{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/pretty/mod.rs\n// crate name is ryu\nuse self::exponent::{write_exponent2, write_exponent3};\nuse self::mantissa::{write_mantissa, write_mantissa_long};\nuse crate::common;\nuse crate::d2s::{self, d2d, DOUBLE_EXPONENT_BITS, DOUBLE_MANTISSA_BITS};\nuse crate::f2s::{f2d, FLOAT_EXPONENT_BITS, FLOAT_MANTISSA_BITS};\nuse core::ptr;\n#[cfg(feature = \"no-panic\")]\nuse no_panic::no_panic;\npub struct FloatingDecimal64 {\n    pub mantissa: u64,\n    pub exponent: i32,\n}\n#[must_use]\n#[cfg_attr(feature = \"no-panic\", no_panic)]\npub unsafe fn format64(f: f64, result: *mut u8) -> usize {\n    let bits = f.to_bits();\n    let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;\n    let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);\n    let ieee_exponent = (bits >> DOUBLE_MANTISSA_BITS) as u32\n        & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);\n    let mut index = 0isize;\n    if sign {\n        *result = b'-';\n        index += 1;\n    }\n    if ieee_exponent == 0 && ieee_mantissa == 0 {\n        ptr::copy_nonoverlapping(b\"0.0\".as_ptr(), result.offset(index), 3);\n        return sign as usize + 3;\n    }\n    let v = d2d(ieee_mantissa, ieee_exponent);\n    let length = d2s::decimal_length17(v.mantissa) as isize;\n    let k = v.exponent as isize;\n    let kk = length + k;\n    debug_assert!(k >= - 324);\n    if 0 <= k && kk <= 16 {\n        write_mantissa_long(v.mantissa, result.offset(index + length));\n        for i in length..kk {\n            *result.offset(index + i) = b'0';\n        }\n        *result.offset(index + kk) = b'.';\n        *result.offset(index + kk + 1) = b'0';\n        index as usize + kk as usize + 2\n    } else if 0 < kk && kk <= 16 {\n        write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n        ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n        *result.offset(index + kk) = b'.';\n        index as usize + length as usize + 1\n    } else if -5 < kk && kk <= 0 {\n        *result.offset(index) = b'0';\n        *result.offset(index + 1) = b'.';\n        let offset = 2 - kk;\n        for i in 2..offset {\n            *result.offset(index + i) = b'0';\n        }\n        write_mantissa_long(v.mantissa, result.offset(index + length + offset));\n        index as usize + length as usize + offset as usize\n    } else if length == 1 {\n        *result.offset(index) = b'0' + v.mantissa as u8;\n        *result.offset(index + 1) = b'e';\n        index as usize + 2 + write_exponent3(kk - 1, result.offset(index + 2))\n    } else {\n        write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n        *result.offset(index) = *result.offset(index + 1);\n        *result.offset(index + 1) = b'.';\n        *result.offset(index + length + 1) = b'e';\n        index as usize + length as usize + 2\n            + write_exponent3(kk - 1, result.offset(index + length + 2))\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub unsafe fn write_mantissa_long(mut output: u64, mut result: *mut u8) {\n    if (output >> 32) != 0 {\n        let mut output2 = (output - 100_000_000 * (output / 100_000_000)) as u32;\n        output /= 100_000_000;\n        let c = output2 % 10_000;\n        output2 /= 10_000;\n        let d = output2 % 10_000;\n        let c0 = (c % 100) << 1;\n        let c1 = (c / 100) << 1;\n        let d0 = (d % 100) << 1;\n        let d1 = (d / 100) << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c0 as isize),\n            result.offset(-2),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c1 as isize),\n            result.offset(-4),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(d0 as isize),\n            result.offset(-6),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(d1 as isize),\n            result.offset(-8),\n            2,\n        );\n        result = result.offset(-8);\n    }\n    write_mantissa(output as u32, result);\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn decimal_length17(v: u64) -> u32 {\n    debug_assert!(v < 100000000000000000);\n    if v >= 10000000000000000 {\n        17\n    } else if v >= 1000000000000000 {\n        16\n    } else if v >= 100000000000000 {\n        15\n    } else if v >= 10000000000000 {\n        14\n    } else if v >= 1000000000000 {\n        13\n    } else if v >= 100000000000 {\n        12\n    } else if v >= 10000000000 {\n        11\n    } else if v >= 1000000000 {\n        10\n    } else if v >= 100000000 {\n        9\n    } else if v >= 10000000 {\n        8\n    } else if v >= 1000000 {\n        7\n    } else if v >= 100000 {\n        6\n    } else if v >= 10000 {\n        5\n    } else if v >= 1000 {\n        4\n    } else if v >= 100 {\n        3\n    } else if v >= 10 {\n        2\n    } else {\n        1\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub unsafe fn write_exponent3(mut k: isize, mut result: *mut u8) -> usize {\n    let sign = k < 0;\n    if sign {\n        *result = b'-';\n        result = result.offset(1);\n        k = -k;\n    }\n    debug_assert!(k < 1000);\n    if k >= 100 {\n        *result = b'0' + (k / 100) as u8;\n        k %= 100;\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result.offset(1), 2);\n        sign as usize + 3\n    } else if k >= 10 {\n        let d = DIGIT_TABLE.as_ptr().offset(k * 2);\n        ptr::copy_nonoverlapping(d, result, 2);\n        sign as usize + 2\n    } else {\n        *result = b'0' + k as u8;\n        sign as usize + 1\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64 {\n    let (e2, m2) = if ieee_exponent == 0 {\n        (1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2, ieee_mantissa)\n    } else {\n        (\n            ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n    let mv = 4 * m2;\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    let mut vr: u64;\n    let mut vp: u64;\n    let mut vm: u64;\n    let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    if e2 >= 0 {\n        let q = log10_pow2(e2) - (e2 > 3) as u32;\n        e10 = q as i32;\n        let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_inv_pow5(q),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n                    DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n                },\n                i as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 21 {\n            let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n            if mv_mod5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n            } else if accept_bounds {\n                vm_is_trailing_zeros = multiple_of_power_of_5(\n                    mv - 1 - mm_shift as u64,\n                    q,\n                );\n            } else {\n                vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n            }\n        }\n    } else {\n        let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n        let j = q as i32 - k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_pow5(i as u32),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n                    DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n                },\n                j as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 1 {\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                vp -= 1;\n            }\n        } else if q < 63 {\n            vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n        }\n    }\n    let mut removed = 0i32;\n    let mut last_removed_digit = 0u8;\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            vm_is_trailing_zeros &= vm_mod10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = vr_mod10 as u8;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            loop {\n                let vm_div10 = div10(vm);\n                let vm_mod10 = (vm as u32)\n                    .wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n                if vm_mod10 != 0 {\n                    break;\n                }\n                let vp_div10 = div10(vp);\n                let vr_div10 = div10(vr);\n                let vr_mod10 = (vr as u32)\n                    .wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = vr_mod10 as u8;\n                vr = vr_div10;\n                vp = vp_div10;\n                vm = vm_div10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            last_removed_digit = 4;\n        }\n        vr\n            + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros))\n                || last_removed_digit >= 5) as u64\n    } else {\n        let mut round_up = false;\n        let vp_div100 = div100(vp);\n        let vm_div100 = div100(vm);\n        if vp_div100 > vm_div100 {\n            let vr_div100 = div100(vr);\n            let vr_mod100 = (vr as u32)\n                .wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n            round_up = vr_mod100 >= 50;\n            vr = vr_div100;\n            vp = vp_div100;\n            vm = vm_div100;\n            removed += 2;\n        }\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            round_up = vr_mod10 >= 5;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        vr + (vr == vm || round_up) as u64\n    };\n    let exp = e10 + removed;\n    FloatingDecimal64 {\n        exponent: exp,\n        mantissa: output,\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Print f64 to the given buffer and return number of bytes written.\n///\n/// At most 24 bytes will be written.\n///\n/// ## Special cases\n///\n/// This function **does not** check for NaN or infinity. If the input\n/// number is not a finite float, the printed representation will be some\n/// correctly formatted but unspecified numerical value.\n///\n/// Please check [`is_finite`] yourself before calling this function, or\n/// check [`is_nan`] and [`is_infinite`] and handle those cases yourself.\n///\n/// [`is_finite`]: f64::is_finite\n/// [`is_nan`]: f64::is_nan\n/// [`is_infinite`]: f64::is_infinite\n///\n/// ## Safety\n///\n/// The `result` pointer argument must point to sufficiently many writable bytes\n/// to hold Ryū's representation of `f`.\n///\n/// ## Example\n///\n/// ```\n/// use std::{mem::MaybeUninit, slice, str};\n///\n/// let f = 1.234f64;\n///\n/// unsafe {\n///     let mut buffer = [MaybeUninit::<u8>::uninit(); 24];\n///     let len = ryu::raw::format64(f, buffer.as_mut_ptr() as *mut u8);\n///     let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, len);\n///     let print = str::from_utf8_unchecked(slice);\n///     assert_eq!(print, \"1.234\");\n/// }\n/// ```\n 52 pub unsafe fn format64(f: f64, result: *mut u8) -> usize {\n 53     let bits = f.to_bits();\n 54     let sign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;\n 55     let ieee_mantissa = bits & ((1u64 << DOUBLE_MANTISSA_BITS) - 1);\n 56     let ieee_exponent =\n 57         (bits >> DOUBLE_MANTISSA_BITS) as u32 & ((1u32 << DOUBLE_EXPONENT_BITS) - 1);\n 58 \n 59     let mut index = 0isize;\n 60     if sign {\n 61         *result = b'-';\n 62         index += 1;\n 63     }\n 64 \n 65     if ieee_exponent == 0 && ieee_mantissa == 0 {\n 66         ptr::copy_nonoverlapping(b\"0.0\".as_ptr(), result.offset(index), 3);\n 67         return sign as usize + 3;\n 68     }\n 69 \n 70     let v = d2d(ieee_mantissa, ieee_exponent);\n 71 \n 72     let length = d2s::decimal_length17(v.mantissa) as isize;\n 73     let k = v.exponent as isize;\n 74     let kk = length + k; // 10^(kk-1) <= v < 10^kk\n 75     debug_assert!(k >= -324);\n 76 \n 77     if 0 <= k && kk <= 16 {\n 78         // 1234e7 -> 12340000000.0\n 79         write_mantissa_long(v.mantissa, result.offset(index + length));\n 80         for i in length..kk {\n 81             *result.offset(index + i) = b'0';\n 82         }\n 83         *result.offset(index + kk) = b'.';\n 84         *result.offset(index + kk + 1) = b'0';\n 85         index as usize + kk as usize + 2\n 86     } else if 0 < kk && kk <= 16 {\n 87         // 1234e-2 -> 12.34\n 88         write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n 89         ptr::copy(result.offset(index + 1), result.offset(index), kk as usize);\n 90         *result.offset(index + kk) = b'.';\n 91         index as usize + length as usize + 1\n 92     } else if -5 < kk && kk <= 0 {\n 93         // 1234e-6 -> 0.001234\n 94         *result.offset(index) = b'0';\n 95         *result.offset(index + 1) = b'.';\n 96         let offset = 2 - kk;\n 97         for i in 2..offset {\n 98             *result.offset(index + i) = b'0';\n 99         }\n100         write_mantissa_long(v.mantissa, result.offset(index + length + offset));\n101         index as usize + length as usize + offset as usize\n102     } else if length == 1 {\n103         // 1e30\n104         *result.offset(index) = b'0' + v.mantissa as u8;\n105         *result.offset(index + 1) = b'e';\n106         index as usize + 2 + write_exponent3(kk - 1, result.offset(index + 2))\n107     } else {\n108         // 1234e30 -> 1.234e33\n109         write_mantissa_long(v.mantissa, result.offset(index + length + 1));\n110         *result.offset(index) = *result.offset(index + 1);\n111         *result.offset(index + 1) = b'.';\n112         *result.offset(index + length + 1) = b'e';\n113         index as usize\n114             + length as usize\n115             + 2\n116             + write_exponent3(kk - 1, result.offset(index + length + 2))\n117     }\n118 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}