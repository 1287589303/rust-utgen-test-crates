{
  "name": "ryu::pretty::mantissa::write_mantissa_long",
  "mod_info": {
    "name": "pretty::mantissa",
    "loc": "src/pretty/mod.rs:2:1:2:14"
  },
  "visible": true,
  "loc": "src/pretty/mantissa.rs:5:1:41:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: (output >> 32) != 0 at line 6 is true\n"
      ],
      "input_infer": "output: any u64 value in the range [1_000_000_000, 18_446_744_073_709_551_615] (inclusive)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let output: u64 = 18_446_744_073_709_551_615;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "}"
              ],
              "oracle": [
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(28), result.offset(-2), 2);",
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(86), result.offset(-4), 2);",
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(14), result.offset(-6), 2);",
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(34), result.offset(-8), 2);",
                "    assert_eq!(result, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b'5']);"
              ],
              "code": [
                "{",
                "    let output: u64 = 18_446_744_073_709_551_615;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(28), result.offset(-2), 2);",
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(86), result.offset(-4), 2);",
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(14), result.offset(-6), 2);",
                "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(34), result.offset(-8), 2);",
                "    assert_eq!(result, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b'5']);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let output: u64 = 1_000_000_000;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result[18], DIGIT_TABLE[(1_000_000_000 % 10_000 * 100) as usize]);",
                "    assert_eq!(result[16], DIGIT_TABLE[((1_000_000_000 / 10_000) % 10_000 * 100) as usize]);",
                "    assert_eq!(result[14], DIGIT_TABLE[((1_000_000_000 / 100_000_000) % 100) as usize * 2]);",
                "    assert_eq!(result[12], DIGIT_TABLE[((1_000_000_000 / 100_000_000 / 100) as usize * 2)]);",
                "    assert_eq!(result[10], b'0' + (1_000_000_000 / 100_000_000) as u8);",
                "    assert_eq!(result[9], 0);",
                "    assert_eq!(result[8], 0);",
                "    assert_eq!(result[7], 0);",
                "    assert_eq!(result[6], 0);",
                "    assert_eq!(result[5], 0);",
                "    assert_eq!(result[4], 0);",
                "    assert_eq!(result[3], 0);",
                "    assert_eq!(result[2], 0);",
                "    assert_eq!(result[1], 0);",
                "    assert_eq!(result[0], 0);"
              ],
              "code": [
                "{",
                "    let output: u64 = 1_000_000_000;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "    assert_eq!(result[18], DIGIT_TABLE[(1_000_000_000 % 10_000 * 100) as usize]);",
                "    assert_eq!(result[16], DIGIT_TABLE[((1_000_000_000 / 10_000) % 10_000 * 100) as usize]);",
                "    assert_eq!(result[14], DIGIT_TABLE[((1_000_000_000 / 100_000_000) % 100) as usize * 2]);",
                "    assert_eq!(result[12], DIGIT_TABLE[((1_000_000_000 / 100_000_000 / 100) as usize * 2)]);",
                "    assert_eq!(result[10], b'0' + (1_000_000_000 / 100_000_000) as u8);",
                "    assert_eq!(result[9], 0);",
                "    assert_eq!(result[8], 0);",
                "    assert_eq!(result[7], 0);",
                "    assert_eq!(result[6], 0);",
                "    assert_eq!(result[5], 0);",
                "    assert_eq!(result[4], 0);",
                "    assert_eq!(result[3], 0);",
                "    assert_eq!(result[2], 0);",
                "    assert_eq!(result[1], 0);",
                "    assert_eq!(result[0], 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let output: u64 = 10_000_000_000;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "}"
              ],
              "oracle": [
                "    let expected_result = [b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];",
                "    assert_eq!(&result, &expected_result);"
              ],
              "code": [
                "{",
                "    let output: u64 = 10_000_000_000;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "    let expected_result = [b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];",
                "    assert_eq!(&result, &expected_result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let output: u64 = 9_765_432_100;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result[18], DIGIT_TABLE[((output / 100_000_000) % 100) << 1] as u8);",
                "    assert_eq!(result[17], DIGIT_TABLE[((output / 100_000_000) / 100) << 1] as u8);",
                "    assert_eq!(result[16], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) / 10_000) % 100) << 1] as u8);",
                "    assert_eq!(result[15], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) / 10_000) / 100) << 1] as u8);",
                "    assert_eq!(result[14], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) % 10_000) / 100) << 1] as u8);",
                "    assert_eq!(result[13], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) % 10_000) % 100) << 1] as u8);"
              ],
              "code": [
                "{",
                "   let output: usize = 9_765_432_100 as usize;",
                "   let mut result = [0u8; 20];",
                "   unsafe {",
                "       write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "   }",
                "  assert_eq!(result[18], DIGIT_TABLE[((output / 100_000_000) % 100) << 1] as u8);",
                "  assert_eq!(result[17], DIGIT_TABLE[((output / 100_000_000) / 100) << 1] as u8);",
                "  assert_eq!(result[16], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) / 10_000) % 100) << 1)] as u8);",
                "  assert_eq!(result[15], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) / 10_000) / 100) << 1)] as u8);",
                "  assert_eq!(result[14], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) % 10_000) / 100) << 1)] as u8);",
                "  assert_eq!(result[13], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) % 10_000) % 100) << 1)] as u8);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let output: u64 = 1_000_000_001;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "}"
              ],
              "oracle": [
                "    result[17] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 % 100) << 1];",
                "    result[15] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 / 100) << 1];",
                "    result[13] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) % 100) << 1];",
                "    result[11] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) / 100) << 1];",
                "    result[9] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 % 100) << 1];",
                "    result[7] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 / 100) << 1];",
                "    result[5] == DIGIT_TABLE[((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000];",
                "    result[4] == '0' + (1_000_000_001 as u32 / 100_000_000) as u8;"
              ],
              "code": [
                "{",
                "    let output: u64 = 1_000_000_001;",
                "    let mut result = [0u8; 20];",
                "    unsafe {",
                "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
                "    }",
                "    result[17] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 % 100) << 1];",
                "    result[15] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 / 100) << 1];",
                "    result[13] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) % 100) << 1];",
                "    result[11] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) / 100) << 1];",
                "    result[9] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 % 100) << 1];",
                "    result[7] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 / 100) << 1];",
                "    result[5] == DIGIT_TABLE[((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000];",
                "    result[4] == '0' + (1_000_000_001 as u32 / 100_000_000) as u8;",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: (output >> 32) != 0 at line 6 is false\n"
      ],
      "input_infer": "output = 0 to 4,294,967,295 (where (output >> 32) == 0) and result as a valid pointer to a u8 array\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut result = [0u8; 10];",
                "    unsafe {",
                "        write_mantissa_long(0, result.as_mut_ptr().offset(10)); ",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);"
              ],
              "code": [
                "{",
                "    let mut result = [0u8; 10];",
                "    unsafe {",
                "        write_mantissa_long(0, result.as_mut_ptr().offset(10)); ",
                "    }",
                "    assert_eq!(result, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut result = [0u8; 10];",
                "    unsafe {",
                "        write_mantissa_long(42, result.as_mut_ptr().offset(10)); ",
                "    }",
                "}"
              ],
              "oracle": [
                "    * assert_eq!(unsafe { &result[8..] }, &[b'4', b'2', 0, 0, 0, 0, 0, 0, 0, 0]);",
                "    * assert_eq!(result[0], 0);",
                "    * assert_eq!(result[1], 0);",
                "    * assert_eq!(result[2], 0);",
                "    * assert_eq!(result[3], 0);",
                "    * assert_eq!(result[4], 0);",
                "    * assert_eq!(result[5], 0);",
                "    * assert_eq!(result[6], 0);",
                "    * assert_eq!(result[7], 0);"
              ],
              "code": [
                "{",
                "   let mut result = [0u8; 10];  ",
                "   unsafe {  ",
                "       write_mantissa_long(42, result.as_mut_ptr().offset(10));  ",
                "   }  ",
                "   assert_eq!(unsafe { &result[8..] }, &[b'4', b'2', 0, 0, 0, 0, 0, 0, 0, 0]);  ",
                "   assert_eq!(result[0], 0);  ",
                "   assert_eq!(result[1], 0);  ",
                "   assert_eq!(result[2], 0);  ",
                "   assert_eq!(result[3], 0);  ",
                "   assert_eq!(result[4], 0);  ",
                "   assert_eq!(result[5], 0);  ",
                "   assert_eq!(result[6], 0);  ",
                "   assert_eq!(result[7], 0);  ",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut result = [0u8; 10];",
                "    unsafe {",
                "        write_mantissa_long(4_294_967_295, result.as_mut_ptr().offset(10)); ",
                "    }",
                "}"
              ],
              "oracle": [
                "    result[8..10].copy_from_slice(&DIGIT_TABLE[98..100]);",
                "    result[6..8].copy_from_slice(&DIGIT_TABLE[42..44]);",
                "    result[4..6].copy_from_slice(&DIGIT_TABLE[42..44]);",
                "    result[2..4].copy_from_slice(&DIGIT_TABLE[42..44]);",
                "    result[0] = b'0';"
              ],
              "code": [
                "{",
                "    let mut result = [0u8; 10];",
                "    unsafe {",
                "        write_mantissa_long(4_294_967_295, result.as_mut_ptr().offset(10)); ",
                "    }",
                "    result[8..10].copy_from_slice(&DIGIT_TABLE[98..100]);",
                "    result[6..8].copy_from_slice(&DIGIT_TABLE[42..44]);",
                "    result[4..6].copy_from_slice(&DIGIT_TABLE[42..44]);",
                "    result[2..4].copy_from_slice(&DIGIT_TABLE[42..44]);",
                "    result[0] = b'0';",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}