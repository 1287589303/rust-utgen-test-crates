[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = u32::max_value();       // Maximum value for m",
          "    let factor: u64 = 1;                  // Minimal factor to ensure overflow",
          "    let shift: i32 = 33;                  // Minimal shift greater than 32",
          "",
          "    let _ = mul_shift_32(m, factor, shift); // Call to the function to trigger the condition",
          "}"
        ],
        "oracle": [
          "    assert!(shift > 32, \"Precondition failed: shift must be greater than 32.\");",
          "    let expected_result = u32::max_value(); // result must be equal to or less than u32::max_value()",
          "    assert!(_ > expected_result, \"Precondition failed: shifted_sum must be greater than u32::max_value() as u64.\");"
        ],
        "code": [
          "{",
          "    let m: u32 = u32::max_value();       // Maximum value for m",
          "    let factor: u64 = 1;                  // Minimal factor to ensure overflow",
          "    let shift: i32 = 33;                  // Minimal shift greater than 32",
          "",
          "    let _ = mul_shift_32(m, factor, shift); // Call to the function to trigger the condition",
          "    assert!(shift > 32, \"Precondition failed: shift must be greater than 32.\");",
          "    let expected_result = u32::max_value(); // result must be equal to or less than u32::max_value()",
          "    assert!(_ > expected_result, \"Precondition failed: shifted_sum must be greater than u32::max_value() as u64.\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 2;                       // Small m to observe overflow with a large factor",
          "    let factor: u64 = u64::max_value();   // Maximum value for factor",
          "    let shift: i32 = 34;                  // Shift set to ensure condition exceeds max value",
          "",
          "    let _ = mul_shift_32(m, factor, shift); // Call to the function to trigger the condition",
          "}"
        ],
        "oracle": [
          "    assert!(mul_shift_32(2, u64::max_value(), 34) > u32::max_value());"
        ],
        "code": [
          "{",
          "    let m: u32 = 2;                       // Small m to observe overflow with a large factor",
          "    let factor: u64 = u64::max_value();   // Maximum value for factor",
          "    let shift: i32 = 34;                  // Shift set to ensure condition exceeds max value",
          "",
          "    let _ = mul_shift_32(m, factor, shift); // Call to the function to trigger the condition",
          "    assert!(mul_shift_32(2, u64::max_value(), 34) > u32::max_value());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 1_000_000;               // Some mid-range value for m",
          "    let factor: u64 = 10_000_000;         // A large factor to ensure shifted_sum exceeds limits",
          "    let shift: i32 = 35;                  // Shift value ensures high overflow",
          "    ",
          "    let _ = mul_shift_32(m, factor, shift); // Call to the function to trigger the condition",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| mul_shift_32(1_000_000, 10_000_000, 35)).is_err());",
          "    assert_eq!(mul_shift_32(1_000_000, 10_000_000, 35) as u64, u32::max_value() as u64 + 1);"
        ],
        "code": [
          "{",
          "    let m: u32 = 1_000_000;               // Some mid-range value for m",
          "    let factor: u64 = 10_000_000;         // A large factor to ensure shifted_sum exceeds limits",
          "    let shift: i32 = 35;                  // Shift value ensures high overflow",
          "    ",
          "    let _ = mul_shift_32(m, factor, shift); // Call to the function to trigger the condition",
          "    assert!(std::panic::catch_unwind(|| mul_shift_32(1_000_000, 10_000_000, 35)).is_err());",
          "    assert_eq!(mul_shift_32(1_000_000, 10_000_000, 35) as u64, u32::max_value() as u64 + 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]