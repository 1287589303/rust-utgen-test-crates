[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let output: u64 = 18_446_744_073_709_551_615;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "}"
        ],
        "oracle": [
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(28), result.offset(-2), 2);",
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(86), result.offset(-4), 2);",
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(14), result.offset(-6), 2);",
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(34), result.offset(-8), 2);",
          "    assert_eq!(result, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b'5']);"
        ],
        "code": [
          "{",
          "    let output: u64 = 18_446_744_073_709_551_615;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(28), result.offset(-2), 2);",
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(86), result.offset(-4), 2);",
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(14), result.offset(-6), 2);",
          "    ptr::copy_nonoverlapping(DIGIT_TABLE.as_ptr().offset(34), result.offset(-8), 2);",
          "    assert_eq!(result, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b'5']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let output: u64 = 1_000_000_000;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result[18], DIGIT_TABLE[(1_000_000_000 % 10_000 * 100) as usize]);",
          "    assert_eq!(result[16], DIGIT_TABLE[((1_000_000_000 / 10_000) % 10_000 * 100) as usize]);",
          "    assert_eq!(result[14], DIGIT_TABLE[((1_000_000_000 / 100_000_000) % 100) as usize * 2]);",
          "    assert_eq!(result[12], DIGIT_TABLE[((1_000_000_000 / 100_000_000 / 100) as usize * 2)]);",
          "    assert_eq!(result[10], b'0' + (1_000_000_000 / 100_000_000) as u8);",
          "    assert_eq!(result[9], 0);",
          "    assert_eq!(result[8], 0);",
          "    assert_eq!(result[7], 0);",
          "    assert_eq!(result[6], 0);",
          "    assert_eq!(result[5], 0);",
          "    assert_eq!(result[4], 0);",
          "    assert_eq!(result[3], 0);",
          "    assert_eq!(result[2], 0);",
          "    assert_eq!(result[1], 0);",
          "    assert_eq!(result[0], 0);"
        ],
        "code": [
          "{",
          "    let output: u64 = 1_000_000_000;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "    assert_eq!(result[18], DIGIT_TABLE[(1_000_000_000 % 10_000 * 100) as usize]);",
          "    assert_eq!(result[16], DIGIT_TABLE[((1_000_000_000 / 10_000) % 10_000 * 100) as usize]);",
          "    assert_eq!(result[14], DIGIT_TABLE[((1_000_000_000 / 100_000_000) % 100) as usize * 2]);",
          "    assert_eq!(result[12], DIGIT_TABLE[((1_000_000_000 / 100_000_000 / 100) as usize * 2)]);",
          "    assert_eq!(result[10], b'0' + (1_000_000_000 / 100_000_000) as u8);",
          "    assert_eq!(result[9], 0);",
          "    assert_eq!(result[8], 0);",
          "    assert_eq!(result[7], 0);",
          "    assert_eq!(result[6], 0);",
          "    assert_eq!(result[5], 0);",
          "    assert_eq!(result[4], 0);",
          "    assert_eq!(result[3], 0);",
          "    assert_eq!(result[2], 0);",
          "    assert_eq!(result[1], 0);",
          "    assert_eq!(result[0], 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let output: u64 = 10_000_000_000;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "}"
        ],
        "oracle": [
          "    let expected_result = [b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];",
          "    assert_eq!(&result, &expected_result);"
        ],
        "code": [
          "{",
          "    let output: u64 = 10_000_000_000;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "    let expected_result = [b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];",
          "    assert_eq!(&result, &expected_result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let output: u64 = 9_765_432_100;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result[18], DIGIT_TABLE[((output / 100_000_000) % 100) << 1] as u8);",
          "    assert_eq!(result[17], DIGIT_TABLE[((output / 100_000_000) / 100) << 1] as u8);",
          "    assert_eq!(result[16], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) / 10_000) % 100) << 1] as u8);",
          "    assert_eq!(result[15], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) / 10_000) / 100) << 1] as u8);",
          "    assert_eq!(result[14], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) % 10_000) / 100) << 1] as u8);",
          "    assert_eq!(result[13], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) % 10_000) % 100) << 1] as u8);"
        ],
        "code": [
          "{",
          "    let output: u64 = 9_765_432_100;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "    assert_eq!(result[18], DIGIT_TABLE[((output / 100_000_000) % 100) << 1] as u8);",
          "    assert_eq!(result[17], DIGIT_TABLE[((output / 100_000_000) / 100) << 1] as u8);",
          "    assert_eq!(result[16], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) / 10_000) % 100) << 1] as u8);",
          "    assert_eq!(result[15], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) / 10_000) / 100) << 1] as u8);",
          "    assert_eq!(result[14], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) % 10_000) / 100) << 1] as u8);",
          "    assert_eq!(result[13], DIGIT_TABLE[((((output - 100_000_000 * (output / 100_000_000)) as u32) % 10_000) % 100) << 1] as u8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let output: u64 = 1_000_000_001;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "}"
        ],
        "oracle": [
          "    result[17] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 % 100) << 1];",
          "    result[15] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 / 100) << 1];",
          "    result[13] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) % 100) << 1];",
          "    result[11] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) / 100) << 1];",
          "    result[9] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 % 100) << 1];",
          "    result[7] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 / 100) << 1];",
          "    result[5] == DIGIT_TABLE[((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000];",
          "    result[4] == '0' + (1_000_000_001 as u32 / 100_000_000) as u8;"
        ],
        "code": [
          "{",
          "    let output: u64 = 1_000_000_001;",
          "    let mut result = [0u8; 20];",
          "    unsafe {",
          "        write_mantissa_long(output, result.as_mut_ptr().add(19));",
          "    }",
          "    result[17] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 % 100) << 1];",
          "    result[15] == DIGIT_TABLE[((1_000_000_001 / 100_000_000) % 10_000 / 100) << 1];",
          "    result[13] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) % 100) << 1];",
          "    result[11] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) % 10_000) / 100) << 1];",
          "    result[9] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 % 100) << 1];",
          "    result[7] == DIGIT_TABLE[(((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000) % 10_000 / 100) << 1];",
          "    result[5] == DIGIT_TABLE[((1_000_000_001 - 100_000_000 * (1_000_000_001 / 100_000_000)) / 10_000) / 10_000];",
          "    result[4] == '0' + (1_000_000_001 as u32 / 100_000_000) as u8;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]