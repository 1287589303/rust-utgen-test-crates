[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            false",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = 1e38; // large positive float",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.bytes.len(), 24);",
          "    assert!(unsafe { FloatValue.write_to_ryu_buffer(buffer.bytes.as_mut_ptr() as *mut u8) } > buffer.bytes.len());",
          "    assert!(buffer.format_finite(FloatValue).contains(\"inf\"));",
          "    assert!(buffer.format_finite(FloatValue).len() > buffer.bytes.len());",
          "    assert!(buffer.format_finite(FloatValue).starts_with(\"1e\"));"
        ],
        "code": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            false",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = 1e38; // large positive float",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "    assert_eq!(buffer.bytes.len(), 24);",
          "    assert!(unsafe { FloatValue.write_to_ryu_buffer(buffer.bytes.as_mut_ptr() as *mut u8) } > buffer.bytes.len());",
          "    assert!(buffer.format_finite(FloatValue).contains(\"inf\"));",
          "    assert!(buffer.format_finite(FloatValue).len() > buffer.bytes.len());",
          "    assert!(buffer.format_finite(FloatValue).starts_with(\"1e\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            false",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = -1e38; // large negative float",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.bytes.iter().all(|&byte| byte.as_ptr() == core::ptr::null()), false);",
          "    assert!(buffer.format_finite(FloatValue).len() <= 24);",
          "    assert_eq!(buffer.format_finite(FloatValue), \"-1e+38\");",
          "    assert_ne!(buffer.bytes[0].assume_init(), 0);"
        ],
        "code": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            false",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = -1e38; // large negative float",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "    assert_eq!(buffer.bytes.iter().all(|&byte| byte.as_ptr() == core::ptr::null()), false);",
          "    assert!(buffer.format_finite(FloatValue).len() <= 24);",
          "    assert_eq!(buffer.format_finite(FloatValue), \"-1e+38\");",
          "    assert_ne!(buffer.bytes[0].assume_init(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            true",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"NaN\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = f64::NAN; // NaN",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.bytes.len(), 24);",
          "    assert!(buffer.format_finite(FloatValue).contains(\"NaN\") == false);",
          "    assert!(buffer.format_finite(FloatValue).is_empty() == false);",
          "    assert!(core::mem::size_of_val(&buffer.bytes) == 24);",
          "    assert!(buffer.format_finite(FloatValue).len() > 0);"
        ],
        "code": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            true",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"NaN\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = f64::NAN; // NaN",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "    assert_eq!(buffer.bytes.len(), 24);",
          "    assert!(buffer.format_finite(FloatValue).contains(\"NaN\") == false);",
          "    assert!(buffer.format_finite(FloatValue).is_empty() == false);",
          "    assert!(core::mem::size_of_val(&buffer.bytes) == 24);",
          "    assert!(buffer.format_finite(FloatValue).len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            true",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"inf\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = f64::INFINITY; // Infinity",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "}"
        ],
        "oracle": [
          "    assert!(buffer.bytes.len() >= 8);",
          "    assert_eq!(buffer.format_finite(FloatValue), \"inf\");",
          "    assert!(buffer.bytes.iter().all(|&b| b.as_ptr() != core::ptr::null_mut()));",
          "    assert!(unsafe { buffer.bytes.as_ptr() as *const u8 != core::ptr::null() });",
          "    assert!(buffer.format_finite(FloatValue).as_ptr() != core::ptr::null());",
          "    assert!(buffer.format_finite(FloatValue).len() <= buffer.bytes.len());",
          "    assert_eq!(buffer.bytes[0].assume_init(), b'i');",
          "    assert_eq!(buffer.bytes[1].assume_init(), b'n');",
          "    assert_eq!(buffer.bytes[2].assume_init(), b'f');",
          "    assert_eq!(buffer.bytes[3].assume_init(), b'in');",
          "    assert_eq!(buffer.bytes[4].assume_init(), b'i');",
          "    assert_eq!(buffer.bytes[5].assume_init(), b't');",
          "    assert_eq!(buffer.bytes[6].assume_init(), b'y');",
          "    assert_eq!(buffer.bytes[7].assume_init(), b'\\0');"
        ],
        "code": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            true",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"inf\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = f64::INFINITY; // Infinity",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "    assert!(buffer.bytes.len() >= 8);",
          "    assert_eq!(buffer.format_finite(FloatValue), \"inf\");",
          "    assert!(buffer.bytes.iter().all(|&b| b.as_ptr() != core::ptr::null_mut()));",
          "    assert!(unsafe { buffer.bytes.as_ptr() as *const u8 != core::ptr::null() });",
          "    assert!(buffer.format_finite(FloatValue).as_ptr() != core::ptr::null());",
          "    assert!(buffer.format_finite(FloatValue).len() <= buffer.bytes.len());",
          "    assert_eq!(buffer.bytes[0].assume_init(), b'i');",
          "    assert_eq!(buffer.bytes[1].assume_init(), b'n');",
          "    assert_eq!(buffer.bytes[2].assume_init(), b'f');",
          "    assert_eq!(buffer.bytes[3].assume_init(), b'in');",
          "    assert_eq!(buffer.bytes[4].assume_init(), b'i');",
          "    assert_eq!(buffer.bytes[5].assume_init(), b't');",
          "    assert_eq!(buffer.bytes[6].assume_init(), b'y');",
          "    assert_eq!(buffer.bytes[7].assume_init(), b'\\0');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            true",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"-inf\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = f64::NEG_INFINITY; // Negative Infinity",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.bytes.len(), 24);",
          "    assert!(std::slice::from_raw_parts(buffer.bytes.as_ptr() as *const u8, 24).iter().all(|&b| b == 0));",
          "    assert!(buffer.format_finite(FloatValue).contains(\"-inf\"));",
          "    assert!(buffer.format_finite(FloatValue).len() <= 24);",
          "    assert_ne!(buffer.format_finite(FloatValue).as_ptr(), core::ptr::null());",
          "    assert!(buffer.format_finite(FloatValue).is_ascii());"
        ],
        "code": [
          "{",
          "    struct FloatValue;",
          "",
          "    impl Copy for FloatValue {}",
          "",
          "    impl Sealed for FloatValue {",
          "        fn is_nonfinite(self) -> bool {",
          "            true",
          "        }",
          "",
          "        fn format_nonfinite(self) -> &'static str {",
          "            \"-inf\"",
          "        }",
          "",
          "        unsafe fn write_to_ryu_buffer(self, result: *mut u8) -> usize {",
          "            let value: f64 = f64::NEG_INFINITY; // Negative Infinity",
          "            let formatted = format!(\"{}\", value);",
          "            let bytes = formatted.as_bytes();",
          "            core::ptr::copy_nonoverlapping(bytes.as_ptr(), result, bytes.len());",
          "            bytes.len()",
          "        }",
          "    }",
          "",
          "    let mut buffer = Buffer::new();",
          "    let _ = buffer.format_finite(FloatValue);",
          "    assert_eq!(buffer.bytes.len(), 24);",
          "    assert!(std::slice::from_raw_parts(buffer.bytes.as_ptr() as *const u8, 24).iter().all(|&b| b == 0));",
          "    assert!(buffer.format_finite(FloatValue).contains(\"-inf\"));",
          "    assert!(buffer.format_finite(FloatValue).len() <= 24);",
          "    assert_ne!(buffer.format_finite(FloatValue).as_ptr(), core::ptr::null());",
          "    assert!(buffer.format_finite(FloatValue).is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]