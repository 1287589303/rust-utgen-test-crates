{
  "name": "ryu::buffer::{impl#7}::write_to_ryu_buffer",
  "mod_info": {
    "name": "buffer",
    "loc": "src/lib.rs:106:1:106:12"
  },
  "visible": true,
  "loc": "src/buffer/mod.rs:168:5:170:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Test input conditions or ranges: f64 values including normal numbers, zero, subnormal numbers, NaN, positive and negative infinity, covering the range from -1.7976931348623157e308 to 1.7976931348623157e308, with attention to edge cases like -0.0, 0.0, and special values like NaN and infinities.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = 123.456;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    let value: f64 = 123.456;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, expected_size);",
                "    assert_eq!(str::from_utf8(&result[0..size]).unwrap(), \"123.456\");",
                "    ",
                "    let nan_value: f64 = f64::NAN;",
                "    let mut nan_result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let nan_size = unsafe { nan_value.write_to_ryu_buffer(nan_result.as_mut_ptr()) };",
                "    assert_eq!(nan_size, expected_nan_size);",
                "    assert_eq!(str::from_utf8(&nan_result[0..nan_size]).unwrap(), \"NaN\");",
                "    ",
                "    let inf_value: f64 = f64::INFINITY;",
                "    let mut inf_result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let inf_size = unsafe { inf_value.write_to_ryu_buffer(inf_result.as_mut_ptr()) };",
                "    assert_eq!(inf_size, expected_inf_size);",
                "    assert_eq!(str::from_utf8(&inf_result[0..inf_size]).unwrap(), \"inf\");",
                "    ",
                "    let neg_inf_value: f64 = f64::NEG_INFINITY;",
                "    let mut neg_inf_result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let neg_inf_size = unsafe { neg_inf_value.write_to_ryu_buffer(neg_inf_result.as_mut_ptr()) };",
                "    assert_eq!(neg_inf_size, expected_neg_inf_size);",
                "    assert_eq!(str::from_utf8(&neg_inf_result[0..neg_inf_size]).unwrap(), \"-inf\");"
              ],
              "code": [
                "{",
                "    let value: f64 = 123.456;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    let value: f64 = 123.456;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, expected_size);",
                "    assert_eq!(str::from_utf8(&result[0..size]).unwrap(), \"123.456\");",
                "    ",
                "    let nan_value: f64 = f64::NAN;",
                "    let mut nan_result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let nan_size = unsafe { nan_value.write_to_ryu_buffer(nan_result.as_mut_ptr()) };",
                "    assert_eq!(nan_size, expected_nan_size);",
                "    assert_eq!(str::from_utf8(&nan_result[0..nan_size]).unwrap(), \"NaN\");",
                "    ",
                "    let inf_value: f64 = f64::INFINITY;",
                "    let mut inf_result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let inf_size = unsafe { inf_value.write_to_ryu_buffer(inf_result.as_mut_ptr()) };",
                "    assert_eq!(inf_size, expected_inf_size);",
                "    assert_eq!(str::from_utf8(&inf_result[0..inf_size]).unwrap(), \"inf\");",
                "    ",
                "    let neg_inf_value: f64 = f64::NEG_INFINITY;",
                "    let mut neg_inf_result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let neg_inf_size = unsafe { neg_inf_value.write_to_ryu_buffer(neg_inf_result.as_mut_ptr()) };",
                "    assert_eq!(neg_inf_size, expected_neg_inf_size);",
                "    assert_eq!(str::from_utf8(&neg_inf_result[0..neg_inf_size]).unwrap(), \"-inf\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = 0.0;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    assert_eq!(size, 4);",
                "    assert_eq!(&result[..size], b\"0.0\");",
                "    let value: f64 = f64::INFINITY;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(&result[..size], b\"inf\");",
                "    let value: f64 = f64::NEG_INFINITY;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 4);",
                "    assert_eq!(&result[..size], b\"-inf\");",
                "    let value: f64 = f64::NAN;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(&result[..size], b\"NaN\");",
                "    let value: f64 = 1.23e4;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 6);",
                "    assert_eq!(&result[..size], b\"12300\");",
                "    let value: f64 = -1.23e-4;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 8);",
                "    assert_eq!(&result[..size], b\"-0.000123\");"
              ],
              "code": [
                "{",
                "    let value: f64 = 0.0;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 4);",
                "    assert_eq!(&result[..size], b\"0.0\");",
                "    let value: f64 = f64::INFINITY;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(&result[..size], b\"inf\");",
                "    let value: f64 = f64::NEG_INFINITY;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 4);",
                "    assert_eq!(&result[..size], b\"-inf\");",
                "    let value: f64 = f64::NAN;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(&result[..size], b\"NaN\");",
                "    let value: f64 = 1.23e4;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 6);",
                "    assert_eq!(&result[..size], b\"12300\");",
                "    let value: f64 = -1.23e-4;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 8);",
                "    assert_eq!(&result[..size], b\"-0.000123\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = -0.0;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    assert_eq!(size, 4);",
                "    assert_eq!(&result[..size], b\"0.0\");",
                "    assert_eq!(result[size], 0);"
              ],
              "code": [
                "{",
                "    let value: f64 = -0.0;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 4);",
                "    assert_eq!(&result[..size], b\"0.0\");",
                "    assert_eq!(result[size], 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = 1e-300;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    assert_eq!(size, 1);",
                "    assert_eq!(result[0], b'0');",
                "    assert_eq!(result[1], b'.');",
                "    assert_eq!(result[2], b'0');",
                "    assert_eq!(result[3], b'0');",
                "    assert_eq!(result[4], b'0');",
                "    assert_eq!(result[5], b'0');",
                "    assert_eq!(result[6], b'0');",
                "    assert_eq!(result[7], b'0');",
                "    assert_eq!(result[8], b'0');",
                "    assert_eq!(result[9], b'0');",
                "    assert_eq!(result[10], b'0');",
                "    assert_eq!(result[11], b'0');",
                "    assert_eq!(result[12], b'0');",
                "    assert_eq!(result[13], b'0');",
                "    assert_eq!(result[14], b'0');",
                "    assert_eq!(result[15], b'0');",
                "    assert_eq!(result[16], b'0');",
                "    assert_eq!(result[17], b'0');",
                "    assert_eq!(result[18], b'0');",
                "    assert_eq!(result[19], b'0');",
                "    assert_eq!(result[20], b'0');",
                "    assert_eq!(result[21], b'0');",
                "    assert_eq!(result[22], b'0');",
                "    assert_eq!(result[23], b'0');",
                "    assert_eq!(result[24], b'0');",
                "    assert_eq!(result[25], b'0');",
                "    assert_eq!(result[26], b'0');",
                "    assert_eq!(result[27], b'0');",
                "    assert_eq!(result[28], b'0');",
                "    assert_eq!(result[29], b'0');",
                "    assert_eq!(result[30], b'0');",
                "    assert_eq!(result[31], b'\\0');"
              ],
              "code": [
                "{",
                "    let value: f64 = 1e-300;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 1);",
                "    assert_eq!(result[0], b'0');",
                "    assert_eq!(result[1], b'.');",
                "    assert_eq!(result[2], b'0');",
                "    assert_eq!(result[3], b'0');",
                "    assert_eq!(result[4], b'0');",
                "    assert_eq!(result[5], b'0');",
                "    assert_eq!(result[6], b'0');",
                "    assert_eq!(result[7], b'0');",
                "    assert_eq!(result[8], b'0');",
                "    assert_eq!(result[9], b'0');",
                "    assert_eq!(result[10], b'0');",
                "    assert_eq!(result[11], b'0');",
                "    assert_eq!(result[12], b'0');",
                "    assert_eq!(result[13], b'0');",
                "    assert_eq!(result[14], b'0');",
                "    assert_eq!(result[15], b'0');",
                "    assert_eq!(result[16], b'0');",
                "    assert_eq!(result[17], b'0');",
                "    assert_eq!(result[18], b'0');",
                "    assert_eq!(result[19], b'0');",
                "    assert_eq!(result[20], b'0');",
                "    assert_eq!(result[21], b'0');",
                "    assert_eq!(result[22], b'0');",
                "    assert_eq!(result[23], b'0');",
                "    assert_eq!(result[24], b'0');",
                "    assert_eq!(result[25], b'0');",
                "    assert_eq!(result[26], b'0');",
                "    assert_eq!(result[27], b'0');",
                "    assert_eq!(result[28], b'0');",
                "    assert_eq!(result[29], b'0');",
                "    assert_eq!(result[30], b'0');",
                "    assert_eq!(result[31], b'\\0');",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = f64::INFINITY;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    let value: f64 = f64::INFINITY;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"inf\");",
                "    ",
                "    let value: f64 = f64::NEG_INFINITY;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 4);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"-inf\");",
                "    ",
                "    let value: f64 = f64::NAN;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"NaN\");",
                "    ",
                "    let value: f64 = 0.0;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"0.0\");",
                "    ",
                "    let value: f64 = 1.2345;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert!(size > 0);",
                "    assert!(unsafe { str::from_utf8_unchecked(&result[..size]) }.contains('.'));",
                "    ",
                "    let value: f64 = -1.2345;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert!(size > 0);",
                "    assert!(unsafe { str::from_utf8_unchecked(&result[..size]) }.contains('-'));"
              ],
              "code": [
                "{",
                "    let value: f64 = f64::INFINITY;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    let value: f64 = f64::INFINITY;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"inf\");",
                "    ",
                "    let value: f64 = f64::NEG_INFINITY;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 4);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"-inf\");",
                "    ",
                "    let value: f64 = f64::NAN;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"NaN\");",
                "    ",
                "    let value: f64 = 0.0;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(unsafe { str::from_utf8_unchecked(&result[..size]) }, \"0.0\");",
                "    ",
                "    let value: f64 = 1.2345;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert!(size > 0);",
                "    assert!(unsafe { str::from_utf8_unchecked(&result[..size]) }.contains('.'));",
                "    ",
                "    let value: f64 = -1.2345;",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert!(size > 0);",
                "    assert!(unsafe { str::from_utf8_unchecked(&result[..size]) }.contains('-'));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = f64::NEG_INFINITY;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    assert_eq!(size, 3);",
                "    assert_eq!(&result[..size], b\"-inf\");"
              ],
              "code": [
                "{",
                "    let value: f64 = f64::NEG_INFINITY;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(&result[..size], b\"-inf\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = f64::NAN;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    assert_eq!(size, 3);",
                "    assert_eq!(result[0], b'N');",
                "    assert_eq!(result[1], b'a');",
                "    assert_eq!(result[2], b'N');",
                "    assert_eq!(result[3], 0);"
              ],
              "code": [
                "{",
                "    let value: f64 = f64::NAN;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 3);",
                "    assert_eq!(result[0], b'N');",
                "    assert_eq!(result[1], b'a');",
                "    assert_eq!(result[2], b'N');",
                "    assert_eq!(result[3], 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = 1.7976931348623157e308;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    assert_eq!(size, expected_size_for_large_float);",
                "    assert_eq!(&result[..size as usize], expected_output_for_large_float);",
                "    assert_eq!(result[size as usize], 0);",
                "    assert!(value.is_finite());",
                "    ",
                "    let value_inf: f64 = f64::INFINITY;",
                "    let size_inf = unsafe { value_inf.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size_inf, expected_size_for_infinity);",
                "    assert_eq!(&result[..size_inf as usize], expected_output_for_infinity);",
                "    assert_eq!(result[size_inf as usize], 0);",
                "    ",
                "    let value_neg_inf: f64 = f64::NEG_INFINITY;",
                "    let size_neg_inf = unsafe { value_neg_inf.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size_neg_inf, expected_size_for_neg_infinity);",
                "    assert_eq!(&result[..size_neg_inf as usize], expected_output_for_neg_infinity);",
                "    assert_eq!(result[size_neg_inf as usize], 0);",
                "    ",
                "    let value_nan: f64 = f64::NAN;",
                "    let size_nan = unsafe { value_nan.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size_nan, expected_size_for_nan);",
                "    assert_eq!(&result[..size_nan as usize], expected_output_for_nan);",
                "    assert_eq!(result[size_nan as usize], 0);"
              ],
              "code": [
                "{",
                "    let value: f64 = 1.7976931348623157e308;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, expected_size_for_large_float);",
                "    assert_eq!(&result[..size as usize], expected_output_for_large_float);",
                "    assert_eq!(result[size as usize], 0);",
                "    assert!(value.is_finite());",
                "    ",
                "    let value_inf: f64 = f64::INFINITY;",
                "    let size_inf = unsafe { value_inf.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size_inf, expected_size_for_infinity);",
                "    assert_eq!(&result[..size_inf as usize], expected_output_for_infinity);",
                "    assert_eq!(result[size_inf as usize], 0);",
                "    ",
                "    let value_neg_inf: f64 = f64::NEG_INFINITY;",
                "    let size_neg_inf = unsafe { value_neg_inf.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size_neg_inf, expected_size_for_neg_infinity);",
                "    assert_eq!(&result[..size_neg_inf as usize], expected_output_for_neg_infinity);",
                "    assert_eq!(result[size_neg_inf as usize], 0);",
                "    ",
                "    let value_nan: f64 = f64::NAN;",
                "    let size_nan = unsafe { value_nan.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size_nan, expected_size_for_nan);",
                "    assert_eq!(&result[..size_nan as usize], expected_output_for_nan);",
                "    assert_eq!(result[size_nan as usize], 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: f64 = -1.7976931348623157e308;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "}"
              ],
              "oracle": [
                "    assert_eq!(size, 32);",
                "    assert_eq!(result, b\"-1.7976931348623157e+308\\0\");"
              ],
              "code": [
                "{",
                "    let value: f64 = -1.7976931348623157e308;",
                "    let mut result: [u8; 32] = unsafe { MaybeUninit::uninit().assume_init() };",
                "    let size = unsafe { value.write_to_ryu_buffer(result.as_mut_ptr()) };",
                "    assert_eq!(size, 32);",
                "    assert_eq!(result, b\"-1.7976931348623157e+308\\0\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}