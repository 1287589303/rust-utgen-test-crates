{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/d2s.rs\n// crate name is ryu\nuse crate::common::{log10_pow2, log10_pow5, pow5bits};\n#[cfg(not(feature = \"small\"))]\npub use crate::d2s_full_table::{DOUBLE_POW5_INV_SPLIT, DOUBLE_POW5_SPLIT};\nuse crate::d2s_intrinsics::{\n    div10, div100, div5, mul_shift_all_64, multiple_of_power_of_2, multiple_of_power_of_5,\n};\n#[cfg(feature = \"small\")]\npub use crate::d2s_small_table::{compute_inv_pow5, compute_pow5};\nuse core::mem::MaybeUninit;\npub const DOUBLE_MANTISSA_BITS: u32 = 52;\npub const DOUBLE_EXPONENT_BITS: u32 = 11;\npub const DOUBLE_BIAS: i32 = 1023;\npub const DOUBLE_POW5_INV_BITCOUNT: i32 = 125;\npub const DOUBLE_POW5_BITCOUNT: i32 = 125;\npub struct FloatingDecimal64 {\n    pub mantissa: u64,\n    pub exponent: i32,\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64 {\n    let (e2, m2) = if ieee_exponent == 0 {\n        (1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2, ieee_mantissa)\n    } else {\n        (\n            ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n    let mv = 4 * m2;\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    let mut vr: u64;\n    let mut vp: u64;\n    let mut vm: u64;\n    let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    if e2 >= 0 {\n        let q = log10_pow2(e2) - (e2 > 3) as u32;\n        e10 = q as i32;\n        let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_inv_pow5(q),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n                    DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n                },\n                i as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 21 {\n            let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n            if mv_mod5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n            } else if accept_bounds {\n                vm_is_trailing_zeros = multiple_of_power_of_5(\n                    mv - 1 - mm_shift as u64,\n                    q,\n                );\n            } else {\n                vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n            }\n        }\n    } else {\n        let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n        let j = q as i32 - k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_pow5(i as u32),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n                    DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n                },\n                j as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 1 {\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                vp -= 1;\n            }\n        } else if q < 63 {\n            vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n        }\n    }\n    let mut removed = 0i32;\n    let mut last_removed_digit = 0u8;\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            vm_is_trailing_zeros &= vm_mod10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = vr_mod10 as u8;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            loop {\n                let vm_div10 = div10(vm);\n                let vm_mod10 = (vm as u32)\n                    .wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n                if vm_mod10 != 0 {\n                    break;\n                }\n                let vp_div10 = div10(vp);\n                let vr_div10 = div10(vr);\n                let vr_mod10 = (vr as u32)\n                    .wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = vr_mod10 as u8;\n                vr = vr_div10;\n                vp = vp_div10;\n                vm = vm_div10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            last_removed_digit = 4;\n        }\n        vr\n            + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros))\n                || last_removed_digit >= 5) as u64\n    } else {\n        let mut round_up = false;\n        let vp_div100 = div100(vp);\n        let vm_div100 = div100(vm);\n        if vp_div100 > vm_div100 {\n            let vr_div100 = div100(vr);\n            let vr_mod100 = (vr as u32)\n                .wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n            round_up = vr_mod100 >= 50;\n            vr = vr_div100;\n            vp = vp_div100;\n            vm = vm_div100;\n            removed += 2;\n        }\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            round_up = vr_mod10 >= 5;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        vr + (vr == vm || round_up) as u64\n    };\n    let exp = e10 + removed;\n    FloatingDecimal64 {\n        exponent: exp,\n        mantissa: output,\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub unsafe fn mul_shift_all_64(\n    m: u64,\n    mul: &(u64, u64),\n    j: u32,\n    vp: *mut u64,\n    vm: *mut u64,\n    mm_shift: u32,\n) -> u64 {\n    ptr::write(vp, mul_shift_64(4 * m + 2, mul, j));\n    ptr::write(vm, mul_shift_64(4 * m - 1 - mm_shift as u64, mul, j));\n    mul_shift_64(4 * m, mul, j)\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn div100(x: u64) -> u64 {\n    x / 100\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn div5(x: u64) -> u64 {\n    x / 5\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn multiple_of_power_of_2(value: u64, p: u32) -> bool {\n    debug_assert!(value != 0);\n    debug_assert!(p < 64);\n    (value & ((1u64 << p) - 1)) == 0\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn multiple_of_power_of_5(value: u64, p: u32) -> bool {\n    pow5_factor(value) >= p\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn div10(x: u64) -> u64 {\n    x / 10\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn pow5bits(e: i32) -> i32 {\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 3528);\n    (((e as u32 * 1217359) >> 19) + 1) as i32\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn log10_pow2(e: i32) -> u32 {\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 1650);\n    (e as u32 * 78913) >> 18\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn log10_pow5(e: i32) -> u32 {\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 2620);\n    (e as u32 * 732923) >> 20\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n 91 pub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64 {\n 92     let (e2, m2) = if ieee_exponent == 0 {\n 93         (\n 94             // We subtract 2 so that the bounds computation has 2 additional bits.\n 95             1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n 96             ieee_mantissa,\n 97         )\n 98     } else {\n 99         (\n100             ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n101             (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n102         )\n103     };\n104     let even = (m2 & 1) == 0;\n105     let accept_bounds = even;\n106 \n107     // Step 2: Determine the interval of valid decimal representations.\n108     let mv = 4 * m2;\n109     // Implicit bool -> int conversion. True is 1, false is 0.\n110     let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n111     // We would compute mp and mm like this:\n112     // uint64_t mp = 4 * m2 + 2;\n113     // uint64_t mm = mv - 1 - mm_shift;\n114 \n115     // Step 3: Convert to a decimal power base using 128-bit arithmetic.\n116     let mut vr: u64;\n117     let mut vp: u64;\n118     let mut vm: u64;\n119     let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n120     let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n121     let e10: i32;\n122     let mut vm_is_trailing_zeros = false;\n123     let mut vr_is_trailing_zeros = false;\n124     if e2 >= 0 {\n125         // I tried special-casing q == 0, but there was no effect on performance.\n126         // This expression is slightly faster than max(0, log10_pow2(e2) - 1).\n127         let q = log10_pow2(e2) - (e2 > 3) as u32;\n128         e10 = q as i32;\n129         let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n130         let i = -e2 + q as i32 + k;\n131         vr = unsafe {\n132             mul_shift_all_64(\n133                 m2,\n134                 #[cfg(feature = \"small\")]\n135                 &compute_inv_pow5(q),\n136                 #[cfg(not(feature = \"small\"))]\n137                 {\n138                     debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n139                     DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n140                 },\n141                 i as u32,\n142                 vp_uninit.as_mut_ptr(),\n143                 vm_uninit.as_mut_ptr(),\n144                 mm_shift,\n145             )\n146         };\n147         vp = unsafe { vp_uninit.assume_init() };\n148         vm = unsafe { vm_uninit.assume_init() };\n149         if q <= 21 {\n150             // This should use q <= 22, but I think 21 is also safe. Smaller values\n151             // may still be safe, but it's more difficult to reason about them.\n152             // Only one of mp, mv, and mm can be a multiple of 5, if any.\n153             let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n154             if mv_mod5 == 0 {\n155                 vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n156             } else if accept_bounds {\n157                 // Same as min(e2 + (~mm & 1), pow5_factor(mm)) >= q\n158                 // <=> e2 + (~mm & 1) >= q && pow5_factor(mm) >= q\n159                 // <=> true && pow5_factor(mm) >= q, since e2 >= q.\n160                 vm_is_trailing_zeros = multiple_of_power_of_5(mv - 1 - mm_shift as u64, q);\n161             } else {\n162                 // Same as min(e2 + 1, pow5_factor(mp)) >= q.\n163                 vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n164             }\n165         }\n166     } else {\n167         // This expression is slightly faster than max(0, log10_pow5(-e2) - 1).\n168         let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n169         e10 = q as i32 + e2;\n170         let i = -e2 - q as i32;\n171         let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n172         let j = q as i32 - k;\n173         vr = unsafe {\n174             mul_shift_all_64(\n175                 m2,\n176                 #[cfg(feature = \"small\")]\n177                 &compute_pow5(i as u32),\n178                 #[cfg(not(feature = \"small\"))]\n179                 {\n180                     debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n181                     DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n182                 },\n183                 j as u32,\n184                 vp_uninit.as_mut_ptr(),\n185                 vm_uninit.as_mut_ptr(),\n186                 mm_shift,\n187             )\n188         };\n189         vp = unsafe { vp_uninit.assume_init() };\n190         vm = unsafe { vm_uninit.assume_init() };\n191         if q <= 1 {\n192             // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n193             // mv = 4 * m2, so it always has at least two trailing 0 bits.\n194             vr_is_trailing_zeros = true;\n195             if accept_bounds {\n196                 // mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit iff mm_shift == 1.\n197                 vm_is_trailing_zeros = mm_shift == 1;\n198             } else {\n199                 // mp = mv + 2, so it always has at least one trailing 0 bit.\n200                 vp -= 1;\n201             }\n202         } else if q < 63 {\n203             // TODO(ulfjack): Use a tighter bound here.\n204             // We want to know if the full product has at least q trailing zeros.\n205             // We need to compute min(p2(mv), p5(mv) - e2) >= q\n206             // <=> p2(mv) >= q && p5(mv) - e2 >= q\n207             // <=> p2(mv) >= q (because -e2 >= q)\n208             vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n209         }\n210     }\n211 \n212     // Step 4: Find the shortest decimal representation in the interval of valid representations.\n213     let mut removed = 0i32;\n214     let mut last_removed_digit = 0u8;\n215     // On average, we remove ~2 digits.\n216     let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n217         // General case, which happens rarely (~0.7%).\n218         loop {\n219             let vp_div10 = div10(vp);\n220             let vm_div10 = div10(vm);\n221             if vp_div10 <= vm_div10 {\n222                 break;\n223             }\n224             let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n225             let vr_div10 = div10(vr);\n226             let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n227             vm_is_trailing_zeros &= vm_mod10 == 0;\n228             vr_is_trailing_zeros &= last_removed_digit == 0;\n229             last_removed_digit = vr_mod10 as u8;\n230             vr = vr_div10;\n231             vp = vp_div10;\n232             vm = vm_div10;\n233             removed += 1;\n234         }\n235         if vm_is_trailing_zeros {\n236             loop {\n237                 let vm_div10 = div10(vm);\n238                 let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n239                 if vm_mod10 != 0 {\n240                     break;\n241                 }\n242                 let vp_div10 = div10(vp);\n243                 let vr_div10 = div10(vr);\n244                 let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n245                 vr_is_trailing_zeros &= last_removed_digit == 0;\n246                 last_removed_digit = vr_mod10 as u8;\n247                 vr = vr_div10;\n248                 vp = vp_div10;\n249                 vm = vm_div10;\n250                 removed += 1;\n251             }\n252         }\n253         if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n254             // Round even if the exact number is .....50..0.\n255             last_removed_digit = 4;\n256         }\n257         // We need to take vr + 1 if vr is outside bounds or we need to round up.\n258         vr + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5)\n259             as u64\n260     } else {\n261         // Specialized for the common case (~99.3%). Percentages below are relative to this.\n262         let mut round_up = false;\n263         let vp_div100 = div100(vp);\n264         let vm_div100 = div100(vm);\n265         // Optimization: remove two digits at a time (~86.2%).\n266         if vp_div100 > vm_div100 {\n267             let vr_div100 = div100(vr);\n268             let vr_mod100 = (vr as u32).wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n269             round_up = vr_mod100 >= 50;\n270             vr = vr_div100;\n271             vp = vp_div100;\n272             vm = vm_div100;\n273             removed += 2;\n274         }\n275         // Loop iterations below (approximately), without optimization above:\n276         // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n277         // Loop iterations below (approximately), with optimization above:\n278         // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n279         loop {\n280             let vp_div10 = div10(vp);\n281             let vm_div10 = div10(vm);\n282             if vp_div10 <= vm_div10 {\n283                 break;\n284             }\n285             let vr_div10 = div10(vr);\n286             let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n287             round_up = vr_mod10 >= 5;\n288             vr = vr_div10;\n289             vp = vp_div10;\n290             vm = vm_div10;\n291             removed += 1;\n292         }\n293         // We need to take vr + 1 if vr is outside bounds or we need to round up.\n294         vr + (vr == vm || round_up) as u64\n295     };\n296     let exp = e10 + removed;\n297 \n298     FloatingDecimal64 {\n299         exponent: exp,\n300         mantissa: output,\n301     }\n302 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}