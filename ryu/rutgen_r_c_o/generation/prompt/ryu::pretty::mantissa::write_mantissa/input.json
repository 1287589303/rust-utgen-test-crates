{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/pretty/mantissa.rs\n// crate name is ryu\nuse crate::digit_table::DIGIT_TABLE;\nuse core::ptr;\n#[cfg_attr(feature = \"no-panic\", inline)]\npub unsafe fn write_mantissa(mut output: u32, mut result: *mut u8) {\n    while output >= 10_000 {\n        let c = output - 10_000 * (output / 10_000);\n        output /= 10_000;\n        let c0 = (c % 100) << 1;\n        let c1 = (c / 100) << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c0 as isize),\n            result.offset(-2),\n            2,\n        );\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c1 as isize),\n            result.offset(-4),\n            2,\n        );\n        result = result.offset(-4);\n    }\n    if output >= 100 {\n        let c = (output % 100) << 1;\n        output /= 100;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n        result = result.offset(-2);\n    }\n    if output >= 10 {\n        let c = output << 1;\n        ptr::copy_nonoverlapping(\n            DIGIT_TABLE.as_ptr().offset(c as isize),\n            result.offset(-2),\n            2,\n        );\n    } else {\n        *result.offset(-1) = b'0' + output as u8;\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n44 pub unsafe fn write_mantissa(mut output: u32, mut result: *mut u8) {\n45     while output >= 10_000 {\n46         let c = output - 10_000 * (output / 10_000);\n47         output /= 10_000;\n48         let c0 = (c % 100) << 1;\n49         let c1 = (c / 100) << 1;\n50         ptr::copy_nonoverlapping(\n51             DIGIT_TABLE.as_ptr().offset(c0 as isize),\n52             result.offset(-2),\n53             2,\n54         );\n55         ptr::copy_nonoverlapping(\n56             DIGIT_TABLE.as_ptr().offset(c1 as isize),\n57             result.offset(-4),\n58             2,\n59         );\n60         result = result.offset(-4);\n61     }\n62     if output >= 100 {\n63         let c = (output % 100) << 1;\n64         output /= 100;\n65         ptr::copy_nonoverlapping(\n66             DIGIT_TABLE.as_ptr().offset(c as isize),\n67             result.offset(-2),\n68             2,\n69         );\n70         result = result.offset(-2);\n71     }\n72     if output >= 10 {\n73         let c = output << 1;\n74         ptr::copy_nonoverlapping(\n75             DIGIT_TABLE.as_ptr().offset(c as isize),\n76             result.offset(-2),\n77             2,\n78         );\n79     } else {\n80         *result.offset(-1) = b'0' + output as u8;\n81     }\n82 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}