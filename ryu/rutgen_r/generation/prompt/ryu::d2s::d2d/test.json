{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/d2s.rs\n// crate name is ryu\nThe function to be tested is presented with each line formatted as 'line number + code':\n 91 pub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64 {\n 92     let (e2, m2) = if ieee_exponent == 0 {\n 93         (\n 94             // We subtract 2 so that the bounds computation has 2 additional bits.\n 95             1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n 96             ieee_mantissa,\n 97         )\n 98     } else {\n 99         (\n100             ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n101             (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n102         )\n103     };\n104     let even = (m2 & 1) == 0;\n105     let accept_bounds = even;\n106 \n107     // Step 2: Determine the interval of valid decimal representations.\n108     let mv = 4 * m2;\n109     // Implicit bool -> int conversion. True is 1, false is 0.\n110     let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n111     // We would compute mp and mm like this:\n112     // uint64_t mp = 4 * m2 + 2;\n113     // uint64_t mm = mv - 1 - mm_shift;\n114 \n115     // Step 3: Convert to a decimal power base using 128-bit arithmetic.\n116     let mut vr: u64;\n117     let mut vp: u64;\n118     let mut vm: u64;\n119     let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n120     let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n121     let e10: i32;\n122     let mut vm_is_trailing_zeros = false;\n123     let mut vr_is_trailing_zeros = false;\n124     if e2 >= 0 {\n125         // I tried special-casing q == 0, but there was no effect on performance.\n126         // This expression is slightly faster than max(0, log10_pow2(e2) - 1).\n127         let q = log10_pow2(e2) - (e2 > 3) as u32;\n128         e10 = q as i32;\n129         let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n130         let i = -e2 + q as i32 + k;\n131         vr = unsafe {\n132             mul_shift_all_64(\n133                 m2,\n134                 #[cfg(feature = \"small\")]\n135                 &compute_inv_pow5(q),\n136                 #[cfg(not(feature = \"small\"))]\n137                 {\n138                     debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n139                     DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n140                 },\n141                 i as u32,\n142                 vp_uninit.as_mut_ptr(),\n143                 vm_uninit.as_mut_ptr(),\n144                 mm_shift,\n145             )\n146         };\n147         vp = unsafe { vp_uninit.assume_init() };\n148         vm = unsafe { vm_uninit.assume_init() };\n149         if q <= 21 {\n150             // This should use q <= 22, but I think 21 is also safe. Smaller values\n151             // may still be safe, but it's more difficult to reason about them.\n152             // Only one of mp, mv, and mm can be a multiple of 5, if any.\n153             let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n154             if mv_mod5 == 0 {\n155                 vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n156             } else if accept_bounds {\n157                 // Same as min(e2 + (~mm & 1), pow5_factor(mm)) >= q\n158                 // <=> e2 + (~mm & 1) >= q && pow5_factor(mm) >= q\n159                 // <=> true && pow5_factor(mm) >= q, since e2 >= q.\n160                 vm_is_trailing_zeros = multiple_of_power_of_5(mv - 1 - mm_shift as u64, q);\n161             } else {\n162                 // Same as min(e2 + 1, pow5_factor(mp)) >= q.\n163                 vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n164             }\n165         }\n166     } else {\n167         // This expression is slightly faster than max(0, log10_pow5(-e2) - 1).\n168         let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n169         e10 = q as i32 + e2;\n170         let i = -e2 - q as i32;\n171         let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n172         let j = q as i32 - k;\n173         vr = unsafe {\n174             mul_shift_all_64(\n175                 m2,\n176                 #[cfg(feature = \"small\")]\n177                 &compute_pow5(i as u32),\n178                 #[cfg(not(feature = \"small\"))]\n179                 {\n180                     debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n181                     DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n182                 },\n183                 j as u32,\n184                 vp_uninit.as_mut_ptr(),\n185                 vm_uninit.as_mut_ptr(),\n186                 mm_shift,\n187             )\n188         };\n189         vp = unsafe { vp_uninit.assume_init() };\n190         vm = unsafe { vm_uninit.assume_init() };\n191         if q <= 1 {\n192             // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n193             // mv = 4 * m2, so it always has at least two trailing 0 bits.\n194             vr_is_trailing_zeros = true;\n195             if accept_bounds {\n196                 // mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit iff mm_shift == 1.\n197                 vm_is_trailing_zeros = mm_shift == 1;\n198             } else {\n199                 // mp = mv + 2, so it always has at least one trailing 0 bit.\n200                 vp -= 1;\n201             }\n202         } else if q < 63 {\n203             // TODO(ulfjack): Use a tighter bound here.\n204             // We want to know if the full product has at least q trailing zeros.\n205             // We need to compute min(p2(mv), p5(mv) - e2) >= q\n206             // <=> p2(mv) >= q && p5(mv) - e2 >= q\n207             // <=> p2(mv) >= q (because -e2 >= q)\n208             vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n209         }\n210     }\n211 \n212     // Step 4: Find the shortest decimal representation in the interval of valid representations.\n213     let mut removed = 0i32;\n214     let mut last_removed_digit = 0u8;\n215     // On average, we remove ~2 digits.\n216     let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n217         // General case, which happens rarely (~0.7%).\n218         loop {\n219             let vp_div10 = div10(vp);\n220             let vm_div10 = div10(vm);\n221             if vp_div10 <= vm_div10 {\n222                 break;\n223             }\n224             let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n225             let vr_div10 = div10(vr);\n226             let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n227             vm_is_trailing_zeros &= vm_mod10 == 0;\n228             vr_is_trailing_zeros &= last_removed_digit == 0;\n229             last_removed_digit = vr_mod10 as u8;\n230             vr = vr_div10;\n231             vp = vp_div10;\n232             vm = vm_div10;\n233             removed += 1;\n234         }\n235         if vm_is_trailing_zeros {\n236             loop {\n237                 let vm_div10 = div10(vm);\n238                 let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n239                 if vm_mod10 != 0 {\n240                     break;\n241                 }\n242                 let vp_div10 = div10(vp);\n243                 let vr_div10 = div10(vr);\n244                 let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n245                 vr_is_trailing_zeros &= last_removed_digit == 0;\n246                 last_removed_digit = vr_mod10 as u8;\n247                 vr = vr_div10;\n248                 vp = vp_div10;\n249                 vm = vm_div10;\n250                 removed += 1;\n251             }\n252         }\n253         if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n254             // Round even if the exact number is .....50..0.\n255             last_removed_digit = 4;\n256         }\n257         // We need to take vr + 1 if vr is outside bounds or we need to round up.\n258         vr + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5)\n259             as u64\n260     } else {\n261         // Specialized for the common case (~99.3%). Percentages below are relative to this.\n262         let mut round_up = false;\n263         let vp_div100 = div100(vp);\n264         let vm_div100 = div100(vm);\n265         // Optimization: remove two digits at a time (~86.2%).\n266         if vp_div100 > vm_div100 {\n267             let vr_div100 = div100(vr);\n268             let vr_mod100 = (vr as u32).wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n269             round_up = vr_mod100 >= 50;\n270             vr = vr_div100;\n271             vp = vp_div100;\n272             vm = vm_div100;\n273             removed += 2;\n274         }\n275         // Loop iterations below (approximately), without optimization above:\n276         // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n277         // Loop iterations below (approximately), with optimization above:\n278         // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n279         loop {\n280             let vp_div10 = div10(vp);\n281             let vm_div10 = div10(vm);\n282             if vp_div10 <= vm_div10 {\n283                 break;\n284             }\n285             let vr_div10 = div10(vr);\n286             let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n287             round_up = vr_mod10 >= 5;\n288             vr = vr_div10;\n289             vp = vp_div10;\n290             vm = vm_div10;\n291             removed += 1;\n292         }\n293         // We need to take vr + 1 if vr is outside bounds or we need to round up.\n294         vr + (vr == vm || round_up) as u64\n295     };\n296     let exp = e10 + removed;\n297 \n298     FloatingDecimal64 {\n299         exponent: exp,\n300         mantissa: output,\n301     }\n302 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}