{
  "name": "ryu::d2s_intrinsics::multiple_of_power_of_2",
  "mod_info": {
    "name": "d2s_intrinsics",
    "loc": "src/lib.rs:111:1:111:20"
  },
  "visible": true,
  "loc": "src/d2s_intrinsics.rs:63:1:68:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: value != 0 at line 64 is true\n",
        "precondition: p < 64 at line 65 is true\n",
        "expected return value/type: (value & ((1u64 << p) - 1)) == 0\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value: u64 = 4; // 100 in binary, which is a multiple of 2^2",
                "    let p: u32 = 2; // p is 2",
                "    assert!(multiple_of_power_of_2(value, p));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value: u64 = 5; // 101 in binary, which is not a multiple of 2^2",
                "    let p: u32 = 2; // p is 2",
                "    assert!(!multiple_of_power_of_2(value, p));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value: u64 = 8; // 1000 in binary, which is a multiple of 2^3",
                "    let p: u32 = 3; // p is 3",
                "    assert!(multiple_of_power_of_2(value, p));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value: u64 = 16; // 10000 in binary, which is a multiple of 2^4",
                "    let p: u32 = 4; // p is 4",
                "    assert!(multiple_of_power_of_2(value, p));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value: u64 = 12; // 1100 in binary, which is a multiple of 2^2 but not of 2^3",
                "    let p: u32 = 3; // p is 3",
                "    assert!(!multiple_of_power_of_2(value, p));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value: u64 = 1 << 62; // 2^62, which is a multiple of 2^62",
                "    let p: u32 = 62; // p is 62",
                "    assert!(multiple_of_power_of_2(value, p));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: value != 0 at line 64 is true\n",
        "precondition: p < 64 at line 65 is false, with bound p == 64\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value = 1; // value is non-zero",
                "    let p = 64; // p is equal to 64, which should panic the debug_assert",
                "    let result = std::panic::catch_unwind(|| {",
                "        multiple_of_power_of_2(value, p);",
                "    });",
                "    assert!(result.is_err()); // We expect a panic due to the debug assertion",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value = 2; // value is non-zero",
                "    let p = 63; // p < 64, following the actual logic",
                "    let result = multiple_of_power_of_2(value, p);",
                "    assert!(result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let value = 3; // value is non-zero",
                "    let p = 1; // p < 64",
                "    let result = multiple_of_power_of_2(value, p);",
                "    assert!(!result);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: value != 0 at line 64 is false\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[should_panic]",
            "fn test_multiple_of_power_of_2_zero_value() {",
            "    let value: u64 = 0; // This will trigger the debug assertion `value != 0`",
            "    let p: u32 = 5;",
            "    multiple_of_power_of_2(value, p);",
            "}",
            "",
            "#[should_panic]",
            "fn test_multiple_of_power_of_2_negative_power() {",
            "    let value: u64 = 8; // This is a valid non-zero value",
            "    let p: u32 = 64; // This will trigger the debug assertion `p < 64`",
            "    multiple_of_power_of_2(value, p);",
            "}"
          ],
          "chain_tests": []
        }
      ]
    }
  ]
}