{
  "name": "bytes::buf::buf_impl::Buf::copy_to_bytes",
  "mod_info": {
    "name": "buf::buf_impl",
    "loc": "src/buf/mod.rs:17:1:17:14"
  },
  "visible": true,
  "loc": "src/buf/buf_impl.rs:2358:5:2371:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.remaining() < len at line 2361 is true\n"
      ],
      "input_infer": "self.remaining() = x, len = y where x < y, and x must be >= 0, y must be > 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() as usize",
                "        }",
                "",
                "        fn take(self, limit: usize) -> Vec<u8> {",
                "            self.data.into_iter().take(limit).collect()",
                "        }",
                "",
                "        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {",
                "            if self.remaining() < len {",
                "                panic_advance(&TryGetError {",
                "                    requested: len,",
                "                    available: self.remaining(),",
                "                });",
                "            }",
                "",
                "            let mut ret = crate::BytesMut::with_capacity(len);",
                "            ret.put(self.take(len));",
                "            ret.freeze()",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![1, 2, 3] };",
                "    let _ = buf.copy_to_bytes(5);",
                "}"
              ],
              "oracle": [
                "    assert_panics!(buf.copy_to_bytes(5), TryGetError { requested: 5, available: 3 });"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() as usize",
                "        }",
                "",
                "        fn take(self, limit: usize) -> Vec<u8> {",
                "            self.data.into_iter().take(limit).collect()",
                "        }",
                "",
                "        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {",
                "            if self.remaining() < len {",
                "                panic_advance(&TryGetError {",
                "                    requested: len,",
                "                    available: self.remaining(),",
                "                });",
                "            }",
                "",
                "            let mut ret = crate::BytesMut::with_capacity(len);",
                "            ret.put(self.take(len));",
                "            ret.freeze()",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![1, 2, 3] };",
                "    let _ = buf.copy_to_bytes(5);",
                "    assert_panics!(buf.copy_to_bytes(5), TryGetError { requested: 5, available: 3 });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() as usize",
                "        }",
                "",
                "        fn take(self, limit: usize) -> Vec<u8> {",
                "            self.data.into_iter().take(limit).collect()",
                "        }",
                "",
                "        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {",
                "            if self.remaining() < len {",
                "                panic_advance(&TryGetError {",
                "                    requested: len,",
                "                    available: self.remaining(),",
                "                });",
                "            }",
                "",
                "            let mut ret = crate::BytesMut::with_capacity(len);",
                "            ret.put(self.take(len));",
                "            ret.freeze()",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![1, 2] };",
                "    let _ = buf.copy_to_bytes(3);",
                "}"
              ],
              "oracle": [
                "    assert_panics!(buf.copy_to_bytes(3), TryGetError { requested: 3, available: 2 });"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() as usize",
                "        }",
                "",
                "        fn take(self, limit: usize) -> Vec<u8> {",
                "            self.data.into_iter().take(limit).collect()",
                "        }",
                "",
                "        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {",
                "            if self.remaining() < len {",
                "                panic_advance(&TryGetError {",
                "                    requested: len,",
                "                    available: self.remaining(),",
                "                });",
                "            }",
                "",
                "            let mut ret = crate::BytesMut::with_capacity(len);",
                "            ret.put(self.take(len));",
                "            ret.freeze()",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![1, 2] };",
                "    let _ = buf.copy_to_bytes(3);",
                "    assert_panics!(buf.copy_to_bytes(3), TryGetError { requested: 3, available: 2 });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() as usize",
                "        }",
                "",
                "        fn take(self, limit: usize) -> Vec<u8> {",
                "            self.data.into_iter().take(limit).collect()",
                "        }",
                "",
                "        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {",
                "            if self.remaining() < len {",
                "                panic_advance(&TryGetError {",
                "                    requested: len,",
                "                    available: self.remaining(),",
                "                });",
                "            }",
                "",
                "            let mut ret = crate::BytesMut::with_capacity(len);",
                "            ret.put(self.take(len));",
                "            ret.freeze()",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![] };",
                "    let _ = buf.copy_to_bytes(1);",
                "}"
              ],
              "oracle": [
                "    panic_advance_called_with(&TryGetError { requested: 1, available: 0 });",
                "    assert_eq!(self.remaining(), 0);",
                "    assert_eq!(buf.data.len(), 0);",
                "    assert!(matches!(std::panic::catch_unwind(|| buf.copy_to_bytes(1)), Err(_)));"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() as usize",
                "        }",
                "",
                "        fn take(self, limit: usize) -> Vec<u8> {",
                "            self.data.into_iter().take(limit).collect()",
                "        }",
                "",
                "        fn copy_to_bytes(&mut self, len: usize) -> crate::Bytes {",
                "            if self.remaining() < len {",
                "                panic_advance(&TryGetError {",
                "                    requested: len,",
                "                    available: self.remaining(),",
                "                });",
                "            }",
                "",
                "            let mut ret = crate::BytesMut::with_capacity(len);",
                "            ret.put(self.take(len));",
                "            ret.freeze()",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![] };",
                "    let _ = buf.copy_to_bytes(1);",
                "    panic_advance_called_with(&TryGetError { requested: 1, available: 0 });",
                "    assert_eq!(self.remaining(), 0);",
                "    assert_eq!(buf.data.len(), 0);",
                "    assert!(matches!(std::panic::catch_unwind(|| buf.copy_to_bytes(1)), Err(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.remaining() < len at line 2361 is false, with bound self.remaining() == len\n"
      ],
      "input_infer": "self.remaining() == len and len > 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(data: Vec<u8>) -> Self {",
                "            TestBuf { data, position: 0 }",
                "        }",
                "",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn take(&mut self, cnt: usize) -> &[u8] {",
                "            let start = self.position;",
                "            self.position += cnt;",
                "            &self.data[start..self.position]",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(vec![1, 2, 3, 4, 5]);",
                "    let len = buf.remaining(); // len will be 5",
                "",
                "    let bytes = buf.copy_to_bytes(len);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining(), 0);",
                "    assert_eq!(&bytes[..], &[1, 2, 3, 4, 5][..]);",
                "    assert!(buf.remaining() == 0);",
                "    assert!(bytes.len() == len);",
                "    assert!(bytes.len() == 5);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(data: Vec<u8>) -> Self {",
                "            TestBuf { data, position: 0 }",
                "        }",
                "",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn take(&mut self, cnt: usize) -> &[u8] {",
                "            let start = self.position;",
                "            self.position += cnt;",
                "            &self.data[start..self.position]",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(vec![1, 2, 3, 4, 5]);",
                "    let len = buf.remaining(); // len will be 5",
                "",
                "    let bytes = buf.copy_to_bytes(len);",
                "    assert_eq!(buf.remaining(), 0);",
                "    assert_eq!(&bytes[..], &[1, 2, 3, 4, 5][..]);",
                "    assert!(buf.remaining() == 0);",
                "    assert!(bytes.len() == len);",
                "    assert!(bytes.len() == 5);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(data: Vec<u8>) -> Self {",
                "            TestBuf { data, position: 0 }",
                "        }",
                "",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn take(&mut self, cnt: usize) -> &[u8] {",
                "            let start = self.position;",
                "            self.position += cnt;",
                "            &self.data[start..self.position]",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(vec![42]);",
                "    let len = buf.remaining(); // len will be 1",
                "",
                "    let bytes = buf.copy_to_bytes(len);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining(), 0);",
                "    assert_eq!(&bytes[..], &[42]);",
                "    assert!(buf.remaining() == 0);",
                "    assert!(buf.position == 1);",
                "    assert!(bytes.len() == 1);",
                "    assert!(buf.copy_to_bytes(1).len() == 1);",
                "    panic_advance(&TryGetError { requested: 2, available: 1 });"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(data: Vec<u8>) -> Self {",
                "            TestBuf { data, position: 0 }",
                "        }",
                "",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn take(&mut self, cnt: usize) -> &[u8] {",
                "            let start = self.position;",
                "            self.position += cnt;",
                "            &self.data[start..self.position]",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(vec![42]);",
                "    let len = buf.remaining(); // len will be 1",
                "",
                "    let bytes = buf.copy_to_bytes(len);",
                "    assert_eq!(buf.remaining(), 0);",
                "    assert_eq!(&bytes[..], &[42]);",
                "    assert!(buf.remaining() == 0);",
                "    assert!(buf.position == 1);",
                "    assert!(bytes.len() == 1);",
                "    assert!(buf.copy_to_bytes(1).len() == 1);",
                "    panic_advance(&TryGetError { requested: 2, available: 1 });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(data: Vec<u8>) -> Self {",
                "            TestBuf { data, position: 0 }",
                "        }",
                "",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn take(&mut self, cnt: usize) -> &[u8] {",
                "            let start = self.position;",
                "            self.position += cnt;",
                "            &self.data[start..self.position]",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(vec![0; 1024]); // 1024 bytes of data",
                "    let len = buf.remaining(); // len will be 1024",
                "",
                "    let bytes = buf.copy_to_bytes(len);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining(), 0);",
                "    assert_eq!(bytes.len(), len);",
                "    assert_eq!(&bytes[..], &buf.take(len)[..]);",
                "    assert!(buf.remaining() == 0);",
                "    assert!(bytes.capacity() >= len);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(data: Vec<u8>) -> Self {",
                "            TestBuf { data, position: 0 }",
                "        }",
                "",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn take(&mut self, cnt: usize) -> &[u8] {",
                "            let start = self.position;",
                "            self.position += cnt;",
                "            &self.data[start..self.position]",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(vec![0; 1024]); // 1024 bytes of data",
                "    let len = buf.remaining(); // len will be 1024",
                "",
                "    let bytes = buf.copy_to_bytes(len);",
                "    assert_eq!(buf.remaining(), 0);",
                "    assert_eq!(bytes.len(), len);",
                "    assert_eq!(&bytes[..], &buf.take(len)[..]);",
                "    assert!(buf.remaining() == 0);",
                "    assert!(bytes.capacity() >= len);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}