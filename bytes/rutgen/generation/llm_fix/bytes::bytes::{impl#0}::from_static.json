{
  "name": "bytes::bytes::{impl#0}::from_static",
  "mod_info": {
    "name": "bytes",
    "loc": "src/lib.rs:82:1:82:11"
  },
  "visible": true,
  "loc": "src/bytes.rs:168:5:175:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Bytes {\n            ptr: bytes.as_ptr(),\n            len: bytes.len(),\n            data: AtomicPtr::new(ptr::null_mut()),\n            vtable: &STATIC_VTABLE,\n        }\n"
      ],
      "input_infer": "test input conditions or ranges: input should be a static byte slice of length 0 to max usize (including empty slice and non-empty slices with various sizes), ensuring valid pointer address and checking against null pointers.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let b = Bytes::from_static(b\"\");",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b.ptr, Bytes::from_static(b\"\").ptr);",
                "    assert_eq!(b.len, Bytes::from_static(b\"\").len);",
                "    assert_eq!(b.data, Bytes::from_static(b\"\").data);",
                "    assert_eq!(b.vtable, Bytes::from_static(b\"\").vtable);"
              ],
              "code": [
                "{",
                "    let b = Bytes::from_static(b\"\");",
                "    assert_eq!(b.ptr, Bytes::from_static(b\"\").ptr);",
                "    assert_eq!(b.len, Bytes::from_static(b\"\").len);",
                "    assert_eq!(b.data, Bytes::from_static(b\"\").data);",
                "    assert_eq!(b.vtable, Bytes::from_static(b\"\").vtable);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let b = Bytes::from_static(b\"a\");",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b.ptr, b\"a\".as_ptr());",
                "    assert_eq!(b.len, 1);",
                "    assert_eq!(b.data, AtomicPtr::new(ptr::null_mut()));",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);"
              ],
              "code": [
                "{",
                "    let b = Bytes::from_static(b\"a\");",
                "    assert_eq!(b.ptr, b\"a\".as_ptr());",
                "    assert_eq!(b.len, 1);",
                "    assert_eq!(b.data, AtomicPtr::new(ptr::null_mut()));",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let b = Bytes::from_static(b\"hello\");",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b.ptr, b\"hello\".as_ptr());",
                "    assert_eq!(b.len, b\"hello\".len());",
                "    assert_eq!(b.data.load(Ordering::SeqCst), ptr::null_mut());",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);"
              ],
              "code": [
                "{",
                "    let b = Bytes::from_static(b\"hello\");",
                "    assert_eq!(b.ptr, b\"hello\".as_ptr());",
                "    assert_eq!(b.len, b\"hello\".len());",
                "    assert_eq!(b.data.load(Ordering::SeqCst), ptr::null_mut());",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let large_slice: &[u8] = &[0; usize::MAX]; // Maximum length in practice can't exceed usize limit.",
                "    let b = Bytes::from_static(large_slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b.ptr, large_slice.as_ptr());",
                "    assert_eq!(b.len, large_slice.len());",
                "    assert_eq!(b.data, AtomicPtr::new(ptr::null_mut()));",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);"
              ],
              "code": [
                "{",
                "    let large_slice: &[u8] = &[0; usize::MAX]; // Maximum length in practice can't exceed usize limit.",
                "    let b = Bytes::from_static(large_slice);",
                "    assert_eq!(b.ptr, large_slice.as_ptr());",
                "    assert_eq!(b.len, large_slice.len());",
                "    assert_eq!(b.data, AtomicPtr::new(ptr::null_mut()));",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let non_empty_slice: &[u8] = b\"rust is fun\";",
                "    let b = Bytes::from_static(non_empty_slice);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b.ptr, non_empty_slice.as_ptr());",
                "    assert_eq!(b.len, non_empty_slice.len());",
                "    assert!(b.data.load(Ordering::SeqCst).is_null());",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);"
              ],
              "code": [
                "{",
                "    let non_empty_slice: &[u8] = b\"rust is fun\";",
                "    let b = Bytes::from_static(non_empty_slice);",
                "    assert_eq!(b.ptr, non_empty_slice.as_ptr());",
                "    assert_eq!(b.len, non_empty_slice.len());",
                "    assert!(b.data.load(Ordering::SeqCst).is_null());",
                "    assert_eq!(b.vtable, &STATIC_VTABLE);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}