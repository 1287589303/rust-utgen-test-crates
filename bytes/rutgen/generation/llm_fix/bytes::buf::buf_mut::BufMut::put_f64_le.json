{
  "name": "bytes::buf::buf_mut::BufMut::put_f64_le",
  "mod_info": {
    "name": "buf::buf_mut",
    "loc": "src/buf/mod.rs:18:1:18:13"
  },
  "visible": true,
  "loc": "src/buf/buf_mut.rs:1239:5:1241:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "remaining capacity must be at least 8 bytes; n must be a valid f64 value for the test scenarios.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
                "    buf.put_f64_le(1.2f64);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
                "    buf.put_f64_le(1.2f64);",
                "    assert!(buf.remaining_mut() == 0);",
                "    buf.put_f64_le(3.14f64);",
                "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\");",
                "    buf.advance_mut(8);",
                "    assert!(buf.remaining_mut() == 0);",
                "    buf.put_f64_le(2.7f64);",
                "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    buf.put_f64_le(0.0f64);",
                "    assert!(buf.remaining_mut() == 0);",
                "    assert!(panic::catch_unwind(|| buf.put_f64_le(1.1)).is_err());",
                "    buf.put_f64_le(f64::MAX);",
                "    assert!(buf.remaining_mut() == 0);"
              ],
              "code": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
                "    buf.put_f64_le(1.2f64);",
                "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
                "    buf.put_f64_le(1.2f64);",
                "    assert!(buf.remaining_mut() == 0);",
                "    buf.put_f64_le(3.14f64);",
                "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\");",
                "    buf.advance_mut(8);",
                "    assert!(buf.remaining_mut() == 0);",
                "    buf.put_f64_le(2.7f64);",
                "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    buf.put_f64_le(0.0f64);",
                "    assert!(buf.remaining_mut() == 0);",
                "    assert!(panic::catch_unwind(|| buf.put_f64_le(1.1)).is_err());",
                "    buf.put_f64_le(f64::MAX);",
                "    assert!(buf.remaining_mut() == 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 16]; // more than 8 bytes",
                "    buf.put_f64_le(1.2f64);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf[0..8], b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
                "    assert_eq!(buf.len(), 16);",
                "    assert!(buf.iter().skip(8).all(|&x| x == 0));"
              ],
              "code": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 16]; // more than 8 bytes",
                "    buf.put_f64_le(1.2f64);",
                "    assert_eq!(buf[0..8], b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
                "    assert_eq!(buf.len(), 16);",
                "    assert!(buf.iter().skip(8).all(|&x| x == 0));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
                "    buf.put_f64_le(0.0f64);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    assert_eq!(buf.remaining_mut(), 0);",
                "    buf.put_f64_le(3.14f64);",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x73\\x20\\x9A\\x99\\x99\\x99\\x3F\");"
              ],
              "code": [
                "   {  ",
                "      use std::vec;  ",
                "      let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes  ",
                "      buf.put_f64_le(0.0f64);  ",
                "      assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");  ",
                "      assert_eq!(buf.remaining_mut(), 0);  ",
                "      buf.put_f64_le(3.14f64);  ",
                "      assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x73\\x20\\x9A\\x99\\x99\\x99\\x3F\");  ",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
                "    buf.put_f64_le(-1.2f64);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf[0..8], b\"\\x9A\\x99\\x99\\x99\\x99\\x99\\xF3\\xBF\");",
                "    assert_eq!(buf.remaining_mut(), 0);",
                "    assert!(buf.has_remaining_mut() == false);"
              ],
              "code": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
                "    buf.put_f64_le(-1.2f64);",
                "    assert_eq!(buf[0..8], b\"\\x9A\\x99\\x99\\x99\\x99\\x99\\xF3\\xBF\");",
                "    assert_eq!(buf.remaining_mut(), 0);",
                "    assert!(buf.has_remaining_mut() == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
                "    buf.put_f64_le(1e100f64);",
                "}"
              ],
              "oracle": [
                "    buf.put_f64_le(1e100f64); // called with large value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF4\\x47\"); // expected little-endian bytes for 1e100",
                "    buf.put_f64_le(-1e100f64); // called with negative large value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xC4\\x47\"); // expected little-endian bytes for -1e100",
                "    buf.put_f64_le(0.0f64); // called with zero value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"); // expected little-endian bytes for 0.0",
                "    buf.put_f64_le(f64::INFINITY); // called with infinity value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"); // expected little-endian bytes for infinity",
                "    buf.put_f64_le(f64::NAN); // called with NaN value",
                "    assert!(buf.is_nan(), \"Buffer should state NaN correctly\"); // validate buffer handles NaN"
              ],
              "code": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
                "    buf.put_f64_le(1e100f64);",
                "    buf.put_f64_le(1e100f64); // called with large value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF4\\x47\"); // expected little-endian bytes for 1e100",
                "    buf.put_f64_le(-1e100f64); // called with negative large value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xC4\\x47\"); // expected little-endian bytes for -1e100",
                "    buf.put_f64_le(0.0f64); // called with zero value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"); // expected little-endian bytes for 0.0",
                "    buf.put_f64_le(f64::INFINITY); // called with infinity value",
                "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"); // expected little-endian bytes for infinity",
                "    buf.put_f64_le(f64::NAN); // called with NaN value",
                "    assert!(buf.is_nan(), \"Buffer should state NaN correctly\"); // validate buffer handles NaN",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 7]; // less than 8 bytes",
                "    buf.put_f64_le(1.2f64);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.len(), 7);",
                "    assert!(buf.remaining_mut() < 8);",
                "    assert!(std::panic::catch_unwind(|| buf.put_f64_le(1.2f64)).is_err());",
                "    assert!(buf.len() == 7);",
                "    assert!(buf == vec![0; 7]);",
                "    assert!(buf.has_remaining_mut() == false);"
              ],
              "code": [
                "{",
                "    let mut buf: Vec<u8> = vec![0; 7]; // less than 8 bytes",
                "    buf.put_f64_le(1.2f64);",
                "    assert_eq!(buf.len(), 7);",
                "    assert!(buf.remaining_mut() < 8);",
                "    assert!(std::panic::catch_unwind(|| buf.put_f64_le(1.2f64)).is_err());",
                "    assert!(buf.len() == 7);",
                "    assert!(buf == vec![0; 7]);",
                "    assert!(buf.has_remaining_mut() == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}