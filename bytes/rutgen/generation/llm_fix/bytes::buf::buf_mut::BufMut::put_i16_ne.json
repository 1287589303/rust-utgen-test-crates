{
  "name": "bytes::buf::buf_mut::BufMut::put_i16_ne",
  "mod_info": {
    "name": "buf::buf_mut",
    "loc": "src/buf/mod.rs:18:1:18:13"
  },
  "visible": true,
  "loc": "src/buf/buf_mut.rs:501:5:503:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "test input conditions or ranges: 1-2 bytes for `self` buffer capacity, `n` values ranging from -32,768 to 32,767 for `i16`, and test cases with buffer capacity exactly equal to, greater than, and less than required for writing 2 bytes with varying values of `n`.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            &mut self.buffer[self.position..self.position + len] as *mut _ as *mut UninitSlice",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let cnt = usize::min(src.len(), self.remaining_mut());",
                "            unsafe { self.chunk_mut().copy_from_slice(&src[..cnt]) };",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "",
                "        fn put_i16_ne(&mut self, n: i16) {",
                "            self.put_slice(&n.to_ne_bytes())",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf {",
                "        buffer: vec![0; 1],",
                "        position: 0,",
                "    };",
                "    buf.put_i16_ne(0x0809);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.buffer, b\"\\x09\\x08\");",
                "    assert_eq!(buf.position, 2);",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let mut buf_small = TestBuf { buffer: vec![0; 1], position: 0 };",
                "    buf_small.put_i16_ne(0x0809);",
                "    }).is_err());",
                "    let mut buf_capacity = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf_capacity.put_i16_ne(-1);",
                "    assert_eq!(buf_capacity.buffer, b\"\\xff\\xff\");",
                "    buf_capacity.put_i16_ne(0x7fff);",
                "    assert_eq!(buf_capacity.buffer, b\"\\xff\\xff\\x7f\\xff\");"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            &mut self.buffer[self.position..self.position + len] as *mut _ as *mut UninitSlice",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let cnt = usize::min(src.len(), self.remaining_mut());",
                "            unsafe { self.chunk_mut().copy_from_slice(&src[..cnt]) };",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "",
                "        fn put_i16_ne(&mut self, n: i16) {",
                "            self.put_slice(&n.to_ne_bytes())",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf {",
                "       buffer: Vec::from([0; 1]),",
                "        position: 0,",
                "    };",
                "    buf.put_i16_ne(0x0809);",
                "    assert_eq!(buf.buffer, b\"\\x09\\x08\");",
                "    assert_eq!(buf.position, 2);",
                "    assert!(std::panic::catch_unwind(|| {",
                "   let mut buf_small = TestBuf { buffer: Vec::from([0; 1]), position: 0 };",
                "    buf_small.put_i16_ne(0x0809);",
                "    }).is_err());",
                "   let mut buf_capacity = TestBuf { buffer: Vec::from([0; 4]), position: 0 };",
                "    buf_capacity.put_i16_ne(-1);",
                "    assert_eq!(buf_capacity.buffer, b\"\\xff\\xff\");",
                "    buf_capacity.put_i16_ne(0x7fff);",
                "    assert_eq!(buf_capacity.buffer, b\"\\xff\\xff\\x7f\\xff\");",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            &mut self.buffer[self.position..self.position + len] as *mut _ as *mut UninitSlice",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let cnt = usize::min(src.len(), self.remaining_mut());",
                "            unsafe { self.chunk_mut().copy_from_slice(&src[..cnt]) };",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "",
                "        fn put_i16_ne(&mut self, n: i16) {",
                "            self.put_slice(&n.to_ne_bytes())",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf {",
                "        buffer: vec![0; 2],",
                "        position: 0,",
                "    };",
                "    buf.put_i16_ne(0x0809);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.buffer, b\"\\x09\\x08\");",
                "    assert_eq!(buf.position, 2);",
                "    let mut buf = TestBuf { buffer: vec![0; 1], position: 0 };",
                "    let result = std::panic::catch_unwind(|| { buf.put_i16_ne(0x0809); });",
                "    assert!(result.is_err());",
                "    let mut buf = TestBuf { buffer: vec![0; 2], position: 0 };",
                "    buf.put_i16_ne(-1);",
                "    assert_eq!(buf.buffer, b\"\\xFF\\xFF\");",
                "    assert_eq!(buf.position, 2);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            &mut self.buffer[self.position..self.position + len] as *mut _ as *mut UninitSlice",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let cnt = usize::min(src.len(), self.remaining_mut());",
                "            unsafe { self.chunk_mut().copy_from_slice(&src[..cnt]) };",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "",
                "        fn put_i16_ne(&mut self, n: i16) {",
                "            self.put_slice(&n.to_ne_bytes())",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf {  ",
                "        buffer: Vec::with_capacity(2),  ",
                "        position: 0,  ",
                "    };  ",
                "    buf.put_i16_ne(0x0809);  ",
                "    assert_eq!(buf.buffer, b\"\\x09\\x08\");  ",
                "    assert_eq!(buf.position, 2);  ",
                "    let mut buf = TestBuf { buffer: Vec::with_capacity(1), position: 0 };  ",
                "    let result = std::panic::catch_unwind(|| { buf.put_i16_ne(0x0809); });",
                "    assert!(result.is_err());",
                "    let mut buf = TestBuf { buffer: vec![0; 2], position: 0 };",
                "    buf.put_i16_ne(-1);",
                "    assert_eq!(buf.buffer, b\"\\xFF\\xFF\");",
                "    assert_eq!(buf.position, 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            &mut self.buffer[self.position..self.position + len] as *mut _ as *mut UninitSlice",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let cnt = usize::min(src.len(), self.remaining_mut());",
                "            unsafe { self.chunk_mut().copy_from_slice(&src[..cnt]) };",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "",
                "        fn put_i16_ne(&mut self, n: i16) {",
                "            self.put_slice(&n.to_ne_bytes())",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf {",
                "        buffer: vec![0; 1],",
                "        position: 0,",
                "    };",
                "    buf.put_i16_ne(0x0809);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining_mut(), 1);",
                "    assert_eq!(buf.position, 0);",
                "    assert_eq!(buf.buffer, vec![0; 1]);",
                "    assert!(buf.has_remaining_mut());",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i16_ne(0x0809);",
                "    });",
                "    assert!(result.is_err());",
                "    assert_eq!(buf.buffer, vec![0; 1]);",
                "    assert_eq!(buf.position, 0);",
                "    assert!(!buf.has_remaining_mut());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            &mut self.buffer[self.position..self.position + len] as *mut _ as *mut UninitSlice",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let cnt = usize::min(src.len(), self.remaining_mut());",
                "            unsafe { self.chunk_mut().copy_from_slice(&src[..cnt]) };",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "",
                "        fn put_i16_ne(&mut self, n: i16) {",
                "            self.put_slice(&n.to_ne_bytes())",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf {",
                "        buffer: vec![0; 1],",
                "        position: 0,",
                "    };",
                "    buf.put_i16_ne(0x0809);",
                "    assert_eq!(buf.remaining_mut(), 1);",
                "    assert_eq!(buf.position, 0);",
                "    assert_eq!(buf.buffer, vec![0; 1]);",
                "    assert!(buf.has_remaining_mut());",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i16_ne(0x0809);",
                "    });",
                "    assert!(result.is_err());",
                "    assert_eq!(buf.buffer, vec![0; 1]);",
                "    assert_eq!(buf.position, 0);",
                "    assert!(!buf.has_remaining_mut());",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}