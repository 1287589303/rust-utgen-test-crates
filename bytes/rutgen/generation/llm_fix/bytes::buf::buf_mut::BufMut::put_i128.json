{
  "name": "bytes::buf::buf_mut::BufMut::put_i128",
  "mod_info": {
    "name": "buf::buf_mut",
    "loc": "src/buf/mod.rs:18:1:18:13"
  },
  "visible": true,
  "loc": "src/buf/buf_mut.rs:889:5:891:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Buffer with at least 16 bytes of remaining capacity, valid i128 values ranging from -170141183460469231731687303715884105728 to 170141183460469231731687303715884105727, and edge case of remaining capacity being exactly 16 bytes (minimum required).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            // Assume UninitSlice is correctly represented as a slice",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.data[self.pos..self.data.len()].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic!();",
                "            }",
                "            let mut src = src;",
                "            while !src.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(src.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&src[..cnt]);",
                "                src = &src[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_slice(&0x01020304050607080910111213141516.to_be_bytes());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.data, b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15\\x16\");",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 15], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(0);",
                "    assert_eq!(buf.data, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(i128::MAX);",
                "    assert_eq!(buf.data, b\"\\x7F\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\");",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(i128::MIN);",
                "    assert_eq!(buf.data, b\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            // Assume UninitSlice is correctly represented as a slice",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.data[self.pos..self.data.len()].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic!();",
                "            }",
                "            let mut src = src;",
                "            while !src.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(src.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&src[..cnt]);",
                "                src = &src[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_slice(&0x01020304050607080910111213141516.to_be_bytes());",
                "    assert_eq!(buf.data, b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x10\\x11\\x12\\x13\\x14\\x15\\x16\");",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 15], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(0);",
                "    assert_eq!(buf.data, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(i128::MAX);",
                "    assert_eq!(buf.data, b\"\\x7F\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\");",
                "    ",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(i128::MIN);",
                "    assert_eq!(buf.data, b\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            // Assume UninitSlice is correctly represented as a slice",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.data[self.pos..self.data.len()].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic!();",
                "            }",
                "            let mut src = src;",
                "            while !src.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(src.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&src[..cnt]);",
                "                src = &src[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_slice(&(-0x01020304050607080910111213141516).to_be_bytes());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.data, b\"\\xff\\xfe\\xfd\\xfc\\xfb\\xfa\\xf9\\xf8\\xf7\\xf6\\xf5\\xf4\\xf3\\xf2\\xf1\\xf0\");",
                "    buf.pos = 0;",
                "    buf.put_i128(0x00000000000000000000000000000000);",
                "    assert_eq!(buf.data[0..16], b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    buf.pos = 0;",
                "    buf.put_i128(0x7FFFFFFFFFFFFFFF);",
                "    assert_eq!(buf.data[0..16], b\"\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\");",
                "    buf.pos = 0;",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            // Assume UninitSlice is correctly represented as a slice",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.data[self.pos..self.data.len()].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic!();",
                "            }",
                "            let mut src = src;",
                "            while !src.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(src.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&src[..cnt]);",
                "                src = &src[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_slice(&(-0x01020304050607080910111213141516).to_be_bytes());",
                "    assert_eq!(buf.data, b\"\\xff\\xfe\\xfd\\xfc\\xfb\\xfa\\xf9\\xf8\\xf7\\xf6\\xf5\\xf4\\xf3\\xf2\\xf1\\xf0\");",
                "    buf.pos = 0;",
                "    buf.put_i128(0x00000000000000000000000000000000);",
                "    assert_eq!(buf.data[0..16], b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    buf.pos = 0;",
                "    buf.put_i128(0x7FFFFFFFFFFFFFFF);",
                "    assert_eq!(buf.data[0..16], b\"\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\");",
                "    buf.pos = 0;",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            // Assume UninitSlice is correctly represented as a slice",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.data[self.pos..self.data.len()].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic!();",
                "            }",
                "            let mut src = src;",
                "            while !src.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(src.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&src[..cnt]);",
                "                src = &src[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_slice(&(i128::MAX).to_be_bytes());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.data, b\"\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\");",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(0);",
                "    assert_eq!(buf.data, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    let mut buf = TestBuf { data: vec![0; 15], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            // Assume UninitSlice is correctly represented as a slice",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.data[self.pos..self.data.len()].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic!();",
                "            }",
                "            let mut src = src;",
                "            while !src.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(src.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&src[..cnt]);",
                "                src = &src[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_slice(&(i128::MAX).to_be_bytes());",
                "    assert_eq!(buf.data, b\"\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\");",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    buf.put_i128(0);",
                "    assert_eq!(buf.data, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
                "    let mut buf = TestBuf { data: vec![0; 16], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    let mut buf = TestBuf { data: vec![0; 15], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, _cnt: usize) {",
                "            panic!(\"Should never reach here\");",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            panic!(\"Should never reach here\");",
                "        }",
                "",
                "        fn put_slice(&mut self, _src: &[u8]) {",
                "            panic!();",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 15], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "        buf.put_slice(&(i128::MAX).to_be_bytes());",
                "    });",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining_mut(), 15);",
                "    assert!(result.is_err());",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    buf.pos = 14; // Set position to test for panic with insufficient space",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    buf.pos = 0; // Reset position for valid test",
                "    buf.data = vec![0; 16]; // Ensure sufficient buffer size",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    assert_eq!(buf.data, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 22]);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, _cnt: usize) {",
                "            panic!(\"Should never reach here\");",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            panic!(\"Should never reach here\");",
                "        }",
                "",
                "        fn put_slice(&mut self, _src: &[u8]) {",
                "            panic!();",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: vec![0; 15], pos: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "        buf.put_slice(&(i128::MAX).to_be_bytes());",
                "    });",
                "    assert!(result.is_err());",
                "    assert_eq!(buf.remaining_mut(), 15);",
                "    assert!(result.is_err());",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    buf.pos = 14; // Set position to test for panic with insufficient space",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    });",
                "    assert!(result.is_err());",
                "    buf.pos = 0; // Reset position for valid test",
                "    buf.data = vec![0; 16]; // Ensure sufficient buffer size",
                "    buf.put_i128(0x01020304050607080910111213141516);",
                "    assert_eq!(buf.data, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 22]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}