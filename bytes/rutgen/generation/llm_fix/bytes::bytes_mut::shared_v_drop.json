{
  "name": "bytes::bytes_mut::shared_v_drop",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": false,
  "loc": "src/bytes_mut.rs:1850:1:1854:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "&mut AtomicPtr<()>, *const u8 (valid or null pointer), usize (0 to MAX_VEC_POS)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(1)) as *mut ());",
                "    unsafe {",
                "        shared_v_drop(&mut atomic_ptr, ptr::null(), 0);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert!(atomic_ptr.load(Ordering::SeqCst).is_null());",
                "    assert_eq!(unsafe { Box::from_raw(atomic_ptr.load(Ordering::SeqCst) as *mut i32) }, 1);",
                "    assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null());"
              ],
              "code": [
                "{",
                "  let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(1)) as *mut ());",
                "  unsafe {",
                "      shared_v_drop(&mut atomic_ptr, ptr::null_mut(), 0);",
                "  }",
                "  assert!(atomic_ptr.load(Ordering::SeqCst).is_null());",
                "  assert_eq!(unsafe { Box::from_raw(atomic_ptr.load(Ordering::SeqCst) as *mut i32) }, Box::new(1));",
                "  assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null_mut());",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(2)) as *mut ());",
                "    unsafe {",
                "        shared_v_drop(&mut atomic_ptr, ptr::null_mut(), 0);",
                "    }",
                "}"
              ],
              "oracle": [
                "    atomic_ptr.load(Ordering::SeqCst).is_null();",
                "    atomic_ptr.load(Ordering::SeqCst) != ptr::null_mut();",
                "    atomic_ptr.load(Ordering::SeqCst) == Box::into_raw(Box::new(2)) as *mut ();",
                "    let shared_ptr = atomic_ptr.load(Ordering::SeqCst);",
                "    assert!(shared_ptr.is_null() || shared_ptr == Box::into_raw(Box::new(2)) as *mut ());"
              ],
              "code": [
                "{",
                "    let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(2)) as *mut ());",
                "    unsafe {",
                "        shared_v_drop(&mut atomic_ptr, ptr::null_mut(), 0);",
                "    }",
                "    atomic_ptr.load(Ordering::SeqCst).is_null();",
                "    atomic_ptr.load(Ordering::SeqCst) != ptr::null_mut();",
                "    atomic_ptr.load(Ordering::SeqCst) == Box::into_raw(Box::new(2)) as *mut ();",
                "    let shared_ptr = atomic_ptr.load(Ordering::SeqCst);",
                "    assert!(shared_ptr.is_null() || shared_ptr == Box::into_raw(Box::new(2)) as *mut ());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(3)) as *mut ());",
                "    unsafe {",
                "        shared_v_drop(&mut atomic_ptr, ptr::null(), MAX_VEC_POS);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null());",
                "    assert!(atomic_ptr.load(Ordering::SeqCst).is_null());",
                "    assert!(unsafe { Box::from_raw(atomic_ptr.load(Ordering::SeqCst) as *mut i32) } == 3);",
                "    assert!(atomic_ptr.load(Ordering::SeqCst) != ptr::null());",
                "    assert!(unsafe { release_shared(*atomic_ptr.load(Ordering::SeqCst) as *mut Shared) }.is_none());"
              ],
              "code": [
                "{",
                "  let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(3)) as *mut i32);",
                "  unsafe {",
                "      shared_v_drop(&mut atomic_ptr, ptr::null::<i32>() as *mut i32, MAX_VEC_POS);",
                "  }",
                "  assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null::<i32>() as *mut i32);",
                "  assert!(atomic_ptr.load(Ordering::SeqCst).is_null());",
                "  assert!(unsafe { Box::from_raw(atomic_ptr.load(Ordering::SeqCst)) } == Box::new(3));",
                "   assert!(atomic_ptr.load(Ordering::SeqCst) != ptr::null::<i32>() as *mut i32);",
                "   assert!(unsafe { release_shared(*atomic_ptr.load(Ordering::SeqCst) as *mut Shared) }.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(4)) as *mut ());",
                "    unsafe {",
                "        shared_v_drop(&mut atomic_ptr, ptr::null(), 0);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null());",
                "    assert!(!atomic_ptr.is_null());",
                "    assert!(atomic_ptr.load(Ordering::SeqCst).is_null() == true);"
              ],
              "code": [
                "{",
                "   let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(4)) as *mut ());",
                "   unsafe {",
                "       shared_v_drop(&mut atomic_ptr, ptr::null_mut(), 0);",
                "   }",
                "   assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null_mut());",
                "   assert!(atomic_ptr.load(Ordering::SeqCst).is_null() == false);",
                "   assert!(atomic_ptr.load(Ordering::SeqCst).is_null() == true);",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(5)) as *mut ());",
                "    unsafe {",
                "        shared_v_drop(&mut atomic_ptr, ptr::null(), 1);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null());",
                "    assert!(unsafe { Box::from_raw(atomic_ptr.load(Ordering::SeqCst) as *mut i32) }.is_none());",
                "    let atomic_ptr_after = AtomicPtr::new(Box::into_raw(Box::new(10)) as *mut ());",
                "    shared_v_drop(&mut atomic_ptr_after, ptr::null(), 1);",
                "    assert_eq!(atomic_ptr_after.load(Ordering::SeqCst), ptr::null());",
                "    assert!(unsafe { Box::from_raw(atomic_ptr_after.load(Ordering::SeqCst) as *mut i32) }.is_none());",
                "    let atomic_ptr_empty = AtomicPtr::new(ptr::null_mut());",
                "    shared_v_drop(&mut atomic_ptr_empty, ptr::null(), 0);",
                "    assert_eq!(atomic_ptr_empty.load(Ordering::SeqCst), ptr::null());"
              ],
              "code": [
                "{",
                "   let mut atomic_ptr = AtomicPtr::new(Box::into_raw(Box::new(5)) as *mut ());",
                "   unsafe {",
                "       shared_v_drop(&mut atomic_ptr, ptr::null_mut(), 1);",
                "   }",
                "   assert_eq!(atomic_ptr.load(Ordering::SeqCst), ptr::null_mut());",
                "  assert!(atomic_ptr.load(Ordering::SeqCst).is_null());",
                "   let atomic_ptr_after = AtomicPtr::new(Box::into_raw(Box::new(10)) as *mut ());",
                "   shared_v_drop(&mut atomic_ptr_after, ptr::null_mut(), 1);",
                "   assert_eq!(atomic_ptr_after.load(Ordering::SeqCst), ptr::null_mut());",
                "   assert!(unsafe { Box::from_raw(atomic_ptr_after.load(Ordering::SeqCst) as *mut i32) }.is_none());",
                "   let atomic_ptr_empty = AtomicPtr::new(ptr::null_mut());",
                "   shared_v_drop(&mut atomic_ptr_empty, ptr::null_mut(), 0);",
                "   assert_eq!(atomic_ptr_empty.load(Ordering::SeqCst), ptr::null_mut());",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}