{
  "name": "bytes::bytes_mut::shared_v_clone",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": false,
  "loc": "src/bytes_mut.rs:1785:1:1791:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "data must be a valid AtomicPtr pointing to an allocated Shared structure, ptr must point to a valid memory location containing at least len bytes, and len must be a non-negative value representing the length of the data to be cloned, ideally within the bounds of 0 to usize::MAX.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3, 4, 5],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(shared_v_clone(&data, ptr::null(), len), Err(TryGetError::InvalidPointer));",
                "    assert_eq!(shared_v_clone(&data, ptr, len), Err(TryGetError::ExceedingRefCount));",
                "    assert!(matches!(shared_v_clone(&data, ptr, len), Ok(_)));",
                "    assert_eq!(unsafe { (*shared_v_clone(&data, ptr, len).unwrap().data.load(Ordering::Relaxed) as *mut Shared).ref_count.load(Ordering::Relaxed) }, 2);",
                "    assert_eq!(unsafe { cloned_bytes.len() }, len);"
              ],
              "code": [
                "{",
                "#[should_panic]",
                "fn test_shared_v_clone_invalid_pointer() {",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr::null(), len);",
                "    }",
                "}",
                "",
                "#[should_panic]",
                "fn test_shared_v_clone_exceeding_ref_count() {",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(usize::MAX),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "}",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3, 4, 5],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "    assert_eq!(shared_v_clone(&data, ptr::null(), len), Err(TryGetError::InvalidPointer));",
                "    assert_eq!(shared_v_clone(&data, ptr, len), Err(TryGetError::ExceedingRefCount));",
                "   let cloned_bytes = shared_v_clone(&data, ptr, len).expect(\"Failed to clone Bytes\");  ",
                "   assert_eq!(unsafe { (*cloned_bytes.data.load(Ordering::Relaxed) as *mut Shared).ref_count.load(Ordering::Relaxed) }, 2);  ",
                "   assert_eq!(unsafe { cloned_bytes.len() }, len);  ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let shared = Box::new(Shared {",
                "        vec: vec![],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert!(std::panic::catch_unwind(|| {",
                "    let shared = Box::new(Shared {",
                "    vec: vec![1, 2, 3],",
                "    original_capacity_repr: 0,",
                "    ref_count: AtomicUsize::new(1),",
                "    });",
                "    ",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    ",
                "    unsafe {",
                "    let cloned_bytes = shared_v_clone(&data, ptr::null(), len);",
                "    }",
                "    }).is_err());",
                "    ",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let shared = Box::new(Shared {",
                "    vec: vec![1, 2, 3],",
                "    original_capacity_repr: 0,",
                "    ref_count: AtomicUsize::new(usize::MAX),",
                "    });",
                "    ",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    ",
                "    unsafe {",
                "    let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "    }).is_err());",
                "    ",
                "    let shared = Box::new(Shared {",
                "    vec: vec![],",
                "    original_capacity_repr: 0,",
                "    ref_count: AtomicUsize::new(1),",
                "    });",
                "    ",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    ",
                "    let cloned_bytes = unsafe { shared_v_clone(&data, ptr, len) };",
                "    assert_eq!(cloned_bytes.len(), len);"
              ],
              "code": [
                "{",
                "#[should_panic]",
                "fn test_shared_v_clone_invalid_pointer() {",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr::null(), len);",
                "    }",
                "}",
                "",
                "#[should_panic]",
                "fn test_shared_v_clone_exceeding_ref_count() {",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(usize::MAX),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "}",
                "    let shared = Box::new(Shared {",
                "        vec: vec![],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let shared = Box::new(Shared {",
                "    vec: vec![1, 2, 3],",
                "    original_capacity_repr: 0,",
                "    ref_count: AtomicUsize::new(1),",
                "    });",
                "    ",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    ",
                "    unsafe {",
                "    let cloned_bytes = shared_v_clone(&data, ptr::null(), len);",
                "    }",
                "    }).is_err());",
                "    ",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let shared = Box::new(Shared {",
                "    vec: vec![1, 2, 3],",
                "    original_capacity_repr: 0,",
                "    ref_count: AtomicUsize::new(usize::MAX),",
                "    });",
                "    ",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    ",
                "    unsafe {",
                "    let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "    }).is_err());",
                "    ",
                "    let shared = Box::new(Shared {",
                "    vec: vec![],",
                "    original_capacity_repr: 0,",
                "    ref_count: AtomicUsize::new(1),",
                "    });",
                "    ",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    ",
                "    let cloned_bytes = unsafe { shared_v_clone(&data, ptr, len) };",
                "    assert_eq!(cloned_bytes.len(), len);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let large_vec = vec![0u8; usize::MAX];",
                "    let shared = Box::new(Shared {",
                "        vec: large_vec,",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "}"
              ],
              "oracle": [
                "    let shared = Box::new(Shared { vec: vec![], original_capacity_repr: 0, ref_count: AtomicUsize::new(1) }); let len = shared.vec.len(); let data = AtomicPtr::new(Box::into_raw(shared) as *mut ()); unsafe { let cloned_bytes = shared_v_clone(&data, ptr::null(), len) };",
                "    let shared = Box::new(Shared { vec: vec![1, 2, 3], original_capacity_repr: 0, ref_count: AtomicUsize::new(usize::MAX) }); let ptr = shared.vec.as_ptr(); let len = shared.vec.len(); let data = AtomicPtr::new(Box::into_raw(shared) as *mut ()); unsafe { let cloned_bytes = shared_v_clone(&data, ptr, len) };",
                "    let large_vec = vec![0u8; usize::MAX]; let shared = Box::new(Shared { vec: large_vec, original_capacity_repr: 0, ref_count: AtomicUsize::new(1) }); let ptr = shared.vec.as_ptr(); let len = shared.vec.len(); let data = AtomicPtr::new(Box::into_raw(shared) as *mut ()); unsafe { let cloned_bytes = shared_v_clone(&data, ptr, len) };"
              ],
              "code": [
                "{",
                "#[should_panic]",
                "fn test_shared_v_clone_invalid_pointer() {",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr::null(), len);",
                "    }",
                "}",
                "",
                "#[should_panic]",
                "fn test_shared_v_clone_exceeding_ref_count() {",
                "    let shared = Box::new(Shared {",
                "        vec: vec![1, 2, 3],",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(usize::MAX),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "    }",
                "}",
                "    let large_vec = vec![0u8; usize::MAX];",
                "    let shared = Box::new(Shared {",
                "        vec: large_vec,",
                "        original_capacity_repr: 0,",
                "        ref_count: AtomicUsize::new(1),",
                "    });",
                "",
                "    let ptr = shared.vec.as_ptr();",
                "    let len = shared.vec.len();",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    unsafe {",
                "        let cloned_bytes = shared_v_clone(&data, ptr, len);",
                "   }",
                "   let shared = Box::new(Shared { vec: vec![], original_capacity_repr: 0, ref_count: AtomicUsize::new(1) }); ",
                "   let len = shared.vec.len(); ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}