{
  "name": "bytes::buf::buf_mut::BufMut::put_int",
  "mod_info": {
    "name": "buf::buf_mut",
    "loc": "src/buf/mod.rs:18:1:18:13"
  },
  "visible": true,
  "loc": "src/buf/buf_mut.rs:1050:5:1057:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: mem::size_of_val(&n).checked_sub(nbytes) matches Some(start) at line 1051 is true\n",
        "precondition: mem::size_of_val(&n).checked_sub(nbytes) matches Some(start) at line 1051 is true\n"
      ],
      "input_infer": "n must be a signed 64-bit integer (i64), nbytes must be a value in the range 1 to 8, and remaining_mut must be greater than or equal to nbytes.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        cursor: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(capacity: usize) -> Self {",
                "            Self {",
                "                data: vec![0; capacity],",
                "                cursor: 0,",
                "            }",
                "        }",
                "",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.cursor",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.cursor += cnt;",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(8);",
                "    buf.put_int(0x0504010203, 3);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.data, vec![0x01, 0x02, 0x03, 0, 0, 0, 0, 0]);",
                "    assert_eq!(buf.cursor, 3);",
                "    ",
                "    let mut buf2 = TestBuf::new(8);",
                "    buf2.put_int(0x0102030405060708, 8);",
                "    assert_eq!(buf2.data, vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);",
                "    assert_eq!(buf2.cursor, 8);",
                "    ",
                "    let mut buf3 = TestBuf::new(8);",
                "    buf3.put_int(0x0102030405060708, 7);",
                "    assert_eq!(buf3.data[..7], vec![0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);",
                "    assert_eq!(buf3.cursor, 7);",
                "    ",
                "    let mut buf4 = TestBuf::new(8);",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf4.put_int(0x0102030405060708, 9);",
                "    });",
                "    assert!(result.is_err());"
              ],
              "code": [
                "   fn test_put_int_00()",
                "   {",
                "       struct TestBuf {",
                "           data: Vec<u8>,",
                "           cursor: usize,",
                "       }",
                "   ",
                "       impl TestBuf {",
                "           fn new(capacity: usize) -> Self {",
                "               Self {",
                "                  data: Vec::with_capacity(capacity),",
                "                   cursor: 0,",
                "               }",
                "           }",
                "   ",
                "           fn remaining_mut(&self) -> usize {",
                "               self.data.len() - self.cursor",
                "           }",
                "   ",
                "           unsafe fn advance_mut(&mut self, cnt: usize) {",
                "               self.cursor += cnt;",
                "           }",
                "   ",
                "           fn put_slice(&mut self, src: &[u8]) {",
                "               let cnt = src.len();",
                "               self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "               unsafe { self.advance_mut(cnt) };",
                "           }",
                "       }",
                "   ",
                "       let mut buf = TestBuf::new(8);",
                "       buf.put_int(0x0504010203, 3);",
                "       assert_eq!(buf.data, vec![0x01, 0x02, 0x03, 0, 0, 0, 0, 0]);",
                "       assert_eq!(buf.cursor, 3);",
                "       ",
                "       let mut buf2 = TestBuf::new(8);",
                "       buf2.put_int(0x0102030405060708, 8);",
                "       assert_eq!(buf2.data, vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);",
                "    ",
                "    let mut buf3 = TestBuf::new(8);",
                "    buf3.put_int(0x0102030405060708, 7);",
                "    assert_eq!(buf3.data[..7], vec![0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);",
                "    assert_eq!(buf3.cursor, 7);",
                "    ",
                "    let mut buf4 = TestBuf::new(8);",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf4.put_int(0x0102030405060708, 9);",
                "    });",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        cursor: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(capacity: usize) -> Self {",
                "            Self {",
                "                data: vec![0; capacity],",
                "                cursor: 0,",
                "            }",
                "        }",
                "",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.cursor",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.cursor += cnt;",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(8);",
                "    buf.put_int(0x0504010203, 8);",
                "}"
              ],
              "oracle": [
                "    buf.put_int(0x0504010203, 3); assert_eq!(buf.data, vec![0, 1, 2, 3, 0, 0, 0, 0]);",
                "    buf.put_int(0x1234567890abcdef, 8); assert_eq!(buf.data, vec![0xab, 0xcd, 0xef, 0x90, 0x78, 0x56, 0x34, 0x12]);",
                "    buf.put_int(0xFFFFFFFFFFFFFFFF, 8); assert_eq!(buf.data, vec![0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);",
                "    assert_panics!(buf.put_int(0x0504010203, 9));",
                "    buf.put_int(0x00, 0); assert_eq!(buf.data, vec![0, 1, 2, 3, 0, 0, 0, 0]);"
              ],
              "code": [
                "   fn test_put_int_01()",
                "   {",
                "       struct TestBuf {",
                "           data: Vec<u8>,",
                "           cursor: usize,",
                "       }",
                "       ",
                "       impl TestBuf {",
                "           fn new(capacity: usize) -> Self {",
                "               Self {",
                "                   data: vec![0; capacity],",
                "                   cursor: 0,",
                "               }",
                "           }",
                "       ",
                "           fn remaining_mut(&self) -> usize {",
                "               self.data.len() - self.cursor",
                "           }",
                "       ",
                "           unsafe fn advance_mut(&mut self, cnt: usize) {",
                "               self.cursor += cnt;",
                "           }",
                "       ",
                "           fn put_slice(&mut self, src: &[u8]) {",
                "               let cnt = src.len();",
                "               self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "               unsafe { self.advance_mut(cnt) };",
                "           }",
                "       }",
                "       ",
                "       let mut buf = TestBuf::new(8);",
                "       buf.put_int(0x0504010203, 8);",
                "       buf.put_int(0x0504010203, 3); assert_eq!(buf.data, vec![0, 1, 2, 3, 0, 0, 0, 0]);",
                "       buf.put_int(0x1234567890abcdef, 8); assert_eq!(buf.data, vec![0xab, 0xcd, 0xef, 0x90, 0x78, 0x56, 0x34, 0x12]);",
                "       buf.put_int(0xFFFFFFFFFFFFFFFF, 8); assert_eq!(buf.data, vec![0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);",
                "       assert_panics!(buf.put_int(0x0504010203, 9));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        cursor: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(capacity: usize) -> Self {",
                "            Self {",
                "                data: vec![0; capacity],",
                "                cursor: 0,",
                "            }",
                "        }",
                "",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.cursor",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.cursor += cnt;",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(8);",
                "    buf.put_int(0x0504010203, 9);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 9)).is_err(), true);",
                "    assert_eq!(buf.remaining_mut(), 8);"
              ],
              "code": [
                "{",
                "  struct TestBuf {  ",
                "      data: Vec<u8>,  ",
                "      cursor: usize,  ",
                "  }  ",
                " ",
                "  impl TestBuf {  ",
                "      fn new(capacity: usize) -> Self {  ",
                "          Self {  ",
                "              data: std::vec![0; capacity],  ",
                "              cursor: 0,  ",
                "            }",
                "        }",
                "",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.cursor",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.cursor += cnt;",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(8);",
                "    buf.put_int(0x0504010203, 9);",
                "    assert_eq!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 9)).is_err(), true);",
                "    assert_eq!(buf.remaining_mut(), 8);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        cursor: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(capacity: usize) -> Self {",
                "            Self {",
                "                data: vec![0; capacity],",
                "                cursor: 0,",
                "            }",
                "        }",
                "",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.cursor",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.cursor += cnt;",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(2);",
                "    buf.put_int(0x0504010203, 3);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining_mut(), 0);",
                "    assert_eq!(&buf.data, &[0x01, 0x02, 0x03, 0, 0]);",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 9)).is_err());",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 3)).is_err());",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 2)).is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        cursor: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(capacity: usize) -> Self {",
                "            Self {",
                "                data: vec![0; capacity],",
                "                cursor: 0,",
                "            }",
                "        }",
                "",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.cursor",
                "        }",
                "",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.cursor += cnt;",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.cursor..self.cursor + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(2);",
                "    buf.put_int(0x0504010203, 3);",
                "    assert_eq!(buf.remaining_mut(), 0);",
                "    assert_eq!(&buf.data, &[0x01, 0x02, 0x03, 0, 0]);",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 9)).is_err());",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 3)).is_err());",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(0x0504010203, 2)).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: mem::size_of_val(&n).checked_sub(nbytes) matches None at line 1051 is true\n"
      ],
      "input_infer": "n must be any signed integer type value where nbytes > mem::size_of_val(&n) and nbytes <= 8, with remaining capacity in self greater than or equal to nbytes\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(size: usize) -> Self {",
                "            Self {",
                "                data: vec![0; size],",
                "                pos: 0,",
                "            }",
                "        }",
                "        ",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(10);",
                "    let n = -1i64;",
                "    let nbytes = 9;",
                "",
                "    // This should panic",
                "    buf.put_int(n, nbytes);",
                "}"
              ],
              "oracle": [
                "    assert_panics!(buf.put_int(-1i64, 9));",
                "    assert_eq!(buf.remaining_mut(), 10);",
                "    assert_eq!(buf.data, vec![0; 10]);"
              ],
              "code": [
                "   {  ",
                "     struct TestBuf {  ",
                "         data: Vec<u8>,  ",
                "         pos: usize,  ",
                "     }  ",
                " ",
                "     impl TestBuf {  ",
                "         fn new(size: usize) -> Self {  ",
                "             Self {  ",
                "                 data: std::vec![0; size],  ",
                "                 pos: 0,  ",
                "           }",
                "       }",
                "       ",
                "       fn remaining_mut(&self) -> usize {",
                "           self.data.len() - self.pos",
                "       }",
                "       ",
                "       unsafe fn advance_mut(&mut self, cnt: usize) {",
                "           self.pos += cnt;",
                "       }",
                "       ",
                "       fn put_slice(&mut self, src: &[u8]) {",
                "           let cnt = src.len();",
                "           self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
                "           unsafe { self.advance_mut(cnt) };",
                "       }",
                "       ",
                "       fn put_int(&mut self, val: i64, nbytes: usize) {",
                "           if nbytes > self.remaining_mut() {",
                "               panic!(\"not enough space to put int\");",
                "           }",
                "           let bytes = val.to_le_bytes();",
                "           self.put_slice(&bytes[..nbytes]);",
                "       }",
                "   }",
                "   ",
                "   let mut buf = TestBuf::new(10);",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(size: usize) -> Self {",
                "            Self {",
                "                data: vec![0; size],",
                "                pos: 0,",
                "            }",
                "        }",
                "        ",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(5);",
                "    let n = -128i64;",
                "    let nbytes = 6;",
                "",
                "    // This should panic due to insufficient capacity",
                "    buf.put_int(n, nbytes);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining_mut(), 5);",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(-128i64, 6)).is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(size: usize) -> Self {",
                "            Self {",
                "               data: Vec::with_capacity(size),",
                "               pos: 0,",
                "           }",
                "        }",
                "        ",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(5);",
                "    let n = -128i64;",
                "    let nbytes = 6;",
                "",
                "    // This should panic due to insufficient capacity",
                "    buf.put_int(n, nbytes);",
                "    assert_eq!(buf.remaining_mut(), 5);",
                "    assert!(std::panic::catch_unwind(|| buf.put_int(-128i64, 6)).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: Vec<u8>,",
                "        pos: usize,",
                "    }",
                "",
                "    impl TestBuf {",
                "        fn new(size: usize) -> Self {",
                "            Self {",
                "                data: vec![0; size],",
                "                pos: 0,",
                "            }",
                "        }",
                "        ",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            let cnt = src.len();",
                "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
                "            unsafe { self.advance_mut(cnt) };",
                "        }",
                "        ",
                "        fn assert_eq_data(&self, expected: &[u8]) {",
                "            assert_eq!(self.data, expected);",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf::new(10);",
                "    let n = 0x0504010203i64;",
                "    let nbytes = 3;",
                "",
                "    buf.put_int(n, nbytes);",
                "    buf.assert_eq_data(&[0x01, 0x02, 0x03, 0, 0, 0, 0, 0, 0, 0]);",
                "}"
              ],
              "oracle": [
                "    buf.put_int(n, nbytes); assert_eq!(buf.remaining_mut(), 7);",
                "    panic_does_not_fit(nbytes, mem::size_of_val(&n));",
                "    buf.put_int(0x01i64, 9);",
                "    buf.put_int(0x0102030405060708i64, 8);",
                "    buf.assert_eq_data(&[0x01, 0x02, 0x03, 0, 0, 0, 0, 0, 0, 0]);"
              ],
              "code": [
                "{",
                "  struct TestBuf {  ",
                "      data: Vec<u8>,  ",
                "      pos: usize,  ",
                "  }  ",
                "  ",
                "  impl TestBuf {  ",
                "      fn new(size: usize) -> Self {  ",
                "          Self {  ",
                "              data: std::vec![0; size],  ",
                "              pos: 0,  ",
                "          }  ",
                "      }  ",
                "      ",
                "      fn remaining_mut(&self) -> usize {  ",
                "          self.data.len() - self.pos  ",
                "      }  ",
                "      ",
                "      unsafe fn advance_mut(&mut self, cnt: usize) {  ",
                "          self.pos += cnt;  ",
                "      }  ",
                "      ",
                "      fn put_slice(&mut self, src: &[u8]) {  ",
                "          let cnt = src.len();  ",
                "          self.data[self.pos..self.pos + cnt].copy_from_slice(src);  ",
                "          unsafe { self.advance_mut(cnt) };  ",
                "      }  ",
                "      ",
                "      fn put_int(&mut self, value: i64, nbytes: usize) {  ",
                "          let slice = &value.to_ne_bytes()[..nbytes];  ",
                "          self.put_slice(slice);  ",
                "      }  ",
                "      ",
                "      fn assert_eq_data(&self, expected: &[u8]) {  ",
                "          assert_eq!(self.data, expected);  ",
                "      }  ",
                "  }  ",
                "  ",
                " let mut buf = TestBuf::new(10);  ",
                " let n = 0x0504010203i64;  ",
                " let nbytes = mem::size_of_val(&n);  ",
                " panic_does_not_fit(nbytes, nbytes);  ",
                " buf.put_int(0x01i64, 9);  ",
                " buf.put_int(0x0102030405060708i64, 8);  ",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}