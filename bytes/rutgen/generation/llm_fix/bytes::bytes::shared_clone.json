{
  "name": "bytes::bytes::shared_clone",
  "mod_info": {
    "name": "bytes",
    "loc": "src/lib.rs:82:1:82:11"
  },
  "visible": false,
  "loc": "src/bytes.rs:1388:1:1391:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "AtomicPtr must point to a valid memory address for a Shared object; ptr must point to a valid memory location holding u8 data with len between 0 and usize::MAX; len must not exceed the allocated size of the shared buffer.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let shared_buf = Box::new(Shared {",
                "        buf: Box::into_raw(Box::new([0u8; 1])) as *mut u8,",
                "        cap: 1,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let atomic_ptr = AtomicPtr::new(shared_buf as *mut Shared as *mut ());",
                "    let ptr = shared_buf.buf;",
                "    let len = 0;",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(shared_clone(&atomic_ptr, ptr, len).len, 0);",
                "    assert!(!shared_clone(&atomic_ptr, ptr, len).ptr.is_null());",
                "    assert_eq!(shared_clone(&atomic_ptr, ptr, len).data.load(Ordering::Relaxed), atomic_ptr.load(Ordering::Relaxed));",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 1);",
                "    let _bytes_clone = shared_clone(&atomic_ptr, ptr, len);",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 2);",
                "    drop(_bytes_clone);",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 1);"
              ],
              "code": [
                "{",
                "    let shared_buf = Box::new(Shared {",
                "        buf: Box::into_raw(Box::new([0u8; 1])) as *mut u8,",
                "        cap: 1,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let atomic_ptr = AtomicPtr::new(shared_buf as *mut Shared as *mut ());",
                "    let ptr = shared_buf.buf;",
                "    let len = 0;",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "    assert_eq!(shared_clone(&atomic_ptr, ptr, len).len, 0);",
                "    assert!(!shared_clone(&atomic_ptr, ptr, len).ptr.is_null());",
                "    assert_eq!(shared_clone(&atomic_ptr, ptr, len).data.load(Ordering::Relaxed), atomic_ptr.load(Ordering::Relaxed));",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 1);",
                "    let _bytes_clone = shared_clone(&atomic_ptr, ptr, len);",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 2);",
                "    drop(_bytes_clone);",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let shared_buf = Box::new(Shared {",
                "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
                "        cap: 10,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let atomic_ptr = AtomicPtr::new(shared_buf as *mut Shared as *mut ());",
                "    let ptr = shared_buf.buf;",
                "    let len = 0;",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.len == 0);",
                "    assert_eq!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.ptr, ptr);",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.data.load(Ordering::Relaxed) == atomic_ptr.get());",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.vtable == &SHARED_VTABLE);",
                "    assert!(unsafe { (*shared_buf).ref_cnt.load(Ordering::Relaxed) } == 1);",
                "    assert!(unsafe { (*shared_buf).ref_cnt.fetch_add(1, Ordering::Relaxed) } == 1);",
                "    assert!(unsafe { (*shared_buf).ref_cnt.load(Ordering::Relaxed) } == 2);"
              ],
              "code": [
                "{",
                "   let shared_buf = Box::new(Shared {  ",
                "       buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,  ",
                "       cap: 10,  ",
                "       ref_cnt: AtomicUsize::new(1),  ",
                "   });  ",
                "   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_buf) as *mut Shared as *mut ());  ",
                "    let ptr = shared_buf.buf;",
                "    let len = 0;",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.len == 0);",
                "    assert_eq!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.ptr, ptr);",
                "   assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.data.load(Ordering::Relaxed) == atomic_ptr.load(Ordering::Relaxed));  ",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.vtable == &SHARED_VTABLE);",
                "    assert!(unsafe { (*shared_buf).ref_cnt.load(Ordering::Relaxed) } == 1);",
                "    assert!(unsafe { (*shared_buf).ref_cnt.fetch_add(1, Ordering::Relaxed) } == 1);",
                "    assert!(unsafe { (*shared_buf).ref_cnt.load(Ordering::Relaxed) } == 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let shared_buf = Box::new(Shared {",
                "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
                "        cap: 10,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let atomic_ptr = AtomicPtr::new(shared_buf as *mut Shared as *mut ());",
                "    let ptr = shared_buf.buf;",
                "    let len = 10;",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.len == 10);",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.ptr == ptr);",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.data.load(Ordering::Relaxed) == atomic_ptr.load(Ordering::Relaxed));",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.vtable == &SHARED_VTABLE);",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.data.load(Ordering::Relaxed) as *mut Shared == atomic_ptr.load(Ordering::Relaxed) as *mut Shared);",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 2);"
              ],
              "code": [
                "{",
                "    let shared_buf = Box::new(Shared {",
                "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
                "        cap: 10,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_buf) as *mut ());",
                "    let ptr = shared_buf.buf;",
                "    let len = 10;",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.len == 10);",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.ptr == ptr);",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.data.load(Ordering::Relaxed) == atomic_ptr.load(Ordering::Relaxed));",
                "    assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.vtable == &SHARED_VTABLE);",
                "   assert!(unsafe { shared_clone(&atomic_ptr, ptr, len) }.data.load(Ordering::Relaxed) as *mut Shared == atomic_ptr.load(Ordering::Relaxed) as *mut Shared);  ",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let shared_buf = Box::new(Shared {",
                "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
                "        cap: 10,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let atomic_ptr = AtomicPtr::new(shared_buf as *mut Shared as *mut ());",
                "    let ptr = shared_buf.buf;",
                "    let len = 11; // Exceeding the allocated size",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(shared_clone(&atomic_ptr, ptr, len).len, 11);",
                "    let bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    assert!(!bytes.data.load(Ordering::Relaxed).is_null());",
                "    assert_eq!(bytes.vtable, &SHARED_VTABLE);",
                "    assert!(bytes.ptr == ptr);",
                "    assert!(bytes.len == len);",
                "    let shared_clone_result = shared_clone(&atomic_ptr, ptr, len);",
                "    assert!(shared_clone_result.data.load(Ordering::Relaxed) as *mut Shared == shared_buf.as_mut());",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 2);"
              ],
              "code": [
                "{",
                "   let shared_buf = Box::new(Shared {",
                "       buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
                "       cap: 10,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let atomic_ptr = AtomicPtr::new(Box::into_raw(shared_buf) as *mut Shared as *mut ());",
                "    let ptr = shared_buf.buf;",
                "    let len = 11; // Exceeding the allocated size",
                "",
                "    unsafe {",
                "        let _bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    }",
                "    assert_eq!(shared_clone(&atomic_ptr, ptr, len).len, 11);",
                "    let bytes = shared_clone(&atomic_ptr, ptr, len);",
                "    assert!(!bytes.data.load(Ordering::Relaxed).is_null());",
                "    assert_eq!(bytes.vtable, &SHARED_VTABLE);",
                "    assert!(bytes.ptr == ptr);",
                "    assert!(bytes.len == len);",
                "    let shared_clone_result = shared_clone(&atomic_ptr, ptr, len);",
                "    assert!(shared_clone_result.data.load(Ordering::Relaxed) as *mut Shared == shared_buf.as_mut());",
                "    assert_eq!(shared_buf.ref_cnt.load(Ordering::Relaxed), 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}