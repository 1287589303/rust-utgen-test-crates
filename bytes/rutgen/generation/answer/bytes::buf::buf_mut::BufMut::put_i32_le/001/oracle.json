[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 8],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(0x0809A0A1i32.to_le_bytes()));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.data, vec![0xA1, 0xA0, 0x09, 0x08, 0, 0, 0, 0]);",
          "    assert!(std::panic::catch_unwind(|| { buf.put_i32_le(0x12345678); }).is_err());",
          "    buf.position = 0;",
          "    buf.put_i32_le(0xFFFFFFFF);",
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0]);",
          "    assert_eq!(buf.remaining_mut(), 4);",
          "    buf.put_i32_le(0x00000000);",
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0]);"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 8],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(0x0809A0A1i32.to_le_bytes()));",
          "    assert_eq!(buf.data, vec![0xA1, 0xA0, 0x09, 0x08, 0, 0, 0, 0]);",
          "    assert!(std::panic::catch_unwind(|| { buf.put_i32_le(0x12345678); }).is_err());",
          "    buf.position = 0;",
          "    buf.put_i32_le(0xFFFFFFFF);",
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0]);",
          "    assert_eq!(buf.remaining_mut(), 4);",
          "    buf.put_i32_le(0x00000000);",
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 8],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(-0x0809A0A1i32.to_le_bytes()));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.data, vec![0xA1, 0xA0, 0x09, 0x08, 0, 0, 0, 0]);",
          "    assert!(std::panic::catch_unwind(|| { buf.put_i32_le(0xFFFFFFFF); }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { buf.put_i32_le(0); }).is_ok());"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 8],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(-0x0809A0A1i32.to_le_bytes()));",
          "    assert_eq!(buf.data, vec![0xA1, 0xA0, 0x09, 0x08, 0, 0, 0, 0]);",
          "    assert!(std::panic::catch_unwind(|| { buf.put_i32_le(0xFFFFFFFF); }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { buf.put_i32_le(0); }).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 3],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(0x0809A0A1i32.to_le_bytes()));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.remaining_mut(), 3);",
          "    let result = std::panic::catch_unwind(|| buf.put_i32_le(0x0809A0A1));",
          "    assert!(result.is_err());",
          "    buf.position = 0;",
          "    buf.data = vec![0; 4];",
          "    buf.put_i32_le(0x0809A0A1);",
          "    assert_eq!(buf.data, b\"\\xA1\\xA0\\x09\\x08\");"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 3],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(0x0809A0A1i32.to_le_bytes()));",
          "    assert_eq!(buf.remaining_mut(), 3);",
          "    let result = std::panic::catch_unwind(|| buf.put_i32_le(0x0809A0A1));",
          "    assert!(result.is_err());",
          "    buf.position = 0;",
          "    buf.data = vec![0; 4];",
          "    buf.put_i32_le(0x0809A0A1);",
          "    assert_eq!(buf.data, b\"\\xA1\\xA0\\x09\\x08\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 4],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(0x7FFFFFFFi32.to_le_bytes()));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0x7F]);",
          "    let mut buf = TestBuf { data: vec![0; 4], position: 0 };",
          "    buf.put_i32_le(0);",
          "    assert_eq!(buf.data, vec![0, 0, 0, 0]);",
          "    let mut buf = TestBuf { data: vec![0; 4], position: 0 };",
          "    buf.put_i32_le(-1);",
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0xFF]);",
          "    let mut buf = TestBuf { data: vec![0; 3], position: 0 };",
          "    let result = std::panic::catch_unwind(|| {",
          "    buf.put_i32_le(1);",
          "    });",
          "    assert!(result.is_err());",
          "    let mut buf = TestBuf { data: vec![0; 4], position: 2 };",
          "    let result = std::panic::catch_unwind(|| {",
          "    buf.put_i32_le(1);",
          "    });",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            assert!(self.remaining_mut() >= src.len());",
          "            let dst = &mut self.data[self.position..self.position + src.len()];",
          "            dst.copy_from_slice(src);",
          "            unsafe { self.advance_mut(src.len()) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf {",
          "        data: vec![0; 4],",
          "        position: 0,",
          "    };",
          "    buf.put_slice(&(0x7FFFFFFFi32.to_le_bytes()));",
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0x7F]);",
          "    let mut buf = TestBuf { data: vec![0; 4], position: 0 };",
          "    buf.put_i32_le(0);",
          "    assert_eq!(buf.data, vec![0, 0, 0, 0]);",
          "    let mut buf = TestBuf { data: vec![0; 4], position: 0 };",
          "    buf.put_i32_le(-1);",
          "    assert_eq!(buf.data, vec![0xFF, 0xFF, 0xFF, 0xFF]);",
          "    let mut buf = TestBuf { data: vec![0; 3], position: 0 };",
          "    let result = std::panic::catch_unwind(|| {",
          "    buf.put_i32_le(1);",
          "    });",
          "    assert!(result.is_err());",
          "    let mut buf = TestBuf { data: vec![0; 4], position: 2 };",
          "    let result = std::panic::catch_unwind(|| {",
          "    buf.put_i32_le(1);",
          "    });",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]