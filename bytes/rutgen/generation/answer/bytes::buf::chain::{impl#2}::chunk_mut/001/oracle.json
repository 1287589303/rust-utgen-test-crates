[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBufMutA {",
          "        remaining: usize,",
          "    }",
          "",
          "    struct TestBufMutB {",
          "        remaining: usize,",
          "    }",
          "",
          "    unsafe impl BufMut for TestBufMutA {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.remaining",
          "        }",
          "        unsafe fn advance_mut(&mut self, _: usize) {}",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            &mut UninitSlice([std::mem::MaybeUninit::uninit(); 10])",
          "        }",
          "    }",
          "",
          "    unsafe impl BufMut for TestBufMutB {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.remaining",
          "        }",
          "        unsafe fn advance_mut(&mut self, _: usize) {}",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            &mut UninitSlice([std::mem::MaybeUninit::uninit(); 10])",
          "        }",
          "    }",
          "",
          "    let buf_a = TestBufMutA { remaining: 5 };",
          "    let buf_b = TestBufMutB { remaining: 0 };",
          "    let mut chain = Chain { a: buf_a, b: buf_b };",
          "    let _result = chain.chunk_mut();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(chain.a.remaining_mut(), 5);",
          "    assert!(chain.a.has_remaining_mut());",
          "    assert_eq!(std::mem::size_of_val(chain.chunk_mut()), std::mem::size_of::<UninitSlice>());",
          "    assert_ne!(chain.chunk_mut() as *mut _, std::ptr::null_mut());",
          "    assert_eq!(chain.chunk_mut(), &mut UninitSlice([std::mem::MaybeUninit::uninit(); 10]));"
        ],
        "code": [
          "{",
          "    struct TestBufMutA {",
          "        remaining: usize,",
          "    }",
          "",
          "    struct TestBufMutB {",
          "        remaining: usize,",
          "    }",
          "",
          "    unsafe impl BufMut for TestBufMutA {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.remaining",
          "        }",
          "        unsafe fn advance_mut(&mut self, _: usize) {}",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            &mut UninitSlice([std::mem::MaybeUninit::uninit(); 10])",
          "        }",
          "    }",
          "",
          "    unsafe impl BufMut for TestBufMutB {",
          "        fn remaining_mut(&self) -> usize {",
          "            self.remaining",
          "        }",
          "        unsafe fn advance_mut(&mut self, _: usize) {}",
          "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
          "            &mut UninitSlice([std::mem::MaybeUninit::uninit(); 10])",
          "        }",
          "    }",
          "",
          "    let buf_a = TestBufMutA { remaining: 5 };",
          "    let buf_b = TestBufMutB { remaining: 0 };",
          "    let mut chain = Chain { a: buf_a, b: buf_b };",
          "    let _result = chain.chunk_mut();",
          "    assert_eq!(chain.a.remaining_mut(), 5);",
          "    assert!(chain.a.has_remaining_mut());",
          "    assert_eq!(std::mem::size_of_val(chain.chunk_mut()), std::mem::size_of::<UninitSlice>());",
          "    assert_ne!(chain.chunk_mut() as *mut _, std::ptr::null_mut());",
          "    assert_eq!(chain.chunk_mut(), &mut UninitSlice([std::mem::MaybeUninit::uninit(); 10]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]