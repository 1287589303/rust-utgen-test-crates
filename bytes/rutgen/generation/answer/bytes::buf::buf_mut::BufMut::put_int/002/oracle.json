[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(size: usize) -> Self {",
          "            Self {",
          "                data: vec![0; size],",
          "                pos: 0,",
          "            }",
          "        }",
          "        ",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "        ",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "        ",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            let cnt = src.len();",
          "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
          "            unsafe { self.advance_mut(cnt) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(10);",
          "    let n = -1i64;",
          "    let nbytes = 9;",
          "",
          "    // This should panic",
          "    buf.put_int(n, nbytes);",
          "}"
        ],
        "oracle": [
          "    assert_panics!(buf.put_int(-1i64, 9));",
          "    assert_eq!(buf.remaining_mut(), 10);",
          "    assert_eq!(buf.data, vec![0; 10]);"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(size: usize) -> Self {",
          "            Self {",
          "                data: vec![0; size],",
          "                pos: 0,",
          "            }",
          "        }",
          "        ",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "        ",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "        ",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            let cnt = src.len();",
          "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
          "            unsafe { self.advance_mut(cnt) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(10);",
          "    let n = -1i64;",
          "    let nbytes = 9;",
          "",
          "    // This should panic",
          "    buf.put_int(n, nbytes);",
          "    assert_panics!(buf.put_int(-1i64, 9));",
          "    assert_eq!(buf.remaining_mut(), 10);",
          "    assert_eq!(buf.data, vec![0; 10]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(size: usize) -> Self {",
          "            Self {",
          "                data: vec![0; size],",
          "                pos: 0,",
          "            }",
          "        }",
          "        ",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "        ",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "        ",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            let cnt = src.len();",
          "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
          "            unsafe { self.advance_mut(cnt) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(5);",
          "    let n = -128i64;",
          "    let nbytes = 6;",
          "",
          "    // This should panic due to insufficient capacity",
          "    buf.put_int(n, nbytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.remaining_mut(), 5);",
          "    assert!(std::panic::catch_unwind(|| buf.put_int(-128i64, 6)).is_err());"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(size: usize) -> Self {",
          "            Self {",
          "                data: vec![0; size],",
          "                pos: 0,",
          "            }",
          "        }",
          "        ",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "        ",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "        ",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            let cnt = src.len();",
          "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
          "            unsafe { self.advance_mut(cnt) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(5);",
          "    let n = -128i64;",
          "    let nbytes = 6;",
          "",
          "    // This should panic due to insufficient capacity",
          "    buf.put_int(n, nbytes);",
          "    assert_eq!(buf.remaining_mut(), 5);",
          "    assert!(std::panic::catch_unwind(|| buf.put_int(-128i64, 6)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(size: usize) -> Self {",
          "            Self {",
          "                data: vec![0; size],",
          "                pos: 0,",
          "            }",
          "        }",
          "        ",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "        ",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "        ",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            let cnt = src.len();",
          "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
          "            unsafe { self.advance_mut(cnt) };",
          "        }",
          "        ",
          "        fn assert_eq_data(&self, expected: &[u8]) {",
          "            assert_eq!(self.data, expected);",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(10);",
          "    let n = 0x0504010203i64;",
          "    let nbytes = 3;",
          "",
          "    buf.put_int(n, nbytes);",
          "    buf.assert_eq_data(&[0x01, 0x02, 0x03, 0, 0, 0, 0, 0, 0, 0]);",
          "}"
        ],
        "oracle": [
          "    buf.put_int(n, nbytes); assert_eq!(buf.remaining_mut(), 7);",
          "    panic_does_not_fit(nbytes, mem::size_of_val(&n));",
          "    buf.put_int(0x01i64, 9);",
          "    buf.put_int(0x0102030405060708i64, 8);",
          "    buf.assert_eq_data(&[0x01, 0x02, 0x03, 0, 0, 0, 0, 0, 0, 0]);"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(size: usize) -> Self {",
          "            Self {",
          "                data: vec![0; size],",
          "                pos: 0,",
          "            }",
          "        }",
          "        ",
          "        fn remaining_mut(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "        ",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "        ",
          "        fn put_slice(&mut self, src: &[u8]) {",
          "            let cnt = src.len();",
          "            self.data[self.pos..self.pos + cnt].copy_from_slice(src);",
          "            unsafe { self.advance_mut(cnt) };",
          "        }",
          "        ",
          "        fn assert_eq_data(&self, expected: &[u8]) {",
          "            assert_eq!(self.data, expected);",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(10);",
          "    let n = 0x0504010203i64;",
          "    let nbytes = 3;",
          "",
          "    buf.put_int(n, nbytes);",
          "    buf.assert_eq_data(&[0x01, 0x02, 0x03, 0, 0, 0, 0, 0, 0, 0]);",
          "    buf.put_int(n, nbytes); assert_eq!(buf.remaining_mut(), 7);",
          "    panic_does_not_fit(nbytes, mem::size_of_val(&n));",
          "    buf.put_int(0x01i64, 9);",
          "    buf.put_int(0x0102030405060708i64, 8);",
          "    buf.assert_eq_data(&[0x01, 0x02, 0x03, 0, 0, 0, 0, 0, 0, 0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]