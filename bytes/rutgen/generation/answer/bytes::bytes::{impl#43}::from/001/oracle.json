[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_slice: Box<[u8]> = Box::new([]);",
          "    let _bytes = Bytes::from(empty_slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_bytes.len(), 0);",
          "    assert!(_bytes.is_empty());",
          "    assert_eq!(_bytes.ptr, Bytes::new().ptr);",
          "    assert_eq!(_bytes.data.load(Ordering::SeqCst), ptr::null_mut());",
          "    assert_eq!(_bytes.vtable, &STATIC_VTABLE);"
        ],
        "code": [
          "{",
          "    let empty_slice: Box<[u8]> = Box::new([]);",
          "    let _bytes = Bytes::from(empty_slice);",
          "    assert_eq!(_bytes.len(), 0);",
          "    assert!(_bytes.is_empty());",
          "    assert_eq!(_bytes.ptr, Bytes::new().ptr);",
          "    assert_eq!(_bytes.data.load(Ordering::SeqCst), ptr::null_mut());",
          "    assert_eq!(_bytes.vtable, &STATIC_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let single_element_slice: Box<[u8]> = Box::new([1]);",
          "    let _bytes = Bytes::from(single_element_slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_bytes.len(), 0);",
          "    assert!(_bytes.is_empty());",
          "    assert_eq!(_bytes.ptr, ptr::null());",
          "    assert_eq!(_bytes.data.load(Ordering::SeqCst), ptr::null_mut());",
          "    assert_eq!(_bytes.vtable, &STATIC_VTABLE);"
        ],
        "code": [
          "{",
          "    let single_element_slice: Box<[u8]> = Box::new([1]);",
          "    let _bytes = Bytes::from(single_element_slice);",
          "    assert_eq!(_bytes.len(), 0);",
          "    assert!(_bytes.is_empty());",
          "    assert_eq!(_bytes.ptr, ptr::null());",
          "    assert_eq!(_bytes.data.load(Ordering::SeqCst), ptr::null_mut());",
          "    assert_eq!(_bytes.vtable, &STATIC_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let two_element_slice: Box<[u8]> = Box::new([1, 2]);",
          "    let _bytes = Bytes::from(two_element_slice);",
          "}"
        ],
        "oracle": [
          "    assert!(bytes.len() == 0);",
          "    assert!(bytes.is_empty());",
          "    assert!(bytes.ptr.is_null());",
          "    assert!(bytes.data.load(Ordering::SeqCst).is_null());",
          "    assert_eq!(bytes.vtable, &STATIC_VTABLE);"
        ],
        "code": [
          "{",
          "    let two_element_slice: Box<[u8]> = Box::new([1, 2]);",
          "    let _bytes = Bytes::from(two_element_slice);",
          "    assert!(bytes.len() == 0);",
          "    assert!(bytes.is_empty());",
          "    assert!(bytes.ptr.is_null());",
          "    assert!(bytes.data.load(Ordering::SeqCst).is_null());",
          "    assert_eq!(bytes.vtable, &STATIC_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]