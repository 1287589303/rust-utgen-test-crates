[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes.len(), 5);",
          "    assert!(bytes.is_empty());",
          "    assert_eq!(split.len(), 5);",
          "    assert_eq!(split.as_slice(), b\"hello\");",
          "    assert!(std::ptr::eq(bytes.as_ptr(), split.as_ptr().wrapping_sub(5)));"
        ],
        "code": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(0);",
          "    assert_eq!(bytes.len(), 5);",
          "    assert!(bytes.is_empty());",
          "    assert_eq!(split.len(), 5);",
          "    assert_eq!(split.as_slice(), b\"hello\");",
          "    assert!(std::ptr::eq(bytes.as_ptr(), split.as_ptr().wrapping_sub(5)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(6); // at > self.len()",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(bytes.len(), 5));",
          "    assert!(bytes.is_empty() == false);",
          "    assert_eq!(unsafe { bytes.as_slice() }, b\"hello\");",
          "    assert!(std::panic::catch_unwind(|| bytes.split_off(6)).is_err());"
        ],
        "code": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(6); // at > self.len()",
          "    assert!(matches!(bytes.len(), 5));",
          "    assert!(bytes.is_empty() == false);",
          "    assert_eq!(unsafe { bytes.as_slice() }, b\"hello\");",
          "    assert!(std::panic::catch_unwind(|| bytes.split_off(6)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let split = bytes.split_off(4);",
          "    assert_eq!(&bytes[..], b\"hell\");",
          "    assert_eq!(&split[..], b\"o\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes.len(), 5);",
          "    assert!(bytes.is_empty() == false);",
          "    assert_eq!(split.len(), 1);",
          "    assert_eq!(split.ptr, bytes.ptr.wrapping_add(4));",
          "    assert!(split.is_unique());",
          "    assert!(bytes.is_unique());"
        ],
        "code": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let split = bytes.split_off(4);",
          "    assert_eq!(&bytes[..], b\"hell\");",
          "    assert_eq!(&split[..], b\"o\");",
          "    assert_eq!(bytes.len(), 5);",
          "    assert!(bytes.is_empty() == false);",
          "    assert_eq!(split.len(), 1);",
          "    assert_eq!(split.ptr, bytes.ptr.wrapping_add(4));",
          "    assert!(split.is_unique());",
          "    assert!(bytes.is_unique());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(usize::MAX); // at < 0 (invalid in Rust)",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| {",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(usize::MAX);",
          "    }).is_err(), \"Expected panic for split_off with at == usize::MAX\");",
          "    ",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let result = bytes.split_off(0);",
          "    assert_eq!(result.len(), 5, \"Expected length of split to be 5 when at is 0\");",
          "    assert!(bytes.is_empty(), \"Expected original bytes to be empty after split_off with at == 0\");",
          "    ",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let panic_result = std::panic::catch_unwind(|| {",
          "    bytes.split_off(6); // at > len() (which is 5)",
          "    });",
          "    assert!(panic_result.is_err(), \"Expected panic for split_off with at > self.len()\");"
        ],
        "code": [
          "{",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(usize::MAX); // at < 0 (invalid in Rust)",
          "    assert!(std::panic::catch_unwind(|| {",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let _split = bytes.split_off(usize::MAX);",
          "    }).is_err(), \"Expected panic for split_off with at == usize::MAX\");",
          "    ",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let result = bytes.split_off(0);",
          "    assert_eq!(result.len(), 5, \"Expected length of split to be 5 when at is 0\");",
          "    assert!(bytes.is_empty(), \"Expected original bytes to be empty after split_off with at == 0\");",
          "    ",
          "    let mut bytes = Bytes::copy_from_slice(b\"hello\");",
          "    let panic_result = std::panic::catch_unwind(|| {",
          "    bytes.split_off(6); // at > len() (which is 5)",
          "    });",
          "    assert!(panic_result.is_err(), \"Expected panic for split_off with at > self.len()\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]