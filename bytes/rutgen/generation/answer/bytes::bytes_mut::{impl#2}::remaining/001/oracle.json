[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_mut = BytesMut::new();",
          "    let _ = bytes_mut.remaining();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.remaining(), 0);"
        ],
        "code": [
          "{",
          "    let bytes_mut = BytesMut::new();",
          "    let _ = bytes_mut.remaining();",
          "    assert_eq!(bytes_mut.remaining(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe { bytes_mut.set_len(5); }",
          "    let _ = bytes_mut.remaining();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert_eq!(bytes_mut.remaining(), 5);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    bytes_mut.clear();",
          "    assert_eq!(bytes_mut.remaining(), 0);",
          "    assert!(bytes_mut.is_empty() == true);",
          "    bytes_mut.resize(8, 0);",
          "    unsafe { bytes_mut.set_len(8); }",
          "    assert_eq!(bytes_mut.remaining(), 8);",
          "    bytes_mut.truncate(3);",
          "    assert_eq!(bytes_mut.remaining(), 3);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe { bytes_mut.set_len(5); }",
          "    let _ = bytes_mut.remaining();",
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert_eq!(bytes_mut.remaining(), 5);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    bytes_mut.clear();",
          "    assert_eq!(bytes_mut.remaining(), 0);",
          "    assert!(bytes_mut.is_empty() == true);",
          "    bytes_mut.resize(8, 0);",
          "    unsafe { bytes_mut.set_len(8); }",
          "    assert_eq!(bytes_mut.remaining(), 8);",
          "    bytes_mut.truncate(3);",
          "    assert_eq!(bytes_mut.remaining(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe { bytes_mut.set_len(10); }",
          "    let _ = bytes_mut.remaining();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.remaining(), 10);",
          "    let empty_bytes_mut = BytesMut::new();",
          "    assert_eq!(empty_bytes_mut.remaining(), 0);",
          "    let mut another_bytes_mut = BytesMut::with_capacity(20);",
          "    unsafe { another_bytes_mut.set_len(15); }",
          "    assert_eq!(another_bytes_mut.remaining(), 15);",
          "    unsafe { another_bytes_mut.set_len(0); }",
          "    assert_eq!(another_bytes_mut.remaining(), 0);",
          "    let mut small_bytes_mut = BytesMut::with_capacity(5);",
          "    unsafe { small_bytes_mut.set_len(5); }",
          "    assert_eq!(small_bytes_mut.remaining(), 5);",
          "    small_bytes_mut.clear();",
          "    assert_eq!(small_bytes_mut.remaining(), 0);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe { bytes_mut.set_len(10); }",
          "    let _ = bytes_mut.remaining();",
          "    assert_eq!(bytes_mut.remaining(), 10);",
          "    let empty_bytes_mut = BytesMut::new();",
          "    assert_eq!(empty_bytes_mut.remaining(), 0);",
          "    let mut another_bytes_mut = BytesMut::with_capacity(20);",
          "    unsafe { another_bytes_mut.set_len(15); }",
          "    assert_eq!(another_bytes_mut.remaining(), 15);",
          "    unsafe { another_bytes_mut.set_len(0); }",
          "    assert_eq!(another_bytes_mut.remaining(), 0);",
          "    let mut small_bytes_mut = BytesMut::with_capacity(5);",
          "    unsafe { small_bytes_mut.set_len(5); }",
          "    assert_eq!(small_bytes_mut.remaining(), 5);",
          "    small_bytes_mut.clear();",
          "    assert_eq!(small_bytes_mut.remaining(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    for i in 0..=10 {",
          "        unsafe { bytes_mut.set_len(i); }",
          "        let _ = bytes_mut.remaining();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.remaining(), 0); // when len is 0",
          "    unsafe { bytes_mut.set_len(1); }",
          "    assert_eq!(bytes_mut.remaining(), 1); // when len is 1",
          "    unsafe { bytes_mut.set_len(2); }",
          "    assert_eq!(bytes_mut.remaining(), 2); // when len is 2",
          "    unsafe { bytes_mut.set_len(3); }",
          "    assert_eq!(bytes_mut.remaining(), 3); // when len is 3",
          "    unsafe { bytes_mut.set_len(4); }",
          "    assert_eq!(bytes_mut.remaining(), 4); // when len is 4",
          "    unsafe { bytes_mut.set_len(5); }",
          "    assert_eq!(bytes_mut.remaining(), 5); // when len is 5",
          "    unsafe { bytes_mut.set_len(6); }",
          "    assert_eq!(bytes_mut.remaining(), 6); // when len is 6",
          "    unsafe { bytes_mut.set_len(7); }",
          "    assert_eq!(bytes_mut.remaining(), 7); // when len is 7",
          "    unsafe { bytes_mut.set_len(8); }",
          "    assert_eq!(bytes_mut.remaining(), 8); // when len is 8",
          "    unsafe { bytes_mut.set_len(9); }",
          "    assert_eq!(bytes_mut.remaining(), 9); // when len is 9",
          "    unsafe { bytes_mut.set_len(10); }",
          "    assert_eq!(bytes_mut.remaining(), 10); // when len is 10"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    for i in 0..=10 {",
          "        unsafe { bytes_mut.set_len(i); }",
          "        let _ = bytes_mut.remaining();",
          "    }",
          "    assert_eq!(bytes_mut.remaining(), 0); // when len is 0",
          "    unsafe { bytes_mut.set_len(1); }",
          "    assert_eq!(bytes_mut.remaining(), 1); // when len is 1",
          "    unsafe { bytes_mut.set_len(2); }",
          "    assert_eq!(bytes_mut.remaining(), 2); // when len is 2",
          "    unsafe { bytes_mut.set_len(3); }",
          "    assert_eq!(bytes_mut.remaining(), 3); // when len is 3",
          "    unsafe { bytes_mut.set_len(4); }",
          "    assert_eq!(bytes_mut.remaining(), 4); // when len is 4",
          "    unsafe { bytes_mut.set_len(5); }",
          "    assert_eq!(bytes_mut.remaining(), 5); // when len is 5",
          "    unsafe { bytes_mut.set_len(6); }",
          "    assert_eq!(bytes_mut.remaining(), 6); // when len is 6",
          "    unsafe { bytes_mut.set_len(7); }",
          "    assert_eq!(bytes_mut.remaining(), 7); // when len is 7",
          "    unsafe { bytes_mut.set_len(8); }",
          "    assert_eq!(bytes_mut.remaining(), 8); // when len is 8",
          "    unsafe { bytes_mut.set_len(9); }",
          "    assert_eq!(bytes_mut.remaining(), 9); // when len is 9",
          "    unsafe { bytes_mut.set_len(10); }",
          "    assert_eq!(bytes_mut.remaining(), 10); // when len is 10",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(usize::MAX);",
          "    unsafe { bytes_mut.set_len(usize::MAX); }",
          "    let _ = bytes_mut.remaining();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.remaining(), usize::MAX);",
          "    bytes_mut.len = usize::MAX;",
          "    assert!(bytes_mut.remaining() <= bytes_mut.capacity());",
          "    bytes_mut.clear();",
          "    assert_eq!(bytes_mut.remaining(), 0);",
          "    bytes_mut.resize(10, 1);",
          "    assert_eq!(bytes_mut.remaining(), 10);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(usize::MAX);",
          "    unsafe { bytes_mut.set_len(usize::MAX); }",
          "    let _ = bytes_mut.remaining();",
          "    assert_eq!(bytes_mut.remaining(), usize::MAX);",
          "    bytes_mut.len = usize::MAX;",
          "    assert!(bytes_mut.remaining() <= bytes_mut.capacity());",
          "    bytes_mut.clear();",
          "    assert_eq!(bytes_mut.remaining(), 0);",
          "    bytes_mut.resize(10, 1);",
          "    assert_eq!(bytes_mut.remaining(), 10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]