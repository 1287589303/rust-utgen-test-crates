[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut b1 = BytesMut::from(\"\");",
          "    let _ = b1.split_off(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(b1.len(), 0);",
          "    assert_eq!(b1.split_off(0).len(), 0);",
          "    assert!(b1.split_off(0).is_empty());"
        ],
        "code": [
          "{",
          "    let mut b1 = BytesMut::from(\"\");",
          "    let _ = b1.split_off(0);",
          "    assert_eq!(b1.len(), 0);",
          "    assert_eq!(b1.split_off(0).len(), 0);",
          "    assert!(b1.split_off(0).is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut b1 = BytesMut::from(\"a\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(b1.split_off(0).len(), 1);",
          "    assert_eq!(b1.split_off(1).len(), 0);",
          "    assert!(b1.split_off(0).is_empty() == false);",
          "    assert!(b1.split_off(1).is_empty() == true);"
        ],
        "code": [
          "{",
          "    let mut b1 = BytesMut::from(\"a\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(1);",
          "    assert_eq!(b1.split_off(0).len(), 1);",
          "    assert_eq!(b1.split_off(1).len(), 0);",
          "    assert!(b1.split_off(0).is_empty() == false);",
          "    assert!(b1.split_off(1).is_empty() == true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut b1 = BytesMut::from(\"ab\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(1);",
          "    let _ = b1.split_off(2);",
          "}"
        ],
        "oracle": [
          "    assert!(b1.split_off(0).len() == 2);",
          "    assert!(b1.split_off(1).len() == 1);",
          "    assert!(b1.split_off(2).len() == 0);"
        ],
        "code": [
          "{",
          "    let mut b1 = BytesMut::from(\"ab\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(1);",
          "    let _ = b1.split_off(2);",
          "    assert!(b1.split_off(0).len() == 2);",
          "    assert!(b1.split_off(1).len() == 1);",
          "    assert!(b1.split_off(2).len() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut b1 = BytesMut::from(\"abcdefghij\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(5);",
          "    let _ = b1.split_off(10);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(b1.split_off(0).len(), 10);",
          "    assert_eq!(b1.split_off(5).len(), 5);",
          "    assert_eq!(b1.split_off(10).len(), 0);",
          "    assert!(matches!(b1.split_off(5), BytesMut::from(\"fghij\")));",
          "    assert!(matches!(b1.split_off(0), BytesMut::from(\"abcdefghij\")));",
          "    assert!(panic::catch_unwind(|| b1.split_off(11)).is_err());"
        ],
        "code": [
          "{",
          "    let mut b1 = BytesMut::from(\"abcdefghij\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(5);",
          "    let _ = b1.split_off(10);",
          "    assert_eq!(b1.split_off(0).len(), 10);",
          "    assert_eq!(b1.split_off(5).len(), 5);",
          "    assert_eq!(b1.split_off(10).len(), 0);",
          "    assert!(matches!(b1.split_off(5), BytesMut::from(\"fghij\")));",
          "    assert!(matches!(b1.split_off(0), BytesMut::from(\"abcdefghij\")));",
          "    assert!(panic::catch_unwind(|| b1.split_off(11)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut b1 = BytesMut::from(\"abcdefghijk\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(5);",
          "    let _ = b1.split_off(11);",
          "}"
        ],
        "oracle": [
          "    let mut b1 = BytesMut::from(\"abcdefghijk\");",
          "    assert_eq!(b1.split_off(0).len(), 11);",
          "    assert_eq!(b1.split_off(5).len(), 6);",
          "    assert!(std::panic::catch_unwind(|| b1.split_off(11)).is_err());",
          "    assert_eq!(b1.len(), 0);"
        ],
        "code": [
          "{",
          "    let mut b1 = BytesMut::from(\"abcdefghijk\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(5);",
          "    let _ = b1.split_off(11);",
          "    let mut b1 = BytesMut::from(\"abcdefghijk\");",
          "    assert_eq!(b1.split_off(0).len(), 11);",
          "    assert_eq!(b1.split_off(5).len(), 6);",
          "    assert!(std::panic::catch_unwind(|| b1.split_off(11)).is_err());",
          "    assert_eq!(b1.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut b1 = BytesMut::from(\"hello world\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(6);",
          "    let _ = b1.split_off(11);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(b1.len(), 11);",
          "    assert_eq!(b1.split_off(0).len(), 11);",
          "    assert_eq!(b1.split_off(6).len(), 5);",
          "    assert_eq!(b1.split_off(11).len(), 0);",
          "    assert!(b1.split_off(6).is_empty());",
          "    assert!(b1.split_off(11).is_empty());",
          "    assert!(b1.is_empty());",
          "    assert_eq!(b1.as_ref(), &b\"hello world\"[..]);",
          "    assert_eq!(b1.split_off(6).as_ref(), &b\"world\"[..]);",
          "    assert_eq!(b1.split_off(0).as_ref(), &b\"hello world\"[..]);"
        ],
        "code": [
          "{",
          "    let mut b1 = BytesMut::from(\"hello world\");",
          "    let _ = b1.split_off(0);",
          "    let _ = b1.split_off(6);",
          "    let _ = b1.split_off(11);",
          "    assert_eq!(b1.len(), 11);",
          "    assert_eq!(b1.split_off(0).len(), 11);",
          "    assert_eq!(b1.split_off(6).len(), 5);",
          "    assert_eq!(b1.split_off(11).len(), 0);",
          "    assert!(b1.split_off(6).is_empty());",
          "    assert!(b1.split_off(11).is_empty());",
          "    assert!(b1.is_empty());",
          "    assert_eq!(b1.as_ref(), &b\"hello world\"[..]);",
          "    assert_eq!(b1.split_off(6).as_ref(), &b\"world\"[..]);",
          "    assert_eq!(b1.split_off(0).as_ref(), &b\"hello world\"[..]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]