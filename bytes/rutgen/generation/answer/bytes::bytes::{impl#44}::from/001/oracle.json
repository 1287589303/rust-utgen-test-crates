[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(BytesMut::from(Bytes::from(b\"hello\".to_vec())), BytesMut::from(&b\"hello\"[..]));",
          "    let empty_bytes = Bytes { ptr: std::ptr::null(), len: 0, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE };",
          "    let _empty_bytes_mut = BytesMut::from(empty_bytes);",
          "    let non_unique_bytes = Bytes { ptr: std::ptr::null(), len: 10, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let _non_unique_bytes_mut = BytesMut::from(non_unique_bytes);",
          "    let unique_bytes = Bytes { ptr: std::ptr::null(), len: 5, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &KIND_VEC };",
          "    let _unique_bytes_mut = BytesMut::from(unique_bytes);",
          "    assert_ne!(BytesMut::from(Bytes::from(b\"world\".to_vec())), BytesMut::from(&b\"hello\"[..]));"
        ],
        "code": [
          "{",
          "    let bytes = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "    assert_eq!(BytesMut::from(Bytes::from(b\"hello\".to_vec())), BytesMut::from(&b\"hello\"[..]));",
          "    let empty_bytes = Bytes { ptr: std::ptr::null(), len: 0, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE };",
          "    let _empty_bytes_mut = BytesMut::from(empty_bytes);",
          "    let non_unique_bytes = Bytes { ptr: std::ptr::null(), len: 10, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let _non_unique_bytes_mut = BytesMut::from(non_unique_bytes);",
          "    let unique_bytes = Bytes { ptr: std::ptr::null(), len: 5, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &KIND_VEC };",
          "    let _unique_bytes_mut = BytesMut::from(unique_bytes);",
          "    assert_ne!(BytesMut::from(Bytes::from(b\"world\".to_vec())), BytesMut::from(&b\"hello\"[..]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let single_byte: Vec<u8> = vec![42];",
          "    let bytes = Bytes {",
          "        ptr: single_byte.as_ptr(),",
          "        len: single_byte.len(),",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_bytes_mut.len(), 1);",
          "    assert_eq!(*_bytes_mut.ptr(), 42);",
          "    assert_eq!(_bytes_mut.cap, 1);",
          "    assert!(_bytes_mut.ptr().is_unique());"
        ],
        "code": [
          "{",
          "    let single_byte: Vec<u8> = vec![42];",
          "    let bytes = Bytes {",
          "        ptr: single_byte.as_ptr(),",
          "        len: single_byte.len(),",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "    assert_eq!(_bytes_mut.len(), 1);",
          "    assert_eq!(*_bytes_mut.ptr(), 42);",
          "    assert_eq!(_bytes_mut.cap, 1);",
          "    assert!(_bytes_mut.ptr().is_unique());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let multiple_bytes: Vec<u8> = (0..10).collect();",
          "    let bytes = Bytes {",
          "        ptr: multiple_bytes.as_ptr(),",
          "        len: multiple_bytes.len(),",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_bytes_mut.len(), 10);",
          "    assert_eq!(_bytes_mut.as_ref(), &multiple_bytes[..]);",
          "    assert_ne!(bytes.data.load(Ordering::SeqCst), std::ptr::null_mut());",
          "    assert!(bytes.vtable.is_unique());",
          "    assert_eq!(BytesMut::from(Bytes::from(b\"example\".to_vec())), BytesMut::from(&b\"example\"[..]));",
          "    assert_eq!(BytesMut::from(Bytes::from(b\"test\".to_vec())), BytesMut::from(&b\"test\"[..]));",
          "    assert!(std::ptr::eq(_bytes_mut.as_ptr(), multiple_bytes.as_ptr()));"
        ],
        "code": [
          "{",
          "    let multiple_bytes: Vec<u8> = (0..10).collect();",
          "    let bytes = Bytes {",
          "        ptr: multiple_bytes.as_ptr(),",
          "        len: multiple_bytes.len(),",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "    assert_eq!(_bytes_mut.len(), 10);",
          "    assert_eq!(_bytes_mut.as_ref(), &multiple_bytes[..]);",
          "    assert_ne!(bytes.data.load(Ordering::SeqCst), std::ptr::null_mut());",
          "    assert!(bytes.vtable.is_unique());",
          "    assert_eq!(BytesMut::from(Bytes::from(b\"example\".to_vec())), BytesMut::from(&b\"example\"[..]));",
          "    assert_eq!(BytesMut::from(Bytes::from(b\"test\".to_vec())), BytesMut::from(&b\"test\"[..]));",
          "    assert!(std::ptr::eq(_bytes_mut.as_ptr(), multiple_bytes.as_ptr()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let large_buffer: Vec<u8> = vec![0; std::usize::MAX];",
          "    let bytes = Bytes {",
          "        ptr: large_buffer.as_ptr(),",
          "        len: large_buffer.len(),",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert!(std::mem::size_of::<BytesMut>() > 0);",
          "    assert_eq!(std::mem::align_of::<BytesMut>(), std::mem::align_of::<NonNull<u8>>());",
          "    assert_eq!(std::mem::align_of::<BytesMut>(), std::mem::align_of::<usize>());",
          "    assert!(std::ptr::null_mut() as *mut Shared == std::ptr::null_mut());",
          "    assert!(unsafe { BytesMut::from(Bytes { ptr: std::ptr::null(), len: 0, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE }) }.len == 0);",
          "    assert_eq!(BytesMut::from(Bytes { ptr: large_buffer.as_ptr(), len: large_buffer.len(), data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE }).len, large_buffer.len());",
          "    assert!(std::panic::catch_unwind(|| { BytesMut::from(Bytes { ptr: std::ptr::null(), len: 1, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE }) }).is_err());",
          "    assert!(std::panic::catch_unwind(|| {",
          "    BytesMut::from(Bytes { ptr: large_buffer.as_ptr(), len: std::usize::MAX, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE })",
          "    }).is_err());",
          "    assert!(std::ptr::eq(large_buffer.as_ptr(), {",
          "    let bytes = Bytes { ptr: large_buffer.as_ptr(), len: large_buffer.len(), data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE };",
          "    let bytes_mut = BytesMut::from(bytes);",
          "    bytes_mut.ptr.as_ptr()",
          "    }));",
          "    assert!(std::panic::catch_unwind(|| {",
          "    BytesMut::from(Bytes { ptr: large_buffer.as_ptr(), len: large_buffer.len() + 1, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE })",
          "    }).is_err());"
        ],
        "code": [
          "{",
          "    let large_buffer: Vec<u8> = vec![0; std::usize::MAX];",
          "    let bytes = Bytes {",
          "        ptr: large_buffer.as_ptr(),",
          "        len: large_buffer.len(),",
          "        data: AtomicPtr::new(std::ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _bytes_mut = BytesMut::from(bytes);",
          "    assert!(std::mem::size_of::<BytesMut>() > 0);",
          "    assert_eq!(std::mem::align_of::<BytesMut>(), std::mem::align_of::<NonNull<u8>>());",
          "    assert_eq!(std::mem::align_of::<BytesMut>(), std::mem::align_of::<usize>());",
          "    assert!(std::ptr::null_mut() as *mut Shared == std::ptr::null_mut());",
          "    assert!(unsafe { BytesMut::from(Bytes { ptr: std::ptr::null(), len: 0, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE }) }.len == 0);",
          "    assert_eq!(BytesMut::from(Bytes { ptr: large_buffer.as_ptr(), len: large_buffer.len(), data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE }).len, large_buffer.len());",
          "    assert!(std::panic::catch_unwind(|| { BytesMut::from(Bytes { ptr: std::ptr::null(), len: 1, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE }) }).is_err());",
          "    assert!(std::panic::catch_unwind(|| {",
          "    BytesMut::from(Bytes { ptr: large_buffer.as_ptr(), len: std::usize::MAX, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE })",
          "    }).is_err());",
          "    assert!(std::ptr::eq(large_buffer.as_ptr(), {",
          "    let bytes = Bytes { ptr: large_buffer.as_ptr(), len: large_buffer.len(), data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE };",
          "    let bytes_mut = BytesMut::from(bytes);",
          "    bytes_mut.ptr.as_ptr()",
          "    }));",
          "    assert!(std::panic::catch_unwind(|| {",
          "    BytesMut::from(Bytes { ptr: large_buffer.as_ptr(), len: large_buffer.len() + 1, data: AtomicPtr::new(std::ptr::null_mut()), vtable: &OWNED_VTABLE })",
          "    }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]