[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(16);",
          "    buf.resize(16, 0); // Fill to capacity",
          "    buf.reserve(1); // additional > rem (which is 0)",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.capacity(), 32);",
          "    assert!(buf.len() == 16);",
          "    assert!(buf.is_empty() == false);",
          "    assert!(buf.as_slice() == &[0; 16]);",
          "    assert!(buf.ptr != NonNull::new(ptr::null_mut()).unwrap());",
          "    assert!(buf.cap >= 17);"
        ],
        "code": [
          "{",
          "    let mut buf = BytesMut::with_capacity(16);",
          "    buf.resize(16, 0); // Fill to capacity",
          "    buf.reserve(1); // additional > rem (which is 0)",
          "    assert_eq!(buf.capacity(), 32);",
          "    assert!(buf.len() == 16);",
          "    assert!(buf.is_empty() == false);",
          "    assert!(buf.as_slice() == &[0; 16]);",
          "    assert!(buf.ptr != NonNull::new(ptr::null_mut()).unwrap());",
          "    assert!(buf.cap >= 17);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(128);",
          "    buf.resize(64, 0); // current length is 64, capacity is 128",
          "    buf.reserve(100); // additional > rem (which is 64)",
          "}"
        ],
        "oracle": [
          "    assert!(buf.capacity() >= 228);",
          "    assert!(!buf.is_empty());",
          "    assert_eq!(buf.len(), 64);",
          "    assert_eq!(buf.capacity(), 228);",
          "    assert_eq!(buf.as_slice()[..64], [0; 64][..]);"
        ],
        "code": [
          "{",
          "    let mut buf = BytesMut::with_capacity(128);",
          "    buf.resize(64, 0); // current length is 64, capacity is 128",
          "    buf.reserve(100); // additional > rem (which is 64)",
          "    assert!(buf.capacity() >= 228);",
          "    assert!(!buf.is_empty());",
          "    assert_eq!(buf.len(), 64);",
          "    assert_eq!(buf.capacity(), 228);",
          "    assert_eq!(buf.as_slice()[..64], [0; 64][..]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(32);",
          "    buf.resize(32, 0); // Fill to capacity",
          "    buf.reserve(17); // additional > rem (which is 0)",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.capacity(), 32);",
          "    assert!(buf.len() == 32);",
          "    assert!(buf.is_empty() == false);",
          "    assert!(buf.spare_capacity_mut().len() == 0);",
          "    assert!(buf.ptr.as_ptr() != std::ptr::null_mut());",
          "    assert!(mem::size_of_val(&buf) > 0);",
          "    assert!(buf.reserve_inner(17, true) == true);"
        ],
        "code": [
          "{",
          "    let mut buf = BytesMut::with_capacity(32);",
          "    buf.resize(32, 0); // Fill to capacity",
          "    buf.reserve(17); // additional > rem (which is 0)",
          "    assert_eq!(buf.capacity(), 32);",
          "    assert!(buf.len() == 32);",
          "    assert!(buf.is_empty() == false);",
          "    assert!(buf.spare_capacity_mut().len() == 0);",
          "    assert!(buf.ptr.as_ptr() != std::ptr::null_mut());",
          "    assert!(mem::size_of_val(&buf) > 0);",
          "    assert!(buf.reserve_inner(17, true) == true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(64);",
          "    buf.resize(32, 0); // current length is 32, capacity is 64",
          "    buf.reserve(33); // additional > rem (which is 32)",
          "}"
        ],
        "oracle": [
          "    assert!(buf.capacity() > 64);",
          "    assert!(buf.len() == 32);",
          "    assert!(buf.is_empty() == false);",
          "    assert!(buf.capacity() >= 97);"
        ],
        "code": [
          "{",
          "    let mut buf = BytesMut::with_capacity(64);",
          "    buf.resize(32, 0); // current length is 32, capacity is 64",
          "    buf.reserve(33); // additional > rem (which is 32)",
          "    assert!(buf.capacity() > 64);",
          "    assert!(buf.len() == 32);",
          "    assert!(buf.is_empty() == false);",
          "    assert!(buf.capacity() >= 97);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]