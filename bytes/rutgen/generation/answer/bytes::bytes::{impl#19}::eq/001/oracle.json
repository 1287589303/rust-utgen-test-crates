[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data1: Vec<u8> = vec![1, 2, 3];",
          "    let data2: Vec<u8> = vec![1, 2, 3];",
          "",
          "    let bytes1 = Bytes {",
          "        ptr: data1.as_ptr(),",
          "        len: data1.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: data2.as_ptr(),",
          "        len: data2.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes1.eq(&bytes2), true);",
          "    let data3: Vec<u8> = vec![4, 5, 6];",
          "    let bytes3 = Bytes {",
          "    ptr: data3.as_ptr(),",
          "    len: data3.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes3), false);",
          "    let empty_bytes = Bytes {",
          "    ptr: ptr::null(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&empty_bytes), false);",
          "    let identical_bytes = Bytes {",
          "    ptr: data1.as_ptr(),",
          "    len: data1.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&identical_bytes), true);"
        ],
        "code": [
          "{",
          "    let data1: Vec<u8> = vec![1, 2, 3];",
          "    let data2: Vec<u8> = vec![1, 2, 3];",
          "",
          "    let bytes1 = Bytes {",
          "        ptr: data1.as_ptr(),",
          "        len: data1.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: data2.as_ptr(),",
          "        len: data2.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "    assert_eq!(bytes1.eq(&bytes2), true);",
          "    let data3: Vec<u8> = vec![4, 5, 6];",
          "    let bytes3 = Bytes {",
          "    ptr: data3.as_ptr(),",
          "    len: data3.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes3), false);",
          "    let empty_bytes = Bytes {",
          "    ptr: ptr::null(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&empty_bytes), false);",
          "    let identical_bytes = Bytes {",
          "    ptr: data1.as_ptr(),",
          "    len: data1.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&identical_bytes), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: Vec<u8> = vec![1, 2, 3];",
          "",
          "    let bytes1 = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes1.eq(&bytes2), false);",
          "    let bytes3 = Bytes {",
          "    ptr: data.as_ptr(),",
          "    len: data.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes3), true);",
          "    let bytes4 = Bytes {",
          "    ptr: ptr::null(),",
          "    len: data.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes4), false);",
          "    let bytes5 = Bytes {",
          "    ptr: data.as_ptr(),",
          "    len: data.len() + 1,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes5), false);",
          "    let bytes6 = Bytes {",
          "    ptr: data.as_ptr(),",
          "    len: data.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes6), true);"
        ],
        "code": [
          "{",
          "    let data: Vec<u8> = vec![1, 2, 3];",
          "",
          "    let bytes1 = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "    assert_eq!(bytes1.eq(&bytes2), false);",
          "    let bytes3 = Bytes {",
          "    ptr: data.as_ptr(),",
          "    len: data.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes3), true);",
          "    let bytes4 = Bytes {",
          "    ptr: ptr::null(),",
          "    len: data.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes4), false);",
          "    let bytes5 = Bytes {",
          "    ptr: data.as_ptr(),",
          "    len: data.len() + 1,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes5), false);",
          "    let bytes6 = Bytes {",
          "    ptr: data.as_ptr(),",
          "    len: data.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes6), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data1: Vec<u8> = vec![1, 2, 3];",
          "    let data2: Vec<u8> = vec![4, 5, 6];",
          "",
          "    let bytes1 = Bytes {",
          "        ptr: data1.as_ptr(),",
          "        len: data1.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: data2.as_ptr(),",
          "        len: data2.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes1.eq(&bytes2), false);",
          "    let data3: Vec<u8> = vec![1, 2, 3];",
          "    let bytes3 = Bytes {",
          "    ptr: data3.as_ptr(),",
          "    len: data3.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes3), true);",
          "    assert_eq!(bytes1.eq(&bytes1), true);",
          "    assert_eq!(bytes2.eq(&bytes2), true);",
          "    assert_eq!(bytes1.eq(&bytes2), false);"
        ],
        "code": [
          "{",
          "    let data1: Vec<u8> = vec![1, 2, 3];",
          "    let data2: Vec<u8> = vec![4, 5, 6];",
          "",
          "    let bytes1 = Bytes {",
          "        ptr: data1.as_ptr(),",
          "        len: data1.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: data2.as_ptr(),",
          "        len: data2.len(),",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "    assert_eq!(bytes1.eq(&bytes2), false);",
          "    let data3: Vec<u8> = vec![1, 2, 3];",
          "    let bytes3 = Bytes {",
          "    ptr: data3.as_ptr(),",
          "    len: data3.len(),",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes1.eq(&bytes3), true);",
          "    assert_eq!(bytes1.eq(&bytes1), true);",
          "    assert_eq!(bytes2.eq(&bytes2), true);",
          "    assert_eq!(bytes1.eq(&bytes2), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes1 = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes1.eq(&bytes2), true);"
        ],
        "code": [
          "{",
          "    let bytes1 = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let bytes2 = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "",
          "    let _ = bytes1.eq(&bytes2);",
          "    assert_eq!(bytes1.eq(&bytes2), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]