[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buffer: [u8; 0] = [];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    let buffer: [u8; 0] = [];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    assert!(slice.is_null() == false);"
        ],
        "code": [
          "{",
          "    let mut buffer: [u8; 0] = [];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    let buffer: [u8; 0] = [];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    assert!(slice.is_null() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buffer = [1u8; 10];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    let mut buffer = [0u8; 64];",
          "    let slice = UninitSlice::new(&mut buffer[..]);",
          "    assert_eq!(slice.len(), 64);",
          "    let slice_ptr = slice.as_mut_ptr();",
          "    assert!(!slice_ptr.is_null());",
          "    let uninit_slice = unsafe { slice.as_uninit_slice_mut() };",
          "    assert_eq!(uninit_slice.len(), 64);",
          "    let byte_value: u8 = 42;",
          "    slice.write_byte(0, byte_value);",
          "    assert_eq!(buffer[0], byte_value);",
          "    let src = [5u8; 10];",
          "    slice.copy_from_slice(&src);",
          "    assert_eq!(&buffer[..10], &src[..]);"
        ],
        "code": [
          "{",
          "    let mut buffer = [1u8; 10];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    let mut buffer = [0u8; 64];",
          "    let slice = UninitSlice::new(&mut buffer[..]);",
          "    assert_eq!(slice.len(), 64);",
          "    let slice_ptr = slice.as_mut_ptr();",
          "    assert!(!slice_ptr.is_null());",
          "    let uninit_slice = unsafe { slice.as_uninit_slice_mut() };",
          "    assert_eq!(uninit_slice.len(), 64);",
          "    let byte_value: u8 = 42;",
          "    slice.write_byte(0, byte_value);",
          "    assert_eq!(buffer[0], byte_value);",
          "    let src = [5u8; 10];",
          "    slice.copy_from_slice(&src);",
          "    assert_eq!(&buffer[..10], &src[..]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buffer = [2u8; 64];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice.len(), 64);",
          "    assert!(slice.as_mut_ptr() == buffer.as_mut_ptr());",
          "    let uninit_slice_ref: &mut UninitSlice = UninitSlice::new(&mut buffer);",
          "    assert!(std::ptr::eq(uninit_slice_ref as *mut _, slice as *mut _));",
          "    for i in 0..64 {",
          "    assert_eq!(unsafe { buffer[i] }, 2);",
          "    }"
        ],
        "code": [
          "{",
          "    let mut buffer = [2u8; 64];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    assert_eq!(slice.len(), 64);",
          "    assert!(slice.as_mut_ptr() == buffer.as_mut_ptr());",
          "    let uninit_slice_ref: &mut UninitSlice = UninitSlice::new(&mut buffer);",
          "    assert!(std::ptr::eq(uninit_slice_ref as *mut _, slice as *mut _));",
          "    for i in 0..64 {",
          "    assert_eq!(unsafe { buffer[i] }, 2);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buffer = [3u8; 32];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    let mut buffer = [3u8; 32];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    assert!(slice.len() == 32);",
          "    assert_eq!(slice.as_mut_ptr(), buffer.as_mut_ptr());"
        ],
        "code": [
          "{",
          "    let mut buffer = [3u8; 32];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    let mut buffer = [3u8; 32];",
          "    let slice = UninitSlice::new(&mut buffer);",
          "    assert!(slice.len() == 32);",
          "    assert_eq!(slice.as_mut_ptr(), buffer.as_mut_ptr());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]