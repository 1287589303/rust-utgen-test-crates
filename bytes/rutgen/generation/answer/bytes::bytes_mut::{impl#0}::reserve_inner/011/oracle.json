[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(10);",
          "        BytesMut::from_vec(v)",
          "    };",
          "    ",
          "    // Setting up preconditions.",
          "    let additional = 5;",
          "    unsafe { bytes_mut.reserve_inner(additional, true); }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.cap, 10);",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.len() + additional <= bytes_mut.capacity());",
          "    assert!(bytes_mut.kind() == KIND_ARC);",
          "    assert!(bytes_mut.is_unique());",
          "    assert_eq!(bytes_mut.capacity(), 10);",
          "    assert!(bytes_mut.spare_capacity_mut().len() > 0);",
          "    assert!(bytes_mut.ptr.as_ptr() == bytes_mut.data.as_ptr());",
          "    assert!(bytes_mut.ptr.as_ptr() != bytes_mut.data.as_ptr());",
          "    assert!(unsafe { bytes_mut.get_vec_pos() } == 0);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(10);",
          "        BytesMut::from_vec(v)",
          "    };",
          "    ",
          "    // Setting up preconditions.",
          "    let additional = 5;",
          "    unsafe { bytes_mut.reserve_inner(additional, true); }",
          "    assert_eq!(bytes_mut.cap, 10);",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.len() + additional <= bytes_mut.capacity());",
          "    assert!(bytes_mut.kind() == KIND_ARC);",
          "    assert!(bytes_mut.is_unique());",
          "    assert_eq!(bytes_mut.capacity(), 10);",
          "    assert!(bytes_mut.spare_capacity_mut().len() > 0);",
          "    assert!(bytes_mut.ptr.as_ptr() == bytes_mut.data.as_ptr());",
          "    assert!(bytes_mut.ptr.as_ptr() != bytes_mut.data.as_ptr());",
          "    assert!(unsafe { bytes_mut.get_vec_pos() } == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(12);",
          "        BytesMut::from_vec(v)",
          "    };",
          "",
          "    // Setting up preconditions.",
          "    let additional = 10;",
          "    let _ = unsafe { bytes_mut.reserve_inner(additional, true) };",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert_eq!(bytes_mut.capacity(), 12);",
          "    assert_eq!(bytes_mut.ptr.as_ptr(), bytes_mut.data as *mut u8);",
          "    assert!(bytes_mut.is_empty());",
          "    assert!(bytes_mut.try_reclaim(10));",
          "    assert!(bytes_mut.capacity() >= 12);",
          "    assert!(bytes_mut.capacity() > 0);",
          "    assert!(bytes_mut.cap >= additional);",
          "    assert!(bytes_mut.len() + additional <= bytes_mut.capacity());",
          "    assert!(bytes_mut.spare_capacity_mut().len() >= additional);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(12);",
          "        BytesMut::from_vec(v)",
          "    };",
          "",
          "    // Setting up preconditions.",
          "    let additional = 10;",
          "    let _ = unsafe { bytes_mut.reserve_inner(additional, true) };",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert_eq!(bytes_mut.capacity(), 12);",
          "    assert_eq!(bytes_mut.ptr.as_ptr(), bytes_mut.data as *mut u8);",
          "    assert!(bytes_mut.is_empty());",
          "    assert!(bytes_mut.try_reclaim(10));",
          "    assert!(bytes_mut.capacity() >= 12);",
          "    assert!(bytes_mut.capacity() > 0);",
          "    assert!(bytes_mut.cap >= additional);",
          "    assert!(bytes_mut.len() + additional <= bytes_mut.capacity());",
          "    assert!(bytes_mut.spare_capacity_mut().len() >= additional);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(20);",
          "        BytesMut::from_vec(v)",
          "    };",
          "",
          "    // Setting up preconditions.",
          "    let additional = 7;",
          "    let _ = unsafe { bytes_mut.reserve_inner(additional, true) };",
          "}"
        ],
        "oracle": [
          "    let mut bytes_mut = { let v = Vec::with_capacity(20); BytesMut::from_vec(v) };",
          "    let additional = 7;",
          "    let result = unsafe { bytes_mut.reserve_inner(additional, true) };",
          "    assert_eq!(result, true);",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.capacity() > 20);",
          "    assert!(bytes_mut.kind() != KIND_VEC);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize % mem::align_of::<u8>(), 0);",
          "    assert_eq!(bytes_mut.cap, bytes_mut.capacity());",
          "    assert!(unsafe { (*bytes_mut.data).is_unique() });",
          "    assert!(unsafe { (*bytes_mut.data).vec.capacity() < bytes_mut.cap });",
          "    assert!(bytes_mut.ptr.as_ptr() != core::ptr::null_mut());"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(20);",
          "        BytesMut::from_vec(v)",
          "    };",
          "",
          "    // Setting up preconditions.",
          "    let additional = 7;",
          "    let _ = unsafe { bytes_mut.reserve_inner(additional, true) };",
          "    let mut bytes_mut = { let v = Vec::with_capacity(20); BytesMut::from_vec(v) };",
          "    let additional = 7;",
          "    let result = unsafe { bytes_mut.reserve_inner(additional, true) };",
          "    assert_eq!(result, true);",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.capacity() > 20);",
          "    assert!(bytes_mut.kind() != KIND_VEC);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize % mem::align_of::<u8>(), 0);",
          "    assert_eq!(bytes_mut.cap, bytes_mut.capacity());",
          "    assert!(unsafe { (*bytes_mut.data).is_unique() });",
          "    assert!(unsafe { (*bytes_mut.data).vec.capacity() < bytes_mut.cap });",
          "    assert!(bytes_mut.ptr.as_ptr() != core::ptr::null_mut());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(15);",
          "        BytesMut::from_vec(v)",
          "    };",
          "    ",
          "    // Setting up preconditions.",
          "    let additional = 4;",
          "    unsafe { bytes_mut.reserve_inner(additional, true); }",
          "}"
        ],
        "oracle": [
          "    assert!(bytes_mut.kind() != KIND_VEC);",
          "    assert!(bytes_mut.len() + additional == bytes_mut.capacity());",
          "    assert!(bytes_mut.len().checked_add(additional) == Some(new_cap));",
          "    assert!(bytes_mut.data as usize & KIND_MASK != KIND_ARC);",
          "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_VEC);",
          "    assert!(bytes_mut.capacity() >= new_cap);",
          "    assert!(bytes_mut.data as usize & NOT_VEC_POS_MASK == 0);",
          "    assert!(bytes_mut.len() <= bytes_mut.capacity());",
          "    assert!(unsafe { (*bytes_mut.data).is_unique() });",
          "    assert!(bytes_mut.capacity() >= new_cap && bytes_mut.len() < (bytes_mut.capacity() - additional));",
          "    assert!(bytes_mut.len() >= 0);",
          "    assert!(unsafe { bytes_mut.get_vec_pos() < bytes_mut.len() });",
          "    assert!(unsafe { bytes_mut.as_slice().len() == bytes_mut.len() });",
          "    assert!(bytes_mut.capacity() >= bytes_mut.len());"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let v = Vec::with_capacity(15);",
          "        BytesMut::from_vec(v)",
          "    };",
          "    ",
          "    // Setting up preconditions.",
          "    let additional = 4;",
          "    unsafe { bytes_mut.reserve_inner(additional, true); }",
          "    assert!(bytes_mut.kind() != KIND_VEC);",
          "    assert!(bytes_mut.len() + additional == bytes_mut.capacity());",
          "    assert!(bytes_mut.len().checked_add(additional) == Some(new_cap));",
          "    assert!(bytes_mut.data as usize & KIND_MASK != KIND_ARC);",
          "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_VEC);",
          "    assert!(bytes_mut.capacity() >= new_cap);",
          "    assert!(bytes_mut.data as usize & NOT_VEC_POS_MASK == 0);",
          "    assert!(bytes_mut.len() <= bytes_mut.capacity());",
          "    assert!(unsafe { (*bytes_mut.data).is_unique() });",
          "    assert!(bytes_mut.capacity() >= new_cap && bytes_mut.len() < (bytes_mut.capacity() - additional));",
          "    assert!(bytes_mut.len() >= 0);",
          "    assert!(unsafe { bytes_mut.get_vec_pos() < bytes_mut.len() });",
          "    assert!(unsafe { bytes_mut.as_slice().len() == bytes_mut.len() });",
          "    assert!(bytes_mut.capacity() >= bytes_mut.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]