[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let shared = Box::into_raw(Box::new(Shared {",
          "            buf: std::ptr::null_mut(),",
          "            cap: 10,",
          "            ref_cnt: AtomicUsize::new(1),",
          "        }));",
          "        BytesMut {",
          "            ptr: NonNull::new(std::ptr::null_mut()).unwrap(),",
          "            len: 5,",
          "            cap: 10,",
          "            data: shared.cast(),",
          "        }",
          "    };",
          "",
          "    let additional = 5; // greater than 0",
          "    let allocate = false; // set allocate to false",
          "",
          "    let result = bytes_mut.reserve_inner(additional, allocate);",
          "}"
        ],
        "oracle": [
          "    let bytes_mut = BytesMut::new();",
          "    let additional = 5;",
          "    let allocate = false;",
          "    assert_eq!(bytes_mut.reserve_inner(additional, allocate), false);",
          "    let shared = Box::into_raw(Box::new(Shared { buf: std::ptr::null_mut(), cap: 15, ref_cnt: AtomicUsize::new(1) }));",
          "    bytes_mut.data = shared.cast();",
          "    bytes_mut.len = 10;",
          "    bytes_mut.cap = 15;",
          "    assert_eq!(bytes_mut.reserve_inner(10, false), false);",
          "    let len = bytes_mut.len();",
          "    assert_eq!(len.checked_add(10), Some(20));",
          "    let mut shared_test = Shared { buf: std::ptr::null_mut(), cap: 8, ref_cnt: AtomicUsize::new(1) };",
          "    let v_capacity = shared_test.cap;",
          "    assert!(v_capacity < 20);",
          "    bytes_mut.data = &mut shared_test as *mut _;",
          "    assert_eq!(bytes_mut.reserve_inner(additional, allocate), false);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let shared = Box::into_raw(Box::new(Shared {",
          "            buf: std::ptr::null_mut(),",
          "            cap: 10,",
          "            ref_cnt: AtomicUsize::new(1),",
          "        }));",
          "        BytesMut {",
          "            ptr: NonNull::new(std::ptr::null_mut()).unwrap(),",
          "            len: 5,",
          "            cap: 10,",
          "            data: shared.cast(),",
          "        }",
          "    };",
          "",
          "    let additional = 5; // greater than 0",
          "    let allocate = false; // set allocate to false",
          "",
          "    let result = bytes_mut.reserve_inner(additional, allocate);",
          "    let bytes_mut = BytesMut::new();",
          "    let additional = 5;",
          "    let allocate = false;",
          "    assert_eq!(bytes_mut.reserve_inner(additional, allocate), false);",
          "    let shared = Box::into_raw(Box::new(Shared { buf: std::ptr::null_mut(), cap: 15, ref_cnt: AtomicUsize::new(1) }));",
          "    bytes_mut.data = shared.cast();",
          "    bytes_mut.len = 10;",
          "    bytes_mut.cap = 15;",
          "    assert_eq!(bytes_mut.reserve_inner(10, false), false);",
          "    let len = bytes_mut.len();",
          "    assert_eq!(len.checked_add(10), Some(20));",
          "    let mut shared_test = Shared { buf: std::ptr::null_mut(), cap: 8, ref_cnt: AtomicUsize::new(1) };",
          "    let v_capacity = shared_test.cap;",
          "    assert!(v_capacity < 20);",
          "    bytes_mut.data = &mut shared_test as *mut _;",
          "    assert_eq!(bytes_mut.reserve_inner(additional, allocate), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let shared = Box::into_raw(Box::new(Shared {",
          "            buf: std::ptr::null_mut(),",
          "            cap: 10,",
          "            ref_cnt: AtomicUsize::new(1),",
          "        }));",
          "        BytesMut {",
          "            ptr: NonNull::new(std::ptr::null_mut()).unwrap(),",
          "            len: 5,",
          "            cap: 8, // less than len + additional",
          "            data: shared.cast(),",
          "        }",
          "    };",
          "",
          "    let additional = 5; // greater than 0",
          "    let allocate = false; // set allocate to false",
          "",
          "    let result = bytes_mut.reserve_inner(additional, allocate);",
          "}"
        ],
        "oracle": [
          "    let bytes_mut = BytesMut::with_capacity(8);",
          "    assert_eq!(bytes_mut.reserve_inner(5, false), false);",
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert_eq!(bytes_mut.capacity(), 8);",
          "    let shared = unsafe { &*(bytes_mut.data as *const Shared) };",
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 1);",
          "    assert_eq!(shared.cap, 10);",
          "    let v = &shared.vec;",
          "    assert!(v.capacity() < 10);",
          "    assert_eq!(v.len(), 0);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize, 0);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let shared = Box::into_raw(Box::new(Shared {",
          "            buf: std::ptr::null_mut(),",
          "            cap: 10,",
          "            ref_cnt: AtomicUsize::new(1),",
          "        }));",
          "        BytesMut {",
          "            ptr: NonNull::new(std::ptr::null_mut()).unwrap(),",
          "            len: 5,",
          "            cap: 8, // less than len + additional",
          "            data: shared.cast(),",
          "        }",
          "    };",
          "",
          "    let additional = 5; // greater than 0",
          "    let allocate = false; // set allocate to false",
          "",
          "    let result = bytes_mut.reserve_inner(additional, allocate);",
          "    let bytes_mut = BytesMut::with_capacity(8);",
          "    assert_eq!(bytes_mut.reserve_inner(5, false), false);",
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert_eq!(bytes_mut.capacity(), 8);",
          "    let shared = unsafe { &*(bytes_mut.data as *const Shared) };",
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 1);",
          "    assert_eq!(shared.cap, 10);",
          "    let v = &shared.vec;",
          "    assert!(v.capacity() < 10);",
          "    assert_eq!(v.len(), 0);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]