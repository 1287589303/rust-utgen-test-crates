[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(10);",
          "        unsafe { b.set_len(5) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 5;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert!(bytes_mut.capacity() > 10);",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert_eq!(bytes_mut.cap, 10 + off);",
          "    assert!(bytes_mut.spare_capacity_mut().len() > 0);",
          "    assert!(bytes_mut.reserve_inner(0, true));",
          "    assert!((*shared).is_unique() == false);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(10);",
          "        unsafe { b.set_len(5) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 5;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert!(bytes_mut.capacity() > 10);",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert_eq!(bytes_mut.cap, 10 + off);",
          "    assert!(bytes_mut.spare_capacity_mut().len() > 0);",
          "    assert!(bytes_mut.reserve_inner(0, true));",
          "    assert!((*shared).is_unique() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(11);",
          "        unsafe { b.set_len(6) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 6;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.capacity(), 11);",
          "    assert_eq!(bytes_mut.len(), 6);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.data.is_null());",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(bytes_mut.capacity() - bytes_mut.len() + off == additional);",
          "    assert!(off >= bytes_mut.len() == false);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(11);",
          "        unsafe { b.set_len(6) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 6;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "    assert_eq!(bytes_mut.capacity(), 11);",
          "    assert_eq!(bytes_mut.len(), 6);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.data.is_null());",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(bytes_mut.capacity() - bytes_mut.len() + off == additional);",
          "    assert!(off >= bytes_mut.len() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(15);",
          "        unsafe { b.set_len(7) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 8;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 7);",
          "    assert!(bytes_mut.capacity() >= 15);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize, bytes_mut.ptr.as_ptr() as usize);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    assert!(bytes_mut.capacity() - bytes_mut.len() + off == additional);",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(unsafe { bytes_mut.get_vec_pos() } == off);",
          "    assert!(unsafe { bytes_mut.data } != std::ptr::null_mut());",
          "    assert!(bytes_mut.cap > 0);",
          "    assert!(bytes_mut.ptr.as_ptr() != std::ptr::null_mut());"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(15);",
          "        unsafe { b.set_len(7) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 8;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "    assert_eq!(bytes_mut.len(), 7);",
          "    assert!(bytes_mut.capacity() >= 15);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize, bytes_mut.ptr.as_ptr() as usize);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    assert!(bytes_mut.capacity() - bytes_mut.len() + off == additional);",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(unsafe { bytes_mut.get_vec_pos() } == off);",
          "    assert!(unsafe { bytes_mut.data } != std::ptr::null_mut());",
          "    assert!(bytes_mut.cap > 0);",
          "    assert!(bytes_mut.ptr.as_ptr() != std::ptr::null_mut());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(17);",
          "        unsafe { b.set_len(10) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 10;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "}"
        ],
        "oracle": [
          "    assert!(bytes_mut.len() == 10);",
          "    assert!(bytes_mut.capacity() >= 17);",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(bytes_mut.ptr.as_ptr() == bytes_mut.ptr.as_ptr().sub(off));",
          "    assert!(bytes_mut.cap == 17);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    assert!(bytes_mut.try_reclaim(0) == true);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize, bytes_mut.ptr.as_ptr().add(off) as usize);",
          "    assert!(bytes_mut.ptr.as_ptr() != bytes_mut.ptr.as_ptr().add(off));",
          "    assert!(bytes_mut.spare_capacity_mut().len() > 0);",
          "    assert!(bytes_mut.split_off(5).len() == 5);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = {",
          "        let mut b = BytesMut::with_capacity(17);",
          "        unsafe { b.set_len(10) };",
          "        b",
          "    };",
          "    let additional = 0;",
          "    let allocate = true;",
          "    let off = 10;",
          "    unsafe {",
          "        bytes_mut.set_vec_pos(off);",
          "    }",
          "    let _ = bytes_mut.reserve_inner(additional, allocate);",
          "    assert!(bytes_mut.len() == 10);",
          "    assert!(bytes_mut.capacity() >= 17);",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(bytes_mut.ptr.as_ptr() == bytes_mut.ptr.as_ptr().sub(off));",
          "    assert!(bytes_mut.cap == 17);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    assert!(bytes_mut.try_reclaim(0) == true);",
          "    assert_eq!(bytes_mut.ptr.as_ptr() as usize, bytes_mut.ptr.as_ptr().add(off) as usize);",
          "    assert!(bytes_mut.ptr.as_ptr() != bytes_mut.ptr.as_ptr().add(off));",
          "    assert!(bytes_mut.spare_capacity_mut().len() > 0);",
          "    assert!(bytes_mut.split_off(5).len() == 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]