[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = vec![1, 2, 3];",
          "    let bytes_self = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let data_other = vec![1, 2, 3];",
          "    let bytes_other = Bytes {",
          "        ptr: data_other.as_ptr(),",
          "        len: data_other.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_other))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_self.partial_cmp(&&bytes_other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other), Some(cmp::Ordering::Equal));",
          "    let data_other_diff = vec![4, 5, 6];",
          "    let bytes_other_diff = Bytes {",
          "    ptr: data_other_diff.as_ptr(),",
          "    len: data_other_diff.len(),",
          "    data: AtomicPtr::new(Box::into_raw(Box::new(data_other_diff))),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other_diff), Some(cmp::Ordering::Less));",
          "    let bytes_other_empty = Bytes {",
          "    ptr: ptr::null(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other_empty), Some(cmp::Ordering::Greater));",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_self), Some(cmp::Ordering::Equal));",
          "    let bytes_other_null = Bytes {",
          "    ptr: ptr::null(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other_null), None);"
        ],
        "code": [
          "{",
          "    let data = vec![1, 2, 3];",
          "    let bytes_self = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let data_other = vec![1, 2, 3];",
          "    let bytes_other = Bytes {",
          "        ptr: data_other.as_ptr(),",
          "        len: data_other.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_other))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_self.partial_cmp(&&bytes_other);",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other), Some(cmp::Ordering::Equal));",
          "    let data_other_diff = vec![4, 5, 6];",
          "    let bytes_other_diff = Bytes {",
          "    ptr: data_other_diff.as_ptr(),",
          "    len: data_other_diff.len(),",
          "    data: AtomicPtr::new(Box::into_raw(Box::new(data_other_diff))),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other_diff), Some(cmp::Ordering::Less));",
          "    let bytes_other_empty = Bytes {",
          "    ptr: ptr::null(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other_empty), Some(cmp::Ordering::Greater));",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_self), Some(cmp::Ordering::Equal));",
          "    let bytes_other_null = Bytes {",
          "    ptr: ptr::null(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other_null), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data_short = vec![1, 2];",
          "    let bytes_short = Bytes {",
          "        ptr: data_short.as_ptr(),",
          "        len: data_short.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_short))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let data_long = vec![1, 2, 3];",
          "    let bytes_long = Bytes {",
          "        ptr: data_long.as_ptr(),",
          "        len: data_long.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_long))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_short.partial_cmp(&&bytes_long);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_short.partial_cmp(&&bytes_long), None);",
          "    assert!(bytes_short.partial_cmp(&&bytes_short).is_some());",
          "    assert!(bytes_long.partial_cmp(&&bytes_long).is_some());",
          "    assert!(bytes_short.partial_cmp(&&bytes_short) == Some(cmp::Ordering::Equal));",
          "    assert!(bytes_short.partial_cmp(&&bytes_long) == None);",
          "    assert!(bytes_long.partial_cmp(&&bytes_short) == None);"
        ],
        "code": [
          "{",
          "    let data_short = vec![1, 2];",
          "    let bytes_short = Bytes {",
          "        ptr: data_short.as_ptr(),",
          "        len: data_short.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_short))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let data_long = vec![1, 2, 3];",
          "    let bytes_long = Bytes {",
          "        ptr: data_long.as_ptr(),",
          "        len: data_long.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_long))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_short.partial_cmp(&&bytes_long);",
          "    assert_eq!(bytes_short.partial_cmp(&&bytes_long), None);",
          "    assert!(bytes_short.partial_cmp(&&bytes_short).is_some());",
          "    assert!(bytes_long.partial_cmp(&&bytes_long).is_some());",
          "    assert!(bytes_short.partial_cmp(&&bytes_short) == Some(cmp::Ordering::Equal));",
          "    assert!(bytes_short.partial_cmp(&&bytes_long) == None);",
          "    assert!(bytes_long.partial_cmp(&&bytes_short) == None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_empty = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let data_other = vec![1, 2, 3];",
          "    let bytes_other = Bytes {",
          "        ptr: data_other.as_ptr(),",
          "        len: data_other.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_other))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_empty.partial_cmp(&&bytes_other);",
          "}"
        ],
        "oracle": [
          "    bytes_empty.partial_cmp(&&bytes_other); // Test comparison between empty Bytes and non-empty Bytes",
          "    assert_eq!(bytes_empty.partial_cmp(&&bytes_other), Some(cmp::Ordering::Less)); // Verify that an empty Bytes is less than non-empty Bytes",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_empty), Some(cmp::Ordering::Greater)); // Verify that non-empty Bytes is greater than an empty Bytes",
          "    let data_equal = vec![1, 2, 3];",
          "    let bytes_equal = Bytes {",
          "    ptr: data_equal.as_ptr(),",
          "    len: data_equal.len(),",
          "    data: AtomicPtr::new(Box::into_raw(Box::new(data_equal))),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_equal), Some(cmp::Ordering::Equal)); // Verify that two equal-length Bytes yield equality",
          "    let data_other_longer = vec![1, 2, 3, 4];",
          "    let bytes_other_longer = Bytes {",
          "    ptr: data_other_longer.as_ptr(),",
          "    len: data_other_longer.len(),",
          "    data: AtomicPtr::new(Box::into_raw(Box::new(data_other_longer))),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_other_longer), Some(cmp::Ordering::Less)); // Verify comparison between two Bytes of different lengths"
        ],
        "code": [
          "{",
          "    let bytes_empty = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let data_other = vec![1, 2, 3];",
          "    let bytes_other = Bytes {",
          "        ptr: data_other.as_ptr(),",
          "        len: data_other.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(data_other))),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_empty.partial_cmp(&&bytes_other);",
          "    bytes_empty.partial_cmp(&&bytes_other); // Test comparison between empty Bytes and non-empty Bytes",
          "    assert_eq!(bytes_empty.partial_cmp(&&bytes_other), Some(cmp::Ordering::Less)); // Verify that an empty Bytes is less than non-empty Bytes",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_empty), Some(cmp::Ordering::Greater)); // Verify that non-empty Bytes is greater than an empty Bytes",
          "    let data_equal = vec![1, 2, 3];",
          "    let bytes_equal = Bytes {",
          "    ptr: data_equal.as_ptr(),",
          "    len: data_equal.len(),",
          "    data: AtomicPtr::new(Box::into_raw(Box::new(data_equal))),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_equal), Some(cmp::Ordering::Equal)); // Verify that two equal-length Bytes yield equality",
          "    let data_other_longer = vec![1, 2, 3, 4];",
          "    let bytes_other_longer = Bytes {",
          "    ptr: data_other_longer.as_ptr(),",
          "    len: data_other_longer.len(),",
          "    data: AtomicPtr::new(Box::into_raw(Box::new(data_other_longer))),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_other_longer), Some(cmp::Ordering::Less)); // Verify comparison between two Bytes of different lengths",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_empty_self = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_empty_other = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_empty_self.partial_cmp(&&bytes_empty_other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_empty_self.partial_cmp(&&bytes_empty_other), None);"
        ],
        "code": [
          "{",
          "    let bytes_empty_self = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_empty_other = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_empty_self.partial_cmp(&&bytes_empty_other);",
          "    assert_eq!(bytes_empty_self.partial_cmp(&&bytes_empty_other), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_other = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    // Self is null",
          "    let bytes_self = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_self.partial_cmp(&&bytes_other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other), None);",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_self), None);",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_self), Some(cmp::Ordering::Equal));",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other), None);",
          "    bytes_self.ptr = &1;",
          "    assert!(bytes_self.partial_cmp(&&bytes_other).is_none());",
          "    bytes_self.len = 1;",
          "    assert!(bytes_self.partial_cmp(&&bytes_other).is_none());"
        ],
        "code": [
          "{",
          "    let bytes_other = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    // Self is null",
          "    let bytes_self = Bytes {",
          "        ptr: std::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "",
          "    bytes_self.partial_cmp(&&bytes_other);",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other), None);",
          "    assert_eq!(bytes_other.partial_cmp(&&bytes_self), None);",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_self), Some(cmp::Ordering::Equal));",
          "    assert_eq!(bytes_self.partial_cmp(&&bytes_other), None);",
          "    bytes_self.ptr = &1;",
          "    assert!(bytes_self.partial_cmp(&&bytes_other).is_none());",
          "    bytes_self.len = 1;",
          "    assert!(bytes_self.partial_cmp(&&bytes_other).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]