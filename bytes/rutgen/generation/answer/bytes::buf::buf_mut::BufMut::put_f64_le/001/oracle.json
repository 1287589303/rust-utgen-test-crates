[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(1.2f64);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
          "    buf.put_f64_le(1.2f64);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f64_le(3.14f64);",
          "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\");",
          "    buf.advance_mut(8);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f64_le(2.7f64);",
          "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    buf.put_f64_le(0.0f64);",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(panic::catch_unwind(|| buf.put_f64_le(1.1)).is_err());",
          "    buf.put_f64_le(f64::MAX);",
          "    assert!(buf.remaining_mut() == 0);"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(1.2f64);",
          "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
          "    buf.put_f64_le(1.2f64);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f64_le(3.14f64);",
          "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\");",
          "    buf.advance_mut(8);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f64_le(2.7f64);",
          "    assert_eq!(buf, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\\xCD\\xCC\\x0C\\xC3\\xF5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    buf.put_f64_le(0.0f64);",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(panic::catch_unwind(|| buf.put_f64_le(1.1)).is_err());",
          "    buf.put_f64_le(f64::MAX);",
          "    assert!(buf.remaining_mut() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 16]; // more than 8 bytes",
          "    buf.put_f64_le(1.2f64);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf[0..8], b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
          "    assert_eq!(buf.len(), 16);",
          "    assert!(buf.iter().skip(8).all(|&x| x == 0));"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 16]; // more than 8 bytes",
          "    buf.put_f64_le(1.2f64);",
          "    assert_eq!(buf[0..8], b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
          "    assert_eq!(buf.len(), 16);",
          "    assert!(buf.iter().skip(8).all(|&x| x == 0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(0.0f64);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    assert_eq!(buf.remaining_mut(), 0);",
          "    buf.put_f64_le(3.14f64);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x73\\x20\\x9A\\x99\\x99\\x99\\x3F\");"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(0.0f64);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    assert_eq!(buf.remaining_mut(), 0);",
          "    buf.put_f64_le(3.14f64);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x73\\x20\\x9A\\x99\\x99\\x99\\x3F\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(-1.2f64);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf[0..8], b\"\\x9A\\x99\\x99\\x99\\x99\\x99\\xF3\\xBF\");",
          "    assert_eq!(buf.remaining_mut(), 0);",
          "    assert!(buf.has_remaining_mut() == false);"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(-1.2f64);",
          "    assert_eq!(buf[0..8], b\"\\x9A\\x99\\x99\\x99\\x99\\x99\\xF3\\xBF\");",
          "    assert_eq!(buf.remaining_mut(), 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(1e100f64);",
          "}"
        ],
        "oracle": [
          "    buf.put_f64_le(1e100f64); // called with large value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF4\\x47\"); // expected little-endian bytes for 1e100",
          "    buf.put_f64_le(-1e100f64); // called with negative large value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xC4\\x47\"); // expected little-endian bytes for -1e100",
          "    buf.put_f64_le(0.0f64); // called with zero value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"); // expected little-endian bytes for 0.0",
          "    buf.put_f64_le(f64::INFINITY); // called with infinity value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"); // expected little-endian bytes for infinity",
          "    buf.put_f64_le(f64::NAN); // called with NaN value",
          "    assert!(buf.is_nan(), \"Buffer should state NaN correctly\"); // validate buffer handles NaN"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 8]; // exactly 8 bytes",
          "    buf.put_f64_le(1e100f64);",
          "    buf.put_f64_le(1e100f64); // called with large value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF4\\x47\"); // expected little-endian bytes for 1e100",
          "    buf.put_f64_le(-1e100f64); // called with negative large value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xC4\\x47\"); // expected little-endian bytes for -1e100",
          "    buf.put_f64_le(0.0f64); // called with zero value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"); // expected little-endian bytes for 0.0",
          "    buf.put_f64_le(f64::INFINITY); // called with infinity value",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"); // expected little-endian bytes for infinity",
          "    buf.put_f64_le(f64::NAN); // called with NaN value",
          "    assert!(buf.is_nan(), \"Buffer should state NaN correctly\"); // validate buffer handles NaN",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 7]; // less than 8 bytes",
          "    buf.put_f64_le(1.2f64);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.len(), 7);",
          "    assert!(buf.remaining_mut() < 8);",
          "    assert!(std::panic::catch_unwind(|| buf.put_f64_le(1.2f64)).is_err());",
          "    assert!(buf.len() == 7);",
          "    assert!(buf == vec![0; 7]);",
          "    assert!(buf.has_remaining_mut() == false);"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 7]; // less than 8 bytes",
          "    buf.put_f64_le(1.2f64);",
          "    assert_eq!(buf.len(), 7);",
          "    assert!(buf.remaining_mut() < 8);",
          "    assert!(std::panic::catch_unwind(|| buf.put_f64_le(1.2f64)).is_err());",
          "    assert!(buf.len() == 7);",
          "    assert!(buf == vec![0; 7]);",
          "    assert!(buf.has_remaining_mut() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]