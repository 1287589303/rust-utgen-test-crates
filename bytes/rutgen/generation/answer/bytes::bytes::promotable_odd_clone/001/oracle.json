[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf = Box::new([0u8; 10]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared {",
          "        buf: Box::into_raw(buf) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 10;",
          "",
          "    unsafe {",
          "        promotable_odd_clone(&data, ptr, len);",
          "    }",
          "",
          "    // Clean up",
          "    unsafe {",
          "        let _ = Box::from_raw(data.load(Ordering::Acquire));",
          "    }",
          "}"
        ],
        "oracle": [
          "    let arc_shared = Box::into_raw(Box::new(Shared { buf: Box::into_raw(buf) as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(1) }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 10;",
          "    let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.ptr, ptr);",
          "    assert!(unsafe { (*(result.data.load(Ordering::Acquire) as *mut Shared)).ref_cnt.load(Ordering::Relaxed) } == 2);",
          "    assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);"
        ],
        "code": [
          "{",
          "    let buf = Box::new([0u8; 10]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared {",
          "        buf: Box::into_raw(buf) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 10;",
          "",
          "    unsafe {",
          "        promotable_odd_clone(&data, ptr, len);",
          "    }",
          "",
          "    // Clean up",
          "    unsafe {",
          "        let _ = Box::from_raw(data.load(Ordering::Acquire));",
          "    }",
          "    let arc_shared = Box::into_raw(Box::new(Shared { buf: Box::into_raw(buf) as *mut u8, cap: 10, ref_cnt: AtomicUsize::new(1) }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 10;",
          "    let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.ptr, ptr);",
          "    assert!(unsafe { (*(result.data.load(Ordering::Acquire) as *mut Shared)).ref_cnt.load(Ordering::Relaxed) } == 2);",
          "    assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf = Box::new([1u8; 5]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared {",
          "        buf: Box::into_raw(buf) as *mut u8,",
          "        cap: 5,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 5;",
          "",
          "    unsafe {",
          "        promotable_odd_clone(&data, ptr, len);",
          "    }",
          "",
          "    // Clean up",
          "    unsafe {",
          "        let _ = Box::from_raw(data.load(Ordering::Acquire));",
          "    }",
          "}"
        ],
        "oracle": [
          "    let buf = Box::new([1u8; 5]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared { buf: Box::into_raw(buf) as *mut u8, cap: 5, ref_cnt: AtomicUsize::new(1), }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 5;",
          "    let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
          "    assert_eq!(result.ptr, ptr);",
          "    assert_eq!(result.len, len);",
          "    assert!(!result.data.load(Ordering::Acquire).is_null());",
          "    assert_eq!(unsafe { (*(result.data.load(Ordering::Acquire) as *mut Shared)).ref_cnt.load(Ordering::Relaxed) }, 2);"
        ],
        "code": [
          "{",
          "    let buf = Box::new([1u8; 5]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared {",
          "        buf: Box::into_raw(buf) as *mut u8,",
          "        cap: 5,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 5;",
          "",
          "    unsafe {",
          "        promotable_odd_clone(&data, ptr, len);",
          "    }",
          "",
          "    // Clean up",
          "    unsafe {",
          "        let _ = Box::from_raw(data.load(Ordering::Acquire));",
          "    }",
          "    let buf = Box::new([1u8; 5]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared { buf: Box::into_raw(buf) as *mut u8, cap: 5, ref_cnt: AtomicUsize::new(1), }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 5;",
          "    let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
          "    assert_eq!(result.ptr, ptr);",
          "    assert_eq!(result.len, len);",
          "    assert!(!result.data.load(Ordering::Acquire).is_null());",
          "    assert_eq!(unsafe { (*(result.data.load(Ordering::Acquire) as *mut Shared)).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf = Box::new([2u8; 100]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared {",
          "        buf: Box::into_raw(buf) as *mut u8,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 100;",
          "",
          "    unsafe {",
          "        promotable_odd_clone(&data, ptr, len);",
          "    }",
          "",
          "    // Clean up",
          "    unsafe {",
          "        let _ = Box::from_raw(data.load(Ordering::Acquire));",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).ptr }, ptr);",
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).len }, len);",
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).data.load(Ordering::Acquire) as *const _ }, arc_shared);",
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).vtable }, &SHARED_VTABLE);",
          "    assert_eq!(unsafe { (*arc_shared).ref_cnt.load(Ordering::Relaxed) }, 2);"
        ],
        "code": [
          "{",
          "    let buf = Box::new([2u8; 100]);",
          "    let arc_shared = Box::into_raw(Box::new(Shared {",
          "        buf: Box::into_raw(buf) as *mut u8,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(arc_shared as *mut _);",
          "    let ptr: *const u8 = (arc_shared as *mut Shared).cast::<u8>().add(0);",
          "    let len: usize = 100;",
          "",
          "    unsafe {",
          "        promotable_odd_clone(&data, ptr, len);",
          "    }",
          "",
          "    // Clean up",
          "    unsafe {",
          "        let _ = Box::from_raw(data.load(Ordering::Acquire));",
          "    }",
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).ptr }, ptr);",
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).len }, len);",
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).data.load(Ordering::Acquire) as *const _ }, arc_shared);",
          "    assert_eq!(unsafe { promotable_odd_clone(&data, ptr, len).vtable }, &SHARED_VTABLE);",
          "    assert_eq!(unsafe { (*arc_shared).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]