[
  {
    "uses": [
      "use std::alloc::alloc;",
      "use std::alloc::dealloc;",
      "use std::alloc::Layout;",
      "use core::ptr::NonNull;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    ",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    ",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 1,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    ",
          "    // Call the function under test with len = 1",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 1) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf, layout);",
          "        let _ = Box::from_raw(result.data.load(Ordering::Relaxed) as *mut Shared);",
          "    }",
          "}"
        ],
        "oracle": [
          "    unsafe {",
          "    let shared = atomic_ptr.load(Ordering::Acquire);",
          "    assert_ne!(shared as usize & KIND_MASK, KIND_ARC);",
          "    }",
          "    ",
          "    assert!(result.ptr == buf as *const _);",
          "    assert_eq!(result.len, 1);",
          "    assert!(result.data.load(Ordering::Relaxed) != atomic_ptr.load(Ordering::Relaxed));"
        ],
        "code": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    ",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    ",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 1,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    ",
          "    // Call the function under test with len = 1",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 1) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf, layout);",
          "        let _ = Box::from_raw(result.data.load(Ordering::Relaxed) as *mut Shared);",
          "    }",
          "    unsafe {",
          "    let shared = atomic_ptr.load(Ordering::Acquire);",
          "    assert_ne!(shared as usize & KIND_MASK, KIND_ARC);",
          "    }",
          "    ",
          "    assert!(result.ptr == buf as *const _);",
          "    assert_eq!(result.len, 1);",
          "    assert!(result.data.load(Ordering::Relaxed) != atomic_ptr.load(Ordering::Relaxed));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let max_len = usize::MAX;",
          "    let layout = Layout::from_size_align(max_len, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    ",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    ",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: max_len,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    ",
          "    // Call the function under test with len set to usize::MAX",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, max_len) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf, layout);",
          "        let _ = Box::from_raw(result.data.load(Ordering::Relaxed) as *mut Shared);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, max_len) };",
          "    assert_eq!(result.len, max_len);",
          "    assert!(result.ptr == buf as *const _);",
          "    assert_eq!(result.data.load(Ordering::Relaxed) as usize & KIND_MASK, KIND_VEC);"
        ],
        "code": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let max_len = usize::MAX;",
          "    let layout = Layout::from_size_align(max_len, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    ",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    ",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: max_len,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    ",
          "    // Call the function under test with len set to usize::MAX",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, max_len) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf, layout);",
          "        let _ = Box::from_raw(result.data.load(Ordering::Relaxed) as *mut Shared);",
          "    }",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, max_len) };",
          "    assert_eq!(result.len, max_len);",
          "    assert!(result.ptr == buf as *const _);",
          "    assert_eq!(result.data.load(Ordering::Relaxed) as usize & KIND_MASK, KIND_VEC);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    ",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    ",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 1,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    ",
          "    // Call the function under test with invalid length, triggering an assertion",
          "    let _ = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 0) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf, layout);",
          "        let _ = Box::from_raw(shared_ptr);",
          "    }",
          "}"
        ],
        "oracle": [
          "    unsafe fn promotable_odd_clone_invalid_kind() {",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    let shared = Box::new(Shared {",
          "    buf,",
          "    cap: 1,",
          "    ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    let _ = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 0) };",
          "    unsafe {",
          "    dealloc(buf, layout);",
          "    let _ = Box::from_raw(shared_ptr);",
          "    }",
          "    }",
          "    ",
          "    fn test_promotable_odd_clone_kind_vec() {",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    let shared = Box::new(Shared {",
          "    buf,",
          "    cap: 1,",
          "    ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 1) };",
          "    assert!(!result.data.load(Ordering::SeqCst).is_null());",
          "    unsafe {",
          "    dealloc(buf, layout);",
          "    let _ = Box::from_raw(shared_ptr);",
          "    }",
          "    }"
        ],
        "code": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    ",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    ",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 1,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    ",
          "    // Call the function under test with invalid length, triggering an assertion",
          "    let _ = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 0) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf, layout);",
          "        let _ = Box::from_raw(shared_ptr);",
          "    }",
          "    unsafe fn promotable_odd_clone_invalid_kind() {",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    let shared = Box::new(Shared {",
          "    buf,",
          "    cap: 1,",
          "    ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    let _ = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 0) };",
          "    unsafe {",
          "    dealloc(buf, layout);",
          "    let _ = Box::from_raw(shared_ptr);",
          "    }",
          "    }",
          "    ",
          "    fn test_promotable_odd_clone_kind_vec() {",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let buf = unsafe { alloc(layout) };",
          "    let atomic_ptr = AtomicPtr::new(buf);",
          "    let shared = Box::new(Shared {",
          "    buf,",
          "    cap: 1,",
          "    ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf as *const _, 1) };",
          "    assert!(!result.data.load(Ordering::SeqCst).is_null());",
          "    unsafe {",
          "    dealloc(buf, layout);",
          "    let _ = Box::from_raw(shared_ptr);",
          "    }",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let layout = Layout::from_size_align(2, 1).unwrap();",
          "    let buf1 = unsafe { alloc(layout) };",
          "    let buf2 = unsafe { alloc(layout) };",
          "",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf1);",
          "",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf: buf1,",
          "        cap: 2,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "",
          "    // Call the function under test with len = 2",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf2 as *const _, 2) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf1, layout);",
          "        dealloc(buf2, layout);",
          "        let _ = Box::from_raw(result.data.load(Ordering::Relaxed) as *mut Shared);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let shared = atomic_ptr.load(Ordering::Acquire);",
          "    let kind = shared as usize & KIND_MASK;",
          "    assert_eq!(kind, KIND_VEC);",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf2 as *const _, 2) };",
          "    assert!(result.ptr == buf2 as *const _);",
          "    assert!(result.len == 2);",
          "    assert!(result.data.load(Ordering::Relaxed) != shared);",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    let shared_result = result.data.load(Ordering::Relaxed);",
          "    assert_eq!((*shared_result).ref_cnt.load(Ordering::Relaxed), 2);",
          "    drop(Box::from_raw(shared_result));"
        ],
        "code": [
          "{",
          "    use core::ptr::NonNull;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    // Prepare a buffer for testing",
          "    let layout = Layout::from_size_align(2, 1).unwrap();",
          "    let buf1 = unsafe { alloc(layout) };",
          "    let buf2 = unsafe { alloc(layout) };",
          "",
          "    // Create an AtomicPtr pointing to the buffer to satisfy precondition",
          "    let atomic_ptr = AtomicPtr::new(buf1);",
          "",
          "    // Set the kind to KIND_VEC by allocating and setting appropriate atomic state",
          "    let shared = Box::new(Shared {",
          "        buf: buf1,",
          "        cap: 2,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    atomic_ptr.store(shared_ptr as *mut _, Ordering::Release);",
          "",
          "    // Call the function under test with len = 2",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf2 as *const _, 2) };",
          "",
          "    // Clean up",
          "    unsafe {",
          "        dealloc(buf1, layout);",
          "        dealloc(buf2, layout);",
          "        let _ = Box::from_raw(result.data.load(Ordering::Relaxed) as *mut Shared);",
          "    }",
          "    let shared = atomic_ptr.load(Ordering::Acquire);",
          "    let kind = shared as usize & KIND_MASK;",
          "    assert_eq!(kind, KIND_VEC);",
          "    let result = unsafe { promotable_odd_clone(&atomic_ptr, buf2 as *const _, 2) };",
          "    assert!(result.ptr == buf2 as *const _);",
          "    assert!(result.len == 2);",
          "    assert!(result.data.load(Ordering::Relaxed) != shared);",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    let shared_result = result.data.load(Ordering::Relaxed);",
          "    assert_eq!((*shared_result).ref_cnt.load(Ordering::Relaxed), 2);",
          "    drop(Box::from_raw(shared_result));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]