[
  {
    "uses": [
      "use core::ptr::null_mut;",
      "use core::ptr::NonNull;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::{null_mut, NonNull};",
          "    ",
          "    // Create a shared object with KIND_ARC",
          "    let shared = Box::new(crate::Shared {",
          "        buf: null_mut(),",
          "        cap: 0,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "",
          "    let atomic_ptr = AtomicPtr::new(shared_ptr as *mut ());",
          "",
          "    // Pointer to valid memory location",
          "    let ptr = NonNull::new(0x1234 as *const u8).unwrap();",
          "    let len = 10;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _ = promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) }.len, len);",
          "    assert!(!unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) }.data.load(Ordering::Relaxed).is_null());",
          "    assert_eq!(unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) }.vtable, &SHARED_VTABLE);",
          "    assert_eq!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "    assert_eq!(unsafe { (*shared_ptr).buf }, null_mut());",
          "    assert_eq!(unsafe { (*shared_ptr).cap }, len);"
        ],
        "code": [
          "{",
          "    use core::ptr::{null_mut, NonNull};",
          "    ",
          "    // Create a shared object with KIND_ARC",
          "    let shared = Box::new(crate::Shared {",
          "        buf: null_mut(),",
          "        cap: 0,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "",
          "    let atomic_ptr = AtomicPtr::new(shared_ptr as *mut ());",
          "",
          "    // Pointer to valid memory location",
          "    let ptr = NonNull::new(0x1234 as *const u8).unwrap();",
          "    let len = 10;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _ = promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len);",
          "    }",
          "    assert_eq!(unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) }.len, len);",
          "    assert!(!unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) }.data.load(Ordering::Relaxed).is_null());",
          "    assert_eq!(unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) }.vtable, &SHARED_VTABLE);",
          "    assert_eq!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "    assert_eq!(unsafe { (*shared_ptr).buf }, null_mut());",
          "    assert_eq!(unsafe { (*shared_ptr).cap }, len);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::{null_mut, NonNull};",
          "",
          "    // Create a shared object with KIND_ARC",
          "    let shared = Box::new(crate::Shared {",
          "        buf: null_mut(),",
          "        cap: 20,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "",
          "    let atomic_ptr = AtomicPtr::new(shared_ptr as *mut ());",
          "",
          "    // Pointer to valid memory location",
          "    let ptr = NonNull::new(0x5678 as *const u8).unwrap();",
          "    let len = 5;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _ = promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(shared_ptr as usize & KIND_MASK, KIND_ARC);",
          "    assert!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Relaxed) } == 1);",
          "    assert!(unsafe { (*shared_ptr).cap } == 20);",
          "    assert_eq!(len, 5);",
          "    assert!(!ptr.is_null());",
          "    let result = unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) };",
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.data.load(Ordering::Relaxed) as usize & KIND_MASK, KIND_ARC);"
        ],
        "code": [
          "{",
          "    use core::ptr::{null_mut, NonNull};",
          "",
          "    // Create a shared object with KIND_ARC",
          "    let shared = Box::new(crate::Shared {",
          "        buf: null_mut(),",
          "        cap: 20,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "",
          "    let atomic_ptr = AtomicPtr::new(shared_ptr as *mut ());",
          "",
          "    // Pointer to valid memory location",
          "    let ptr = NonNull::new(0x5678 as *const u8).unwrap();",
          "    let len = 5;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _ = promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len);",
          "    }",
          "    assert_eq!(shared_ptr as usize & KIND_MASK, KIND_ARC);",
          "    assert!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Relaxed) } == 1);",
          "    assert!(unsafe { (*shared_ptr).cap } == 20);",
          "    assert_eq!(len, 5);",
          "    assert!(!ptr.is_null());",
          "    let result = unsafe { promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len) };",
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.data.load(Ordering::Relaxed) as usize & KIND_MASK, KIND_ARC);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::{null_mut, NonNull};",
          "",
          "    // Create a shared object with KIND_ARC",
          "    let shared = Box::new(crate::Shared {",
          "        buf: null_mut(),",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "",
          "    let atomic_ptr = AtomicPtr::new(shared_ptr as *mut ());",
          "",
          "    // Pointer to valid memory location",
          "    let ptr = NonNull::new(0x9abc as *const u8).unwrap();",
          "    let len = 1; // Minimum non-zero length",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _ = promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).data.load(Ordering::Relaxed) == shared_ptr as *const ());",
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).len == len);",
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).ptr == ptr.as_ptr());",
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).vtable == &SHARED_VTABLE);",
          "    assert!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Relaxed) } == 2);"
        ],
        "code": [
          "{",
          "    use core::ptr::{null_mut, NonNull};",
          "",
          "    // Create a shared object with KIND_ARC",
          "    let shared = Box::new(crate::Shared {",
          "        buf: null_mut(),",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "",
          "    let atomic_ptr = AtomicPtr::new(shared_ptr as *mut ());",
          "",
          "    // Pointer to valid memory location",
          "    let ptr = NonNull::new(0x9abc as *const u8).unwrap();",
          "    let len = 1; // Minimum non-zero length",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        let _ = promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len);",
          "    }",
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).data.load(Ordering::Relaxed) == shared_ptr as *const ());",
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).len == len);",
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).ptr == ptr.as_ptr());",
          "    assert!(promotable_even_clone(&atomic_ptr, ptr.as_ptr(), len).vtable == &SHARED_VTABLE);",
          "    assert!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Relaxed) } == 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]