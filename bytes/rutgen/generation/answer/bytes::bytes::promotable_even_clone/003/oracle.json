[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    // Create a shared memory buffer",
          "    let buf: *mut u8 = alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "    let len: usize = 50;  // len is greater than 0 and less than usize::MAX",
          "",
          "    // Constructing a shared object with KIND_VEC",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr: *mut Shared = Box::into_raw(shared);",
          "",
          "    // Create an AtomicPtr initialized with KIND_VEC",
          "    let data = AtomicPtr::new(shared_ptr as *mut () | KIND_VEC as usize);",
          "    ",
          "    // Pointer to chunk of data to clone",
          "    let ptr: *const u8 = buf as *const u8;",
          "",
          "    // Call the function to be tested",
          "    let _ = promotable_even_clone(&data, ptr, len);",
          "    ",
          "    // Clean up allocation",
          "    alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "}"
        ],
        "oracle": [
          "    let shared_ptr: *mut Shared = Box::into_raw(shared);",
          "    let data = AtomicPtr::new(shared_ptr as *mut () | KIND_VEC as usize);",
          "    let result = promotable_even_clone(&data, ptr, len);",
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.ptr, ptr);",
          "    assert_eq!(result.vtable, &SHARED_VTABLE);",
          "    assert!((*shared_ptr).ref_cnt.load(Ordering::Relaxed) == 2);",
          "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
          "    assert!(kind == KIND_VEC);",
          "    assert!(mem::size_of::<Bytes>() > 0);",
          "    assert!(data.load(Ordering::Acquire) != shared_ptr as *mut ());",
          "    let shared = unsafe { &*shared_ptr };",
          "    assert!(shared.buf == buf);"
        ],
        "code": [
          "{",
          "    // Create a shared memory buffer",
          "    let buf: *mut u8 = alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "    let len: usize = 50;  // len is greater than 0 and less than usize::MAX",
          "",
          "    // Constructing a shared object with KIND_VEC",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr: *mut Shared = Box::into_raw(shared);",
          "",
          "    // Create an AtomicPtr initialized with KIND_VEC",
          "    let data = AtomicPtr::new(shared_ptr as *mut () | KIND_VEC as usize);",
          "    ",
          "    // Pointer to chunk of data to clone",
          "    let ptr: *const u8 = buf as *const u8;",
          "",
          "    // Call the function to be tested",
          "    let _ = promotable_even_clone(&data, ptr, len);",
          "    ",
          "    // Clean up allocation",
          "    alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "    let shared_ptr: *mut Shared = Box::into_raw(shared);",
          "    let data = AtomicPtr::new(shared_ptr as *mut () | KIND_VEC as usize);",
          "    let result = promotable_even_clone(&data, ptr, len);",
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.ptr, ptr);",
          "    assert_eq!(result.vtable, &SHARED_VTABLE);",
          "    assert!((*shared_ptr).ref_cnt.load(Ordering::Relaxed) == 2);",
          "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
          "    assert!(kind == KIND_VEC);",
          "    assert!(mem::size_of::<Bytes>() > 0);",
          "    assert!(data.load(Ordering::Acquire) != shared_ptr as *mut ());",
          "    let shared = unsafe { &*shared_ptr };",
          "    assert!(shared.buf == buf);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    // Create a memory buffer that causes the compare_exchange to fail",
          "    let buf: *mut u8 = alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "    let len: usize = 50;",
          "",
          "    // Constructing a non-ARC shared object",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr: *mut Shared = Box::into_raw(shared);",
          "",
          "    // Create an AtomicPtr but initialize it with an Arc's kind",
          "    let data = AtomicPtr::new(shared_ptr as *mut () | KIND_ARC as usize);",
          "    ",
          "    // Pointer to chunk of data to clone",
          "    let ptr: *const u8 = buf as *const u8;",
          "",
          "    // Call the function to be tested, expecting it to trigger the else branch",
          "    let _ = promotable_even_clone(&data, ptr, len);",
          "    ",
          "    // Clean up allocation",
          "    alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(promotable_even_clone(&data, ptr, len).data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_VEC);",
          "    assert!(unsafe { (*promotable_even_clone(&data, ptr, len).data.load(Ordering::Acquire) as *mut Shared).ref_cnt.load(Ordering::Relaxed) } > 1);",
          "    assert!(promotable_even_clone(&data, ptr, len).len == len);",
          "    assert!(promotable_even_clone(&data, ptr, len).ptr != ptr);",
          "    assert_eq!(promotable_even_clone(&data, ptr, len).vtable, &SHARED_VTABLE);"
        ],
        "code": [
          "{",
          "    // Create a memory buffer that causes the compare_exchange to fail",
          "    let buf: *mut u8 = alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "    let len: usize = 50;",
          "",
          "    // Constructing a non-ARC shared object",
          "    let shared = Box::new(Shared {",
          "        buf,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let shared_ptr: *mut Shared = Box::into_raw(shared);",
          "",
          "    // Create an AtomicPtr but initialize it with an Arc's kind",
          "    let data = AtomicPtr::new(shared_ptr as *mut () | KIND_ARC as usize);",
          "    ",
          "    // Pointer to chunk of data to clone",
          "    let ptr: *const u8 = buf as *const u8;",
          "",
          "    // Call the function to be tested, expecting it to trigger the else branch",
          "    let _ = promotable_even_clone(&data, ptr, len);",
          "    ",
          "    // Clean up allocation",
          "    alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(100, 1).unwrap());",
          "    assert_eq!(promotable_even_clone(&data, ptr, len).data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_VEC);",
          "    assert!(unsafe { (*promotable_even_clone(&data, ptr, len).data.load(Ordering::Acquire) as *mut Shared).ref_cnt.load(Ordering::Relaxed) } > 1);",
          "    assert!(promotable_even_clone(&data, ptr, len).len == len);",
          "    assert!(promotable_even_clone(&data, ptr, len).ptr != ptr);",
          "    assert_eq!(promotable_even_clone(&data, ptr, len).vtable, &SHARED_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]