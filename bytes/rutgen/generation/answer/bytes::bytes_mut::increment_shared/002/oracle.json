[
  {
    "uses": [
      "use std::alloc::alloc;",
      "use std::alloc::dealloc;",
      "use std::alloc::Layout;",
      "use std::sync::atomic::AtomicUsize;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::sync::atomic::AtomicUsize;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    struct Shared {",
          "        vec: Vec<u8>,",
          "        original_capacity_repr: usize,",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let layout = Layout::new::<Shared>();",
          "    let ptr = unsafe { alloc(layout) as *mut Shared };",
          "",
          "    unsafe {",
          "        (*ptr).vec = Vec::new();",
          "        (*ptr).original_capacity_repr = 0;",
          "        (*ptr).ref_count = AtomicUsize::new(isize::MAX as usize);",
          "    }",
          "",
          "    unsafe {",
          "        increment_shared(ptr);",
          "    }",
          "",
          "    unsafe {",
          "        dealloc(ptr as *mut u8, layout);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(unsafe { (*ptr).ref_count.load(Ordering::Relaxed) }, isize::MAX as usize + 1);",
          "    assert!(std::panic::catch_unwind(|| { increment_shared(ptr); }).is_err());",
          "    assert_eq!(unsafe { (*ptr).vec }, Vec::new());",
          "    assert_eq!(unsafe { (*ptr).original_capacity_repr }, 0);"
        ],
        "code": [
          "{",
          "    use std::sync::atomic::AtomicUsize;",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "",
          "    struct Shared {",
          "        vec: Vec<u8>,",
          "        original_capacity_repr: usize,",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let layout = Layout::new::<Shared>();",
          "    let ptr = unsafe { alloc(layout) as *mut Shared };",
          "",
          "    unsafe {",
          "        (*ptr).vec = Vec::new();",
          "        (*ptr).original_capacity_repr = 0;",
          "        (*ptr).ref_count = AtomicUsize::new(isize::MAX as usize);",
          "    }",
          "",
          "    unsafe {",
          "        increment_shared(ptr);",
          "    }",
          "",
          "    unsafe {",
          "        dealloc(ptr as *mut u8, layout);",
          "    }",
          "    assert_eq!(unsafe { (*ptr).ref_count.load(Ordering::Relaxed) }, isize::MAX as usize + 1);",
          "    assert!(std::panic::catch_unwind(|| { increment_shared(ptr); }).is_err());",
          "    assert_eq!(unsafe { (*ptr).vec }, Vec::new());",
          "    assert_eq!(unsafe { (*ptr).original_capacity_repr }, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]