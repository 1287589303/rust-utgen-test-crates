[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    let input = b\"hello\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frozen_bytes.len(), 5);",
          "    assert!(!frozen_bytes.is_empty());",
          "    assert_eq!(frozen_bytes[..], *b\"hello\");",
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert!(bytes_mut.capacity() >= 10);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert_eq!(frozen_bytes.ptr, bytes_mut.ptr);",
          "    assert!(frozen_bytes.data.load(Ordering::Relaxed).is_null());",
          "    assert!(frozen_bytes.vtable == &SHARED_VTABLE);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    let input = b\"hello\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    assert_eq!(frozen_bytes.len(), 5);",
          "    assert!(!frozen_bytes.is_empty());",
          "    assert_eq!(frozen_bytes[..], *b\"hello\");",
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert!(bytes_mut.capacity() >= 10);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert_eq!(frozen_bytes.ptr, bytes_mut.ptr);",
          "    assert!(frozen_bytes.data.load(Ordering::Relaxed).is_null());",
          "    assert!(frozen_bytes.vtable == &SHARED_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(64);",
          "    let input = b\"world\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frozen_bytes.len(), 5);",
          "    assert!(frozen_bytes.is_empty() == false);",
          "    assert_eq!(frozen_bytes.slice(..), Bytes::copy_from_slice(b\"world\"));",
          "    assert_eq!(frozen_bytes.ptr, bytes_mut.ptr);",
          "    assert_eq!(frozen_bytes.data.load(Ordering::SeqCst), bytes_mut.data.load(Ordering::SeqCst));",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(bytes_mut.len() == 5);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(64);",
          "    let input = b\"world\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    assert_eq!(frozen_bytes.len(), 5);",
          "    assert!(frozen_bytes.is_empty() == false);",
          "    assert_eq!(frozen_bytes.slice(..), Bytes::copy_from_slice(b\"world\"));",
          "    assert_eq!(frozen_bytes.ptr, bytes_mut.ptr);",
          "    assert_eq!(frozen_bytes.data.load(Ordering::SeqCst), bytes_mut.data.load(Ordering::SeqCst));",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "    assert!(bytes_mut.len() == 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(128);",
          "    let input = b\"test exact capacity\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frozen_bytes.len(), 20);",
          "    assert_eq!(frozen_bytes.is_empty(), false);",
          "    assert!(frozen_bytes.kind() == KIND_VEC);",
          "    assert_eq!(frozen_bytes.as_slice(), b\"test exact capacity\");",
          "    assert_eq!(frozen_bytes.capacity(), 128);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(128);",
          "    let input = b\"test exact capacity\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    assert_eq!(frozen_bytes.len(), 20);",
          "    assert_eq!(frozen_bytes.is_empty(), false);",
          "    assert!(frozen_bytes.kind() == KIND_VEC);",
          "    assert_eq!(frozen_bytes.as_slice(), b\"test exact capacity\");",
          "    assert_eq!(frozen_bytes.capacity(), 128);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(131072);",
          "    let input = b\"maximum capacity test\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frozen_bytes.len(), 20);",
          "    assert_eq!(frozen_bytes.is_empty(), false);",
          "    assert_eq!(&frozen_bytes[..], b\"maximum capacity test\");",
          "    assert!(frozen_bytes.kind() == KIND_ARC || frozen_bytes.kind() == KIND_VEC);",
          "    assert!(frozen_bytes.ptr.is_null() == false);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(131072);",
          "    let input = b\"maximum capacity test\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    assert_eq!(frozen_bytes.len(), 20);",
          "    assert_eq!(frozen_bytes.is_empty(), false);",
          "    assert_eq!(&frozen_bytes[..], b\"maximum capacity test\");",
          "    assert!(frozen_bytes.kind() == KIND_ARC || frozen_bytes.kind() == KIND_VEC);",
          "    assert!(frozen_bytes.ptr.is_null() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(50);",
          "    bytes_mut.truncate(0);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frozen_bytes.len(), 0);",
          "    assert!(frozen_bytes.is_empty());",
          "    assert_eq!(frozen_bytes.as_slice(), &[]);",
          "    assert!(frozen_bytes.is_unique());",
          "    assert!(bytes_mut.kind() == KIND_VEC);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(50);",
          "    bytes_mut.truncate(0);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    assert_eq!(frozen_bytes.len(), 0);",
          "    assert!(frozen_bytes.is_empty());",
          "    assert_eq!(frozen_bytes.as_slice(), &[]);",
          "    assert!(frozen_bytes.is_unique());",
          "    assert!(bytes_mut.kind() == KIND_VEC);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(128);",
          "    let input = b\"capacity equal test\";",
          "    bytes_mut.extend_from_slice(input);",
          "    bytes_mut.resize(128, 0);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "}"
        ],
        "oracle": [
          "    assert!(frozen_bytes.len() == 128);",
          "    assert!(!frozen_bytes.is_empty());",
          "    assert_eq!(&frozen_bytes[..], b\"capacity equal test\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\");",
          "    assert!(frozen_bytes.kind() == KIND_ARC);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(128);",
          "    let input = b\"capacity equal test\";",
          "    bytes_mut.extend_from_slice(input);",
          "    bytes_mut.resize(128, 0);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    assert!(frozen_bytes.len() == 128);",
          "    assert!(!frozen_bytes.is_empty());",
          "    assert_eq!(&frozen_bytes[..], b\"capacity equal test\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\");",
          "    assert!(frozen_bytes.kind() == KIND_ARC);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(20);",
          "    let input = b\"goodbye\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frozen_bytes.len(), 7);",
          "    assert!(!frozen_bytes.is_empty());",
          "    assert_eq!(frozen_bytes.as_slice(), b\"goodbye\");",
          "    assert_eq!(bytes_mut.len(), 8); // To check if the original reference is still intact",
          "    assert!(bytes_mut.capacity() >= 20); // Check if capacity is still maintained",
          "    assert!(bytes_mut.kind() == KIND_VEC); // Check the kind is still KIND_VEC"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(20);",
          "    let input = b\"goodbye\";",
          "    bytes_mut.extend_from_slice(input);",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    assert_eq!(frozen_bytes.len(), 7);",
          "    assert!(!frozen_bytes.is_empty());",
          "    assert_eq!(frozen_bytes.as_slice(), b\"goodbye\");",
          "    assert_eq!(bytes_mut.len(), 8); // To check if the original reference is still intact",
          "    assert!(bytes_mut.capacity() >= 20); // Check if capacity is still maintained",
          "    assert!(bytes_mut.kind() == KIND_VEC); // Check the kind is still KIND_VEC",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]