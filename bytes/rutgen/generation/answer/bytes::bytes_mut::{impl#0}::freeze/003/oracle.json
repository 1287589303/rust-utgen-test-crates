[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::new();",
          "    bytes_mut.extend_from_slice(&[1, 2, 3]); // Non-zero length and filled with data",
          "",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    let cloned_bytes = frozen_bytes.clone();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 3);",
          "    assert!(bytes_mut.is_empty());",
          "    assert_eq!(frozen_bytes.len(), 3);",
          "    assert!(!cloned_bytes.is_empty());",
          "    assert!(frozen_bytes.kind() == KIND_ARC);",
          "    assert_ne!(frozen_bytes.ptr, cloned_bytes.ptr);",
          "    assert_eq!(&frozen_bytes[..], &[1, 2, 3]);",
          "    assert_eq!(&cloned_bytes[..], &[1, 2, 3]);",
          "    assert!(frozen_bytes.data.load(Ordering::SeqCst) as *const u8 != cloned_bytes.data.load(Ordering::SeqCst) as *const u8);",
          "    assert!(frozen_bytes.is_unique());",
          "    assert!(!cloned_bytes.is_unique());"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::new();",
          "    bytes_mut.extend_from_slice(&[1, 2, 3]); // Non-zero length and filled with data",
          "",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    let cloned_bytes = frozen_bytes.clone();",
          "    assert_eq!(bytes_mut.len(), 3);",
          "    assert!(bytes_mut.is_empty());",
          "    assert_eq!(frozen_bytes.len(), 3);",
          "    assert!(!cloned_bytes.is_empty());",
          "    assert!(frozen_bytes.kind() == KIND_ARC);",
          "    assert_ne!(frozen_bytes.ptr, cloned_bytes.ptr);",
          "    assert_eq!(&frozen_bytes[..], &[1, 2, 3]);",
          "    assert_eq!(&cloned_bytes[..], &[1, 2, 3]);",
          "    assert!(frozen_bytes.data.load(Ordering::SeqCst) as *const u8 != cloned_bytes.data.load(Ordering::SeqCst) as *const u8);",
          "    assert!(frozen_bytes.is_unique());",
          "    assert!(!cloned_bytes.is_unique());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::new();",
          "    bytes_mut.extend_from_slice(&[4, 5, 6]); // Non-zero length and filled with data",
          "",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    let cloned_bytes = frozen_bytes.clone();",
          "",
          "    // Create a differing byte slice",
          "    let different_slice = &[7, 8, 9];",
          "    assert_ne!(&frozen_bytes[..], different_slice);",
          "}"
        ],
        "oracle": [
          "    assert!(bytes_mut.kind() != KIND_VEC);",
          "    assert_ne!(&frozen_bytes[..], &[7, 8, 9]);",
          "    assert_eq!(frozen_bytes.len(), 3);",
          "    assert_eq!(frozen_bytes.ptr, bytes_mut.as_ptr());",
          "    assert!(frozen_bytes.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::new();",
          "    bytes_mut.extend_from_slice(&[4, 5, 6]); // Non-zero length and filled with data",
          "",
          "    let frozen_bytes = bytes_mut.freeze();",
          "    let cloned_bytes = frozen_bytes.clone();",
          "",
          "    // Create a differing byte slice",
          "    let different_slice = &[7, 8, 9];",
          "    assert_ne!(&frozen_bytes[..], different_slice);",
          "    assert!(bytes_mut.kind() != KIND_VEC);",
          "    assert_ne!(&frozen_bytes[..], &[7, 8, 9]);",
          "    assert_eq!(frozen_bytes.len(), 3);",
          "    assert_eq!(frozen_bytes.ptr, bytes_mut.as_ptr());",
          "    assert!(frozen_bytes.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]