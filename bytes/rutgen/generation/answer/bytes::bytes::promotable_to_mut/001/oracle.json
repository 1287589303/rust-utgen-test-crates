[
  {
    "uses": [
      "use std::ptr::NonNull;",
      "use std::sync::atomic::Ordering;",
      "use std::sync::atomic::AtomicPtr;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    fn dummy_function(shared: *mut ()) -> *mut u8 {",
          "        // Simulate conversion logic to non-null u8 pointer",
          "        shared as *mut u8",
          "    }",
          "    ",
          "    // Create an AtomicPtr pointing to a valid shared object",
          "    let shared_data: *mut Dummy = Box::into_raw(Box::new(Dummy));",
          "    let atomic_ptr = AtomicPtr::new(shared_data);",
          "    ",
          "    let ptr: *const u8 = NonNull::new(shared_data as *mut u8).unwrap().as_ptr();",
          "    let len: usize = 10;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(kind, KIND_ARC);",
          "    assert!(std::ptr::is_null(ptr) == false);",
          "    assert!(len > 0);",
          "    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.len() == len);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.capacity() >= len);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.is_empty() == false);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }",
          "    .as_slice() as *const _ != ptr);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }",
          "    .ptr.as_ptr() == ptr);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.ptr != shared_data);"
        ],
        "code": [
          "{",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    fn dummy_function(shared: *mut ()) -> *mut u8 {",
          "        // Simulate conversion logic to non-null u8 pointer",
          "        shared as *mut u8",
          "    }",
          "    ",
          "    // Create an AtomicPtr pointing to a valid shared object",
          "    let shared_data: *mut Dummy = Box::into_raw(Box::new(Dummy));",
          "    let atomic_ptr = AtomicPtr::new(shared_data);",
          "    ",
          "    let ptr: *const u8 = NonNull::new(shared_data as *mut u8).unwrap().as_ptr();",
          "    let len: usize = 10;",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    }",
          "    assert_eq!(kind, KIND_ARC);",
          "    assert!(std::ptr::is_null(ptr) == false);",
          "    assert!(len > 0);",
          "    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.len() == len);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.capacity() >= len);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.is_empty() == false);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }",
          "    .as_slice() as *const _ != ptr);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }",
          "    .ptr.as_ptr() == ptr);",
          "    assert!(unsafe { promotable_to_mut(&atomic_ptr, ptr, len, dummy_function) }.ptr != shared_data);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    fn dummy_function(shared: *mut ()) -> *mut u8 {",
          "        shared as *mut u8",
          "    }",
          "",
          "    let shared_data: *mut Dummy = Box::into_raw(Box::new(Dummy));",
          "    let atomic_ptr = AtomicPtr::new(shared_data);",
          "    ",
          "    let ptr: *const u8 = NonNull::new(shared_data as *mut u8).unwrap().as_ptr();",
          "    let len: usize = 1;  // minimum length",
          "",
          "    unsafe {",
          "        promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(kind_of_atomic_ptr(&atomic_ptr), KIND_ARC);",
          "    assert_ne!(ptr, std::ptr::null());",
          "    assert!(len > 0);",
          "    let bytes_mut = promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    assert_eq!(bytes_mut.len(), len);",
          "    assert!(bytes_mut.capacity() >= len);",
          "    assert!(bytes_mut.is_empty() == false);"
        ],
        "code": [
          "{",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    fn dummy_function(shared: *mut ()) -> *mut u8 {",
          "        shared as *mut u8",
          "    }",
          "",
          "    let shared_data: *mut Dummy = Box::into_raw(Box::new(Dummy));",
          "    let atomic_ptr = AtomicPtr::new(shared_data);",
          "    ",
          "    let ptr: *const u8 = NonNull::new(shared_data as *mut u8).unwrap().as_ptr();",
          "    let len: usize = 1;  // minimum length",
          "",
          "    unsafe {",
          "        promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    }",
          "    assert_eq!(kind_of_atomic_ptr(&atomic_ptr), KIND_ARC);",
          "    assert_ne!(ptr, std::ptr::null());",
          "    assert!(len > 0);",
          "    let bytes_mut = promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    assert_eq!(bytes_mut.len(), len);",
          "    assert!(bytes_mut.capacity() >= len);",
          "    assert!(bytes_mut.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    fn dummy_function(shared: *mut ()) -> *mut u8 {",
          "        shared as *mut u8",
          "    }",
          "",
          "    let shared_data: *mut Dummy = Box::into_raw(Box::new(Dummy));",
          "    let atomic_ptr = AtomicPtr::new(shared_data);",
          "    ",
          "    let ptr: *const u8 = NonNull::new(shared_data as *mut u8).unwrap().as_ptr();",
          "    let len: usize = usize::MAX;  // maximum length",
          "",
          "    unsafe {",
          "        promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let shared = atomic_ptr.load(Ordering::Acquire); assert_eq!(shared as usize & KIND_MASK, KIND_ARC);",
          "    let buf = dummy_function(shared); assert!(!buf.is_null());",
          "    let off = offset_from(ptr, buf); assert!(off <= len);",
          "    let cap = off + len; assert!(cap <= usize::MAX);",
          "    let v = Vec::from_raw_parts(buf, cap, cap); assert_eq!(v.len(), cap);",
          "    let b = BytesMut::from_vec(v); assert_eq!(b.len(), cap);",
          "    let new_len = b.len(); assert!(new_len == len);",
          "    assert!(b.ptr.as_ptr() == (ptr as *mut u8).add(off));"
        ],
        "code": [
          "{",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicPtr, Ordering};",
          "",
          "    struct Dummy;",
          "",
          "    fn dummy_function(shared: *mut ()) -> *mut u8 {",
          "        shared as *mut u8",
          "    }",
          "",
          "    let shared_data: *mut Dummy = Box::into_raw(Box::new(Dummy));",
          "    let atomic_ptr = AtomicPtr::new(shared_data);",
          "    ",
          "    let ptr: *const u8 = NonNull::new(shared_data as *mut u8).unwrap().as_ptr();",
          "    let len: usize = usize::MAX;  // maximum length",
          "",
          "    unsafe {",
          "        promotable_to_mut(&atomic_ptr, ptr, len, dummy_function);",
          "    }",
          "    let shared = atomic_ptr.load(Ordering::Acquire); assert_eq!(shared as usize & KIND_MASK, KIND_ARC);",
          "    let buf = dummy_function(shared); assert!(!buf.is_null());",
          "    let off = offset_from(ptr, buf); assert!(off <= len);",
          "    let cap = off + len; assert!(cap <= usize::MAX);",
          "    let v = Vec::from_raw_parts(buf, cap, cap); assert_eq!(v.len(), cap);",
          "    let b = BytesMut::from_vec(v); assert_eq!(b.len(), cap);",
          "    let new_len = b.len(); assert!(new_len == len);",
          "    assert!(b.ptr.as_ptr() == (ptr as *mut u8).add(off));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]