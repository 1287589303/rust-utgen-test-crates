[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let atom = AtomicPtr::new(ptr::null_mut());",
          "    let mut buffer: Vec<u8> = Vec::with_capacity(10);",
          "    buffer.extend_from_slice(&[1, 2, 3, 4, 5]);",
          "    let buf_ptr = buffer.as_mut_ptr();",
          "    let offset = buf_ptr.add(2); // Non-null and within bounds",
          "    let len = 3; // Greater than 0 and less than or equal to capacity",
          "",
          "    // Ensure the shared pointer is null initially",
          "    assert!(atom.load(Ordering::Relaxed).is_null());",
          "",
          "    let result = shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert!(!result.data.load(Ordering::Relaxed).is_null());",
          "    assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);",
          "    assert_eq!(unsafe { (*result.data.load(Ordering::Relaxed) as *mut Shared).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "    assert!(atom.load(Ordering::Relaxed) as usize & KIND_MASK == 0);",
          "    assert!(unsafe { (*result.data.load(Ordering::Relaxed)).buf } == buf_ptr);",
          "    assert!(unsafe { (*result.data.load(Ordering::Relaxed)).cap } == offset_from(offset, buf_ptr) + len);"
        ],
        "code": [
          "{",
          "    let atom = AtomicPtr::new(ptr::null_mut());",
          "    let mut buffer: Vec<u8> = Vec::with_capacity(10);",
          "    buffer.extend_from_slice(&[1, 2, 3, 4, 5]);",
          "    let buf_ptr = buffer.as_mut_ptr();",
          "    let offset = buf_ptr.add(2); // Non-null and within bounds",
          "    let len = 3; // Greater than 0 and less than or equal to capacity",
          "",
          "    // Ensure the shared pointer is null initially",
          "    assert!(atom.load(Ordering::Relaxed).is_null());",
          "",
          "    let result = shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len);",
          "    assert_eq!(result.len, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert!(!result.data.load(Ordering::Relaxed).is_null());",
          "    assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);",
          "    assert_eq!(unsafe { (*result.data.load(Ordering::Relaxed) as *mut Shared).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "    assert!(atom.load(Ordering::Relaxed) as usize & KIND_MASK == 0);",
          "    assert!(unsafe { (*result.data.load(Ordering::Relaxed)).buf } == buf_ptr);",
          "    assert!(unsafe { (*result.data.load(Ordering::Relaxed)).cap } == offset_from(offset, buf_ptr) + len);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let atom = AtomicPtr::new(ptr::null_mut());",
          "    let mut buffer: Vec<u8> = Vec::with_capacity(10);",
          "    buffer.extend_from_slice(&[1, 2, 3, 4, 5]);",
          "    let buf_ptr = buffer.as_mut_ptr();",
          "    let offset = buf_ptr.add(2); // Non-null and within bounds",
          "    let len = 3; // Greater than 0 and less than or equal to capacity",
          "",
          "    // Ensure the shared pointer is null initially",
          "    assert!(atom.load(Ordering::Relaxed).is_null());",
          "",
          "    // Create two clones concurrently",
          "    let handle1 = std::thread::spawn(move || {",
          "        shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len)",
          "    });",
          "",
          "    let handle2 = std::thread::spawn(move || {",
          "        shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len)",
          "    });",
          "",
          "    handle1.join().unwrap();",
          "    handle2.join().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(atom.load(Ordering::Relaxed), ptr::null_mut());",
          "    assert!(buffer.len() == 5);",
          "    assert!(buffer.capacity() >= 10);",
          "    assert!(offset == buf_ptr.add(2));",
          "    assert!(len > 0 && len <= buffer.capacity());",
          "    assert_eq!(share_count_after_clone(&atom), 2);",
          "    assert!(atom.load(Ordering::Acquire) as usize & KIND_MASK == 0);",
          "    assert!(validate_bytes_result(handle1.join().unwrap()));",
          "    assert!(validate_bytes_result(handle2.join().unwrap()));"
        ],
        "code": [
          "{",
          "    let atom = AtomicPtr::new(ptr::null_mut());",
          "    let mut buffer: Vec<u8> = Vec::with_capacity(10);",
          "    buffer.extend_from_slice(&[1, 2, 3, 4, 5]);",
          "    let buf_ptr = buffer.as_mut_ptr();",
          "    let offset = buf_ptr.add(2); // Non-null and within bounds",
          "    let len = 3; // Greater than 0 and less than or equal to capacity",
          "",
          "    // Ensure the shared pointer is null initially",
          "    assert!(atom.load(Ordering::Relaxed).is_null());",
          "",
          "    // Create two clones concurrently",
          "    let handle1 = std::thread::spawn(move || {",
          "        shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len)",
          "    });",
          "",
          "    let handle2 = std::thread::spawn(move || {",
          "        shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len)",
          "    });",
          "",
          "    handle1.join().unwrap();",
          "    handle2.join().unwrap();",
          "    assert_eq!(atom.load(Ordering::Relaxed), ptr::null_mut());",
          "    assert!(buffer.len() == 5);",
          "    assert!(buffer.capacity() >= 10);",
          "    assert!(offset == buf_ptr.add(2));",
          "    assert!(len > 0 && len <= buffer.capacity());",
          "    assert_eq!(share_count_after_clone(&atom), 2);",
          "    assert!(atom.load(Ordering::Acquire) as usize & KIND_MASK == 0);",
          "    assert!(validate_bytes_result(handle1.join().unwrap()));",
          "    assert!(validate_bytes_result(handle2.join().unwrap()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let atom = AtomicPtr::new(ptr::null_mut());",
          "    let mut buffer: Vec<u8> = Vec::with_capacity(10);",
          "    let buf_ptr = buffer.as_mut_ptr();",
          "    let offset = buf_ptr; // Non-null and within bounds",
          "    let len = 0; // Less than or equal to capacity, but edge case for zero length",
          "",
          "    // Ensure the shared pointer is null initially",
          "    assert!(atom.load(Ordering::Relaxed).is_null());",
          "",
          "    let result = shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len, 0);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(unsafe { result.data.load(Ordering::Relaxed) as usize & KIND_MASK }, 0);",
          "    assert!(result.vtable.is_unique(&result.data));",
          "    assert_eq!(unsafe { (*result.data.load(Ordering::Relaxed)).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "    assert!(atom.load(Ordering::Relaxed) as *const _ == buf_ptr);"
        ],
        "code": [
          "{",
          "    let atom = AtomicPtr::new(ptr::null_mut());",
          "    let mut buffer: Vec<u8> = Vec::with_capacity(10);",
          "    let buf_ptr = buffer.as_mut_ptr();",
          "    let offset = buf_ptr; // Non-null and within bounds",
          "    let len = 0; // Less than or equal to capacity, but edge case for zero length",
          "",
          "    // Ensure the shared pointer is null initially",
          "    assert!(atom.load(Ordering::Relaxed).is_null());",
          "",
          "    let result = shallow_clone_vec(&atom, buf_ptr as _, buf_ptr, offset, len);",
          "    assert_eq!(result.len, 0);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(unsafe { result.data.load(Ordering::Relaxed) as usize & KIND_MASK }, 0);",
          "    assert!(result.vtable.is_unique(&result.data));",
          "    assert_eq!(unsafe { (*result.data.load(Ordering::Relaxed)).ref_cnt.load(Ordering::Relaxed) }, 2);",
          "    assert!(atom.load(Ordering::Relaxed) as *const _ == buf_ptr);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]