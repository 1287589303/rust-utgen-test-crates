[
  {
    "uses": [
      "use core::ptr::NonNull;",
      "use alloc::vec::Vec;",
      "use core::sync::atomic::AtomicPtr;",
      "use core::thread;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::NonNull;",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(1) // offset within bounds of buf",
          "    };",
          "",
          "    unsafe {",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        // The following reference/expression: ",
          "        // Bytes { ptr: offset, len, data: AtomicPtr::new(shared as _), vtable: &SHARED_VTABLE }",
          "        // is expected to be valid post-call.",
          "    }",
          "}"
        ],
        "oracle": [
          "    unsafe fn test_shallow_clone_vec_invalid_shared() {",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "    ",
          "    let offset: *const u8 = unsafe {",
          "    ptr.add(1) // offset within bounds of buf",
          "    };",
          "    ",
          "    // Modify ptr to simulate failure of pointer alignment precondition",
          "    let shared = Box::new(Shared {",
          "    buf: buffer.as_mut_ptr(),",
          "    cap: len,",
          "    ref_cnt: AtomicUsize::new(2),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    assert!(0 != (shared_ptr as usize & KIND_MASK)); // Ensure precondition",
          "    ",
          "    unsafe {",
          "    let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(result.data.load(Ordering::Relaxed) == shared_ptr as *mut ());",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    }",
          "    }",
          "    ",
          "    unsafe fn test_shallow_clone_vec_success() {",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "    ",
          "    let offset: *const u8 = unsafe {",
          "    ptr.add(1) // offset within bounds of buf",
          "    };",
          "    ",
          "    unsafe {",
          "    let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(result.data.load(Ordering::Relaxed) as usize == shared_ptr as usize);",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    }",
          "    }",
          "    ",
          "    unsafe fn test_shallow_clone_vec_concurrent_success() {",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "    ",
          "    let offset: *const u8 = unsafe {",
          "    ptr.add(1) // offset within bounds of buf",
          "    };",
          "    ",
          "    unsafe {",
          "    // Mimic concurrent modification",
          "    atom.store(ptr as *mut ());",
          "    ",
          "    let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(result.data.load(Ordering::Relaxed) == original_shared_ptr); // original shared pointer after compare exchange",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    }",
          "    }"
        ],
        "code": [
          "{",
          "    use core::ptr::NonNull;",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(1) // offset within bounds of buf",
          "    };",
          "",
          "    unsafe {",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        // The following reference/expression: ",
          "        // Bytes { ptr: offset, len, data: AtomicPtr::new(shared as _), vtable: &SHARED_VTABLE }",
          "        // is expected to be valid post-call.",
          "    }",
          "    unsafe fn test_shallow_clone_vec_invalid_shared() {",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "    ",
          "    let offset: *const u8 = unsafe {",
          "    ptr.add(1) // offset within bounds of buf",
          "    };",
          "    ",
          "    // Modify ptr to simulate failure of pointer alignment precondition",
          "    let shared = Box::new(Shared {",
          "    buf: buffer.as_mut_ptr(),",
          "    cap: len,",
          "    ref_cnt: AtomicUsize::new(2),",
          "    });",
          "    let shared_ptr = Box::into_raw(shared);",
          "    assert!(0 != (shared_ptr as usize & KIND_MASK)); // Ensure precondition",
          "    ",
          "    unsafe {",
          "    let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(result.data.load(Ordering::Relaxed) == shared_ptr as *mut ());",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    }",
          "    }",
          "    ",
          "    unsafe fn test_shallow_clone_vec_success() {",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "    ",
          "    let offset: *const u8 = unsafe {",
          "    ptr.add(1) // offset within bounds of buf",
          "    };",
          "    ",
          "    unsafe {",
          "    let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(result.data.load(Ordering::Relaxed) as usize == shared_ptr as usize);",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    }",
          "    }",
          "    ",
          "    unsafe fn test_shallow_clone_vec_concurrent_success() {",
          "    let buffer: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "    ",
          "    let offset: *const u8 = unsafe {",
          "    ptr.add(1) // offset within bounds of buf",
          "    };",
          "    ",
          "    unsafe {",
          "    // Mimic concurrent modification",
          "    atom.store(ptr as *mut ());",
          "    ",
          "    let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(result.data.load(Ordering::Relaxed) == original_shared_ptr); // original shared pointer after compare exchange",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "    }",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::NonNull;",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "",
          "    let buffer: Vec<u8> = vec![10, 20, 30, 40, 50];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = 3; // choosing a specific length less than buffer.len()",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(2) // offset within bounds of buf",
          "    };",
          "",
          "    unsafe {",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        // The expected result structure has ptr as offset, len, and data initialized correctly.",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(result.ptr == offset);",
          "    assert!(result.len == len);",
          "    assert!(result.data.load(Ordering::SeqCst) as usize & KIND_MASK == 0);",
          "    assert!(result.vtable == &SHARED_VTABLE);"
        ],
        "code": [
          "{",
          "    use core::ptr::NonNull;",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "",
          "    let buffer: Vec<u8> = vec![10, 20, 30, 40, 50];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = 3; // choosing a specific length less than buffer.len()",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(2) // offset within bounds of buf",
          "    };",
          "",
          "    unsafe {",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        // The expected result structure has ptr as offset, len, and data initialized correctly.",
          "    }",
          "    assert!(result.ptr == offset);",
          "    assert!(result.len == len);",
          "    assert!(result.data.load(Ordering::SeqCst) as usize & KIND_MASK == 0);",
          "    assert!(result.vtable == &SHARED_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::NonNull;",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "    use core::thread;",
          "",
          "    let buffer: Vec<u8> = vec![100, 200, 300, 400, 500];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // valid length",
          "    let atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(1) // offset within bounds",
          "    };",
          "",
          "    // Spawn a thread that will attempt to clone concurrently",
          "    let handle = thread::spawn(move || {",
          "        unsafe {",
          "            shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        }",
          "    });",
          "",
          "    unsafe {",
          "        // Attempt to clone in the main thread also",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    }",
          "",
          "    handle.join().unwrap(); // Ensure the thread completes",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(unsafe { result.data.load(core::sync::atomic::Ordering::SeqCst) } as usize & KIND_MASK == 0);",
          "    assert_eq!(result.vtable, &SHARED_VTABLE);",
          "    assert!(result.data.load(core::sync::atomic::Ordering::SeqCst) != ptr as *mut ());",
          "    ",
          "    assert!(atom.compare_exchange(ptr as _, result.data.load(core::sync::atomic::Ordering::SeqCst), core::sync::atomic::Ordering::AcqRel, core::sync::atomic::Ordering::Acquire).is_ok());",
          "    assert!(actual as usize == ptr as usize);",
          "    assert!(result.data.load(core::sync::atomic::Ordering::SeqCst) != ptr);",
          "    ",
          "    let shared_ptr = result.data.load(core::sync::atomic::Ordering::SeqCst);",
          "    assert!(shared_ptr != std::ptr::null_mut());",
          "    assert!(len > 0);"
        ],
        "code": [
          "{",
          "    use core::ptr::NonNull;",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "    use core::thread;",
          "",
          "    let buffer: Vec<u8> = vec![100, 200, 300, 400, 500];",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // valid length",
          "    let atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(1) // offset within bounds",
          "    };",
          "",
          "    // Spawn a thread that will attempt to clone concurrently",
          "    let handle = thread::spawn(move || {",
          "        unsafe {",
          "            shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        }",
          "    });",
          "",
          "    unsafe {",
          "        // Attempt to clone in the main thread also",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "    }",
          "",
          "    handle.join().unwrap(); // Ensure the thread completes",
          "    assert_eq!(result.ptr, offset);",
          "    assert_eq!(result.len, len);",
          "    assert!(unsafe { result.data.load(core::sync::atomic::Ordering::SeqCst) } as usize & KIND_MASK == 0);",
          "    assert_eq!(result.vtable, &SHARED_VTABLE);",
          "    assert!(result.data.load(core::sync::atomic::Ordering::SeqCst) != ptr as *mut ());",
          "    ",
          "    assert!(atom.compare_exchange(ptr as _, result.data.load(core::sync::atomic::Ordering::SeqCst), core::sync::atomic::Ordering::AcqRel, core::sync::atomic::Ordering::Acquire).is_ok());",
          "    assert!(actual as usize == ptr as usize);",
          "    assert!(result.data.load(core::sync::atomic::Ordering::SeqCst) != ptr);",
          "    ",
          "    let shared_ptr = result.data.load(core::sync::atomic::Ordering::SeqCst);",
          "    assert!(shared_ptr != std::ptr::null_mut());",
          "    assert!(len > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "",
          "    let buffer: Vec<u8> = (0..100_000).map(|x| x as u8).collect(); // large input",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(100) // offset within bounds of buf",
          "    };",
          "",
          "    unsafe {",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        // Validate expected result format and fields ",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(result.ptr == offset);",
          "    assert!(result.len == len);",
          "    assert!(result.data.load(Ordering::Relaxed) != ptr as *mut ());",
          "    assert_eq!(result.vtable, &SHARED_VTABLE);"
        ],
        "code": [
          "{",
          "    use alloc::vec::Vec;",
          "    use core::sync::atomic::AtomicPtr;",
          "",
          "    let buffer: Vec<u8> = (0..100_000).map(|x| x as u8).collect(); // large input",
          "    let ptr = buffer.as_ptr(); // valid non-null pointer",
          "    let len = buffer.len(); // len is > 0 and <= capacity",
          "    let mut atom = AtomicPtr::new(ptr as *mut ());",
          "",
          "    let offset: *const u8 = unsafe {",
          "        ptr.add(100) // offset within bounds of buf",
          "    };",
          "",
          "    unsafe {",
          "        let result = shallow_clone_vec(&atom, ptr, buffer.as_mut_ptr(), offset, len);",
          "        // Validate expected result format and fields ",
          "    }",
          "    assert!(result.ptr == offset);",
          "    assert!(result.len == len);",
          "    assert!(result.data.load(Ordering::Relaxed) != ptr as *mut ());",
          "    assert_eq!(result.vtable, &SHARED_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]