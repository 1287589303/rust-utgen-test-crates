[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut shared = Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.buf).unwrap(),",
          "        len: 5,",
          "        cap: 10,",
          "        data: &mut shared as *mut Shared,",
          "    };",
          "",
          "    // Call drop method",
          "    let _ = std::mem::ManuallyDrop::new(bytes_mut);",
          "}"
        ],
        "oracle": [
          "    let kind = bytes_mut.kind(); assert_eq!(kind, KIND_ARC);",
          "    let ref_count_after_drop = unsafe { (*bytes_mut.data).ref_cnt.load(Ordering::SeqCst) }; assert_eq!(ref_count_after_drop, 0);",
          "    let buf_after_drop = unsafe { (*bytes_mut.data).buf }; assert!(buf_after_drop.is_null());",
          "    let cap_after_drop = unsafe { (*bytes_mut.data).cap }; assert_eq!(cap_after_drop, 10);"
        ],
        "code": [
          "{",
          "    let mut shared = Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.buf).unwrap(),",
          "        len: 5,",
          "        cap: 10,",
          "        data: &mut shared as *mut Shared,",
          "    };",
          "",
          "    // Call drop method",
          "    let _ = std::mem::ManuallyDrop::new(bytes_mut);",
          "    let kind = bytes_mut.kind(); assert_eq!(kind, KIND_ARC);",
          "    let ref_count_after_drop = unsafe { (*bytes_mut.data).ref_cnt.load(Ordering::SeqCst) }; assert_eq!(ref_count_after_drop, 0);",
          "    let buf_after_drop = unsafe { (*bytes_mut.data).buf }; assert!(buf_after_drop.is_null());",
          "    let cap_after_drop = unsafe { (*bytes_mut.data).cap }; assert_eq!(cap_after_drop, 10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut shared = Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 15])) as *mut u8,",
          "        cap: 15,",
          "        ref_cnt: AtomicUsize::new(5), // Reference count greater than 1",
          "    };",
          "",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.buf).unwrap(),",
          "        len: 7,",
          "        cap: 15,",
          "        data: &mut shared as *mut Shared,",
          "    };",
          "",
          "    // Call drop method",
          "    let _ = std::mem::ManuallyDrop::new(bytes_mut);",
          "}"
        ],
        "oracle": [
          "    let kind = bytes_mut.kind(); assert_eq!(kind, KIND_ARC);",
          "    let ref_cnt = unsafe { (*bytes_mut.data).ref_count.load(Ordering::Acquire) }; assert_eq!(ref_cnt, 5);",
          "    let buf = unsafe { (*bytes_mut.data).buf }; assert!(!buf.is_null());",
          "    let cap = unsafe { (*bytes_mut.data).cap }; assert_eq!(cap, 15);",
          "    let shared_ref_cnt = unsafe { (*bytes_mut.data).ref_cnt.load(Ordering::Acquire) }; assert_eq!(shared_ref_cnt, 4);"
        ],
        "code": [
          "{",
          "    let mut shared = Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 15])) as *mut u8,",
          "        cap: 15,",
          "        ref_cnt: AtomicUsize::new(5), // Reference count greater than 1",
          "    };",
          "",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.buf).unwrap(),",
          "        len: 7,",
          "        cap: 15,",
          "        data: &mut shared as *mut Shared,",
          "    };",
          "",
          "    // Call drop method",
          "    let _ = std::mem::ManuallyDrop::new(bytes_mut);",
          "    let kind = bytes_mut.kind(); assert_eq!(kind, KIND_ARC);",
          "    let ref_cnt = unsafe { (*bytes_mut.data).ref_count.load(Ordering::Acquire) }; assert_eq!(ref_cnt, 5);",
          "    let buf = unsafe { (*bytes_mut.data).buf }; assert!(!buf.is_null());",
          "    let cap = unsafe { (*bytes_mut.data).cap }; assert_eq!(cap, 15);",
          "    let shared_ref_cnt = unsafe { (*bytes_mut.data).ref_cnt.load(Ordering::Acquire) }; assert_eq!(shared_ref_cnt, 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]