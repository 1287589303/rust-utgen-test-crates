[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &b\"\\x12\\x34\"[..];",
          "    let result = buf.get_u16();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(0x1234, result);",
          "    let mut buf: &[u8] = &b\"\\x00\\x00\"[..];",
          "    assert_eq!(0x0000, buf.get_u16());",
          "    let mut buf: &[u8] = &b\"\\x01\\x02\\x03\\x04\"[..];",
          "    buf.advance(2);",
          "    assert_eq!(0x0102, buf.get_u16());",
          "    let mut buf: &[u8] = &b\"\\x01\"[..];",
          "    panic::catch_unwind(|| { buf.get_u16(); }).unwrap_err();"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &b\"\\x12\\x34\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(0x1234, result);",
          "    let mut buf: &[u8] = &b\"\\x00\\x00\"[..];",
          "    assert_eq!(0x0000, buf.get_u16());",
          "    let mut buf: &[u8] = &b\"\\x01\\x02\\x03\\x04\"[..];",
          "    buf.advance(2);",
          "    assert_eq!(0x0102, buf.get_u16());",
          "    let mut buf: &[u8] = &b\"\\x01\"[..];",
          "    panic::catch_unwind(|| { buf.get_u16(); }).unwrap_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &b\"\\x12\"[..];",
          "    let result = buf.get_u16();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.remaining(), 1);",
          "    assert_eq!(panic_does_not_fit(), true);",
          "    assert!(std::panic::catch_unwind(|| buf.get_u16()).is_err());",
          "    assert_eq!(buf.remaining(), 1);",
          "    assert!(buf.has_remaining());",
          "    assert_eq!(result, 0);"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &b\"\\x12\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(buf.remaining(), 1);",
          "    assert_eq!(panic_does_not_fit(), true);",
          "    assert!(std::panic::catch_unwind(|| buf.get_u16()).is_err());",
          "    assert_eq!(buf.remaining(), 1);",
          "    assert!(buf.has_remaining());",
          "    assert_eq!(result, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &b\"\\x00\\x00\"[..];",
          "    let result = buf.get_u16();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0x0000);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\x08\\x09\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0x0809);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\xFF\\xFF\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0xFFFF);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\x01\\x02\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0x0102);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\xAA\\xBB\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0xAABB);",
          "    ",
          "    let mut buf: &[u8] = &b\"\"[..];",
          "    let result = std::panic::catch_unwind(|| {",
          "    buf.get_u16();",
          "    });",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &b\"\\x00\\x00\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0x0000);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\x08\\x09\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0x0809);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\xFF\\xFF\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0xFFFF);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\x01\\x02\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0x0102);",
          "    ",
          "    let mut buf: &[u8] = &b\"\\xAA\\xBB\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0xAABB);",
          "    ",
          "    let mut buf: &[u8] = &b\"\"[..];",
          "    let result = std::panic::catch_unwind(|| {",
          "    buf.get_u16();",
          "    });",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &b\"\\xFF\\xFF\"[..];",
          "    let result = buf.get_u16();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0xFFFF);",
          "    assert_eq!(buf.remaining(), 0);"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &b\"\\xFF\\xFF\"[..];",
          "    let result = buf.get_u16();",
          "    assert_eq!(result, 0xFFFF);",
          "    assert_eq!(buf.remaining(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &b\"\\xAB\\xCD\\xEF\\x12\"[..];",
          "    let result_first = buf.get_u16();",
          "    let result_second = buf.get_u16();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result_first, 0xABCD);",
          "    assert_eq!(result_second, 0xEF12);",
          "    assert_eq!(buf.remaining(), 0);",
          "    assert!(buf.has_remaining() == false);"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &b\"\\xAB\\xCD\\xEF\\x12\"[..];",
          "    let result_first = buf.get_u16();",
          "    let result_second = buf.get_u16();",
          "    assert_eq!(result_first, 0xABCD);",
          "    assert_eq!(result_second, 0xEF12);",
          "    assert_eq!(buf.remaining(), 0);",
          "    assert!(buf.has_remaining() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]