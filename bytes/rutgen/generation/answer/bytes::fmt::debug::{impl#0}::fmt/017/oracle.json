[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[b'\\n', b'\\\\', b'a', 0x00];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\")? is Ok",
          "    &b in self.0 is true",
          "    b == b'\\n' is true",
          "    b == b'\\\\' is true",
          "    b == b'a' is true",
          "    b == b'\\0' is false",
          "    write!(f, \"\\\\0\")? is Err"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[b'\\n', b'\\\\', b'a', 0x00];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\")? is Ok",
          "    &b in self.0 is true",
          "    b == b'\\n' is true",
          "    b == b'\\\\' is true",
          "    b == b'a' is true",
          "    b == b'\\0' is false",
          "    write!(f, \"\\\\0\")? is Err",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[b'\\r', b'\\\\', b'a', 0x01];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\")?;",
          "    self.0.len() > 0;",
          "    b == b'\\n';",
          "    b == b'\\r';",
          "    b == b'\\t';",
          "    b == b'\\\\';",
          "    b == b'\"';",
          "    b == b'\\0';",
          "    write!(f, \"\\\\0\")?;",
          "    b == 0x01;",
          "    write!(f, \"\\\\x{:02x}\", b)?;"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[b'\\r', b'\\\\', b'a', 0x01];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\")?;",
          "    self.0.len() > 0;",
          "    b == b'\\n';",
          "    b == b'\\r';",
          "    b == b'\\t';",
          "    b == b'\\\\';",
          "    b == b'\"';",
          "    b == b'\\0';",
          "    write!(f, \"\\\\0\")?;",
          "    b == 0x01;",
          "    write!(f, \"\\\\x{:02x}\", b)?;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[b'\\t', b'\\\\', b'a', 0x02];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\")? == Ok",
          "    &b in self.0 == true",
          "    b == b'\\n' == false",
          "    b == b'\\r' == false",
          "    b == b'\\t' == true",
          "    b == b'\\\\' == true",
          "    b == b'\"' == false",
          "    b == b'\\0' == false",
          "    write!(f, \"\\\\0\")? == Err"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[b'\\t', b'\\\\', b'a', 0x02];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\")? == Ok",
          "    &b in self.0 == true",
          "    b == b'\\n' == false",
          "    b == b'\\r' == false",
          "    b == b'\\t' == true",
          "    b == b'\\\\' == true",
          "    b == b'\"' == false",
          "    b == b'\\0' == false",
          "    write!(f, \"\\\\0\")? == Err",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[b'\\\\', b'\\\\', b'a', 0x03];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\n'])), \"b\\\"\\\\n\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\r'])), \"b\\\"\\\\r\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\t'])), \"b\\\"\\\\t\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\\\'])), \"b\\\"\\\\\\\\\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\\"'])), \"b\\\"\\\\\\\"\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\0'])), \"b\\\"\\\\0\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'a'])), \"b\\\"a\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[0x01])), \"b\\\"\\\\x01\\\"\");",
          "    assert!(format!(\"{:?}\", BytesRef(&[b'\\0'])).contains(\"\\\\0\").not());"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[b'\\\\', b'\\\\', b'a', 0x03];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\n'])), \"b\\\"\\\\n\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\r'])), \"b\\\"\\\\r\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\t'])), \"b\\\"\\\\t\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\\\'])), \"b\\\"\\\\\\\\\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\\"'])), \"b\\\"\\\\\\\"\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'\\0'])), \"b\\\"\\\\0\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[b'a'])), \"b\\\"a\\\"\");",
          "    assert_eq!(format!(\"{:?}\", BytesRef(&[0x01])), \"b\\\"\\\\x01\\\"\");",
          "    assert!(format!(\"{:?}\", BytesRef(&[b'\\0'])).contains(\"\\\\0\").not());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[b'\"', b'\\\\', b'a', 0x04];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\").is_ok()",
          "    self.0.len() > 0",
          "    b == b'\\n'",
          "    b == b'\\r'",
          "    b == b'\\t'",
          "    b == b'\\\\'",
          "    b == b'\"'",
          "    b != b'\\0'",
          "    write!(f, \"\\\\0\").is_err()"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[b'\"', b'\\\\', b'a', 0x04];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\").is_ok()",
          "    self.0.len() > 0",
          "    b == b'\\n'",
          "    b == b'\\r'",
          "    b == b'\\t'",
          "    b == b'\\\\'",
          "    b == b'\"'",
          "    b != b'\\0'",
          "    write!(f, \"\\\\0\").is_err()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[0x01, 0x02, 0x03, 0x04, 0x00];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\")? == Ok",
          "    &b in self.0 == true",
          "    b == b'\\n' == true",
          "    b == b'\\r' == true",
          "    b == b'\\t' == true",
          "    b == b'\\\\' == true",
          "    b == b'\"' == true",
          "    b == b'\\0' == false",
          "    write!(f, \"\\\\0\")? == Err"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[0x01, 0x02, 0x03, 0x04, 0x00];",
          "    let bytes_ref = BytesRef(data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\")? == Ok",
          "    &b in self.0 == true",
          "    b == b'\\n' == true",
          "    b == b'\\r' == true",
          "    b == b'\\t' == true",
          "    b == b'\\\\' == true",
          "    b == b'\"' == true",
          "    b == b'\\0' == false",
          "    write!(f, \"\\\\0\")? == Err",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]