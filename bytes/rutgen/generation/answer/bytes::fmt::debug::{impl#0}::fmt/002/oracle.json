[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = [0x00, 0x01, 0x1F, 0x80]; // Non-printable and out-of-range bytes",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\")?;",
          "    &b in self.0;",
          "    b == b'\\n';",
          "    write!(f, \"\\\\n\")?;"
        ],
        "code": [
          "{",
          "    let data = [0x00, 0x01, 0x1F, 0x80]; // Non-printable and out-of-range bytes",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\")?;",
          "    &b in self.0;",
          "    b == b'\\n';",
          "    write!(f, \"\\\\n\")?;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = [b'\\\\', b'\"']; // Escape characters",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\")?;",
          "    for &b in self.0 {",
          "    write!(f, \"\\\\n\")?;",
          "    write!(f, \"\\\\r\")?;",
          "    write!(f, \"\\\\t\")?;",
          "    write!(f, \"\\\\{}\", b as char)?;",
          "    write!(f, \"\\\\0\")?;",
          "    write!(f, \"{}\", b as char)?;",
          "    write!(f, \"\\\\x{:02x}\", b)?;",
          "    Ok(())?;",
          "    b == b'\\n';",
          "    &b in self.0;",
          "    write!(f, \"\\\\n\")?;",
          "    Err(())?;"
        ],
        "code": [
          "{",
          "    let data = [b'\\\\', b'\"']; // Escape characters",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\")?;",
          "    for &b in self.0 {",
          "    write!(f, \"\\\\n\")?;",
          "    write!(f, \"\\\\r\")?;",
          "    write!(f, \"\\\\t\")?;",
          "    write!(f, \"\\\\{}\", b as char)?;",
          "    write!(f, \"\\\\0\")?;",
          "    write!(f, \"{}\", b as char)?;",
          "    write!(f, \"\\\\x{:02x}\", b)?;",
          "    Ok(())?;",
          "    b == b'\\n';",
          "    &b in self.0;",
          "    write!(f, \"\\\\n\")?;",
          "    Err(())?;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = [b'a', b' ', b'~']; // Printable characters",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    assert!(write!(f, \"b\\\"\").is_ok());",
          "    assert!(self.0.len() > 0);",
          "    assert!(self.0.iter().all(|&b| b != b'\\n'));",
          "    assert!(write!(f, \"\\\\n\").is_err());"
        ],
        "code": [
          "{",
          "    let data = [b'a', b' ', b'~']; // Printable characters",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    assert!(write!(f, \"b\\\"\").is_ok());",
          "    assert!(self.0.len() > 0);",
          "    assert!(self.0.iter().all(|&b| b != b'\\n'));",
          "    assert!(write!(f, \"\\\\n\").is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = [0x20, b'\\\\', b'\"', 0x7E, 0x1F, 0x80]; // Mixed printable, escape, and non-printable",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"b\\\"\")? == Ok",
          "    &b in self.0 == true",
          "    b == b'\\n' == false",
          "    write!(f, \"\\\\n\")? == Err"
        ],
        "code": [
          "{",
          "    let data = [0x20, b'\\\\', b'\"', 0x7E, 0x1F, 0x80]; // Mixed printable, escape, and non-printable",
          "    let bytes_ref = BytesRef(&data);",
          "    let _ = format!(\"{:?}\", bytes_ref);",
          "    write!(f, \"b\\\"\")? == Ok",
          "    &b in self.0 == true",
          "    b == b'\\n' == false",
          "    write!(f, \"\\\\n\")? == Err",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]