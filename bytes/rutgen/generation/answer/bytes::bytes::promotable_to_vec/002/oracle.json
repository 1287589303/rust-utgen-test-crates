[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestShared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    let mut shared_data = TestShared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let shared_ptr = NonNull::new(&mut shared_data as *mut _ as *mut ()).unwrap();",
          "    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(shared_ptr.as_ptr());",
          "",
          "    let data = &atomic_ptr;",
          "    let buffer_ptr: *const u8 = shared_data.buf;",
          "    let length: usize = 5;",
          "",
          "    extern \"C\" fn buffer_handler(shared: *mut ()) -> *mut u8 {",
          "        let shared_ref = unsafe { &mut *(shared as *mut TestShared) };",
          "        shared_ref.buf",
          "    }",
          "",
          "    let _result = unsafe {",
          "        promotable_to_vec(data, buffer_ptr, length, buffer_handler)",
          "    };",
          "}"
        ],
        "oracle": [
          "    assert_eq!(kind & KIND_MASK, KIND_VEC);",
          "    assert_eq!(_result.len(), length);",
          "    assert!(_result.capacity() >= length);",
          "    unsafe { assert_eq!(*_result.as_ptr(), *buffer_ptr); }",
          "    assert_eq!(atomic_ptr.load(Ordering::Acquire) as usize & KIND_MASK, KIND_VEC);"
        ],
        "code": [
          "{",
          "    struct TestShared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    let mut shared_data = TestShared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let shared_ptr = NonNull::new(&mut shared_data as *mut _ as *mut ()).unwrap();",
          "    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(shared_ptr.as_ptr());",
          "",
          "    let data = &atomic_ptr;",
          "    let buffer_ptr: *const u8 = shared_data.buf;",
          "    let length: usize = 5;",
          "",
          "    extern \"C\" fn buffer_handler(shared: *mut ()) -> *mut u8 {",
          "        let shared_ref = unsafe { &mut *(shared as *mut TestShared) };",
          "        shared_ref.buf",
          "    }",
          "",
          "    let _result = unsafe {",
          "        promotable_to_vec(data, buffer_ptr, length, buffer_handler)",
          "    };",
          "    assert_eq!(kind & KIND_MASK, KIND_VEC);",
          "    assert_eq!(_result.len(), length);",
          "    assert!(_result.capacity() >= length);",
          "    unsafe { assert_eq!(*_result.as_ptr(), *buffer_ptr); }",
          "    assert_eq!(atomic_ptr.load(Ordering::Acquire) as usize & KIND_MASK, KIND_VEC);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestShared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    let mut shared_data = TestShared {",
          "        buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let shared_ptr = NonNull::new(&mut shared_data as *mut _ as *mut ()).unwrap();",
          "    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(shared_ptr.as_ptr());",
          "",
          "    let data = &atomic_ptr;",
          "    let buffer_ptr: *const u8 = shared_data.buf;",
          "    let length: usize = 1;",
          "",
          "    extern \"C\" fn buffer_handler(shared: *mut ()) -> *mut u8 {",
          "        let shared_ref = unsafe { &mut *(shared as *mut TestShared) };",
          "        shared_ref.buf",
          "    }",
          "",
          "    let _result = unsafe {",
          "        promotable_to_vec(data, buffer_ptr, length, buffer_handler)",
          "    };",
          "}"
        ],
        "oracle": [
          "    atomic_ptr.store(shared_ptr.as_ptr(), Ordering::Release);",
          "    assert_eq!(atomic_ptr.load(Ordering::Acquire), shared_ptr.as_ptr());",
          "    let returned_vec = unsafe { promotable_to_vec(data, buffer_ptr, length, buffer_handler) };",
          "    assert_eq!(returned_vec.len(), length);",
          "    assert_eq!(returned_vec[0], 1);",
          "    assert!(shared_data.ref_cnt.load(Ordering::Relaxed) > 0);"
        ],
        "code": [
          "{",
          "    struct TestShared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    let mut shared_data = TestShared {",
          "        buf: Box::into_raw(Box::new([1u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let shared_ptr = NonNull::new(&mut shared_data as *mut _ as *mut ()).unwrap();",
          "    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(shared_ptr.as_ptr());",
          "",
          "    let data = &atomic_ptr;",
          "    let buffer_ptr: *const u8 = shared_data.buf;",
          "    let length: usize = 1;",
          "",
          "    extern \"C\" fn buffer_handler(shared: *mut ()) -> *mut u8 {",
          "        let shared_ref = unsafe { &mut *(shared as *mut TestShared) };",
          "        shared_ref.buf",
          "    }",
          "",
          "    let _result = unsafe {",
          "        promotable_to_vec(data, buffer_ptr, length, buffer_handler)",
          "    };",
          "    atomic_ptr.store(shared_ptr.as_ptr(), Ordering::Release);",
          "    assert_eq!(atomic_ptr.load(Ordering::Acquire), shared_ptr.as_ptr());",
          "    let returned_vec = unsafe { promotable_to_vec(data, buffer_ptr, length, buffer_handler) };",
          "    assert_eq!(returned_vec.len(), length);",
          "    assert_eq!(returned_vec[0], 1);",
          "    assert!(shared_data.ref_cnt.load(Ordering::Relaxed) > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestShared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    let mut shared_data = TestShared {",
          "        buf: Box::into_raw(Box::new([2u8; 100])) as *mut u8,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let shared_ptr = NonNull::new(&mut shared_data as *mut _ as *mut ()).unwrap();",
          "    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(shared_ptr.as_ptr());",
          "",
          "    let data = &atomic_ptr;",
          "    let buffer_ptr: *const u8 = shared_data.buf;",
          "    let length: usize = 10;",
          "",
          "    extern \"C\" fn buffer_handler(shared: *mut ()) -> *mut u8 {",
          "        let shared_ref = unsafe { &mut *(shared as *mut TestShared) };",
          "        shared_ref.buf",
          "    }",
          "",
          "    let _result = unsafe {",
          "        promotable_to_vec(data, buffer_ptr, length, buffer_handler)",
          "    };",
          "}"
        ],
        "oracle": [
          "    assert_eq!(unsafe { data.load(Ordering::Acquire) as usize & KIND_MASK }, KIND_VEC);",
          "    assert!(unsafe { (*shared_data.ref_cnt.get_mut()) == 1 });",
          "    assert_eq!(unsafe { ptr::read(buffer_ptr) }, 2u8);",
          "    let result = unsafe { promotable_to_vec(data, buffer_ptr, length, buffer_handler) };",
          "    assert_eq!(result.len(), length);",
          "    assert_eq!(result[0], 2u8);",
          "    assert_eq!(result[1], 2u8);",
          "    assert_eq!(result[2], 2u8);",
          "    assert_eq!(result[3], 2u8);",
          "    assert_eq!(result[4], 2u8);",
          "    assert_eq!(result[5], 2u8);",
          "    assert_eq!(result[6], 2u8);",
          "    assert_eq!(result[7], 2u8);",
          "    assert_eq!(result[8], 2u8);",
          "    assert_eq!(result[9], 2u8);"
        ],
        "code": [
          "{",
          "    struct TestShared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    let mut shared_data = TestShared {",
          "        buf: Box::into_raw(Box::new([2u8; 100])) as *mut u8,",
          "        cap: 100,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    };",
          "",
          "    let shared_ptr = NonNull::new(&mut shared_data as *mut _ as *mut ()).unwrap();",
          "    let atomic_ptr: AtomicPtr<()> = AtomicPtr::new(shared_ptr.as_ptr());",
          "",
          "    let data = &atomic_ptr;",
          "    let buffer_ptr: *const u8 = shared_data.buf;",
          "    let length: usize = 10;",
          "",
          "    extern \"C\" fn buffer_handler(shared: *mut ()) -> *mut u8 {",
          "        let shared_ref = unsafe { &mut *(shared as *mut TestShared) };",
          "        shared_ref.buf",
          "    }",
          "",
          "    let _result = unsafe {",
          "        promotable_to_vec(data, buffer_ptr, length, buffer_handler)",
          "    };",
          "    assert_eq!(unsafe { data.load(Ordering::Acquire) as usize & KIND_MASK }, KIND_VEC);",
          "    assert!(unsafe { (*shared_data.ref_cnt.get_mut()) == 1 });",
          "    assert_eq!(unsafe { ptr::read(buffer_ptr) }, 2u8);",
          "    let result = unsafe { promotable_to_vec(data, buffer_ptr, length, buffer_handler) };",
          "    assert_eq!(result.len(), length);",
          "    assert_eq!(result[0], 2u8);",
          "    assert_eq!(result[1], 2u8);",
          "    assert_eq!(result[2], 2u8);",
          "    assert_eq!(result[3], 2u8);",
          "    assert_eq!(result[4], 2u8);",
          "    assert_eq!(result[5], 2u8);",
          "    assert_eq!(result[6], 2u8);",
          "    assert_eq!(result[7], 2u8);",
          "    assert_eq!(result[8], 2u8);",
          "    assert_eq!(result[9], 2u8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]