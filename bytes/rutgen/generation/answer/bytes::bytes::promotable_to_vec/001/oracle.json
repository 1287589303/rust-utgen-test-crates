[
  {
    "uses": [
      "use core::ptr::null_mut;",
      "use std::sync::Arc;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::Arc;",
          "    ",
          "    struct TestData {",
          "        data: AtomicPtr<()>,",
          "    }",
          "",
          "    let shared_data = Arc::new(Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let data = Arc::into_raw(shared_data);",
          "    let atomic_ptr = AtomicPtr::new(data as *mut ());",
          "",
          "    let buffer: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
          "    let ptr: *const u8 = buffer.as_ptr();",
          "    let len: usize = 10;",
          "",
          "    unsafe fn mock_f(shared: *mut ()) -> *mut u8 {",
          "        let shared: *mut Shared = shared.cast();",
          "        (*shared).buf",
          "    }",
          "",
          "    let _result = unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) };",
          "}"
        ],
        "oracle": [
          "    assert_eq!(unsafe { atomic_ptr.load(Ordering::Acquire) as usize & KIND_MASK }, KIND_ARC);",
          "    assert_eq!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f).len() }, len);",
          "    assert_eq!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f)[0] }, 1);",
          "    assert_eq!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f)[9] }, 10);",
          "    assert_eq!(unsafe { atomic_ptr.load(Ordering::Acquire).ref_cnt.load(Ordering::SeqCst) }, 1);",
          "    assert!(unsafe { atomic_ptr.load(Ordering::Acquire).buf.is_null() } == false);"
        ],
        "code": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::Arc;",
          "    ",
          "    struct TestData {",
          "        data: AtomicPtr<()>,",
          "    }",
          "",
          "    let shared_data = Arc::new(Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let data = Arc::into_raw(shared_data);",
          "    let atomic_ptr = AtomicPtr::new(data as *mut ());",
          "",
          "    let buffer: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
          "    let ptr: *const u8 = buffer.as_ptr();",
          "    let len: usize = 10;",
          "",
          "    unsafe fn mock_f(shared: *mut ()) -> *mut u8 {",
          "        let shared: *mut Shared = shared.cast();",
          "        (*shared).buf",
          "    }",
          "",
          "    let _result = unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) };",
          "    assert_eq!(unsafe { atomic_ptr.load(Ordering::Acquire) as usize & KIND_MASK }, KIND_ARC);",
          "    assert_eq!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f).len() }, len);",
          "    assert_eq!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f)[0] }, 1);",
          "    assert_eq!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f)[9] }, 10);",
          "    assert_eq!(unsafe { atomic_ptr.load(Ordering::Acquire).ref_cnt.load(Ordering::SeqCst) }, 1);",
          "    assert!(unsafe { atomic_ptr.load(Ordering::Acquire).buf.is_null() } == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::Arc;",
          "",
          "    struct TestData {",
          "        data: AtomicPtr<()>,",
          "    }",
          "",
          "    let shared_data = Arc::new(Shared {",
          "        buf: Box::into_raw(Box::new([])) as *mut u8,",
          "        cap: 0,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let data = Arc::into_raw(shared_data);",
          "    let atomic_ptr = AtomicPtr::new(data as *mut ());",
          "",
          "    let buffer: [u8; 0] = [];",
          "    let ptr: *const u8 = buffer.as_ptr();",
          "    let len: usize = 0;",
          "",
          "    unsafe fn mock_f(shared: *mut ()) -> *mut u8 {",
          "        let shared: *mut Shared = shared.cast();",
          "        (*shared).buf",
          "    }",
          "",
          "    let _result = unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) };",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Vec::<u8>::from([]));",
          "    assert!(atomic_ptr.load(Ordering::Acquire).is_null());",
          "    assert_eq!(unsafe { (*data).ref_cnt.load(Ordering::Relaxed) }, 1);",
          "    assert_eq!(unsafe { (*data).cap }, 0);",
          "    assert_eq!(unsafe { (*data).buf }, Box::into_raw(Box::new([])) as *mut u8);",
          "    debug_assert!(true);"
        ],
        "code": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::Arc;",
          "",
          "    struct TestData {",
          "        data: AtomicPtr<()>,",
          "    }",
          "",
          "    let shared_data = Arc::new(Shared {",
          "        buf: Box::into_raw(Box::new([])) as *mut u8,",
          "        cap: 0,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let data = Arc::into_raw(shared_data);",
          "    let atomic_ptr = AtomicPtr::new(data as *mut ());",
          "",
          "    let buffer: [u8; 0] = [];",
          "    let ptr: *const u8 = buffer.as_ptr();",
          "    let len: usize = 0;",
          "",
          "    unsafe fn mock_f(shared: *mut ()) -> *mut u8 {",
          "        let shared: *mut Shared = shared.cast();",
          "        (*shared).buf",
          "    }",
          "",
          "    let _result = unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) };",
          "    assert_eq!(_result, Vec::<u8>::from([]));",
          "    assert!(atomic_ptr.load(Ordering::Acquire).is_null());",
          "    assert_eq!(unsafe { (*data).ref_cnt.load(Ordering::Relaxed) }, 1);",
          "    assert_eq!(unsafe { (*data).cap }, 0);",
          "    assert_eq!(unsafe { (*data).buf }, Box::into_raw(Box::new([])) as *mut u8);",
          "    debug_assert!(true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::Arc;",
          "",
          "    struct TestData {",
          "        data: AtomicPtr<()>,",
          "    }",
          "",
          "    let shared_data = Arc::new(Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let data = Arc::into_raw(shared_data);",
          "    let atomic_ptr = AtomicPtr::new(data as *mut ());",
          "",
          "    let buffer: [u8; 5] = [1, 2, 3, 4, 5];",
          "    let ptr: *const u8 = buffer.as_ptr();",
          "    let len: usize = 5;",
          "",
          "    unsafe fn mock_f(shared: *mut ()) -> *mut u8 {",
          "        let shared: *mut Shared = shared.cast();",
          "        (*shared).buf",
          "    }",
          "",
          "    let _result = unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) };",
          "}"
        ],
        "oracle": [
          "    assert_eq!(unsafe { AtomicPtr::new(data as *mut ()).load(Ordering::Acquire) }, data as *mut ());",
          "    assert!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) }.len() == len);",
          "    assert!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) }.as_slice() == &[1, 2, 3, 4, 5]);",
          "    assert!(unsafe { *shared_data.ref_cnt.get_mut() } == 1);",
          "    assert!(ptr::null_mut() != unsafe { (*data.cast::<Shared>()).buf });",
          "    assert!(unsafe { (*data.cast::<Shared>()).cap } >= len);"
        ],
        "code": [
          "{",
          "    use core::ptr::null_mut;",
          "    use std::sync::Arc;",
          "",
          "    struct TestData {",
          "        data: AtomicPtr<()>,",
          "    }",
          "",
          "    let shared_data = Arc::new(Shared {",
          "        buf: Box::into_raw(Box::new([0u8; 10])) as *mut u8,",
          "        cap: 10,",
          "        ref_cnt: AtomicUsize::new(1),",
          "    });",
          "    let data = Arc::into_raw(shared_data);",
          "    let atomic_ptr = AtomicPtr::new(data as *mut ());",
          "",
          "    let buffer: [u8; 5] = [1, 2, 3, 4, 5];",
          "    let ptr: *const u8 = buffer.as_ptr();",
          "    let len: usize = 5;",
          "",
          "    unsafe fn mock_f(shared: *mut ()) -> *mut u8 {",
          "        let shared: *mut Shared = shared.cast();",
          "        (*shared).buf",
          "    }",
          "",
          "    let _result = unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) };",
          "    assert_eq!(unsafe { AtomicPtr::new(data as *mut ()).load(Ordering::Acquire) }, data as *mut ());",
          "    assert!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) }.len() == len);",
          "    assert!(unsafe { promotable_to_vec(&atomic_ptr, ptr, len, mock_f) }.as_slice() == &[1, 2, 3, 4, 5]);",
          "    assert!(unsafe { *shared_data.ref_cnt.get_mut() } == 1);",
          "    assert!(ptr::null_mut() != unsafe { (*data.cast::<Shared>()).buf });",
          "    assert!(unsafe { (*data.cast::<Shared>()).cap } >= len);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]