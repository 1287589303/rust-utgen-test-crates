[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = Bytes {",
          "        ptr: core::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(core::ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "}"
        ],
        "oracle": [
          "    let bytes = Bytes { ptr: core::ptr::null(), len: 0, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 0);",
          "    assert!(result.is_empty());",
          "    ",
          "    let bytes = Bytes { ptr: core::ptr::null_mut(), len: 10, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 10);",
          "    ",
          "    let valid_ptr: *const u8 = &0u8;",
          "    let bytes = Bytes { ptr: valid_ptr, len: 1, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 1);",
          "    assert_eq!(result[0], 0);",
          "    ",
          "    let valid_data = AtomicPtr::new(Box::into_raw(Box::new([1u8; 5])) as *mut ());",
          "    let bytes = Bytes { ptr: valid_ptr, len: 5, data: valid_data, vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 5);",
          "    unsafe { Box::from_raw(valid_data.load(Ordering::SeqCst) as *mut [u8; 5]); }",
          "    ",
          "    let bytes = Bytes { ptr: core::ptr::null(), len: 0, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert!(result.is_empty());",
          "    ",
          "    let bytes = Bytes { ptr: valid_ptr, len: usize::MAX, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert!(result.len() <= usize::MAX);"
        ],
        "code": [
          "{",
          "    let bytes = Bytes {",
          "        ptr: core::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(core::ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "    let bytes = Bytes { ptr: core::ptr::null(), len: 0, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 0);",
          "    assert!(result.is_empty());",
          "    ",
          "    let bytes = Bytes { ptr: core::ptr::null_mut(), len: 10, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 10);",
          "    ",
          "    let valid_ptr: *const u8 = &0u8;",
          "    let bytes = Bytes { ptr: valid_ptr, len: 1, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 1);",
          "    assert_eq!(result[0], 0);",
          "    ",
          "    let valid_data = AtomicPtr::new(Box::into_raw(Box::new([1u8; 5])) as *mut ());",
          "    let bytes = Bytes { ptr: valid_ptr, len: 5, data: valid_data, vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert_eq!(result.len(), 5);",
          "    unsafe { Box::from_raw(valid_data.load(Ordering::SeqCst) as *mut [u8; 5]); }",
          "    ",
          "    let bytes = Bytes { ptr: core::ptr::null(), len: 0, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert!(result.is_empty());",
          "    ",
          "    let bytes = Bytes { ptr: valid_ptr, len: usize::MAX, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert!(result.len() <= usize::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = Bytes {",
          "        ptr: core::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(()))),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, vec![]);",
          "    assert_eq!(bytes.len, 0);",
          "    assert!(bytes.ptr.is_null());",
          "    assert_eq!(unsafe { (*bytes.data.get()).is_unique() }, true);",
          "    assert_eq!(bytes.vtable, &SHARED_VTABLE);"
        ],
        "code": [
          "{",
          "    let bytes = Bytes {",
          "        ptr: core::ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(()))),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "    assert_eq!(_result, vec![]);",
          "    assert_eq!(bytes.len, 0);",
          "    assert!(bytes.ptr.is_null());",
          "    assert_eq!(unsafe { (*bytes.data.get()).is_unique() }, true);",
          "    assert_eq!(bytes.vtable, &SHARED_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = vec![1u8, 2, 3, 4, 5];",
          "    let bytes = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(()))),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, vec![1u8, 2, 3, 4, 5]);",
          "    assert_eq!(bytes.len, 5);",
          "    assert!(bytes.data.load(Ordering::SeqCst).is_null());",
          "    assert!(!bytes.ptr.is_null());",
          "    assert_eq!(bytes.vtable, &SHARED_VTABLE);"
        ],
        "code": [
          "{",
          "    let data = vec![1u8, 2, 3, 4, 5];",
          "    let bytes = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(()))),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "    assert_eq!(_result, vec![1u8, 2, 3, 4, 5]);",
          "    assert_eq!(bytes.len, 5);",
          "    assert!(bytes.data.load(Ordering::SeqCst).is_null());",
          "    assert!(!bytes.ptr.is_null());",
          "    assert_eq!(bytes.vtable, &SHARED_VTABLE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let length = usize::MAX;",
          "    let bytes = Bytes {",
          "        ptr: core::ptr::null(),",
          "        len: length,",
          "        data: AtomicPtr::new(core::ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "}"
        ],
        "oracle": [
          "    let length = usize::MAX;",
          "    let bytes = Bytes { ptr: core::ptr::null(), len: length, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE, };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert!(result.is_empty());",
          "    assert_eq!(result.len(), 0);",
          "    assert_eq!(result.capacity(), 0);"
        ],
        "code": [
          "{",
          "    let length = usize::MAX;",
          "    let bytes = Bytes {",
          "        ptr: core::ptr::null(),",
          "        len: length,",
          "        data: AtomicPtr::new(core::ptr::null_mut()),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "    let length = usize::MAX;",
          "    let bytes = Bytes { ptr: core::ptr::null(), len: length, data: AtomicPtr::new(core::ptr::null_mut()), vtable: &SHARED_VTABLE, };",
          "    let result = Vec::<u8>::from(bytes);",
          "    assert!(result.is_empty());",
          "    assert_eq!(result.len(), 0);",
          "    assert_eq!(result.capacity(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = vec![10u8, 20, 30];",
          "    let bytes = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(()))),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, vec![10u8, 20, 30]);"
        ],
        "code": [
          "{",
          "    let data = vec![10u8, 20, 30];",
          "    let bytes = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(Box::into_raw(Box::new(()))),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "    assert_eq!(_result, vec![10u8, 20, 30]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data = vec![100u8, 200, 300];",
          "    let shared_data = Box::into_raw(Box::new(()));",
          "    let bytes = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(shared_data),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Vec::<u8>::from(bytes), vec![100, 200, 300]);",
          "    unsafe { ManuallyDrop::drop(&bytes); }",
          "    let empty_data = vec![];",
          "    let empty_bytes = Bytes { ptr: empty_data.as_ptr(), len: 0, data: AtomicPtr::new(shared_data), vtable: &SHARED_VTABLE };",
          "    assert_eq!(Vec::<u8>::from(empty_bytes), vec![]);",
          "    let single_data = vec![42u8];",
          "    let single_bytes = Bytes { ptr: single_data.as_ptr(), len: 1, data: AtomicPtr::new(shared_data), vtable: &SHARED_VTABLE };",
          "    assert_eq!(Vec::<u8>::from(single_bytes), vec![42]);",
          "    let overflow_data = vec![u8::MAX, u8::MAX-1, u8::MAX-2];",
          "    let overflow_bytes = Bytes { ptr: overflow_data.as_ptr(), len: 3, data: AtomicPtr::new(shared_data), vtable: &SHARED_VTABLE };",
          "    assert_eq!(Vec::<u8>::from(overflow_bytes), overflow_data);"
        ],
        "code": [
          "{",
          "    let data = vec![100u8, 200, 300];",
          "    let shared_data = Box::into_raw(Box::new(()));",
          "    let bytes = Bytes {",
          "        ptr: data.as_ptr(),",
          "        len: data.len(),",
          "        data: AtomicPtr::new(shared_data),",
          "        vtable: &SHARED_VTABLE,",
          "    };",
          "    let _result = Vec::<u8>::from(bytes);",
          "    assert_eq!(Vec::<u8>::from(bytes), vec![100, 200, 300]);",
          "    unsafe { ManuallyDrop::drop(&bytes); }",
          "    let empty_data = vec![];",
          "    let empty_bytes = Bytes { ptr: empty_data.as_ptr(), len: 0, data: AtomicPtr::new(shared_data), vtable: &SHARED_VTABLE };",
          "    assert_eq!(Vec::<u8>::from(empty_bytes), vec![]);",
          "    let single_data = vec![42u8];",
          "    let single_bytes = Bytes { ptr: single_data.as_ptr(), len: 1, data: AtomicPtr::new(shared_data), vtable: &SHARED_VTABLE };",
          "    assert_eq!(Vec::<u8>::from(single_bytes), vec![42]);",
          "    let overflow_data = vec![u8::MAX, u8::MAX-1, u8::MAX-2];",
          "    let overflow_bytes = Bytes { ptr: overflow_data.as_ptr(), len: 3, data: AtomicPtr::new(shared_data), vtable: &SHARED_VTABLE };",
          "    assert_eq!(Vec::<u8>::from(overflow_bytes), overflow_data);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]