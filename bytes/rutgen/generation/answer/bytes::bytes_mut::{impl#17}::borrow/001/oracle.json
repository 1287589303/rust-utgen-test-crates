[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: 0,",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "}"
        ],
        "oracle": [
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "    ptr,",
          "    len: 3,",
          "    cap: vec.len(),",
          "    data: ptr::null_mut(),",
          "    };",
          "    let result = bytes_mut.borrow();",
          "    assert_eq!(result, &[1u8, 2u8, 3u8]);"
        ],
        "code": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: 0,",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "    ptr,",
          "    len: 3,",
          "    cap: vec.len(),",
          "    data: ptr::null_mut(),",
          "    };",
          "    let result = bytes_mut.borrow();",
          "    assert_eq!(result, &[1u8, 2u8, 3u8]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: vec.len(),",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.borrow(), &[1u8, 2u8, 3u8]);"
        ],
        "code": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: vec.len(),",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "    assert_eq!(bytes_mut.borrow(), &[1u8, 2u8, 3u8]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: 2,",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.borrow(), &[1u8, 2u8]);",
          "    assert_eq!(bytes_mut.len, 2);",
          "    assert!(bytes_mut.cap >= bytes_mut.len);",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.borrow().len() == bytes_mut.len);",
          "    assert!(bytes_mut.borrow() as *const _ as usize == bytes_mut.ptr.as_ptr() as usize);",
          "    assert!(bytes_mut.borrow().is_empty() == false);"
        ],
        "code": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: 2,",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "    assert_eq!(bytes_mut.borrow(), &[1u8, 2u8]);",
          "    assert_eq!(bytes_mut.len, 2);",
          "    assert!(bytes_mut.cap >= bytes_mut.len);",
          "    assert!(bytes_mut.ptr.as_ptr() != ptr::null_mut());",
          "    assert!(bytes_mut.borrow().len() == bytes_mut.len);",
          "    assert!(bytes_mut.borrow() as *const _ as usize == bytes_mut.ptr.as_ptr() as usize);",
          "    assert!(bytes_mut.borrow().is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec = vec![1u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: 0,",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "}"
        ],
        "oracle": [
          "    let vec = vec![1u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut { ptr, len: 0, cap: vec.len(), data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut.borrow(), &[] as &[u8]);",
          "    let vec2 = vec![2u8, 3u8, 4u8];",
          "    let ptr2 = NonNull::from(vec2.as_ptr() as *mut u8);",
          "    let bytes_mut2 = BytesMut { ptr: ptr2, len: 3, cap: vec2.len(), data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut2.borrow(), &[2u8, 3u8, 4u8]);",
          "    let empty_vec: Vec<u8> = Vec::new();",
          "    let ptr_empty = NonNull::from(empty_vec.as_ptr() as *mut u8);",
          "    let bytes_mut_empty = BytesMut { ptr: ptr_empty, len: 0, cap: 0, data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut_empty.borrow(), &[] as &[u8]);",
          "    let capacity_vec = vec![5u8, 6u8];",
          "    let capacity_ptr = NonNull::from(capacity_vec.as_ptr() as *mut u8);",
          "    let bytes_mut_capacity = BytesMut { ptr: capacity_ptr, len: 2, cap: capacity_vec.len(), data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut_capacity.borrow(), &[5u8, 6u8]);"
        ],
        "code": [
          "{",
          "    let vec = vec![1u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: 0,",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "    let vec = vec![1u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut { ptr, len: 0, cap: vec.len(), data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut.borrow(), &[] as &[u8]);",
          "    let vec2 = vec![2u8, 3u8, 4u8];",
          "    let ptr2 = NonNull::from(vec2.as_ptr() as *mut u8);",
          "    let bytes_mut2 = BytesMut { ptr: ptr2, len: 3, cap: vec2.len(), data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut2.borrow(), &[2u8, 3u8, 4u8]);",
          "    let empty_vec: Vec<u8> = Vec::new();",
          "    let ptr_empty = NonNull::from(empty_vec.as_ptr() as *mut u8);",
          "    let bytes_mut_empty = BytesMut { ptr: ptr_empty, len: 0, cap: 0, data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut_empty.borrow(), &[] as &[u8]);",
          "    let capacity_vec = vec![5u8, 6u8];",
          "    let capacity_ptr = NonNull::from(capacity_vec.as_ptr() as *mut u8);",
          "    let bytes_mut_capacity = BytesMut { ptr: capacity_ptr, len: 2, cap: capacity_vec.len(), data: ptr::null_mut() };",
          "    assert_eq!(bytes_mut_capacity.borrow(), &[5u8, 6u8]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: vec.len(),",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.borrow(), &[1u8, 2u8, 3u8]);"
        ],
        "code": [
          "{",
          "    let vec = vec![1u8, 2u8, 3u8];",
          "    let ptr = NonNull::from(vec.as_ptr() as *mut u8);",
          "    let bytes_mut = BytesMut {",
          "        ptr,",
          "        len: vec.len(),",
          "        cap: vec.len(),",
          "        data: ptr::null_mut(),",
          "    };",
          "    let _ = bytes_mut.borrow();",
          "    assert_eq!(bytes_mut.borrow(), &[1u8, 2u8, 3u8]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]