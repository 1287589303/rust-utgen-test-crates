[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_a.eq(&&bytes_b), true);",
          "    let bytes_c = Bytes {",
          "    ptr: NonNull::from(&b\"world\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_c), false);",
          "    let bytes_d = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 4,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_d), false);",
          "    let bytes_e = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &PROMOTABLE_EVEN_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_e), false);"
        ],
        "code": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "    assert_eq!(bytes_a.eq(&&bytes_b), true);",
          "    let bytes_c = Bytes {",
          "    ptr: NonNull::from(&b\"world\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_c), false);",
          "    let bytes_d = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 4,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_d), false);",
          "    let bytes_e = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &PROMOTABLE_EVEN_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_e), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(*bytes_a == *bytes_b, true);",
          "    assert_eq!(bytes_a.eq(&&bytes_b), true);",
          "    let bytes_c = Bytes { ptr: ptr::null(), len: 1, data: AtomicPtr::new(ptr::null_mut()), vtable: &OWNED_VTABLE };",
          "    assert_eq!(bytes_a.eq(&&bytes_c), false);",
          "    let bytes_d = Bytes { ptr: ptr::null(), len: 0, data: AtomicPtr::new(ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    assert_eq!(bytes_a.eq(&&bytes_d), false);"
        ],
        "code": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "    assert_eq!(*bytes_a == *bytes_b, true);",
          "    assert_eq!(bytes_a.eq(&&bytes_b), true);",
          "    let bytes_c = Bytes { ptr: ptr::null(), len: 1, data: AtomicPtr::new(ptr::null_mut()), vtable: &OWNED_VTABLE };",
          "    assert_eq!(bytes_a.eq(&&bytes_c), false);",
          "    let bytes_d = Bytes { ptr: ptr::null(), len: 0, data: AtomicPtr::new(ptr::null_mut()), vtable: &SHARED_VTABLE };",
          "    assert_eq!(bytes_a.eq(&&bytes_d), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: NonNull::from(&b\"world\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_a.eq(&&bytes_b), false);",
          "    let bytes_c = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_c), true);",
          "    let bytes_d = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 3,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_d), false);",
          "    let bytes_e = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_e), false);"
        ],
        "code": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: NonNull::from(&b\"world\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "    assert_eq!(bytes_a.eq(&&bytes_b), false);",
          "    let bytes_c = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_c), true);",
          "    let bytes_d = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 3,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_d), false);",
          "    let bytes_e = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &SHARED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_e), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: NonNull::from(&b\"\"[..]).as_ptr(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_a.eq(&&bytes_b), false);",
          "    assert_eq!(bytes_b.eq(&&bytes_a), false);",
          "    let bytes_c = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_b.eq(&&bytes_c), true);",
          "    let bytes_d = Bytes {",
          "    ptr: NonNull::from(&b\"hello world\"[..]).as_ptr(),",
          "    len: 11,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_b.eq(&&bytes_d), false);",
          "    let bytes_e = Bytes {",
          "    ptr: NonNull::from(&b\"\"[..]).as_ptr(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_e), true);",
          "    assert_eq!(bytes_e.eq(&&bytes_a), true);"
        ],
        "code": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: NonNull::from(&b\"\"[..]).as_ptr(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "        len: 5,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "    assert_eq!(bytes_a.eq(&&bytes_b), false);",
          "    assert_eq!(bytes_b.eq(&&bytes_a), false);",
          "    let bytes_c = Bytes {",
          "    ptr: NonNull::from(&b\"hello\"[..]).as_ptr(),",
          "    len: 5,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_b.eq(&&bytes_c), true);",
          "    let bytes_d = Bytes {",
          "    ptr: NonNull::from(&b\"hello world\"[..]).as_ptr(),",
          "    len: 11,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_b.eq(&&bytes_d), false);",
          "    let bytes_e = Bytes {",
          "    ptr: NonNull::from(&b\"\"[..]).as_ptr(),",
          "    len: 0,",
          "    data: AtomicPtr::new(ptr::null_mut()),",
          "    vtable: &OWNED_VTABLE,",
          "    };",
          "    assert_eq!(bytes_a.eq(&&bytes_e), true);",
          "    assert_eq!(bytes_e.eq(&&bytes_a), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_a.eq(&&bytes_b), true);"
        ],
        "code": [
          "{",
          "    let bytes_a = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let bytes_b = Bytes {",
          "        ptr: ptr::null(),",
          "        len: 0,",
          "        data: AtomicPtr::new(ptr::null_mut()),",
          "        vtable: &OWNED_VTABLE,",
          "    };",
          "    let _ = bytes_a.eq(&&bytes_b);",
          "    assert_eq!(bytes_a.eq(&&bytes_b), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]