[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.set_len(0);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "}"
        ],
        "oracle": [
          "    bytes_mut.capacity() == 10",
          "    bytes_mut.len() == 0",
          "    Vec::from(bytes_mut).len() == 0",
          "    Vec::from(bytes_mut) is of type Vec<u8>",
          "    Vec::from(bytes_mut).capacity() >= 10"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.set_len(0);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "    bytes_mut.capacity() == 10",
          "    bytes_mut.len() == 0",
          "    Vec::from(bytes_mut).len() == 0",
          "    Vec::from(bytes_mut) is of type Vec<u8>",
          "    Vec::from(bytes_mut).capacity() >= 10",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(MAX_VEC_POS);",
          "    unsafe {",
          "        bytes_mut.set_len(MAX_VEC_POS);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.capacity(), MAX_VEC_POS);",
          "    assert_eq!(bytes_mut.len(), MAX_VEC_POS);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert_eq!(Vec::from(bytes_mut).len(), MAX_VEC_POS);",
          "    assert_eq!(Vec::from(bytes_mut).capacity(), MAX_VEC_POS);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(MAX_VEC_POS);",
          "    unsafe {",
          "        bytes_mut.set_len(MAX_VEC_POS);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "    assert_eq!(bytes_mut.capacity(), MAX_VEC_POS);",
          "    assert_eq!(bytes_mut.len(), MAX_VEC_POS);",
          "    assert!(!bytes_mut.is_empty());",
          "    assert_eq!(Vec::from(bytes_mut).len(), MAX_VEC_POS);",
          "    assert_eq!(Vec::from(bytes_mut).capacity(), MAX_VEC_POS);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(20);",
          "    let data: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe {",
          "        bytes_mut.set_len(data.len());",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let bytes_mut = BytesMut::with_capacity(20);",
          "    let data: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe { bytes_mut.set_len(data.len()); }",
          "    let result = Vec::from(bytes_mut);",
          "    assert_eq!(result.len(), data.len());",
          "    assert_eq!(result, data.to_vec());"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(20);",
          "    let data: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe {",
          "        bytes_mut.set_len(data.len());",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "    let bytes_mut = BytesMut::with_capacity(20);",
          "    let data: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe { bytes_mut.set_len(data.len()); }",
          "    let result = Vec::from(bytes_mut);",
          "    assert_eq!(result.len(), data.len());",
          "    assert_eq!(result, data.to_vec());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(MAX_ORIGINAL_CAPACITY_WIDTH);",
          "    let data = vec![0u8; MAX_ORIGINAL_CAPACITY_WIDTH];",
          "    bytes_mut.extend_from_slice(&data);",
          "    unsafe {",
          "        bytes_mut.set_len(MAX_ORIGINAL_CAPACITY_WIDTH);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), MAX_ORIGINAL_CAPACITY_WIDTH);",
          "    assert!(bytes_mut.capacity() >= MAX_ORIGINAL_CAPACITY_WIDTH);",
          "    assert!(bytes_mut.as_slice() == &data[..]);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    assert!(bytes_mut.spare_capacity_mut().len() == 0);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(MAX_ORIGINAL_CAPACITY_WIDTH);",
          "    let data = vec![0u8; MAX_ORIGINAL_CAPACITY_WIDTH];",
          "    bytes_mut.extend_from_slice(&data);",
          "    unsafe {",
          "        bytes_mut.set_len(MAX_ORIGINAL_CAPACITY_WIDTH);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "    assert_eq!(bytes_mut.len(), MAX_ORIGINAL_CAPACITY_WIDTH);",
          "    assert!(bytes_mut.capacity() >= MAX_ORIGINAL_CAPACITY_WIDTH);",
          "    assert!(bytes_mut.as_slice() == &data[..]);",
          "    assert!(bytes_mut.is_empty() == false);",
          "    assert!(bytes_mut.spare_capacity_mut().len() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(1);",
          "    let data: &[u8] = &[42];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe {",
          "        bytes_mut.set_len(1);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let mut bytes_mut = BytesMut::with_capacity(1);",
          "    let data: &[u8] = &[42];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe {",
          "    bytes_mut.set_len(1);",
          "    let vec = Vec::from(bytes_mut);",
          "    assert_eq!(vec.len(), 1);",
          "    assert_eq!(vec[0], 42);",
          "    }"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(1);",
          "    let data: &[u8] = &[42];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe {",
          "        bytes_mut.set_len(1);",
          "        let _ = Vec::from(bytes_mut);",
          "    }",
          "    let mut bytes_mut = BytesMut::with_capacity(1);",
          "    let data: &[u8] = &[42];",
          "    bytes_mut.extend_from_slice(data);",
          "    unsafe {",
          "    bytes_mut.set_len(1);",
          "    let vec = Vec::from(bytes_mut);",
          "    assert_eq!(vec.len(), 1);",
          "    assert_eq!(vec[0], 42);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]