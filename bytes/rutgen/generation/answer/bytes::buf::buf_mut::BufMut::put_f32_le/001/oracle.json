[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(1.2f32);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"\\x9A\\x99\\x99\\x3F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.advance_mut(4);",
          "    assert!(buf.has_remaining_mut() == false);"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(1.2f32);",
          "    assert_eq!(buf, b\"\\x9A\\x99\\x99\\x3F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.advance_mut(4);",
          "    assert!(buf.has_remaining_mut() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(-3.40282347e+38f32);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf[0], 0xFF);",
          "    assert_eq!(buf[1], 0x7F);",
          "    assert_eq!(buf[2], 0x7F);",
          "    assert_eq!(buf[3], 0xFF);",
          "    assert!(buf.remaining_mut() == 0);"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(-3.40282347e+38f32);",
          "    assert_eq!(buf[0], 0xFF);",
          "    assert_eq!(buf[1], 0x7F);",
          "    assert_eq!(buf[2], 0x7F);",
          "    assert_eq!(buf[3], 0xFF);",
          "    assert!(buf.remaining_mut() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(3.40282347e+38f32);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"\\xFF\\xFF\\x7F\\x7F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(!buf.has_remaining_mut());",
          "    unsafe { buf.advance_mut(4) };",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(panic_does_not_fit(buf.remaining_mut(), 4));"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(3.40282347e+38f32);",
          "    assert_eq!(buf, b\"\\xFF\\xFF\\x7F\\x7F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(!buf.has_remaining_mut());",
          "    unsafe { buf.advance_mut(4) };",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(panic_does_not_fit(buf.remaining_mut(), 4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(f32::NAN);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"\\x00\\x00\\x80\\x7F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    assert!(std::panic::catch_unwind(|| buf.put_f32_le(1.0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| buf.advance_mut(5)).is_err());",
          "    buf.put_f32_le(0.0);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\");",
          "    assert!(buf.remaining_mut() == 4);",
          "    buf.put_f32_le(2.5);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x40\\x40\");"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(f32::NAN);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x80\\x7F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    assert!(std::panic::catch_unwind(|| buf.put_f32_le(1.0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| buf.advance_mut(5)).is_err());",
          "    buf.put_f32_le(0.0);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x00\\x00\");",
          "    assert!(buf.remaining_mut() == 4);",
          "    buf.put_f32_le(2.5);",
          "    assert_eq!(buf, b\"\\x00\\x00\\x40\\x40\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(f32::INFINITY);",
          "}"
        ],
        "oracle": [
          "    assert!(buf == b\"\\x00\\x00\\x80\\x7F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(f32::NEG_INFINITY);",
          "    assert!(buf == b\"\\x00\\x00\\x80\\xFF\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(0.0);",
          "    assert!(buf == b\"\\x00\\x00\\x00\\x00\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(-1.0);",
          "    assert!(buf == b\"\\x00\\x00\\x80\\xBF\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(1.2);",
          "    assert!(buf == b\"\\x9A\\x99\\x99\\x3F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(2.5);",
          "    assert!(buf == b\"\\x00\\x00\\x28\\x40\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(-2.5);",
          "    assert!(buf == b\"\\x00\\x00\\x28\\xC0\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(3.14);",
          "    assert!(buf == b\"\\xD2\\xF6\\x28\\x40\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(-3.14);",
          "    assert!(buf == b\"\\xD2\\xF6\\x28\\xC0\");"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 4];",
          "    buf.put_f32_le(f32::INFINITY);",
          "    assert!(buf == b\"\\x00\\x00\\x80\\x7F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(f32::NEG_INFINITY);",
          "    assert!(buf == b\"\\x00\\x00\\x80\\xFF\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(0.0);",
          "    assert!(buf == b\"\\x00\\x00\\x00\\x00\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(-1.0);",
          "    assert!(buf == b\"\\x00\\x00\\x80\\xBF\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(1.2);",
          "    assert!(buf == b\"\\x9A\\x99\\x99\\x3F\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(2.5);",
          "    assert!(buf == b\"\\x00\\x00\\x28\\x40\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(-2.5);",
          "    assert!(buf == b\"\\x00\\x00\\x28\\xC0\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(3.14);",
          "    assert!(buf == b\"\\xD2\\xF6\\x28\\x40\");",
          "    assert!(buf.remaining_mut() == 0);",
          "    assert!(buf.has_remaining_mut() == false);",
          "    buf.advance_mut(4);",
          "    assert!(buf.remaining_mut() == 0);",
          "    buf.put_f32_le(-3.14);",
          "    assert!(buf == b\"\\xD2\\xF6\\x28\\xC0\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 0];",
          "    buf.put_f32_le(1.0f32);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.len(), 0);",
          "    assert!(buf.is_empty());",
          "    assert!(std::panic::catch_unwind(|| buf.put_f32_le(1.0f32)).is_err());",
          "    assert!(buf.capacity() == 0);",
          "    assert_eq!(buf, vec![0; 0]);"
        ],
        "code": [
          "{",
          "    let mut buf: Vec<u8> = vec![0; 0];",
          "    buf.put_f32_le(1.0f32);",
          "    assert_eq!(buf.len(), 0);",
          "    assert!(buf.is_empty());",
          "    assert!(std::panic::catch_unwind(|| buf.put_f32_le(1.0f32)).is_err());",
          "    assert!(buf.capacity() == 0);",
          "    assert_eq!(buf, vec![0; 0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]