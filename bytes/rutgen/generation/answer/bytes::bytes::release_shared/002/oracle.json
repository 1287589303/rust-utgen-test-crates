[
  {
    "uses": [
      "use std::ptr::NonNull;",
      "use std::sync::atomic::Ordering;",
      "use std::sync::atomic::AtomicUsize;",
      "use std::alloc::alloc;",
      "use std::alloc::Layout;",
      "use std::alloc::dealloc;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicUsize, Ordering};",
          "    ",
          "    struct Shared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    // Allocate some memory for a Shared instance",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    ",
          "    // Initialize the Shared instance",
          "    unsafe {",
          "        (*shared_ptr).buf = std::ptr::null_mut();",
          "        (*shared_ptr).cap = 0;",
          "        (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst);",
          "    }",
          "    ",
          "    // Call the function under test",
          "    unsafe {",
          "        release_shared(shared_ptr);",
          "    }",
          "}"
        ],
        "oracle": [
          "    unsafe fn release_shared_test_oracle_ref_count_not_zero() {",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    unsafe {",
          "    (*shared_ptr).buf = std::ptr::null_mut();",
          "    (*shared_ptr).cap = 0;",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst); // Initialize reference count to 1",
          "    }",
          "    unsafe {",
          "    release_shared(shared_ptr); // Call release_shared which should drop the allocation",
          "    }",
          "    // Assert that the memory was deallocated, ensuring proper cleanup",
          "    }",
          "    ",
          "    unsafe fn release_shared_test_oracle_reference_count_zero() {",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    unsafe {",
          "    (*shared_ptr).buf = std::ptr::null_mut();",
          "    (*shared_ptr).cap = 0;",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst); // Initialize reference count to 1",
          "    release_shared(shared_ptr); // First call should decrement to zero",
          "    release_shared(shared_ptr); // Second call should drop the memory",
          "    }",
          "    // Assert that the memory was deallocated on second call",
          "    }",
          "    ",
          "    unsafe fn release_shared_test_oracle_safe_fence() {",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    unsafe {",
          "    (*shared_ptr).buf = std::ptr::null_mut();",
          "    (*shared_ptr).cap = 0;",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst); // Reference count starts at 1",
          "    release_shared(shared_ptr); // First call should succeed",
          "    // Ensure the 'load' operation happens correctly with the fence",
          "    }",
          "    // Assert correct behavior without data misuse after the first decrement",
          "    }"
        ],
        "code": [
          "{",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicUsize, Ordering};",
          "    ",
          "    struct Shared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    // Allocate some memory for a Shared instance",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    ",
          "    // Initialize the Shared instance",
          "    unsafe {",
          "        (*shared_ptr).buf = std::ptr::null_mut();",
          "        (*shared_ptr).cap = 0;",
          "        (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst);",
          "    }",
          "    ",
          "    // Call the function under test",
          "    unsafe {",
          "        release_shared(shared_ptr);",
          "    }",
          "    unsafe fn release_shared_test_oracle_ref_count_not_zero() {",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    unsafe {",
          "    (*shared_ptr).buf = std::ptr::null_mut();",
          "    (*shared_ptr).cap = 0;",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst); // Initialize reference count to 1",
          "    }",
          "    unsafe {",
          "    release_shared(shared_ptr); // Call release_shared which should drop the allocation",
          "    }",
          "    // Assert that the memory was deallocated, ensuring proper cleanup",
          "    }",
          "    ",
          "    unsafe fn release_shared_test_oracle_reference_count_zero() {",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    unsafe {",
          "    (*shared_ptr).buf = std::ptr::null_mut();",
          "    (*shared_ptr).cap = 0;",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst); // Initialize reference count to 1",
          "    release_shared(shared_ptr); // First call should decrement to zero",
          "    release_shared(shared_ptr); // Second call should drop the memory",
          "    }",
          "    // Assert that the memory was deallocated on second call",
          "    }",
          "    ",
          "    unsafe fn release_shared_test_oracle_safe_fence() {",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    unsafe {",
          "    (*shared_ptr).buf = std::ptr::null_mut();",
          "    (*shared_ptr).cap = 0;",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst); // Reference count starts at 1",
          "    release_shared(shared_ptr); // First call should succeed",
          "    // Ensure the 'load' operation happens correctly with the fence",
          "    }",
          "    // Assert correct behavior without data misuse after the first decrement",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicUsize, Ordering};",
          "    ",
          "    struct Shared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    // Allocate memory for another Shared instance",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    ",
          "    // Initialize another Shared instance",
          "    unsafe {",
          "        (*shared_ptr).buf = std::ptr::null_mut();",
          "        (*shared_ptr).cap = 0;",
          "        (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst);",
          "    }",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        release_shared(shared_ptr);",
          "    }",
          "}"
        ],
        "oracle": [
          "    unsafe {",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::Release);",
          "    }",
          "    ",
          "    assert_eq!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::SeqCst) }, 0);",
          "    ",
          "    // Verifying memory is released",
          "    let layout = Layout::new::<Shared>();",
          "    assert!(unsafe { shared_ptr.is_null() } == false);",
          "    unsafe { dealloc(shared_ptr as *mut u8, layout); }",
          "    ",
          "    // Ensure the reference count is decremented correctly",
          "    assert_eq!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Acquire) }, 0);",
          "    ",
          "    // Verify that cleanup happens as expected without double freeing",
          "    unsafe { release_shared(shared_ptr); } // Should not panic or double free",
          "    ",
          "    // Ensure the reference count is greater than zero before cleaning up",
          "    unsafe {",
          "    (*shared_ptr).ref_cnt.store(2, Ordering::Release);",
          "    }",
          "    ",
          "    unsafe { release_shared(shared_ptr); } // Ensure successful cleanup without crash"
        ],
        "code": [
          "{",
          "    use std::alloc::{alloc, dealloc, Layout};",
          "    use std::ptr::NonNull;",
          "    use std::sync::atomic::{AtomicUsize, Ordering};",
          "    ",
          "    struct Shared {",
          "        buf: *mut u8,",
          "        cap: usize,",
          "        ref_cnt: AtomicUsize,",
          "    }",
          "",
          "    // Allocate memory for another Shared instance",
          "    let layout = Layout::new::<Shared>();",
          "    let shared_ptr: *mut Shared = unsafe { alloc(layout) as *mut Shared };",
          "    ",
          "    // Initialize another Shared instance",
          "    unsafe {",
          "        (*shared_ptr).buf = std::ptr::null_mut();",
          "        (*shared_ptr).cap = 0;",
          "        (*shared_ptr).ref_cnt.store(1, Ordering::SeqCst);",
          "    }",
          "",
          "    // Call the function under test",
          "    unsafe {",
          "        release_shared(shared_ptr);",
          "    }",
          "    unsafe {",
          "    (*shared_ptr).ref_cnt.store(1, Ordering::Release);",
          "    }",
          "    ",
          "    assert_eq!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::SeqCst) }, 0);",
          "    ",
          "    // Verifying memory is released",
          "    let layout = Layout::new::<Shared>();",
          "    assert!(unsafe { shared_ptr.is_null() } == false);",
          "    unsafe { dealloc(shared_ptr as *mut u8, layout); }",
          "    ",
          "    // Ensure the reference count is decremented correctly",
          "    assert_eq!(unsafe { (*shared_ptr).ref_cnt.load(Ordering::Acquire) }, 0);",
          "    ",
          "    // Verify that cleanup happens as expected without double freeing",
          "    unsafe { release_shared(shared_ptr); } // Should not panic or double free",
          "    ",
          "    // Ensure the reference count is greater than zero before cleaning up",
          "    unsafe {",
          "    (*shared_ptr).ref_cnt.store(2, Ordering::Release);",
          "    }",
          "    ",
          "    unsafe { release_shared(shared_ptr); } // Ensure successful cleanup without crash",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]