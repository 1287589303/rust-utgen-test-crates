[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [",
          "        core::mem::MaybeUninit::uninit(),",
          "        core::mem::MaybeUninit::uninit(),",
          "        core::mem::MaybeUninit::uninit(),",
          "    ];",
          "    let src: &[u8] = &[1, 2, 3];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.len(), 3);",
          "    assert_eq!(buffer[0].assume_init(), 1);",
          "    assert_eq!(buffer[1].assume_init(), 2);",
          "    assert_eq!(buffer[2].assume_init(), 3);"
        ],
        "code": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [",
          "        core::mem::MaybeUninit::uninit(),",
          "        core::mem::MaybeUninit::uninit(),",
          "        core::mem::MaybeUninit::uninit(),",
          "    ];",
          "    let src: &[u8] = &[1, 2, 3];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "    assert_eq!(buffer.len(), 3);",
          "    assert_eq!(buffer[0].assume_init(), 1);",
          "    assert_eq!(buffer[1].assume_init(), 2);",
          "    assert_eq!(buffer[2].assume_init(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [",
          "        core::mem::MaybeUninit::uninit(),",
          "        core::mem::MaybeUninit::uninit(),",
          "    ];",
          "    let src: &[u8] = &[4, 5];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.len(), 2);",
          "    assert_eq!(buffer[0].assume_init(), 4);",
          "    assert_eq!(buffer[1].assume_init(), 5);"
        ],
        "code": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [",
          "        core::mem::MaybeUninit::uninit(),",
          "        core::mem::MaybeUninit::uninit(),",
          "    ];",
          "    let src: &[u8] = &[4, 5];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "    assert_eq!(buffer.len(), 2);",
          "    assert_eq!(buffer[0].assume_init(), 4);",
          "    assert_eq!(buffer[1].assume_init(), 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [];",
          "    let src: &[u8] = &[];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 0];",
          "    let src: &[u8] = &[];",
          "    unsafe { buffer.put_slice(src); }",
          "    assert_eq!(buffer.len(), 0);",
          "    assert_eq!(buffer as *const _ as usize, buffer.as_mut_ptr() as usize);",
          "    assert!(core::ptr::eq(buffer.as_mut_ptr(), buffer.as_mut_ptr().offset(0)));"
        ],
        "code": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [];",
          "    let src: &[u8] = &[];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "    let buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [core::mem::MaybeUninit::uninit(); 0];",
          "    let src: &[u8] = &[];",
          "    unsafe { buffer.put_slice(src); }",
          "    assert_eq!(buffer.len(), 0);",
          "    assert_eq!(buffer as *const _ as usize, buffer.as_mut_ptr() as usize);",
          "    assert!(core::ptr::eq(buffer.as_mut_ptr(), buffer.as_mut_ptr().offset(0)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [",
          "        core::mem::MaybeUninit::uninit(),",
          "    ];",
          "    let src: &[u8] = &[1, 2, 3, 4];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.len(), 4);",
          "    assert_eq!(buffer[0].assume_init(), 1);",
          "    assert_eq!(buffer[1].assume_init(), 2);",
          "    assert_eq!(buffer[2].assume_init(), 3);",
          "    assert_eq!(buffer[3].assume_init(), 4);"
        ],
        "code": [
          "{",
          "    let mut buffer: &mut [core::mem::MaybeUninit<u8>] = &mut [",
          "        core::mem::MaybeUninit::uninit(),",
          "    ];",
          "    let src: &[u8] = &[1, 2, 3, 4];",
          "    unsafe {",
          "        buffer.put_slice(src);",
          "    }",
          "    assert_eq!(buffer.len(), 4);",
          "    assert_eq!(buffer[0].assume_init(), 1);",
          "    assert_eq!(buffer[1].assume_init(), 2);",
          "    assert_eq!(buffer[2].assume_init(), 3);",
          "    assert_eq!(buffer[3].assume_init(), 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]