[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src = BytesMut::new();",
          "    let _result: Bytes = Bytes::from(src);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.len(), 0);",
          "    assert!(src.is_empty());",
          "    assert_eq!(_result.capacity(), 0);",
          "    assert_eq!(src.capacity(), 0);",
          "    assert_eq!(_result.ptr, src.ptr.as_ptr());",
          "    assert_eq!(_result.data.load(Ordering::SeqCst), src.data);"
        ],
        "code": [
          "{",
          "    let src = BytesMut::new();",
          "    let _result: Bytes = Bytes::from(src);",
          "    assert_eq!(_result.len(), 0);",
          "    assert!(src.is_empty());",
          "    assert_eq!(_result.capacity(), 0);",
          "    assert_eq!(src.capacity(), 0);",
          "    assert_eq!(_result.ptr, src.ptr.as_ptr());",
          "    assert_eq!(_result.data.load(Ordering::SeqCst), src.data);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src = BytesMut::zeroed(10);",
          "    let _result: Bytes = Bytes::from(src);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.len(), 0);",
          "    assert!(!_result.is_empty());",
          "    assert_eq!(_result.capacity(), 10);",
          "    assert_eq!(unsafe { _result.as_slice().len() }, 0);",
          "    assert_eq!(unsafe { _result.try_unsplit(BytesMut::zeroed(5)) }.is_ok(), false);"
        ],
        "code": [
          "{",
          "    let src = BytesMut::zeroed(10);",
          "    let _result: Bytes = Bytes::from(src);",
          "    assert_eq!(_result.len(), 0);",
          "    assert!(!_result.is_empty());",
          "    assert_eq!(_result.capacity(), 10);",
          "    assert_eq!(unsafe { _result.as_slice().len() }, 0);",
          "    assert_eq!(unsafe { _result.try_unsplit(BytesMut::zeroed(5)) }.is_ok(), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capacity = 1024; // an arbitrary non-zero capacity",
          "    let src = BytesMut::with_capacity(capacity);",
          "    let _result: Bytes = Bytes::from(src);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.len(), 0);",
          "    assert!(src.is_empty());",
          "    assert_eq!(src.capacity(), capacity);",
          "    assert_eq!(capacity, src.capacity());",
          "    assert_eq!(src.ptr.as_ptr(), _result.ptr);",
          "    assert_eq!(_result.vtable, &SHARED_VTABLE);",
          "    assert!(ptr::eq(_result.data.get_mut(), src.data.get_mut()));",
          "    assert_eq!(_result.len(), src.len());",
          "    assert!(src.data.is_null() || _result.data.load(Ordering::SeqCst).is_null());",
          "    assert!(src.ptr.as_ptr() != ptr::null());"
        ],
        "code": [
          "{",
          "    let capacity = 1024; // an arbitrary non-zero capacity",
          "    let src = BytesMut::with_capacity(capacity);",
          "    let _result: Bytes = Bytes::from(src);",
          "    assert_eq!(_result.len(), 0);",
          "    assert!(src.is_empty());",
          "    assert_eq!(src.capacity(), capacity);",
          "    assert_eq!(capacity, src.capacity());",
          "    assert_eq!(src.ptr.as_ptr(), _result.ptr);",
          "    assert_eq!(_result.vtable, &SHARED_VTABLE);",
          "    assert!(ptr::eq(_result.data.get_mut(), src.data.get_mut()));",
          "    assert_eq!(_result.len(), src.len());",
          "    assert!(src.data.is_null() || _result.data.load(Ordering::SeqCst).is_null());",
          "    assert!(src.ptr.as_ptr() != ptr::null());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let src = BytesMut::with_capacity(usize::MAX);",
          "    let _result: Bytes = Bytes::from(src);",
          "}"
        ],
        "oracle": [
          "    let src = BytesMut::with_capacity(usize::MAX);",
          "    let _result: Bytes = Bytes::from(src);",
          "    assert_eq!(_result.len(), 0);",
          "    assert!(src.is_empty());",
          "    assert_eq!(src.capacity(), usize::MAX);"
        ],
        "code": [
          "{",
          "    let src = BytesMut::with_capacity(usize::MAX);",
          "    let _result: Bytes = Bytes::from(src);",
          "    let src = BytesMut::with_capacity(usize::MAX);",
          "    let _result: Bytes = Bytes::from(src);",
          "    assert_eq!(_result.len(), 0);",
          "    assert!(src.is_empty());",
          "    assert_eq!(src.capacity(), usize::MAX);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]