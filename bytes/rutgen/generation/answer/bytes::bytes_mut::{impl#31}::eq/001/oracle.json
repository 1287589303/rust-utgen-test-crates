[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3, 4, 5]))).unwrap(),",
          "        len: 5,",
          "        cap: 5,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.eq(other);",
          "}"
        ],
        "oracle": [
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5]));",
          "    assert!(!bytes_mut.eq(&[1, 2, 3, 4]));",
          "    assert!(!bytes_mut.eq(&[6, 7, 8]));",
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5][..]));",
          "    assert!(!bytes_mut.eq(&[1, 2, 3, 4, 5, 6]));",
          "    assert!(bytes_mut.eq(&[]));",
          "    let empty_bytes_mut = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([]))).unwrap(),",
          "    len: 0,",
          "    cap: 0,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert!(empty_bytes_mut.eq(&[]));",
          "    assert!(!empty_bytes_mut.eq(&[1]));"
        ],
        "code": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3, 4, 5]))).unwrap(),",
          "        len: 5,",
          "        cap: 5,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.eq(other);",
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5]));",
          "    assert!(!bytes_mut.eq(&[1, 2, 3, 4]));",
          "    assert!(!bytes_mut.eq(&[6, 7, 8]));",
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5][..]));",
          "    assert!(!bytes_mut.eq(&[1, 2, 3, 4, 5, 6]));",
          "    assert!(bytes_mut.eq(&[]));",
          "    let empty_bytes_mut = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([]))).unwrap(),",
          "    len: 0,",
          "    cap: 0,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert!(empty_bytes_mut.eq(&[]));",
          "    assert!(!empty_bytes_mut.eq(&[1]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3, 4, 5]))).unwrap(),",
          "        len: 5,",
          "        cap: 5,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[5, 4, 3, 2, 1];",
          "    bytes_mut.eq(other);",
          "}"
        ],
        "oracle": [
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5]) == true);",
          "    assert!(bytes_mut.eq(&[1, 2, 3]) == false);",
          "    assert!(bytes_mut.eq(&[]) == false);",
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5, 6]) == false);",
          "    assert!(bytes_mut.eq(&[5, 4, 3, 2, 1]) == false);"
        ],
        "code": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3, 4, 5]))).unwrap(),",
          "        len: 5,",
          "        cap: 5,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[5, 4, 3, 2, 1];",
          "    bytes_mut.eq(other);",
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5]) == true);",
          "    assert!(bytes_mut.eq(&[1, 2, 3]) == false);",
          "    assert!(bytes_mut.eq(&[]) == false);",
          "    assert!(bytes_mut.eq(&[1, 2, 3, 4, 5, 6]) == false);",
          "    assert!(bytes_mut.eq(&[5, 4, 3, 2, 1]) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3]))).unwrap(),",
          "        len: 3,",
          "        cap: 3,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.eq(other);",
          "}"
        ],
        "oracle": [
          "    assert!(!bytes_mut.eq(&[1, 2, 3, 4, 5]));",
          "    assert!(bytes_mut.eq(&[1, 2, 3]));",
          "    assert!(!bytes_mut.eq(&[1, 2]));",
          "    assert!(!bytes_mut.eq(&[]));",
          "    let empty_bytes_mut = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([]))).unwrap(),",
          "    len: 0,",
          "    cap: 0,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert!(empty_bytes_mut.eq(&[]));",
          "    assert!(!empty_bytes_mut.eq(&[1]));",
          "    assert!(!bytes_mut.eq(&[4, 5, 6]));",
          "    assert!(bytes_mut.eq(&[1, 2, 3]));"
        ],
        "code": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3]))).unwrap(),",
          "        len: 3,",
          "        cap: 3,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[1, 2, 3, 4, 5];",
          "    bytes_mut.eq(other);",
          "    assert!(!bytes_mut.eq(&[1, 2, 3, 4, 5]));",
          "    assert!(bytes_mut.eq(&[1, 2, 3]));",
          "    assert!(!bytes_mut.eq(&[1, 2]));",
          "    assert!(!bytes_mut.eq(&[]));",
          "    let empty_bytes_mut = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([]))).unwrap(),",
          "    len: 0,",
          "    cap: 0,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert!(empty_bytes_mut.eq(&[]));",
          "    assert!(!empty_bytes_mut.eq(&[1]));",
          "    assert!(!bytes_mut.eq(&[4, 5, 6]));",
          "    assert!(bytes_mut.eq(&[1, 2, 3]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3, 4, 5]))).unwrap(),",
          "        len: 5,",
          "        cap: 5,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[];",
          "    bytes_mut.eq(other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3, 4, 5]), true);",
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3]), false);",
          "    assert_eq!(bytes_mut.eq(&[6, 7, 8]), false);",
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3, 4, 5, 6]), false);",
          "    assert_eq!(bytes_mut.eq(&[]), false);"
        ],
        "code": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3, 4, 5]))).unwrap(),",
          "        len: 5,",
          "        cap: 5,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[];",
          "    bytes_mut.eq(other);",
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3, 4, 5]), true);",
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3]), false);",
          "    assert_eq!(bytes_mut.eq(&[6, 7, 8]), false);",
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3, 4, 5, 6]), false);",
          "    assert_eq!(bytes_mut.eq(&[]), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([])).unwrap()).unwrap(),",
          "        len: 0,",
          "        cap: 0,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[];",
          "    bytes_mut.eq(other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.eq(&[]), true);",
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3]), false);",
          "    let bytes_mut_non_empty = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3])).unwrap()).unwrap(),",
          "    len: 3,",
          "    cap: 3,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert_eq!(bytes_mut_non_empty.eq(&[1, 2, 3]), true);",
          "    assert_eq!(bytes_mut_non_empty.eq(&[3, 2, 1]), false);",
          "    let bytes_mut_with_different_length = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3])).unwrap()).unwrap(),",
          "    len: 3,",
          "    cap: 3,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert_eq!(bytes_mut_with_different_length.eq(&[1, 2]), false);",
          "    assert_eq!(bytes_mut_with_different_length.eq(&[1, 2, 3, 4]), false);"
        ],
        "code": [
          "{",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(Box::into_raw(Box::new([])).unwrap()).unwrap(),",
          "        len: 0,",
          "        cap: 0,",
          "        data: ptr::null_mut(),",
          "    };",
          "    let other: &[u8] = &[];",
          "    bytes_mut.eq(other);",
          "    assert_eq!(bytes_mut.eq(&[]), true);",
          "    assert_eq!(bytes_mut.eq(&[1, 2, 3]), false);",
          "    let bytes_mut_non_empty = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3])).unwrap()).unwrap(),",
          "    len: 3,",
          "    cap: 3,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert_eq!(bytes_mut_non_empty.eq(&[1, 2, 3]), true);",
          "    assert_eq!(bytes_mut_non_empty.eq(&[3, 2, 1]), false);",
          "    let bytes_mut_with_different_length = BytesMut {",
          "    ptr: NonNull::new(Box::into_raw(Box::new([1, 2, 3])).unwrap()).unwrap(),",
          "    len: 3,",
          "    cap: 3,",
          "    data: ptr::null_mut(),",
          "    };",
          "    assert_eq!(bytes_mut_with_different_length.eq(&[1, 2]), false);",
          "    assert_eq!(bytes_mut_with_different_length.eq(&[1, 2, 3, 4]), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]