[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(0),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "}"
        ],
        "oracle": [
          "    let shared = TestShared { ref_count: AtomicUsize::new(1) };",
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 1);",
          "    assert!(shared.ref_count.load(Ordering::Acquire) == 1);",
          "    let shared = TestShared { ref_count: AtomicUsize::new(2) };",
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 2);",
          "    assert!(shared.ref_count.load(Ordering::Acquire) != 1);",
          "    let shared = TestShared { ref_count: AtomicUsize::new(1) };",
          "    assert!(shared.is_unique());",
          "    let shared = TestShared { ref_count: AtomicUsize::new(0) };",
          "    assert!(!shared.is_unique());"
        ],
        "code": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(0),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    let shared = TestShared { ref_count: AtomicUsize::new(1) };",
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 1);",
          "    assert!(shared.ref_count.load(Ordering::Acquire) == 1);",
          "    let shared = TestShared { ref_count: AtomicUsize::new(2) };",
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 2);",
          "    assert!(shared.ref_count.load(Ordering::Acquire) != 1);",
          "    let shared = TestShared { ref_count: AtomicUsize::new(1) };",
          "    assert!(shared.is_unique());",
          "    let shared = TestShared { ref_count: AtomicUsize::new(0) };",
          "    assert!(!shared.is_unique());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);  // Check for unique reference count",
          "    ",
          "    let shared_unique = TestShared {",
          "    ref_count: AtomicUsize::new(1),",
          "    };",
          "    let result_unique = shared_unique.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result_unique, true); // Unique reference count should return true",
          "    ",
          "    let shared_not_unique = TestShared {",
          "    ref_count: AtomicUsize::new(2),",
          "    };",
          "    let result_not_unique = shared_not_unique.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result_not_unique, false); // Non-unique reference count should return false",
          "    ",
          "    let shared_zero = TestShared {",
          "    ref_count: AtomicUsize::new(0),",
          "    };",
          "    let result_zero = shared_zero.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result_zero, false); // Zero reference count should return false"
        ],
        "code": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result, true);  // Check for unique reference count",
          "    ",
          "    let shared_unique = TestShared {",
          "    ref_count: AtomicUsize::new(1),",
          "    };",
          "    let result_unique = shared_unique.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result_unique, true); // Unique reference count should return true",
          "    ",
          "    let shared_not_unique = TestShared {",
          "    ref_count: AtomicUsize::new(2),",
          "    };",
          "    let result_not_unique = shared_not_unique.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result_not_unique, false); // Non-unique reference count should return false",
          "    ",
          "    let shared_zero = TestShared {",
          "    ref_count: AtomicUsize::new(0),",
          "    };",
          "    let result_zero = shared_zero.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result_zero, false); // Zero reference count should return false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(2),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 2);",
          "    assert!(!result);"
        ],
        "code": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(2),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(shared.ref_count.load(Ordering::Acquire), 2);",
          "    assert!(!result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(usize::MAX),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false);",
          "    shared.ref_count.store(1, Ordering::Release);",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result, true);",
          "    shared.ref_count.store(2, Ordering::Release);",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    struct TestShared {",
          "        ref_count: AtomicUsize,",
          "    }",
          "",
          "    let shared = TestShared {",
          "        ref_count: AtomicUsize::new(usize::MAX),",
          "    };",
          "",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result, false);",
          "    shared.ref_count.store(1, Ordering::Release);",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result, true);",
          "    shared.ref_count.store(2, Ordering::Release);",
          "    let result = shared.ref_count.load(Ordering::Acquire) == 1;",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]