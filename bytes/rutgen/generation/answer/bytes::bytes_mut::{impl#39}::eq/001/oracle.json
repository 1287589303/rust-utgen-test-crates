[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![1, 2, 3],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = vec![1, 2, 3];",
          "    let _ = bytes_mut.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert!(bytes_mut.eq(&vec![1, 2, 3]));",
          "    assert!(!bytes_mut.eq(&vec![4, 5, 6]));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3, 4]));",
          "    assert!(!bytes_mut.eq(&vec![]));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3]));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3].clone()));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3].iter().cloned().collect()));"
        ],
        "code": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![1, 2, 3],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = vec![1, 2, 3];",
          "    let _ = bytes_mut.eq(&other);",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3]));",
          "    assert!(!bytes_mut.eq(&vec![4, 5, 6]));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3, 4]));",
          "    assert!(!bytes_mut.eq(&vec![]));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3]));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3].clone()));",
          "    assert!(bytes_mut.eq(&vec![1, 2, 3].iter().cloned().collect()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![1, 2, 3],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = vec![4, 5, 6];",
          "    let _ = bytes_mut.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), true);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![2, 3, 1]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![3, 2, 1]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3].to_vec()), true);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4, 5]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![4, 5, 6]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 0]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), true);"
        ],
        "code": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![1, 2, 3],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = vec![4, 5, 6];",
          "    let _ = bytes_mut.eq(&other);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), true);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![2, 3, 1]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![3, 2, 1]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3].to_vec()), true);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4, 5]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![4, 5, 6]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 0]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = vec![1, 2, 3];",
          "    let _ = bytes_mut.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4, 5]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&bytes_mut.ptr.as_ref()[..bytes_mut.len]), true);"
        ],
        "code": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = vec![1, 2, 3];",
          "    let _ = bytes_mut.eq(&other);",
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4, 5]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&bytes_mut.ptr.as_ref()[..bytes_mut.len]), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![1, 2, 3],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other: Vec<u8> = vec![];",
          "    let _ = bytes_mut.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), true);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![4, 5, 6]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    let other_empty: Vec<u8> = vec![];",
          "    assert_eq!(bytes_mut.eq(&other_empty), false);",
          "    let other_identical: Vec<u8> = vec![1, 2, 3];",
          "    assert_eq!(bytes_mut.eq(&other_identical), true);",
          "    let partial_eq: Vec<u8> = vec![1, 2, 3, 3];",
          "    assert_eq!(bytes_mut.eq(&partial_eq), false);",
          "    let other_len_only: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7];",
          "    assert_eq!(bytes_mut.eq(&other_len_only), false);"
        ],
        "code": [
          "{",
          "    let shared = Shared {",
          "        vec: vec![1, 2, 3],",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other: Vec<u8> = vec![];",
          "    let _ = bytes_mut.eq(&other);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3]), true);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![4, 5, 6]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![1, 2, 3, 4]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    let other_empty: Vec<u8> = vec![];",
          "    assert_eq!(bytes_mut.eq(&other_empty), false);",
          "    let other_identical: Vec<u8> = vec![1, 2, 3];",
          "    assert_eq!(bytes_mut.eq(&other_identical), true);",
          "    let partial_eq: Vec<u8> = vec![1, 2, 3, 3];",
          "    assert_eq!(bytes_mut.eq(&partial_eq), false);",
          "    let other_len_only: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7];",
          "    assert_eq!(bytes_mut.eq(&other_len_only), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let shared = Shared {",
          "        vec: (0..MAX_VEC_POS).map(|i| i as u8).collect(),",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = (0..MAX_VEC_POS).map(|i| i as u8).collect::<Vec<u8>>();",
          "    let _ = bytes_mut.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4]), true);",
          "    assert_eq!(bytes_mut.eq(&vec![5, 6, 7, 8, 9]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4, 5]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![0; MAX_VEC_POS]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4].to_vec()), true);",
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4][..]), true);"
        ],
        "code": [
          "{",
          "    let shared = Shared {",
          "        vec: (0..MAX_VEC_POS).map(|i| i as u8).collect(),",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    };",
          "    let bytes_mut = BytesMut {",
          "        ptr: NonNull::new(shared.vec.as_ptr() as *mut u8).unwrap(),",
          "        len: shared.vec.len(),",
          "        cap: shared.vec.capacity(),",
          "        data: &shared as *const Shared as *mut Shared,",
          "    };",
          "    let other = (0..MAX_VEC_POS).map(|i| i as u8).collect::<Vec<u8>>();",
          "    let _ = bytes_mut.eq(&other);",
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4]), true);",
          "    assert_eq!(bytes_mut.eq(&vec![5, 6, 7, 8, 9]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4, 5]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![0; MAX_VEC_POS]), false);",
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4].to_vec()), true);",
          "    assert_eq!(bytes_mut.eq(&vec![0, 1, 2, 3, 4][..]), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]