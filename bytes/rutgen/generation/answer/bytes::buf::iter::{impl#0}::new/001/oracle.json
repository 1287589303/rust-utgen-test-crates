[
  {
    "uses": [
      "use bytes::Bytes;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"abc\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(iter.inner, buf);",
          "    assert!(matches!(iter, IntoIter { inner: _ }));"
        ],
        "code": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"abc\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "    assert_eq!(iter.inner, buf);",
          "    assert!(matches!(iter, IntoIter { inner: _ }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(iter.inner, buf);",
          "    assert!(iter.get_ref() == &buf);",
          "    assert!(iter.get_mut() == &mut buf);",
          "    assert!(iter.into_inner() == buf);",
          "    assert!(std::mem::size_of::<IntoIter<Bytes>>() > 0);",
          "    assert!(std::mem::size_of::<Bytes>() > 0);"
        ],
        "code": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "    assert_eq!(iter.inner, buf);",
          "    assert!(iter.get_ref() == &buf);",
          "    assert!(iter.get_mut() == &mut buf);",
          "    assert!(iter.into_inner() == buf);",
          "    assert!(std::mem::size_of::<IntoIter<Bytes>>() > 0);",
          "    assert!(std::mem::size_of::<Bytes>() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"1234567890abcdef\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(iter.inner.len(), 16);",
          "    assert_eq!(inner.slice(..).to_vec(), vec![49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 97, 98, 99, 100, 101, 102]);",
          "    assert!(inner.is_static());"
        ],
        "code": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"1234567890abcdef\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "    assert_eq!(iter.inner.len(), 16);",
          "    assert_eq!(inner.slice(..).to_vec(), vec![49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 97, 98, 99, 100, 101, 102]);",
          "    assert!(inner.is_static());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(iter.inner, buf);",
          "    assert!(inner.is_empty());",
          "    assert!(iter.get_ref().is_empty());",
          "    assert!(iter.get_mut().is_empty());",
          "    let buf_non_empty = Bytes::from_static(b\"abc\");",
          "    let iter_non_empty = IntoIter::new(buf_non_empty);",
          "    assert_eq!(iter_non_empty.get_ref(), &buf_non_empty);",
          "    let mut mutable_inner = iter_non_empty.get_mut();",
          "    mutable_inner.extend_from_slice(b\"def\");",
          "    assert_eq!(iter_non_empty.get_ref(), &Bytes::from_static(b\"abcdef\"));"
        ],
        "code": [
          "{",
          "    use bytes::Bytes;",
          "",
          "    let buf = Bytes::from_static(b\"\");",
          "    let iter = IntoIter::new(buf);",
          "    let inner = iter.into_inner();",
          "    assert_eq!(iter.inner, buf);",
          "    assert!(inner.is_empty());",
          "    assert!(iter.get_ref().is_empty());",
          "    assert!(iter.get_mut().is_empty());",
          "    let buf_non_empty = Bytes::from_static(b\"abc\");",
          "    let iter_non_empty = IntoIter::new(buf_non_empty);",
          "    assert_eq!(iter_non_empty.get_ref(), &buf_non_empty);",
          "    let mut mutable_inner = iter_non_empty.get_mut();",
          "    mutable_inner.extend_from_slice(b\"def\");",
          "    assert_eq!(iter_non_empty.get_ref(), &Bytes::from_static(b\"abcdef\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]