[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    // Step 1: Create a Vec<u8> and wrap it in Shared",
          "    let vec: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    // Step 2: Create an AtomicPtr<()>",
          "    let data = AtomicPtr::new(shared.cast());",
          "",
          "    // Step 3: Get the pointer to the Vec<u8> and the length",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared).vec.len() };",
          "",
          "    // Step 4: Call the function under test",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let vec: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let shared_ptr = Box::into_raw(Box::new(Shared {",
          "    vec: vec.clone(),",
          "    original_capacity_repr: 0,",
          "    ref_count: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(shared_ptr.cast());",
          "    let ptr = unsafe { (*shared_ptr).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared_ptr).vec.len() };",
          "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
          "    assert_eq!(result.len(), len);",
          "    assert_eq!(result.cap, unsafe { (*shared_ptr).vec.capacity() - offset_from(ptr as *mut u8, (*shared_ptr).vec.as_mut_ptr()) });",
          "    assert_eq!(result.data, shared_ptr);",
          "    assert!(!result.ptr.is_null());",
          "    assert_eq!(result.ptr.as_ptr(), ptr);"
        ],
        "code": [
          "{",
          "    // Step 1: Create a Vec<u8> and wrap it in Shared",
          "    let vec: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    // Step 2: Create an AtomicPtr<()>",
          "    let data = AtomicPtr::new(shared.cast());",
          "",
          "    // Step 3: Get the pointer to the Vec<u8> and the length",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared).vec.len() };",
          "",
          "    // Step 4: Call the function under test",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "    let vec: Vec<u8> = vec![1, 2, 3, 4, 5];",
          "    let shared_ptr = Box::into_raw(Box::new(Shared {",
          "    vec: vec.clone(),",
          "    original_capacity_repr: 0,",
          "    ref_count: AtomicUsize::new(1),",
          "    }));",
          "    let data = AtomicPtr::new(shared_ptr.cast());",
          "    let ptr = unsafe { (*shared_ptr).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared_ptr).vec.len() };",
          "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
          "    assert_eq!(result.len(), len);",
          "    assert_eq!(result.cap, unsafe { (*shared_ptr).vec.capacity() - offset_from(ptr as *mut u8, (*shared_ptr).vec.as_mut_ptr()) });",
          "    assert_eq!(result.data, shared_ptr);",
          "    assert!(!result.ptr.is_null());",
          "    assert_eq!(result.ptr.as_ptr(), ptr);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec: Vec<u8> = vec![10, 20, 30, 40, 50];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared).vec.len() };",
          "",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let vec: Vec<u8> = vec![10, 20, 30, 40, 50];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "    vec,",
          "    original_capacity_repr: 0,",
          "    ref_count: AtomicUsize::new(1),",
          "    }));",
          "    ",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared).vec.len() };",
          "    ",
          "    unsafe {",
          "    let result = shared_v_to_mut(&data, ptr, len);",
          "    assert_eq!(result.len(), len);",
          "    assert_eq!(result.capacity(), (*shared).vec.capacity() - offset_from(ptr as *mut u8, (*shared).vec.as_mut_ptr()));",
          "    assert_eq!(result.data, shared);",
          "    }"
        ],
        "code": [
          "{",
          "    let vec: Vec<u8> = vec![10, 20, 30, 40, 50];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared).vec.len() };",
          "",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "    let vec: Vec<u8> = vec![10, 20, 30, 40, 50];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "    vec,",
          "    original_capacity_repr: 0,",
          "    ref_count: AtomicUsize::new(1),",
          "    }));",
          "    ",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = unsafe { (*shared).vec.len() };",
          "    ",
          "    unsafe {",
          "    let result = shared_v_to_mut(&data, ptr, len);",
          "    assert_eq!(result.len(), len);",
          "    assert_eq!(result.capacity(), (*shared).vec.capacity() - offset_from(ptr as *mut u8, (*shared).vec.as_mut_ptr()));",
          "    assert_eq!(result.data, shared);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec: Vec<u8> = vec![100, 200, 300, 400, 500];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = 3; // valid partial length",
          "",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let expected_ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let expected_len = 3;",
          "    let expected_cap = unsafe { (*shared).vec.capacity() - offset_from(ptr, expected_ptr) };",
          "    let expected_data = shared;",
          "    ",
          "    assert_eq!(result.ptr, expected_ptr);",
          "    assert_eq!(result.len, expected_len);",
          "    assert_eq!(result.cap, expected_cap);",
          "    assert_eq!(result.data, expected_data);"
        ],
        "code": [
          "{",
          "    let vec: Vec<u8> = vec![100, 200, 300, 400, 500];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = 3; // valid partial length",
          "",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "    let expected_ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let expected_len = 3;",
          "    let expected_cap = unsafe { (*shared).vec.capacity() - offset_from(ptr, expected_ptr) };",
          "    let expected_data = shared;",
          "    ",
          "    assert_eq!(result.ptr, expected_ptr);",
          "    assert_eq!(result.len, expected_len);",
          "    assert_eq!(result.cap, expected_cap);",
          "    assert_eq!(result.data, expected_data);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let vec: Vec<u8> = vec![12, 34, 56, 78];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = 0; // Zero length case",
          "",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let vec: Vec<u8> = vec![12, 34, 56, 78];",
          "    let shared = Box::into_raw(Box::new(Shared { vec, original_capacity_repr: 0, ref_count: AtomicUsize::new(1), }));",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = 0;",
          "    unsafe { let result = shared_v_to_mut(&data, ptr, len); assert_eq!(result.len(), 0); assert_eq!(result.cap, (*shared).vec.capacity()); assert!(result.data == shared); }",
          "    let expected_ptr = vptr(ptr as *mut u8); assert!(result.ptr == expected_ptr);"
        ],
        "code": [
          "{",
          "    let vec: Vec<u8> = vec![12, 34, 56, 78];",
          "    let shared = Box::into_raw(Box::new(Shared {",
          "        vec,",
          "        original_capacity_repr: 0,",
          "        ref_count: AtomicUsize::new(1),",
          "    }));",
          "",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = 0; // Zero length case",
          "",
          "    unsafe {",
          "        let result = shared_v_to_mut(&data, ptr, len);",
          "    }",
          "    let vec: Vec<u8> = vec![12, 34, 56, 78];",
          "    let shared = Box::into_raw(Box::new(Shared { vec, original_capacity_repr: 0, ref_count: AtomicUsize::new(1), }));",
          "    let data = AtomicPtr::new(shared.cast());",
          "    let ptr = unsafe { (*shared).vec.as_mut_ptr() };",
          "    let len = 0;",
          "    unsafe { let result = shared_v_to_mut(&data, ptr, len); assert_eq!(result.len(), 0); assert_eq!(result.cap, (*shared).vec.capacity()); assert!(result.data == shared); }",
          "    let expected_ptr = vptr(ptr as *mut u8); assert!(result.ptr == expected_ptr);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]