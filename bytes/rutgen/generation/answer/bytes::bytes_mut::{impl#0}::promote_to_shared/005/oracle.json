[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 10])) as *mut u8);",
          "        bytes_mut.len = 5;",
          "        bytes_mut.cap = 10;",
          "        bytes_mut.data = (KIND_VEC | (4 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(bytes_mut.len, 5);",
          "    assert_eq!(bytes_mut.cap, 10);",
          "    assert_eq!(bytes_mut.ptr.as_ptr(), (bytes_mut.data as *mut Shared).vec.as_ptr());",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 1);",
          "    ",
          "    unsafe {",
          "    bytes_mut.promote_to_shared(2);",
          "    }",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 2);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 10])) as *mut u8);",
          "        bytes_mut.len = 5;",
          "        bytes_mut.cap = 10;",
          "        bytes_mut.data = (KIND_VEC | (4 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(bytes_mut.len, 5);",
          "    assert_eq!(bytes_mut.cap, 10);",
          "    assert_eq!(bytes_mut.ptr.as_ptr(), (bytes_mut.data as *mut Shared).vec.as_ptr());",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 1);",
          "    ",
          "    unsafe {",
          "    bytes_mut.promote_to_shared(2);",
          "    }",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 10])) as *mut u8);",
          "        bytes_mut.len = 5;",
          "        bytes_mut.cap = 10;",
          "        bytes_mut.data = (KIND_VEC | (4 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(2);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(bytes_mut.len, 5);",
          "    assert_eq!(bytes_mut.cap, 10);",
          "    assert_eq!(unsafe { &*(bytes_mut.data as *mut Shared) }.ref_count.load(Ordering::SeqCst), 2);",
          "    assert_eq!(unsafe { &*(bytes_mut.data as *mut Shared) }.vec.len(), 10);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 10])) as *mut u8);",
          "        bytes_mut.len = 5;",
          "        bytes_mut.cap = 10;",
          "        bytes_mut.data = (KIND_VEC | (4 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(2);",
          "    }",
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(bytes_mut.len, 5);",
          "    assert_eq!(bytes_mut.cap, 10);",
          "    assert_eq!(unsafe { &*(bytes_mut.data as *mut Shared) }.ref_count.load(Ordering::SeqCst), 2);",
          "    assert_eq!(unsafe { &*(bytes_mut.data as *mut Shared) }.vec.len(), 10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 10])) as *mut u8);",
          "        bytes_mut.len = 5;",
          "        bytes_mut.cap = 10;",
          "        bytes_mut.data = (KIND_VEC | (0 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(1);",
          "",
          "        bytes_mut.data = (KIND_VEC | (1 << VEC_POS_OFFSET)) as *mut Shared;",
          "        bytes_mut.promote_to_shared(2);",
          "    }",
          "}"
        ],
        "oracle": [
          "    bytes_mut.kind() == KIND_VEC",
          "    bytes_mut.len() == 5",
          "    bytes_mut.capacity() == 10",
          "    unsafe { bytes_mut.promote_to_shared(1) }",
          "    unsafe { (bytes_mut.data as usize & KIND_MASK) == KIND_ARC }",
          "    unsafe { bytes_mut.promote_to_shared(2) }",
          "    unsafe { (bytes_mut.data as usize & KIND_MASK) == KIND_ARC }",
          "    unsafe { (*bytes_mut.data).ref_count.load(Ordering::Relaxed) == 1 }",
          "    unsafe { (*bytes_mut.data).ref_count.load(Ordering::Relaxed) == 2 }",
          "    unsafe { (*bytes_mut.data).vec.len() == 5 }",
          "    unsafe { (*bytes_mut.data).vec.capacity() == 10 }"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 10])) as *mut u8);",
          "        bytes_mut.len = 5;",
          "        bytes_mut.cap = 10;",
          "        bytes_mut.data = (KIND_VEC | (0 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(1);",
          "",
          "        bytes_mut.data = (KIND_VEC | (1 << VEC_POS_OFFSET)) as *mut Shared;",
          "        bytes_mut.promote_to_shared(2);",
          "    }",
          "    bytes_mut.kind() == KIND_VEC",
          "    bytes_mut.len() == 5",
          "    bytes_mut.capacity() == 10",
          "    unsafe { bytes_mut.promote_to_shared(1) }",
          "    unsafe { (bytes_mut.data as usize & KIND_MASK) == KIND_ARC }",
          "    unsafe { bytes_mut.promote_to_shared(2) }",
          "    unsafe { (bytes_mut.data as usize & KIND_MASK) == KIND_ARC }",
          "    unsafe { (*bytes_mut.data).ref_count.load(Ordering::Relaxed) == 1 }",
          "    unsafe { (*bytes_mut.data).ref_count.load(Ordering::Relaxed) == 2 }",
          "    unsafe { (*bytes_mut.data).vec.len() == 5 }",
          "    unsafe { (*bytes_mut.data).vec.capacity() == 10 }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::new();",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 0])) as *mut u8);",
          "        bytes_mut.len = 0;",
          "        bytes_mut.cap = 0;",
          "        bytes_mut.data = (KIND_VEC | (0 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(bytes_mut.data as usize & ORIGINAL_CAPACITY_MASK >> ORIGINAL_CAPACITY_OFFSET, 0);",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 1);",
          "    ",
          "    let vec_ref = unsafe { &(*bytes_mut.data).vec };",
          "    assert_eq!(vec_ref.len(), 0);",
          "    assert_eq!(vec_ref.cap, 0);",
          "    ",
          "    unsafe {",
          "    bytes_mut.promote_to_shared(2);",
          "    }",
          "    ",
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 2);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::new();",
          "    unsafe {",
          "        bytes_mut.ptr = NonNull::new_unchecked(Box::into_raw(Box::new([0u8; 0])) as *mut u8);",
          "        bytes_mut.len = 0;",
          "        bytes_mut.cap = 0;",
          "        bytes_mut.data = (KIND_VEC | (0 << VEC_POS_OFFSET)) as *mut Shared;",
          "",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(bytes_mut.data as usize & ORIGINAL_CAPACITY_MASK >> ORIGINAL_CAPACITY_OFFSET, 0);",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 1);",
          "    ",
          "    let vec_ref = unsafe { &(*bytes_mut.data).vec };",
          "    assert_eq!(vec_ref.len(), 0);",
          "    assert_eq!(vec_ref.cap, 0);",
          "    ",
          "    unsafe {",
          "    bytes_mut.promote_to_shared(2);",
          "    }",
          "    ",
          "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
          "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]