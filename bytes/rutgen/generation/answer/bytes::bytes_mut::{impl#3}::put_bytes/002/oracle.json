[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    let val: u8 = 127; ",
          "    let cnt: usize = 11; // cnt is greater than the current capacity",
          "    bytes_mut.put_bytes(val, cnt);",
          "}"
        ],
        "oracle": [
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    let val: u8 = 127;",
          "    let cnt: usize = 11;  // cnt is greater than the current capacity",
          "    let result = std::panic::catch_unwind(|| { bytes_mut.put_bytes(val, cnt); });",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    let val: u8 = 127; ",
          "    let cnt: usize = 11; // cnt is greater than the current capacity",
          "    bytes_mut.put_bytes(val, cnt);",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    let val: u8 = 127;",
          "    let cnt: usize = 11;  // cnt is greater than the current capacity",
          "    let result = std::panic::catch_unwind(|| { bytes_mut.put_bytes(val, cnt); });",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(5);",
          "    let val: u8 = 200; ",
          "    let cnt: usize = 6; // cnt is equal to capacity + 1",
          "    bytes_mut.put_bytes(val, cnt);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.capacity() >= cnt);",
          "    assert!(bytes_mut.is_empty());",
          "    assert!(unsafe { bytes_mut.spare_capacity_mut().len() < cnt });"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(5);",
          "    let val: u8 = 200; ",
          "    let cnt: usize = 6; // cnt is equal to capacity + 1",
          "    bytes_mut.put_bytes(val, cnt);",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.capacity() >= cnt);",
          "    assert!(bytes_mut.is_empty());",
          "    assert!(unsafe { bytes_mut.spare_capacity_mut().len() < cnt });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(20);",
          "    let val: u8 = 255; ",
          "    let cnt: usize = 0; // cnt is zero",
          "    bytes_mut.put_bytes(val, cnt);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.capacity() >= 20);",
          "    assert!(bytes_mut.is_empty());",
          "    assert_eq!(bytes_mut.spare_capacity_mut().len(), 20);"
        ],
        "code": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(20);",
          "    let val: u8 = 255; ",
          "    let cnt: usize = 0; // cnt is zero",
          "    bytes_mut.put_bytes(val, cnt);",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.capacity() >= 20);",
          "    assert!(bytes_mut.is_empty());",
          "    assert_eq!(bytes_mut.spare_capacity_mut().len(), 20);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]