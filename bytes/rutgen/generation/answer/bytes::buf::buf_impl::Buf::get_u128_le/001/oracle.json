[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x09,",
          "        0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01",
          "    ];",
          "    let result = buf.get_u128_le();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(0x01020304050607080910111213141516, result);",
          "    let mut buf_underflow: &[u8] = &[0x01, 0x02];",
          "    let panic_result = std::panic::catch_unwind(|| buf_underflow.get_u128_le());",
          "    assert!(panic_result.is_err());",
          "    let mut empty_buf: &[u8] = &[];",
          "    let panic_result_empty = std::panic::catch_unwind(|| empty_buf.get_u128_le());",
          "    assert!(panic_result_empty.is_err());",
          "    let mut buf_partial: &[u8] = &[0x01, 0x02, 0x03];",
          "    let panic_result_partial = std::panic::catch_unwind(|| buf_partial.get_u128_le());",
          "    assert!(panic_result_partial.is_err());",
          "    let mut full_buffer: &[u8] = &",
          "    [0x01, 0x02, 0x03, 0x04,",
          "    0x05, 0x06, 0x07, 0x08,",
          "    0x09, 0x10, 0x11, 0x12,",
          "    0x13, 0x14, 0x15, 0x16];",
          "    let result_full = full_buffer.get_u128_le();",
          "    assert_eq!(0x01020304050607080910111213141516, result_full);"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x09,",
          "        0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01",
          "    ];",
          "    let result = buf.get_u128_le();",
          "    assert_eq!(0x01020304050607080910111213141516, result);",
          "    let mut buf_underflow: &[u8] = &[0x01, 0x02];",
          "    let panic_result = std::panic::catch_unwind(|| buf_underflow.get_u128_le());",
          "    assert!(panic_result.is_err());",
          "    let mut empty_buf: &[u8] = &[];",
          "    let panic_result_empty = std::panic::catch_unwind(|| empty_buf.get_u128_le());",
          "    assert!(panic_result_empty.is_err());",
          "    let mut buf_partial: &[u8] = &[0x01, 0x02, 0x03];",
          "    let panic_result_partial = std::panic::catch_unwind(|| buf_partial.get_u128_le());",
          "    assert!(panic_result_partial.is_err());",
          "    let mut full_buffer: &[u8] = &",
          "    [0x01, 0x02, 0x03, 0x04,",
          "    0x05, 0x06, 0x07, 0x08,",
          "    0x09, 0x10, 0x11, 0x12,",
          "    0x13, 0x14, 0x15, 0x16];",
          "    let result_full = full_buffer.get_u128_le();",
          "    assert_eq!(0x01020304050607080910111213141516, result_full);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &[];",
          "    let _ = buf.get_u128_le();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(0x01020304050607080910111213141516, buf.get_u128_le());",
          "    let mut buf: &[u8] = &[];",
          "    let _ = buf.get_u128_le();"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &[];",
          "    let _ = buf.get_u128_le();",
          "    assert_eq!(0x01020304050607080910111213141516, buf.get_u128_le());",
          "    let mut buf: &[u8] = &[];",
          "    let _ = buf.get_u128_le();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &[0x01];",
          "    let _ = buf.get_u128_le();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(0x01020304050607080910111213141516, buf.get_u128_le());",
          "    let mut buf: &[u8] = &[0x01];",
          "    let result = std::panic::catch_unwind(|| { buf.get_u128_le(); });",
          "    assert!(result.is_err());",
          "    let mut buf_with_sufficient_data: &[u8] = &[0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01];",
          "    let value = buf_with_sufficient_data.get_u128_le();",
          "    assert_eq!(value, 0x01020304050607080910111213141516);",
          "    let buf_empty: &[u8] = &[];",
          "    let empty_result = std::panic::catch_unwind(|| { buf_empty.get_u128_le(); });",
          "    assert!(empty_result.is_err());"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &[0x01];",
          "    let _ = buf.get_u128_le();",
          "    assert_eq!(0x01020304050607080910111213141516, buf.get_u128_le());",
          "    let mut buf: &[u8] = &[0x01];",
          "    let result = std::panic::catch_unwind(|| { buf.get_u128_le(); });",
          "    assert!(result.is_err());",
          "    let mut buf_with_sufficient_data: &[u8] = &[0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01];",
          "    let value = buf_with_sufficient_data.get_u128_le();",
          "    assert_eq!(value, 0x01020304050607080910111213141516);",
          "    let buf_empty: &[u8] = &[];",
          "    let empty_result = std::panic::catch_unwind(|| { buf_empty.get_u128_le(); });",
          "    assert!(empty_result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,",
          "        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F",
          "    ];",
          "    let _ = buf.get_u128_le();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.remaining(), 16);",
          "    assert!(buf.has_remaining());",
          "    assert!(std::panic::catch_unwind(|| buf.get_u128_le()).is_err());"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,",
          "        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F",
          "    ];",
          "    let _ = buf.get_u128_le();",
          "    assert_eq!(buf.remaining(), 16);",
          "    assert!(buf.has_remaining());",
          "    assert!(std::panic::catch_unwind(|| buf.get_u128_le()).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00",
          "    ];",
          "    let result = buf.get_u128_le();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 0x00000000000000000000000000000000);",
          "    assert_eq!(buf.remaining(), 0);",
          "    buf.advance(16);",
          "    assert!(!buf.has_remaining());",
          "    assert!(std::panic::catch_unwind(|| buf.get_u128_le()).is_err());",
          "    buf = &b\"\\x16\\x15\\x14\\x13\\x12\\x11\\x10\\x09\\x08\\x07\\x06\\x05\\x04\\x03\\x02\\x01 hello\"[..];",
          "    let result2 = buf.get_u128_le();",
          "    assert_eq!(result2, 0x01020304050607080910111213141516);"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,",
          "        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00",
          "    ];",
          "    let result = buf.get_u128_le();",
          "    assert_eq!(result, 0x00000000000000000000000000000000);",
          "    assert_eq!(buf.remaining(), 0);",
          "    buf.advance(16);",
          "    assert!(!buf.has_remaining());",
          "    assert!(std::panic::catch_unwind(|| buf.get_u128_le()).is_err());",
          "    buf = &b\"\\x16\\x15\\x14\\x13\\x12\\x11\\x10\\x09\\x08\\x07\\x06\\x05\\x04\\x03\\x02\\x01 hello\"[..];",
          "    let result2 = buf.get_u128_le();",
          "    assert_eq!(result2, 0x01020304050607080910111213141516);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,",
          "        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF",
          "    ];",
          "    let result = buf.get_u128_le();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, result);"
        ],
        "code": [
          "{",
          "    let mut buf: &[u8] = &[",
          "        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,",
          "        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF",
          "    ];",
          "    let result = buf.get_u128_le();",
          "    assert_eq!(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]