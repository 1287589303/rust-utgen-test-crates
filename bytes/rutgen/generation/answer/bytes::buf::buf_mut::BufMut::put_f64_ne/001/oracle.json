[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(1.2f64.to_bits());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.remaining_mut(), 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    assert_eq!(buf.buffer[..8], if cfg!(target_endian = \"big\") {",
          "    b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\"",
          "    } else {",
          "    b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\"",
          "    });",
          "    assert!(buf.remaining_mut() == 8);"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(1.2f64.to_bits());",
          "    assert_eq!(buf.remaining_mut(), 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    assert_eq!(buf.buffer[..8], if cfg!(target_endian = \"big\") {",
          "    b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\"",
          "    } else {",
          "    b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\"",
          "    });",
          "    assert!(buf.remaining_mut() == 8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(0.0f64.to_bits());",
          "}"
        ],
        "oracle": [
          "    assert!(buf.remaining_mut() == 16);",
          "    assert!(buf.remaining_mut() == 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    assert_eq!(&buf.buffer[..], if cfg!(target_endian = \"big\") { &b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\"[..] } else { &b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\"[..] });",
          "    assert!(buf.remaining_mut() == 8);",
          "    buf.put_f64_ne(2.5f64);",
          "    assert_eq!(&buf.buffer[..16], if cfg!(target_endian = \"big\") { &b\"\\x3F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\"[..] } else { &b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x3F\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\"[..] });",
          "    assert!(panic::catch_unwind(|| buf.put_f64_ne(3.0f64)).is_err());"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(0.0f64.to_bits());",
          "    assert!(buf.remaining_mut() == 16);",
          "    assert!(buf.remaining_mut() == 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    assert_eq!(&buf.buffer[..], if cfg!(target_endian = \"big\") { &b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\"[..] } else { &b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\"[..] });",
          "    assert!(buf.remaining_mut() == 8);",
          "    buf.put_f64_ne(2.5f64);",
          "    assert_eq!(&buf.buffer[..16], if cfg!(target_endian = \"big\") { &b\"\\x3F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\"[..] } else { &b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x3F\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\"[..] });",
          "    assert!(panic::catch_unwind(|| buf.put_f64_ne(3.0f64)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne((-0.0f64).to_bits());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf.remaining_mut(), 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    assert_eq!(buf.buffer[0..8], if cfg!(target_endian = \"big\") { b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\" } else { b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\" });",
          "    assert!(buf.remaining_mut() == 0);",
          "    let initial_capacity = 8;",
          "    let mut buf_overflow = TestBuf::new(initial_capacity);",
          "    let result = std::panic::catch_unwind(|| { buf_overflow.put_f64_ne(1.0); });",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne((-0.0f64).to_bits());",
          "    assert_eq!(buf.remaining_mut(), 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    assert_eq!(buf.buffer[0..8], if cfg!(target_endian = \"big\") { b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\" } else { b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\" });",
          "    assert!(buf.remaining_mut() == 0);",
          "    let initial_capacity = 8;",
          "    let mut buf_overflow = TestBuf::new(initial_capacity);",
          "    let result = std::panic::catch_unwind(|| { buf_overflow.put_f64_ne(1.0); });",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(f64::NAN.to_bits());",
          "}"
        ],
        "oracle": [
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    if cfg!(target_endian = \"big\") {",
          "    assert_eq!(buf.buffer, b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\");",
          "    } else {",
          "    assert_eq!(buf.buffer, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
          "    }",
          "    buf.put_f64_ne(f64::INFINITY);",
          "    if cfg!(target_endian = \"big\") {",
          "    assert_eq!(buf.buffer[8..], b\"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    } else {",
          "    assert_eq!(buf.buffer[8..], b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\");",
          "    }",
          "    buf.put_f64_ne(f64::NEG_INFINITY);",
          "    if cfg!(target_endian = \"big\") {",
          "    assert_eq!(buf.buffer[16..], b\"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    } else {",
          "    assert_eq!(buf.buffer[16..], b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\");",
          "    }",
          "    let remaining = buf.remaining_mut();",
          "    buf.advance_mut(8);",
          "    assert!(remaining >= 8);"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(f64::NAN.to_bits());",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(1.2f64);",
          "    if cfg!(target_endian = \"big\") {",
          "    assert_eq!(buf.buffer, b\"\\x3F\\xF3\\x33\\x33\\x33\\x33\\x33\\x33\");",
          "    } else {",
          "    assert_eq!(buf.buffer, b\"\\x33\\x33\\x33\\x33\\x33\\x33\\xF3\\x3F\");",
          "    }",
          "    buf.put_f64_ne(f64::INFINITY);",
          "    if cfg!(target_endian = \"big\") {",
          "    assert_eq!(buf.buffer[8..], b\"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    } else {",
          "    assert_eq!(buf.buffer[8..], b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\");",
          "    }",
          "    buf.put_f64_ne(f64::NEG_INFINITY);",
          "    if cfg!(target_endian = \"big\") {",
          "    assert_eq!(buf.buffer[16..], b\"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\");",
          "    } else {",
          "    assert_eq!(buf.buffer[16..], b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\");",
          "    }",
          "    let remaining = buf.remaining_mut();",
          "    buf.advance_mut(8);",
          "    assert!(remaining >= 8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(f64::INFINITY.to_bits());",
          "}"
        ],
        "oracle": [
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(f64::INFINITY);",
          "    assert_eq!(buf.buffer[..8], f64::INFINITY.to_ne_bytes());",
          "    assert_eq!(buf.position, 8);",
          "    buf.put_f64_ne(f64::NEG_INFINITY);",
          "    assert_eq!(buf.buffer[..8], f64::NEG_INFINITY.to_ne_bytes());",
          "    assert_eq!(buf.position, 16);",
          "    let result = std::panic::catch_unwind(|| { buf.put_f64_ne(1.0); });",
          "    assert!(result.is_err());",
          "    let mut buf2 = TestBuf::new(8);",
          "    assert!(buf2.remaining_mut() < 8);",
          "    let result2 = std::panic::catch_unwind(|| { buf2.put_f64_ne(2.0); });",
          "    assert!(result2.is_err());"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne(f64::INFINITY.to_bits());",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(f64::INFINITY);",
          "    assert_eq!(buf.buffer[..8], f64::INFINITY.to_ne_bytes());",
          "    assert_eq!(buf.position, 8);",
          "    buf.put_f64_ne(f64::NEG_INFINITY);",
          "    assert_eq!(buf.buffer[..8], f64::NEG_INFINITY.to_ne_bytes());",
          "    assert_eq!(buf.position, 16);",
          "    let result = std::panic::catch_unwind(|| { buf.put_f64_ne(1.0); });",
          "    assert!(result.is_err());",
          "    let mut buf2 = TestBuf::new(8);",
          "    assert!(buf2.remaining_mut() < 8);",
          "    let result2 = std::panic::catch_unwind(|| { buf2.put_f64_ne(2.0); });",
          "    assert!(result2.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne((-f64::INFINITY).to_bits());",
          "}"
        ],
        "oracle": [
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(f64::MAX);",
          "    assert_eq!(buf.buffer[0..8], f64::MAX.to_bits().to_ne_bytes());",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(f64::MIN);",
          "    assert_eq!(buf.buffer[8..16], f64::MIN.to_bits().to_ne_bytes());",
          "    assert!(buf.remaining_mut() < 8);",
          "    let result = std::panic::catch_unwind(|| { buf.put_f64_ne(1.0); });",
          "    assert!(result.is_err());",
          "    assert!(buf.remaining_mut() == 0);"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        buffer: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestBuf {",
          "        fn new(capacity: usize) -> Self {",
          "            Self { buffer: vec![0; capacity], position: 0 }",
          "        }",
          "",
          "        fn remaining_mut(&self) -> usize {",
          "            self.buffer.len() - self.position",
          "        }",
          "",
          "        unsafe fn advance_mut(&mut self, cnt: usize) {",
          "            self.position += cnt;",
          "        }",
          "",
          "        fn put_u64_ne(&mut self, n: u64) {",
          "            let bytes = n.to_ne_bytes();",
          "            self.buffer[self.position..self.position + 8].copy_from_slice(&bytes);",
          "            unsafe { self.advance_mut(8) };",
          "        }",
          "    }",
          "",
          "    let mut buf = TestBuf::new(16);",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_u64_ne((-f64::INFINITY).to_bits());",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(f64::MAX);",
          "    assert_eq!(buf.buffer[0..8], f64::MAX.to_bits().to_ne_bytes());",
          "    assert!(buf.remaining_mut() >= 8);",
          "    buf.put_f64_ne(f64::MIN);",
          "    assert_eq!(buf.buffer[8..16], f64::MIN.to_bits().to_ne_bytes());",
          "    assert!(buf.remaining_mut() < 8);",
          "    let result = std::panic::catch_unwind(|| { buf.put_f64_ne(1.0); });",
          "    assert!(result.is_err());",
          "    assert!(buf.remaining_mut() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]