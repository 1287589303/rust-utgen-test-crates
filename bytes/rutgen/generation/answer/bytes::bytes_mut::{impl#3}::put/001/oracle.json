[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl Buf for TestBuf {",
          "        fn remaining(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "",
          "        fn chunk(&self) -> &[u8] {",
          "            &self.data[self.pos..]",
          "        }",
          "",
          "        fn advance(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "",
          "        fn has_remaining(&self) -> bool {",
          "            self.remaining() > 0",
          "        }",
          "    }",
          "",
          "    let mut bytes_mut = BytesMut::new();",
          "    let buf = TestBuf {",
          "        data: vec![1, 2, 3, 4, 5],",
          "        pos: 0,",
          "    };",
          "    ",
          "    bytes_mut.put(buf);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert!(bytes_mut.as_slice() == &[1, 2, 3, 4, 5]);",
          "    assert!(bytes_mut.capacity() >= 5);",
          "    assert!(!bytes_mut.is_empty());",
          "    ",
          "    let buf_empty = TestBuf {",
          "    data: vec![],",
          "    pos: 0,",
          "    };",
          "    ",
          "    let prev_len = bytes_mut.len();",
          "    bytes_mut.put(buf_empty);",
          "    assert_eq!(bytes_mut.len(), prev_len);"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl Buf for TestBuf {",
          "        fn remaining(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "",
          "        fn chunk(&self) -> &[u8] {",
          "            &self.data[self.pos..]",
          "        }",
          "",
          "        fn advance(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "",
          "        fn has_remaining(&self) -> bool {",
          "            self.remaining() > 0",
          "        }",
          "    }",
          "",
          "    let mut bytes_mut = BytesMut::new();",
          "    let buf = TestBuf {",
          "        data: vec![1, 2, 3, 4, 5],",
          "        pos: 0,",
          "    };",
          "    ",
          "    bytes_mut.put(buf);",
          "    assert_eq!(bytes_mut.len(), 5);",
          "    assert!(bytes_mut.as_slice() == &[1, 2, 3, 4, 5]);",
          "    assert!(bytes_mut.capacity() >= 5);",
          "    assert!(!bytes_mut.is_empty());",
          "    ",
          "    let buf_empty = TestBuf {",
          "    data: vec![],",
          "    pos: 0,",
          "    };",
          "    ",
          "    let prev_len = bytes_mut.len();",
          "    bytes_mut.put(buf_empty);",
          "    assert_eq!(bytes_mut.len(), prev_len);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl Buf for TestBuf {",
          "        fn remaining(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "",
          "        fn chunk(&self) -> &[u8] {",
          "            &self.data[self.pos..]",
          "        }",
          "",
          "        fn advance(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "",
          "        fn has_remaining(&self) -> bool {",
          "            self.remaining() > 0",
          "        }",
          "    }",
          "",
          "    let mut bytes_mut = BytesMut::new();",
          "    let buf = TestBuf {",
          "        data: vec![], // No remaining data",
          "        pos: 0,",
          "    };",
          "    ",
          "    bytes_mut.put(buf);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.is_empty());",
          "    ",
          "    let data = vec![1, 2, 3];",
          "    let mut buf_with_data = TestBuf {",
          "    data,",
          "    pos: 0,",
          "    };",
          "    ",
          "    bytes_mut.put(buf_with_data);",
          "    assert_eq!(bytes_mut.len(), 3);",
          "    assert!(!bytes_mut.is_empty());"
        ],
        "code": [
          "{",
          "    struct TestBuf {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl Buf for TestBuf {",
          "        fn remaining(&self) -> usize {",
          "            self.data.len() - self.pos",
          "        }",
          "",
          "        fn chunk(&self) -> &[u8] {",
          "            &self.data[self.pos..]",
          "        }",
          "",
          "        fn advance(&mut self, cnt: usize) {",
          "            self.pos += cnt;",
          "        }",
          "",
          "        fn has_remaining(&self) -> bool {",
          "            self.remaining() > 0",
          "        }",
          "    }",
          "",
          "    let mut bytes_mut = BytesMut::new();",
          "    let buf = TestBuf {",
          "        data: vec![], // No remaining data",
          "        pos: 0,",
          "    };",
          "    ",
          "    bytes_mut.put(buf);",
          "    assert_eq!(bytes_mut.len(), 0);",
          "    assert!(bytes_mut.is_empty());",
          "    ",
          "    let data = vec![1, 2, 3];",
          "    let mut buf_with_data = TestBuf {",
          "    data,",
          "    pos: 0,",
          "    };",
          "    ",
          "    bytes_mut.put(buf_with_data);",
          "    assert_eq!(bytes_mut.len(), 3);",
          "    assert!(!bytes_mut.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]