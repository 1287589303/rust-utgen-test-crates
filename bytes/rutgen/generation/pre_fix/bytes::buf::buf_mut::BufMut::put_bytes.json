{
  "name": "bytes::buf::buf_mut::BufMut::put_bytes",
  "mod_info": {
    "name": "buf::buf_mut",
    "loc": "src/buf/mod.rs:18:1:18:13"
  },
  "visible": true,
  "loc": "src/buf/buf_mut.rs:292:5:309:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.remaining_mut() < cnt at line 293 is true\n"
      ],
      "input_infer": "self.remaining_mut() = cnt + 1 to self.remaining_mut() = u64::MAX\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: [u8; 5],",
                "        position: usize,",
                "    }",
                "    ",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            UninitSlice::new(&mut self.data[self.position..])",
                "        }",
                "        ",
                "        fn put_u8(&mut self, _n: u8) {}",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: [0; 5], position: 0 };",
                "    buf.put_bytes(b'a', 6); // Panic expected",
                "}"
              ],
              "oracle": [
                "    assert_panics!(buf.put_bytes(b'a', 6));",
                "    assert_eq!(buf.remaining_mut(), 5);",
                "    assert_eq!(buf.data, [0, 0, 0, 0, 0]);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: [u8; 5],",
                "        position: usize,",
                "    }",
                "    ",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            UninitSlice::new(&mut self.data[self.position..])",
                "        }",
                "        ",
                "        fn put_u8(&mut self, _n: u8) {}",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: [0; 5], position: 0 };",
                "    buf.put_bytes(b'a', 6); // Panic expected",
                "    assert_panics!(buf.put_bytes(b'a', 6));",
                "    assert_eq!(buf.remaining_mut(), 5);",
                "    assert_eq!(buf.data, [0, 0, 0, 0, 0]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: [u8; 10],",
                "        position: usize,",
                "    }",
                "    ",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            UninitSlice::new(&mut self.data[self.position..])",
                "        }",
                "",
                "        fn put_u8(&mut self, _n: u8) {}",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: [0; 10], position: 5 };",
                "    buf.put_bytes(b'b', 6); // Panic expected",
                "}"
              ],
              "oracle": [
                "    panic_advance(&TryGetError { requested: 6, available: 5 });",
                "    ",
                "    assert_eq!(buf.position, 5);",
                "    ",
                "    assert_eq!(buf.data, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: [u8; 10],",
                "        position: usize,",
                "    }",
                "    ",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            UninitSlice::new(&mut self.data[self.position..])",
                "        }",
                "",
                "        fn put_u8(&mut self, _n: u8) {}",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: [0; 10], position: 5 };",
                "    buf.put_bytes(b'b', 6); // Panic expected",
                "    panic_advance(&TryGetError { requested: 6, available: 5 });",
                "    ",
                "    assert_eq!(buf.position, 5);",
                "    ",
                "    assert_eq!(buf.data, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: [u8; 15],",
                "        position: usize,",
                "    }",
                "    ",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            UninitSlice::new(&mut self.data[self.position..])",
                "        }",
                "",
                "        fn put_u8(&mut self, _n: u8) {}",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: [0; 15], position: 10 };",
                "    buf.put_bytes(b'c', 6); // Panic expected",
                "}"
              ],
              "oracle": [
                "    assert_panics!(|| buf.put_bytes(b'c', 6));",
                "    assert_eq!(buf.position, 10);",
                "    assert_eq!(buf.data, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);",
                "    assert_eq!(buf.remaining_mut(), 5);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: [u8; 15],",
                "        position: usize,",
                "    }",
                "    ",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.data.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            UninitSlice::new(&mut self.data[self.position..])",
                "        }",
                "",
                "        fn put_u8(&mut self, _n: u8) {}",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: [0; 15], position: 10 };",
                "    buf.put_bytes(b'c', 6); // Panic expected",
                "    assert_panics!(|| buf.put_bytes(b'c', 6));",
                "    assert_eq!(buf.position, 10);",
                "    assert_eq!(buf.data, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);",
                "    assert_eq!(buf.remaining_mut(), 5);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.remaining_mut() < cnt at line 293 is false, with bound self.remaining_mut() == cnt\n",
        "precondition: cnt > 0 at line 300 is true\n",
        "precondition: cnt > 0 at line 300 is false, with bound cnt == 0\n"
      ],
      "input_infer": "self.remaining_mut() = cnt, cnt > 0; self.remaining_mut() = 1, cnt = 1; self.remaining_mut() = 2, cnt = 2; self.remaining_mut() = 3, cnt = 3; self.remaining_mut() = 4, cnt = 4; self.remaining_mut() = 6, cnt = 0; self.remaining_mut() = 0, cnt = 1 (to test panic case), 0 < cnt <= 6.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf = [0; 4];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 4);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf, [b'a', b'a', b'a', b'a']);",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    slice.put_bytes(b'b', 0);",
                "    assert_eq!(buf, [b'a', b'a', b'a', b'a']);",
                "    assert_panics!(slice.put_bytes(b'a', 1));",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    assert_panics!(slice.put_bytes(b'a', 5));"
              ],
              "code": [
                "{",
                "    let mut buf = [0; 4];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 4);",
                "    }",
                "    assert_eq!(buf, [b'a', b'a', b'a', b'a']);",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    slice.put_bytes(b'b', 0);",
                "    assert_eq!(buf, [b'a', b'a', b'a', b'a']);",
                "    assert_panics!(slice.put_bytes(b'a', 1));",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    assert_panics!(slice.put_bytes(b'a', 5));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf = [0; 1];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 1);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf[0], b'a');",
                "    assert_eq!(buf[1], 0);",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    assert!(panic_caught);  // used for testing panic when self.remaining_mut() < cnt",
                "    slice.put_bytes(b'a', 2);  // This line triggers panic",
                "    assert!(slice.remaining_mut() >= 1);   // after put_bytes for 1 byte",
                "    assert!(slice.remaining_mut() == 0);   // after fully using the buffer",
                "    slice.put_bytes(b'a', 0);  // Should not panic with 0 count"
              ],
              "code": [
                "{",
                "    let mut buf = [0; 1];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 1);",
                "    }",
                "    assert_eq!(buf[0], b'a');",
                "    assert_eq!(buf[1], 0);",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    assert!(panic_caught);  // used for testing panic when self.remaining_mut() < cnt",
                "    slice.put_bytes(b'a', 2);  // This line triggers panic",
                "    assert!(slice.remaining_mut() >= 1);   // after put_bytes for 1 byte",
                "    assert!(slice.remaining_mut() == 0);   // after fully using the buffer",
                "    slice.put_bytes(b'a', 0);  // Should not panic with 0 count",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf = [0; 2];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 2);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(0, buf.remaining_mut());",
                "    assert_eq!(b\"aa\", &buf);",
                "    let mut buf_empty = [0; 2];",
                "    let mut slice_empty = &mut buf_empty[..];",
                "    slice_empty.put_bytes(b'a', 2);",
                "    assert_eq!(0, slice_empty.remaining_mut());",
                "    assert_eq!(b\"aa\", &buf_empty);"
              ],
              "code": [
                "{",
                "    let mut buf = [0; 2];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 2);",
                "    }",
                "    assert_eq!(0, buf.remaining_mut());",
                "    assert_eq!(b\"aa\", &buf);",
                "    let mut buf_empty = [0; 2];",
                "    let mut slice_empty = &mut buf_empty[..];",
                "    slice_empty.put_bytes(b'a', 2);",
                "    assert_eq!(0, slice_empty.remaining_mut());",
                "    assert_eq!(b\"aa\", &buf_empty);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf = [0; 3];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 3);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf, [b'a', b'a', b'a']);",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    assert!(std::panic::catch_unwind(|| slice.put_bytes(b'a', 1)).is_err());"
              ],
              "code": [
                "{",
                "    let mut buf = [0; 3];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 3);",
                "    }",
                "    assert_eq!(buf, [b'a', b'a', b'a']);",
                "    assert_eq!(slice.remaining_mut(), 0);",
                "    assert!(std::panic::catch_unwind(|| slice.put_bytes(b'a', 1)).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buf = [0; 6];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 0);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf, [0, 0, 0, 0, 0, 0]);",
                "    assert_eq!(slice.remaining_mut(), 6);",
                "    assert_eq!(slice.len(), 6);",
                "    assert_eq!(slice.chunk_mut().len(), 6);",
                "    assert!(slice.has_remaining_mut());"
              ],
              "code": [
                "{",
                "    let mut buf = [0; 6];",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 0);",
                "    }",
                "    assert_eq!(buf, [0, 0, 0, 0, 0, 0]);",
                "    assert_eq!(slice.remaining_mut(), 6);",
                "    assert_eq!(slice.len(), 6);",
                "    assert_eq!(slice.chunk_mut().len(), 6);",
                "    assert!(slice.has_remaining_mut());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut buf = [0; 0]; // remaining_mut() = 0",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 1); // panic case, cnt = 1",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining_mut(), 0); // Verify remaining capacity is 0 before operation",
                "    assert!(std::panic::catch_unwind(|| slice.put_bytes(b'a', 1)).is_err()); // Ensure panic occurs for insufficient capacity",
                "    buf[0] == 0; // Ensure buffer remains unchanged after panic"
              ],
              "code": [
                "{",
                "    let mut buf = [0; 0]; // remaining_mut() = 0",
                "    {",
                "        let mut slice = &mut buf[..];",
                "        slice.put_bytes(b'a', 1); // panic case, cnt = 1",
                "    }",
                "    assert_eq!(buf.remaining_mut(), 0); // Verify remaining capacity is 0 before operation",
                "    assert!(std::panic::catch_unwind(|| slice.put_bytes(b'a', 1)).is_err()); // Ensure panic occurs for insufficient capacity",
                "    buf[0] == 0; // Ensure buffer remains unchanged after panic",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: self.remaining_mut() < cnt at line 293 is false, with bound self.remaining_mut() == cnt\n",
        "precondition: cnt > 0 at line 300 is false, with bound cnt == 0\n"
      ],
      "input_infer": "self.remaining_mut() values: 0, 1, 2, 3, 4, 5, 6; cnt values: 0, 1, 2, 3, 4, 5, 6 (where cnt <= self.remaining_mut())\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dst = [0; 6];",
                "    {",
                "        let mut buf = &mut dst[..];",
                "        buf.put_bytes(b'a', 6);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(0, buf.remaining_mut());",
                "    assert_eq!(b\"aaaaaa\", &dst);",
                "    assert!(match panic::catch_unwind(|| buf.put_bytes(b'a', 1)) { Err(_) => true, _ => false });",
                "    assert!(match panic::catch_unwind(|| buf.put_bytes(b'a', 7)) { Err(_) => true, _ => false });",
                "    assert_eq!(0, buf.remaining_mut());",
                "    buf.put_bytes(b'b', 0);",
                "    assert_eq!(0, buf.remaining_mut());",
                "    assert_eq!(b\"aaaaaa\", &dst);"
              ],
              "code": [
                "{",
                "    let mut dst = [0; 6];",
                "    {",
                "        let mut buf = &mut dst[..];",
                "        buf.put_bytes(b'a', 6);",
                "    }",
                "    assert_eq!(0, buf.remaining_mut());",
                "    assert_eq!(b\"aaaaaa\", &dst);",
                "    assert!(match panic::catch_unwind(|| buf.put_bytes(b'a', 1)) { Err(_) => true, _ => false });",
                "    assert!(match panic::catch_unwind(|| buf.put_bytes(b'a', 7)) { Err(_) => true, _ => false });",
                "    assert_eq!(0, buf.remaining_mut());",
                "    buf.put_bytes(b'b', 0);",
                "    assert_eq!(0, buf.remaining_mut());",
                "    assert_eq!(b\"aaaaaa\", &dst);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut dst = [0; 6];",
                "    {",
                "        let mut buf = &mut dst[..];",
                "        buf.put_bytes(b'a', 7);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert!(std::panic::catch_unwind(|| {",
                "    let mut dst = [0; 6];",
                "    let mut buf = &mut dst[..];",
                "    buf.put_bytes(b'a', 7);",
                "    }).is_err());",
                "    ",
                "    let mut dst = [0; 6];",
                "    let mut buf = &mut dst[..];",
                "    buf.put_bytes(b'a', 6);",
                "    assert_eq!(b\"aaaaaa\", &dst);",
                "    ",
                "    let mut dst = [0; 6];",
                "    let mut buf = &mut dst[..];",
                "    buf.put_bytes(b'a', 0);",
                "    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);"
              ],
              "code": [
                "{",
                "    let mut dst = [0; 6];",
                "    {",
                "        let mut buf = &mut dst[..];",
                "        buf.put_bytes(b'a', 7);",
                "    }",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let mut dst = [0; 6];",
                "    let mut buf = &mut dst[..];",
                "    buf.put_bytes(b'a', 7);",
                "    }).is_err());",
                "    ",
                "    let mut dst = [0; 6];",
                "    let mut buf = &mut dst[..];",
                "    buf.put_bytes(b'a', 6);",
                "    assert_eq!(b\"aaaaaa\", &dst);",
                "    ",
                "    let mut dst = [0; 6];",
                "    let mut buf = &mut dst[..];",
                "    buf.put_bytes(b'a', 0);",
                "    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dst = [0; 6];",
                "    {",
                "        let mut buf = &mut dst[..];",
                "        buf.put_bytes(b'a', 0);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);",
                "    assert_eq!(2, buf.remaining_mut());",
                "    assert!(panic_advance_called);",
                "    assert!(self.remaining_mut() >= cnt);",
                "    assert!(cnt == 0);"
              ],
              "code": [
                "{",
                "    let mut dst = [0; 6];",
                "    {",
                "        let mut buf = &mut dst[..];",
                "        buf.put_bytes(b'a', 0);",
                "    }",
                "    assert_eq!(b\"\\0\\0\\0\\0\\0\\0\", &dst);",
                "    assert_eq!(2, buf.remaining_mut());",
                "    assert!(panic_advance_called);",
                "    assert!(self.remaining_mut() >= cnt);",
                "    assert!(cnt == 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}