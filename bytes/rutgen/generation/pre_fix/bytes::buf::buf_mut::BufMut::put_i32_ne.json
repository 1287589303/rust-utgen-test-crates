{
  "name": "bytes::buf::buf_mut::BufMut::put_i32_ne",
  "mod_info": {
    "name": "buf::buf_mut",
    "loc": "src/buf/mod.rs:18:1:18:13"
  },
  "visible": true,
  "loc": "src/buf/buf_mut.rs:647:5:649:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "1 <= remaining_mut <= 4; n in [-2147483648, 2147483647]; remaining_mut >= 4 to avoid panic\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            // Safety: Assuming size is as expected.",
                "            unsafe { &mut *(self.buffer[self.position..self.position + len].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            // Implementing as in the provided context.",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let mut remaining = src;",
                "            while !remaining.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(remaining.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&remaining[..cnt]);",
                "                remaining = &remaining[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "",
                "        fn put_i32_ne(&mut self, n: i32) {",
                "            self.put_slice(&n.to_ne_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(0x0809A0A1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0x08, 0x09, 0xA0, 0xA1] } else { vec![0xA1, 0xA0, 0x09, 0x08] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(0x00000000);",
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0x00, 0x00, 0x00, 0x00] } else { vec![0x00, 0x00, 0x00, 0x00] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(-1);",
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0xFF, 0xFF, 0xFF, 0xFF] } else { vec![0xFF, 0xFF, 0xFF, 0xFF] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(0x7FFFFFFF);",
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0x7F, 0xFF, 0xFF, 0xFF] } else { vec![0xFF, 0xFF, 0xFF, 0x7F] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i32_ne(1);",
                "    buf.put_slice(&[0; 5]);",
                "    });",
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            // Safety: Assuming size is as expected.",
                "            unsafe { &mut *(self.buffer[self.position..self.position + len].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            // Implementing as in the provided context.",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let mut remaining = src;",
                "            while !remaining.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(remaining.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&remaining[..cnt]);",
                "                remaining = &remaining[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "",
                "        fn put_i32_ne(&mut self, n: i32) {",
                "            self.put_slice(&n.to_ne_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(0x0809A0A1);",
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0x08, 0x09, 0xA0, 0xA1] } else { vec![0xA1, 0xA0, 0x09, 0x08] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(0x00000000);",
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0x00, 0x00, 0x00, 0x00] } else { vec![0x00, 0x00, 0x00, 0x00] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(-1);",
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0xFF, 0xFF, 0xFF, 0xFF] } else { vec![0xFF, 0xFF, 0xFF, 0xFF] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(0x7FFFFFFF);",
                "    assert_eq!(buf.buffer, if cfg!(target_endian = \"big\") { vec![0x7F, 0xFF, 0xFF, 0xFF] } else { vec![0xFF, 0xFF, 0xFF, 0x7F] });",
                "    ",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    let result = std::panic::catch_unwind(|| {",
                "    buf.put_i32_ne(1);",
                "    buf.put_slice(&[0; 5]);",
                "    });",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            // Safety: Assuming size is as expected.",
                "            unsafe { &mut *(self.buffer[self.position..self.position + len].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let mut remaining = src;",
                "            while !remaining.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(remaining.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&remaining[..cnt]);",
                "                remaining = &remaining[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "",
                "        fn put_i32_ne(&mut self, n: i32) {",
                "            self.put_slice(&n.to_ne_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(-2147483648);",
                "    ",
                "    let mut buf_max = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf_max.put_i32_ne(2147483647);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.buffer, b\"\\x80\\x00\\x00\\x00\");",
                "    assert_eq!(buf_max.buffer, b\"\\x7F\\xFF\\xFF\\xFF\");",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let mut buf_Insufficient = TestBuf { buffer: vec![0; 2], position: 0 };",
                "    buf_Insufficient.put_i32_ne(-1);",
                "    }).is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            // Safety: Assuming size is as expected.",
                "            unsafe { &mut *(self.buffer[self.position..self.position + len].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let mut remaining = src;",
                "            while !remaining.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(remaining.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&remaining[..cnt]);",
                "                remaining = &remaining[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "",
                "        fn put_i32_ne(&mut self, n: i32) {",
                "            self.put_slice(&n.to_ne_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf.put_i32_ne(-2147483648);",
                "    ",
                "    let mut buf_max = TestBuf { buffer: vec![0; 4], position: 0 };",
                "    buf_max.put_i32_ne(2147483647);",
                "    assert_eq!(buf.buffer, b\"\\x80\\x00\\x00\\x00\");",
                "    assert_eq!(buf_max.buffer, b\"\\x7F\\xFF\\xFF\\xFF\");",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let mut buf_Insufficient = TestBuf { buffer: vec![0; 2], position: 0 };",
                "    buf_Insufficient.put_i32_ne(-1);",
                "    }).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.buffer[self.position..self.position + len].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let mut remaining = src;",
                "            while !remaining.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(remaining.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&remaining[..cnt]);",
                "                remaining = &remaining[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "",
                "        fn put_i32_ne(&mut self, n: i32) {",
                "            self.put_slice(&n.to_ne_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { buffer: vec![0; 2], position: 0 }; // Insufficient capacity",
                "    buf.put_i32_ne(0x0809A0A1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining_mut(), 2);",
                "    assert!(!buf.has_remaining_mut());",
                "    panic_does_not_fit(&TryGetError { requested: 4, available: 2 });",
                "    assert_eq!(buf.position, 0);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        buffer: Vec<u8>,",
                "        position: usize,",
                "    }",
                "",
                "    unsafe impl BufMut for TestBuf {",
                "        fn remaining_mut(&self) -> usize {",
                "            self.buffer.len() - self.position",
                "        }",
                "        ",
                "        unsafe fn advance_mut(&mut self, cnt: usize) {",
                "            self.position += cnt;",
                "        }",
                "",
                "        fn has_remaining_mut(&self) -> bool {",
                "            self.remaining_mut() > 0",
                "        }",
                "",
                "        fn chunk_mut(&mut self) -> &mut UninitSlice {",
                "            let len = self.remaining_mut();",
                "            unsafe { &mut *(self.buffer[self.position..self.position + len].as_mut_ptr() as *mut UninitSlice) }",
                "        }",
                "",
                "        fn put_slice(&mut self, src: &[u8]) {",
                "            if self.remaining_mut() < src.len() {",
                "                panic_advance(&TryGetError {",
                "                    requested: src.len(),",
                "                    available: self.remaining_mut(),",
                "                });",
                "            }",
                "            let mut remaining = src;",
                "            while !remaining.is_empty() {",
                "                let dst = self.chunk_mut();",
                "                let cnt = usize::min(remaining.len(), dst.len());",
                "                dst[..cnt].copy_from_slice(&remaining[..cnt]);",
                "                remaining = &remaining[cnt..];",
                "                unsafe { self.advance_mut(cnt) };",
                "            }",
                "        }",
                "",
                "        fn put_i32_ne(&mut self, n: i32) {",
                "            self.put_slice(&n.to_ne_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { buffer: vec![0; 2], position: 0 }; // Insufficient capacity",
                "    buf.put_i32_ne(0x0809A0A1);",
                "    assert_eq!(buf.remaining_mut(), 2);",
                "    assert!(!buf.has_remaining_mut());",
                "    panic_does_not_fit(&TryGetError { requested: 4, available: 2 });",
                "    assert_eq!(buf.position, 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}