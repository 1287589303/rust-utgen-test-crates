{
  "name": "bytes::bytes_mut::{impl#0}::set_vec_pos",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": false,
  "loc": "src/bytes_mut.rs:1076:5:1081:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: (*left_val == *right_val) at line 40 is true\n",
        "precondition: pos <= MAX_VEC_POS at line 1078 is true, with bound pos == MAX_VEC_POS\n"
      ],
      "input_infer": "pos must be in the range [0, MAX_VEC_POS] and kind must equal KIND_VEC\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockBytesMut {",
                "        data: *mut Shared,",
                "        kind: usize,",
                "    }",
                "",
                "    impl MockBytesMut {",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind, KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    let mut mock = MockBytesMut {",
                "        data: core::ptr::null_mut(),",
                "        kind: KIND_VEC,",
                "    };",
                "",
                "    let pos = MAX_VEC_POS;",
                "    unsafe {",
                "        mock.set_vec_pos(pos);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(mock.data, invalid_ptr((MAX_VEC_POS << VEC_POS_OFFSET) | (core::ptr::null_mut() as usize & NOT_VEC_POS_MASK)));",
                "    assert!(mock.kind == KIND_VEC);",
                "    assert!(pos <= MAX_VEC_POS);",
                "    debug_assert!(mock.data != core::ptr::null_mut());",
                "    debug_assert_eq!(mock.kind, KIND_VEC);"
              ],
              "code": [
                "{",
                "    struct MockBytesMut {",
                "        data: *mut Shared,",
                "        kind: usize,",
                "    }",
                "",
                "    impl MockBytesMut {",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind, KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    let mut mock = MockBytesMut {",
                "        data: core::ptr::null_mut(),",
                "        kind: KIND_VEC,",
                "    };",
                "",
                "    let pos = MAX_VEC_POS;",
                "    unsafe {",
                "        mock.set_vec_pos(pos);",
                "    }",
                "    assert_eq!(mock.data, invalid_ptr((MAX_VEC_POS << VEC_POS_OFFSET) | (core::ptr::null_mut() as usize & NOT_VEC_POS_MASK)));",
                "    assert!(mock.kind == KIND_VEC);",
                "    assert!(pos <= MAX_VEC_POS);",
                "    debug_assert!(mock.data != core::ptr::null_mut());",
                "    debug_assert_eq!(mock.kind, KIND_VEC);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct MockBytesMut {",
                "        data: *mut Shared,",
                "        kind: usize,",
                "    }",
                "",
                "    impl MockBytesMut {",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind, KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    let mut mock = MockBytesMut {",
                "        data: core::ptr::null_mut(),",
                "        kind: KIND_VEC,",
                "    };",
                "",
                "    let pos = MAX_VEC_POS + 1; // Exceeds the maximum valid position",
                "    unsafe {",
                "        mock.set_vec_pos(pos);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(mock.kind, KIND_VEC);",
                "    assert!(pos <= MAX_VEC_POS);"
              ],
              "code": [
                "{",
                "    struct MockBytesMut {",
                "        data: *mut Shared,",
                "        kind: usize,",
                "    }",
                "",
                "    impl MockBytesMut {",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind, KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    let mut mock = MockBytesMut {",
                "        data: core::ptr::null_mut(),",
                "        kind: KIND_VEC,",
                "    };",
                "",
                "    let pos = MAX_VEC_POS + 1; // Exceeds the maximum valid position",
                "    unsafe {",
                "        mock.set_vec_pos(pos);",
                "    }",
                "    assert_eq!(mock.kind, KIND_VEC);",
                "    assert!(pos <= MAX_VEC_POS);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: (*left_val == *right_val) at line 40 is true\n",
        "precondition: pos <= MAX_VEC_POS at line 1078 is false\n"
      ],
      "input_infer": "pos > MAX_VEC_POS, and valid self object with kind() returning KIND_VEC\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    // Create a valid BytesMut object",
                "    let mut bytes_mut = BytesMut::with_capacity(32);",
                "    // Assume we have some way to set the kind to KIND_VEC (simply for the purpose of this test)",
                "    unsafe {",
                "        bytes_mut.data = ptr::null_mut(); // Placeholder, should be set to valid pointer",
                "        bytes_mut.set_vec_pos(usize::MAX >> 5 + 1); // Set pos to exceed MAX_VEC_POS",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(usize::MAX >> 5 + 1 > MAX_VEC_POS);",
                "    assert!(std::panic::catch_unwind(|| { bytes_mut.set_vec_pos(usize::MAX >> 5 + 1); }).is_err());",
                "    assert!(bytes_mut.data.is_null());"
              ],
              "code": [
                "{",
                "    // Create a valid BytesMut object",
                "    let mut bytes_mut = BytesMut::with_capacity(32);",
                "    // Assume we have some way to set the kind to KIND_VEC (simply for the purpose of this test)",
                "    unsafe {",
                "        bytes_mut.data = ptr::null_mut(); // Placeholder, should be set to valid pointer",
                "        bytes_mut.set_vec_pos(usize::MAX >> 5 + 1); // Set pos to exceed MAX_VEC_POS",
                "    }",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(usize::MAX >> 5 + 1 > MAX_VEC_POS);",
                "    assert!(std::panic::catch_unwind(|| { bytes_mut.set_vec_pos(usize::MAX >> 5 + 1); }).is_err());",
                "    assert!(bytes_mut.data.is_null());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    // Create a valid BytesMut object",
                "    let mut bytes_mut = BytesMut::with_capacity(32);",
                "    // Assume we have some way to set the kind to KIND_VEC (simply for the purpose of this test)",
                "    unsafe {",
                "        bytes_mut.data = ptr::null_mut(); // Placeholder, should be set to valid pointer",
                "        bytes_mut.set_vec_pos((usize::MAX >> 5) + 1); // Test just above MAX_VEC_POS",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(usize::MAX >> 5 > MAX_VEC_POS);",
                "    assert!(bytes_mut.data.is_null());",
                "    assert!(bytes_mut.data as usize > NOT_VEC_POS_MASK);"
              ],
              "code": [
                "{",
                "    // Create a valid BytesMut object",
                "    let mut bytes_mut = BytesMut::with_capacity(32);",
                "    // Assume we have some way to set the kind to KIND_VEC (simply for the purpose of this test)",
                "    unsafe {",
                "        bytes_mut.data = ptr::null_mut(); // Placeholder, should be set to valid pointer",
                "        bytes_mut.set_vec_pos((usize::MAX >> 5) + 1); // Test just above MAX_VEC_POS",
                "    }",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(usize::MAX >> 5 > MAX_VEC_POS);",
                "    assert!(bytes_mut.data.is_null());",
                "    assert!(bytes_mut.data as usize > NOT_VEC_POS_MASK);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: (*left_val == *right_val) at line 40 is false\n"
      ],
      "input_infer": "pos: 0 to MAX_VEC_POS and pos: 0 - 1 for boundary check\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    unsafe { bytes_mut.set_vec_pos(0); }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(unsafe { core::ptr::addr_of_mut!(bytes_mut.data).read() } & NOT_VEC_POS_MASK == 0);",
                "    assert!(bytes_mut.data != core::ptr::null_mut());",
                "    assert!(unsafe { bytes_mut.data } as usize <= MAX_VEC_POS);"
              ],
              "code": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    unsafe { bytes_mut.set_vec_pos(0); }",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(unsafe { core::ptr::addr_of_mut!(bytes_mut.data).read() } & NOT_VEC_POS_MASK == 0);",
                "    assert!(bytes_mut.data != core::ptr::null_mut());",
                "    assert!(unsafe { bytes_mut.data } as usize <= MAX_VEC_POS);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    unsafe { bytes_mut.set_vec_pos(MAX_VEC_POS); }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(bytes_mut.data as usize & NOT_VEC_POS_MASK == 0);",
                "    assert_eq!(bytes_mut.data as usize, (MAX_VEC_POS << VEC_POS_OFFSET) | (bytes_mut.data as usize & NOT_VEC_POS_MASK));"
              ],
              "code": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    unsafe { bytes_mut.set_vec_pos(MAX_VEC_POS); }",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(bytes_mut.data as usize & NOT_VEC_POS_MASK == 0);",
                "    assert_eq!(bytes_mut.data as usize, (MAX_VEC_POS << VEC_POS_OFFSET) | (bytes_mut.data as usize & NOT_VEC_POS_MASK));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    unsafe { bytes_mut.set_vec_pos(MAX_VEC_POS + 1); }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(pos > MAX_VEC_POS);"
              ],
              "code": [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    unsafe { bytes_mut.set_vec_pos(MAX_VEC_POS + 1); }",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "    assert!(pos > MAX_VEC_POS);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}