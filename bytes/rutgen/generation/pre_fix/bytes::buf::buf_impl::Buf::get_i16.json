{
  "name": "bytes::buf::buf_impl::Buf::get_i16",
  "mod_info": {
    "name": "buf::buf_impl",
    "loc": "src/buf/mod.rs:17:1:17:14"
  },
  "visible": true,
  "loc": "src/buf/buf_impl.rs:434:5:436:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "- The buffer must have at least 2 bytes available; valid test input ranges for the input buffer are from 2 bytes up to any size (e.g., 2 to N bytes); expected return values are signed 16-bit integers within the range of -32,768 to 32,767; test should include edge cases of exactly 2 bytes, large buffers, and buffers with non-integer values.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: &b\"\\x08\\x09 hello\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 0x0809);",
                "    let mut buf2 = TestBuf { data: &b\"\\x01\\x02 more data\"[..], pos: 0 };",
                "    let result2 = buf2.get_i16();",
                "    assert_eq!(result2, 0x0102);",
                "    let mut buf3 = TestBuf { data: &b\"\\xFF\\xFE trailing bytes\"[..], pos: 0 };",
                "    let result3 = buf3.get_i16();",
                "    assert_eq!(result3, -2);",
                "    let mut buf4 = TestBuf { data: &b\"\\x08\"[..], pos: 0 };",
                "    let result4 = std::panic::catch_unwind(|| { buf4.get_i16(); });",
                "    assert!(result4.is_err());",
                "    let mut buf5 = TestBuf { data: &b\"\"[..], pos: 0 };",
                "    let result5 = std::panic::catch_unwind(|| { buf5.get_i16(); });",
                "    assert!(result5.is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "    ",
                "    let mut buf = TestBuf { data: &b\"\\x08\\x09 hello\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "    assert_eq!(result, 0x0809);",
                "    let mut buf2 = TestBuf { data: &b\"\\x01\\x02 more data\"[..], pos: 0 };",
                "    let result2 = buf2.get_i16();",
                "    assert_eq!(result2, 0x0102);",
                "    let mut buf3 = TestBuf { data: &b\"\\xFF\\xFE trailing bytes\"[..], pos: 0 };",
                "    let result3 = buf3.get_i16();",
                "    assert_eq!(result3, -2);",
                "    let mut buf4 = TestBuf { data: &b\"\\x08\"[..], pos: 0 };",
                "    let result4 = std::panic::catch_unwind(|| { buf4.get_i16(); });",
                "    assert!(result4.is_err());",
                "    let mut buf5 = TestBuf { data: &b\"\"[..], pos: 0 };",
                "    let result5 = std::panic::catch_unwind(|| { buf5.get_i16(); });",
                "    assert!(result5.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: &b\"\\x00\\x01\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "    ",
                "    let mut buf_neg = TestBuf { data: &b\"\\x80\\x00\"[..], pos: 0 };",
                "    let result_neg = buf_neg.get_i16();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 1);",
                "    assert_eq!(result_neg, -32768);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: &b\"\\x00\\x01\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "    ",
                "    let mut buf_neg = TestBuf { data: &b\"\\x80\\x00\"[..], pos: 0 };",
                "    let result_neg = buf_neg.get_i16();",
                "    assert_eq!(result, 1);",
                "    assert_eq!(result_neg, -32768);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: &b\"\\x12\\x34 more data than needed\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 0x1234);",
                "    assert_eq!(buf.remaining(), 16);",
                "    assert_eq!(buf.chunk(), &b\"\\x34 more data than needed\"[..]);",
                "    buf.advance(2);",
                "    assert_eq!(buf.remaining(), 14);",
                "    buf.advance(2);",
                "    assert_eq!(buf.chunk(), &b\" more data than needed\"[..]);"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: &b\"\\x12\\x34 more data than needed\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "    assert_eq!(result, 0x1234);",
                "    assert_eq!(buf.remaining(), 16);",
                "    assert_eq!(buf.chunk(), &b\"\\x34 more data than needed\"[..]);",
                "    buf.advance(2);",
                "    assert_eq!(buf.remaining(), 14);",
                "    buf.advance(2);",
                "    assert_eq!(buf.chunk(), &b\" more data than needed\"[..]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            if self.remaining() < 2 {",
                "                panic!(\"not enough data\");",
                "            }",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: &b\"\\x01\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buf.remaining(), 1);",
                "    assert!(std::panic::catch_unwind(|| buf.get_i16()).is_err());",
                "    buf.advance(2);",
                "    assert_eq!(buf.chunk(), b\"\");",
                "    let mut buf = TestBuf { data: &b\"\\x01\\x02\\x03\\x04\"[..], pos: 0 };",
                "    assert_eq!(buf.get_i16(), 0x0102);",
                "    assert_eq!(buf.remaining(), 2);",
                "    assert_eq!(buf.get_i16(), 0x0304);",
                "    assert_eq!(buf.remaining(), 0);",
                "    assert!(std::panic::catch_unwind(|| buf.get_i16()).is_err());"
              ],
              "code": [
                "{",
                "    struct TestBuf {",
                "        data: &'static [u8],",
                "        pos: usize,",
                "    }",
                "    ",
                "    impl TestBuf {",
                "        fn remaining(&self) -> usize {",
                "            self.data.len() - self.pos",
                "        }",
                "        ",
                "        fn chunk(&self) -> &[u8] {",
                "            &self.data[self.pos..]",
                "        }",
                "        ",
                "        fn advance(&mut self, cnt: usize) {",
                "            self.pos += cnt;",
                "        }",
                "        ",
                "        fn get_i16(&mut self) -> i16 {",
                "            if self.remaining() < 2 {",
                "                panic!(\"not enough data\");",
                "            }",
                "            let bytes = [self.chunk()[0], self.chunk()[1]];",
                "            self.advance(2);",
                "            i16::from_be_bytes(bytes)",
                "        }",
                "    }",
                "",
                "    let mut buf = TestBuf { data: &b\"\\x01\"[..], pos: 0 };",
                "    let result = buf.get_i16();",
                "    assert_eq!(buf.remaining(), 1);",
                "    assert!(std::panic::catch_unwind(|| buf.get_i16()).is_err());",
                "    buf.advance(2);",
                "    assert_eq!(buf.chunk(), b\"\");",
                "    let mut buf = TestBuf { data: &b\"\\x01\\x02\\x03\\x04\"[..], pos: 0 };",
                "    assert_eq!(buf.get_i16(), 0x0102);",
                "    assert_eq!(buf.remaining(), 2);",
                "    assert_eq!(buf.get_i16(), 0x0304);",
                "    assert_eq!(buf.remaining(), 0);",
                "    assert!(std::panic::catch_unwind(|| buf.get_i16()).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}