{
  "name": "bytes::bytes::_split_to_must_use",
  "mod_info": {
    "name": "bytes",
    "loc": "src/lib.rs:82:1:82:11"
  },
  "visible": false,
  "loc": "src/bytes.rs:1637:1:1637:27",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Input string length: 0 to 11 characters; Input range for split: 0 to 11 (inclusive)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut b1 = Bytes::from(\"\");",
                "    _split_to_must_use();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());",
                "    assert_eq!(b1.split_to(0), Bytes::from(\"\"));",
                "    assert_eq!(b1.split_to(6), Bytes::from(\"hello \")); // Expecting an error on split_to as it should not execute due to compile_fail directive.",
                "    assert_eq!(b1.split_to(5).len(), 5);",
                "    assert_eq!(b1.split_to(0).len(), 0);"
              ],
              "code": [
                "{",
                "    let mut b1 = Bytes::from(\"\");",
                "    _split_to_must_use();",
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());",
                "    assert_eq!(b1.split_to(0), Bytes::from(\"\"));",
                "    assert_eq!(b1.split_to(6), Bytes::from(\"hello \")); // Expecting an error on split_to as it should not execute due to compile_fail directive.",
                "    assert_eq!(b1.split_to(5).len(), 5);",
                "    assert_eq!(b1.split_to(0).len(), 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(11);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b1.len(), 0);",
                "    assert_eq!(b1.split_to(6).len(), 5);",
                "    assert_eq!(b1.split_to(6).as_ref(), \"hello\");",
                "    assert!(b1.split_to(0).is_empty());",
                "    assert_eq!(b1.split_to(5).as_ref(), \"hello\");",
                "    assert_eq!(b1.split_to(6).len(), 5);",
                "    assert_eq!(b1.split_to(11).len(), 0);",
                "    assert!(b1.split_to(11).is_empty());"
              ],
              "code": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(11);",
                "    assert_eq!(b1.len(), 0);",
                "    assert_eq!(b1.split_to(6).len(), 5);",
                "    assert_eq!(b1.split_to(6).as_ref(), \"hello\");",
                "    assert!(b1.split_to(0).is_empty());",
                "    assert_eq!(b1.split_to(5).as_ref(), \"hello\");",
                "    assert_eq!(b1.split_to(6).len(), 5);",
                "    assert_eq!(b1.split_to(11).len(), 0);",
                "    assert!(b1.split_to(11).is_empty());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut b1 = Bytes::from(\"hello\");",
                "    b1.split_to(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b1, Bytes::from(\"hello\"));",
                "    assert_eq!(b1.len(), 5);",
                "    assert_eq!(b1.split_to(0), Bytes::from(\"\"));",
                "    assert_eq!(b1.len(), 5);",
                "    assert_eq!(b1.split_to(5), Bytes::from(\"hello\"));",
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());",
                "    assert_eq!(b1.split_to(3), Bytes::from(\"hel\"));",
                "    assert_eq!(b1.len(), 2);",
                "    assert_eq!(b1.split_to(2), Bytes::from(\"he\"));",
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());"
              ],
              "code": [
                "{",
                "    let mut b1 = Bytes::from(\"hello\");",
                "    b1.split_to(0);",
                "    assert_eq!(b1, Bytes::from(\"hello\"));",
                "    assert_eq!(b1.len(), 5);",
                "    assert_eq!(b1.split_to(0), Bytes::from(\"\"));",
                "    assert_eq!(b1.len(), 5);",
                "    assert_eq!(b1.split_to(5), Bytes::from(\"hello\"));",
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());",
                "    assert_eq!(b1.split_to(3), Bytes::from(\"hel\"));",
                "    assert_eq!(b1.len(), 2);",
                "    assert_eq!(b1.split_to(2), Bytes::from(\"he\"));",
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut b1 = Bytes::from(\"hello\");",
                "    b1.split_to(1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b1.len(), 4);",
                "    assert_eq!(b1, Bytes::from(\"ello\"));",
                "    assert_eq!(b1.split_to(2).len(), 2);",
                "    assert_eq!(b1, Bytes::from(\"lo\"));",
                "    assert_eq!(b1.split_to(0).len(), 0);",
                "    assert_eq!(b1, Bytes::from(\"lo\"));",
                "    assert_eq!(b1.split_to(4).len(), 0);"
              ],
              "code": [
                "{",
                "    let mut b1 = Bytes::from(\"hello\");",
                "    b1.split_to(1);",
                "    assert_eq!(b1.len(), 4);",
                "    assert_eq!(b1, Bytes::from(\"ello\"));",
                "    assert_eq!(b1.split_to(2).len(), 2);",
                "    assert_eq!(b1, Bytes::from(\"lo\"));",
                "    assert_eq!(b1.split_to(0).len(), 0);",
                "    assert_eq!(b1, Bytes::from(\"lo\"));",
                "    assert_eq!(b1.split_to(4).len(), 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(10);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b1.len(), 11);",
                "    assert_eq!(b1.split_to(10).len(), 10);",
                "    assert_eq!(b1.split_to(10).to_vec(), b\"hello world\"[..10]);",
                "    assert!(b1.split_to(0).is_empty());",
                "    assert_eq!(b1.split_to(11).len(), 11);",
                "    assert!(b1.split_to(6).len() < b1.len());"
              ],
              "code": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(10);",
                "    assert_eq!(b1.len(), 11);",
                "    assert_eq!(b1.split_to(10).len(), 10);",
                "    assert_eq!(b1.split_to(10).to_vec(), b\"hello world\"[..10]);",
                "    assert!(b1.split_to(0).is_empty());",
                "    assert_eq!(b1.split_to(11).len(), 11);",
                "    assert!(b1.split_to(6).len() < b1.len());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(9);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b1.len(), 2); // Expecting the length of remaining Bytes after split_to(9) to be 2",
                "    assert_eq!(b1, Bytes::from(\"rld\")); // Expecting the remaining Bytes to equal \"rld\" after split_to(9)",
                "    let b2 = b1.split_to(2); // Splitting again to create b2",
                "    assert_eq!(b2, Bytes::from(\"rd\")); // Expecting b2 to equal \"rd\"",
                "    assert_eq!(b1.len(), 0); // Expecting original b1 to be empty after the second split",
                "    assert_eq!(b1.split_to(1).len(), 0); // Make sure splitting from empty does not panic or cause issues"
              ],
              "code": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(9);",
                "    assert_eq!(b1.len(), 2); // Expecting the length of remaining Bytes after split_to(9) to be 2",
                "    assert_eq!(b1, Bytes::from(\"rld\")); // Expecting the remaining Bytes to equal \"rld\" after split_to(9)",
                "    let b2 = b1.split_to(2); // Splitting again to create b2",
                "    assert_eq!(b2, Bytes::from(\"rd\")); // Expecting b2 to equal \"rd\"",
                "    assert_eq!(b1.len(), 0); // Expecting original b1 to be empty after the second split",
                "    assert_eq!(b1.split_to(1).len(), 0); // Make sure splitting from empty does not panic or cause issues",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(11);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(b1, Bytes::from(\"hello world\"));",
                "    assert_eq!(b1.len(), 11);",
                "    assert_eq!(b1.split_to(6), Bytes::from(\"hello \"));",
                "    assert_eq!(b1.len(), 5);",
                "    assert_eq!(b1.split_to(5), Bytes::from(\"world\"));",
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());",
                "    assert!(b1.split_to(0).is_empty());",
                "    assert!(b1.split_to(0).len() == 0);",
                "    assert!(b1.split_to(11).is_empty());"
              ],
              "code": [
                "{",
                "    let mut b1 = Bytes::from(\"hello world\");",
                "    b1.split_to(11);",
                "    assert_eq!(b1, Bytes::from(\"hello world\"));",
                "    assert_eq!(b1.len(), 11);",
                "    assert_eq!(b1.split_to(6), Bytes::from(\"hello \"));",
                "    assert_eq!(b1.len(), 5);",
                "    assert_eq!(b1.split_to(5), Bytes::from(\"world\"));",
                "    assert_eq!(b1.len(), 0);",
                "    assert!(b1.is_empty());",
                "    assert!(b1.split_to(0).is_empty());",
                "    assert!(b1.split_to(0).len() == 0);",
                "    assert!(b1.split_to(11).is_empty());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}