{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/bytes.rs\n// crate name is bytes\nuse core::iter::FromIterator;\nuse core::mem::{self, ManuallyDrop};\nuse core::ops::{Deref, RangeBounds};\nuse core::ptr::NonNull;\nuse core::{cmp, fmt, hash, ptr, slice, usize};\nuse alloc::{\n    alloc::{dealloc, Layout},\n    borrow::Borrow, boxed::Box, string::String, vec::Vec,\n};\nuse crate::buf::IntoIter;\n#[allow(unused)]\nuse crate::loom::sync::atomic::AtomicMut;\nuse crate::loom::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\nuse crate::{offset_from, Buf, BytesMut};\nstatic OWNED_VTABLE: Vtable = Vtable {\n    clone: owned_clone,\n    into_vec: owned_to_vec,\n    into_mut: owned_to_mut,\n    is_unique: owned_is_unique,\n    drop: owned_drop,\n};\nstatic PROMOTABLE_EVEN_VTABLE: Vtable = Vtable {\n    clone: promotable_even_clone,\n    into_vec: promotable_even_to_vec,\n    into_mut: promotable_even_to_mut,\n    is_unique: promotable_is_unique,\n    drop: promotable_even_drop,\n};\nstatic PROMOTABLE_ODD_VTABLE: Vtable = Vtable {\n    clone: promotable_odd_clone,\n    into_vec: promotable_odd_to_vec,\n    into_mut: promotable_odd_to_mut,\n    is_unique: promotable_is_unique,\n    drop: promotable_odd_drop,\n};\nstatic SHARED_VTABLE: Vtable = Vtable {\n    clone: shared_clone,\n    into_vec: shared_to_vec,\n    into_mut: shared_to_mut,\n    is_unique: shared_is_unique,\n    drop: shared_drop,\n};\nconst STATIC_VTABLE: Vtable = Vtable {\n    clone: static_clone,\n    into_vec: static_to_vec,\n    into_mut: static_to_mut,\n    is_unique: static_is_unique,\n    drop: static_drop,\n};\nconst _: [(); 0 - mem::align_of::<Shared>() % 2] = [];\nconst KIND_ARC: usize = 0b0;\nconst KIND_VEC: usize = 0b1;\nconst KIND_MASK: usize = 0b1;\npub struct Bytes {\n    ptr: *const u8,\n    len: usize,\n    data: AtomicPtr<()>,\n    vtable: &'static Vtable,\n}\npub struct BytesMut {\n    ptr: NonNull<u8>,\n    len: usize,\n    cap: usize,\n    data: *mut Shared,\n}\npub(crate) struct Vtable {\n    /// fn(data, ptr, len)\n    pub clone: unsafe fn(&AtomicPtr<()>, *const u8, usize) -> Bytes,\n    /// fn(data, ptr, len)\n    ///\n    /// `into_*` consumes the `Bytes`, returning the respective value.\n    pub into_vec: unsafe fn(&AtomicPtr<()>, *const u8, usize) -> Vec<u8>,\n    pub into_mut: unsafe fn(&AtomicPtr<()>, *const u8, usize) -> BytesMut,\n    /// fn(data)\n    pub is_unique: unsafe fn(&AtomicPtr<()>) -> bool,\n    /// fn(data, ptr, len)\n    pub drop: unsafe fn(&mut AtomicPtr<()>, *const u8, usize),\n}\nimpl Bytes {\n    #[inline]\n    #[cfg(not(all(loom, test)))]\n    pub const fn new() -> Self {\n        const EMPTY: &[u8] = &[];\n        Bytes::from_static(EMPTY)\n    }\n    #[cfg(all(loom, test))]\n    pub fn new() -> Self {\n        const EMPTY: &[u8] = &[];\n        Bytes::from_static(EMPTY)\n    }\n    #[inline]\n    #[cfg(not(all(loom, test)))]\n    pub const fn from_static(bytes: &'static [u8]) -> Self {\n        Bytes {\n            ptr: bytes.as_ptr(),\n            len: bytes.len(),\n            data: AtomicPtr::new(ptr::null_mut()),\n            vtable: &STATIC_VTABLE,\n        }\n    }\n    #[cfg(all(loom, test))]\n    pub fn from_static(bytes: &'static [u8]) -> Self {\n        Bytes {\n            ptr: bytes.as_ptr(),\n            len: bytes.len(),\n            data: AtomicPtr::new(ptr::null_mut()),\n            vtable: &STATIC_VTABLE,\n        }\n    }\n    fn new_empty_with_ptr(ptr: *const u8) -> Self {\n        debug_assert!(! ptr.is_null());\n        let ptr = without_provenance(ptr as usize);\n        Bytes {\n            ptr,\n            len: 0,\n            data: AtomicPtr::new(ptr::null_mut()),\n            vtable: &STATIC_VTABLE,\n        }\n    }\n    pub fn from_owner<T>(owner: T) -> Self\n    where\n        T: AsRef<[u8]> + Send + 'static,\n    {\n        let owned = Box::into_raw(\n            Box::new(Owned {\n                lifetime: OwnedLifetime {\n                    ref_cnt: AtomicUsize::new(1),\n                    drop: owned_box_and_drop::<T>,\n                },\n                owner,\n            }),\n        );\n        let mut ret = Bytes {\n            ptr: NonNull::dangling().as_ptr(),\n            len: 0,\n            data: AtomicPtr::new(owned.cast()),\n            vtable: &OWNED_VTABLE,\n        };\n        let buf = unsafe { &*owned }.owner.as_ref();\n        ret.ptr = buf.as_ptr();\n        ret.len = buf.len();\n        ret\n    }\n    #[inline]\n    pub const fn len(&self) -> usize {}\n    #[inline]\n    pub const fn is_empty(&self) -> bool {}\n    pub fn is_unique(&self) -> bool {\n        unsafe { (self.vtable.is_unique)(&self.data) }\n    }\n    pub fn copy_from_slice(data: &[u8]) -> Self {\n        data.to_vec().into()\n    }\n    pub fn slice(&self, range: impl RangeBounds<usize>) -> Self {\n        use core::ops::Bound;\n        let len = self.len();\n        let begin = match range.start_bound() {\n            Bound::Included(&n) => n,\n            Bound::Excluded(&n) => n.checked_add(1).expect(\"out of range\"),\n            Bound::Unbounded => 0,\n        };\n        let end = match range.end_bound() {\n            Bound::Included(&n) => n.checked_add(1).expect(\"out of range\"),\n            Bound::Excluded(&n) => n,\n            Bound::Unbounded => len,\n        };\n        assert!(\n            begin <= end, \"range start must not be greater than end: {:?} <= {:?}\",\n            begin, end,\n        );\n        assert!(end <= len, \"range end out of bounds: {:?} <= {:?}\", end, len,);\n        if end == begin {\n            return Bytes::new();\n        }\n        let mut ret = self.clone();\n        ret.len = end - begin;\n        ret.ptr = unsafe { ret.ptr.add(begin) };\n        ret\n    }\n    pub fn slice_ref(&self, subset: &[u8]) -> Self {\n        if subset.is_empty() {\n            return Bytes::new();\n        }\n        let bytes_p = self.as_ptr() as usize;\n        let bytes_len = self.len();\n        let sub_p = subset.as_ptr() as usize;\n        let sub_len = subset.len();\n        assert!(\n            sub_p >= bytes_p,\n            \"subset pointer ({:p}) is smaller than self pointer ({:p})\", subset.as_ptr(),\n            self.as_ptr(),\n        );\n        assert!(\n            sub_p + sub_len <= bytes_p + bytes_len,\n            \"subset is out of bounds: self = ({:p}, {}), subset = ({:p}, {})\", self\n            .as_ptr(), bytes_len, subset.as_ptr(), sub_len,\n        );\n        let sub_offset = sub_p - bytes_p;\n        self.slice(sub_offset..(sub_offset + sub_len))\n    }\n    #[must_use = \"consider Bytes::truncate if you don't need the other half\"]\n    pub fn split_off(&mut self, at: usize) -> Self {\n        if at == self.len() {\n            return Bytes::new_empty_with_ptr(self.ptr.wrapping_add(at));\n        }\n        if at == 0 {\n            return mem::replace(self, Bytes::new_empty_with_ptr(self.ptr));\n        }\n        assert!(\n            at <= self.len(), \"split_off out of bounds: {:?} <= {:?}\", at, self.len(),\n        );\n        let mut ret = self.clone();\n        self.len = at;\n        unsafe { ret.inc_start(at) };\n        ret\n    }\n    #[must_use = \"consider Bytes::advance if you don't need the other half\"]\n    pub fn split_to(&mut self, at: usize) -> Self {\n        if at == self.len() {\n            let end_ptr = self.ptr.wrapping_add(at);\n            return mem::replace(self, Bytes::new_empty_with_ptr(end_ptr));\n        }\n        if at == 0 {\n            return Bytes::new_empty_with_ptr(self.ptr);\n        }\n        assert!(\n            at <= self.len(), \"split_to out of bounds: {:?} <= {:?}\", at, self.len(),\n        );\n        let mut ret = self.clone();\n        unsafe { self.inc_start(at) };\n        ret.len = at;\n        ret\n    }\n    #[inline]\n    pub fn truncate(&mut self, len: usize) {}\n    #[inline]\n    pub fn clear(&mut self) {}\n    pub fn try_into_mut(self) -> Result<BytesMut, Bytes> {\n        if self.is_unique() { Ok(self.into()) } else { Err(self) }\n    }\n    #[inline]\n    pub(crate) unsafe fn with_vtable(\n        ptr: *const u8,\n        len: usize,\n        data: AtomicPtr<()>,\n        vtable: &'static Vtable,\n    ) -> Bytes {}\n    #[inline]\n    fn as_slice(&self) -> &[u8] {}\n    #[inline]\n    unsafe fn inc_start(&mut self, by: usize) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Try to convert self into `BytesMut`.\n///\n/// If `self` is unique for the entire original buffer, this will succeed\n/// and return a `BytesMut` with the contents of `self` without copying.\n/// If `self` is not unique for the entire original buffer, this will fail\n/// and return self.\n///\n/// This will also always fail if the buffer was constructed via either\n/// [from_owner](Bytes::from_owner) or [from_static](Bytes::from_static).\n///\n/// # Examples\n///\n/// ```\n/// use bytes::{Bytes, BytesMut};\n///\n/// let bytes = Bytes::from(b\"hello\".to_vec());\n/// assert_eq!(bytes.try_into_mut(), Ok(BytesMut::from(&b\"hello\"[..])));\n/// ```\n641 pub fn try_into_mut(self) -> Result<BytesMut, Bytes> {\n642     if self.is_unique() {\n643         Ok(self.into())\n644     } else {\n645         Err(self)\n646     }\n647 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}