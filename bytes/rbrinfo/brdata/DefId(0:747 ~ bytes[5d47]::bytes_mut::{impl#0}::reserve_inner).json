{
  "name": "bytes::bytes_mut::{impl#0}::reserve_inner",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": false,
  "loc": "src/bytes_mut.rs:608:5:784:6",
  "doc": "",
  "code": [
    "fn reserve_inner(&mut self, additional: usize, allocate: bool) -> bool {",
    "    let len = self.len();",
    "    let kind = self.kind();",
    "",
    "    if kind == KIND_VEC {",
    "        // If there's enough free space before the start of the buffer, then",
    "        // just copy the data backwards and reuse the already-allocated",
    "        // space.",
    "        //",
    "        // Otherwise, since backed by a vector, use `Vec::reserve`",
    "        //",
    "        // We need to make sure that this optimization does not kill the",
    "        // amortized runtimes of BytesMut's operations.",
    "        unsafe {",
    "            let off = self.get_vec_pos();",
    "",
    "            // Only reuse space if we can satisfy the requested additional space.",
    "            //",
    "            // Also check if the value of `off` suggests that enough bytes",
    "            // have been read to account for the overhead of shifting all",
    "            // the data (in an amortized analysis).",
    "            // Hence the condition `off >= self.len()`.",
    "            //",
    "            // This condition also already implies that the buffer is going",
    "            // to be (at least) half-empty in the end; so we do not break",
    "            // the (amortized) runtime with future resizes of the underlying",
    "            // `Vec`.",
    "            //",
    "            // [For more details check issue #524, and PR #525.]",
    "            if self.capacity() - self.len() + off >= additional && off >= self.len() {",
    "                // There's enough space, and it's not too much overhead:",
    "                // reuse the space!",
    "                //",
    "                // Just move the pointer back to the start after copying",
    "                // data back.",
    "                let base_ptr = self.ptr.as_ptr().sub(off);",
    "                // Since `off >= self.len()`, the two regions don't overlap.",
    "                ptr::copy_nonoverlapping(self.ptr.as_ptr(), base_ptr, self.len);",
    "                self.ptr = vptr(base_ptr);",
    "                self.set_vec_pos(0);",
    "",
    "                // Length stays constant, but since we moved backwards we",
    "                // can gain capacity back.",
    "                self.cap += off;",
    "            } else {",
    "                if !allocate {",
    "                    return false;",
    "                }",
    "                // Not enough space, or reusing might be too much overhead:",
    "                // allocate more space!",
    "                let mut v =",
    "                    ManuallyDrop::new(rebuild_vec(self.ptr.as_ptr(), self.len, self.cap, off));",
    "                v.reserve(additional);",
    "",
    "                // Update the info",
    "                self.ptr = vptr(v.as_mut_ptr().add(off));",
    "                self.cap = v.capacity() - off;",
    "                debug_assert_eq!(self.len, v.len() - off);",
    "            }",
    "",
    "            return true;",
    "        }",
    "    }",
    "",
    "    debug_assert_eq!(kind, KIND_ARC);",
    "    let shared: *mut Shared = self.data;",
    "",
    "    // Reserving involves abandoning the currently shared buffer and",
    "    // allocating a new vector with the requested capacity.",
    "    //",
    "    // Compute the new capacity",
    "    let mut new_cap = match len.checked_add(additional) {",
    "        Some(new_cap) => new_cap,",
    "        None if !allocate => return false,",
    "        None => panic!(\"overflow\"),",
    "    };",
    "",
    "    unsafe {",
    "        // First, try to reclaim the buffer. This is possible if the current",
    "        // handle is the only outstanding handle pointing to the buffer.",
    "        if (*shared).is_unique() {",
    "            // This is the only handle to the buffer. It can be reclaimed.",
    "            // However, before doing the work of copying data, check to make",
    "            // sure that the vector has enough capacity.",
    "            let v = &mut (*shared).vec;",
    "",
    "            let v_capacity = v.capacity();",
    "            let ptr = v.as_mut_ptr();",
    "",
    "            let offset = offset_from(self.ptr.as_ptr(), ptr);",
    "",
    "            // Compare the condition in the `kind == KIND_VEC` case above",
    "            // for more details.",
    "            if v_capacity >= new_cap + offset {",
    "                self.cap = new_cap;",
    "                // no copy is necessary",
    "            } else if v_capacity >= new_cap && offset >= len {",
    "                // The capacity is sufficient, and copying is not too much",
    "                // overhead: reclaim the buffer!",
    "",
    "                // `offset >= len` means: no overlap",
    "                ptr::copy_nonoverlapping(self.ptr.as_ptr(), ptr, len);",
    "",
    "                self.ptr = vptr(ptr);",
    "                self.cap = v.capacity();",
    "            } else {",
    "                if !allocate {",
    "                    return false;",
    "                }",
    "                // calculate offset",
    "                let off = (self.ptr.as_ptr() as usize) - (v.as_ptr() as usize);",
    "",
    "                // new_cap is calculated in terms of `BytesMut`, not the underlying",
    "                // `Vec`, so it does not take the offset into account.",
    "                //",
    "                // Thus we have to manually add it here.",
    "                new_cap = new_cap.checked_add(off).expect(\"overflow\");",
    "",
    "                // The vector capacity is not sufficient. The reserve request is",
    "                // asking for more than the initial buffer capacity. Allocate more",
    "                // than requested if `new_cap` is not much bigger than the current",
    "                // capacity.",
    "                //",
    "                // There are some situations, using `reserve_exact` that the",
    "                // buffer capacity could be below `original_capacity`, so do a",
    "                // check.",
    "                let double = v.capacity().checked_shl(1).unwrap_or(new_cap);",
    "",
    "                new_cap = cmp::max(double, new_cap);",
    "",
    "                // No space - allocate more",
    "                //",
    "                // The length field of `Shared::vec` is not used by the `BytesMut`;",
    "                // instead we use the `len` field in the `BytesMut` itself. However,",
    "                // when calling `reserve`, it doesn't guarantee that data stored in",
    "                // the unused capacity of the vector is copied over to the new",
    "                // allocation, so we need to ensure that we don't have any data we",
    "                // care about in the unused capacity before calling `reserve`.",
    "                debug_assert!(off + len <= v.capacity());",
    "                v.set_len(off + len);",
    "                v.reserve(new_cap - v.len());",
    "",
    "                // Update the info",
    "                self.ptr = vptr(v.as_mut_ptr().add(off));",
    "                self.cap = v.capacity() - off;",
    "            }",
    "",
    "            return true;",
    "        }",
    "    }",
    "    if !allocate {",
    "        return false;",
    "    }",
    "",
    "    let original_capacity_repr = unsafe { (*shared).original_capacity_repr };",
    "    let original_capacity = original_capacity_from_repr(original_capacity_repr);",
    "",
    "    new_cap = cmp::max(new_cap, original_capacity);",
    "",
    "    // Create a new vector to store the data",
    "    let mut v = ManuallyDrop::new(Vec::with_capacity(new_cap));",
    "",
    "    // Copy the bytes",
    "    v.extend_from_slice(self.as_ref());",
    "",
    "    // Release the shared handle. This must be done *after* the bytes are",
    "    // copied.",
    "    unsafe { release_shared(shared) };",
    "",
    "    // Update self",
    "    let data = (original_capacity_repr << ORIGINAL_CAPACITY_OFFSET) | KIND_VEC;",
    "    self.data = invalid_ptr(data);",
    "    self.ptr = vptr(v.as_mut_ptr());",
    "    self.cap = v.capacity();",
    "    debug_assert_eq!(self.len, v.len());",
    "    return true;",
    "}"
  ],
  "size": {
    "chain": 21,
    "contra": 1,
    "min_set": 12
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 612,
          "bound": null
        },
        {
          "cond": "self.capacity() - self.len() + off >= additional",
          "norm": "additional <= self.capacity() - self.len() + off",
          "value": "true",
          "line": 637,
          "bound": "self.capacity() - self.len() + off == additional"
        },
        {
          "cond": "off >= self.len()",
          "norm": null,
          "value": "true",
          "line": 637,
          "bound": "off == self.len()"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        44,
        135,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 612,
          "bound": null
        },
        {
          "cond": "self.capacity() - self.len() + off >= additional",
          "norm": "additional <= self.capacity() - self.len() + off",
          "value": "true",
          "line": 637,
          "bound": "self.capacity() - self.len() + off == additional"
        },
        {
          "cond": "off >= self.len()",
          "norm": null,
          "value": "false",
          "line": 637,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 653,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        19,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        43,
        44,
        135,
        136
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 612,
          "bound": null
        },
        {
          "cond": "self.capacity() - self.len() + off >= additional",
          "norm": "additional <= self.capacity() - self.len() + off",
          "value": "true",
          "line": 637,
          "bound": "self.capacity() - self.len() + off == additional"
        },
        {
          "cond": "off >= self.len()",
          "norm": null,
          "value": "false",
          "line": 637,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 653,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "false",
          "line": 40,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        19,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        41,
        139
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 612,
          "bound": null
        },
        {
          "cond": "self.capacity() - self.len() + off >= additional",
          "norm": "additional <= self.capacity() - self.len() + off",
          "value": "true",
          "line": 637,
          "bound": "self.capacity() - self.len() + off == additional"
        },
        {
          "cond": "off >= self.len()",
          "norm": null,
          "value": "false",
          "line": 637,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "false",
          "line": 653,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        19,
        21,
        22,
        135,
        136
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 612,
          "bound": null
        },
        {
          "cond": "self.capacity() - self.len() + off >= additional",
          "norm": "additional <= self.capacity() - self.len() + off",
          "value": "false",
          "line": 637,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 653,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        20,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        43,
        44,
        135,
        136
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 612,
          "bound": null
        },
        {
          "cond": "self.capacity() - self.len() + off >= additional",
          "norm": "additional <= self.capacity() - self.len() + off",
          "value": "false",
          "line": 637,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 653,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "false",
          "line": 40,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        20,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        41,
        139
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 612,
          "bound": null
        },
        {
          "cond": "self.capacity() - self.len() + off >= additional",
          "norm": "additional <= self.capacity() - self.len() + off",
          "value": "false",
          "line": 637,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "false",
          "line": 653,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        20,
        21,
        22,
        135,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "true",
          "line": 701,
          "bound": "v_capacity == new_cap + offset"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        107,
        133,
        134,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "false",
          "line": 701,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap",
          "norm": "new_cap <= v_capacity",
          "value": "true",
          "line": 704,
          "bound": "v_capacity == new_cap"
        },
        {
          "cond": "offset >= len",
          "norm": "len <= offset",
          "value": "true",
          "line": 704,
          "bound": "offset == len"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        106,
        107,
        133,
        134,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "false",
          "line": 701,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap",
          "norm": "new_cap <= v_capacity",
          "value": "true",
          "line": 704,
          "bound": "v_capacity == new_cap"
        },
        {
          "cond": "offset >= len",
          "norm": "len <= offset",
          "value": "false",
          "line": 704,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 714,
          "bound": null
        },
        {
          "cond": "off + len <= v.capacity()",
          "norm": null,
          "value": "true",
          "line": 746,
          "bound": "off + len == v.capacity()"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        69,
        75,
        77,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        133,
        134,
        136
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "false",
          "line": 701,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap",
          "norm": "new_cap <= v_capacity",
          "value": "true",
          "line": 704,
          "bound": "v_capacity == new_cap"
        },
        {
          "cond": "offset >= len",
          "norm": "len <= offset",
          "value": "false",
          "line": 704,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 714,
          "bound": null
        },
        {
          "cond": "off + len <= v.capacity()",
          "norm": null,
          "value": "false",
          "line": 746,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        69,
        75,
        77,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        93,
        139
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "false",
          "line": 701,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap",
          "norm": "new_cap <= v_capacity",
          "value": "true",
          "line": 704,
          "bound": "v_capacity == new_cap"
        },
        {
          "cond": "offset >= len",
          "norm": "len <= offset",
          "value": "false",
          "line": 704,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "false",
          "line": 714,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        69,
        75,
        77,
        78,
        133,
        134,
        136
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "false",
          "line": 701,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap",
          "norm": "new_cap <= v_capacity",
          "value": "false",
          "line": 704,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 714,
          "bound": null
        },
        {
          "cond": "off + len <= v.capacity()",
          "norm": null,
          "value": "true",
          "line": 746,
          "bound": "off + len == v.capacity()"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        76,
        77,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        133,
        134,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 14,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "false",
          "line": 701,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap",
          "norm": "new_cap <= v_capacity",
          "value": "false",
          "line": 704,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 714,
          "bound": null
        },
        {
          "cond": "off + len <= v.capacity()",
          "norm": null,
          "value": "false",
          "line": 746,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        76,
        77,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        93,
        139
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 15,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "true",
          "line": 688,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap + offset",
          "norm": "new_cap + offset <= v_capacity",
          "value": "false",
          "line": 701,
          "bound": null
        },
        {
          "cond": "v_capacity >= new_cap",
          "norm": "new_cap <= v_capacity",
          "value": "false",
          "line": 704,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "false",
          "line": 714,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        76,
        77,
        78,
        133,
        134,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 16,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "false",
          "line": 688,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 758,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        108,
        109,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        132,
        134,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 17,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "false",
          "line": 688,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 758,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "false",
          "line": 40,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        108,
        109,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        130,
        139
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 18,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches Some(new_cap)",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "(*shared).is_unique()",
          "norm": null,
          "value": "false",
          "line": 688,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "false",
          "line": 758,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        53,
        56,
        60,
        108,
        110,
        134,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 19,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches None or None",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches None",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "true",
          "line": 681,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        54,
        57,
        58,
        55,
        139
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 20,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches None or None",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "len.checked_add(additional) matches None",
          "norm": null,
          "value": "true",
          "line": 679,
          "bound": null
        },
        {
          "cond": "allocate",
          "norm": null,
          "value": "false",
          "line": 681,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        45,
        46,
        48,
        50,
        51,
        54,
        57,
        59,
        134,
        136
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 21,
      "conds": [
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 612,
          "bound": null
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "false",
          "line": 40,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        45,
        46,
        49,
        139
      ],
      "may_contra": false,
      "min_set": false
    }
  ]
}