{
  "name": "bytes::bytes_mut::{impl#0}::advance_unchecked",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": true,
  "loc": "src/bytes_mut.rs:956:5:991:6",
  "doc": "/// Advance the buffer without bounds checking.\n///\n/// # SAFETY\n///\n/// The caller must ensure that `count` <= `self.cap`.\n",
  "code": [
    "pub(crate) unsafe fn advance_unchecked(&mut self, count: usize) {",
    "    // Setting the start to 0 is a no-op, so return early if this is the",
    "    // case.",
    "    if count == 0 {",
    "        return;",
    "    }",
    "",
    "    debug_assert!(count <= self.cap, \"internal: set_start out of bounds\");",
    "",
    "    let kind = self.kind();",
    "",
    "    if kind == KIND_VEC {",
    "        // Setting the start when in vec representation is a little more",
    "        // complicated. First, we have to track how far ahead the",
    "        // \"start\" of the byte buffer from the beginning of the vec. We",
    "        // also have to ensure that we don't exceed the maximum shift.",
    "        let pos = self.get_vec_pos() + count;",
    "",
    "        if pos <= MAX_VEC_POS {",
    "            self.set_vec_pos(pos);",
    "        } else {",
    "            // The repr must be upgraded to ARC. This will never happen",
    "            // on 64 bit systems and will only happen on 32 bit systems",
    "            // when shifting past 134,217,727 bytes. As such, we don't",
    "            // worry too much about performance here.",
    "            self.promote_to_shared(/*ref_count = */ 1);",
    "        }",
    "    }",
    "",
    "    // Updating the start of the view is setting `ptr` to point to the",
    "    // new start and updating the `len` field to reflect the new length",
    "    // of the view.",
    "    self.ptr = vptr(self.ptr.as_ptr().add(count));",
    "    self.len = self.len.checked_sub(count).unwrap_or(0);",
    "    self.cap -= count;",
    "}"
  ],
  "size": {
    "chain": 5,
    "contra": 0,
    "min_set": 5
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "count == 0",
          "norm": "0 == count",
          "value": "false",
          "line": 959,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        25
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "count == 0",
          "norm": "0 == count",
          "value": "true",
          "line": 959,
          "bound": null
        },
        {
          "cond": "count <= self.cap",
          "norm": null,
          "value": "true",
          "line": 963,
          "bound": "count == self.cap"
        },
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 967,
          "bound": null
        },
        {
          "cond": "pos <= MAX_VEC_POS",
          "norm": "MAX_VEC_POS >= pos",
          "value": "true",
          "line": 974,
          "bound": "pos == MAX_VEC_POS"
        }
      ],
      "ret": null,
      "path": [
        0,
        2,
        3,
        5,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        16,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "count == 0",
          "norm": "0 == count",
          "value": "true",
          "line": 959,
          "bound": null
        },
        {
          "cond": "count <= self.cap",
          "norm": null,
          "value": "true",
          "line": 963,
          "bound": "count == self.cap"
        },
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "true",
          "line": 967,
          "bound": null
        },
        {
          "cond": "pos <= MAX_VEC_POS",
          "norm": "MAX_VEC_POS >= pos",
          "value": "false",
          "line": 974,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        2,
        3,
        5,
        7,
        8,
        9,
        10,
        11,
        14,
        15,
        16,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "count == 0",
          "norm": "0 == count",
          "value": "true",
          "line": 959,
          "bound": null
        },
        {
          "cond": "count <= self.cap",
          "norm": null,
          "value": "true",
          "line": 963,
          "bound": "count == self.cap"
        },
        {
          "cond": "kind == KIND_VEC",
          "norm": "KIND_VEC == kind",
          "value": "false",
          "line": 967,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        2,
        3,
        5,
        7,
        8,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "count == 0",
          "norm": "0 == count",
          "value": "true",
          "line": 959,
          "bound": null
        },
        {
          "cond": "count <= self.cap",
          "norm": null,
          "value": "false",
          "line": 963,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        2,
        3,
        6,
        26
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}