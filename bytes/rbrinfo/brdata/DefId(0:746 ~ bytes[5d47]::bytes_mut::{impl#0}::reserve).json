{
  "name": "bytes::bytes_mut::{impl#0}::reserve",
  "mod_info": {
    "name": "bytes_mut",
    "loc": "src/lib.rs:83:1:83:15"
  },
  "visible": true,
  "loc": "src/bytes_mut.rs:592:5:604:6",
  "doc": "/// Reserves capacity for at least `additional` more bytes to be inserted\n/// into the given `BytesMut`.\n///\n/// More than `additional` bytes may be reserved in order to avoid frequent\n/// reallocations. A call to `reserve` may result in an allocation.\n///\n/// Before allocating new buffer space, the function will attempt to reclaim\n/// space in the existing buffer. If the current handle references a view\n/// into a larger original buffer, and all other handles referencing part\n/// of the same original buffer have been dropped, then the current view\n/// can be copied/shifted to the front of the buffer and the handle can take\n/// ownership of the full buffer, provided that the full buffer is large\n/// enough to fit the requested additional capacity.\n///\n/// This optimization will only happen if shifting the data from the current\n/// view to the front of the buffer is not too expensive in terms of the\n/// (amortized) time required. The precise condition is subject to change;\n/// as of now, the length of the data being shifted needs to be at least as\n/// large as the distance that it's shifted by. If the current view is empty\n/// and the original buffer is large enough to fit the requested additional\n/// capacity, then reallocations will never happen.\n///\n/// # Examples\n///\n/// In the following example, a new buffer is allocated.\n///\n/// ```\n/// use bytes::BytesMut;\n///\n/// let mut buf = BytesMut::from(&b\"hello\"[..]);\n/// buf.reserve(64);\n/// assert!(buf.capacity() >= 69);\n/// ```\n///\n/// In the following example, the existing buffer is reclaimed.\n///\n/// ```\n/// use bytes::{BytesMut, BufMut};\n///\n/// let mut buf = BytesMut::with_capacity(128);\n/// buf.put(&[0; 64][..]);\n///\n/// let ptr = buf.as_ptr();\n/// let other = buf.split();\n///\n/// assert!(buf.is_empty());\n/// assert_eq!(buf.capacity(), 64);\n///\n/// drop(other);\n/// buf.reserve(128);\n///\n/// assert_eq!(buf.capacity(), 128);\n/// assert_eq!(buf.as_ptr(), ptr);\n/// ```\n///\n/// # Panics\n///\n/// Panics if the new capacity overflows `usize`.\n",
  "code": [
    "pub fn reserve(&mut self, additional: usize) {",
    "    let len = self.len();",
    "    let rem = self.capacity() - len;",
    "",
    "    if additional <= rem {",
    "        // The handle can already store at least `additional` more bytes, so",
    "        // there is no further work needed to be done.",
    "        return;",
    "    }",
    "",
    "    // will always succeed",
    "    let _ = self.reserve_inner(additional, true);",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "additional <= rem",
          "norm": null,
          "value": "true",
          "line": 596,
          "bound": "additional == rem"
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "additional <= rem",
          "norm": null,
          "value": "false",
          "line": 596,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        5,
        6,
        7
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}