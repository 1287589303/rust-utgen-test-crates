[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2RlZA==\"; // valid base64 encoded string",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        // fill with valid decode values",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2RlZA==\"; // valid base64 encoded string",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: (input.len() * 3) / 4 };",
          "    let mut output = vec![0u8; estimate.conservative_decoded_len];",
          "    ",
          "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);",
          "    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "    assert_eq!(output.len(), estimate.conservative_decoded_len);",
          "    ",
          "    // Additional checks for each chunk",
          "    let expected_output: &[u8] = b\"any can\"; // expected decoded output",
          "    ",
          "    decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).unwrap();",
          "    assert_eq!(output.as_slice(), expected_output); // Valid decoded output assert",
          "    ",
          "    // Check invalid input that caused `decode_chunk_8` to error",
          "    let invalid_input: &[u8] = b\"!!invalid input!!\"; // invalid characters",
          "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: (invalid_input.len() * 3) / 4 };",
          "    assert!(decode_helper(invalid_input, &estimate_invalid, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err());",
          "    ",
          "    let input_partial: &[u8] = b\"YW55\"; // valid but partial base64",
          "    let estimate_partial = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: (input_partial.len() * 3) / 4 };",
          "    assert!(decode_helper(input_partial, &estimate_partial, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());"
        ],
        "code": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2RlZA==\"; // valid base64 encoded string",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        // fill with valid decode values",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2RlZA==\"; // valid base64 encoded string",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: (input.len() * 3) / 4 };",
          "    let mut output = vec![0u8; estimate.conservative_decoded_len];",
          "    ",
          "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);",
          "    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "    assert_eq!(output.len(), estimate.conservative_decoded_len);",
          "    ",
          "    // Additional checks for each chunk",
          "    let expected_output: &[u8] = b\"any can\"; // expected decoded output",
          "    ",
          "    decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).unwrap();",
          "    assert_eq!(output.as_slice(), expected_output); // Valid decoded output assert",
          "    ",
          "    // Check invalid input that caused `decode_chunk_8` to error",
          "    let invalid_input: &[u8] = b\"!!invalid input!!\"; // invalid characters",
          "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: (invalid_input.len() * 3) / 4 };",
          "    assert!(decode_helper(invalid_input, &estimate_invalid, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err());",
          "    ",
          "    let input_partial: &[u8] = b\"YW55\"; // valid but partial base64",
          "    let estimate_partial = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: (input_partial.len() * 3) / 4 };",
          "    assert!(decode_helper(input_partial, &estimate_partial, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2xl\"; // valid base64 with remainder",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(complete_quads_len(input, estimate.rem, output.len(), &decode_table).is_ok(), true);",
          "    assert!(!input[..input_unrolled_loop_len].is_empty());",
          "    assert!(output.iter().all(|&byte| byte == 0));",
          "    assert_eq!(decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]).is_err(), false);",
          "    assert_eq!(decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]), decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]));",
          "    assert!(matches!(decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]), Err(DecodeError::InvalidByte(_, _))));"
        ],
        "code": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2xl\"; // valid base64 with remainder",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert_eq!(complete_quads_len(input, estimate.rem, output.len(), &decode_table).is_ok(), true);",
          "    assert!(!input[..input_unrolled_loop_len].is_empty());",
          "    assert!(output.iter().all(|&byte| byte == 0));",
          "    assert_eq!(decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]).is_err(), false);",
          "    assert_eq!(decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]), decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]));",
          "    assert!(matches!(decode_chunk_8(&input[0..8], 0, &decode_table, &mut output[0..6]), Err(DecodeError::InvalidByte(_, _))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2xlYw==\"; // valid base64 with remainder",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "    let invalid_input: &[u8] = b\"YW55IGNhbmEgZW5jb2xlYw==\"; // valid base64 but simulate error",
          "    assert!(decode_chunk_8(&invalid_input[0..8], 0, &decode_table, &mut output[0..6]).is_err());",
          "    let empty_input: &[u8] = b\"\"; // empty input",
          "    let result = decode_helper(empty_input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert!(result.is_err());",
          "    let short_input: &[u8] = b\"YQ==\"; // short valid base64",
          "    assert!(decode_helper(short_input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "    let large_input = vec![b'A'; 64]; // large valid base64 input",
          "    assert!(decode_helper(&large_input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());"
        ],
        "code": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2xlYw==\"; // valid base64 with remainder",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "    let invalid_input: &[u8] = b\"YW55IGNhbmEgZW5jb2xlYw==\"; // valid base64 but simulate error",
          "    assert!(decode_chunk_8(&invalid_input[0..8], 0, &decode_table, &mut output[0..6]).is_err());",
          "    let empty_input: &[u8] = b\"\"; // empty input",
          "    let result = decode_helper(empty_input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert!(result.is_err());",
          "    let short_input: &[u8] = b\"YQ==\"; // short valid base64",
          "    assert!(decode_helper(short_input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "    let large_input = vec![b'A'; 64]; // large valid base64 input",
          "    assert!(decode_helper(&large_input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2xlYXRh\"; // valid base64 with remainder",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 3, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh\", &GeneralPurposeEstimate { rem: 3, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireCanonical).is_ok(), true);",
          "    ",
          "    assert_eq!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh=\", &GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireCanonical).is_ok(), true);",
          "    ",
          "    assert_eq!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh=\", &GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 29 }, &mut vec![0u8; 29], &decode_table, false, DecodePaddingMode::RequireCanonical).is_err(), true);",
          "    ",
          "    assert!(matches!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh@#\", &GeneralPurposeEstimate { rem: 3, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(_, b'@')))));",
          "    ",
          "    assert!(matches!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh=\", &GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding))));"
        ],
        "code": [
          "{",
          "    let input: &[u8] = b\"YW55IGNhbmEgZW5jb2xlYXRh\"; // valid base64 with remainder",
          "    let mut output = vec![0u8; (input.len() * 3) / 4];",
          "    let estimate = GeneralPurposeEstimate { rem: 3, conservative_decoded_len: output.len() };",
          "    let decode_table: [u8; 256] = {",
          "        let mut table = [INVALID_VALUE; 256];",
          "        for (i, c) in \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".bytes().enumerate() {",
          "            table[c as usize] = i as u8;",
          "        }",
          "        table[b'=' as usize] = 0; // Valid padding",
          "        table",
          "    };",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert_eq!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh\", &GeneralPurposeEstimate { rem: 3, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireCanonical).is_ok(), true);",
          "    ",
          "    assert_eq!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh=\", &GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireCanonical).is_ok(), true);",
          "    ",
          "    assert_eq!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh=\", &GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 29 }, &mut vec![0u8; 29], &decode_table, false, DecodePaddingMode::RequireCanonical).is_err(), true);",
          "    ",
          "    assert!(matches!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh@#\", &GeneralPurposeEstimate { rem: 3, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(_, b'@')))));",
          "    ",
          "    assert!(matches!(decode_helper(b\"YW55IGNhbmEgZW5jb2xlYXRh=\", &GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 30 }, &mut vec![0u8; 30], &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]