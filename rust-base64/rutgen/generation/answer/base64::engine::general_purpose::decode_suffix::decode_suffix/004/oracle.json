[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"QUJD\"; // Base64 for \"ABC\"",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3]; // Output size should be enough to hold the decoded bytes",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set up the decode_table with valid Base64 mapping",
          "    decode_table[b'A' as usize] = 0;  // 0",
          "    decode_table[b'Q' as usize] = 16; // 16",
          "    decode_table[b'J' as usize] = 9;  // 9",
          "    decode_table[b'D' as usize] = 3;  // 3",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::Indifferent;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(output, &[65, 66, 67]); // Check output matches decoded \"ABC\"",
          "    assert!(decode_suffix(b\"QUJ\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireCanonical).is_err()); // Invalid length (only 3 symbols)",
          "    assert!(decode_suffix(b\"QUJD=\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireNone).is_err()); // Invalid padding (1 '=' with RequireNone)",
          "    assert!(decode_suffix(b\"QUJD==\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireCanonical).is_err()); // Invalid padding (3 '=' with RequireCanonical)",
          "    assert!(decode_suffix(b\"QUJDI\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::Indifferent).is_err()); // Invalid byte (non-base64 character)",
          "    assert!(decode_suffix(b\"QUJD=\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireNone).is_err()); // Invalid dimensions of padding with RequireNone",
          "    assert!(decode_suffix(b\"QUJD\\0\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::Indifferent).is_err()); // Invalid byte (null byte)",
          "    assert!(decode_suffix(b\"QUJD\", 0, &mut output, 1, &decode_table, false, DecodePaddingMode::Indifferent).is_err()); // Output slice too small (insufficient space)"
        ],
        "code": [
          "{",
          "    let input = b\"QUJD\"; // Base64 for \"ABC\"",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3]; // Output size should be enough to hold the decoded bytes",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set up the decode_table with valid Base64 mapping",
          "    decode_table[b'A' as usize] = 0;  // 0",
          "    decode_table[b'Q' as usize] = 16; // 16",
          "    decode_table[b'J' as usize] = 9;  // 9",
          "    decode_table[b'D' as usize] = 3;  // 3",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::Indifferent;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert_eq!(output, &[65, 66, 67]); // Check output matches decoded \"ABC\"",
          "    assert!(decode_suffix(b\"QUJ\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireCanonical).is_err()); // Invalid length (only 3 symbols)",
          "    assert!(decode_suffix(b\"QUJD=\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireNone).is_err()); // Invalid padding (1 '=' with RequireNone)",
          "    assert!(decode_suffix(b\"QUJD==\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireCanonical).is_err()); // Invalid padding (3 '=' with RequireCanonical)",
          "    assert!(decode_suffix(b\"QUJDI\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::Indifferent).is_err()); // Invalid byte (non-base64 character)",
          "    assert!(decode_suffix(b\"QUJD=\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::RequireNone).is_err()); // Invalid dimensions of padding with RequireNone",
          "    assert!(decode_suffix(b\"QUJD\\0\", 0, &mut output, 0, &decode_table, false, DecodePaddingMode::Indifferent).is_err()); // Invalid byte (null byte)",
          "    assert!(decode_suffix(b\"QUJD\", 0, &mut output, 1, &decode_table, false, DecodePaddingMode::Indifferent).is_err()); // Output slice too small (insufficient space)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"QUJD==\"; // Base64 for \"ABC\" with valid padding",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3];",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
          "    decode_table[b'A' as usize] = 0;",
          "    decode_table[b'Q' as usize] = 16;",
          "    decode_table[b'J' as usize] = 9;",
          "    decode_table[b'D' as usize] = 3;",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(decode_suffix(b\"QUJD==\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Ok(DecodeMetadata::new(3, Some(4)));",
          "    assert_eq!(decode_suffix(b\"QUJ\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeSliceError::OutputSliceTooSmall));",
          "    assert_eq!(decode_suffix(b\"QUJD=@\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidByte(4, b'@').into()));",
          "    assert_eq!(decode_suffix(b\"QUJ==\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeError::InvalidPadding.into()));",
          "    assert_eq!(decode_suffix(b\"QUJ=C\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidByte(4, b'C').into()));",
          "    assert_eq!(decode_suffix(b\"QUJD=\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidPadding.into()));",
          "    assert_eq!(decode_suffix(b\"Q\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidLength(1).into()));",
          "    assert_eq!(decode_suffix(b\"QUJD\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeError::InvalidPadding.into()));"
        ],
        "code": [
          "{",
          "    let input = b\"QUJD==\"; // Base64 for \"ABC\" with valid padding",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3];",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
          "    decode_table[b'A' as usize] = 0;",
          "    decode_table[b'Q' as usize] = 16;",
          "    decode_table[b'J' as usize] = 9;",
          "    decode_table[b'D' as usize] = 3;",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireCanonical;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert_eq!(decode_suffix(b\"QUJD==\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Ok(DecodeMetadata::new(3, Some(4)));",
          "    assert_eq!(decode_suffix(b\"QUJ\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeSliceError::OutputSliceTooSmall));",
          "    assert_eq!(decode_suffix(b\"QUJD=@\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidByte(4, b'@').into()));",
          "    assert_eq!(decode_suffix(b\"QUJ==\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeError::InvalidPadding.into()));",
          "    assert_eq!(decode_suffix(b\"QUJ=C\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidByte(4, b'C').into()));",
          "    assert_eq!(decode_suffix(b\"QUJD=\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidPadding.into()));",
          "    assert_eq!(decode_suffix(b\"Q\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireCanonical), Err(DecodeError::InvalidLength(1).into()));",
          "    assert_eq!(decode_suffix(b\"QUJD\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeError::InvalidPadding.into()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"QUJ=F\"; // Invalid due to padding after a valid character",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3];",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
          "    decode_table[b'A' as usize] = 0;",
          "    decode_table[b'Q' as usize] = 16;",
          "    decode_table[b'J' as usize] = 9;",
          "    decode_table[b'F' as usize] = INVALID_VALUE; // F is invalid in this context",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::Indifferent;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(3, b'F'))));"
        ],
        "code": [
          "{",
          "    let input = b\"QUJ=F\"; // Invalid due to padding after a valid character",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3];",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
          "    decode_table[b'A' as usize] = 0;",
          "    decode_table[b'Q' as usize] = 16;",
          "    decode_table[b'J' as usize] = 9;",
          "    decode_table[b'F' as usize] = INVALID_VALUE; // F is invalid in this context",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::Indifferent;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert_eq!(_, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(3, b'F'))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"QUJD=E\"; // Invalid due to padding after a valid character",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3];",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
          "    decode_table[b'A' as usize] = 0;",
          "    decode_table[b'Q' as usize] = 16;",
          "    decode_table[b'J' as usize] = 9;",
          "    decode_table[b'E' as usize] = INVALID_VALUE; // E is invalid",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireNone;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(decode_suffix(b\"QUJD=E\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(5, b'E'))));"
        ],
        "code": [
          "{",
          "    let input = b\"QUJD=E\"; // Invalid due to padding after a valid character",
          "    let input_index = 0;",
          "    let mut output = [0u8; 3];",
          "    let output_index = 0;",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
          "    decode_table[b'A' as usize] = 0;",
          "    decode_table[b'Q' as usize] = 16;",
          "    decode_table[b'J' as usize] = 9;",
          "    decode_table[b'E' as usize] = INVALID_VALUE; // E is invalid",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireNone;",
          "",
          "    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "    assert_eq!(decode_suffix(b\"QUJD=E\", 0, &mut [0u8; 3], 0, &decode_table, false, DecodePaddingMode::RequireNone), Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(5, b'E'))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]