{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/write/encoder.rs\n// crate name is base64\nuse crate::engine::Engine;\nuse std::{cmp, fmt, io, io::{ErrorKind, Result}};\npub(crate) const BUF_SIZE: usize = 1024;\nconst MAX_INPUT_LEN: usize = BUF_SIZE / 4 * 3;\nconst MIN_ENCODE_CHUNK_SIZE: usize = 3;\npub trait Engine: Send + Sync {\n    type Config: Config;\n    type DecodeEstimate: DecodeEstimate;\n    fn internal_encode(&self, input: &[u8], output: &mut [u8]) -> usize;\n    fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate;\n    fn internal_decode(\n        &self,\n        input: &[u8],\n        output: &mut [u8],\n        decode_estimate: Self::DecodeEstimate,\n    ) -> Result<DecodeMetadata, DecodeSliceError>;\n    fn config(&self) -> &Self::Config;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn encode<T: AsRef<[u8]>>(&self, input: T) -> String;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn encode_string<T: AsRef<[u8]>>(&self, input: T, output_buf: &mut String);\n    #[cfg_attr(feature = \"alloc\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"alloc\"), doc = \"```ignore\")]\n    #[inline]\n    fn encode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output_buf: &mut [u8],\n    ) -> Result<usize, EncodeSliceError>;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn decode<T: AsRef<[u8]>>(&self, input: T) -> Result<Vec<u8>, DecodeError>;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn decode_vec<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        buffer: &mut Vec<u8>,\n    ) -> Result<(), DecodeError>;\n    #[inline]\n    fn decode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeSliceError>;\n    #[inline]\n    fn decode_slice_unchecked<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeError>;\n}\npub struct EncoderWriter<'e, E: Engine, W: io::Write> {\n    engine: &'e E,\n    /// Where encoded data is written to. It's an Option as it's None immediately before Drop is\n    /// called so that `finish()` can return the underlying writer. None implies that `finish()` has\n    /// been called successfully.\n    delegate: Option<W>,\n    /// Holds a partial chunk, if any, after the last `write()`, so that we may then fill the chunk\n    /// with the next `write()`, encode it, then proceed with the rest of the input normally.\n    extra_input: [u8; MIN_ENCODE_CHUNK_SIZE],\n    /// How much of `extra` is occupied, in `[0, MIN_ENCODE_CHUNK_SIZE]`.\n    extra_input_occupied_len: usize,\n    /// Buffer to encode into. May hold leftover encoded bytes from a previous write call that the underlying writer\n    /// did not write last time.\n    output: [u8; BUF_SIZE],\n    /// How much of `output` is occupied with encoded data that couldn't be written last time\n    output_occupied_len: usize,\n    /// panic safety: don't write again in destructor if writer panicked while we were writing to it\n    panicked: bool,\n}\nimpl<'e, E: Engine, W: io::Write> io::Write for EncoderWriter<'e, E, W> {\n    fn write(&mut self, input: &[u8]) -> Result<usize> {\n        assert!(self.delegate.is_some(), \"Cannot write more after calling finish()\");\n        if input.is_empty() {\n            return Ok(0);\n        }\n        if self.output_occupied_len > 0 {\n            let current_len = self.output_occupied_len;\n            return self.write_to_delegate(current_len).map(|()| 0);\n        }\n        debug_assert_eq!(0, self.output_occupied_len);\n        let mut extra_input_read_len = 0;\n        let mut input = input;\n        let orig_extra_len = self.extra_input_occupied_len;\n        let mut encoded_size = 0;\n        let mut max_input_len = MAX_INPUT_LEN;\n        if self.extra_input_occupied_len > 0 {\n            debug_assert!(self.extra_input_occupied_len < 3);\n            if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n                extra_input_read_len = MIN_ENCODE_CHUNK_SIZE\n                    - self.extra_input_occupied_len;\n                debug_assert!(extra_input_read_len > 0);\n                self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n                    .copy_from_slice(&input[0..extra_input_read_len]);\n                let len = self\n                    .engine\n                    .internal_encode(\n                        &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n                        &mut self.output[..],\n                    );\n                debug_assert_eq!(4, len);\n                input = &input[extra_input_read_len..];\n                self.extra_input_occupied_len = 0;\n                encoded_size = 4;\n                max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n            } else {\n                debug_assert_eq!(1, input.len());\n                debug_assert_eq!(1, self.extra_input_occupied_len);\n                self.extra_input[self.extra_input_occupied_len] = input[0];\n                self.extra_input_occupied_len += 1;\n                return Ok(1);\n            };\n        } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n            self.extra_input[0..input.len()].copy_from_slice(input);\n            self.extra_input_occupied_len = input.len();\n            return Ok(input.len());\n        }\n        debug_assert!(encoded_size == 0 || encoded_size == 4);\n        debug_assert!(\n            MAX_INPUT_LEN == max_input_len || MAX_INPUT_LEN == max_input_len +\n            MIN_ENCODE_CHUNK_SIZE\n        );\n        let input_complete_chunks_len = input.len()\n            - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n        let input_chunks_to_encode_len = cmp::min(\n            input_complete_chunks_len,\n            max_input_len,\n        );\n        debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n        debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n        encoded_size\n            += self\n                .engine\n                .internal_encode(\n                    &input[..(input_chunks_to_encode_len)],\n                    &mut self.output[encoded_size..],\n                );\n        self.write_to_delegate(encoded_size)\n            .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n            .map_err(|e| {\n                self.extra_input_occupied_len = orig_extra_len;\n                e\n            })\n    }\n    fn flush(&mut self) -> Result<()> {}\n}\nimpl<'e, E: Engine, W: io::Write> EncoderWriter<'e, E, W> {\n    pub fn new(delegate: W, engine: &'e E) -> EncoderWriter<'e, E, W> {}\n    pub fn finish(&mut self) -> Result<W> {}\n    fn write_final_leftovers(&mut self) -> Result<()> {}\n    fn write_to_delegate(&mut self, current_output_len: usize) -> Result<()> {\n        self.panicked = true;\n        let res = self\n            .delegate\n            .as_mut()\n            .expect(\"Writer must be present\")\n            .write(&self.output[..current_output_len]);\n        self.panicked = false;\n        res.map(|consumed| {\n            debug_assert!(consumed <= current_output_len);\n            if consumed < current_output_len {\n                self.output_occupied_len = current_output_len\n                    .checked_sub(consumed)\n                    .unwrap();\n                self.output.rotate_left(consumed);\n            } else {\n                self.output_occupied_len = 0;\n            }\n        })\n    }\n    fn write_all_encoded_output(&mut self) -> Result<()> {}\n    pub fn into_inner(mut self) -> W {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Encode input and then write to the delegate writer.\n///\n/// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n/// of `input` consumed. The value may be `0`, which interacts poorly with `write_all`, which\n/// interprets `Ok(0)` as an error, despite it being allowed by the contract of `write`. See\n/// <https://github.com/rust-lang/rust/issues/56889> for more on that.\n///\n/// If the previous call to `write` provided more (encoded) data than the delegate writer could\n/// accept in a single call to its `write`, the remaining data is buffered. As long as buffered\n/// data is present, subsequent calls to `write` will try to write the remaining buffered data\n/// to the delegate and return either `Ok(0)` -- and therefore not consume any of `input` -- or\n/// an error.\n///\n/// # Errors\n///\n/// Any errors emitted by the delegate writer are returned.\n266 fn write(&mut self, input: &[u8]) -> Result<usize> {\n267     assert!(\n268         self.delegate.is_some(),\n269         \"Cannot write more after calling finish()\"\n270     );\n271 \n272     if input.is_empty() {\n273         return Ok(0);\n274     }\n275 \n276     // The contract of `Write::write` places some constraints on this implementation:\n277     // - a call to `write()` represents at most one call to a wrapped `Write`, so we can't\n278     // iterate over the input and encode multiple chunks.\n279     // - Errors mean that \"no bytes were written to this writer\", so we need to reset the\n280     // internal state to what it was before the error occurred\n281 \n282     // before reading any input, write any leftover encoded output from last time\n283     if self.output_occupied_len > 0 {\n284         let current_len = self.output_occupied_len;\n285         return self\n286             .write_to_delegate(current_len)\n287             // did not read any input\n288             .map(|()| 0);\n289     }\n290 \n291     debug_assert_eq!(0, self.output_occupied_len);\n292 \n293     // how many bytes, if any, were read into `extra` to create a triple to encode\n294     let mut extra_input_read_len = 0;\n295     let mut input = input;\n296 \n297     let orig_extra_len = self.extra_input_occupied_len;\n298 \n299     let mut encoded_size = 0;\n300     // always a multiple of MIN_ENCODE_CHUNK_SIZE\n301     let mut max_input_len = MAX_INPUT_LEN;\n302 \n303     // process leftover un-encoded input from last write\n304     if self.extra_input_occupied_len > 0 {\n305         debug_assert!(self.extra_input_occupied_len < 3);\n306         if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n307             // Fill up `extra`, encode that into `output`, and consume as much of the rest of\n308             // `input` as possible.\n309             // We could write just the encoding of `extra` by itself but then we'd have to\n310             // return after writing only 4 bytes, which is inefficient if the underlying writer\n311             // would make a syscall.\n312             extra_input_read_len = MIN_ENCODE_CHUNK_SIZE - self.extra_input_occupied_len;\n313             debug_assert!(extra_input_read_len > 0);\n314             // overwrite only bytes that weren't already used. If we need to rollback extra_len\n315             // (when the subsequent write errors), the old leading bytes will still be there.\n316             self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n317                 .copy_from_slice(&input[0..extra_input_read_len]);\n318 \n319             let len = self.engine.internal_encode(\n320                 &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n321                 &mut self.output[..],\n322             );\n323             debug_assert_eq!(4, len);\n324 \n325             input = &input[extra_input_read_len..];\n326 \n327             // consider extra to be used up, since we encoded it\n328             self.extra_input_occupied_len = 0;\n329             // don't clobber where we just encoded to\n330             encoded_size = 4;\n331             // and don't read more than can be encoded\n332             max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n333 \n334         // fall through to normal encoding\n335         } else {\n336             // `extra` and `input` are non empty, but `|extra| + |input| < 3`, so there must be\n337             // 1 byte in each.\n338             debug_assert_eq!(1, input.len());\n339             debug_assert_eq!(1, self.extra_input_occupied_len);\n340 \n341             self.extra_input[self.extra_input_occupied_len] = input[0];\n342             self.extra_input_occupied_len += 1;\n343             return Ok(1);\n344         };\n345     } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n346         // `extra` is empty, and `input` fits inside it\n347         self.extra_input[0..input.len()].copy_from_slice(input);\n348         self.extra_input_occupied_len = input.len();\n349         return Ok(input.len());\n350     };\n351 \n352     // either 0 or 1 complete chunks encoded from extra\n353     debug_assert!(encoded_size == 0 || encoded_size == 4);\n354     debug_assert!(\n355         // didn't encode extra input\n356         MAX_INPUT_LEN == max_input_len\n357             // encoded one triple\n358             || MAX_INPUT_LEN == max_input_len + MIN_ENCODE_CHUNK_SIZE\n359     );\n360 \n361     // encode complete triples only\n362     let input_complete_chunks_len = input.len() - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n363     let input_chunks_to_encode_len = cmp::min(input_complete_chunks_len, max_input_len);\n364     debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n365     debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n366 \n367     encoded_size += self.engine.internal_encode(\n368         &input[..(input_chunks_to_encode_len)],\n369         &mut self.output[encoded_size..],\n370     );\n371 \n372     // not updating `self.output_occupied_len` here because if the below write fails, it should\n373     // \"never take place\" -- the buffer contents we encoded are ignored and perhaps retried\n374     // later, if the consumer chooses.\n375 \n376     self.write_to_delegate(encoded_size)\n377         // no matter whether we wrote the full encoded buffer or not, we consumed the same\n378         // input\n379         .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n380         .map_err(|e| {\n381             // in case we filled and encoded `extra`, reset extra_len\n382             self.extra_input_occupied_len = orig_extra_len;\n383 \n384             e\n385         })\n386 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}