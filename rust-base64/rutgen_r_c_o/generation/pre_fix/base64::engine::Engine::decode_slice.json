{
  "name": "base64::engine::Engine::decode_slice",
  "mod_info": {
    "name": "engine",
    "loc": "src/lib.rs:281:1:281:16"
  },
  "visible": true,
  "loc": "src/engine/mod.rs:353:5:376:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "input length greater than 0, input containing valid base64 encoded data, output slice size equal to or greater than the estimated decoded length, input containing invalid base64 data, output slice size smaller than the estimated decoded length, empty input, and input containing padding characters.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4 // A rough estimate for base64 decoding",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\"; // Valid Base64 encoded string",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    let _ = engine.decode_slice(input, &mut output);",
                "}"
              ],
              "oracle": [
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    assert_eq!(engine.decode_slice(input, &mut output), Ok(output.len()));",
                "    ",
                "    let input_invalid = \"SGVsbG8gd29ybGQ\";",
                "    let mut output_invalid = vec![0u8; engine.internal_decoded_len_estimate(input_invalid.len())];",
                "    assert!(engine.decode_slice(input_invalid, &mut output_invalid).is_err());",
                "    ",
                "    let input_too_short = \"\";",
                "    let mut output_too_short = vec![0u8; engine.internal_decoded_len_estimate(input_too_short.len())];",
                "    assert_eq!(engine.decode_slice(input_too_short, &mut output_too_short), Ok(0));",
                "    ",
                "    let input_padding = \"SGVsbG8gd29ybGQ==\";",
                "    let mut output_padding = vec![0u8; engine.internal_decoded_len_estimate(input_padding.len())];",
                "    assert_eq!(engine.decode_slice(input_padding, &mut output_padding), Ok(output_padding.len()));",
                "    ",
                "    let input_large = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output_large = vec![0u8; engine.internal_decoded_len_estimate(input_large.len() * 10)];",
                "    assert_eq!(engine.decode_slice(input_large.repeat(10), &mut output_large), Ok(output_large.len()));"
              ],
              "code": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4 // A rough estimate for base64 decoding",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\"; // Valid Base64 encoded string",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    let _ = engine.decode_slice(input, &mut output);",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    assert_eq!(engine.decode_slice(input, &mut output), Ok(output.len()));",
                "    ",
                "    let input_invalid = \"SGVsbG8gd29ybGQ\";",
                "    let mut output_invalid = vec![0u8; engine.internal_decoded_len_estimate(input_invalid.len())];",
                "    assert!(engine.decode_slice(input_invalid, &mut output_invalid).is_err());",
                "    ",
                "    let input_too_short = \"\";",
                "    let mut output_too_short = vec![0u8; engine.internal_decoded_len_estimate(input_too_short.len())];",
                "    assert_eq!(engine.decode_slice(input_too_short, &mut output_too_short), Ok(0));",
                "    ",
                "    let input_padding = \"SGVsbG8gd29ybGQ==\";",
                "    let mut output_padding = vec![0u8; engine.internal_decoded_len_estimate(input_padding.len())];",
                "    assert_eq!(engine.decode_slice(input_padding, &mut output_padding), Ok(output_padding.len()));",
                "    ",
                "    let input_large = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output_large = vec![0u8; engine.internal_decoded_len_estimate(input_large.len() * 10)];",
                "    assert_eq!(engine.decode_slice(input_large.repeat(10), &mut output_large), Ok(output_large.len()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError)).and_then(|decoded| {",
                "                output[..decoded.len()].copy_from_slice(&decoded);",
                "                Ok(DecodeMetadata { decoded_len: decoded.len() })",
                "            })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"InvalidBase64@@@\"; // Invalid Base64 input",
                "    let mut output = vec![0u8; 10]; // Arbitrary size",
                "    let _ = engine.decode_slice(input, &mut output);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(engine.decode_slice(\"InvalidBase64@@@\", &mut output).is_err(), true);",
                "    assert!(matches!(engine.decode_slice(\"InvalidBase64@@@\", &mut output), Err(DecodeSliceError::DecodeError(_))));",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut output).unwrap(), 11);",
                "    assert_eq!(output[..11], b\"Hello world\");",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8g\", &mut output).unwrap(), 8);",
                "    assert_eq!(output[..8], b\"Hello g\");",
                "    assert!(engine.decode_slice(\"\", &mut output).is_ok());",
                "    assert_eq!(engine.decode_slice(\"\", &mut output).unwrap(), 0);"
              ],
              "code": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError)).and_then(|decoded| {",
                "                output[..decoded.len()].copy_from_slice(&decoded);",
                "                Ok(DecodeMetadata { decoded_len: decoded.len() })",
                "            })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"InvalidBase64@@@\"; // Invalid Base64 input",
                "    let mut output = vec![0u8; 10]; // Arbitrary size",
                "    let _ = engine.decode_slice(input, &mut output);",
                "    assert_eq!(engine.decode_slice(\"InvalidBase64@@@\", &mut output).is_err(), true);",
                "    assert!(matches!(engine.decode_slice(\"InvalidBase64@@@\", &mut output), Err(DecodeSliceError::DecodeError(_))));",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut output).unwrap(), 11);",
                "    assert_eq!(output[..11], b\"Hello world\");",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8g\", &mut output).unwrap(), 8);",
                "    assert_eq!(output[..8], b\"Hello g\");",
                "    assert!(engine.decode_slice(\"\", &mut output).is_ok());",
                "    assert_eq!(engine.decode_slice(\"\", &mut output).unwrap(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\"; // Valid Base64 encoded string",
                "    let mut output = vec![0u8; 5]; // Smaller than the expected output size",
                "    let _ = engine.decode_slice(input, &mut output);",
                "}"
              ],
              "oracle": [
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output = vec![0u8; 5];",
                "    assert!(engine.decode_slice(input, &mut output).is_err());",
                "    ",
                "    let input = \"SGVs\";",
                "    let mut output = vec![0u8; 4];",
                "    assert_eq!(engine.decode_slice(input, &mut output).unwrap(), 3);",
                "    ",
                "    let input = \"U28gY29vbCBjbGllbnQ=\";",
                "    let mut output = vec![0u8; 16];",
                "    assert_eq!(engine.decode_slice(input, &mut output).unwrap(), 15);",
                "    ",
                "    let input = \"\";",
                "    let mut output = vec![0u8; 1];",
                "    assert_eq!(engine.decode_slice(input, &mut output).unwrap(), 0);",
                "    ",
                "    let input = \"InvalidBase64!\";",
                "    let mut output = vec![0u8; 10];",
                "    assert!(engine.decode_slice(input, &mut output).is_err());"
              ],
              "code": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\"; // Valid Base64 encoded string",
                "    let mut output = vec![0u8; 5]; // Smaller than the expected output size",
                "    let _ = engine.decode_slice(input, &mut output);",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output = vec![0u8; 5];",
                "    assert!(engine.decode_slice(input, &mut output).is_err());",
                "    ",
                "    let input = \"SGVs\";",
                "    let mut output = vec![0u8; 4];",
                "    assert_eq!(engine.decode_slice(input, &mut output).unwrap(), 3);",
                "    ",
                "    let input = \"U28gY29vbCBjbGllbnQ=\";",
                "    let mut output = vec![0u8; 16];",
                "    assert_eq!(engine.decode_slice(input, &mut output).unwrap(), 15);",
                "    ",
                "    let input = \"\";",
                "    let mut output = vec![0u8; 1];",
                "    assert_eq!(engine.decode_slice(input, &mut output).unwrap(), 0);",
                "    ",
                "    let input = \"InvalidBase64!\";",
                "    let mut output = vec![0u8; 10];",
                "    assert!(engine.decode_slice(input, &mut output).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"\"; // Empty input",
                "    let mut output = vec![0u8; 10]; // Any non-zero length",
                "    let _ = engine.decode_slice(input, &mut output);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(engine.decode_slice(\"\", &mut vec![0u8; 10]), Ok(0));",
                "    assert!(matches!(engine.decode_slice(\"\", &mut []), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert!(matches!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut []), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut vec![0u8; 10]), Ok(11));",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut [0u8; 11]), Ok(11));",
                "    assert!(matches!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut [0u8; 10]), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert!(matches!(engine.decode_slice(\"InvalidBase64@\", &mut vec![0u8; 10]), Err(DecodeSliceError::DecodeError(_))));",
                "    assert_eq!(engine.decode_slice(\"QQ==\", &mut [0u8; 1]), Ok(1));",
                "    assert!(matches!(engine.decode_slice(\"QQ==\", &mut [0u8; 0]), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert_eq!(engine.decode_slice(\"U29tZSB0ZXh0\", &mut vec![0u8; 10]), Ok(12));"
              ],
              "code": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"\"; // Empty input",
                "    let mut output = vec![0u8; 10]; // Any non-zero length",
                "    let _ = engine.decode_slice(input, &mut output);",
                "    assert_eq!(engine.decode_slice(\"\", &mut vec![0u8; 10]), Ok(0));",
                "    assert!(matches!(engine.decode_slice(\"\", &mut []), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert!(matches!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut []), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut vec![0u8; 10]), Ok(11));",
                "    assert_eq!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut [0u8; 11]), Ok(11));",
                "    assert!(matches!(engine.decode_slice(\"SGVsbG8gd29ybGQ=\", &mut [0u8; 10]), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert!(matches!(engine.decode_slice(\"InvalidBase64@\", &mut vec![0u8; 10]), Err(DecodeSliceError::DecodeError(_))));",
                "    assert_eq!(engine.decode_slice(\"QQ==\", &mut [0u8; 1]), Ok(1));",
                "    assert!(matches!(engine.decode_slice(\"QQ==\", &mut [0u8; 0]), Err(DecodeSliceError::OutputSliceTooSmall)));",
                "    assert_eq!(engine.decode_slice(\"U29tZSB0ZXh0\", &mut vec![0u8; 10]), Ok(12));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\"; // Base64 with padding",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    let _ = engine.decode_slice(input, &mut output);",
                "}"
              ],
              "oracle": [
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    let result = engine.decode_slice(input, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, b\"Hello world\");",
                "    ",
                "    let input_too_short = \"SGVsbG8gd29ybGQ\";",
                "    let mut output_short = vec![0u8; engine.internal_decoded_len_estimate(input_too_short.len()) - 1];",
                "    let result_short = engine.decode_slice(input_too_short, &mut output_short);",
                "    assert!(result_short.is_err());",
                "    assert_eq!(result_short.unwrap_err(), DecodeSliceError::OutputSliceTooSmall);",
                "    ",
                "    let input_empty = \"\";",
                "    let mut output_empty = vec![0u8; engine.internal_decoded_len_estimate(input_empty.len())];",
                "    let result_empty = engine.decode_slice(input_empty, &mut output_empty);",
                "    assert!(result_empty.is_ok());",
                "    assert_eq!(output_empty.len(), 0);",
                "    ",
                "    let input_invalid = \"!!!\";",
                "    let mut output_invalid = vec![0u8; 4];",
                "    let result_invalid = engine.decode_slice(input_invalid, &mut output_invalid);",
                "    assert!(result_invalid.is_err());",
                "    assert!(matches!(result_invalid.unwrap_err(), DecodeSliceError::DecodeError(_)));"
              ],
              "code": [
                "{",
                "    struct TestEngine;",
                "    impl Engine for TestEngine {",
                "        type Config = ();",
                "        type DecodeEstimate = usize;",
                "        fn internal_encode(&self, _input: &[u8], _output: &mut [u8]) -> usize { 0 }",
                "        fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate {",
                "            input_len * 3 / 4",
                "        }",
                "        fn internal_decode(",
                "            &self,",
                "            input: &[u8],",
                "            output: &mut [u8],",
                "            _decode_estimate: Self::DecodeEstimate,",
                "        ) -> Result<DecodeMetadata, DecodeSliceError> {",
                "            let decoded_len = base64::decode(&input).map_err(|_| DecodeSliceError::DecodeError(DecodeError))?;",
                "            output[..decoded_len.len()].copy_from_slice(&decoded_len);",
                "            Ok(DecodeMetadata { decoded_len: decoded_len.len() })",
                "        }",
                "        fn config(&self) -> &Self::Config { &() }",
                "    }",
                "",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\"; // Base64 with padding",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    let _ = engine.decode_slice(input, &mut output);",
                "    let engine = TestEngine;",
                "    let input = \"SGVsbG8gd29ybGQ=\";",
                "    let mut output = vec![0u8; engine.internal_decoded_len_estimate(input.len())];",
                "    let result = engine.decode_slice(input, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, b\"Hello world\");",
                "    ",
                "    let input_too_short = \"SGVsbG8gd29ybGQ\";",
                "    let mut output_short = vec![0u8; engine.internal_decoded_len_estimate(input_too_short.len()) - 1];",
                "    let result_short = engine.decode_slice(input_too_short, &mut output_short);",
                "    assert!(result_short.is_err());",
                "    assert_eq!(result_short.unwrap_err(), DecodeSliceError::OutputSliceTooSmall);",
                "    ",
                "    let input_empty = \"\";",
                "    let mut output_empty = vec![0u8; engine.internal_decoded_len_estimate(input_empty.len())];",
                "    let result_empty = engine.decode_slice(input_empty, &mut output_empty);",
                "    assert!(result_empty.is_ok());",
                "    assert_eq!(output_empty.len(), 0);",
                "    ",
                "    let input_invalid = \"!!!\";",
                "    let mut output_invalid = vec![0u8; 4];",
                "    let result_invalid = engine.decode_slice(input_invalid, &mut output_invalid);",
                "    assert!(result_invalid.is_err());",
                "    assert!(matches!(result_invalid.unwrap_err(), DecodeSliceError::DecodeError(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}