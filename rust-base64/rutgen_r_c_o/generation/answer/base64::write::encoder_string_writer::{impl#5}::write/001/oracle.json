[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockConsumer;",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, _buf: &str) {}",
          "    }",
          "",
          "    let mut consumer = MockConsumer;",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let result = writer.write(&[]);",
          "}"
        ],
        "oracle": [
          "    let result = writer.write(&[]); assert_eq!(result, Ok(0));",
          "    let result = writer.write(&[72]); assert_eq!(result, Ok(1));",
          "    let result = writer.write(b\"Hello\"); assert_eq!(result, Ok(5));",
          "    let result = writer.write(b\"üöÄ\"); assert_eq!(result, Ok(4));",
          "    let result = writer.write(b\"„Åì„Çì„Å´„Å°„ÅØ\"); assert_eq!(result, Ok(15));",
          "    let result = writer.write(b\"Invalid \\xFF\"); assert!(result.is_err());",
          "    let result = writer.write(&[0, 159, 146, 150]); assert_eq!(result, Ok(4));"
        ],
        "code": [
          "{",
          "    struct MockConsumer;",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, _buf: &str) {}",
          "    }",
          "",
          "    let mut consumer = MockConsumer;",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let result = writer.write(&[]);",
          "    let result = writer.write(&[]); assert_eq!(result, Ok(0));",
          "    let result = writer.write(&[72]); assert_eq!(result, Ok(1));",
          "    let result = writer.write(b\"Hello\"); assert_eq!(result, Ok(5));",
          "    let result = writer.write(b\"üöÄ\"); assert_eq!(result, Ok(4));",
          "    let result = writer.write(b\"„Åì„Çì„Å´„Å°„ÅØ\"); assert_eq!(result, Ok(15));",
          "    let result = writer.write(b\"Invalid \\xFF\"); assert!(result.is_err());",
          "    let result = writer.write(&[0, 159, 146, 150]); assert_eq!(result, Ok(4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let byte: &[u8] = &[0x61]; // 'a'",
          "    let result = writer.write(byte);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(1));",
          "    assert_eq!(writer.str_consumer.consumed, \"a\");",
          "    assert!(writer.str_consumer.consumed.is_ascii());",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), 1);"
        ],
        "code": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let byte: &[u8] = &[0x61]; // 'a'",
          "    let result = writer.write(byte);",
          "    assert_eq!(result, Ok(1));",
          "    assert_eq!(writer.str_consumer.consumed, \"a\");",
          "    assert!(writer.str_consumer.consumed.is_ascii());",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let bytes: &[u8] = &[0x61, 0x62, 0x63]; // 'abc'",
          "    let result = writer.write(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(3));",
          "    assert_eq!(consumer.consumed, \"abc\");",
          "    assert!(matches!(result, Ok(_)));",
          "    assert!(consumer.consumed.is_empty() == false);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), bytes.len());",
          "    assert!(consumer.consumed.contains(\"abc\"));"
        ],
        "code": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let bytes: &[u8] = &[0x61, 0x62, 0x63]; // 'abc'",
          "    let result = writer.write(bytes);",
          "    assert_eq!(result, Ok(3));",
          "    assert_eq!(consumer.consumed, \"abc\");",
          "    assert!(matches!(result, Ok(_)));",
          "    assert!(consumer.consumed.is_empty() == false);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), bytes.len());",
          "    assert!(consumer.consumed.contains(\"abc\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let bytes: &[u8] = &[0xE2, 0x9C, 0x94]; // '‚úì' (check mark)",
          "    let result = writer.write(bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(bytes.len()));",
          "    assert_eq!(writer.str_consumer.consumed, \"‚úì\");",
          "    assert_eq!(writer.str_consumer.consumed.len(), 1);",
          "    assert!(result.is_ok());",
          "    assert!(writer.str_consumer.consumed.is_empty() == false);",
          "    assert!(writer.str_consumer.consumed.contains('‚úì'));"
        ],
        "code": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let bytes: &[u8] = &[0xE2, 0x9C, 0x94]; // '‚úì' (check mark)",
          "    let result = writer.write(bytes);",
          "    assert_eq!(result, Ok(bytes.len()));",
          "    assert_eq!(writer.str_consumer.consumed, \"‚úì\");",
          "    assert_eq!(writer.str_consumer.consumed.len(), 1);",
          "    assert!(result.is_ok());",
          "    assert!(writer.str_consumer.consumed.is_empty() == false);",
          "    assert!(writer.str_consumer.consumed.contains('‚úì'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let bytes: Vec<u8> = (0..1024).map(|i| (i % 256) as u8).collect(); // Practically valid UTF-8 range",
          "    let result = writer.write(&bytes);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(bytes.len()));",
          "    assert_eq!(consumer.consumed, std::str::from_utf8(&bytes).unwrap());",
          "    assert!(result.is_ok());",
          "    assert!(consumer.consumed.len() == bytes.len());",
          "    assert!(consumer.consumed.is_empty() == false);"
        ],
        "code": [
          "{",
          "    struct MockConsumer {",
          "        consumed: String,",
          "    }",
          "    ",
          "    impl StrConsumer for MockConsumer {",
          "        fn consume(&mut self, buf: &str) {",
          "            self.consumed.push_str(buf);",
          "        }",
          "    }",
          "",
          "    let mut consumer = MockConsumer { consumed: String::new() };",
          "    let mut writer = Utf8SingleCodeUnitWriter { str_consumer: consumer };",
          "    let bytes: Vec<u8> = (0..1024).map(|i| (i % 256) as u8).collect(); // Practically valid UTF-8 range",
          "    let result = writer.write(&bytes);",
          "    assert_eq!(result, Ok(bytes.len()));",
          "    assert_eq!(consumer.consumed, std::str::from_utf8(&bytes).unwrap());",
          "    assert!(result.is_ok());",
          "    assert!(consumer.consumed.len() == bytes.len());",
          "    assert!(consumer.consumed.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]