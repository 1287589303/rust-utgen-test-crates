[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alphabet = \"ABCDEF\" // 6 unique characters",
          "        .chars()",
          "        .chain(\"ABCDEFAABBCCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")",
          "        .collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "}"
        ],
        "oracle": [
          "    let alphabet = \"ABCDEF\".chars().chain(\"ABCDEFAABBCCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "    assert_eq!(result, Err(ParseAlphabetError::DuplicatedByte(b'A')));"
        ],
        "code": [
          "{",
          "    let alphabet = \"ABCDEF\" // 6 unique characters",
          "        .chars()",
          "        .chain(\"ABCDEFAABBCCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")",
          "        .collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "    let alphabet = \"ABCDEF\".chars().chain(\"ABCDEFAABBCCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "    assert_eq!(result, Err(ParseAlphabetError::DuplicatedByte(b'A')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alphabet = \" A\" // leading space and two A's",
          "        .chars()",
          "        .chain(\"BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")",
          "        .collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "}"
        ],
        "oracle": [
          "    result.unwrap_err() == ParseAlphabetError::DuplicatedByte(b'A')"
        ],
        "code": [
          "{",
          "    let alphabet = \" A\" // leading space and two A's",
          "        .chars()",
          "        .chain(\"BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")",
          "        .collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "    result.unwrap_err() == ParseAlphabetError::DuplicatedByte(b'A')",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alphabet = \"ABCDEF\" // 6 unique and 2 trailing F's",
          "        .chars()",
          "        .chain(\"GHIJKLAVF\") // A is duplicated",
          "        .chain(\"MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")",
          "        .collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "}"
        ],
        "oracle": [
          "    let alphabet = \"ABCDEF\".chars().chain(\"GHIJKLAVF\").chain(\"MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "    assert_eq!(result, Err(ParseAlphabetError::DuplicatedByte(b'A')));"
        ],
        "code": [
          "{",
          "    let alphabet = \"ABCDEF\" // 6 unique and 2 trailing F's",
          "        .chars()",
          "        .chain(\"GHIJKLAVF\") // A is duplicated",
          "        .chain(\"MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")",
          "        .collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "    let alphabet = \"ABCDEF\".chars().chain(\"GHIJKLAVF\").chain(\"MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").collect::<String>();",
          "    let result = Alphabet::new(&alphabet);",
          "    assert_eq!(result, Err(ParseAlphabetError::DuplicatedByte(b'A')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]