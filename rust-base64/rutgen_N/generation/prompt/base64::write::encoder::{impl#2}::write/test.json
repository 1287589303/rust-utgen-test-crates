{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/write/encoder.rs\n// crate name is base64\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Encode input and then write to the delegate writer.\n///\n/// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n/// of `input` consumed. The value may be `0`, which interacts poorly with `write_all`, which\n/// interprets `Ok(0)` as an error, despite it being allowed by the contract of `write`. See\n/// <https://github.com/rust-lang/rust/issues/56889> for more on that.\n///\n/// If the previous call to `write` provided more (encoded) data than the delegate writer could\n/// accept in a single call to its `write`, the remaining data is buffered. As long as buffered\n/// data is present, subsequent calls to `write` will try to write the remaining buffered data\n/// to the delegate and return either `Ok(0)` -- and therefore not consume any of `input` -- or\n/// an error.\n///\n/// # Errors\n///\n/// Any errors emitted by the delegate writer are returned.\n266 fn write(&mut self, input: &[u8]) -> Result<usize> {\n267     assert!(\n268         self.delegate.is_some(),\n269         \"Cannot write more after calling finish()\"\n270     );\n271 \n272     if input.is_empty() {\n273         return Ok(0);\n274     }\n275 \n276     // The contract of `Write::write` places some constraints on this implementation:\n277     // - a call to `write()` represents at most one call to a wrapped `Write`, so we can't\n278     // iterate over the input and encode multiple chunks.\n279     // - Errors mean that \"no bytes were written to this writer\", so we need to reset the\n280     // internal state to what it was before the error occurred\n281 \n282     // before reading any input, write any leftover encoded output from last time\n283     if self.output_occupied_len > 0 {\n284         let current_len = self.output_occupied_len;\n285         return self\n286             .write_to_delegate(current_len)\n287             // did not read any input\n288             .map(|()| 0);\n289     }\n290 \n291     debug_assert_eq!(0, self.output_occupied_len);\n292 \n293     // how many bytes, if any, were read into `extra` to create a triple to encode\n294     let mut extra_input_read_len = 0;\n295     let mut input = input;\n296 \n297     let orig_extra_len = self.extra_input_occupied_len;\n298 \n299     let mut encoded_size = 0;\n300     // always a multiple of MIN_ENCODE_CHUNK_SIZE\n301     let mut max_input_len = MAX_INPUT_LEN;\n302 \n303     // process leftover un-encoded input from last write\n304     if self.extra_input_occupied_len > 0 {\n305         debug_assert!(self.extra_input_occupied_len < 3);\n306         if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n307             // Fill up `extra`, encode that into `output`, and consume as much of the rest of\n308             // `input` as possible.\n309             // We could write just the encoding of `extra` by itself but then we'd have to\n310             // return after writing only 4 bytes, which is inefficient if the underlying writer\n311             // would make a syscall.\n312             extra_input_read_len = MIN_ENCODE_CHUNK_SIZE - self.extra_input_occupied_len;\n313             debug_assert!(extra_input_read_len > 0);\n314             // overwrite only bytes that weren't already used. If we need to rollback extra_len\n315             // (when the subsequent write errors), the old leading bytes will still be there.\n316             self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n317                 .copy_from_slice(&input[0..extra_input_read_len]);\n318 \n319             let len = self.engine.internal_encode(\n320                 &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n321                 &mut self.output[..],\n322             );\n323             debug_assert_eq!(4, len);\n324 \n325             input = &input[extra_input_read_len..];\n326 \n327             // consider extra to be used up, since we encoded it\n328             self.extra_input_occupied_len = 0;\n329             // don't clobber where we just encoded to\n330             encoded_size = 4;\n331             // and don't read more than can be encoded\n332             max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n333 \n334         // fall through to normal encoding\n335         } else {\n336             // `extra` and `input` are non empty, but `|extra| + |input| < 3`, so there must be\n337             // 1 byte in each.\n338             debug_assert_eq!(1, input.len());\n339             debug_assert_eq!(1, self.extra_input_occupied_len);\n340 \n341             self.extra_input[self.extra_input_occupied_len] = input[0];\n342             self.extra_input_occupied_len += 1;\n343             return Ok(1);\n344         };\n345     } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n346         // `extra` is empty, and `input` fits inside it\n347         self.extra_input[0..input.len()].copy_from_slice(input);\n348         self.extra_input_occupied_len = input.len();\n349         return Ok(input.len());\n350     };\n351 \n352     // either 0 or 1 complete chunks encoded from extra\n353     debug_assert!(encoded_size == 0 || encoded_size == 4);\n354     debug_assert!(\n355         // didn't encode extra input\n356         MAX_INPUT_LEN == max_input_len\n357             // encoded one triple\n358             || MAX_INPUT_LEN == max_input_len + MIN_ENCODE_CHUNK_SIZE\n359     );\n360 \n361     // encode complete triples only\n362     let input_complete_chunks_len = input.len() - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n363     let input_chunks_to_encode_len = cmp::min(input_complete_chunks_len, max_input_len);\n364     debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n365     debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n366 \n367     encoded_size += self.engine.internal_encode(\n368         &input[..(input_chunks_to_encode_len)],\n369         &mut self.output[encoded_size..],\n370     );\n371 \n372     // not updating `self.output_occupied_len` here because if the below write fails, it should\n373     // \"never take place\" -- the buffer contents we encoded are ignored and perhaps retried\n374     // later, if the consumer chooses.\n375 \n376     self.write_to_delegate(encoded_size)\n377         // no matter whether we wrote the full encoded buffer or not, we consumed the same\n378         // input\n379         .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n380         .map_err(|e| {\n381             // in case we filled and encoded `extra`, reset extra_len\n382             self.extra_input_occupied_len = orig_extra_len;\n383 \n384             e\n385         })\n386 }\n\n",
  "depend_pt": ""
}