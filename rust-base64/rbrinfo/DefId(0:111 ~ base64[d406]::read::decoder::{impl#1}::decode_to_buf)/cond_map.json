{
  "src/read/decoder.rs:142:23:142:65": [
    {
      "Bool": {
        "Binary": {
          "kind": "Le",
          "expr": "self.b64_offset + self.b64_len <= BUF_SIZE",
          "lhs": "self.b64_offset + self.b64_len",
          "rhs": "BUF_SIZE",
          "cmp_with_int": false
        }
      }
    }
  ],
  "src/read/decoder.rs:142:23:142:53": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "self.b64_offset + self.b64_len",
          "lhs": "self.b64_offset",
          "rhs": "self.b64_len",
          "cmp_with_int": false
        }
      }
    }
  ],
  "/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:316:12:316:42": [
    {
      "Bool": {
        "Other": "$crate::cfg!(debug_assertions)"
      }
    }
  ],
  "src/read/decoder.rs:203:23:203:53": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "self.b64_offset + self.b64_len",
          "lhs": "self.b64_offset",
          "rhs": "self.b64_len",
          "cmp_with_int": false
        }
      }
    }
  ],
  "src/read/decoder.rs:145:63:145:98": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "self.b64_offset + b64_len_to_decode",
          "lhs": "self.b64_offset",
          "rhs": "b64_len_to_decode",
          "cmp_with_int": false
        }
      }
    }
  ],
  "src/read/decoder.rs:185:12:185:50": [
    {
      "Bool": {
        "Other": "let Some(offset) = self.padding_offset"
      }
    }
  ],
  "src/read/decoder.rs:203:23:203:65": [
    {
      "Bool": {
        "Binary": {
          "kind": "Le",
          "expr": "self.b64_offset + self.b64_len <= BUF_SIZE",
          "lhs": "self.b64_offset + self.b64_len",
          "rhs": "BUF_SIZE",
          "cmp_with_int": false
        }
      }
    }
  ],
  "src/read/decoder.rs:143:24:143:38": [
    {
      "Bool": {
        "Other": "buf.is_empty()"
      }
    }
  ],
  "src/read/decoder.rs:187:16:187:47": [
    {
      "Bool": {
        "Binary": {
          "kind": "Gt",
          "expr": "decode_metadata.decoded_len > 0",
          "lhs": "decode_metadata.decoded_len",
          "rhs": "0",
          "cmp_with_int": true
        }
      }
    }
  ],
  "src/read/decoder.rs:146:31:183:73": [
    {
      "Try": "self\n            .engine\n            .internal_decode(\n                b64_to_decode,\n                buf,\n                self.engine.internal_decoded_len_estimate(b64_len_to_decode),\n            )\n            .map_err(|dse| match dse {\n                DecodeSliceError::DecodeError(de) => {\n                    match de {\n                        DecodeError::InvalidByte(offset, byte) => {\n                            match (byte, self.padding_offset) {\n                                // if there was padding in a previous block of decoding that happened to\n                                // be correct, and we now find more padding that happens to be incorrect,\n                                // to be consistent with non-reader decodes, record the error at the first\n                                // padding\n                                (PAD_BYTE, Some(first_pad_offset)) => {\n                                    DecodeError::InvalidByte(first_pad_offset, PAD_BYTE)\n                                }\n                                _ => {\n                                    DecodeError::InvalidByte(self.input_consumed_len + offset, byte)\n                                }\n                            }\n                        }\n                        DecodeError::InvalidLength(len) => {\n                            DecodeError::InvalidLength(self.input_consumed_len + len)\n                        }\n                        DecodeError::InvalidLastSymbol(offset, byte) => {\n                            DecodeError::InvalidLastSymbol(self.input_consumed_len + offset, byte)\n                        }\n                        DecodeError::InvalidPadding => DecodeError::InvalidPadding,\n                    }\n                }\n                DecodeSliceError::OutputSliceTooSmall => {\n                    unreachable!(\"buf is sized correctly in calling code\")\n                }\n            })\n            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?"
    }
  ],
  "src/read/decoder.rs:141:23:141:56": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ge",
          "expr": "self.b64_len >= b64_len_to_decode",
          "lhs": "self.b64_len",
          "rhs": "b64_len_to_decode",
          "cmp_with_int": false
        }
      }
    }
  ]
}