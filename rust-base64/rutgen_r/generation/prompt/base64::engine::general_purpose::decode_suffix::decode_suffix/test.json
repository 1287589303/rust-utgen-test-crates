{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/engine/general_purpose/decode_suffix.rs\n// crate name is base64\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Decode the last 0-4 bytes, checking for trailing set bits and padding per the provided\n/// parameters.\n///\n/// Returns the decode metadata representing the total number of bytes decoded, including the ones\n/// indicated as already written by `output_index`.\n 11 pub(crate) fn decode_suffix(\n 12     input: &[u8],\n 13     input_index: usize,\n 14     output: &mut [u8],\n 15     mut output_index: usize,\n 16     decode_table: &[u8; 256],\n 17     decode_allow_trailing_bits: bool,\n 18     padding_mode: DecodePaddingMode,\n 19 ) -> Result<DecodeMetadata, DecodeSliceError> {\n 20     debug_assert!((input.len() - input_index) <= 4);\n 21 \n 22     // Decode any leftovers that might not be a complete input chunk of 4 bytes.\n 23     // Use a u32 as a stack-resident 4 byte buffer.\n 24     let mut morsels_in_leftover = 0;\n 25     let mut padding_bytes_count = 0;\n 26     // offset from input_index\n 27     let mut first_padding_offset: usize = 0;\n 28     let mut last_symbol = 0_u8;\n 29     let mut morsels = [0_u8; 4];\n 30 \n 31     for (leftover_index, &b) in input[input_index..].iter().enumerate() {\n 32         // '=' padding\n 33         if b == PAD_BYTE {\n 34             // There can be bad padding bytes in a few ways:\n 35             // 1 - Padding with non-padding characters after it\n 36             // 2 - Padding after zero or one characters in the current quad (should only\n 37             //     be after 2 or 3 chars)\n 38             // 3 - More than two characters of padding. If 3 or 4 padding chars\n 39             //     are in the same quad, that implies it will be caught by #2.\n 40             //     If it spreads from one quad to another, it will be an invalid byte\n 41             //     in the first quad.\n 42             // 4 - Non-canonical padding -- 1 byte when it should be 2, etc.\n 43             //     Per config, non-canonical but still functional non- or partially-padded base64\n 44             //     may be treated as an error condition.\n 45 \n 46             if leftover_index < 2 {\n 47                 // Check for error #2.\n 48                 // Either the previous byte was padding, in which case we would have already hit\n 49                 // this case, or it wasn't, in which case this is the first such error.\n 50                 debug_assert!(\n 51                     leftover_index == 0 || (leftover_index == 1 && padding_bytes_count == 0)\n 52                 );\n 53                 let bad_padding_index = input_index + leftover_index;\n 54                 return Err(DecodeError::InvalidByte(bad_padding_index, b).into());\n 55             }\n 56 \n 57             if padding_bytes_count == 0 {\n 58                 first_padding_offset = leftover_index;\n 59             }\n 60 \n 61             padding_bytes_count += 1;\n 62             continue;\n 63         }\n 64 \n 65         // Check for case #1.\n 66         // To make '=' handling consistent with the main loop, don't allow\n 67         // non-suffix '=' in trailing chunk either. Report error as first\n 68         // erroneous padding.\n 69         if padding_bytes_count > 0 {\n 70             return Err(\n 71                 DecodeError::InvalidByte(input_index + first_padding_offset, PAD_BYTE).into(),\n 72             );\n 73         }\n 74 \n 75         last_symbol = b;\n 76 \n 77         // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.\n 78         // Pack the leftovers from left to right.\n 79         let morsel = decode_table[b as usize];\n 80         if morsel == INVALID_VALUE {\n 81             return Err(DecodeError::InvalidByte(input_index + leftover_index, b).into());\n 82         }\n 83 \n 84         morsels[morsels_in_leftover] = morsel;\n 85         morsels_in_leftover += 1;\n 86     }\n 87 \n 88     // If there was 1 trailing byte, and it was valid, and we got to this point without hitting\n 89     // an invalid byte, now we can report invalid length\n 90     if !input.is_empty() && morsels_in_leftover < 2 {\n 91         return Err(DecodeError::InvalidLength(input_index + morsels_in_leftover).into());\n 92     }\n 93 \n 94     match padding_mode {\n 95         DecodePaddingMode::Indifferent => { /* everything we care about was already checked */ }\n 96         DecodePaddingMode::RequireCanonical => {\n 97             // allow empty input\n 98             if (padding_bytes_count + morsels_in_leftover) % 4 != 0 {\n 99                 return Err(DecodeError::InvalidPadding.into());\n100             }\n101         }\n102         DecodePaddingMode::RequireNone => {\n103             if padding_bytes_count > 0 {\n104                 // check at the end to make sure we let the cases of padding that should be InvalidByte\n105                 // get hit\n106                 return Err(DecodeError::InvalidPadding.into());\n107             }\n108         }\n109     }\n110 \n111     // When encoding 1 trailing byte (e.g. 0xFF), 2 base64 bytes (\"/w\") are needed.\n112     // / is the symbol for 63 (0x3F, bottom 6 bits all set) and w is 48 (0x30, top 2 bits\n113     // of bottom 6 bits set).\n114     // When decoding two symbols back to one trailing byte, any final symbol higher than\n115     // w would still decode to the original byte because we only care about the top two\n116     // bits in the bottom 6, but would be a non-canonical encoding. So, we calculate a\n117     // mask based on how many bits are used for just the canonical encoding, and optionally\n118     // error if any other bits are set. In the example of one encoded byte -> 2 symbols,\n119     // 2 symbols can technically encode 12 bits, but the last 4 are non-canonical, and\n120     // useless since there are no more symbols to provide the necessary 4 additional bits\n121     // to finish the second original byte.\n122 \n123     let leftover_bytes_to_append = morsels_in_leftover * 6 / 8;\n124     // Put the up to 6 complete bytes as the high bytes.\n125     // Gain a couple percent speedup from nudging these ORs to use more ILP with a two-way split.\n126     let mut leftover_num = (u32::from(morsels[0]) << 26)\n127         | (u32::from(morsels[1]) << 20)\n128         | (u32::from(morsels[2]) << 14)\n129         | (u32::from(morsels[3]) << 8);\n130 \n131     // if there are bits set outside the bits we care about, last symbol encodes trailing bits that\n132     // will not be included in the output\n133     let mask = !0_u32 >> (leftover_bytes_to_append * 8);\n134     if !decode_allow_trailing_bits && (leftover_num & mask) != 0 {\n135         // last morsel is at `morsels_in_leftover` - 1\n136         return Err(DecodeError::InvalidLastSymbol(\n137             input_index + morsels_in_leftover - 1,\n138             last_symbol,\n139         )\n140         .into());\n141     }\n142 \n143     // Strangely, this approach benchmarks better than writing bytes one at a time,\n144     // or copy_from_slice into output.\n145     for _ in 0..leftover_bytes_to_append {\n146         let hi_byte = (leftover_num >> 24) as u8;\n147         leftover_num <<= 8;\n148         *output\n149             .get_mut(output_index)\n150             .ok_or(DecodeSliceError::OutputSliceTooSmall)? = hi_byte;\n151         output_index += 1;\n152     }\n153 \n154     Ok(DecodeMetadata::new(\n155         output_index,\n156         if padding_bytes_count > 0 {\n157             Some(input_index + first_padding_offset)\n158         } else {\n159             None\n160         },\n161     ))\n162 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}