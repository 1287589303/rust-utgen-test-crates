{
  "name": "itoa::udiv128::udivmod_1e19",
  "mod_info": {
    "name": "udiv128",
    "loc": "src/lib.rs:45:1:45:13"
  },
  "visible": true,
  "loc": "src/udiv128.rs:34:1:48:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: n < 1 << 83 at line 37 is true\n",
        "precondition: (*left_val == *right_val) at line 40 is true\n",
        "precondition: (*left_val == *right_val) at line 40 is true\n",
        "expected return value/type: (quot, rem)\n"
      ],
      "input_infer": "n: 0 to 9,999,999,999,999,999,999 (inclusive)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0_u128;",
                "    let result = udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    let n = 0_u128;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = 0_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = 1_u128;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = 1_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = 1_000_000_000_000_000_000_u128;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = 1_000_000_000_000_000_000_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = (1 << 82) - 1;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = (1 << 82) - 1;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = (1 << 83);",
                "    let expected_quot = 1_u128;",
                "    let expected_rem = 0_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = (1 << 84) - 1;",
                "    let expected_quot = 1_u128;",
                "    let expected_rem = 999999999999999999_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = u128::MAX;",
                "    let expected_quot = 156927543384667019095894735580191660403_u128;",
                "    let expected_rem = 999999999999999999_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);"
              ],
              "code": [
                "{",
                "    let n = 0_u128;",
                "    let result = udivmod_1e19(n);",
                "    let n = 0_u128;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = 0_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = 1_u128;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = 1_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = 1_000_000_000_000_000_000_u128;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = 1_000_000_000_000_000_000_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = (1 << 82) - 1;",
                "    let expected_quot = 0_u128;",
                "    let expected_rem = (1 << 82) - 1;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = (1 << 83);",
                "    let expected_quot = 1_u128;",
                "    let expected_rem = 0_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = (1 << 84) - 1;",
                "    let expected_quot = 1_u128;",
                "    let expected_rem = 999999999999999999_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "    ",
                "    let n = u128::MAX;",
                "    let expected_quot = 156927543384667019095894735580191660403_u128;",
                "    let expected_rem = 999999999999999999_u64;",
                "    assert_eq!(result.0, expected_quot);",
                "    assert_eq!(result.1, expected_rem);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 9_999_999_999_999_999_999_u128;",
                "    let result = udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, (quote, rem));",
                "    assert!(result.0 < 1 << 83);",
                "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
                "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
                "    assert!(result.1 < 10_000_000_000_000_000_000_u64);"
              ],
              "code": [
                "{",
                "    let n = 9_999_999_999_999_999_999_u128;",
                "    let result = udivmod_1e19(n);",
                "    assert_eq!(result, (quote, rem));",
                "    assert!(result.0 < 1 << 83);",
                "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
                "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
                "    assert!(result.1 < 10_000_000_000_000_000_000_u64);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 5_000_000_000_000_000_000_u128;",
                "    let result = udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.0, 500);",
                "    assert_eq!(result.1, 0);"
              ],
              "code": [
                "{",
                "    let n = 5_000_000_000_000_000_000_u128;",
                "    let result = udivmod_1e19(n);",
                "    assert_eq!(result.0, 500);",
                "    assert_eq!(result.1, 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 8_000_000_000_000_000_000_u128;",
                "    let result = udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.0, 8000); // Expected quotient",
                "    assert_eq!(result.1, 0); // Expected remainder",
                "    assert!(result.0 < (1 << 83)); // Precondition: n < 1 << 83 is true",
                "    assert_eq!(result.0 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n); // Verification of n = quot * d + rem",
                "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128 as u64); // Verification of remainder"
              ],
              "code": [
                "{",
                "    let n = 8_000_000_000_000_000_000_u128;",
                "    let result = udivmod_1e19(n);",
                "    assert_eq!(result.0, 8000); // Expected quotient",
                "    assert_eq!(result.1, 0); // Expected remainder",
                "    assert!(result.0 < (1 << 83)); // Precondition: n < 1 << 83 is true",
                "    assert_eq!(result.0 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n); // Verification of n = quot * d + rem",
                "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128 as u64); // Verification of remainder",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 1_u128;",
                "    let result = udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, (0, 1));",
                "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
                "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
                "    assert!(result.0 < (1 << 83));",
                "    assert!(result.1 < 10_000_000_000_000_000_000_u64);",
                "    assert_eq!(result.0 as u128 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n);",
                "    debug_assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
                "    debug_assert_eq!(result.1 as u128, n % 10_000_000_000_000_000_000_u128);"
              ],
              "code": [
                "{",
                "    let n = 1_u128;",
                "    let result = udivmod_1e19(n);",
                "    assert_eq!(result, (0, 1));",
                "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
                "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
                "    assert!(result.0 < (1 << 83));",
                "    assert!(result.1 < 10_000_000_000_000_000_000_u64);",
                "    assert_eq!(result.0 as u128 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n);",
                "    debug_assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
                "    debug_assert_eq!(result.1 as u128, n % 10_000_000_000_000_000_000_u128);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "precondition: n < 1 << 83 at line 37 is false, with bound n == 1 << 83\n",
        "precondition: (*left_val == *right_val) at line 40 is false\n"
      ],
      "input_infer": "n = (1 << 83), n = (1 << 83) + 1, n = u128::MAX, n = 0, n = 1, n = 10_000_000_000_000_000_000, n = 1 << 82\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n: u128 = 1 << 83;",
                "    udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    let result = udivmod_1e19(1 << 83);",
                "    assert!(result.0 != (1 << 83) / 10_000_000_000_000_000_000);",
                "    assert!(result.1 != (1 << 83) % 10_000_000_000_000_000_000);"
              ],
              "code": [
                "{",
                "    let n: u128 = 1 << 83;",
                "    udivmod_1e19(n);",
                "    let result = udivmod_1e19(1 << 83);",
                "    assert!(result.0 != (1 << 83) / 10_000_000_000_000_000_000);",
                "    assert!(result.1 != (1 << 83) % 10_000_000_000_000_000_000);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n: u128 = (1 << 83) + 1;",
                "    udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(udivmod_1e19((1 << 83) + 1), (expected_quotient, expected_remainder));",
                "    assert!(udivmod_1e19((1 << 83) + 1).0 != ((1 << 83) + 1) / 10_000_000_000_000_000_000_u128);",
                "    assert!(udivmod_1e19((1 << 83) + 1).1 != ((1 << 83) + 1) % 10_000_000_000_000_000_000_u128);"
              ],
              "code": [
                "{",
                "    let n: u128 = (1 << 83) + 1;",
                "    udivmod_1e19(n);",
                "    assert_eq!(udivmod_1e19((1 << 83) + 1), (expected_quotient, expected_remainder));",
                "    assert!(udivmod_1e19((1 << 83) + 1).0 != ((1 << 83) + 1) / 10_000_000_000_000_000_000_u128);",
                "    assert!(udivmod_1e19((1 << 83) + 1).1 != ((1 << 83) + 1) % 10_000_000_000_000_000_000_u128);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n: u128 = u128::MAX;",
                "    udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    udivmod_1e19(u128::MAX);",
                "    assert_eq!(udivmod_1e19(u128::MAX).0, u128::MAX / 10_000_000_000_000_000_000_u128);",
                "    assert_eq!(udivmod_1e19(u128::MAX).1, u128::MAX % 10_000_000_000_000_000_000_u128);",
                "    udivmod_1e19(1 << 83);",
                "    assert!(udivmod_1e19(1 << 83).0 != (1 << 83) / 10_000_000_000_000_000_000_u128);",
                "    assert!(udivmod_1e19(1 << 83).0 != 0);",
                "    assert!(udivmod_1e19(1 << 83).1 != 0);",
                "    assert!(udivmod_1e19(u128::MAX).0 != u128_mulhi(u128::MAX, 156927543384667019095894735580191660403) >> 62);"
              ],
              "code": [
                "{",
                "    let n: u128 = u128::MAX;",
                "    udivmod_1e19(n);",
                "    udivmod_1e19(u128::MAX);",
                "    assert_eq!(udivmod_1e19(u128::MAX).0, u128::MAX / 10_000_000_000_000_000_000_u128);",
                "    assert_eq!(udivmod_1e19(u128::MAX).1, u128::MAX % 10_000_000_000_000_000_000_u128);",
                "    udivmod_1e19(1 << 83);",
                "    assert!(udivmod_1e19(1 << 83).0 != (1 << 83) / 10_000_000_000_000_000_000_u128);",
                "    assert!(udivmod_1e19(1 << 83).0 != 0);",
                "    assert!(udivmod_1e19(1 << 83).1 != 0);",
                "    assert!(udivmod_1e19(u128::MAX).0 != u128_mulhi(u128::MAX, 156927543384667019095894735580191660403) >> 62);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n: u128 = 0;",
                "    udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    udivmod_1e19(0) == (0, 0)",
                "    udivmod_1e19(1 << 83) // Precondition where n >= 1 << 83",
                "    udivmod_1e19(1 << 83) == (udivmod_1e19(1 << 83).0, 0) // Check with n == 1 << 83",
                "    udivmod_1e19(u128::MAX) // Test with maximum value for u128",
                "    udivmod_1e19(10_u128.pow(19) - 1) // Test with just below 1e19",
                "    udivmod_1e19(10_u128.pow(19)) // Test with exact 1e19",
                "    udivmod_1e19(10_u128.pow(19) + 1) // Test with just above 1e19",
                "    udivmod_1e19(1) == (0, 1) // Check base case where n == 1",
                "    udivmod_1e19(10_u128.pow(18)) == (0, 100000000000000000) // Test with 1e18",
                "    udivmod_1e19(10_u128.pow(17)) == (0, 10000000000000000) // Test with 1e17",
                "    udivmod_1e19(1 << 82) // Test with n just below the 1 << 83 threshold",
                "    udivmod_1e19(156927543384667019095894735580191660403) // Check with a specific large number",
                "    udivmod_1e19(u128::from(10000000000).pow(2) * 1 << 83) // Check with a large calculated value",
                "    udivmod_1e19(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) // Test with all bits set for u128"
              ],
              "code": [
                "{",
                "    let n: u128 = 0;",
                "    udivmod_1e19(n);",
                "    udivmod_1e19(0) == (0, 0)",
                "    udivmod_1e19(1 << 83) // Precondition where n >= 1 << 83",
                "    udivmod_1e19(1 << 83) == (udivmod_1e19(1 << 83).0, 0) // Check with n == 1 << 83",
                "    udivmod_1e19(u128::MAX) // Test with maximum value for u128",
                "    udivmod_1e19(10_u128.pow(19) - 1) // Test with just below 1e19",
                "    udivmod_1e19(10_u128.pow(19)) // Test with exact 1e19",
                "    udivmod_1e19(10_u128.pow(19) + 1) // Test with just above 1e19",
                "    udivmod_1e19(1) == (0, 1) // Check base case where n == 1",
                "    udivmod_1e19(10_u128.pow(18)) == (0, 100000000000000000) // Test with 1e18",
                "    udivmod_1e19(10_u128.pow(17)) == (0, 10000000000000000) // Test with 1e17",
                "    udivmod_1e19(1 << 82) // Test with n just below the 1 << 83 threshold",
                "    udivmod_1e19(156927543384667019095894735580191660403) // Check with a specific large number",
                "    udivmod_1e19(u128::from(10000000000).pow(2) * 1 << 83) // Check with a large calculated value",
                "    udivmod_1e19(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) // Test with all bits set for u128",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n: u128 = 1;",
                "    udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
                "    assert_ne!(udivmod_1e19(1 << 83).0, (1 << 83) / 10000000000000000000);",
                "    assert_ne!(udivmod_1e19((1 << 83) - 1).1, 0);",
                "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_000_u128), (1, 0));",
                "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_001_u128), (1, 1));",
                "    assert_eq!(udivmod_1e19(0), (0, 0));",
                "    assert_eq!(udivmod_1e19(1_000_000_000_000_000_000_u128), (0, 1_000_000_000_000_000_000));",
                "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000_u128, u128::MAX % 10_000_000_000_000_000_000_u128 as u64));"
              ],
              "code": [
                "{",
                "    let n: u128 = 1;",
                "    udivmod_1e19(n);",
                "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
                "    assert_ne!(udivmod_1e19(1 << 83).0, (1 << 83) / 10000000000000000000);",
                "    assert_ne!(udivmod_1e19((1 << 83) - 1).1, 0);",
                "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_000_u128), (1, 0));",
                "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_001_u128), (1, 1));",
                "    assert_eq!(udivmod_1e19(0), (0, 0));",
                "    assert_eq!(udivmod_1e19(1_000_000_000_000_000_000_u128), (0, 1_000_000_000_000_000_000));",
                "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000_u128, u128::MAX % 10_000_000_000_000_000_000_u128 as u64));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n: u128 = 10_000_000_000_000_000_000;",
                "    udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
                "    assert_ne!(udivmod_1e19(1 << 83), (0, 0));",
                "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660403), (1, 0));",
                "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660404), (1, 1));",
                "    assert_eq!(udivmod_1e19((1 << 83) - 1), (0, (1 << 83) - 1));",
                "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000, (u128::MAX % 10_000_000_000_000_000_000) as u64));",
                "    assert_eq!(udivmod_1e19(0), (0, 0));"
              ],
              "code": [
                "{",
                "    let n: u128 = 10_000_000_000_000_000_000;",
                "    udivmod_1e19(n);",
                "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
                "    assert_ne!(udivmod_1e19(1 << 83), (0, 0));",
                "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660403), (1, 0));",
                "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660404), (1, 1));",
                "    assert_eq!(udivmod_1e19((1 << 83) - 1), (0, (1 << 83) - 1));",
                "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000, (u128::MAX % 10_000_000_000_000_000_000) as u64));",
                "    assert_eq!(udivmod_1e19(0), (0, 0));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n: u128 = 1 << 82;",
                "    udivmod_1e19(n);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(udivmod_1e19(1 << 82), (0, 0));",
                "    assert!(udivmod_1e19(1 << 83).0 > 0);",
                "    assert!(udivmod_1e19(1 << 83).1 < 10_000_000_000_000_000_000);",
                "    let result = udivmod_1e19(1 << 83);",
                "    assert!(result.0 * 10_000_000_000_000_000_000_u128 <= (1 << 83));",
                "    assert_ne!(result.0, result.1);"
              ],
              "code": [
                "{",
                "    let n: u128 = 1 << 82;",
                "    udivmod_1e19(n);",
                "    assert_eq!(udivmod_1e19(1 << 82), (0, 0));",
                "    assert!(udivmod_1e19(1 << 83).0 > 0);",
                "    assert!(udivmod_1e19(1 << 83).1 < 10_000_000_000_000_000_000);",
                "    let result = udivmod_1e19(1 << 83);",
                "    assert!(result.0 * 10_000_000_000_000_000_000_u128 <= (1 << 83));",
                "    assert_ne!(result.0, result.1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}