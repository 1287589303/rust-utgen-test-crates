[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 1 << 83;",
          "    udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    let result = udivmod_1e19(1 << 83);",
          "    assert!(result.0 != (1 << 83) / 10_000_000_000_000_000_000);",
          "    assert!(result.1 != (1 << 83) % 10_000_000_000_000_000_000);"
        ],
        "code": [
          "{",
          "    let n: u128 = 1 << 83;",
          "    udivmod_1e19(n);",
          "    let result = udivmod_1e19(1 << 83);",
          "    assert!(result.0 != (1 << 83) / 10_000_000_000_000_000_000);",
          "    assert!(result.1 != (1 << 83) % 10_000_000_000_000_000_000);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = (1 << 83) + 1;",
          "    udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(udivmod_1e19((1 << 83) + 1), (expected_quotient, expected_remainder));",
          "    assert!(udivmod_1e19((1 << 83) + 1).0 != ((1 << 83) + 1) / 10_000_000_000_000_000_000_u128);",
          "    assert!(udivmod_1e19((1 << 83) + 1).1 != ((1 << 83) + 1) % 10_000_000_000_000_000_000_u128);"
        ],
        "code": [
          "{",
          "    let n: u128 = (1 << 83) + 1;",
          "    udivmod_1e19(n);",
          "    assert_eq!(udivmod_1e19((1 << 83) + 1), (expected_quotient, expected_remainder));",
          "    assert!(udivmod_1e19((1 << 83) + 1).0 != ((1 << 83) + 1) / 10_000_000_000_000_000_000_u128);",
          "    assert!(udivmod_1e19((1 << 83) + 1).1 != ((1 << 83) + 1) % 10_000_000_000_000_000_000_u128);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = u128::MAX;",
          "    udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    udivmod_1e19(u128::MAX);",
          "    assert_eq!(udivmod_1e19(u128::MAX).0, u128::MAX / 10_000_000_000_000_000_000_u128);",
          "    assert_eq!(udivmod_1e19(u128::MAX).1, u128::MAX % 10_000_000_000_000_000_000_u128);",
          "    udivmod_1e19(1 << 83);",
          "    assert!(udivmod_1e19(1 << 83).0 != (1 << 83) / 10_000_000_000_000_000_000_u128);",
          "    assert!(udivmod_1e19(1 << 83).0 != 0);",
          "    assert!(udivmod_1e19(1 << 83).1 != 0);",
          "    assert!(udivmod_1e19(u128::MAX).0 != u128_mulhi(u128::MAX, 156927543384667019095894735580191660403) >> 62);"
        ],
        "code": [
          "{",
          "    let n: u128 = u128::MAX;",
          "    udivmod_1e19(n);",
          "    udivmod_1e19(u128::MAX);",
          "    assert_eq!(udivmod_1e19(u128::MAX).0, u128::MAX / 10_000_000_000_000_000_000_u128);",
          "    assert_eq!(udivmod_1e19(u128::MAX).1, u128::MAX % 10_000_000_000_000_000_000_u128);",
          "    udivmod_1e19(1 << 83);",
          "    assert!(udivmod_1e19(1 << 83).0 != (1 << 83) / 10_000_000_000_000_000_000_u128);",
          "    assert!(udivmod_1e19(1 << 83).0 != 0);",
          "    assert!(udivmod_1e19(1 << 83).1 != 0);",
          "    assert!(udivmod_1e19(u128::MAX).0 != u128_mulhi(u128::MAX, 156927543384667019095894735580191660403) >> 62);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 0;",
          "    udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    udivmod_1e19(0) == (0, 0)",
          "    udivmod_1e19(1 << 83) // Precondition where n >= 1 << 83",
          "    udivmod_1e19(1 << 83) == (udivmod_1e19(1 << 83).0, 0) // Check with n == 1 << 83",
          "    udivmod_1e19(u128::MAX) // Test with maximum value for u128",
          "    udivmod_1e19(10_u128.pow(19) - 1) // Test with just below 1e19",
          "    udivmod_1e19(10_u128.pow(19)) // Test with exact 1e19",
          "    udivmod_1e19(10_u128.pow(19) + 1) // Test with just above 1e19",
          "    udivmod_1e19(1) == (0, 1) // Check base case where n == 1",
          "    udivmod_1e19(10_u128.pow(18)) == (0, 100000000000000000) // Test with 1e18",
          "    udivmod_1e19(10_u128.pow(17)) == (0, 10000000000000000) // Test with 1e17",
          "    udivmod_1e19(1 << 82) // Test with n just below the 1 << 83 threshold",
          "    udivmod_1e19(156927543384667019095894735580191660403) // Check with a specific large number",
          "    udivmod_1e19(u128::from(10000000000).pow(2) * 1 << 83) // Check with a large calculated value",
          "    udivmod_1e19(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) // Test with all bits set for u128"
        ],
        "code": [
          "{",
          "    let n: u128 = 0;",
          "    udivmod_1e19(n);",
          "    udivmod_1e19(0) == (0, 0)",
          "    udivmod_1e19(1 << 83) // Precondition where n >= 1 << 83",
          "    udivmod_1e19(1 << 83) == (udivmod_1e19(1 << 83).0, 0) // Check with n == 1 << 83",
          "    udivmod_1e19(u128::MAX) // Test with maximum value for u128",
          "    udivmod_1e19(10_u128.pow(19) - 1) // Test with just below 1e19",
          "    udivmod_1e19(10_u128.pow(19)) // Test with exact 1e19",
          "    udivmod_1e19(10_u128.pow(19) + 1) // Test with just above 1e19",
          "    udivmod_1e19(1) == (0, 1) // Check base case where n == 1",
          "    udivmod_1e19(10_u128.pow(18)) == (0, 100000000000000000) // Test with 1e18",
          "    udivmod_1e19(10_u128.pow(17)) == (0, 10000000000000000) // Test with 1e17",
          "    udivmod_1e19(1 << 82) // Test with n just below the 1 << 83 threshold",
          "    udivmod_1e19(156927543384667019095894735580191660403) // Check with a specific large number",
          "    udivmod_1e19(u128::from(10000000000).pow(2) * 1 << 83) // Check with a large calculated value",
          "    udivmod_1e19(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) // Test with all bits set for u128",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 1;",
          "    udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
          "    assert_ne!(udivmod_1e19(1 << 83).0, (1 << 83) / 10000000000000000000);",
          "    assert_ne!(udivmod_1e19((1 << 83) - 1).1, 0);",
          "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_000_u128), (1, 0));",
          "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_001_u128), (1, 1));",
          "    assert_eq!(udivmod_1e19(0), (0, 0));",
          "    assert_eq!(udivmod_1e19(1_000_000_000_000_000_000_u128), (0, 1_000_000_000_000_000_000));",
          "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000_u128, u128::MAX % 10_000_000_000_000_000_000_u128 as u64));"
        ],
        "code": [
          "{",
          "    let n: u128 = 1;",
          "    udivmod_1e19(n);",
          "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
          "    assert_ne!(udivmod_1e19(1 << 83).0, (1 << 83) / 10000000000000000000);",
          "    assert_ne!(udivmod_1e19((1 << 83) - 1).1, 0);",
          "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_000_u128), (1, 0));",
          "    assert_eq!(udivmod_1e19(10_000_000_000_000_000_001_u128), (1, 1));",
          "    assert_eq!(udivmod_1e19(0), (0, 0));",
          "    assert_eq!(udivmod_1e19(1_000_000_000_000_000_000_u128), (0, 1_000_000_000_000_000_000));",
          "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000_u128, u128::MAX % 10_000_000_000_000_000_000_u128 as u64));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 10_000_000_000_000_000_000;",
          "    udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
          "    assert_ne!(udivmod_1e19(1 << 83), (0, 0));",
          "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660403), (1, 0));",
          "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660404), (1, 1));",
          "    assert_eq!(udivmod_1e19((1 << 83) - 1), (0, (1 << 83) - 1));",
          "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000, (u128::MAX % 10_000_000_000_000_000_000) as u64));",
          "    assert_eq!(udivmod_1e19(0), (0, 0));"
        ],
        "code": [
          "{",
          "    let n: u128 = 10_000_000_000_000_000_000;",
          "    udivmod_1e19(n);",
          "    assert_eq!(udivmod_1e19(1 << 83), (1, 0));",
          "    assert_ne!(udivmod_1e19(1 << 83), (0, 0));",
          "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660403), (1, 0));",
          "    assert_eq!(udivmod_1e19(156927543384667019095894735580191660404), (1, 1));",
          "    assert_eq!(udivmod_1e19((1 << 83) - 1), (0, (1 << 83) - 1));",
          "    assert_eq!(udivmod_1e19(u128::MAX), (u128::MAX / 10_000_000_000_000_000_000, (u128::MAX % 10_000_000_000_000_000_000) as u64));",
          "    assert_eq!(udivmod_1e19(0), (0, 0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 1 << 82;",
          "    udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(udivmod_1e19(1 << 82), (0, 0));",
          "    assert!(udivmod_1e19(1 << 83).0 > 0);",
          "    assert!(udivmod_1e19(1 << 83).1 < 10_000_000_000_000_000_000);",
          "    let result = udivmod_1e19(1 << 83);",
          "    assert!(result.0 * 10_000_000_000_000_000_000_u128 <= (1 << 83));",
          "    assert_ne!(result.0, result.1);"
        ],
        "code": [
          "{",
          "    let n: u128 = 1 << 82;",
          "    udivmod_1e19(n);",
          "    assert_eq!(udivmod_1e19(1 << 82), (0, 0));",
          "    assert!(udivmod_1e19(1 << 83).0 > 0);",
          "    assert!(udivmod_1e19(1 << 83).1 < 10_000_000_000_000_000_000);",
          "    let result = udivmod_1e19(1 << 83);",
          "    assert!(result.0 * 10_000_000_000_000_000_000_u128 <= (1 << 83));",
          "    assert_ne!(result.0, result.1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]