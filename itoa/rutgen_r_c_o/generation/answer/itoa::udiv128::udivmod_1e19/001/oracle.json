[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = 0_u128;",
          "    let result = udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    let n = 0_u128;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = 0_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = 1_u128;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = 1_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = 1_000_000_000_000_000_000_u128;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = 1_000_000_000_000_000_000_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = (1 << 82) - 1;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = (1 << 82) - 1;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = (1 << 83);",
          "    let expected_quot = 1_u128;",
          "    let expected_rem = 0_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = (1 << 84) - 1;",
          "    let expected_quot = 1_u128;",
          "    let expected_rem = 999999999999999999_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = u128::MAX;",
          "    let expected_quot = 156927543384667019095894735580191660403_u128;",
          "    let expected_rem = 999999999999999999_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);"
        ],
        "code": [
          "{",
          "    let n = 0_u128;",
          "    let result = udivmod_1e19(n);",
          "    let n = 0_u128;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = 0_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = 1_u128;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = 1_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = 1_000_000_000_000_000_000_u128;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = 1_000_000_000_000_000_000_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = (1 << 82) - 1;",
          "    let expected_quot = 0_u128;",
          "    let expected_rem = (1 << 82) - 1;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = (1 << 83);",
          "    let expected_quot = 1_u128;",
          "    let expected_rem = 0_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = (1 << 84) - 1;",
          "    let expected_quot = 1_u128;",
          "    let expected_rem = 999999999999999999_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "    ",
          "    let n = u128::MAX;",
          "    let expected_quot = 156927543384667019095894735580191660403_u128;",
          "    let expected_rem = 999999999999999999_u64;",
          "    assert_eq!(result.0, expected_quot);",
          "    assert_eq!(result.1, expected_rem);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = 9_999_999_999_999_999_999_u128;",
          "    let result = udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, (quote, rem));",
          "    assert!(result.0 < 1 << 83);",
          "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
          "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
          "    assert!(result.1 < 10_000_000_000_000_000_000_u64);"
        ],
        "code": [
          "{",
          "    let n = 9_999_999_999_999_999_999_u128;",
          "    let result = udivmod_1e19(n);",
          "    assert_eq!(result, (quote, rem));",
          "    assert!(result.0 < 1 << 83);",
          "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
          "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
          "    assert!(result.1 < 10_000_000_000_000_000_000_u64);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = 5_000_000_000_000_000_000_u128;",
          "    let result = udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.0, 500);",
          "    assert_eq!(result.1, 0);"
        ],
        "code": [
          "{",
          "    let n = 5_000_000_000_000_000_000_u128;",
          "    let result = udivmod_1e19(n);",
          "    assert_eq!(result.0, 500);",
          "    assert_eq!(result.1, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = 8_000_000_000_000_000_000_u128;",
          "    let result = udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.0, 8000); // Expected quotient",
          "    assert_eq!(result.1, 0); // Expected remainder",
          "    assert!(result.0 < (1 << 83)); // Precondition: n < 1 << 83 is true",
          "    assert_eq!(result.0 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n); // Verification of n = quot * d + rem",
          "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128 as u64); // Verification of remainder"
        ],
        "code": [
          "{",
          "    let n = 8_000_000_000_000_000_000_u128;",
          "    let result = udivmod_1e19(n);",
          "    assert_eq!(result.0, 8000); // Expected quotient",
          "    assert_eq!(result.1, 0); // Expected remainder",
          "    assert!(result.0 < (1 << 83)); // Precondition: n < 1 << 83 is true",
          "    assert_eq!(result.0 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n); // Verification of n = quot * d + rem",
          "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128 as u64); // Verification of remainder",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = 1_u128;",
          "    let result = udivmod_1e19(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, (0, 1));",
          "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
          "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
          "    assert!(result.0 < (1 << 83));",
          "    assert!(result.1 < 10_000_000_000_000_000_000_u64);",
          "    assert_eq!(result.0 as u128 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n);",
          "    debug_assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
          "    debug_assert_eq!(result.1 as u128, n % 10_000_000_000_000_000_000_u128);"
        ],
        "code": [
          "{",
          "    let n = 1_u128;",
          "    let result = udivmod_1e19(n);",
          "    assert_eq!(result, (0, 1));",
          "    assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
          "    assert_eq!(result.1, n % 10_000_000_000_000_000_000_u128);",
          "    assert!(result.0 < (1 << 83));",
          "    assert!(result.1 < 10_000_000_000_000_000_000_u64);",
          "    assert_eq!(result.0 as u128 * 10_000_000_000_000_000_000_u128 + result.1 as u128, n);",
          "    debug_assert_eq!(result.0, n / 10_000_000_000_000_000_000_u128);",
          "    debug_assert_eq!(result.1 as u128, n % 10_000_000_000_000_000_000_u128);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]