{
  "name": "strsim::generic_damerau_levenshtein",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1307:2"
  },
  "visible": true,
  "loc": "src/lib.rs:353:1:414:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: a_len == 0 at line 360 is false\n",
        "expected return value/type: b_len\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![];",
                "    let b_elems: Vec<i32> = vec![1, 2, 3];",
                "    assert_eq!(3, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![1, 2, 3];",
                "    let b_elems: Vec<i32> = vec![];",
                "    assert_eq!(3, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![1, 2, 3];",
                "    let b_elems: Vec<i32> = vec![1, 2, 3];",
                "    assert_eq!(0, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![1, 2, 3];",
                "    let b_elems: Vec<i32> = vec![4, 5, 6];",
                "    assert_eq!(6, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![1, 2];",
                "    let b_elems: Vec<i32> = vec![1, 3];",
                "    assert_eq!(1, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![1, 2];",
                "    let b_elems: Vec<i32> = vec![1, 2, 3];",
                "    assert_eq!(1, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![1, 2, 3];",
                "    let b_elems: Vec<i32> = vec![1, 2];",
                "    assert_eq!(1, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a_elems: Vec<i32> = vec![1, 2, 3, 4];",
                "    let b_elems: Vec<i32> = vec![1, 3, 2, 4];",
                "    assert_eq!(1, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: a_len == 0 at line 360 is true\n",
        "precondition: b_len == 0 at line 363 is false\n",
        "expected return value/type: a_len\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use std::collections::HashMap;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    fn flat_index(row: usize, col: usize, width: usize) -> usize {",
                "        row * width + col",
                "    }",
                "",
                "    let a_elems: &[i32] = &[];",
                "    let b_elems: &[i32] = &[2, 3, 1];",
                "",
                "    let result = generic_damerau_levenshtein(a_elems, b_elems);",
                "    ",
                "    assert_eq!(result, 3);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    fn flat_index(row: usize, col: usize, width: usize) -> usize {",
                "        row * width + col",
                "    }",
                "",
                "    let a_elems: &[i32] = &[];",
                "    let b_elems: &[i32] = &[5, 6];",
                "",
                "    let result = generic_damerau_levenshtein(a_elems, b_elems);",
                "    ",
                "    assert_eq!(result, 2);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "precondition: a_len == 0 at line 360 is true\n",
        "precondition: b_len == 0 at line 363 is true\n",
        "precondition: i in 0..(a_len + 1) at line 372 is true\n",
        "precondition: i in 0..(a_len + 1) at line 372 is false\n",
        "precondition: j in 0..(b_len + 1) at line 377 is true\n",
        "precondition: j in 0..(b_len + 1) at line 377 is false\n",
        "precondition: i in 1..(a_len + 1) at line 384 is true\n",
        "precondition: j in 1..(b_len + 1) at line 387 is true\n",
        "precondition: j - 1 at line 388 is true\n",
        "precondition: elems.get(&b_elems[j - 1]) matches Some(&value) at line 388 is true\n",
        "precondition: a_elems[i - 1] == b_elems[j - 1] at line 399 is false\n",
        "precondition: j in 1..(b_len + 1) at line 387 is false\n",
        "precondition: i in 1..(a_len + 1) at line 384 is false\n",
        "expected return value/type: distances[flat_index(a_len + 1, b_len + 1, width)]\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use super::*;",
            "use std::collections::HashMap;",
            "use std::cmp::min;",
            "use std::hash::Hash;"
          ],
          "has_test_mod": true,
          "common": [
            "    fn flat_index(i: usize, j: usize, width: usize) -> usize {",
            "        i * width + j",
            "    }"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[];",
                "    let b: &[i32] = &[1, 2, 3];",
                "    assert_eq!(3, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[1, 2, 3];",
                "    let b: &[i32] = &[];",
                "    assert_eq!(3, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[];",
                "    let b: &[i32] = &[];",
                "    assert_eq!(0, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[1];",
                "    let b: &[i32] = &[1, 2];",
                "    assert_eq!(1, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[1, 2];",
                "    let b: &[i32] = &[1];",
                "    assert_eq!(1, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[1];",
                "    let b: &[i32] = &[2];",
                "    assert_eq!(1, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[1, 2];",
                "    let b: &[i32] = &[2, 1];",
                "    assert_eq!(1, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: &[i32] = &[1, 3, 2];",
                "    let b: &[i32] = &[2, 1];",
                "    assert_eq!(3, generic_damerau_levenshtein(a, b));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 23,
      "prompt_conds": [
        "precondition: a_len == 0 at line 360 is true\n",
        "precondition: b_len == 0 at line 363 is true\n",
        "precondition: i in 0..(a_len + 1) at line 372 is false\n",
        "precondition: j in 0..(b_len + 1) at line 377 is false\n",
        "precondition: i in 1..(a_len + 1) at line 384 is true\n",
        "precondition: j in 1..(b_len + 1) at line 387 is true\n",
        "precondition: j - 1 at line 388 is false\n",
        "precondition: a_elems[i - 1] == b_elems[j - 1] at line 399 is true\n",
        "precondition: j in 1..(b_len + 1) at line 387 is false\n",
        "precondition: i in 1..(a_len + 1) at line 384 is false\n",
        "expected return value/type: distances[flat_index(a_len + 1, b_len + 1, width)]\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use std::collections::HashMap;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    let a_elems: Vec<i32> = vec![];",
                "    let b_elems: Vec<i32> = vec![1, 2, 3];",
                "    assert_eq!(b_elems.len(), generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    let a_elems: Vec<i32> = vec![1, 2, 3];",
                "    let b_elems: Vec<i32> = vec![];",
                "    assert_eq!(a_elems.len(), generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    let a_elems: Vec<char> = vec!['a'];",
                "    let b_elems: Vec<char> = vec!['a'];",
                "    assert_eq!(0, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    let a_elems: Vec<char> = vec!['a'];",
                "    let b_elems: Vec<char> = vec!['a', 'b'];",
                "    assert_eq!(1, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    let a_elems: Vec<char> = vec!['a', 'b'];",
                "    let b_elems: Vec<char> = vec!['a'];",
                "    assert_eq!(1, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    let a_elems: Vec<char> = vec!['a'];",
                "    let b_elems: Vec<char> = vec!['b'];",
                "    assert_eq!(1, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    use std::collections::HashMap;",
                "",
                "    let a_elems: Vec<char> = vec!['a', 'b', 'c'];",
                "    let b_elems: Vec<char> = vec!['c', 'b', 'a'];",
                "    assert_eq!(2, generic_damerau_levenshtein(&a_elems, &b_elems));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 26,
      "prompt_conds": [
        "precondition: a_len == 0 at line 360 is true\n",
        "precondition: b_len == 0 at line 363 is true\n",
        "precondition: i in 0..(a_len + 1) at line 372 is false\n",
        "precondition: j in 0..(b_len + 1) at line 377 is false\n",
        "precondition: i in 1..(a_len + 1) at line 384 is false\n",
        "expected return value/type: distances[flat_index(a_len + 1, b_len + 1, width)]\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: Vec<i32> = vec![];",
                "    let b: Vec<i32> = vec![];",
                "    assert_eq!(generic_damerau_levenshtein(&a, &b), 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: Vec<i32> = vec![];",
                "    let b: Vec<i32> = vec![1, 2, 3];",
                "    assert_eq!(generic_damerau_levenshtein(&a, &b), 3);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: Vec<i32> = vec![1, 2, 3];",
                "    let b: Vec<i32> = vec![];",
                "    assert_eq!(generic_damerau_levenshtein(&a, &b), 3);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: Vec<i32> = vec![1];",
                "    let b: Vec<i32> = vec![2];",
                "    assert_eq!(generic_damerau_levenshtein(&a, &b), 2);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: Vec<i32> = vec![1];",
                "    let b: Vec<i32> = vec![1];",
                "    assert_eq!(generic_damerau_levenshtein(&a, &b), 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [],
              "oracle": [],
              "code": [
                "{",
                "    let a: Vec<i32> = vec![1, 2, 3];",
                "    let b: Vec<i32> = vec![3, 2, 1];",
                "    assert_eq!(generic_damerau_levenshtein(&a, &b), 4);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}