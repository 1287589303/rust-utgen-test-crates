{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/lib.rs\n// crate name is strsim\nThe function to be tested is presented with each line formatted as 'line number + code':\n609 fn damerau_levenshtein_impl<Iter1, Iter2>(s1: Iter1, len1: usize, s2: Iter2, len2: usize) -> usize\n610 where\n611     Iter1: Iterator<Item = char> + Clone,\n612     Iter2: Iterator<Item = char> + Clone,\n613 {\n614     // The implementations is based on the paper\n615     // `Linear space string correction algorithm using the Damerau-Levenshtein distance`\n616     // from Chunchun Zhao and Sartaj Sahni\n617     //\n618     // It has a runtime complexity of `O(N*M)` and a memory usage of `O(N+M)`.\n619     let max_val = max(len1, len2) as isize + 1;\n620 \n621     let mut last_row_id = HybridGrowingHashmapChar::<RowId>::default();\n622 \n623     let size = len2 + 2;\n624     let mut fr = vec![max_val; size];\n625     let mut r1 = vec![max_val; size];\n626     let mut r: Vec<isize> = (max_val..max_val + 1)\n627         .chain(0..(size - 1) as isize)\n628         .collect();\n629 \n630     for (i, ch1) in s1.enumerate().map(|(i, ch1)| (i + 1, ch1)) {\n631         mem::swap(&mut r, &mut r1);\n632         let mut last_col_id: isize = -1;\n633         let mut last_i2l1 = r[1];\n634         r[1] = i as isize;\n635         let mut t = max_val;\n636 \n637         for (j, ch2) in s2.clone().enumerate().map(|(j, ch2)| (j + 1, ch2)) {\n638             let diag = r1[j] + isize::from(ch1 != ch2);\n639             let left = r[j] + 1;\n640             let up = r1[j + 1] + 1;\n641             let mut temp = min(diag, min(left, up));\n642 \n643             if ch1 == ch2 {\n644                 last_col_id = j as isize; // last occurence of s1_i\n645                 fr[j + 1] = r1[j - 1]; // save H_k-1,j-2\n646                 t = last_i2l1; // save H_i-2,l-1\n647             } else {\n648                 let k = last_row_id.get(ch2).val;\n649                 let l = last_col_id;\n650 \n651                 if j as isize - l == 1 {\n652                     let transpose = fr[j + 1] + (i as isize - k);\n653                     temp = min(temp, transpose);\n654                 } else if i as isize - k == 1 {\n655                     let transpose = t + (j as isize - l);\n656                     temp = min(temp, transpose);\n657                 }\n658             }\n659 \n660             last_i2l1 = r[j + 1];\n661             r[j + 1] = temp;\n662         }\n663         last_row_id.get_mut(ch1).val = i as isize;\n664     }\n665 \n666     r[len2 + 1] as usize\n667 }\n\n",
  "depend_pt": ""
}