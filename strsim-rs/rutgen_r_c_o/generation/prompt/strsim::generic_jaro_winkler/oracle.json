{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/lib.rs\n// crate name is strsim\npub type HammingResult = Result<usize, StrSimError>;\nuse std::char;\nuse std::cmp::{max, min};\nuse std::collections::HashMap;\nuse std::convert::TryFrom;\nuse std::error::Error;\nuse std::fmt::{self, Display, Formatter};\nuse std::hash::Hash;\nuse std::mem;\nuse std::str::Chars;\npub fn generic_jaro_winkler<'a, 'b, Iter1, Iter2, Elem1, Elem2>(\n    a: &'a Iter1,\n    b: &'b Iter2,\n) -> f64\nwhere\n    &'a Iter1: IntoIterator<Item = Elem1>,\n    &'b Iter2: IntoIterator<Item = Elem2>,\n    Elem1: PartialEq<Elem2>,\n{\n    let sim = generic_jaro(a, b);\n    if sim > 0.7 {\n        let prefix_length = a\n            .into_iter()\n            .take(4)\n            .zip(b)\n            .take_while(|(a_elem, b_elem)| a_elem == b_elem)\n            .count();\n        sim + 0.1 * prefix_length as f64 * (1.0 - sim)\n    } else {\n        sim\n    }\n}\npub fn generic_jaro<'a, 'b, Iter1, Iter2, Elem1, Elem2>(\n    a: &'a Iter1,\n    b: &'b Iter2,\n) -> f64\nwhere\n    &'a Iter1: IntoIterator<Item = Elem1>,\n    &'b Iter2: IntoIterator<Item = Elem2>,\n    Elem1: PartialEq<Elem2>,\n{\n    let a_len = a.into_iter().count();\n    let b_len = b.into_iter().count();\n    if a_len == 0 && b_len == 0 {\n        return 1.0;\n    } else if a_len == 0 || b_len == 0 {\n        return 0.0;\n    }\n    let mut search_range = max(a_len, b_len) / 2;\n    search_range = search_range.saturating_sub(1);\n    let mut flags_memory = vec![false; a_len + b_len];\n    let (a_flags, b_flags) = flags_memory.split_at_mut(a_len);\n    let mut matches = 0_usize;\n    for (i, a_elem) in a.into_iter().enumerate() {\n        let min_bound = if i > search_range { i - search_range } else { 0 };\n        let max_bound = min(b_len, i + search_range + 1);\n        for (j, b_elem) in b.into_iter().enumerate().take(max_bound) {\n            if min_bound <= j && a_elem == b_elem && !b_flags[j] {\n                a_flags[i] = true;\n                b_flags[j] = true;\n                matches += 1;\n                break;\n            }\n        }\n    }\n    let mut transpositions = 0_usize;\n    if matches != 0 {\n        let mut b_iter = b_flags.iter().zip(b);\n        for (a_flag, ch1) in a_flags.iter().zip(a) {\n            if *a_flag {\n                loop {\n                    if let Some((b_flag, ch2)) = b_iter.next() {\n                        if !*b_flag {\n                            continue;\n                        }\n                        if ch1 != ch2 {\n                            transpositions += 1;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    transpositions /= 2;\n    if matches == 0 {\n        0.0\n    } else {\n        ((matches as f64 / a_len as f64) + (matches as f64 / b_len as f64)\n            + ((matches - transpositions) as f64 / matches as f64)) / 3.0\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Like Jaro but gives a boost to sequences that have a common prefix.\n191 pub fn generic_jaro_winkler<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> f64\n192 where\n193     &'a Iter1: IntoIterator<Item = Elem1>,\n194     &'b Iter2: IntoIterator<Item = Elem2>,\n195     Elem1: PartialEq<Elem2>,\n196 {\n197     let sim = generic_jaro(a, b);\n198 \n199     if sim > 0.7 {\n200         let prefix_length = a\n201             .into_iter()\n202             .take(4)\n203             .zip(b)\n204             .take_while(|(a_elem, b_elem)| a_elem == b_elem)\n205             .count();\n206 \n207         sim + 0.1 * prefix_length as f64 * (1.0 - sim)\n208     } else {\n209         sim\n210     }\n211 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}