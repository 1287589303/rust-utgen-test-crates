[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{0100}');",
          "}"
        ],
        "oracle": [
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{0100}');",
          "    assert_eq!(result, Default::default());",
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [42; 256] };",
          "    let result = hashmap.get('\\u{00A0}');",
          "    assert_eq!(result, 42);",
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{0100}');",
          "    assert_eq!(result, Default::default());"
        ],
        "code": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{0100}');",
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{0100}');",
          "    assert_eq!(result, Default::default());",
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [42; 256] };",
          "    let result = hashmap.get('\\u{00A0}');",
          "    assert_eq!(result, 42);",
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{0100}');",
          "    assert_eq!(result, Default::default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{FFFF}');",
          "}"
        ],
        "oracle": [
          "    let hashmap = HybridGrowingHashmapChar {",
          "    map: GrowingHashmapChar {",
          "    used: 0,",
          "    fill: 0,",
          "    mask: 0,",
          "    map: None,",
          "    },",
          "    extended_ascii: [0; 256],",
          "    };",
          "    let result = hashmap.get('\\u{FFFF}');",
          "    assert!(result.is_default());"
        ],
        "code": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{FFFF}');",
          "    let hashmap = HybridGrowingHashmapChar {",
          "    map: GrowingHashmapChar {",
          "    used: 0,",
          "    fill: 0,",
          "    mask: 0,",
          "    map: None,",
          "    },",
          "    extended_ascii: [0; 256],",
          "    };",
          "    let result = hashmap.get('\\u{FFFF}');",
          "    assert!(result.is_default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{10000}');",
          "}"
        ],
        "oracle": [
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{10000}');",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err(), StrSimError::OutOfBounds);",
          "    let hashmap_with_data = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 1, fill: 1, mask: 1, map: Some(vec![GrowingHashmapMapElemChar { key: 65536, value: 42 }]), }, extended_ascii: [0; 256] };",
          "    let result = hashmap_with_data.get('\\u{10000}');",
          "    assert_eq!(result, 42);"
        ],
        "code": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{10000}');",
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{10000}');",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err(), StrSimError::OutOfBounds);",
          "    let hashmap_with_data = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 1, fill: 1, mask: 1, map: Some(vec![GrowingHashmapMapElemChar { key: 65536, value: 42 }]), }, extended_ascii: [0; 256] };",
          "    let result = hashmap_with_data.get('\\u{10000}');",
          "    assert_eq!(result, 42);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{20000}');",
          "}"
        ],
        "oracle": [
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{20000}');",
          "    assert_eq!(result, Default::default());"
        ],
        "code": [
          "{",
          "    let hashmap = HybridGrowingHashmapChar {",
          "        map: GrowingHashmapChar {",
          "            used: 0,",
          "            fill: 0,",
          "            mask: 0,",
          "            map: None,",
          "        },",
          "        extended_ascii: [0; 256],",
          "    };",
          "    let _ = hashmap.get('\\u{20000}');",
          "    let hashmap = HybridGrowingHashmapChar { map: GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None }, extended_ascii: [0; 256] };",
          "    let result = hashmap.get('\\u{20000}');",
          "    assert_eq!(result, Default::default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]