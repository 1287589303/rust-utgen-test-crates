{
  "name": "serde::__private::de::content::{impl#27}::tuple_variant",
  "mod_info": {
    "name": "__private::de::content",
    "loc": "serde/src/private/de.rs:198:1:2358:2"
  },
  "visible": true,
  "loc": "serde/src/private/de.rs:2197:9:2218:10",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.value matches Some(other) or Some(Content::Seq(v)) at line 2201 is true\n",
        "precondition: self.value matches Some(other) at line 2209 is false\n",
        "precondition: self.value matches None at line 2213 is false\n",
        "precondition: self.value matches Some(Content::Seq(v)) at line 2208 is false\n",
        "precondition: self.value matches Some(other) at line 2201 is true\n",
        "expected return value/type: Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"tuple variant\",\n                ))\n"
      ],
      "input_infer": "self.value = Some(Content::Map(vec![(Content::String(\"key\".to_string()), Content::U32(1))]))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct VisitorImpl;",
                "",
                "    impl<'de> de::Visitor<'de> for VisitorImpl {",
                "        type Value = ();",
                "",
                "        fn visit_seq<V>(self, _seq: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let content = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U32(1))]);",
                "    let deserializer = VariantRefDeserializer {",
                "        value: Some(&content),",
                "        err: PhantomData,",
                "    };",
                "",
                "    let visitor = VisitorImpl;",
                "    let _result = deserializer.tuple_variant(2, visitor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(de::Error::invalid_type(other.unexpected(), &\"tuple variant\")));",
                "    assert!(matches!(deserializer.value, Some(Content::Map(_))));",
                "    assert!(deserializer.value.is_some());",
                "    assert_ne!(deserializer.value, Some(Content::Seq(vec![])));",
                "    assert_ne!(deserializer.value, None);",
                "    assert!(matches!(content, Content::Map(_)));"
              ],
              "code": [
                "{",
                "    struct VisitorImpl;",
                "",
                "    impl<'de> de::Visitor<'de> for VisitorImpl {",
                "        type Value = ();",
                "",
                "        fn visit_seq<V>(self, _seq: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let content = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U32(1))]);",
                "    let deserializer = VariantRefDeserializer {",
                "        value: Some(&content),",
                "        err: PhantomData,",
                "    };",
                "",
                "    let visitor = VisitorImpl;",
                "    let _result = deserializer.tuple_variant(2, visitor);",
                "    assert_eq!(_result, Err(de::Error::invalid_type(other.unexpected(), &\"tuple variant\")));",
                "    assert!(matches!(deserializer.value, Some(Content::Map(_))));",
                "    assert!(deserializer.value.is_some());",
                "    assert_ne!(deserializer.value, Some(Content::Seq(vec![])));",
                "    assert_ne!(deserializer.value, None);",
                "    assert!(matches!(content, Content::Map(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct VisitorImpl;",
                "",
                "    impl<'de> de::Visitor<'de> for VisitorImpl {",
                "        type Value = ();",
                "",
                "        fn visit_seq<V>(self, _seq: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let content = Content::String(\"not a sequence\".to_string());",
                "    let deserializer = VariantRefDeserializer {",
                "        value: Some(&content),",
                "        err: PhantomData,",
                "    };",
                "",
                "    let visitor = VisitorImpl;",
                "    let _result = deserializer.tuple_variant(1, visitor);",
                "}"
              ],
              "oracle": [
                "    let content = Content::String(\"not a sequence\".to_string());",
                "    let deserializer = VariantRefDeserializer {",
                "    value: Some(&content),",
                "    err: PhantomData,",
                "    };",
                "    assert_eq!(deserializer.tuple_variant(1, VisitorImpl), Err(de::Error::invalid_type(Unexpected::Str(\"not a sequence\"), &\"tuple variant\")));"
              ],
              "code": [
                "{",
                "    struct VisitorImpl;",
                "",
                "    impl<'de> de::Visitor<'de> for VisitorImpl {",
                "        type Value = ();",
                "",
                "        fn visit_seq<V>(self, _seq: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let content = Content::String(\"not a sequence\".to_string());",
                "    let deserializer = VariantRefDeserializer {",
                "        value: Some(&content),",
                "        err: PhantomData,",
                "    };",
                "",
                "    let visitor = VisitorImpl;",
                "    let _result = deserializer.tuple_variant(1, visitor);",
                "    let content = Content::String(\"not a sequence\".to_string());",
                "    let deserializer = VariantRefDeserializer {",
                "    value: Some(&content),",
                "    err: PhantomData,",
                "    };",
                "    assert_eq!(deserializer.tuple_variant(1, VisitorImpl), Err(de::Error::invalid_type(Unexpected::Str(\"not a sequence\"), &\"tuple variant\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.value matches Some(other) or Some(Content::Seq(v)) at line 2201 is true\n",
        "precondition: self.value matches  at line 2201 is true\n",
        "precondition: self.value matches Some(Content::Seq(v)) at line 2201 is true\n"
      ],
      "input_infer": "self.value must be Some(Content::Seq(vec![Content::U32(0), Content::Bool(true), Content::F64(3.14)])) or Some(Content::Seq(vec![Content::Str(\"test\"), Content::Bytes(vec![1, 2, 3])])) or None\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl<'de> de::Visitor<'de> for DummyVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let value = Some(Content::Seq(vec![",
                "        Content::U32(0),",
                "        Content::Bool(true),",
                "        Content::F64(3.14),",
                "    ]));",
                "    let deserializer = VariantRefDeserializer {",
                "        value,",
                "        err: PhantomData,",
                "    };",
                "    let visitor = DummyVisitor;",
                "    let _ = deserializer.tuple_variant(3, visitor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(deserializer.tuple_variant(3, visitor), Ok(()));",
                "    assert!(deserializer.value.is_some());",
                "    assert!(matches!(deserializer.value, Some(Content::Seq(_))));",
                "    assert!(deserializer.value.unwrap().as_seq().is_some());",
                "    assert!(matches!(deserializer.tuple_variant(3, visitor), Ok(())));",
                "    assert!(matches!(deserializer.tuple_variant(2, visitor), Err(_)));",
                "    assert!(matches!(deserializer.tuple_variant(3, DummyVisitor), Ok(())));",
                "    assert!(matches!(deserializer.tuple_variant(0, visitor), Err(_)));",
                "    assert!(matches!(deserializer.tuple_variant(5, visitor), Err(_)));"
              ],
              "code": [
                "{",
                "    struct DummyVisitor;",
                "    impl<'de> de::Visitor<'de> for DummyVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let value = Some(Content::Seq(vec![",
                "        Content::U32(0),",
                "        Content::Bool(true),",
                "        Content::F64(3.14),",
                "    ]));",
                "    let deserializer = VariantRefDeserializer {",
                "        value,",
                "        err: PhantomData,",
                "    };",
                "    let visitor = DummyVisitor;",
                "    let _ = deserializer.tuple_variant(3, visitor);",
                "    assert_eq!(deserializer.tuple_variant(3, visitor), Ok(()));",
                "    assert!(deserializer.value.is_some());",
                "    assert!(matches!(deserializer.value, Some(Content::Seq(_))));",
                "    assert!(deserializer.value.unwrap().as_seq().is_some());",
                "    assert!(matches!(deserializer.tuple_variant(3, visitor), Ok(())));",
                "    assert!(matches!(deserializer.tuple_variant(2, visitor), Err(_)));",
                "    assert!(matches!(deserializer.tuple_variant(3, DummyVisitor), Ok(())));",
                "    assert!(matches!(deserializer.tuple_variant(0, visitor), Err(_)));",
                "    assert!(matches!(deserializer.tuple_variant(5, visitor), Err(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl<'de> de::Visitor<'de> for DummyVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let value = Some(Content::Seq(vec![",
                "        Content::Str(\"test\"),",
                "        Content::Bytes(vec![1, 2, 3]),",
                "    ]));",
                "    let deserializer = VariantRefDeserializer {",
                "        value,",
                "        err: PhantomData,",
                "    };",
                "    let visitor = DummyVisitor;",
                "    let _ = deserializer.tuple_variant(2, visitor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(deserializer.tuple_variant(2, visitor).is_ok(), true);",
                "    assert!(matches!(deserializer.tuple_variant(2, visitor), Ok(())));",
                "    assert!(deserializer.tuple_variant(2, visitor).is_ok());",
                "    assert!(deserializer.value.is_some());",
                "    assert!(matches!(deserializer.value, Some(Content::Seq(_))));",
                "    assert!(matches!(deserializer.value, Some(Content::Seq(vec![Content::Str(\"test\"), Content::Bytes(vec![1, 2, 3])]))));",
                "    assert!(deserializer.tuple_variant(1, visitor).is_err());",
                "    assert_eq!(deserializer.tuple_variant(0, visitor).is_err(), true);",
                "    assert!(deserializer.tuple_variant(2, visitor).is_ok());",
                "    assert!(deserializer.tuple_variant(3, visitor).is_err());"
              ],
              "code": [
                "{",
                "    struct DummyVisitor;",
                "    impl<'de> de::Visitor<'de> for DummyVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let value = Some(Content::Seq(vec![",
                "        Content::Str(\"test\"),",
                "        Content::Bytes(vec![1, 2, 3]),",
                "    ]));",
                "    let deserializer = VariantRefDeserializer {",
                "        value,",
                "        err: PhantomData,",
                "    };",
                "    let visitor = DummyVisitor;",
                "    let _ = deserializer.tuple_variant(2, visitor);",
                "    assert_eq!(deserializer.tuple_variant(2, visitor).is_ok(), true);",
                "    assert!(matches!(deserializer.tuple_variant(2, visitor), Ok(())));",
                "    assert!(deserializer.tuple_variant(2, visitor).is_ok());",
                "    assert!(deserializer.value.is_some());",
                "    assert!(matches!(deserializer.value, Some(Content::Seq(_))));",
                "    assert!(matches!(deserializer.value, Some(Content::Seq(vec![Content::Str(\"test\"), Content::Bytes(vec![1, 2, 3])]))));",
                "    assert!(deserializer.tuple_variant(1, visitor).is_err());",
                "    assert_eq!(deserializer.tuple_variant(0, visitor).is_err(), true);",
                "    assert!(deserializer.tuple_variant(2, visitor).is_ok());",
                "    assert!(deserializer.tuple_variant(3, visitor).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl<'de> de::Visitor<'de> for DummyVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let value: Option<Content> = None;",
                "    let deserializer = VariantRefDeserializer {",
                "        value,",
                "        err: PhantomData,",
                "    };",
                "    let visitor = DummyVisitor;",
                "    let _ = deserializer.tuple_variant(0, visitor);",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(deserializer.value, Some(Content::Seq(_))));",
                "    assert!(matches!(deserializer.value, Some(other) if other != Content::Seq(vec![])));",
                "    assert_eq!(deserializer.tuple_variant(0, visitor).is_err(), true);",
                "    assert!(deserializer.tuple_variant(1, visitor).is_err());",
                "    assert!(deserializer.tuple_variant(0, visitor).unwrap_err().unexpected(), &other.unexpected());",
                "    assert_eq!(deserializer.tuple_variant(0, visitor).unwrap_err().unexpected(), Unexpected::UnitVariant);"
              ],
              "code": [
                "{",
                "    struct DummyVisitor;",
                "    impl<'de> de::Visitor<'de> for DummyVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let value: Option<Content> = None;",
                "    let deserializer = VariantRefDeserializer {",
                "        value,",
                "        err: PhantomData,",
                "    };",
                "    let visitor = DummyVisitor;",
                "    let _ = deserializer.tuple_variant(0, visitor);",
                "    assert!(matches!(deserializer.value, Some(Content::Seq(_))));",
                "    assert!(matches!(deserializer.value, Some(other) if other != Content::Seq(vec![])));",
                "    assert_eq!(deserializer.tuple_variant(0, visitor).is_err(), true);",
                "    assert!(deserializer.tuple_variant(1, visitor).is_err());",
                "    assert!(deserializer.tuple_variant(0, visitor).unwrap_err().unexpected(), &other.unexpected());",
                "    assert_eq!(deserializer.tuple_variant(0, visitor).unwrap_err().unexpected(), Unexpected::UnitVariant);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: self.value matches None at line 2201 is true\n",
        "expected return value/type: Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    &\"tuple variant\",\n                ))\n"
      ],
      "input_infer": "self.value = None\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestVisitor;",
                "    impl<'de> de::Visitor<'de> for TestVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _seq: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "    }",
                "    ",
                "    struct TestVariantAccess<'a, 'de> {",
                "        value: Option<&'a Content<'de>>,",
                "    }",
                "    ",
                "    impl<'de, 'a> de::VariantAccess<'de> for TestVariantAccess<'a, 'de> {",
                "        type Error = de::Error;",
                "        fn unit_variant(self) -> Result<(), Self::Error> { unimplemented!() }",
                "        fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error> ",
                "        where T: de::DeserializeSeed<'de> {",
                "            unimplemented!()",
                "        }",
                "        fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error> ",
                "        where V: de::Visitor<'de> {",
                "            match self.value {",
                "                Some(_) => unreachable!(),",
                "                None => Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"tuple variant\")),",
                "            }",
                "        }",
                "        fn struct_variant<V>(self, _fields: &'static [&'static str], visitor: V) -> Result<V::Value, Self::Error>",
                "        where V: de::Visitor<'de> {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let deserializer = TestVariantAccess { value: None };",
                "    let visitor = TestVisitor;",
                "    let _result = deserializer.tuple_variant(0, visitor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"tuple variant\")));"
              ],
              "code": [
                "{",
                "    struct TestVisitor;",
                "    impl<'de> de::Visitor<'de> for TestVisitor {",
                "        type Value = ();",
                "        fn visit_seq<V>(self, _seq: V) -> Result<Self::Value, V::Error>",
                "        where",
                "            V: de::SeqAccess<'de>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "    }",
                "    ",
                "    struct TestVariantAccess<'a, 'de> {",
                "        value: Option<&'a Content<'de>>,",
                "    }",
                "    ",
                "    impl<'de, 'a> de::VariantAccess<'de> for TestVariantAccess<'a, 'de> {",
                "        type Error = de::Error;",
                "        fn unit_variant(self) -> Result<(), Self::Error> { unimplemented!() }",
                "        fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error> ",
                "        where T: de::DeserializeSeed<'de> {",
                "            unimplemented!()",
                "        }",
                "        fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error> ",
                "        where V: de::Visitor<'de> {",
                "            match self.value {",
                "                Some(_) => unreachable!(),",
                "                None => Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"tuple variant\")),",
                "            }",
                "        }",
                "        fn struct_variant<V>(self, _fields: &'static [&'static str], visitor: V) -> Result<V::Value, Self::Error>",
                "        where V: de::Visitor<'de> {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let deserializer = TestVariantAccess { value: None };",
                "    let visitor = TestVisitor;",
                "    let _result = deserializer.tuple_variant(0, visitor);",
                "    assert_eq!(_result, Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"tuple variant\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}