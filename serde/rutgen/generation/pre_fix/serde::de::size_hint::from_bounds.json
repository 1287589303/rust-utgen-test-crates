{
  "name": "serde::de::size_hint::from_bounds",
  "mod_info": {
    "name": "de::size_hint",
    "loc": "serde/src/de/mod.rs:123:1:123:26"
  },
  "visible": true,
  "loc": "serde/src/de/size_hint.rs:4:1:9:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "iter.size_hint() should return a tuple (lower, Some(upper)) where lower and upper are equal for a return value of Some(upper), or a tuple (lower, None) or (lower, Some(upper)) where lower is not equal to upper for a return value of None; test cases should include (0, Some(0)), (1, Some(1)), (2, Some(2)), (5, Some(5)), (3, None), and (0, None).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (0, Some(0))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 0 };",
                "    let result = from_bounds(&iter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (0, Some(0))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 0 };",
                "    let result = from_bounds(&iter);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (1, Some(1))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 1 };",
                "    let result = from_bounds(&iter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Some(1));"
              ],
              "code": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (1, Some(1))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 1 };",
                "    let result = from_bounds(&iter);",
                "    assert_eq!(result, Some(1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (2, Some(2))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 2 };",
                "    let result = from_bounds(&iter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Some(2));"
              ],
              "code": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (2, Some(2))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 2 };",
                "    let result = from_bounds(&iter);",
                "    assert_eq!(result, Some(2));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (5, Some(5))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 5 };",
                "    let result = from_bounds(&iter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(from_bounds(&EqualBoundsIter { count: 5 }), Some(5));"
              ],
              "code": [
                "{",
                "    struct EqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for EqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (5, Some(5))",
                "        }",
                "    }",
                "",
                "    let iter = EqualBoundsIter { count: 5 };",
                "    let result = from_bounds(&iter);",
                "    assert_eq!(from_bounds(&EqualBoundsIter { count: 5 }), Some(5));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NotEqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for NotEqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (3, None)",
                "        }",
                "    }",
                "",
                "    let iter = NotEqualBoundsIter { count: 3 };",
                "    let result = from_bounds(&iter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    struct NotEqualBoundsIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for NotEqualBoundsIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (3, None)",
                "        }",
                "    }",
                "",
                "    let iter = NotEqualBoundsIter { count: 3 };",
                "    let result = from_bounds(&iter);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct ZeroNoneIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for ZeroNoneIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (0, None)",
                "        }",
                "    }",
                "",
                "    let iter = ZeroNoneIter { count: 0 };",
                "    let result = from_bounds(&iter);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    struct ZeroNoneIter {",
                "        count: usize,",
                "    }",
                "",
                "    impl Iterator for ZeroNoneIter {",
                "        type Item = usize;",
                "",
                "        fn next(&mut self) -> Option<Self::Item> {",
                "            if self.count > 0 {",
                "                self.count -= 1;",
                "                Some(0)",
                "            } else {",
                "                None",
                "            }",
                "        }",
                "",
                "        fn size_hint(&self) -> (usize, Option<usize>) {",
                "            (0, None)",
                "        }",
                "    }",
                "",
                "    let iter = ZeroNoneIter { count: 0 };",
                "    let result = from_bounds(&iter);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}