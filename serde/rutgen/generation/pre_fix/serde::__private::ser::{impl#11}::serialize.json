{
  "name": "serde::__private::ser::{impl#11}::serialize",
  "mod_info": {
    "name": "__private::ser",
    "loc": "serde/src/private/mod.rs:4:1:4:13"
  },
  "visible": true,
  "loc": "serde/src/private/ser.rs:1343:5:1348:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "enum_name: non-empty static string, variant_index: valid u32 (0 to maximum u32), variant_name: non-empty static string\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = AdjacentlyTaggedEnumVariant {",
                "        enum_name: \"TestEnum\",",
                "        variant_index: 0,",
                "        variant_name: \"VariantA\",",
                "    };",
                "    let mock_serializer = MockSerializer::new();",
                "    let _ = variant.serialize(mock_serializer);",
                "}"
              ],
              "oracle": [
                "    assert!(_is_ok());",
                "    assert_eq!(mock_serializer.enum_name, \"TestEnum\");",
                "    assert_eq!(mock_serializer.variant_index, 0);",
                "    assert_eq!(mock_serializer.variant_name, \"VariantA\");",
                "    assert!(mock_serializer.called_serialize_unit_variant);"
              ],
              "code": [
                "{",
                "    let variant = AdjacentlyTaggedEnumVariant {",
                "        enum_name: \"TestEnum\",",
                "        variant_index: 0,",
                "        variant_name: \"VariantA\",",
                "    };",
                "    let mock_serializer = MockSerializer::new();",
                "    let _ = variant.serialize(mock_serializer);",
                "    assert!(_is_ok());",
                "    assert_eq!(mock_serializer.enum_name, \"TestEnum\");",
                "    assert_eq!(mock_serializer.variant_index, 0);",
                "    assert_eq!(mock_serializer.variant_name, \"VariantA\");",
                "    assert!(mock_serializer.called_serialize_unit_variant);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = AdjacentlyTaggedEnumVariant {",
                "        enum_name: \"TestEnum\",",
                "        variant_index: u32::MAX,",
                "        variant_name: \"VariantMax\",",
                "    };",
                "    let mock_serializer = MockSerializer::new();",
                "    let _ = variant.serialize(mock_serializer);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(variant.enum_name, \"TestEnum\");",
                "    assert_eq!(variant.variant_index, u32::MAX);",
                "    assert_eq!(variant.variant_name, \"VariantMax\");",
                "    assert!(mock_serializer.serialized_unit_variant_called);",
                "    assert_eq!(mock_serializer.last_serialized_enum_name, \"TestEnum\");",
                "    assert_eq!(mock_serializer.last_serialized_variant_index, u32::MAX);",
                "    assert_eq!(mock_serializer.last_serialized_variant_name, \"VariantMax\");"
              ],
              "code": [
                "{",
                "    let variant = AdjacentlyTaggedEnumVariant {",
                "        enum_name: \"TestEnum\",",
                "        variant_index: u32::MAX,",
                "        variant_name: \"VariantMax\",",
                "    };",
                "    let mock_serializer = MockSerializer::new();",
                "    let _ = variant.serialize(mock_serializer);",
                "    assert_eq!(variant.enum_name, \"TestEnum\");",
                "    assert_eq!(variant.variant_index, u32::MAX);",
                "    assert_eq!(variant.variant_name, \"VariantMax\");",
                "    assert!(mock_serializer.serialized_unit_variant_called);",
                "    assert_eq!(mock_serializer.last_serialized_enum_name, \"TestEnum\");",
                "    assert_eq!(mock_serializer.last_serialized_variant_index, u32::MAX);",
                "    assert_eq!(mock_serializer.last_serialized_variant_name, \"VariantMax\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = AdjacentlyTaggedEnumVariant {",
                "        enum_name: \"AnotherEnum\",",
                "        variant_index: 1,",
                "        variant_name: \"VariantB\",",
                "    };",
                "    let mock_serializer = MockSerializer::new();",
                "    let _ = variant.serialize(mock_serializer);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(variant.enum_name, \"AnotherEnum\");",
                "    assert_eq!(variant.variant_index, 1);",
                "    assert_eq!(variant.variant_name, \"VariantB\");",
                "    assert!(mock_serializer.is_called());",
                "    assert_eq!(mock_serializer.last_serialized_unit_variant().unwrap(), (\"AnotherEnum\", 1, \"VariantB\"));"
              ],
              "code": [
                "{",
                "    let variant = AdjacentlyTaggedEnumVariant {",
                "        enum_name: \"AnotherEnum\",",
                "        variant_index: 1,",
                "        variant_name: \"VariantB\",",
                "    };",
                "    let mock_serializer = MockSerializer::new();",
                "    let _ = variant.serialize(mock_serializer);",
                "    assert_eq!(variant.enum_name, \"AnotherEnum\");",
                "    assert_eq!(variant.variant_index, 1);",
                "    assert_eq!(variant.variant_name, \"VariantB\");",
                "    assert!(mock_serializer.is_called());",
                "    assert_eq!(mock_serializer.last_serialized_unit_variant().unwrap(), (\"AnotherEnum\", 1, \"VariantB\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}