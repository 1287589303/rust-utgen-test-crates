{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/de/impls.rs\n// crate name is serde\nuse crate::lib::*;\nuse crate::de::{\n    Deserialize, Deserializer, EnumAccess, Error, MapAccess, SeqAccess, Unexpected,\n    VariantAccess, Visitor,\n};\nuse crate::seed::InPlaceSeed;\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse crate::de::size_hint;\n#[cfg_attr(\n    not(no_diagnostic_namespace),\n    diagnostic::on_unimplemented(\n        note = \"for local types consider adding `#[derive(serde::Deserialize)]` to your `{Self}` type\",\n        note = \"for types from other crates check whether the crate offers a `serde` feature flag\",\n    )\n)]\npub trait Deserialize<'de>: Sized {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>;\n    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        *place = tri!(Deserialize::deserialize(deserializer));\n        Ok(())\n    }\n}\npub trait IntoDeserializer<'de, E: Error = value::Error> {\n    type Deserializer: Deserializer<'de, Error = E>;\n    fn into_deserializer(self) -> Self::Deserializer;\n}\npub trait Serializer: Sized {\n    type Ok;\n    type Error: Error;\n    type SerializeSeq: SerializeSeq<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeTuple: SerializeTuple<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeTupleStruct: SerializeTupleStruct<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeTupleVariant: SerializeTupleVariant<\n            Ok = Self::Ok,\n            Error = Self::Error,\n        >;\n    type SerializeMap: SerializeMap<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeStruct: SerializeStruct<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeStructVariant: SerializeStructVariant<\n            Ok = Self::Ok,\n            Error = Self::Error,\n        >;\n    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i128(self, v: i128) -> Result<Self::Ok, Self::Error> {\n        let _ = v;\n        Err(Error::custom(\"i128 is not supported\"))\n    }\n    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u128(self, v: u128) -> Result<Self::Ok, Self::Error> {\n        let _ = v;\n        Err(Error::custom(\"u128 is not supported\"))\n    }\n    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error>;\n    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error>;\n    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error>;\n    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error>;\n    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error>;\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error>;\n    fn serialize_some<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error>;\n    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error>;\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error>;\n    fn serialize_newtype_struct<T>(\n        self,\n        name: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_newtype_variant<T>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_seq(\n        self,\n        len: Option<usize>,\n    ) -> Result<Self::SerializeSeq, Self::Error>;\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error>;\n    fn serialize_tuple_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error>;\n    fn serialize_tuple_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error>;\n    fn serialize_map(\n        self,\n        len: Option<usize>,\n    ) -> Result<Self::SerializeMap, Self::Error>;\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error>;\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error>;\n    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n    where\n        I: IntoIterator,\n        <I as IntoIterator>::Item: Serialize,\n    {\n        let mut iter = iter.into_iter();\n        let mut serializer = tri!(self.serialize_seq(iterator_len_hint(& iter)));\n        tri!(iter.try_for_each(| item | serializer.serialize_element(& item)));\n        serializer.end()\n    }\n    fn collect_map<K, V, I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n    where\n        K: Serialize,\n        V: Serialize,\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let mut iter = iter.into_iter();\n        let mut serializer = tri!(self.serialize_map(iterator_len_hint(& iter)));\n        tri!(\n            iter.try_for_each(| (key, value) | serializer.serialize_entry(& key, &\n            value))\n        );\n        serializer.end()\n    }\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn collect_str<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Display,\n    {\n        self.serialize_str(&value.to_string())\n    }\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Display;\n    #[inline]\n    fn is_human_readable(&self) -> bool;\n}\npub trait MapAccess<'de> {\n    type Error: Error;\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n    where\n        K: DeserializeSeed<'de>;\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n    where\n        V: DeserializeSeed<'de>;\n    #[inline]\n    fn next_entry_seed<K, V>(\n        &mut self,\n        kseed: K,\n        vseed: V,\n    ) -> Result<Option<(K::Value, V::Value)>, Self::Error>\n    where\n        K: DeserializeSeed<'de>,\n        V: DeserializeSeed<'de>,\n    {\n        match tri!(self.next_key_seed(kseed)) {\n            Some(key) => {\n                let value = tri!(self.next_value_seed(vseed));\n                Ok(Some((key, value)))\n            }\n            None => Ok(None),\n        }\n    }\n    #[inline]\n    fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n    where\n        K: Deserialize<'de>,\n    {\n        self.next_key_seed(PhantomData)\n    }\n    #[inline]\n    fn next_value<V>(&mut self) -> Result<V, Self::Error>\n    where\n        V: Deserialize<'de>,\n    {\n        self.next_value_seed(PhantomData)\n    }\n    #[inline]\n    fn next_entry<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n    where\n        K: Deserialize<'de>,\n        V: Deserialize<'de>,\n    {\n        self.next_entry_seed(PhantomData, PhantomData)\n    }\n    #[inline]\n    fn size_hint(&self) -> Option<usize>;\n}\npub trait IdentifierDeserializer<'de, E: Error> {\n    type Deserializer: Deserializer<'de, Error = E>;\n    fn from(self) -> Self::Deserializer;\n}\npub trait SeqAccess<'de> {\n    type Error: Error;\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: DeserializeSeed<'de>;\n    #[inline]\n    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n    where\n        T: Deserialize<'de>,\n    {\n        self.next_element_seed(PhantomData)\n    }\n    #[inline]\n    fn size_hint(&self) -> Option<usize>;\n}\npub trait DeserializeSeed<'de>: Sized {\n    type Value;\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>;\n}\npub trait Expected {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n}\npub trait Pair {\n    type First;\n    type Second;\n    fn split(self) -> (Self::First, Self::Second);\n}\n#[cfg_attr(\n    not(no_diagnostic_namespace),\n    diagnostic::on_unimplemented(\n        note = \"for local types consider adding `#[derive(serde::Serialize)]` to your `{Self}` type\",\n        note = \"for types from other crates check whether the crate offers a `serde` feature flag\",\n    )\n)]\npub trait Serialize {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer;\n}\nimpl<'de, T> Deserialize<'de> for Wrapping<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        Deserialize::deserialize(deserializer).map(Wrapping)\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n2273 fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n2274 where\n2275     D: Deserializer<'de>,\n2276 {\n2277     // Reuse duration\n2278     enum Field {\n2279         Secs,\n2280         Nanos,\n2281     }\n2282 \n2283     impl<'de> Deserialize<'de> for Field {\n2284         fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n2285         where\n2286             D: Deserializer<'de>,\n2287         {\n2288             struct FieldVisitor;\n2289 \n2290             impl<'de> Visitor<'de> for FieldVisitor {\n2291                 type Value = Field;\n2292 \n2293                 fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n2294                     formatter.write_str(\"`secs_since_epoch` or `nanos_since_epoch`\")\n2295                 }\n2296 \n2297                 fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n2298                 where\n2299                     E: Error,\n2300                 {\n2301                     match value {\n2302                         \"secs_since_epoch\" => Ok(Field::Secs),\n2303                         \"nanos_since_epoch\" => Ok(Field::Nanos),\n2304                         _ => Err(Error::unknown_field(value, FIELDS)),\n2305                     }\n2306                 }\n2307 \n2308                 fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n2309                 where\n2310                     E: Error,\n2311                 {\n2312                     match value {\n2313                         b\"secs_since_epoch\" => Ok(Field::Secs),\n2314                         b\"nanos_since_epoch\" => Ok(Field::Nanos),\n2315                         _ => {\n2316                             let value = String::from_utf8_lossy(value);\n2317                             Err(Error::unknown_field(&value, FIELDS))\n2318                         }\n2319                     }\n2320                 }\n2321             }\n2322 \n2323             deserializer.deserialize_identifier(FieldVisitor)\n2324         }\n2325     }\n2326 \n2327     fn check_overflow<E>(secs: u64, nanos: u32) -> Result<(), E>\n2328     where\n2329         E: Error,\n2330     {\n2331         static NANOS_PER_SEC: u32 = 1_000_000_000;\n2332         match secs.checked_add((nanos / NANOS_PER_SEC) as u64) {\n2333             Some(_) => Ok(()),\n2334             None => Err(E::custom(\"overflow deserializing SystemTime epoch offset\")),\n2335         }\n2336     }\n2337 \n2338     struct DurationVisitor;\n2339 \n2340     impl<'de> Visitor<'de> for DurationVisitor {\n2341         type Value = Duration;\n2342 \n2343         fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n2344             formatter.write_str(\"struct SystemTime\")\n2345         }\n2346 \n2347         fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n2348         where\n2349             A: SeqAccess<'de>,\n2350         {\n2351             let secs: u64 = match tri!(seq.next_element()) {\n2352                 Some(value) => value,\n2353                 None => {\n2354                     return Err(Error::invalid_length(0, &self));\n2355                 }\n2356             };\n2357             let nanos: u32 = match tri!(seq.next_element()) {\n2358                 Some(value) => value,\n2359                 None => {\n2360                     return Err(Error::invalid_length(1, &self));\n2361                 }\n2362             };\n2363             tri!(check_overflow(secs, nanos));\n2364             Ok(Duration::new(secs, nanos))\n2365         }\n2366 \n2367         fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n2368         where\n2369             A: MapAccess<'de>,\n2370         {\n2371             let mut secs: Option<u64> = None;\n2372             let mut nanos: Option<u32> = None;\n2373             while let Some(key) = tri!(map.next_key()) {\n2374                 match key {\n2375                     Field::Secs => {\n2376                         if secs.is_some() {\n2377                             return Err(<A::Error as Error>::duplicate_field(\n2378                                 \"secs_since_epoch\",\n2379                             ));\n2380                         }\n2381                         secs = Some(tri!(map.next_value()));\n2382                     }\n2383                     Field::Nanos => {\n2384                         if nanos.is_some() {\n2385                             return Err(<A::Error as Error>::duplicate_field(\n2386                                 \"nanos_since_epoch\",\n2387                             ));\n2388                         }\n2389                         nanos = Some(tri!(map.next_value()));\n2390                     }\n2391                 }\n2392             }\n2393             let secs = match secs {\n2394                 Some(secs) => secs,\n2395                 None => return Err(<A::Error as Error>::missing_field(\"secs_since_epoch\")),\n2396             };\n2397             let nanos = match nanos {\n2398                 Some(nanos) => nanos,\n2399                 None => return Err(<A::Error as Error>::missing_field(\"nanos_since_epoch\")),\n2400             };\n2401             tri!(check_overflow(secs, nanos));\n2402             Ok(Duration::new(secs, nanos))\n2403         }\n2404     }\n2405 \n2406     const FIELDS: &[&str] = &[\"secs_since_epoch\", \"nanos_since_epoch\"];\n2407     let duration = tri!(deserializer.deserialize_struct(\"SystemTime\", FIELDS, DurationVisitor));\n2408     UNIX_EPOCH\n2409         .checked_add(duration)\n2410         .ok_or_else(|| D::Error::custom(\"overflow deserializing SystemTime\"))\n2411 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}