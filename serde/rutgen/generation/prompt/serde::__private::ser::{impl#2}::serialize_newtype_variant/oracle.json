{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/private/ser.rs\n// crate name is serde\nuse crate::lib::*;\nuse crate::ser::{self, Impossible, Serialize, SerializeMap, SerializeStruct, Serializer};\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse self::content::{\n    Content, ContentSerializer, SerializeStructVariantAsMapValue,\n    SerializeTupleVariantAsMapValue,\n};\npub trait Serializer: Sized {\n    type Ok;\n    type Error: Error;\n    type SerializeSeq: SerializeSeq<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeTuple: SerializeTuple<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeTupleStruct: SerializeTupleStruct<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeTupleVariant: SerializeTupleVariant<\n            Ok = Self::Ok,\n            Error = Self::Error,\n        >;\n    type SerializeMap: SerializeMap<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeStruct: SerializeStruct<Ok = Self::Ok, Error = Self::Error>;\n    type SerializeStructVariant: SerializeStructVariant<\n            Ok = Self::Ok,\n            Error = Self::Error,\n        >;\n    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>;\n    fn serialize_i128(self, v: i128) -> Result<Self::Ok, Self::Error> {\n        let _ = v;\n        Err(Error::custom(\"i128 is not supported\"))\n    }\n    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error>;\n    fn serialize_u128(self, v: u128) -> Result<Self::Ok, Self::Error> {\n        let _ = v;\n        Err(Error::custom(\"u128 is not supported\"))\n    }\n    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error>;\n    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error>;\n    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error>;\n    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error>;\n    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error>;\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error>;\n    fn serialize_some<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error>;\n    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error>;\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error>;\n    fn serialize_newtype_struct<T>(\n        self,\n        name: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_newtype_variant<T>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_seq(\n        self,\n        len: Option<usize>,\n    ) -> Result<Self::SerializeSeq, Self::Error>;\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error>;\n    fn serialize_tuple_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error>;\n    fn serialize_tuple_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error>;\n    fn serialize_map(\n        self,\n        len: Option<usize>,\n    ) -> Result<Self::SerializeMap, Self::Error>;\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error>;\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error>;\n    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n    where\n        I: IntoIterator,\n        <I as IntoIterator>::Item: Serialize,\n    {\n        let mut iter = iter.into_iter();\n        let mut serializer = tri!(self.serialize_seq(iterator_len_hint(& iter)));\n        tri!(iter.try_for_each(| item | serializer.serialize_element(& item)));\n        serializer.end()\n    }\n    fn collect_map<K, V, I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n    where\n        K: Serialize,\n        V: Serialize,\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let mut iter = iter.into_iter();\n        let mut serializer = tri!(self.serialize_map(iterator_len_hint(& iter)));\n        tri!(\n            iter.try_for_each(| (key, value) | serializer.serialize_entry(& key, &\n            value))\n        );\n        serializer.end()\n    }\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn collect_str<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Display,\n    {\n        self.serialize_str(&value.to_string())\n    }\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Display;\n    #[inline]\n    fn is_human_readable(&self) -> bool {\n        true\n    }\n}\npub trait SerializeMap {\n    type Ok;\n    type Error: Error;\n    fn serialize_key<T>(&mut self, key: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_value<T>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + Serialize;\n    fn serialize_entry<K, V>(&mut self, key: &K, value: &V) -> Result<(), Self::Error>\n    where\n        K: ?Sized + Serialize,\n        V: ?Sized + Serialize,\n    {\n        tri!(self.serialize_key(key));\n        self.serialize_value(value)\n    }\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\npub trait SerializeStruct {\n    type Ok;\n    type Error: Error;\n    fn serialize_field<T>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: ?Sized + Serialize;\n    #[inline]\n    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n        let _ = key;\n        Ok(())\n    }\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\nstruct TaggedSerializer<S> {\n    type_ident: &'static str,\n    variant_ident: &'static str,\n    tag: &'static str,\n    variant_name: &'static str,\n    delegate: S,\n}\n#[derive(Debug)]\npub struct Error;\npub struct T;\npub struct SerializeStruct<E> {\n    name: &'static str,\n    fields: Vec<(&'static str, Content)>,\n    error: PhantomData<E>,\n}\npub struct Impossible<Ok, Error> {\n    void: Void,\n    ok: PhantomData<Ok>,\n    error: PhantomData<Error>,\n}\npub struct SerializeTupleVariantAsMapValue<M> {\n    map: M,\n    name: &'static str,\n    fields: Vec<Content>,\n}\n#[derive(Clone, PartialEq)]\npub struct Error {\n    err: ErrorImpl,\n}\npub struct SerializeMap<E> {\n    entries: Vec<(Content, Content)>,\n    key: Option<Content>,\n    error: PhantomData<E>,\n}\npub struct SerializeStructVariantAsMapValue<M> {\n    map: M,\n    name: &'static str,\n    fields: Vec<(&'static str, Content)>,\n}\nimpl<S> Serializer for TaggedSerializer<S>\nwhere\n    S: Serializer,\n{\n    type Ok = S::Ok;\n    type Error = S::Error;\n    type SerializeSeq = Impossible<S::Ok, S::Error>;\n    type SerializeTuple = Impossible<S::Ok, S::Error>;\n    type SerializeTupleStruct = Impossible<S::Ok, S::Error>;\n    type SerializeMap = S::SerializeMap;\n    type SerializeStruct = S::SerializeStruct;\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeTupleVariant = Impossible<S::Ok, S::Error>;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeTupleVariant = SerializeTupleVariantAsMapValue<S::SerializeMap>;\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeStructVariant = Impossible<S::Ok, S::Error>;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeStructVariant = SerializeStructVariantAsMapValue<S::SerializeMap>;\n    fn serialize_bool(self, _: bool) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Boolean))\n    }\n    fn serialize_i8(self, _: i8) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_i16(self, _: i16) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_i32(self, _: i32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_i64(self, _: i64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_u8(self, _: u8) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_u16(self, _: u16) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_u32(self, _: u32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_u64(self, _: u64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n    fn serialize_f32(self, _: f32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Float))\n    }\n    fn serialize_f64(self, _: f64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Float))\n    }\n    fn serialize_char(self, _: char) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Char))\n    }\n    fn serialize_str(self, _: &str) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::String))\n    }\n    fn serialize_bytes(self, _: &[u8]) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::ByteArray))\n    }\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n    fn serialize_some<T>(self, _: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        let mut map = tri!(self.delegate.serialize_map(Some(1)));\n        tri!(map.serialize_entry(self.tag, self.variant_name));\n        map.end()\n    }\n    fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n        let mut map = tri!(self.delegate.serialize_map(Some(1)));\n        tri!(map.serialize_entry(self.tag, self.variant_name));\n        map.end()\n    }\n    fn serialize_unit_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        let mut map = tri!(self.delegate.serialize_map(Some(2)));\n        tri!(map.serialize_entry(self.tag, self.variant_name));\n        tri!(map.serialize_entry(inner_variant, & ()));\n        map.end()\n    }\n    fn serialize_newtype_struct<T>(\n        self,\n        _: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n    fn serialize_newtype_variant<T>(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n        inner_value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Serialize,\n    {\n        let mut map = tri!(self.delegate.serialize_map(Some(2)));\n        tri!(map.serialize_entry(self.tag, self.variant_name));\n        tri!(map.serialize_entry(inner_variant, inner_value));\n        map.end()\n    }\n    fn serialize_seq(self, _: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        Err(self.bad_type(Unsupported::Sequence))\n    }\n    fn serialize_tuple(self, _: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        Err(self.bad_type(Unsupported::Tuple))\n    }\n    fn serialize_tuple_struct(\n        self,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        Err(self.bad_type(Unsupported::TupleStruct))\n    }\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_tuple_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_tuple_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        let mut map = tri!(self.delegate.serialize_map(Some(2)));\n        tri!(map.serialize_entry(self.tag, self.variant_name));\n        tri!(map.serialize_key(inner_variant));\n        Ok(SerializeTupleVariantAsMapValue::new(map, inner_variant, len))\n    }\n    fn serialize_map(\n        self,\n        len: Option<usize>,\n    ) -> Result<Self::SerializeMap, Self::Error> {\n        let mut map = tri!(self.delegate.serialize_map(len.map(| len | len + 1)));\n        tri!(map.serialize_entry(self.tag, self.variant_name));\n        Ok(map)\n    }\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        let mut state = tri!(self.delegate.serialize_struct(name, len + 1));\n        tri!(state.serialize_field(self.tag, self.variant_name));\n        Ok(state)\n    }\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_struct_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_struct_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        let mut map = tri!(self.delegate.serialize_map(Some(2)));\n        tri!(map.serialize_entry(self.tag, self.variant_name));\n        tri!(map.serialize_key(inner_variant));\n        Ok(SerializeStructVariantAsMapValue::new(map, inner_variant, len))\n    }\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str<T>(self, _: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Display,\n    {\n        Err(self.bad_type(Unsupported::String))\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n217 fn serialize_newtype_variant<T>(\n218     self,\n219     _: &'static str,\n220     _: u32,\n221     inner_variant: &'static str,\n222     inner_value: &T,\n223 ) -> Result<Self::Ok, Self::Error>\n224 where\n225     T: ?Sized + Serialize,\n226 {\n227     let mut map = tri!(self.delegate.serialize_map(Some(2)));\n228     tri!(map.serialize_entry(self.tag, self.variant_name));\n229     tri!(map.serialize_entry(inner_variant, inner_value));\n230     map.end()\n231 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}