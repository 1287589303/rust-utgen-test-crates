{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/private/ser.rs\n// crate name is serde\nuse crate::lib::*;\nuse crate::ser::{self, Serialize, Serializer};\n#[cfg_attr(\n    not(no_diagnostic_namespace),\n    diagnostic::on_unimplemented(\n        note = \"for local types consider adding `#[derive(serde::Serialize)]` to your `{Self}` type\",\n        note = \"for types from other crates check whether the crate offers a `serde` feature flag\",\n    )\n)]\npub trait Serialize {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer;\n}\npub enum Content {\n    Bool(bool),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    F32(f32),\n    F64(f64),\n    Char(char),\n    String(String),\n    Bytes(Vec<u8>),\n    None,\n    Some(Box<Content>),\n    Unit,\n    UnitStruct(&'static str),\n    UnitVariant(&'static str, u32, &'static str),\n    NewtypeStruct(&'static str, Box<Content>),\n    NewtypeVariant(&'static str, u32, &'static str, Box<Content>),\n    Seq(Vec<Content>),\n    Tuple(Vec<Content>),\n    TupleStruct(&'static str, Vec<Content>),\n    TupleVariant(&'static str, u32, &'static str, Vec<Content>),\n    Map(Vec<(Content, Content)>),\n    Struct(&'static str, Vec<(&'static str, Content)>),\n    StructVariant(&'static str, u32, &'static str, Vec<(&'static str, Content)>),\n}\n#[derive(Debug, Clone)]\npub enum Content<'de> {\n    Bool(bool),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    F32(f32),\n    F64(f64),\n    Char(char),\n    String(String),\n    Str(&'de str),\n    ByteBuf(Vec<u8>),\n    Bytes(&'de [u8]),\n    None,\n    Some(Box<Content<'de>>),\n    Unit,\n    Newtype(Box<Content<'de>>),\n    Seq(Vec<Content<'de>>),\n    Map(Vec<(Content<'de>, Content<'de>)>),\n}\nimpl Serialize for Content {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match *self {\n            Content::Bool(b) => serializer.serialize_bool(b),\n            Content::U8(u) => serializer.serialize_u8(u),\n            Content::U16(u) => serializer.serialize_u16(u),\n            Content::U32(u) => serializer.serialize_u32(u),\n            Content::U64(u) => serializer.serialize_u64(u),\n            Content::I8(i) => serializer.serialize_i8(i),\n            Content::I16(i) => serializer.serialize_i16(i),\n            Content::I32(i) => serializer.serialize_i32(i),\n            Content::I64(i) => serializer.serialize_i64(i),\n            Content::F32(f) => serializer.serialize_f32(f),\n            Content::F64(f) => serializer.serialize_f64(f),\n            Content::Char(c) => serializer.serialize_char(c),\n            Content::String(ref s) => serializer.serialize_str(s),\n            Content::Bytes(ref b) => serializer.serialize_bytes(b),\n            Content::None => serializer.serialize_none(),\n            Content::Some(ref c) => serializer.serialize_some(&**c),\n            Content::Unit => serializer.serialize_unit(),\n            Content::UnitStruct(n) => serializer.serialize_unit_struct(n),\n            Content::UnitVariant(n, i, v) => serializer.serialize_unit_variant(n, i, v),\n            Content::NewtypeStruct(n, ref c) => {\n                serializer.serialize_newtype_struct(n, &**c)\n            }\n            Content::NewtypeVariant(n, i, v, ref c) => {\n                serializer.serialize_newtype_variant(n, i, v, &**c)\n            }\n            Content::Seq(ref elements) => elements.serialize(serializer),\n            Content::Tuple(ref elements) => {\n                use crate::ser::SerializeTuple;\n                let mut tuple = tri!(serializer.serialize_tuple(elements.len()));\n                for e in elements {\n                    tri!(tuple.serialize_element(e));\n                }\n                tuple.end()\n            }\n            Content::TupleStruct(n, ref fields) => {\n                use crate::ser::SerializeTupleStruct;\n                let mut ts = tri!(serializer.serialize_tuple_struct(n, fields.len()));\n                for f in fields {\n                    tri!(ts.serialize_field(f));\n                }\n                ts.end()\n            }\n            Content::TupleVariant(n, i, v, ref fields) => {\n                use crate::ser::SerializeTupleVariant;\n                let mut tv = tri!(\n                    serializer.serialize_tuple_variant(n, i, v, fields.len())\n                );\n                for f in fields {\n                    tri!(tv.serialize_field(f));\n                }\n                tv.end()\n            }\n            Content::Map(ref entries) => {\n                use crate::ser::SerializeMap;\n                let mut map = tri!(serializer.serialize_map(Some(entries.len())));\n                for (k, v) in entries {\n                    tri!(map.serialize_entry(k, v));\n                }\n                map.end()\n            }\n            Content::Struct(n, ref fields) => {\n                use crate::ser::SerializeStruct;\n                let mut s = tri!(serializer.serialize_struct(n, fields.len()));\n                for &(k, ref v) in fields {\n                    tri!(s.serialize_field(k, v));\n                }\n                s.end()\n            }\n            Content::StructVariant(n, i, v, ref fields) => {\n                use crate::ser::SerializeStructVariant;\n                let mut sv = tri!(\n                    serializer.serialize_struct_variant(n, i, v, fields.len())\n                );\n                for &(k, ref v) in fields {\n                    tri!(sv.serialize_field(k, v));\n                }\n                sv.end()\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n466 fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n467 where\n468     S: Serializer,\n469 {\n470     match *self {\n471         Content::Bool(b) => serializer.serialize_bool(b),\n472         Content::U8(u) => serializer.serialize_u8(u),\n473         Content::U16(u) => serializer.serialize_u16(u),\n474         Content::U32(u) => serializer.serialize_u32(u),\n475         Content::U64(u) => serializer.serialize_u64(u),\n476         Content::I8(i) => serializer.serialize_i8(i),\n477         Content::I16(i) => serializer.serialize_i16(i),\n478         Content::I32(i) => serializer.serialize_i32(i),\n479         Content::I64(i) => serializer.serialize_i64(i),\n480         Content::F32(f) => serializer.serialize_f32(f),\n481         Content::F64(f) => serializer.serialize_f64(f),\n482         Content::Char(c) => serializer.serialize_char(c),\n483         Content::String(ref s) => serializer.serialize_str(s),\n484         Content::Bytes(ref b) => serializer.serialize_bytes(b),\n485         Content::None => serializer.serialize_none(),\n486         Content::Some(ref c) => serializer.serialize_some(&**c),\n487         Content::Unit => serializer.serialize_unit(),\n488         Content::UnitStruct(n) => serializer.serialize_unit_struct(n),\n489         Content::UnitVariant(n, i, v) => serializer.serialize_unit_variant(n, i, v),\n490         Content::NewtypeStruct(n, ref c) => serializer.serialize_newtype_struct(n, &**c),\n491         Content::NewtypeVariant(n, i, v, ref c) => {\n492             serializer.serialize_newtype_variant(n, i, v, &**c)\n493         }\n494         Content::Seq(ref elements) => elements.serialize(serializer),\n495         Content::Tuple(ref elements) => {\n496             use crate::ser::SerializeTuple;\n497             let mut tuple = tri!(serializer.serialize_tuple(elements.len()));\n498             for e in elements {\n499                 tri!(tuple.serialize_element(e));\n500             }\n501             tuple.end()\n502         }\n503         Content::TupleStruct(n, ref fields) => {\n504             use crate::ser::SerializeTupleStruct;\n505             let mut ts = tri!(serializer.serialize_tuple_struct(n, fields.len()));\n506             for f in fields {\n507                 tri!(ts.serialize_field(f));\n508             }\n509             ts.end()\n510         }\n511         Content::TupleVariant(n, i, v, ref fields) => {\n512             use crate::ser::SerializeTupleVariant;\n513             let mut tv = tri!(serializer.serialize_tuple_variant(n, i, v, fields.len()));\n514             for f in fields {\n515                 tri!(tv.serialize_field(f));\n516             }\n517             tv.end()\n518         }\n519         Content::Map(ref entries) => {\n520             use crate::ser::SerializeMap;\n521             let mut map = tri!(serializer.serialize_map(Some(entries.len())));\n522             for (k, v) in entries {\n523                 tri!(map.serialize_entry(k, v));\n524             }\n525             map.end()\n526         }\n527         Content::Struct(n, ref fields) => {\n528             use crate::ser::SerializeStruct;\n529             let mut s = tri!(serializer.serialize_struct(n, fields.len()));\n530             for &(k, ref v) in fields {\n531                 tri!(s.serialize_field(k, v));\n532             }\n533             s.end()\n534         }\n535         Content::StructVariant(n, i, v, ref fields) => {\n536             use crate::ser::SerializeStructVariant;\n537             let mut sv = tri!(serializer.serialize_struct_variant(n, i, v, fields.len()));\n538             for &(k, ref v) in fields {\n539                 tri!(sv.serialize_field(k, v));\n540             }\n541             sv.end()\n542         }\n543     }\n544 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}