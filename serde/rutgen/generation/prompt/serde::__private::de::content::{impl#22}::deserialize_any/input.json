{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/private/de.rs\n// crate name is serde\nuse crate::lib::*;\nuse crate::actually_private;\nuse crate::de::value::{MapDeserializer, SeqDeserializer};\nuse crate::de::{\n    self, size_hint, Deserialize, DeserializeSeed, Deserializer, EnumAccess, Expected,\n    IgnoredAny, MapAccess, SeqAccess, Unexpected, Visitor,\n};\npub trait Deserializer<'de>: Sized {\n    type Error: Error;\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i128<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let _ = visitor;\n        Err(Error::custom(\"i128 is not supported\"))\n    }\n    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u128<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let _ = visitor;\n        Err(Error::custom(\"u128 is not supported\"))\n    }\n    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_unit_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_tuple<V>(\n        self,\n        len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_tuple_struct<V>(\n        self,\n        name: &'static str,\n        len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    #[inline]\n    fn is_human_readable(&self) -> bool {\n        true\n    }\n    #[cfg(all(not(no_serde_derive), any(feature = \"std\", feature = \"alloc\")))]\n    fn __deserialize_content<V>(\n        self,\n        _: crate::actually_private::T,\n        visitor: V,\n    ) -> Result<crate::__private::de::Content<'de>, Self::Error>\n    where\n        V: Visitor<'de, Value = crate::__private::de::Content<'de>>,\n    {\n        self.deserialize_any(visitor)\n    }\n}\npub trait IntoDeserializer<'de, E: Error = value::Error> {\n    type Deserializer: Deserializer<'de, Error = E>;\n    fn into_deserializer(self) -> Self::Deserializer;\n}\npub struct ContentRefDeserializer<'a, 'de: 'a, E> {\n    content: &'a Content<'de>,\n    err: PhantomData<E>,\n}\n#[derive(Debug, Clone)]\npub enum Content<'de> {\n    Bool(bool),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    F32(f32),\n    F64(f64),\n    Char(char),\n    String(String),\n    Str(&'de str),\n    ByteBuf(Vec<u8>),\n    Bytes(&'de [u8]),\n    None,\n    Some(Box<Content<'de>>),\n    Unit,\n    Newtype(Box<Content<'de>>),\n    Seq(Vec<Content<'de>>),\n    Map(Vec<(Content<'de>, Content<'de>)>),\n}\npub enum Content {\n    Bool(bool),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    F32(f32),\n    F64(f64),\n    Char(char),\n    String(String),\n    Bytes(Vec<u8>),\n    None,\n    Some(Box<Content>),\n    Unit,\n    UnitStruct(&'static str),\n    UnitVariant(&'static str, u32, &'static str),\n    NewtypeStruct(&'static str, Box<Content>),\n    NewtypeVariant(&'static str, u32, &'static str, Box<Content>),\n    Seq(Vec<Content>),\n    Tuple(Vec<Content>),\n    TupleStruct(&'static str, Vec<Content>),\n    TupleVariant(&'static str, u32, &'static str, Vec<Content>),\n    Map(Vec<(Content, Content)>),\n    Struct(&'static str, Vec<(&'static str, Content)>),\n    StructVariant(&'static str, u32, &'static str, Vec<(&'static str, Content)>),\n}\nimpl<'de, 'a, E> Deserializer<'de> for ContentRefDeserializer<'a, 'de, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::Bool(v) => visitor.visit_bool(v),\n            Content::U8(v) => visitor.visit_u8(v),\n            Content::U16(v) => visitor.visit_u16(v),\n            Content::U32(v) => visitor.visit_u32(v),\n            Content::U64(v) => visitor.visit_u64(v),\n            Content::I8(v) => visitor.visit_i8(v),\n            Content::I16(v) => visitor.visit_i16(v),\n            Content::I32(v) => visitor.visit_i32(v),\n            Content::I64(v) => visitor.visit_i64(v),\n            Content::F32(v) => visitor.visit_f32(v),\n            Content::F64(v) => visitor.visit_f64(v),\n            Content::Char(v) => visitor.visit_char(v),\n            Content::String(ref v) => visitor.visit_str(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            Content::Unit => visitor.visit_unit(),\n            Content::None => visitor.visit_none(),\n            Content::Some(ref v) => visitor.visit_some(ContentRefDeserializer::new(v)),\n            Content::Newtype(ref v) => {\n                visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n            }\n            Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n            Content::Map(ref v) => visit_content_map_ref(v, visitor),\n        }\n    }\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_float(visitor)\n    }\n    fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_float(visitor)\n    }\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::Char(v) => visitor.visit_char(v),\n            Content::String(ref v) => visitor.visit_str(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::String(ref v) => visitor.visit_str(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_str(visitor)\n    }\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::String(ref v) => visitor.visit_str(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_bytes(visitor)\n    }\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n    {}\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::Unit => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_unit_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_unit(visitor)\n    }\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &str,\n        visitor: V,\n    ) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n    {}\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_tuple<V>(\n        self,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n    fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::Map(ref v) => visit_content_map_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n            Content::Map(ref v) => visit_content_map_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let (variant, value) = match *self.content {\n            Content::Map(ref value) => {\n                let mut iter = value.iter();\n                let (variant, value) = match iter.next() {\n                    Some(v) => v,\n                    None => {\n                        return Err(\n                            de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                &\"map with a single key\",\n                            ),\n                        );\n                    }\n                };\n                if iter.next().is_some() {\n                    return Err(\n                        de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            &\"map with a single key\",\n                        ),\n                    );\n                }\n                (variant, Some(value))\n            }\n            ref s @ Content::String(_) | ref s @ Content::Str(_) => (s, None),\n            ref other => {\n                return Err(\n                    de::Error::invalid_type(other.unexpected(), &\"string or map\"),\n                );\n            }\n        };\n        visitor\n            .visit_enum(EnumRefDeserializer {\n                variant,\n                value,\n                err: PhantomData,\n            })\n    }\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match *self.content {\n            Content::String(ref v) => visitor.visit_str(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            Content::U8(v) => visitor.visit_u8(v),\n            Content::U64(v) => visitor.visit_u64(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_unit()\n    }\n    fn __deserialize_content<V>(\n        self,\n        _: actually_private::T,\n        visitor: V,\n    ) -> Result<Content<'de>, Self::Error>\n    where\n        V: Visitor<'de, Value = Content<'de>>,\n    {\n        let _ = visitor;\n        Ok(self.content.clone())\n    }\n}\nimpl<'a, 'de, E> ContentRefDeserializer<'a, 'de, E> {\n    pub fn new(content: &'a Content<'de>) -> Self {\n        ContentRefDeserializer {\n            content,\n            err: PhantomData,\n        }\n    }\n}\nfn visit_content_map_ref<'a, 'de, V, E>(\n    content: &'a [(Content<'de>, Content<'de>)],\n    visitor: V,\n) -> Result<V::Value, E>\nwhere\n    V: Visitor<'de>,\n    E: de::Error,\n{\n    fn content_ref_deserializer_pair<'a, 'de>(\n        (k, v): &'a (Content<'de>, Content<'de>),\n    ) -> (&'a Content<'de>, &'a Content<'de>) {\n        (k, v)\n    }\n    let map = content.iter().map(content_ref_deserializer_pair);\n    let mut map_visitor = MapDeserializer::new(map);\n    let value = tri!(visitor.visit_map(& mut map_visitor));\n    tri!(map_visitor.end());\n    Ok(value)\n}\nfn visit_content_seq_ref<'a, 'de, V, E>(\n    content: &'a [Content<'de>],\n    visitor: V,\n) -> Result<V::Value, E>\nwhere\n    V: Visitor<'de>,\n    E: de::Error,\n{\n    let mut seq_visitor = SeqDeserializer::new(content.iter());\n    let value = tri!(visitor.visit_seq(& mut seq_visitor));\n    tri!(seq_visitor.end());\n    Ok(value)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1741 fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, E>\n1742 where\n1743     V: Visitor<'de>,\n1744 {\n1745     match *self.content {\n1746         Content::Bool(v) => visitor.visit_bool(v),\n1747         Content::U8(v) => visitor.visit_u8(v),\n1748         Content::U16(v) => visitor.visit_u16(v),\n1749         Content::U32(v) => visitor.visit_u32(v),\n1750         Content::U64(v) => visitor.visit_u64(v),\n1751         Content::I8(v) => visitor.visit_i8(v),\n1752         Content::I16(v) => visitor.visit_i16(v),\n1753         Content::I32(v) => visitor.visit_i32(v),\n1754         Content::I64(v) => visitor.visit_i64(v),\n1755         Content::F32(v) => visitor.visit_f32(v),\n1756         Content::F64(v) => visitor.visit_f64(v),\n1757         Content::Char(v) => visitor.visit_char(v),\n1758         Content::String(ref v) => visitor.visit_str(v),\n1759         Content::Str(v) => visitor.visit_borrowed_str(v),\n1760         Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n1761         Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n1762         Content::Unit => visitor.visit_unit(),\n1763         Content::None => visitor.visit_none(),\n1764         Content::Some(ref v) => visitor.visit_some(ContentRefDeserializer::new(v)),\n1765         Content::Newtype(ref v) => {\n1766             visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n1767         }\n1768         Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n1769         Content::Map(ref v) => visit_content_map_ref(v, visitor),\n1770     }\n1771 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}