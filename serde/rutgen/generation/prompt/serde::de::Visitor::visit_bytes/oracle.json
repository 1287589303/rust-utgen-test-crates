{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/de/mod.rs\n// crate name is serde\nuse crate::lib::*;\npub use self::ignored_any::IgnoredAny;\n#[cfg(all(not(feature = \"std\"), no_core_error))]\npub use crate::std_error::Error as StdError;\n#[cfg(not(any(feature = \"std\", no_core_error)))]\npub use core::error::Error as StdError;\n#[cfg(feature = \"std\")]\npub use std::error::Error as StdError;\npub trait Visitor<'de>: Sized {\n    type Value;\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Bool(v), &self))\n    }\n    fn visit_i8<E>(self, v: i8) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n    fn visit_i16<E>(self, v: i16) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n    fn visit_i32<E>(self, v: i32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n    fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Signed(v), &self))\n    }\n    fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let mut buf = [0u8; 58];\n        let mut writer = crate::format::Buf::new(&mut buf);\n        fmt::Write::write_fmt(&mut writer, format_args!(\"integer `{}` as i128\", v))\n            .unwrap();\n        Err(Error::invalid_type(Unexpected::Other(writer.as_str()), &self))\n    }\n    fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n    fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n    fn visit_u32<E>(self, v: u32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unsigned(v), &self))\n    }\n    fn visit_u128<E>(self, v: u128) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let mut buf = [0u8; 57];\n        let mut writer = crate::format::Buf::new(&mut buf);\n        fmt::Write::write_fmt(&mut writer, format_args!(\"integer `{}` as u128\", v))\n            .unwrap();\n        Err(Error::invalid_type(Unexpected::Other(writer.as_str()), &self))\n    }\n    fn visit_f32<E>(self, v: f32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_f64(v as f64)\n    }\n    fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Float(v), &self))\n    }\n    #[inline]\n    fn visit_char<E>(self, v: char) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(v.encode_utf8(&mut [0u8; 4]))\n    }\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Str(v), &self))\n    }\n    #[inline]\n    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(v)\n    }\n    #[inline]\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(&v)\n    }\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Bytes(v), &self))\n    }\n    #[inline]\n    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_bytes(v)\n    }\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_bytes(&v)\n    }\n    fn visit_none<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Option, &self))\n    }\n    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::Option, &self))\n    }\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unit, &self))\n    }\n    fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::NewtypeStruct, &self))\n    }\n    fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        let _ = seq;\n        Err(Error::invalid_type(Unexpected::Seq, &self))\n    }\n    fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>\n    where\n        A: MapAccess<'de>,\n    {\n        let _ = map;\n        Err(Error::invalid_type(Unexpected::Map, &self))\n    }\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        let _ = data;\n        Err(Error::invalid_type(Unexpected::Enum, &self))\n    }\n    fn __private_visit_untagged_option<D>(self, _: D) -> Result<Self::Value, ()>\n    where\n        D: Deserializer<'de>,\n    {\n        Err(())\n    }\n}\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Unexpected<'a> {\n    /// The input contained a boolean value that was not expected.\n    Bool(bool),\n    /// The input contained an unsigned integer `u8`, `u16`, `u32` or `u64` that\n    /// was not expected.\n    Unsigned(u64),\n    /// The input contained a signed integer `i8`, `i16`, `i32` or `i64` that\n    /// was not expected.\n    Signed(i64),\n    /// The input contained a floating point `f32` or `f64` that was not\n    /// expected.\n    Float(f64),\n    /// The input contained a `char` that was not expected.\n    Char(char),\n    /// The input contained a `&str` or `String` that was not expected.\n    Str(&'a str),\n    /// The input contained a `&[u8]` or `Vec<u8>` that was not expected.\n    Bytes(&'a [u8]),\n    /// The input contained a unit `()` that was not expected.\n    Unit,\n    /// The input contained an `Option<T>` that was not expected.\n    Option,\n    /// The input contained a newtype struct that was not expected.\n    NewtypeStruct,\n    /// The input contained a sequence that was not expected.\n    Seq,\n    /// The input contained a map that was not expected.\n    Map,\n    /// The input contained an enum that was not expected.\n    Enum,\n    /// The input contained a unit variant that was not expected.\n    UnitVariant,\n    /// The input contained a newtype variant that was not expected.\n    NewtypeVariant,\n    /// The input contained a tuple variant that was not expected.\n    TupleVariant,\n    /// The input contained a struct variant that was not expected.\n    StructVariant,\n    /// A message stating what uncategorized thing the input contained that was\n    /// not expected.\n    ///\n    /// The message should be a noun or noun phrase, not capitalized and without\n    /// a period. An example message is \"unoriginal superhero\".\n    Other(&'a str),\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// The input contains a byte array. The lifetime of the byte array is\n/// ephemeral and it may be destroyed after this method returns.\n///\n/// This method allows the `Deserializer` to avoid a copy by retaining\n/// ownership of any buffered data. `Deserialize` implementations that do\n/// not benefit from taking ownership of `Vec<u8>` data should indicate that\n/// to the deserializer by using `Deserializer::deserialize_bytes` rather\n/// than `Deserializer::deserialize_byte_buf`.\n///\n/// It is never correct to implement `visit_byte_buf` without implementing\n/// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n1553 fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n1554 where\n1555     E: Error,\n1556 {\n1557     Err(Error::invalid_type(Unexpected::Bytes(v), &self))\n1558 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}