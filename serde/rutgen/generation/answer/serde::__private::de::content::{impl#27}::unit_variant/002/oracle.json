[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVariantAccess;",
          "    ",
          "    impl<'de> VariantAccess<'de> for TestVariantAccess {",
          "        type Error = ();",
          "",
          "        fn unit_variant(self) -> Result<(), Self::Error> {",
          "            match self.value {",
          "                Some(value) => {",
          "                    // Skip the actual deserialization to fulfill the test condition",
          "                    Err(())",
          "                }",
          "                None => Ok(()),",
          "            }",
          "        }",
          "",
          "        fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>",
          "        where",
          "            T: DeserializeSeed<'de>,",
          "        {",
          "            unimplemented!()",
          "        }",
          "",
          "        fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>",
          "        where",
          "            V: Visitor<'de>,",
          "        {",
          "            unimplemented!()",
          "        }",
          "",
          "        fn struct_variant<V>(",
          "            self,",
          "            fields: &'static [&'static str],",
          "            visitor: V,",
          "        ) -> Result<V::Value, Self::Error>",
          "        where",
          "            V: Visitor<'de>,",
          "        {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let deserializer = VariantRefDeserializer {",
          "        value: None,",
          "        err: PhantomData::<()>,",
          "    };",
          "",
          "    let _result: Result<(), ()> = deserializer.unit_variant();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.value, None);",
          "    assert!(matches!(_result, Ok(())));"
        ],
        "code": [
          "{",
          "    struct TestVariantAccess;",
          "    ",
          "    impl<'de> VariantAccess<'de> for TestVariantAccess {",
          "        type Error = ();",
          "",
          "        fn unit_variant(self) -> Result<(), Self::Error> {",
          "            match self.value {",
          "                Some(value) => {",
          "                    // Skip the actual deserialization to fulfill the test condition",
          "                    Err(())",
          "                }",
          "                None => Ok(()),",
          "            }",
          "        }",
          "",
          "        fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>",
          "        where",
          "            T: DeserializeSeed<'de>,",
          "        {",
          "            unimplemented!()",
          "        }",
          "",
          "        fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>",
          "        where",
          "            V: Visitor<'de>,",
          "        {",
          "            unimplemented!()",
          "        }",
          "",
          "        fn struct_variant<V>(",
          "            self,",
          "            fields: &'static [&'static str],",
          "            visitor: V,",
          "        ) -> Result<V::Value, Self::Error>",
          "        where",
          "            V: Visitor<'de>,",
          "        {",
          "            unimplemented!()",
          "        }",
          "    }",
          "",
          "    let deserializer = VariantRefDeserializer {",
          "        value: None,",
          "        err: PhantomData::<()>,",
          "    };",
          "",
          "    let _result: Result<(), ()> = deserializer.unit_variant();",
          "    assert_eq!(deserializer.value, None);",
          "    assert!(matches!(_result, Ok(())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]