[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Boolean);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Boolean)\");",
          "    assert_eq!(error.kind(), serde::ser::Error::kind());",
          "    assert!(matches!(error, serde::ser::Error::Custom(_)));",
          "    let unsupported_type = Unsupported::Integer;",
          "    let error_integer = FlatMapSerializer(&mut serializer).bad_type(unsupported_type);",
          "    assert_eq!(error_integer.to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    let unsupported_float = Unsupported::Float;",
          "    let error_float = FlatMapSerializer(&mut serializer).bad_type(unsupported_float);",
          "    assert_eq!(error_float.to_string(), \"can only flatten structs and maps (got Float)\");",
          "    let unsupported_char = Unsupported::Char;",
          "    let error_char = FlatMapSerializer(&mut serializer).bad_type(unsupported_char);",
          "    assert_eq!(error_char.to_string(), \"can only flatten structs and maps (got Char)\");",
          "    let unsupported_string = Unsupported::String;",
          "    let error_string = FlatMapSerializer(&mut serializer).bad_type(unsupported_string);",
          "    assert_eq!(error_string.to_string(), \"can only flatten structs and maps (got String)\");",
          "    let unsupported_bytes = Unsupported::ByteArray;",
          "    let error_bytes = FlatMapSerializer(&mut serializer).bad_type(unsupported_bytes);",
          "    assert_eq!(error_bytes.to_string(), \"can only flatten structs and maps (got ByteArray)\");",
          "    let unsupported_optional = Unsupported::Optional;",
          "    let error_optional = FlatMapSerializer(&mut serializer).bad_type(unsupported_optional);",
          "    assert_eq!(error_optional.to_string(), \"can only flatten structs and maps (got Optional)\");",
          "    let unsupported_sequence = Unsupported::Sequence;",
          "    let error_sequence = FlatMapSerializer(&mut serializer).bad_type(unsupported_sequence);",
          "    assert_eq!(error_sequence.to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    let unsupported_tuple = Unsupported::Tuple;",
          "    let error_tuple = FlatMapSerializer(&mut serializer).bad_type(unsupported_tuple);",
          "    assert_eq!(error_tuple.to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    let unsupported_tuple_struct = Unsupported::TupleStruct;",
          "    let error_tuple_struct = FlatMapSerializer(&mut serializer).bad_type(unsupported_tuple_struct);",
          "    assert_eq!(error_tuple_struct.to_string(), \"can only flatten structs and maps (got TupleStruct)\");"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Boolean);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Boolean)\");",
          "    assert_eq!(error.kind(), serde::ser::Error::kind());",
          "    assert!(matches!(error, serde::ser::Error::Custom(_)));",
          "    let unsupported_type = Unsupported::Integer;",
          "    let error_integer = FlatMapSerializer(&mut serializer).bad_type(unsupported_type);",
          "    assert_eq!(error_integer.to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    let unsupported_float = Unsupported::Float;",
          "    let error_float = FlatMapSerializer(&mut serializer).bad_type(unsupported_float);",
          "    assert_eq!(error_float.to_string(), \"can only flatten structs and maps (got Float)\");",
          "    let unsupported_char = Unsupported::Char;",
          "    let error_char = FlatMapSerializer(&mut serializer).bad_type(unsupported_char);",
          "    assert_eq!(error_char.to_string(), \"can only flatten structs and maps (got Char)\");",
          "    let unsupported_string = Unsupported::String;",
          "    let error_string = FlatMapSerializer(&mut serializer).bad_type(unsupported_string);",
          "    assert_eq!(error_string.to_string(), \"can only flatten structs and maps (got String)\");",
          "    let unsupported_bytes = Unsupported::ByteArray;",
          "    let error_bytes = FlatMapSerializer(&mut serializer).bad_type(unsupported_bytes);",
          "    assert_eq!(error_bytes.to_string(), \"can only flatten structs and maps (got ByteArray)\");",
          "    let unsupported_optional = Unsupported::Optional;",
          "    let error_optional = FlatMapSerializer(&mut serializer).bad_type(unsupported_optional);",
          "    assert_eq!(error_optional.to_string(), \"can only flatten structs and maps (got Optional)\");",
          "    let unsupported_sequence = Unsupported::Sequence;",
          "    let error_sequence = FlatMapSerializer(&mut serializer).bad_type(unsupported_sequence);",
          "    assert_eq!(error_sequence.to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    let unsupported_tuple = Unsupported::Tuple;",
          "    let error_tuple = FlatMapSerializer(&mut serializer).bad_type(unsupported_tuple);",
          "    assert_eq!(error_tuple.to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    let unsupported_tuple_struct = Unsupported::TupleStruct;",
          "    let error_tuple_struct = FlatMapSerializer(&mut serializer).bad_type(unsupported_tuple_struct);",
          "    assert_eq!(error_tuple_struct.to_string(), \"can only flatten structs and maps (got TupleStruct)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "}"
        ],
        "oracle": [
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Boolean);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Boolean)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Float);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Float)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Char);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Char)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got String)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::ByteArray);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got ByteArray)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Optional);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Optional)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::TupleStruct);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got TupleStruct)\");"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Boolean);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Boolean)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Float);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Float)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Char);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Char)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got String)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::ByteArray);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got ByteArray)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Optional);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Optional)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::TupleStruct);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got TupleStruct)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Float);",
          "}"
        ],
        "oracle": [
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Boolean);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Boolean)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got String)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::ByteArray);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got ByteArray)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Optional);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Optional)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::TupleStruct);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got TupleStruct)\");"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Float);",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Boolean);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Boolean)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got String)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::ByteArray);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got ByteArray)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Optional);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Optional)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    ",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::TupleStruct);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got TupleStruct)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Char);",
          "}"
        ],
        "oracle": [
          "    let expected_error = ser::Error::custom(\"can only flatten structs and maps (got Char)\");",
          "    assert_eq!(error, expected_error);"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Char);",
          "    let expected_error = ser::Error::custom(\"can only flatten structs and maps (got Char)\");",
          "    assert_eq!(error, expected_error);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "}"
        ],
        "oracle": [
          "    let serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert!(error.is_err());",
          "    let error_message = format!(\"can only flatten structs and maps (got {})\", Unsupported::String);",
          "    assert_eq!(error.unwrap_err().to_string(), error_message);",
          "    let error2 = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert!(error2.is_err());",
          "    let error_message2 = format!(\"can only flatten structs and maps (got {})\", Unsupported::Integer);",
          "    assert_eq!(error2.unwrap_err().to_string(), error_message2);",
          "    let error3 = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert!(error3.is_err());",
          "    let error_message3 = format!(\"can only flatten structs and maps (got {})\", Unsupported::Sequence);",
          "    assert_eq!(error3.unwrap_err().to_string(), error_message3);"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    let serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert!(error.is_err());",
          "    let error_message = format!(\"can only flatten structs and maps (got {})\", Unsupported::String);",
          "    assert_eq!(error.unwrap_err().to_string(), error_message);",
          "    let error2 = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert!(error2.is_err());",
          "    let error_message2 = format!(\"can only flatten structs and maps (got {})\", Unsupported::Integer);",
          "    assert_eq!(error2.unwrap_err().to_string(), error_message2);",
          "    let error3 = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert!(error3.is_err());",
          "    let error_message3 = format!(\"can only flatten structs and maps (got {})\", Unsupported::Sequence);",
          "    assert_eq!(error3.unwrap_err().to_string(), error_message3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::ByteArray);",
          "}"
        ],
        "oracle": [
          "    let expected_error = ser::Error::custom(format_args!(\"can only flatten structs and maps (got {:?})\", Unsupported::ByteArray));",
          "    assert_eq!(error, expected_error);"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::ByteArray);",
          "    let expected_error = ser::Error::custom(format_args!(\"can only flatten structs and maps (got {:?})\", Unsupported::ByteArray));",
          "    assert_eq!(error, expected_error);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Optional);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Optional)\");"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Optional);",
          "    assert_eq!(error.to_string(), \"can only flatten structs and maps (got Optional)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "}"
        ],
        "oracle": [
          "    let expected_error = ser::Error::custom(format_args!(",
          "    \"can only flatten structs and maps (got {})\",",
          "    Unsupported::Sequence",
          "    ));",
          "    assert_eq!(error, expected_error);"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    let expected_error = ser::Error::custom(format_args!(",
          "    \"can only flatten structs and maps (got {})\",",
          "    Unsupported::Sequence",
          "    ));",
          "    assert_eq!(error, expected_error);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "}"
        ],
        "oracle": [
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got String)\");"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Tuple);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Tuple)\");",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Sequence);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Sequence)\");",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::Integer);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got Integer)\");",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::String);",
          "    assert!(error.is_err());",
          "    assert_eq!(error.unwrap_err().to_string(), \"can only flatten structs and maps (got String)\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::TupleStruct);",
          "}"
        ],
        "oracle": [
          "    let expected_error = ser::Error::custom(format_args!(\"can only flatten structs and maps (got {})\", Unsupported::TupleStruct));",
          "    assert_eq!(error, expected_error);"
        ],
        "code": [
          "{",
          "    struct DummySerializer;",
          "    impl SerializeMap for DummySerializer {",
          "        type Ok = ();",
          "        type Error = serde::ser::Error;",
          "        fn serialize_entry<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> ",
          "        where ",
          "            K: Serialize, ",
          "            V: Serialize { ",
          "            Ok(()) ",
          "        }",
          "        fn end(self) -> Result<Self::Ok, Self::Error> { ",
          "            Ok(()) ",
          "        }",
          "    }",
          "",
          "    let mut serializer = DummySerializer;",
          "    let error = FlatMapSerializer(&mut serializer).bad_type(Unsupported::TupleStruct);",
          "    let expected_error = ser::Error::custom(format_args!(\"can only flatten structs and maps (got {})\", Unsupported::TupleStruct));",
          "    assert_eq!(error, expected_error);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]