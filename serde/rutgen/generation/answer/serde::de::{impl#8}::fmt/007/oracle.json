[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    let names: &'static [&'static str] = &[\"single_name\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"first_name\", \"second_name\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"name1\", \"name2\", \"name3\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"name\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"first\", \"second\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    assert!(formatter.write_str(\"one of \").is_ok());",
          "    ",
          "    let names: &'static [&'static str] = &[\"value1\", \"value2\", \"value3\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    let names: &'static [&'static str] = &[\"single_name\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"first_name\", \"second_name\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"name1\", \"name2\", \"name3\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"name\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "    ",
          "    let names: &'static [&'static str] = &[\"first\", \"second\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    assert!(formatter.write_str(\"one of \").is_ok());",
          "    ",
          "    let names: &'static [&'static str] = &[\"value1\", \"value2\", \"value3\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    assert_eq!(one_of.fmt(&mut formatter), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[\"name1\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    panic!(); // when self.names.len() matches 0",
          "    write!(formatter, \"`{}`\", self.names[0]); // when self.names.len() matches 1",
          "    write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]); // when self.names.len() matches 2",
          "    tri!(formatter.write_str(\"one of \")); // when self.names.len() matches _",
          "    tri!(formatter.write_str(\", \")); // when i > 0 in the for loop",
          "    tri!(write!(formatter, \"`{}`\", alt)); // when (i, alt) in self.names.iter().enumerate() is false",
          "    Ok(()); // expected return value/type"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[\"name1\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    panic!(); // when self.names.len() matches 0",
          "    write!(formatter, \"`{}`\", self.names[0]); // when self.names.len() matches 1",
          "    write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]); // when self.names.len() matches 2",
          "    tri!(formatter.write_str(\"one of \")); // when self.names.len() matches _",
          "    tri!(formatter.write_str(\", \")); // when i > 0 in the for loop",
          "    tri!(write!(formatter, \"`{}`\", alt)); // when (i, alt) in self.names.iter().enumerate() is false",
          "    Ok(()); // expected return value/type",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[\"name1\", \"name2\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    panic!(); // when self.names.len() matches 0",
          "    let names_empty: &'static [&'static str] = &[];",
          "    let one_of_empty = OneOf { names: names_empty };",
          "    let result_empty = one_of_empty.fmt(&mut formatter);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let names_single: &'static [&'static str] = &[\"name1\"];",
          "    let one_of_single = OneOf { names: names_single };",
          "    let result_single = one_of_single.fmt(&mut formatter);",
          "    assert_eq!(result_single, Ok(()));",
          "    ",
          "    let names_pair: &'static [&'static str] = &[\"name1\", \"name2\"];",
          "    let one_of_pair = OneOf { names: names_pair };",
          "    let result_pair = one_of_pair.fmt(&mut formatter);",
          "    assert_eq!(result_pair, Ok(()));",
          "    ",
          "    let names_multiple: &'static [&'static str] = &[\"name1\", \"name2\", \"name3\"];",
          "    let one_of_multiple = OneOf { names: names_multiple };",
          "    let result_multiple = one_of_multiple.fmt(&mut formatter);",
          "    assert_eq!(result_multiple, Ok(()));"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[\"name1\", \"name2\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    panic!(); // when self.names.len() matches 0",
          "    let names_empty: &'static [&'static str] = &[];",
          "    let one_of_empty = OneOf { names: names_empty };",
          "    let result_empty = one_of_empty.fmt(&mut formatter);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let names_single: &'static [&'static str] = &[\"name1\"];",
          "    let one_of_single = OneOf { names: names_single };",
          "    let result_single = one_of_single.fmt(&mut formatter);",
          "    assert_eq!(result_single, Ok(()));",
          "    ",
          "    let names_pair: &'static [&'static str] = &[\"name1\", \"name2\"];",
          "    let one_of_pair = OneOf { names: names_pair };",
          "    let result_pair = one_of_pair.fmt(&mut formatter);",
          "    assert_eq!(result_pair, Ok(()));",
          "    ",
          "    let names_multiple: &'static [&'static str] = &[\"name1\", \"name2\", \"name3\"];",
          "    let one_of_multiple = OneOf { names: names_multiple };",
          "    let result_multiple = one_of_multiple.fmt(&mut formatter);",
          "    assert_eq!(result_multiple, Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[\"name1\", \"name2\", \"name3\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    panic!(); // Check when names.len() == 0",
          "    write!(formatter, \"`{}`\", self.names[0]); // Check when names.len() == 1",
          "    write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]); // Check when names.len() == 2",
          "    tri!(formatter.write_str(\"one of \")); // Check when names.len() > 2",
          "    tri!(formatter.write_str(\", \")); // Verify comma handling in the iteration",
          "    tri!(write!(formatter, \"`{}`\", alt)); // Check correct formatting of alternatives",
          "    Ok(()); // Check expected return value"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[\"name1\", \"name2\", \"name3\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    panic!(); // Check when names.len() == 0",
          "    write!(formatter, \"`{}`\", self.names[0]); // Check when names.len() == 1",
          "    write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]); // Check when names.len() == 2",
          "    tri!(formatter.write_str(\"one of \")); // Check when names.len() > 2",
          "    tri!(formatter.write_str(\", \")); // Verify comma handling in the iteration",
          "    tri!(write!(formatter, \"`{}`\", alt)); // Check correct formatting of alternatives",
          "    Ok(()); // Check expected return value",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]