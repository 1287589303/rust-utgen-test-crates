[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    let names_empty: &'static [&'static str] = &[];",
          "    let one_of_empty = OneOf { names: names_empty };",
          "    let mut formatter_empty = fmt::Formatter::new();",
          "    assert_eq!(one_of_empty.fmt(&mut formatter_empty), Err(_));",
          "    ",
          "    let names_single: &'static [&'static str] = &[\"Single\"];",
          "    let one_of_single = OneOf { names: names_single };",
          "    let mut formatter_single = fmt::Formatter::new();",
          "    assert_eq!(one_of_single.fmt(&mut formatter_single), Ok(()));",
          "    ",
          "    let names_double: &'static [&'static str] = &[\"First\", \"Second\"];",
          "    let one_of_double = OneOf { names: names_double };",
          "    let mut formatter_double = fmt::Formatter::new();",
          "    assert_eq!(one_of_double.fmt(&mut formatter_double), Ok(()));",
          "    ",
          "    let names_multiple: &'static [&'static str] = &[\"First\", \"Second\", \"Third\"];",
          "    let one_of_multiple = OneOf { names: names_multiple };",
          "    let mut formatter_multiple = fmt::Formatter::new();",
          "    assert_eq!(one_of_multiple.fmt(&mut formatter_multiple), Ok(()));",
          "    assert!(formatter_multiple.includes(\"one of\"));",
          "    assert!(formatter_multiple.includes(\", \"));"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    let names_empty: &'static [&'static str] = &[];",
          "    let one_of_empty = OneOf { names: names_empty };",
          "    let mut formatter_empty = fmt::Formatter::new();",
          "    assert_eq!(one_of_empty.fmt(&mut formatter_empty), Err(_));",
          "    ",
          "    let names_single: &'static [&'static str] = &[\"Single\"];",
          "    let one_of_single = OneOf { names: names_single };",
          "    let mut formatter_single = fmt::Formatter::new();",
          "    assert_eq!(one_of_single.fmt(&mut formatter_single), Ok(()));",
          "    ",
          "    let names_double: &'static [&'static str] = &[\"First\", \"Second\"];",
          "    let one_of_double = OneOf { names: names_double };",
          "    let mut formatter_double = fmt::Formatter::new();",
          "    assert_eq!(one_of_double.fmt(&mut formatter_double), Ok(()));",
          "    ",
          "    let names_multiple: &'static [&'static str] = &[\"First\", \"Second\", \"Third\"];",
          "    let one_of_multiple = OneOf { names: names_multiple };",
          "    let mut formatter_multiple = fmt::Formatter::new();",
          "    assert_eq!(one_of_multiple.fmt(&mut formatter_multiple), Ok(()));",
          "    assert!(formatter_multiple.includes(\"one of\"));",
          "    assert!(formatter_multiple.includes(\", \"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[\"A\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    panic!() // when self.names.len() == 0",
          "    assert_eq!(one_of.fmt(&mut formatter).is_ok(), true); // when self.names.len() == 1",
          "    assert_eq!(one_of.fmt(&mut formatter).unwrap(), \"`A`\"); // when self.names.len() == 1",
          "    assert_eq!(one_of.fmt(&mut formatter).is_ok(), true); // when self.names.len() == 2 with names: [\"A\", \"B\"]",
          "    assert_eq!(one_of.fmt(&mut formatter).unwrap(), \"`A` or `B`\"); // when self.names.len() == 2",
          "    assert_eq!(one_of.fmt(&mut formatter).is_err(), true); // when self.names.len() > 2",
          "    assert_eq!(formatter.write_str(\"one of \").is_ok(), true); // check if write_str(\"one of \") is Ok",
          "    assert_eq!(formatter.write_str(\", \").is_err(), true); // check if write_str(\", \") returns Err",
          "    assert!(self.names.iter().enumerate().next().is_some()); // check if (i, alt) exists",
          "    assert_eq!(i > 0, false); // check if i == 0 holds true"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[\"A\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    panic!() // when self.names.len() == 0",
          "    assert_eq!(one_of.fmt(&mut formatter).is_ok(), true); // when self.names.len() == 1",
          "    assert_eq!(one_of.fmt(&mut formatter).unwrap(), \"`A`\"); // when self.names.len() == 1",
          "    assert_eq!(one_of.fmt(&mut formatter).is_ok(), true); // when self.names.len() == 2 with names: [\"A\", \"B\"]",
          "    assert_eq!(one_of.fmt(&mut formatter).unwrap(), \"`A` or `B`\"); // when self.names.len() == 2",
          "    assert_eq!(one_of.fmt(&mut formatter).is_err(), true); // when self.names.len() > 2",
          "    assert_eq!(formatter.write_str(\"one of \").is_ok(), true); // check if write_str(\"one of \") is Ok",
          "    assert_eq!(formatter.write_str(\", \").is_err(), true); // check if write_str(\", \") returns Err",
          "    assert!(self.names.iter().enumerate().next().is_some()); // check if (i, alt) exists",
          "    assert_eq!(i > 0, false); // check if i == 0 holds true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[\"A\", \"B\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(one_of.names.len(), 0);",
          "    assert!(std::panic::catch_unwind(|| one_of.fmt(&mut formatter)).is_err());",
          "    assert_eq!(one_of.names.len(), 1);",
          "    assert_eq!(one_of.names.len(), 2);",
          "    assert_eq!(one_of.names.len(), 3);",
          "    assert!(formatter.write_str(\"one of \").is_ok());",
          "    assert!(formatter.write_str(\", \").is_ok());",
          "    let (i, alt) = one_of.names.iter().enumerate().next().unwrap();",
          "    assert!(i == 0);",
          "    assert!(formatter.write_str(\", \").is_err());"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[\"A\", \"B\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    assert_eq!(one_of.names.len(), 0);",
          "    assert!(std::panic::catch_unwind(|| one_of.fmt(&mut formatter)).is_err());",
          "    assert_eq!(one_of.names.len(), 1);",
          "    assert_eq!(one_of.names.len(), 2);",
          "    assert_eq!(one_of.names.len(), 3);",
          "    assert!(formatter.write_str(\"one of \").is_ok());",
          "    assert!(formatter.write_str(\", \").is_ok());",
          "    let (i, alt) = one_of.names.iter().enumerate().next().unwrap();",
          "    assert!(i == 0);",
          "    assert!(formatter.write_str(\", \").is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let names: &'static [&'static str] = &[\"A\", \"B\", \"C\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    let names_empty: &'static [&'static str] = &[];",
          "    let one_of_empty = OneOf { names: names_empty };",
          "    let result_empty = one_of_empty.fmt(&mut formatter);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let names_one: &'static [&'static str] = &[\"A\"];",
          "    let one_of_one = OneOf { names: names_one };",
          "    let result_one = one_of_one.fmt(&mut formatter);",
          "    assert_eq!(result_one.is_ok(), true);",
          "    ",
          "    let names_two: &'static [&'static str] = &[\"A\", \"B\"];",
          "    let one_of_two = OneOf { names: names_two };",
          "    let result_two = one_of_two.fmt(&mut formatter);",
          "    assert_eq!(result_two.is_ok(), true);",
          "    ",
          "    let names_multiple: &'static [&'static str] = &[\"A\", \"B\", \"C\"];",
          "    let one_of_multiple = OneOf { names: names_multiple };",
          "    let result_multiple = one_of_multiple.fmt(&mut formatter);",
          "    assert_eq!(result_multiple.is_ok(), true);",
          "    ",
          "    let names_error: &'static [&'static str] = &[\"A\", \"B\"];",
          "    let one_of_error = OneOf { names: names_error };",
          "    formatter.force_write_error();",
          "    let result_error = one_of_error.fmt(&mut formatter);",
          "    assert!(result_error.is_err());"
        ],
        "code": [
          "{",
          "    let names: &'static [&'static str] = &[\"A\", \"B\", \"C\"];",
          "    let one_of = OneOf { names };",
          "    let mut formatter = fmt::Formatter::new();",
          "    one_of.fmt(&mut formatter);",
          "    let names_empty: &'static [&'static str] = &[];",
          "    let one_of_empty = OneOf { names: names_empty };",
          "    let result_empty = one_of_empty.fmt(&mut formatter);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let names_one: &'static [&'static str] = &[\"A\"];",
          "    let one_of_one = OneOf { names: names_one };",
          "    let result_one = one_of_one.fmt(&mut formatter);",
          "    assert_eq!(result_one.is_ok(), true);",
          "    ",
          "    let names_two: &'static [&'static str] = &[\"A\", \"B\"];",
          "    let one_of_two = OneOf { names: names_two };",
          "    let result_two = one_of_two.fmt(&mut formatter);",
          "    assert_eq!(result_two.is_ok(), true);",
          "    ",
          "    let names_multiple: &'static [&'static str] = &[\"A\", \"B\", \"C\"];",
          "    let one_of_multiple = OneOf { names: names_multiple };",
          "    let result_multiple = one_of_multiple.fmt(&mut formatter);",
          "    assert_eq!(result_multiple.is_ok(), true);",
          "    ",
          "    let names_error: &'static [&'static str] = &[\"A\", \"B\"];",
          "    let one_of_error = OneOf { names: names_error };",
          "    formatter.force_write_error();",
          "    let result_error = one_of_error.fmt(&mut formatter);",
          "    assert!(result_error.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]