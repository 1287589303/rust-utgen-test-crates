{
  "serde_derive_internals/src/attr.rs:1079:16:1188:15": [
    {
      "Bool": {
        "Other": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            default.set(&meta.path, Default::Path(path));\n                        }\n                    } else {\n                        // #[serde(default)]\n                        default.set(&meta.path, Default::Default);\n                    }\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING_IF {\n                    // #[serde(skip_serializing_if = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SKIP_SERIALIZING_IF, &meta)? {\n                        skip_serializing_if.set(&meta.path, path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == BORROW {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                            for lifetime in &lifetimes {\n                                if !borrowable.contains(lifetime) {\n                                    let msg = format!(\n                                        \"field `{}` does not have lifetime {}\",\n                                        ident, lifetime,\n                                    );\n                                    cx.error_spanned_by(field, msg);\n                                }\n                            }\n                            borrowed_lifetimes.set(&meta.path, lifetimes);\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                            borrowed_lifetimes.set(&meta.path, borrowable);\n                        }\n                    }\n                } else if meta.path == GETTER {\n                    // #[serde(getter = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, GETTER, &meta)? {\n                        getter.set(&meta.path, path);\n                    }\n                } else if meta.path == FLATTEN {\n                    // #[serde(flatten)]\n                    flatten.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde field attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1069:16:1069:36": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ne",
          "expr": "attr.path() != SERDE",
          "lhs": "attr.path()",
          "rhs": "SERDE",
          "cmp_with_int": false
        }
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1230:23:1230:53": [
    {
      "Bool": {
        "Other": "is_cow(&field.ty, is_slice_u8)"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1051:12:1051:90": [
    {
      "Bool": {
        "Other": "let Some(borrow_attribute) = attrs.and_then(|variant| variant.borrow.as_ref())"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1054:37:1054:46": [
    {
      "For": {
        "iter_var": "lifetime",
        "iter_range": "lifetimes"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1248:19:1248:52": [
    {
      "Bool": {
        "Other": "is_implicitly_borrowed(&field.ty)"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1043:27:1043:39": [
    {
      "Match": {
        "match_source": "serde_derive_internals/src/attr.rs:1043:27:1043:39",
        "match_str": "&field.ident",
        "match_kind": {
          "Enum": [
            "None",
            "Some"
          ]
        },
        "arms": {
          "serde_derive_internals/src/attr.rs:1044:13:1044:24": {
            "pat": {
              "pat_str": "Some(ident)",
              "kind": {
                "Enum": 1
              }
            },
            "guard": null,
            "body_source": "serde_derive_internals/src/attr.rs:1044:28:1044:53"
          },
          "serde_derive_internals/src/attr.rs:1045:13:1045:17": {
            "pat": {
              "pat_str": "None",
              "kind": {
                "Enum": 0
              }
            },
            "guard": null,
            "body_source": "serde_derive_internals/src/attr.rs:1045:21:1048:14"
          }
        }
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1203:13:1203:42": [
    {
      "Bool": {
        "Other": "borrowed_lifetimes.is_empty()"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1073:16:1073:54": [
    {
      "Bool": {
        "Other": "let syn::Meta::List(meta) = &attr.meta"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1074:20:1074:42": [
    {
      "Bool": {
        "Other": "meta.tokens.is_empty()"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1055:29:1055:58": [
    {
      "Bool": {
        "Other": "borrowable.contains(lifetime)"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1053:20:1053:69": [
    {
      "Bool": {
        "Other": "let Some(lifetimes) = &borrow_attribute.lifetimes"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1068:21:1068:33": [
    {
      "For": {
        "iter_var": "attr",
        "iter_range": "&field.attrs"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1196:12:1196:50": [
    {
      "Bool": {
        "Other": "let Default::None = *container_default"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1197:16:1197:52": [
    {
      "Bool": {
        "Other": "skip_deserializing.0.value.is_some()"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1213:16:1213:41": [
    {
      "Bool": {
        "Other": "is_cow(&field.ty, is_str)"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:1052:16:1052:76": [
    {
      "Bool": {
        "Other": "let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field)"
      }
    }
  ]
}