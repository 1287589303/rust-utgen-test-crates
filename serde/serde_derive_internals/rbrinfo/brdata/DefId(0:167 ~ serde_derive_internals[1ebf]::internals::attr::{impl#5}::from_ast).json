{
  "name": "serde_derive_internals::internals::attr::{impl#5}::from_ast",
  "mod_info": {
    "name": "internals::attr",
    "loc": "serde_derive_internals/src/mod.rs:2:1:2:14"
  },
  "visible": true,
  "loc": "serde_derive_internals/src/attr.rs:238:5:546:6",
  "doc": "/// Extract out the `#[serde(...)]` attributes from an item.\n",
  "code": [
    "pub fn from_ast(cx: &Ctxt, item: &syn::DeriveInput) -> Self {",
    "    let mut ser_name = Attr::none(cx, RENAME);",
    "    let mut de_name = Attr::none(cx, RENAME);",
    "    let mut transparent = BoolAttr::none(cx, TRANSPARENT);",
    "    let mut deny_unknown_fields = BoolAttr::none(cx, DENY_UNKNOWN_FIELDS);",
    "    let mut default = Attr::none(cx, DEFAULT);",
    "    let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);",
    "    let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);",
    "    let mut rename_all_fields_ser_rule = Attr::none(cx, RENAME_ALL_FIELDS);",
    "    let mut rename_all_fields_de_rule = Attr::none(cx, RENAME_ALL_FIELDS);",
    "    let mut ser_bound = Attr::none(cx, BOUND);",
    "    let mut de_bound = Attr::none(cx, BOUND);",
    "    let mut untagged = BoolAttr::none(cx, UNTAGGED);",
    "    let mut internal_tag = Attr::none(cx, TAG);",
    "    let mut content = Attr::none(cx, CONTENT);",
    "    let mut type_from = Attr::none(cx, FROM);",
    "    let mut type_try_from = Attr::none(cx, TRY_FROM);",
    "    let mut type_into = Attr::none(cx, INTO);",
    "    let mut remote = Attr::none(cx, REMOTE);",
    "    let mut field_identifier = BoolAttr::none(cx, FIELD_IDENTIFIER);",
    "    let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);",
    "    let mut serde_path = Attr::none(cx, CRATE);",
    "    let mut expecting = Attr::none(cx, EXPECTING);",
    "    let mut non_exhaustive = false;",
    "",
    "    for attr in &item.attrs {",
    "        if attr.path() != SERDE {",
    "            non_exhaustive |=",
    "                matches!(&attr.meta, syn::Meta::Path(path) if path == NON_EXHAUSTIVE);",
    "            continue;",
    "        }",
    "",
    "        if let syn::Meta::List(meta) = &attr.meta {",
    "            if meta.tokens.is_empty() {",
    "                continue;",
    "            }",
    "        }",
    "",
    "        if let Err(err) = attr.parse_nested_meta(|meta| {",
    "            if meta.path == RENAME {",
    "                // #[serde(rename = \"foo\")]",
    "                // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]",
    "                let (ser, de) = get_renames(cx, RENAME, &meta)?;",
    "                ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));",
    "                de_name.set_opt(&meta.path, de.as_ref().map(Name::from));",
    "            } else if meta.path == RENAME_ALL {",
    "                // #[serde(rename_all = \"foo\")]",
    "                // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]",
    "                let one_name = meta.input.peek(Token![=]);",
    "                let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;",
    "                if let Some(ser) = ser {",
    "                    match RenameRule::from_str(&ser.value()) {",
    "                        Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),",
    "                        Err(err) => cx.error_spanned_by(ser, err),",
    "                    }",
    "                }",
    "                if let Some(de) = de {",
    "                    match RenameRule::from_str(&de.value()) {",
    "                        Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),",
    "                        Err(err) => {",
    "                            if !one_name {",
    "                                cx.error_spanned_by(de, err);",
    "                            }",
    "                        }",
    "                    }",
    "                }",
    "            } else if meta.path == RENAME_ALL_FIELDS {",
    "                // #[serde(rename_all_fields = \"foo\")]",
    "                // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]",
    "                let one_name = meta.input.peek(Token![=]);",
    "                let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;",
    "",
    "                match item.data {",
    "                    syn::Data::Enum(_) => {",
    "                        if let Some(ser) = ser {",
    "                            match RenameRule::from_str(&ser.value()) {",
    "                                Ok(rename_rule) => {",
    "                                    rename_all_fields_ser_rule.set(&meta.path, rename_rule);",
    "                                }",
    "                                Err(err) => cx.error_spanned_by(ser, err),",
    "                            }",
    "                        }",
    "                        if let Some(de) = de {",
    "                            match RenameRule::from_str(&de.value()) {",
    "                                Ok(rename_rule) => {",
    "                                    rename_all_fields_de_rule.set(&meta.path, rename_rule);",
    "                                }",
    "                                Err(err) => {",
    "                                    if !one_name {",
    "                                        cx.error_spanned_by(de, err);",
    "                                    }",
    "                                }",
    "                            }",
    "                        }",
    "                    }",
    "                    syn::Data::Struct(_) => {",
    "                        let msg = \"#[serde(rename_all_fields)] can only be used on enums\";",
    "                        cx.syn_error(meta.error(msg));",
    "                    }",
    "                    syn::Data::Union(_) => {",
    "                        let msg = \"#[serde(rename_all_fields)] can only be used on enums\";",
    "                        cx.syn_error(meta.error(msg));",
    "                    }",
    "                }",
    "            } else if meta.path == TRANSPARENT {",
    "                // #[serde(transparent)]",
    "                transparent.set_true(meta.path);",
    "            } else if meta.path == DENY_UNKNOWN_FIELDS {",
    "                // #[serde(deny_unknown_fields)]",
    "                deny_unknown_fields.set_true(meta.path);",
    "            } else if meta.path == DEFAULT {",
    "                if meta.input.peek(Token![=]) {",
    "                    // #[serde(default = \"...\")]",
    "                    if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {",
    "                        match &item.data {",
    "                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {",
    "                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {",
    "                                    default.set(&meta.path, Default::Path(path));",
    "                                }",
    "                                syn::Fields::Unit => {",
    "                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";",
    "                                    cx.syn_error(meta.error(msg));",
    "                                }",
    "                            },",
    "                            syn::Data::Enum(_) => {",
    "                                let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";",
    "                                cx.syn_error(meta.error(msg));",
    "                            }",
    "                            syn::Data::Union(_) => {",
    "                                let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";",
    "                                cx.syn_error(meta.error(msg));",
    "                            }",
    "                        }",
    "                    }",
    "                } else {",
    "                    // #[serde(default)]",
    "                    match &item.data {",
    "                        syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {",
    "                            syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {",
    "                                default.set(meta.path, Default::Default);",
    "                            }",
    "                            syn::Fields::Unit => {",
    "                                let msg = \"#[serde(default)] can only be used on structs that have fields\";",
    "                                cx.error_spanned_by(fields, msg);",
    "                            }",
    "                        },",
    "                        syn::Data::Enum(_) => {",
    "                            let msg = \"#[serde(default)] can only be used on structs\";",
    "                            cx.syn_error(meta.error(msg));",
    "                        }",
    "                        syn::Data::Union(_) => {",
    "                            let msg = \"#[serde(default)] can only be used on structs\";",
    "                            cx.syn_error(meta.error(msg));",
    "                        }",
    "                    }",
    "                }",
    "            } else if meta.path == BOUND {",
    "                // #[serde(bound = \"T: SomeBound\")]",
    "                // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]",
    "                let (ser, de) = get_where_predicates(cx, &meta)?;",
    "                ser_bound.set_opt(&meta.path, ser);",
    "                de_bound.set_opt(&meta.path, de);",
    "            } else if meta.path == UNTAGGED {",
    "                // #[serde(untagged)]",
    "                match item.data {",
    "                    syn::Data::Enum(_) => {",
    "                        untagged.set_true(&meta.path);",
    "                    }",
    "                    syn::Data::Struct(_) => {",
    "                        let msg = \"#[serde(untagged)] can only be used on enums\";",
    "                        cx.syn_error(meta.error(msg));",
    "                    }",
    "                    syn::Data::Union(_) => {",
    "                        let msg = \"#[serde(untagged)] can only be used on enums\";",
    "                        cx.syn_error(meta.error(msg));",
    "                    }",
    "                }",
    "            } else if meta.path == TAG {",
    "                // #[serde(tag = \"type\")]",
    "                if let Some(s) = get_lit_str(cx, TAG, &meta)? {",
    "                    match &item.data {",
    "                        syn::Data::Enum(_) => {",
    "                            internal_tag.set(&meta.path, s.value());",
    "                        }",
    "                        syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {",
    "                            syn::Fields::Named(_) => {",
    "                                internal_tag.set(&meta.path, s.value());",
    "                            }",
    "                            syn::Fields::Unnamed(_) | syn::Fields::Unit => {",
    "                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";",
    "                                cx.syn_error(meta.error(msg));",
    "                            }",
    "                        },",
    "                        syn::Data::Union(_) => {",
    "                            let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";",
    "                            cx.syn_error(meta.error(msg));",
    "                        }",
    "                    }",
    "                }",
    "            } else if meta.path == CONTENT {",
    "                // #[serde(content = \"c\")]",
    "                if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {",
    "                    match &item.data {",
    "                        syn::Data::Enum(_) => {",
    "                            content.set(&meta.path, s.value());",
    "                        }",
    "                        syn::Data::Struct(_) => {",
    "                            let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";",
    "                            cx.syn_error(meta.error(msg));",
    "                        }",
    "                        syn::Data::Union(_) => {",
    "                            let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";",
    "                            cx.syn_error(meta.error(msg));",
    "                        }",
    "                    }",
    "                }",
    "            } else if meta.path == FROM {",
    "                // #[serde(from = \"Type\")]",
    "                if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {",
    "                    type_from.set_opt(&meta.path, Some(from_ty));",
    "                }",
    "            } else if meta.path == TRY_FROM {",
    "                // #[serde(try_from = \"Type\")]",
    "                if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {",
    "                    type_try_from.set_opt(&meta.path, Some(try_from_ty));",
    "                }",
    "            } else if meta.path == INTO {",
    "                // #[serde(into = \"Type\")]",
    "                if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {",
    "                    type_into.set_opt(&meta.path, Some(into_ty));",
    "                }",
    "            } else if meta.path == REMOTE {",
    "                // #[serde(remote = \"...\")]",
    "                if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {",
    "                    if is_primitive_path(&path, \"Self\") {",
    "                        remote.set(&meta.path, item.ident.clone().into());",
    "                    } else {",
    "                        remote.set(&meta.path, path);",
    "                    }",
    "                }",
    "            } else if meta.path == FIELD_IDENTIFIER {",
    "                // #[serde(field_identifier)]",
    "                field_identifier.set_true(&meta.path);",
    "            } else if meta.path == VARIANT_IDENTIFIER {",
    "                // #[serde(variant_identifier)]",
    "                variant_identifier.set_true(&meta.path);",
    "            } else if meta.path == CRATE {",
    "                // #[serde(crate = \"foo\")]",
    "                if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {",
    "                    serde_path.set(&meta.path, path);",
    "                }",
    "            } else if meta.path == EXPECTING {",
    "                // #[serde(expecting = \"a message\")]",
    "                if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {",
    "                    expecting.set(&meta.path, s.value());",
    "                }",
    "            } else {",
    "                let path = meta.path.to_token_stream().to_string().replace(' ', \"\");",
    "                return Err(",
    "                    meta.error(format_args!(\"unknown serde container attribute `{}`\", path))",
    "                );",
    "            }",
    "            Ok(())",
    "        }) {",
    "            cx.syn_error(err);",
    "        }",
    "    }",
    "",
    "    let mut is_packed = false;",
    "    for attr in &item.attrs {",
    "        if attr.path() == REPR {",
    "            let _ = attr.parse_args_with(|input: ParseStream| {",
    "                while let Some(token) = input.parse()? {",
    "                    if let TokenTree::Ident(ident) = token {",
    "                        is_packed |= ident == \"packed\";",
    "                    }",
    "                }",
    "                Ok(())",
    "            });",
    "        }",
    "    }",
    "",
    "    Container {",
    "        name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),",
    "        transparent: transparent.get(),",
    "        deny_unknown_fields: deny_unknown_fields.get(),",
    "        default: default.get().unwrap_or(Default::None),",
    "        rename_all_rules: RenameAllRules {",
    "            serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),",
    "            deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),",
    "        },",
    "        rename_all_fields_rules: RenameAllRules {",
    "            serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),",
    "            deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),",
    "        },",
    "        ser_bound: ser_bound.get(),",
    "        de_bound: de_bound.get(),",
    "        tag: decide_tag(cx, item, untagged, internal_tag, content),",
    "        type_from: type_from.get(),",
    "        type_try_from: type_try_from.get(),",
    "        type_into: type_into.get(),",
    "        remote: remote.get(),",
    "        identifier: decide_identifier(cx, item, field_identifier, variant_identifier),",
    "        serde_path: serde_path.get(),",
    "        is_packed,",
    "        expecting: expecting.get(),",
    "        non_exhaustive,",
    "    }",
    "}"
  ],
  "size": {
    "chain": 27,
    "contra": 26,
    "min_set": 6
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "false",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches _",
          "norm": null,
          "value": "true",
          "line": 459,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        34,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "false",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches _",
          "norm": null,
          "value": "true",
          "line": 459,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        34,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "false",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches _",
          "norm": null,
          "value": "true",
          "line": 459,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        34,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "path == NON_EXHAUSTIVE",
          "norm": "NON_EXHAUSTIVE == path",
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        35,
        36,
        37,
        38,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "path == NON_EXHAUSTIVE",
          "norm": "NON_EXHAUSTIVE == path",
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        35,
        36,
        37,
        38,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "path == NON_EXHAUSTIVE",
          "norm": "NON_EXHAUSTIVE == path",
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        35,
        36,
        37,
        38,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "path == NON_EXHAUSTIVE",
          "norm": "NON_EXHAUSTIVE == path",
          "value": "false",
          "line": 266,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        35,
        36,
        37,
        39,
        34,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "path == NON_EXHAUSTIVE",
          "norm": "NON_EXHAUSTIVE == path",
          "value": "false",
          "line": 266,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        35,
        36,
        37,
        39,
        34,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 264,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "&attr.meta matches syn::Meta::Path(path)",
          "norm": null,
          "value": "true",
          "line": 266,
          "bound": null
        },
        {
          "cond": "path == NON_EXHAUSTIVE",
          "norm": "NON_EXHAUSTIVE == path",
          "value": "false",
          "line": 266,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        33,
        35,
        36,
        37,
        39,
        34,
        40,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        42,
        48,
        49,
        53,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        42,
        48,
        49,
        53,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        42,
        48,
        49,
        53,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        42,
        48,
        49,
        50,
        51,
        52,
        54,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 14,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        42,
        48,
        49,
        50,
        51,
        52,
        54,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 15,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        42,
        48,
        49,
        50,
        51,
        52,
        54,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 16,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        46,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 17,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        46,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 18,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "true",
          "line": 271,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        46,
        57,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 19,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        47,
        48,
        49,
        53,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 20,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        47,
        48,
        49,
        53,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 21,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        47,
        48,
        49,
        53,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 22,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        47,
        48,
        49,
        50,
        51,
        52,
        54,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 23,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        47,
        48,
        49,
        50,
        51,
        52,
        54,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 24,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 270,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 271,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_renames(cx, RENAME, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    de_name.set_opt(&meta.path, de.as_ref().map(Name::from));\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == RENAME_ALL_FIELDS {\n                    // #[serde(rename_all_fields = \"foo\")]\n                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => cx.error_spanned_by(ser, err),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n                                    }\n                                    Err(err) => {\n                                        if !one_name {\n                                            cx.error_spanned_by(de, err);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TRANSPARENT {\n                    // #[serde(transparent)]\n                    transparent.set_true(meta.path);\n                } else if meta.path == DENY_UNKNOWN_FIELDS {\n                    // #[serde(deny_unknown_fields)]\n                    deny_unknown_fields.set_true(meta.path);\n                } else if meta.path == DEFAULT {\n                    if meta.input.peek(Token![=]) {\n                        // #[serde(default = \"...\")]\n                        if let Some(path) = parse_lit_into_expr_path(cx, DEFAULT, &meta)? {\n                            match &item.data {\n                                syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                    syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                        default.set(&meta.path, Default::Path(path));\n                                    }\n                                    syn::Fields::Unit => {\n                                        let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs that have fields\";\n                                        cx.syn_error(meta.error(msg));\n                                    }\n                                },\n                                syn::Data::Enum(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                                syn::Data::Union(_) => {\n                                    let msg = \"#[serde(default = \\\"...\\\")] can only be used on structs\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            }\n                        }\n                    } else {\n                        // #[serde(default)]\n                        match &item.data {\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) | syn::Fields::Unnamed(_) => {\n                                    default.set(meta.path, Default::Default);\n                                }\n                                syn::Fields::Unit => {\n                                    let msg = \"#[serde(default)] can only be used on structs that have fields\";\n                                    cx.error_spanned_by(fields, msg);\n                                }\n                            },\n                            syn::Data::Enum(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(default)] can only be used on structs\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == UNTAGGED {\n                    // #[serde(untagged)]\n                    match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(&meta.path);\n                        }\n                        syn::Data::Struct(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                        syn::Data::Union(_) => {\n                            let msg = \"#[serde(untagged)] can only be used on enums\";\n                            cx.syn_error(meta.error(msg));\n                        }\n                    }\n                } else if meta.path == TAG {\n                    // #[serde(tag = \"type\")]\n                    if let Some(s) = get_lit_str(cx, TAG, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                internal_tag.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(syn::DataStruct { fields, .. }) => match fields {\n                                syn::Fields::Named(_) => {\n                                    internal_tag.set(&meta.path, s.value());\n                                }\n                                syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                    let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                    cx.syn_error(meta.error(msg));\n                                }\n                            },\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(tag = \\\"...\\\")] can only be used on enums and structs with named fields\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == CONTENT {\n                    // #[serde(content = \"c\")]\n                    if let Some(s) = get_lit_str(cx, CONTENT, &meta)? {\n                        match &item.data {\n                            syn::Data::Enum(_) => {\n                                content.set(&meta.path, s.value());\n                            }\n                            syn::Data::Struct(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                            syn::Data::Union(_) => {\n                                let msg = \"#[serde(content = \\\"...\\\")] can only be used on enums\";\n                                cx.syn_error(meta.error(msg));\n                            }\n                        }\n                    }\n                } else if meta.path == FROM {\n                    // #[serde(from = \"Type\")]\n                    if let Some(from_ty) = parse_lit_into_ty(cx, FROM, &meta)? {\n                        type_from.set_opt(&meta.path, Some(from_ty));\n                    }\n                } else if meta.path == TRY_FROM {\n                    // #[serde(try_from = \"Type\")]\n                    if let Some(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &meta)? {\n                        type_try_from.set_opt(&meta.path, Some(try_from_ty));\n                    }\n                } else if meta.path == INTO {\n                    // #[serde(into = \"Type\")]\n                    if let Some(into_ty) = parse_lit_into_ty(cx, INTO, &meta)? {\n                        type_into.set_opt(&meta.path, Some(into_ty));\n                    }\n                } else if meta.path == REMOTE {\n                    // #[serde(remote = \"...\")]\n                    if let Some(path) = parse_lit_into_path(cx, REMOTE, &meta)? {\n                        if is_primitive_path(&path, \"Self\") {\n                            remote.set(&meta.path, item.ident.clone().into());\n                        } else {\n                            remote.set(&meta.path, path);\n                        }\n                    }\n                } else if meta.path == FIELD_IDENTIFIER {\n                    // #[serde(field_identifier)]\n                    field_identifier.set_true(&meta.path);\n                } else if meta.path == VARIANT_IDENTIFIER {\n                    // #[serde(variant_identifier)]\n                    variant_identifier.set_true(&meta.path);\n                } else if meta.path == CRATE {\n                    // #[serde(crate = \"foo\")]\n                    if let Some(path) = parse_lit_into_path(cx, CRATE, &meta)? {\n                        serde_path.set(&meta.path, path);\n                    }\n                } else if meta.path == EXPECTING {\n                    // #[serde(expecting = \"a message\")]\n                    if let Some(s) = get_lit_str(cx, EXPECTING, &meta)? {\n                        expecting.set(&meta.path, s.value());\n                    }\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde container attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        29,
        31,
        32,
        41,
        43,
        44,
        45,
        47,
        48,
        49,
        50,
        51,
        52,
        54,
        55,
        56,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 25,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "true",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        68,
        69,
        70,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 26,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "true",
          "line": 507,
          "bound": null
        },
        {
          "cond": "attr.path() == REPR",
          "norm": "REPR == attr.path()",
          "value": "false",
          "line": 508,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        64,
        66,
        67,
        71,
        72,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 27,
      "conds": [
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 263,
          "bound": null
        },
        {
          "cond": "attr in &item.attrs",
          "norm": null,
          "value": "false",
          "line": 507,
          "bound": null
        }
      ],
      "ret": "Container {\n            name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            rename_all_fields_rules: RenameAllRules {\n                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            serde_path: serde_path.get(),\n            is_packed,\n            expecting: expecting.get(),\n            non_exhaustive,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        28,
        30,
        58,
        59,
        60,
        61,
        63,
        65,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}