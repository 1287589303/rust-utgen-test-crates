{
  "name": "serde_derive_internals::internals::attr::{impl#6}::from_ast",
  "mod_info": {
    "name": "internals::attr",
    "loc": "serde_derive_internals/src/mod.rs:2:1:2:14"
  },
  "visible": true,
  "loc": "serde_derive_internals/src/attr.rs:754:5:921:6",
  "doc": "",
  "code": [
    "pub fn from_ast(cx: &Ctxt, variant: &syn::Variant) -> Self {",
    "    let mut ser_name = Attr::none(cx, RENAME);",
    "    let mut de_name = Attr::none(cx, RENAME);",
    "    let mut de_aliases = VecAttr::none(cx, RENAME);",
    "    let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);",
    "    let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);",
    "    let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);",
    "    let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);",
    "    let mut ser_bound = Attr::none(cx, BOUND);",
    "    let mut de_bound = Attr::none(cx, BOUND);",
    "    let mut other = BoolAttr::none(cx, OTHER);",
    "    let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);",
    "    let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);",
    "    let mut borrow = Attr::none(cx, BORROW);",
    "    let mut untagged = BoolAttr::none(cx, UNTAGGED);",
    "",
    "    for attr in &variant.attrs {",
    "        if attr.path() != SERDE {",
    "            continue;",
    "        }",
    "",
    "        if let syn::Meta::List(meta) = &attr.meta {",
    "            if meta.tokens.is_empty() {",
    "                continue;",
    "            }",
    "        }",
    "",
    "        if let Err(err) = attr.parse_nested_meta(|meta| {",
    "            if meta.path == RENAME {",
    "                // #[serde(rename = \"foo\")]",
    "                // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]",
    "                let (ser, de) = get_multiple_renames(cx, &meta)?;",
    "                ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));",
    "                for de_value in de {",
    "                    de_name.set_if_none(Name::from(&de_value));",
    "                    de_aliases.insert(&meta.path, Name::from(&de_value));",
    "                }",
    "            } else if meta.path == ALIAS {",
    "                // #[serde(alias = \"foo\")]",
    "                if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {",
    "                    de_aliases.insert(&meta.path, Name::from(&s));",
    "                }",
    "            } else if meta.path == RENAME_ALL {",
    "                // #[serde(rename_all = \"foo\")]",
    "                // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]",
    "                let one_name = meta.input.peek(Token![=]);",
    "                let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;",
    "                if let Some(ser) = ser {",
    "                    match RenameRule::from_str(&ser.value()) {",
    "                        Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),",
    "                        Err(err) => cx.error_spanned_by(ser, err),",
    "                    }",
    "                }",
    "                if let Some(de) = de {",
    "                    match RenameRule::from_str(&de.value()) {",
    "                        Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),",
    "                        Err(err) => {",
    "                            if !one_name {",
    "                                cx.error_spanned_by(de, err);",
    "                            }",
    "                        }",
    "                    }",
    "                }",
    "            } else if meta.path == SKIP {",
    "                // #[serde(skip)]",
    "                skip_serializing.set_true(&meta.path);",
    "                skip_deserializing.set_true(&meta.path);",
    "            } else if meta.path == SKIP_DESERIALIZING {",
    "                // #[serde(skip_deserializing)]",
    "                skip_deserializing.set_true(&meta.path);",
    "            } else if meta.path == SKIP_SERIALIZING {",
    "                // #[serde(skip_serializing)]",
    "                skip_serializing.set_true(&meta.path);",
    "            } else if meta.path == OTHER {",
    "                // #[serde(other)]",
    "                other.set_true(&meta.path);",
    "            } else if meta.path == BOUND {",
    "                // #[serde(bound = \"T: SomeBound\")]",
    "                // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]",
    "                let (ser, de) = get_where_predicates(cx, &meta)?;",
    "                ser_bound.set_opt(&meta.path, ser);",
    "                de_bound.set_opt(&meta.path, de);",
    "            } else if meta.path == WITH {",
    "                // #[serde(with = \"...\")]",
    "                if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {",
    "                    let mut ser_path = path.clone();",
    "                    ser_path",
    "                        .path",
    "                        .segments",
    "                        .push(Ident::new(\"serialize\", ser_path.span()).into());",
    "                    serialize_with.set(&meta.path, ser_path);",
    "                    let mut de_path = path;",
    "                    de_path",
    "                        .path",
    "                        .segments",
    "                        .push(Ident::new(\"deserialize\", de_path.span()).into());",
    "                    deserialize_with.set(&meta.path, de_path);",
    "                }",
    "            } else if meta.path == SERIALIZE_WITH {",
    "                // #[serde(serialize_with = \"...\")]",
    "                if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {",
    "                    serialize_with.set(&meta.path, path);",
    "                }",
    "            } else if meta.path == DESERIALIZE_WITH {",
    "                // #[serde(deserialize_with = \"...\")]",
    "                if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {",
    "                    deserialize_with.set(&meta.path, path);",
    "                }",
    "            } else if meta.path == BORROW {",
    "                let borrow_attribute = if meta.input.peek(Token![=]) {",
    "                    // #[serde(borrow = \"'a + 'b\")]",
    "                    let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;",
    "                    BorrowAttribute {",
    "                        path: meta.path.clone(),",
    "                        lifetimes: Some(lifetimes),",
    "                    }",
    "                } else {",
    "                    // #[serde(borrow)]",
    "                    BorrowAttribute {",
    "                        path: meta.path.clone(),",
    "                        lifetimes: None,",
    "                    }",
    "                };",
    "                match &variant.fields {",
    "                    syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {",
    "                        borrow.set(&meta.path, borrow_attribute);",
    "                    }",
    "                    _ => {",
    "                        let msg = \"#[serde(borrow)] may only be used on newtype variants\";",
    "                        cx.error_spanned_by(variant, msg);",
    "                    }",
    "                }",
    "            } else if meta.path == UNTAGGED {",
    "                untagged.set_true(&meta.path);",
    "            } else {",
    "                let path = meta.path.to_token_stream().to_string().replace(' ', \"\");",
    "                return Err(",
    "                    meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))",
    "                );",
    "            }",
    "            Ok(())",
    "        }) {",
    "            cx.syn_error(err);",
    "        }",
    "    }",
    "",
    "    Variant {",
    "        name: MultiName::from_attrs(",
    "            Name::from(&unraw(&variant.ident)),",
    "            ser_name,",
    "            de_name,",
    "            Some(de_aliases),",
    "        ),",
    "        rename_all_rules: RenameAllRules {",
    "            serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),",
    "            deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),",
    "        },",
    "        ser_bound: ser_bound.get(),",
    "        de_bound: de_bound.get(),",
    "        skip_deserializing: skip_deserializing.get(),",
    "        skip_serializing: skip_serializing.get(),",
    "        other: other.get(),",
    "        serialize_with: serialize_with.get(),",
    "        deserialize_with: deserialize_with.get(),",
    "        borrow: borrow.get(),",
    "        untagged: untagged.get(),",
    "    }",
    "}"
  ],
  "size": {
    "chain": 7,
    "contra": 6,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "true",
          "line": 770,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "true",
          "line": 771,
          "bound": null
        },
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "false",
          "line": 770,
          "bound": null
        }
      ],
      "ret": "Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        25,
        42,
        16,
        17,
        18,
        20,
        22,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "true",
          "line": 770,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 771,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 775,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == OTHER {\n                    // #[serde(other)]\n                    other.set_true(&meta.path);\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == BORROW {\n                    let borrow_attribute = if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: Some(lifetimes),\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: None,\n                        }\n                    };\n                    match &variant.fields {\n                        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(&meta.path, borrow_attribute);\n                        }\n                        _ => {\n                            let msg = \"#[serde(borrow)] may only be used on newtype variants\";\n                            cx.error_spanned_by(variant, msg);\n                        }\n                    }\n                } else if meta.path == UNTAGGED {\n                    untagged.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 781,
          "bound": null
        },
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "false",
          "line": 770,
          "bound": null
        }
      ],
      "ret": "Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        26,
        27,
        33,
        34,
        38,
        40,
        41,
        16,
        17,
        18,
        20,
        22,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "true",
          "line": 770,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 771,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 775,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == OTHER {\n                    // #[serde(other)]\n                    other.set_true(&meta.path);\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == BORROW {\n                    let borrow_attribute = if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: Some(lifetimes),\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: None,\n                        }\n                    };\n                    match &variant.fields {\n                        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(&meta.path, borrow_attribute);\n                        }\n                        _ => {\n                            let msg = \"#[serde(borrow)] may only be used on newtype variants\";\n                            cx.error_spanned_by(variant, msg);\n                        }\n                    }\n                } else if meta.path == UNTAGGED {\n                    untagged.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 781,
          "bound": null
        },
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "false",
          "line": 770,
          "bound": null
        }
      ],
      "ret": "Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        26,
        27,
        33,
        34,
        35,
        36,
        37,
        39,
        40,
        41,
        16,
        17,
        18,
        20,
        22,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "true",
          "line": 770,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 771,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 775,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "true",
          "line": 776,
          "bound": null
        },
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "false",
          "line": 770,
          "bound": null
        }
      ],
      "ret": "Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        26,
        28,
        29,
        30,
        31,
        42,
        16,
        17,
        18,
        20,
        22,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "true",
          "line": 770,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 771,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 775,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 776,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == OTHER {\n                    // #[serde(other)]\n                    other.set_true(&meta.path);\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == BORROW {\n                    let borrow_attribute = if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: Some(lifetimes),\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: None,\n                        }\n                    };\n                    match &variant.fields {\n                        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(&meta.path, borrow_attribute);\n                        }\n                        _ => {\n                            let msg = \"#[serde(borrow)] may only be used on newtype variants\";\n                            cx.error_spanned_by(variant, msg);\n                        }\n                    }\n                } else if meta.path == UNTAGGED {\n                    untagged.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 781,
          "bound": null
        },
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "false",
          "line": 770,
          "bound": null
        }
      ],
      "ret": "Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        26,
        28,
        29,
        30,
        32,
        33,
        34,
        38,
        40,
        41,
        16,
        17,
        18,
        20,
        22,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "true",
          "line": 770,
          "bound": null
        },
        {
          "cond": "attr.path() != SERDE",
          "norm": "SERDE != attr.path()",
          "value": "false",
          "line": 771,
          "bound": null
        },
        {
          "cond": "let syn::Meta::List(meta) = &attr.meta",
          "norm": null,
          "value": "true",
          "line": 775,
          "bound": null
        },
        {
          "cond": "meta.tokens.is_empty()",
          "norm": null,
          "value": "false",
          "line": 776,
          "bound": null
        },
        {
          "cond": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == OTHER {\n                    // #[serde(other)]\n                    other.set_true(&meta.path);\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == BORROW {\n                    let borrow_attribute = if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: Some(lifetimes),\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: None,\n                        }\n                    };\n                    match &variant.fields {\n                        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(&meta.path, borrow_attribute);\n                        }\n                        _ => {\n                            let msg = \"#[serde(borrow)] may only be used on newtype variants\";\n                            cx.error_spanned_by(variant, msg);\n                        }\n                    }\n                } else if meta.path == UNTAGGED {\n                    untagged.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })",
          "norm": null,
          "value": "true",
          "line": 781,
          "bound": null
        },
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "false",
          "line": 770,
          "bound": null
        }
      ],
      "ret": "Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        26,
        28,
        29,
        30,
        32,
        33,
        34,
        35,
        36,
        37,
        39,
        40,
        41,
        16,
        17,
        18,
        20,
        22,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "attr in &variant.attrs",
          "norm": null,
          "value": "false",
          "line": 770,
          "bound": null
        }
      ],
      "ret": "Variant {\n            name: MultiName::from_attrs(\n                Name::from(&unraw(&variant.ident)),\n                ser_name,\n                de_name,\n                Some(de_aliases),\n            ),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n            untagged: untagged.get(),\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}