{
  "serde_derive_internals/src/attr.rs:775:16:775:54": [
    {
      "Bool": {
        "Other": "let syn::Meta::List(meta) = &attr.meta"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:771:16:771:36": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ne",
          "expr": "attr.path() != SERDE",
          "lhs": "attr.path()",
          "rhs": "SERDE",
          "cmp_with_int": false
        }
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:781:16:895:15": [
    {
      "Bool": {
        "Other": "let Err(err) = attr.parse_nested_meta(|meta| {\n                if meta.path == RENAME {\n                    // #[serde(rename = \"foo\")]\n                    // #[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]\n                    let (ser, de) = get_multiple_renames(cx, &meta)?;\n                    ser_name.set_opt(&meta.path, ser.as_ref().map(Name::from));\n                    for de_value in de {\n                        de_name.set_if_none(Name::from(&de_value));\n                        de_aliases.insert(&meta.path, Name::from(&de_value));\n                    }\n                } else if meta.path == ALIAS {\n                    // #[serde(alias = \"foo\")]\n                    if let Some(s) = get_lit_str(cx, ALIAS, &meta)? {\n                        de_aliases.insert(&meta.path, Name::from(&s));\n                    }\n                } else if meta.path == RENAME_ALL {\n                    // #[serde(rename_all = \"foo\")]\n                    // #[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]\n                    let one_name = meta.input.peek(Token![=]);\n                    let (ser, de) = get_renames(cx, RENAME_ALL, &meta)?;\n                    if let Some(ser) = ser {\n                        match RenameRule::from_str(&ser.value()) {\n                            Ok(rename_rule) => rename_all_ser_rule.set(&meta.path, rename_rule),\n                            Err(err) => cx.error_spanned_by(ser, err),\n                        }\n                    }\n                    if let Some(de) = de {\n                        match RenameRule::from_str(&de.value()) {\n                            Ok(rename_rule) => rename_all_de_rule.set(&meta.path, rename_rule),\n                            Err(err) => {\n                                if !one_name {\n                                    cx.error_spanned_by(de, err);\n                                }\n                            }\n                        }\n                    }\n                } else if meta.path == SKIP {\n                    // #[serde(skip)]\n                    skip_serializing.set_true(&meta.path);\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_DESERIALIZING {\n                    // #[serde(skip_deserializing)]\n                    skip_deserializing.set_true(&meta.path);\n                } else if meta.path == SKIP_SERIALIZING {\n                    // #[serde(skip_serializing)]\n                    skip_serializing.set_true(&meta.path);\n                } else if meta.path == OTHER {\n                    // #[serde(other)]\n                    other.set_true(&meta.path);\n                } else if meta.path == BOUND {\n                    // #[serde(bound = \"T: SomeBound\")]\n                    // #[serde(bound(serialize = \"...\", deserialize = \"...\"))]\n                    let (ser, de) = get_where_predicates(cx, &meta)?;\n                    ser_bound.set_opt(&meta.path, ser);\n                    de_bound.set_opt(&meta.path, de);\n                } else if meta.path == WITH {\n                    // #[serde(with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, WITH, &meta)? {\n                        let mut ser_path = path.clone();\n                        ser_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"serialize\", ser_path.span()).into());\n                        serialize_with.set(&meta.path, ser_path);\n                        let mut de_path = path;\n                        de_path\n                            .path\n                            .segments\n                            .push(Ident::new(\"deserialize\", de_path.span()).into());\n                        deserialize_with.set(&meta.path, de_path);\n                    }\n                } else if meta.path == SERIALIZE_WITH {\n                    // #[serde(serialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &meta)? {\n                        serialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == DESERIALIZE_WITH {\n                    // #[serde(deserialize_with = \"...\")]\n                    if let Some(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &meta)? {\n                        deserialize_with.set(&meta.path, path);\n                    }\n                } else if meta.path == BORROW {\n                    let borrow_attribute = if meta.input.peek(Token![=]) {\n                        // #[serde(borrow = \"'a + 'b\")]\n                        let lifetimes = parse_lit_into_lifetimes(cx, &meta)?;\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: Some(lifetimes),\n                        }\n                    } else {\n                        // #[serde(borrow)]\n                        BorrowAttribute {\n                            path: meta.path.clone(),\n                            lifetimes: None,\n                        }\n                    };\n                    match &variant.fields {\n                        syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(&meta.path, borrow_attribute);\n                        }\n                        _ => {\n                            let msg = \"#[serde(borrow)] may only be used on newtype variants\";\n                            cx.error_spanned_by(variant, msg);\n                        }\n                    }\n                } else if meta.path == UNTAGGED {\n                    untagged.set_true(&meta.path);\n                } else {\n                    let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                    return Err(\n                        meta.error(format_args!(\"unknown serde variant attribute `{}`\", path))\n                    );\n                }\n                Ok(())\n            })"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:776:20:776:42": [
    {
      "Bool": {
        "Other": "meta.tokens.is_empty()"
      }
    }
  ],
  "serde_derive_internals/src/attr.rs:770:21:770:35": [
    {
      "For": {
        "iter_var": "attr",
        "iter_range": "&variant.attrs"
      }
    }
  ]
}