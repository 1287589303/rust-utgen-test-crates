{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94","manifest_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/proc-macro2-1.0.94/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/proc-macro2-1.0.94/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["proc-macro"],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/build/proc-macro2-0c3d45c0079797c8/build-script-build"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94","linked_libs":[],"linked_paths":[],"cfgs":["wrap_proc_macro","proc_macro_span"],"env":[],"out_dir":"/home/abezbm/rust-utgen-test-crates/serde/target/debug/build/proc-macro2-3bfb6d3b5c679c6f/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.18","manifest_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/unicode-ident-1.0.18/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"unicode_ident","src_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/unicode-ident-1.0.18/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libunicode_ident-926027468c5cecb0.rlib","/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libunicode_ident-926027468c5cecb0.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94","manifest_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/proc-macro2-1.0.94/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"proc_macro2","src_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/proc-macro2-1.0.94/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["proc-macro"],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libproc_macro2-266ccd2fb7e5af8f.rlib","/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libproc_macro2-266ccd2fb7e5af8f.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#quote@1.0.39","manifest_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/quote-1.0.39/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"quote","src_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/quote-1.0.39/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["proc-macro"],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libquote-ba51b6359bb907e7.rlib","/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libquote-ba51b6359bb907e7.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde_derive#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde_derive/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde_derive/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/build/serde_derive-a51edaf4c064a40e/build-script-build"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/build/serde-d05a4376da9b44f6/build-script-build"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde_derive#1.0.219","linked_libs":[],"linked_paths":[],"cfgs":["check_cfg"],"env":[],"out_dir":"/home/abezbm/rust-utgen-test-crates/serde/target/debug/build/serde_derive-ced11b7b1fb35010/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#syn@2.0.100","manifest_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.100/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"syn","src_path":"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.100/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["clone-impls","derive","parsing","printing","proc-macro"],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libsyn-43438f6056661991.rlib","/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libsyn-43438f6056661991.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[],"out_dir":"/home/abezbm/rust-utgen-test-crates/serde/target/debug/build/serde-1a12532a11ede2bb/out"}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde_derive#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde_derive/Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"serde_derive","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde_derive/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["/home/abezbm/rust-utgen-test-crates/serde/target/debug/deps/libserde_derive-614ac6932407fbdd.so"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: cannot find macro `assert_matches` in this scope\n    --> serde/src/private/ser.rs:1009:5\n     |\n1009 |     assert_matches!(serializer.fields[0].1, Content::Some(_));\n     |     ^^^^^^^^^^^^^^\n     |\nhelp: consider importing this macro\n     |\n990  +     use std::assert_matches::assert_matches;\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"consider importing this macro","rendered":null,"spans":[{"byte_end":29798,"byte_start":29798,"column_end":5,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":null,"line_end":990,"line_start":990,"suggested_replacement":"use std::assert_matches::assert_matches;\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":null,"level":"error","message":"cannot find macro `assert_matches` in this scope","spans":[{"byte_end":30338,"byte_start":30324,"column_end":19,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":null,"line_end":1009,"line_start":1009,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":19,"highlight_start":5,"text":"    assert_matches!(serializer.fields[0].1, Content::Some(_));"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: the trait bound `TestError: std::error::Error` is not satisfied\n   --> serde/src/private/ser.rs:997:25\n    |\n997 |     impl ser::Error for TestError {}\n    |                         ^^^^^^^^^ the trait `std::error::Error` is not implemented for `TestError`\n    |\nnote: required by a bound in `ser::Error`\n   --> serde/src/ser/mod.rs:142:38\n    |\n142 |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n    |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n186 | declare_error_trait!(Error: Sized + StdError);\n    | --------------------------------------------- in this macro invocation\n    = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"required by a bound in `ser::Error`","rendered":null,"spans":[{"byte_end":4844,"byte_start":4833,"column_end":49,"column_start":38,"expansion":{"def_site_span":{"byte_end":4278,"byte_start":4246,"column_end":33,"column_start":1,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":false,"label":null,"line_end":130,"line_start":130,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":33,"highlight_start":1,"text":"macro_rules! declare_error_trait {"}]},"macro_decl_name":"declare_error_trait!","span":{"byte_end":6407,"byte_start":6362,"column_end":46,"column_start":1,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":false,"label":null,"line_end":186,"line_start":186,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":1,"text":"declare_error_trait!(Error: Sized + StdError);"}]}},"file_name":"serde/src/ser/mod.rs","is_primary":true,"label":"required by this bound in `Error`","line_end":142,"line_start":142,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":49,"highlight_start":38,"text":"        pub trait Error: Sized $(+ $($supertrait)::+)* {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"the trait bound `TestError: std::error::Error` is not satisfied","spans":[{"byte_end":29908,"byte_start":29899,"column_end":34,"column_start":25,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":"the trait `std::error::Error` is not implemented for `TestError`","line_end":997,"line_start":997,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":25,"text":"    impl ser::Error for TestError {}"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0046]: not all trait items implemented, missing: `custom`\n   --> serde/src/private/ser.rs:997:5\n    |\n997 |       impl ser::Error for TestError {}\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `custom` in implementation\n    |\n   ::: serde/src/ser/mod.rs:178:13\n    |\n178 | /             fn custom<T>(msg: T) -> Self\n179 | |             where\n180 | |                 T: Display;\n    | |___________________________- `custom` from trait\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"implement the missing item: `fn custom<T>(_: T) -> Self where T: std::fmt::Display { todo!() }`","rendered":null,"spans":[{"byte_end":29910,"byte_start":29910,"column_end":36,"column_start":36,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":null,"line_end":997,"line_start":997,"suggested_replacement":"    fn custom<T>(_: T) -> Self where T: std::fmt::Display { todo!() }\n    ","suggestion_applicability":"HasPlaceholders","text":[{"highlight_end":36,"highlight_start":36,"text":"    impl ser::Error for TestError {}"}]}]}],"code":{"code":"E0046","explanation":"Items are missing in a trait implementation.\n\nErroneous code example:\n\n```compile_fail,E0046\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {}\n// error: not all trait items implemented, missing: `foo`\n```\n\nWhen trying to make some type implement a trait `Foo`, you must, at minimum,\nprovide implementations for all of `Foo`'s required methods (meaning the\nmethods that do not have default implementations), as well as any required\ntrait items like associated types or constants. Example:\n\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n"},"level":"error","message":"not all trait items implemented, missing: `custom`","spans":[{"byte_end":29908,"byte_start":29879,"column_end":34,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":"missing `custom` in implementation","line_end":997,"line_start":997,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":5,"text":"    impl ser::Error for TestError {}"}]},{"byte_end":6318,"byte_start":6244,"column_end":28,"column_start":13,"expansion":{"def_site_span":{"byte_end":4278,"byte_start":4246,"column_end":33,"column_start":1,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":false,"label":null,"line_end":130,"line_start":130,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":33,"highlight_start":1,"text":"macro_rules! declare_error_trait {"}]},"macro_decl_name":"declare_error_trait!","span":{"byte_end":6407,"byte_start":6362,"column_end":46,"column_start":1,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":false,"label":null,"line_end":186,"line_start":186,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":1,"text":"declare_error_trait!(Error: Sized + StdError);"}]}},"file_name":"serde/src/ser/mod.rs","is_primary":false,"label":"`custom` from trait","line_end":180,"line_start":178,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":13,"text":"            fn custom<T>(msg: T) -> Self"},{"highlight_end":18,"highlight_start":1,"text":"            where"},{"highlight_end":28,"highlight_start":1,"text":"                T: Display;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: no method named `serialize_field` found for struct `__private::ser::content::SerializeStruct` in the current scope\n    --> serde/src/private/ser.rs:1004:16\n     |\n927  |     pub struct SerializeStruct<E> {\n     |     ----------------------------- method `serialize_field` not found for this struct\n...\n1004 |     serializer.serialize_field(\"field_some\", &Some(42)).unwrap();\n     |                ^^^^^^^^^^^^^^^\n     |\n    ::: serde/src/ser/mod.rs:1864:8\n     |\n1864 |     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n     |        --------------- the method is available for `__private::ser::content::SerializeStruct<TestError>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `skip_field` with a similar name, but with different arguments\n    --> serde/src/ser/mod.rs:1872:5\n     |\n1872 |     fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `SerializeStruct` which provides `serialize_field` is implemented but not in scope; perhaps you want to import it\n     |\n990  +     use crate::ser::SerializeStruct;\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"items from traits can only be used if the trait is in scope","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"there is a method `skip_field` with a similar name, but with different arguments","rendered":null,"spans":[{"byte_end":61109,"byte_start":61039,"column_end":75,"column_start":5,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":true,"label":null,"line_end":1872,"line_start":1872,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":75,"highlight_start":5,"text":"    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {"}]}]},{"children":[],"code":null,"level":"help","message":"trait `SerializeStruct` which provides `serialize_field` is implemented but not in scope; perhaps you want to import it","rendered":null,"spans":[{"byte_end":29798,"byte_start":29798,"column_end":5,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":null,"line_end":990,"line_start":990,"suggested_replacement":"use crate::ser::SerializeStruct;\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"no method named `serialize_field` found for struct `__private::ser::content::SerializeStruct` in the current scope","spans":[{"byte_end":28175,"byte_start":28146,"column_end":34,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":false,"label":"method `serialize_field` not found for this struct","line_end":927,"line_start":927,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":5,"text":"    pub struct SerializeStruct<E> {"}]},{"byte_end":60795,"byte_start":60780,"column_end":23,"column_start":8,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":false,"label":"the method is available for `__private::ser::content::SerializeStruct<TestError>` here","line_end":1864,"line_start":1864,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":8,"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>"}]},{"byte_end":30084,"byte_start":30069,"column_end":31,"column_start":16,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":null,"line_end":1004,"line_start":1004,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":16,"text":"    serializer.serialize_field(\"field_some\", &Some(42)).unwrap();"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: no method named `serialize_field` found for struct `__private::ser::content::SerializeStruct` in the current scope\n    --> serde/src/private/ser.rs:1005:29\n     |\n927  |     pub struct SerializeStruct<E> {\n     |     ----------------------------- method `serialize_field` not found for this struct\n...\n1005 |     let result = serializer.serialize_field(\"field_some\", &Some(42));\n     |                             ^^^^^^^^^^^^^^^\n     |\n    ::: serde/src/ser/mod.rs:1864:8\n     |\n1864 |     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n     |        --------------- the method is available for `__private::ser::content::SerializeStruct<TestError>` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `skip_field` with a similar name, but with different arguments\n    --> serde/src/ser/mod.rs:1872:5\n     |\n1872 |     fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `SerializeStruct` which provides `serialize_field` is implemented but not in scope; perhaps you want to import it\n     |\n990  +     use crate::ser::SerializeStruct;\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"items from traits can only be used if the trait is in scope","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"there is a method `skip_field` with a similar name, but with different arguments","rendered":null,"spans":[{"byte_end":61109,"byte_start":61039,"column_end":75,"column_start":5,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":true,"label":null,"line_end":1872,"line_start":1872,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":75,"highlight_start":5,"text":"    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {"}]}]},{"children":[],"code":null,"level":"help","message":"trait `SerializeStruct` which provides `serialize_field` is implemented but not in scope; perhaps you want to import it","rendered":null,"spans":[{"byte_end":29798,"byte_start":29798,"column_end":5,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":null,"line_end":990,"line_start":990,"suggested_replacement":"use crate::ser::SerializeStruct;\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"no method named `serialize_field` found for struct `__private::ser::content::SerializeStruct` in the current scope","spans":[{"byte_end":28175,"byte_start":28146,"column_end":34,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":false,"label":"method `serialize_field` not found for this struct","line_end":927,"line_start":927,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":5,"text":"    pub struct SerializeStruct<E> {"}]},{"byte_end":60795,"byte_start":60780,"column_end":23,"column_start":8,"expansion":null,"file_name":"serde/src/ser/mod.rs","is_primary":false,"label":"the method is available for `__private::ser::content::SerializeStruct<TestError>` here","line_end":1864,"line_start":1864,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":8,"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>"}]},{"byte_end":30163,"byte_start":30148,"column_end":44,"column_start":29,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":true,"label":null,"line_end":1005,"line_start":1005,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":44,"highlight_start":29,"text":"    let result = serializer.serialize_field(\"field_some\", &Some(42));"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0369]: binary operation `==` cannot be applied to type `std::boxed::Box<__private::ser::content::Content>`\n    --> serde/src/private/ser.rs:1011:5\n     |\n1011 |     assert_eq!(some_content, Content::I32(42));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::boxed::Box<__private::ser::content::Content>\n     |     __private::ser::content::Content\n     |\nnote: the foreign item type `std::boxed::Box<__private::ser::content::Content>` doesn't implement `PartialEq<__private::ser::content::Content>`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:238:1\n     |\n238  | / pub struct Box<\n239  | |     T: ?Sized,\n240  | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n241  | | >(Unique<T>, A);\n     | |_^ not implement `PartialEq<__private::ser::content::Content>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"the foreign item type `std::boxed::Box<__private::ser::content::Content>` doesn't implement `PartialEq<__private::ser::content::Content>`","rendered":null,"spans":[{"byte_end":9188,"byte_start":9073,"column_end":2,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs","is_primary":true,"label":"not implement `PartialEq<__private::ser::content::Content>`","line_end":241,"line_start":238,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":1,"highlight_start":1,"text":"pub struct Box<"},{"highlight_end":1,"highlight_start":1,"text":"    T: ?Sized,"},{"highlight_end":1,"highlight_start":1,"text":"    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,"},{"highlight_end":2,"highlight_start":1,"text":">(Unique<T>, A);"}]}]}],"code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","message":"binary operation `==` cannot be applied to type `std::boxed::Box<__private::ser::content::Content>`","spans":[{"byte_end":1239,"byte_start":1230,"column_end":31,"column_start":22,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":30550,"byte_start":30508,"column_end":47,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":false,"label":null,"line_end":1011,"line_start":1011,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":47,"highlight_start":5,"text":"    assert_eq!(some_content, Content::I32(42));"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":"std::boxed::Box<__private::ser::content::Content>","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":22,"text":"                if !(*left_val == *right_val) {"}]},{"byte_end":1253,"byte_start":1243,"column_end":45,"column_start":35,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":30550,"byte_start":30508,"column_end":47,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":false,"label":null,"line_end":1011,"line_start":1011,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":47,"highlight_start":5,"text":"    assert_eq!(some_content, Content::I32(42));"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":"__private::ser::content::Content","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":45,"highlight_start":35,"text":"                if !(*left_val == *right_val) {"}]},{"byte_end":1242,"byte_start":1240,"column_end":34,"column_start":32,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":30550,"byte_start":30508,"column_end":47,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":false,"label":null,"line_end":1011,"line_start":1011,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":47,"highlight_start":5,"text":"    assert_eq!(some_content, Content::I32(42));"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":null,"line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":32,"text":"                if !(*left_val == *right_val) {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `__private::ser::content::Content` doesn't implement `std::fmt::Debug`\n    --> serde/src/private/ser.rs:1011:5\n     |\n1011 |     assert_eq!(some_content, Content::I32(42));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `__private::ser::content::Content` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `__private::ser::content::Content`, which is required by `std::boxed::Box<__private::ser::content::Content>: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `__private::ser::content::Content` or manually `impl std::fmt::Debug for __private::ser::content::Content`\n     = help: the trait `std::fmt::Debug` is implemented for `std::boxed::Box<T, A>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `std::fmt::Debug` is not implemented for `__private::ser::content::Content`, which is required by `std::boxed::Box<__private::ser::content::Content>: std::fmt::Debug`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `__private::ser::content::Content` or manually `impl std::fmt::Debug for __private::ser::content::Content`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"the trait `std::fmt::Debug` is implemented for `std::boxed::Box<T, A>`","rendered":null,"spans":[]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`__private::ser::content::Content` doesn't implement `std::fmt::Debug`","spans":[{"byte_end":1629,"byte_start":1619,"column_end":70,"column_start":60,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":30550,"byte_start":30508,"column_end":47,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":false,"label":null,"line_end":1011,"line_start":1011,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":47,"highlight_start":5,"text":"    assert_eq!(some_content, Content::I32(42));"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`__private::ser::content::Content` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":60,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `__private::ser::content::Content` doesn't implement `std::fmt::Debug`\n    --> serde/src/private/ser.rs:1011:5\n     |\n1011 |     assert_eq!(some_content, Content::I32(42));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `__private::ser::content::Content` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `__private::ser::content::Content`\n     = note: add `#[derive(Debug)]` to `__private::ser::content::Content` or manually `impl std::fmt::Debug for __private::ser::content::Content`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `std::fmt::Debug` is not implemented for `__private::ser::content::Content`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `__private::ser::content::Content` or manually `impl std::fmt::Debug for __private::ser::content::Content`","rendered":null,"spans":[]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`__private::ser::content::Content` doesn't implement `std::fmt::Debug`","spans":[{"byte_end":1642,"byte_start":1631,"column_end":83,"column_start":72,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":30550,"byte_start":30508,"column_end":47,"column_start":5,"expansion":null,"file_name":"serde/src/private/ser.rs","is_primary":false,"label":null,"line_end":1011,"line_start":1011,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":47,"highlight_start":5,"text":"    assert_eq!(some_content, Content::I32(42));"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`__private::ser::content::Content` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":83,"highlight_start":72,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: aborting due to 8 previous errors\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 8 previous errors","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"Some errors have detailed explanations: E0046, E0277, E0369, E0599.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"Some errors have detailed explanations: E0046, E0277, E0369, E0599.","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates/serde/serde#1.0.219","manifest_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"serde","src_path":"/home/abezbm/rust-utgen-test-crates/serde/serde/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"For more information about an error, try `rustc --explain E0046`.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"For more information about an error, try `rustc --explain E0046`.","spans":[]}}
{"reason":"build-finished","success":false}
