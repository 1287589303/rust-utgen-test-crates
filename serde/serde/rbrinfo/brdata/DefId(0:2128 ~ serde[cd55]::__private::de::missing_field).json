{
  "name": "serde::__private::de::missing_field",
  "mod_info": {
    "name": "__private::de",
    "loc": "serde/src/private/mod.rs:2:1:2:12"
  },
  "visible": true,
  "loc": "serde/src/private/de.rs:23:1:59:2",
  "doc": "/// If the missing field is of type `Option<T>` then treat is as `None`,\n/// otherwise it is an error.\n",
  "code": [
    "pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>",
    "where",
    "    V: Deserialize<'de>,",
    "    E: Error,",
    "{",
    "    struct MissingFieldDeserializer<E>(&'static str, PhantomData<E>);",
    "",
    "    impl<'de, E> Deserializer<'de> for MissingFieldDeserializer<E>",
    "    where",
    "        E: Error,",
    "    {",
    "        type Error = E;",
    "",
    "        fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, E>",
    "        where",
    "            V: Visitor<'de>,",
    "        {",
    "            Err(Error::missing_field(self.0))",
    "        }",
    "",
    "        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, E>",
    "        where",
    "            V: Visitor<'de>,",
    "        {",
    "            visitor.visit_none()",
    "        }",
    "",
    "        forward_to_deserialize_any! {",
    "            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string",
    "            bytes byte_buf unit unit_struct newtype_struct seq tuple",
    "            tuple_struct map struct enum identifier ignored_any",
    "        }",
    "    }",
    "",
    "    let deserializer = MissingFieldDeserializer(field, PhantomData);",
    "    Deserialize::deserialize(deserializer)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}