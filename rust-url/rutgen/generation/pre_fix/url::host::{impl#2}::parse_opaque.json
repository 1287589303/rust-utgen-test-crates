{
  "name": "url::host::{impl#2}::parse_opaque",
  "mod_info": {
    "name": "host",
    "loc": "url/src/lib.rs:216:1:216:10"
  },
  "visible": true,
  "loc": "url/src/host.rs:106:5:143:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: input.starts_with('[') at line 107 is true\n",
        "precondition: input.ends_with(']') at line 108 is true\n"
      ],
      "input_infer": "input must be a valid IPv6 address enclosed in brackets, e.g., \"[::1]\", \"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\", and should not contain unrecognized characters or empty spaces.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"[::1]\";",
                "    let _ = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"[::1]\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_ok());",
                "    assert!(matches!(result.unwrap(), Host::Ipv6(_)));"
              ],
              "code": [
                "{",
                "    let input = \"[::1]\";",
                "    let _ = Host::parse_opaque(input);",
                "    let input = \"[::1]\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_ok());",
                "    assert!(matches!(result.unwrap(), Host::Ipv6(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\";",
                "    let _ = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(Host::parse_opaque(\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\"), Ok(Host::Ipv6(Ipv6Addr::new(32_768, 3_509, 34_035, 0, 0, 35_118, 14_984, 29_956)));",
                "    assert!(Host::parse_opaque(\"[::1]\").is_ok());",
                "    assert!(matches!(Host::parse_opaque(\"[::1]\"), Ok(Host::Ipv6(_))));",
                "    assert!(Host::parse_opaque(\"[::]\").is_ok());",
                "    assert!(Host::parse_opaque(\"[2001:db8::1]\").is_ok());",
                "    assert!(Host::parse_opaque(\"[abcd:ef01:2345:6789:abcd:ef01:2345:6789]\").is_ok());",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8::1 2]\"), Err(ParseError::InvalidIpv6Address));",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8:::1]\"), Err(ParseError::InvalidIpv6Address));",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8:::1]\"), Err(ParseError::InvalidIpv6Address));",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8::1:2:3]\"), Err(ParseError::InvalidIpv6Address));"
              ],
              "code": [
                "{",
                "    let input = \"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\";",
                "    let _ = Host::parse_opaque(input);",
                "    assert_eq!(Host::parse_opaque(\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\"), Ok(Host::Ipv6(Ipv6Addr::new(32_768, 3_509, 34_035, 0, 0, 35_118, 14_984, 29_956)));",
                "    assert!(Host::parse_opaque(\"[::1]\").is_ok());",
                "    assert!(matches!(Host::parse_opaque(\"[::1]\"), Ok(Host::Ipv6(_))));",
                "    assert!(Host::parse_opaque(\"[::]\").is_ok());",
                "    assert!(Host::parse_opaque(\"[2001:db8::1]\").is_ok());",
                "    assert!(Host::parse_opaque(\"[abcd:ef01:2345:6789:abcd:ef01:2345:6789]\").is_ok());",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8::1 2]\"), Err(ParseError::InvalidIpv6Address));",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8:::1]\"), Err(ParseError::InvalidIpv6Address));",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8:::1]\"), Err(ParseError::InvalidIpv6Address));",
                "    assert_eq!(Host::parse_opaque(\"[2001:db8::1:2:3]\"), Err(ParseError::InvalidIpv6Address));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"[2001:db8::1]\";",
                "    let _ = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"[2001:db8::1]\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Host::Ipv6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1)));"
              ],
              "code": [
                "{",
                "    let input = \"[2001:db8::1]\";",
                "    let _ = Host::parse_opaque(input);",
                "    let input = \"[2001:db8::1]\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Host::Ipv6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"[2001:0db8:0:0:0:0:0:2]\";",
                "    let _ = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    Assert(Host::parse_opaque(\"[2001:0db8:0:0:0:0:0:2]\") == Ok(Host::Ipv6(Ipv6Addr::new(8193, 3512, 0, 0, 0, 0, 0, 2)));",
                "    Assert(Host::parse_opaque(\"[::1]\") == Ok(Host::Ipv6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)));",
                "    Assert(Host::parse_opaque(\"[::]\") == Ok(Host::Ipv6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)));",
                "    Assert(Host::parse_opaque(\"[2001:db8:85a3:0:0:8a2e:0370:7334]\") == Ok(Host::Ipv6(Ipv6Addr::new(8193, 3512, 34303, 0, 0, 35754, 3, 29556)));",
                "    Assert(Host::parse_opaque(\"[fe80::1ff:fe23:4567:890a]\") == Ok(Host::Ipv6(Ipv6Addr::new(65280, 0, 0, 0, 0, 511, 1, 255)));",
                "    Assert(Host::parse_opaque(\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\") == Ok(Host::Ipv6(Ipv6Addr::new(8193, 3512, 34303, 0, 0, 35754, 3, 29556)));"
              ],
              "code": [
                "{",
                "    let input = \"[2001:0db8:0:0:0:0:0:2]\";",
                "    let _ = Host::parse_opaque(input);",
                "    Assert(Host::parse_opaque(\"[2001:0db8:0:0:0:0:0:2]\") == Ok(Host::Ipv6(Ipv6Addr::new(8193, 3512, 0, 0, 0, 0, 0, 2)));",
                "    Assert(Host::parse_opaque(\"[::1]\") == Ok(Host::Ipv6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)));",
                "    Assert(Host::parse_opaque(\"[::]\") == Ok(Host::Ipv6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)));",
                "    Assert(Host::parse_opaque(\"[2001:db8:85a3:0:0:8a2e:0370:7334]\") == Ok(Host::Ipv6(Ipv6Addr::new(8193, 3512, 34303, 0, 0, 35754, 3, 29556)));",
                "    Assert(Host::parse_opaque(\"[fe80::1ff:fe23:4567:890a]\") == Ok(Host::Ipv6(Ipv6Addr::new(65280, 0, 0, 0, 0, 511, 1, 255)));",
                "    Assert(Host::parse_opaque(\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\") == Ok(Host::Ipv6(Ipv6Addr::new(8193, 3512, 34303, 0, 0, 35754, 3, 29556)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: input.starts_with('[') at line 107 is true\n",
        "precondition: input.ends_with(']') at line 108 is false\n",
        "expected return value/type: Err(ParseError::InvalidIpv6Address)\n"
      ],
      "input_infer": "input = \"[\" or input = \"[valid_ipv6_address\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"[\";",
                "    let _ = Host::<String>::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"[\";",
                "    let result = Host::<String>::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidIpv6Address));"
              ],
              "code": [
                "{",
                "    let input = \"[\";",
                "    let _ = Host::<String>::parse_opaque(input);",
                "    let input = \"[\";",
                "    let result = Host::<String>::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidIpv6Address));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"[valid_ipv6_address\";",
                "    let _ = Host::<String>::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"[valid_ipv6_address\";",
                "    let result = Host::<String>::parse_opaque(input);",
                "    assert_eq!(result, Err(ParseError::InvalidIpv6Address));"
              ],
              "code": [
                "{",
                "    let input = \"[valid_ipv6_address\";",
                "    let _ = Host::<String>::parse_opaque(input);",
                "    let input = \"[valid_ipv6_address\";",
                "    let result = Host::<String>::parse_opaque(input);",
                "    assert_eq!(result, Err(ParseError::InvalidIpv6Address));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: input.starts_with('[') at line 107 is false\n",
        "precondition: input.find(is_invalid_host_char).is_some() at line 136 is true\n",
        "expected return value/type: Err(ParseError::InvalidDomainCharacter)\n"
      ],
      "input_infer": "input should contain any invalid character from the defined set, such as '\\0', '\\t', '\\n', '\\r', ' ', '#', '/', ':', '<', '>', '?', '@', '[', '\\\\', ']', '^', or '|' and must not start with '['.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid\\nhost\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid\\nhost\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    assert_eq!(Host::parse_opaque(input), expected);"
              ],
              "code": [
                "{",
                "    let input = \"invalid\\nhost\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid\\nhost\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    assert_eq!(Host::parse_opaque(input), expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid\\thost\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid\\thost\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    let result = Host::parse_opaque(input);",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let input = \"invalid\\thost\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid\\thost\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    let result = Host::parse_opaque(input);",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidDomainCharacter));"
              ],
              "code": [
                "{",
                "    let input = \"invalid host\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidDomainCharacter));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid#host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid#host\";",
                "    let _result = Host::parse_opaque(input);",
                "    assert_eq!(_result, Err(ParseError::InvalidDomainCharacter));"
              ],
              "code": [
                "{",
                "    let input = \"invalid#host\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid#host\";",
                "    let _result = Host::parse_opaque(input);",
                "    assert_eq!(_result, Err(ParseError::InvalidDomainCharacter));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid/host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid/host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidDomainCharacter));"
              ],
              "code": [
                "{",
                "    let input = \"invalid/host\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid/host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidDomainCharacter));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid:host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    assert!(_result.is_err());",
                "    assert_eq!(_result.unwrap_err(), ParseError::InvalidDomainCharacter);"
              ],
              "code": [
                "{",
                "    let input = \"invalid:host\";",
                "    let _result = Host::parse_opaque(input);",
                "    assert!(_result.is_err());",
                "    assert_eq!(_result.unwrap_err(), ParseError::InvalidDomainCharacter);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid<host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid<host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidDomainCharacter));"
              ],
              "code": [
                "{",
                "    let input = \"invalid<host\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid<host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err(), Some(ParseError::InvalidDomainCharacter));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid>host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Err(ParseError::InvalidDomainCharacter));"
              ],
              "code": [
                "{",
                "    let input = \"invalid>host\";",
                "    let _result = Host::parse_opaque(input);",
                "    assert_eq!(_result, Err(ParseError::InvalidDomainCharacter));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid?host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid?host\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    let result = Host::parse_opaque(input);",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let input = \"invalid?host\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid?host\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    let result = Host::parse_opaque(input);",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid@host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    Host::parse_opaque(\"invalid@host\").is_err();",
                "    assert_eq!(Host::parse_opaque(\"invalid@host\"), Err(ParseError::InvalidDomainCharacter));"
              ],
              "code": [
                "{",
                "    let input = \"invalid@host\";",
                "    let _result = Host::parse_opaque(input);",
                "    Host::parse_opaque(\"invalid@host\").is_err();",
                "    assert_eq!(Host::parse_opaque(\"invalid@host\"), Err(ParseError::InvalidDomainCharacter));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid\\\\host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid\\\\host\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    assert_eq!(Host::parse_opaque(input), expected);"
              ],
              "code": [
                "{",
                "    let input = \"invalid\\\\host\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid\\\\host\";",
                "    let expected = Err(ParseError::InvalidDomainCharacter);",
                "    assert_eq!(Host::parse_opaque(input), expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid^host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    assert!(_result.is_err());",
                "    assert_eq!(_result.unwrap_err(), ParseError::InvalidDomainCharacter);"
              ],
              "code": [
                "{",
                "    let input = \"invalid^host\";",
                "    let _result = Host::parse_opaque(input);",
                "    assert!(_result.is_err());",
                "    assert_eq!(_result.unwrap_err(), ParseError::InvalidDomainCharacter);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"invalid|host\";",
                "    let _result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"invalid|host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert_eq!(result, Err(ParseError::InvalidDomainCharacter));"
              ],
              "code": [
                "{",
                "    let input = \"invalid|host\";",
                "    let _result = Host::parse_opaque(input);",
                "    let input = \"invalid|host\";",
                "    let result = Host::parse_opaque(input);",
                "    assert_eq!(result, Err(ParseError::InvalidDomainCharacter));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "precondition: input.starts_with('[') at line 107 is false\n",
        "precondition: input.find(is_invalid_host_char).is_some() at line 136 is false\n",
        "expected return value/type: Ok(Host::Domain(\n                utf8_percent_encode(input, CONTROLS).to_string(),\n            ))\n"
      ],
      "input_infer": "1. Non-empty string input consisting only of valid host characters without any control characters, special characters listed in the is_invalid_host_char function, and not starting with '[' (e.g., \"example.com\", \"sub.domain.org\", \"my-host123\").\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"example.com\";",
                "    let result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Host::Domain(utf8_percent_encode(\"example.com\", CONTROLS).to_string()));"
              ],
              "code": [
                "{",
                "    let input = \"example.com\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Host::Domain(utf8_percent_encode(\"example.com\", CONTROLS).to_string()));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"sub.domain.org\";",
                "    let result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Ok(Host::Domain(utf8_percent_encode(\"sub.domain.org\", CONTROLS).to_string())));"
              ],
              "code": [
                "{",
                "    let input = \"sub.domain.org\";",
                "    let result = Host::parse_opaque(input);",
                "    assert_eq!(result, Ok(Host::Domain(utf8_percent_encode(\"sub.domain.org\", CONTROLS).to_string())));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"my-host123\";",
                "    let result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"my-host123\";",
                "    let expected = Ok(Host::Domain(utf8_percent_encode(input, CONTROLS).to_string()));",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let input = \"my-host123\";",
                "    let result = Host::parse_opaque(input);",
                "    let input = \"my-host123\";",
                "    let expected = Ok(Host::Domain(utf8_percent_encode(input, CONTROLS).to_string()));",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"my host.com\";",
                "    let result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    let input = \"my host.com\";",
                "    let expected = Ok(Host::Domain(utf8_percent_encode(input, CONTROLS).to_string()));",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let input = \"my host.com\";",
                "    let result = Host::parse_opaque(input);",
                "    let input = \"my host.com\";",
                "    let expected = Ok(Host::Domain(utf8_percent_encode(input, CONTROLS).to_string()));",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = \"my_host.com\";",
                "    let result = Host::parse_opaque(input);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Host::Domain(\"my_host.com\".to_string()));"
              ],
              "code": [
                "{",
                "    let input = \"my_host.com\";",
                "    let result = Host::parse_opaque(input);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), Host::Domain(\"my_host.com\".to_string()));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}