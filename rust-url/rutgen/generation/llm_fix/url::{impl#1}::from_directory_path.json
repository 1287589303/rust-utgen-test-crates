{
  "name": "url::{impl#1}::from_directory_path",
  "mod_info": {
    "name": "",
    "loc": "url/src/lib.rs:9:1:3218:2"
  },
  "visible": true,
  "loc": "url/src/lib.rs:2588:5:2594:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: Url::from_file_path(path)? at line 2589 is Err/None\n"
      ],
      "input_infer": "path must be an absolute directory path on Unix (e.g., \"/var/www\") or a valid Windows disk prefix path (e.g., \"C:\\\\path\\\\to\\\\directory\") or UNC path (e.g., \"\\\\\\\\server\\\\share\") that must be complete and valid, avoiding empty or non-existing paths, ensuring to test special cases like trailing slashes, broken paths, and invalid characters.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Url::from_directory_path(\"/non/existing/directory\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    let result = Url::from_directory_path(\"/non/existing/directory\");",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Url::from_directory_path(\"Z:\\\\non\\\\existing\\\\directory\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());"
              ],
              "code": [
                "{",
                "    let result = Url::from_directory_path(\"Z:\\\\non\\\\existing\\\\directory\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Url::from_directory_path(\"\\\\\\\\server\\\\non\\\\existing\\\\share\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert!(Url::from_directory_path(\"C:non_existing_path\").is_err());",
                "    assert!(Url::from_directory_path(\"/non_absolute_path\").is_err());",
                "    assert!(Url::from_directory_path(\"\").is_err());",
                "    assert!(Url::from_directory_path(\"index.html\").is_err());"
              ],
              "code": [
                "{",
                "    let result = Url::from_directory_path(\"\\\\\\\\server\\\\non\\\\existing\\\\share\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert!(Url::from_directory_path(\"C:non_existing_path\").is_err());",
                "    assert!(Url::from_directory_path(\"/non_absolute_path\").is_err());",
                "    assert!(Url::from_directory_path(\"\").is_err());",
                "    assert!(Url::from_directory_path(\"index.html\").is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Url::from_directory_path(\"\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert!(Url::from_directory_path(Path::new(\"index.html\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"/non/absolute/path\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"\\\\non/absolute/path\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"C:index.html\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"C:\\\\\")).is_ok());",
                "    assert!(Url::from_directory_path(Path::new(\"C:/\")).is_ok());",
                "    assert!(Url::from_directory_path(Path::new(r\"\\\\servername\\share\")).is_ok());",
                "    assert!(Url::from_directory_path(Path::new(r\"\\\\\")), \"Should succeed for UNC path without trailing slash\");",
                "    assert!(Url::from_directory_path(Path::new(\"/var/www\")).is_ok());",
                "    assert_eq!(Url::from_directory_path(\"/var/www\").unwrap().as_str(), \"file:///var/www/\");"
              ],
              "code": [
                "{",
                "    let result = Url::from_directory_path(\"\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "    assert!(Url::from_directory_path(Path::new(\"index.html\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"/non/absolute/path\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"\\\\non/absolute/path\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"C:index.html\")).is_err());",
                "    assert!(Url::from_directory_path(Path::new(\"C:\\\\\")).is_ok());",
                "    assert!(Url::from_directory_path(Path::new(\"C:/\")).is_ok());",
                "    assert!(Url::from_directory_path(Path::new(r\"\\\\servername\\share\")).is_ok());",
                "    assert!(Url::from_directory_path(Path::new(r\"\\\\\")), \"Should succeed for UNC path without trailing slash\");",
                "    assert!(Url::from_directory_path(Path::new(\"/var/www\")).is_ok());",
                "    assert_eq!(Url::from_directory_path(\"/var/www\").unwrap().as_str(), \"file:///var/www/\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Url::from_directory_path(\"/var/www/invalid:path\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());"
              ],
              "code": [
                "{",
                "    let result = Url::from_directory_path(\"/var/www/invalid:path\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), ());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Url::from_directory_path(\"/var/www\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(()));",
                "    assert!(matches!(result, Err(_)));",
                "    assert!(result.is_ok() == false);",
                "    assert!(result.is_err() == true);",
                "    assert!(result.unwrap_or_else(|_| Url::default()).path().is_empty());"
              ],
              "code": [
                "{",
                "    let result = Url::from_directory_path(\"/var/www\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(()));",
                "    assert!(matches!(result, Err(_)));",
                "    assert!(result.is_ok() == false);",
                "    assert!(result.is_err() == true);",
                "    assert!(result.unwrap_or_else(|_| Url::default()).path().is_empty());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: Url::from_file_path(path)? at line 2589 is Ok/Some\n",
        "precondition: url.serialization.ends_with('/') at line 2590 is true\n",
        "expected return value/type: Ok(url)\n"
      ],
      "input_infer": "absolute file paths, valid disk prefixes like \"C:\", UNC prefixes like \"\\\\\", all followed by paths that do not end with a trailing slash\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"C:/Users/User/Documents\"); ",
                "    let result = Url::from_directory_path(&path);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert_eq!(url.serialization, \"file:///C:/Users/User/Documents/\");",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert!(url.path().ends_with('/'));",
                "    assert!(url.has_authority());",
                "    assert_eq!(url.scheme(), \"file\");"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"C:/Users/User/Documents\"); ",
                "    let result = Url::from_directory_path(&path);",
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert_eq!(url.serialization, \"file:///C:/Users/User/Documents/\");",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert!(url.path().ends_with('/'));",
                "    assert!(url.has_authority());",
                "    assert_eq!(url.scheme(), \"file\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"\\\\\\\\Server\\\\Share\\\\Folder\");",
                "    let result = Url::from_directory_path(&path);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert_eq!(url.scheme(), \"file\");",
                "    assert_eq!(url.host_str(), None);",
                "    assert_eq!(url.path(), \"/Server/Share/Folder/\");"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"\\\\\\\\Server\\\\Share\\\\Folder\");",
                "    let result = Url::from_directory_path(&path);",
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert_eq!(url.scheme(), \"file\");",
                "    assert_eq!(url.host_str(), None);",
                "    assert_eq!(url.path(), \"/Server/Share/Folder/\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"D:/Projects/Rust\");",
                "    let result = Url::from_directory_path(&path);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap().serialization, \"file:///D:/Projects/Rust/\");",
                "    assert!(result.unwrap().serialization.ends_with('/'));",
                "    assert!(result.unwrap().serialization.starts_with(\"file:///\"));",
                "    assert_eq!(result.unwrap().host(), Some(Host::Domain));",
                "    assert_eq!(result.unwrap().port(), None);"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"D:/Projects/Rust\");",
                "    let result = Url::from_directory_path(&path);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap().serialization, \"file:///D:/Projects/Rust/\");",
                "    assert!(result.unwrap().serialization.ends_with('/'));",
                "    assert!(result.unwrap().serialization.starts_with(\"file:///\"));",
                "    assert_eq!(result.unwrap().host(), Some(Host::Domain));",
                "    assert_eq!(result.unwrap().port(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"/home/user/projects\");",
                "    let result = Url::from_directory_path(&path);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert_eq!(url.serialization, \"file:///home/user/projects/\");"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"/home/user/projects\");",
                "    let result = Url::from_directory_path(&path);",
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert_eq!(url.serialization, \"file:///home/user/projects/\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"/Users/User/Documents\");",
                "    let result = Url::from_directory_path(&path);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert_eq!(url.serialization, \"file:///Users/User/Documents/\");",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert!(url.path().is_empty());",
                "    assert!(url.has_authority());",
                "    assert_eq!(url.scheme(), \"file\");",
                "    assert_eq!(url.host_str(), None);",
                "    assert_eq!(url.port(), None);"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"/Users/User/Documents\");",
                "    let result = Url::from_directory_path(&path);",
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert_eq!(url.serialization, \"file:///Users/User/Documents/\");",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert!(url.path().is_empty());",
                "    assert!(url.has_authority());",
                "    assert_eq!(url.scheme(), \"file\");",
                "    assert_eq!(url.host_str(), None);",
                "    assert_eq!(url.port(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: Url::from_file_path(path)? at line 2589 is Ok/Some\n",
        "precondition: url.serialization.ends_with('/') at line 2590 is false\n",
        "expected return value/type: Ok(url)\n"
      ],
      "input_infer": "Valid absolute directory paths on Unix and Windows that do not end with a trailing slash and are not UNC paths, e.g., \"/var/www\" or \"C:\\\\Users\\\\Username\\\\Documents\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"/var/www\");",
                "    let result = Url::from_directory_path(&path);",
                "    let _ = result.unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(Url::from_directory_path(std::path::Path::new(\"/var/www\")), Ok(_)));",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"/var/www\")).unwrap().serialization.ends_with('/'));",
                "    assert_eq!(Url::from_directory_path(std::path::Path::new(\"/var/www\")).unwrap().serialization, \"file:///var/www/\");",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"C:/Users\")).is_ok());",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"\\\\\\\\Server\\\\Share\")).is_ok());",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"relative/path\")).is_err());"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"/var/www\");",
                "    let result = Url::from_directory_path(&path);",
                "    let _ = result.unwrap();",
                "    assert!(matches!(Url::from_directory_path(std::path::Path::new(\"/var/www\")), Ok(_)));",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"/var/www\")).unwrap().serialization.ends_with('/'));",
                "    assert_eq!(Url::from_directory_path(std::path::Path::new(\"/var/www\")).unwrap().serialization, \"file:///var/www/\");",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"C:/Users\")).is_ok());",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"\\\\\\\\Server\\\\Share\")).is_ok());",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"relative/path\")).is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"C:\\\\Users\\\\Username\\\\Documents\");",
                "    let result = Url::from_directory_path(&path);",
                "    let _ = result.unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(Url::from_directory_path(std::path::Path::new(\"C:\\\\Users\\\\Username\\\\Documents\")).is_ok());",
                "    let url = Url::from_directory_path(std::path::Path::new(\"C:\\\\Users\\\\Username\\\\Documents\")).unwrap();",
                "    assert!(!url.serialization.ends_with('/'));",
                "    assert_eq!(url.serialization, \"file:///C:/Users/Username/Documents/\");"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"C:\\\\Users\\\\Username\\\\Documents\");",
                "    let result = Url::from_directory_path(&path);",
                "    let _ = result.unwrap();",
                "    assert!(Url::from_directory_path(std::path::Path::new(\"C:\\\\Users\\\\Username\\\\Documents\")).is_ok());",
                "    let url = Url::from_directory_path(std::path::Path::new(\"C:\\\\Users\\\\Username\\\\Documents\")).unwrap();",
                "    assert!(!url.serialization.ends_with('/'));",
                "    assert_eq!(url.serialization, \"file:///C:/Users/Username/Documents/\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let path = std::path::Path::new(\"\\\\\\\\Server\\\\Share\\\\Folder\");",
                "    let result = Url::from_directory_path(&path);",
                "    let _ = result.unwrap();",
                "}"
              ],
              "oracle": [
                "    let path = std::path::Path::new(\"\\\\\\\\Server\\\\Share\\\\Folder\");",
                "    let result = Url::from_directory_path(&path);",
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert_eq!(url.scheme(), \"file\");",
                "    assert!(url.has_authority());",
                "    assert_eq!(url.host_str(), Some(\"\\\\\\\\Server\\\\Share\"));",
                "    assert_eq!(url.path(), \"/Folder/\");"
              ],
              "code": [
                "{",
                "    let path = std::path::Path::new(\"\\\\\\\\Server\\\\Share\\\\Folder\");",
                "    let result = Url::from_directory_path(&path);",
                "    let _ = result.unwrap();",
                "    let path = std::path::Path::new(\"\\\\\\\\Server\\\\Share\\\\Folder\");",
                "    let result = Url::from_directory_path(&path);",
                "    assert!(result.is_ok());",
                "    let url = result.unwrap();",
                "    assert!(url.serialization.ends_with('/'));",
                "    assert_eq!(url.scheme(), \"file\");",
                "    assert!(url.has_authority());",
                "    assert_eq!(url.host_str(), Some(\"\\\\\\\\Server\\\\Share\"));",
                "    assert_eq!(url.path(), \"/Folder/\");",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}