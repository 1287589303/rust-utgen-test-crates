{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/lib.rs\n// crate name is url\npub use form_urlencoded;\nuse crate::host::HostInternal;\nuse crate::net::IpAddr;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse crate::net::{SocketAddr, ToSocketAddrs};\nuse crate::parser::{to_u32, Context, Parser, SchemeType, USERINFO};\nuse alloc::borrow::ToOwned;\nuse alloc::str;\nuse alloc::string::{String, ToString};\nuse core::borrow::Borrow;\nuse core::convert::TryFrom;\nuse core::fmt::Write;\nuse core::ops::{Range, RangeFrom, RangeTo};\nuse core::{cmp, fmt, hash, mem};\nuse percent_encoding::utf8_percent_encode;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse std::io;\n#[cfg(feature = \"std\")]\nuse std::path::{Path, PathBuf};\npub use crate::host::Host;\npub use crate::origin::{OpaqueOrigin, Origin};\npub use crate::parser::{ParseError, SyntaxViolation};\npub use crate::path_segments::PathSegmentsMut;\npub use crate::slicing::Position;\npub use form_urlencoded::EncodingOverride;\n#[derive(Clone)]\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n    scheme_end: u32,\n    username_end: u32,\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,\n    query_start: Option<u32>,\n    fragment_start: Option<u32>,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub(crate) enum HostInternal {\n    None,\n    Domain,\n    Ipv4(Ipv4Addr),\n    Ipv6(Ipv6Addr),\n}\nimpl Url {\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {}\n    #[inline]\n    pub fn parse_with_params<I, K, V>(\n        input: &str,\n        iter: I,\n    ) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {}\n    fn strip_trailing_spaces_from_opaque_path(&mut self) {}\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {}\n    pub fn make_relative(&self, url: &Url) -> Option<String> {}\n    pub fn options<'a>() -> ParseOptions<'a> {}\n    #[inline]\n    pub fn as_str(&self) -> &str {}\n    #[inline]\n    #[deprecated(since = \"2.3.0\", note = \"use Into<String>\")]\n    pub fn into_string(self) -> String {}\n    pub fn check_invariants(&self) -> Result<(), String> {}\n    #[inline]\n    pub fn origin(&self) -> Origin {}\n    #[inline]\n    pub fn scheme(&self) -> &str {}\n    pub fn is_special(&self) -> bool {}\n    #[inline]\n    pub fn has_authority(&self) -> bool {}\n    pub fn authority(&self) -> &str {}\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {}\n    pub fn username(&self) -> &str {}\n    pub fn password(&self) -> Option<&str> {}\n    pub fn has_host(&self) -> bool {}\n    pub fn host_str(&self) -> Option<&str> {}\n    pub fn host(&self) -> Option<Host<&str>> {}\n    pub fn domain(&self) -> Option<&str> {}\n    #[inline]\n    pub fn port(&self) -> Option<u16> {}\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {\n        self.port.or_else(|| parser::default_port(self.scheme()))\n    }\n    #[cfg(feature = \"std\")]\n    #[cfg(\n        any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\")\n    )]\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<alloc::vec::Vec<SocketAddr>> {}\n    pub fn path(&self) -> &str {}\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {}\n    pub fn query(&self) -> Option<&str> {}\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {}\n    pub fn fragment(&self) -> Option<&str> {}\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {}\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {}\n    fn take_fragment(&mut self) -> Option<String> {}\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {}\n    pub fn set_query(&mut self, query: Option<&str>) {}\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {}\n    fn take_after_path(&mut self) -> String {}\n    pub fn set_path(&mut self, mut path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {}\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {}\n    fn set_port_internal(&mut self, port: Option<u16>) {}\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {}\n    fn set_host_internal(\n        &mut self,\n        host: Host<String>,\n        opt_new_port: Option<Option<u16>>,\n    ) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err, clippy::suspicious_operation_groupings)]\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(Error::custom)?\n        }\n        Ok(url)\n    }\n    #[inline]\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {}\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {}\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Return the port number for this URL, or the default port number if it is known.\n///\n/// This method only knows the default port number\n/// of the `http`, `https`, `ws`, `wss` and `ftp` schemes.\n///\n/// For URLs in these schemes, this method always returns `Some(_)`.\n/// For other schemes, it is the same as `Url::port()`.\n///\n/// # Examples\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let url = Url::parse(\"foo://example.com\")?;\n/// assert_eq!(url.port_or_known_default(), None);\n///\n/// let url = Url::parse(\"foo://example.com:1456\")?;\n/// assert_eq!(url.port_or_known_default(), Some(1456));\n///\n/// let url = Url::parse(\"https://example.com\")?;\n/// assert_eq!(url.port_or_known_default(), Some(443));\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n1288 pub fn port_or_known_default(&self) -> Option<u16> {\n1289     self.port.or_else(|| parser::default_port(self.scheme()))\n1290 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}