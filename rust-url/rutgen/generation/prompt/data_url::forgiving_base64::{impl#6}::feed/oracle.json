{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// data-url/src/forgiving_base64.rs\n// crate name is data_url\nuse alloc::vec::Vec;\nuse core::fmt;\n#[rustfmt::skip]\nconst BASE64_DECODE_TABLE: [i8; 256] = [\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    62,\n    -1,\n    -1,\n    -1,\n    63,\n    52,\n    53,\n    54,\n    55,\n    56,\n    57,\n    58,\n    59,\n    60,\n    61,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    16,\n    17,\n    18,\n    19,\n    20,\n    21,\n    22,\n    23,\n    24,\n    25,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    26,\n    27,\n    28,\n    29,\n    30,\n    31,\n    32,\n    33,\n    34,\n    35,\n    36,\n    37,\n    38,\n    39,\n    40,\n    41,\n    42,\n    43,\n    44,\n    45,\n    46,\n    47,\n    48,\n    49,\n    50,\n    51,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n];\npub struct Decoder<F, E>\nwhere\n    F: FnMut(&[u8]) -> Result<(), E>,\n{\n    write_bytes: F,\n    bit_buffer: u32,\n    buffer_bit_length: u8,\n    padding_symbols: u8,\n}\n#[derive(Debug)]\nenum InvalidBase64Details {\n    UnexpectedSymbol(u8),\n    AlphabetSymbolAfterPadding,\n    LoneAlphabetSymbol,\n    Padding,\n}\n#[derive(Debug)]\npub enum DecodeError<E> {\n    InvalidBase64(InvalidBase64),\n    WriteError(E),\n}\nimpl<F, E> Decoder<F, E>\nwhere\n    F: FnMut(&[u8]) -> Result<(), E>,\n{\n    pub fn new(write_bytes: F) -> Self {\n        Self {\n            write_bytes,\n            bit_buffer: 0,\n            buffer_bit_length: 0,\n            padding_symbols: 0,\n        }\n    }\n    pub fn feed(&mut self, input: &[u8]) -> Result<(), DecodeError<E>> {\n        for &byte in input.iter() {\n            let value = BASE64_DECODE_TABLE[byte as usize];\n            if value < 0 {\n                if matches!(byte, b' ' | b'\\t' | b'\\n' | b'\\r' | b'\\x0C') {\n                    continue;\n                }\n                if byte == b'=' {\n                    self.padding_symbols = self.padding_symbols.saturating_add(1);\n                    continue;\n                }\n                return Err(InvalidBase64Details::UnexpectedSymbol(byte).into());\n            }\n            if self.padding_symbols > 0 {\n                return Err(InvalidBase64Details::AlphabetSymbolAfterPadding.into());\n            }\n            self.bit_buffer <<= 6;\n            self.bit_buffer |= value as u32;\n            if self.buffer_bit_length < 18 {\n                self.buffer_bit_length += 6;\n            } else {\n                let byte_buffer = [\n                    (self.bit_buffer >> 16) as u8,\n                    (self.bit_buffer >> 8) as u8,\n                    self.bit_buffer as u8,\n                ];\n                (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n                self.buffer_bit_length = 0;\n            }\n        }\n        Ok(())\n    }\n    pub fn finish(mut self) -> Result<(), DecodeError<E>> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Feed to the decoder partial input in an ASCII-compatible encoding\n109 pub fn feed(&mut self, input: &[u8]) -> Result<(), DecodeError<E>> {\n110     for &byte in input.iter() {\n111         let value = BASE64_DECODE_TABLE[byte as usize];\n112         if value < 0 {\n113             // A character that’s not part of the alphabet\n114 \n115             // Remove ASCII whitespace\n116             if matches!(byte, b' ' | b'\\t' | b'\\n' | b'\\r' | b'\\x0C') {\n117                 continue;\n118             }\n119 \n120             if byte == b'=' {\n121                 self.padding_symbols = self.padding_symbols.saturating_add(1);\n122                 continue;\n123             }\n124 \n125             return Err(InvalidBase64Details::UnexpectedSymbol(byte).into());\n126         }\n127         if self.padding_symbols > 0 {\n128             return Err(InvalidBase64Details::AlphabetSymbolAfterPadding.into());\n129         }\n130         self.bit_buffer <<= 6;\n131         self.bit_buffer |= value as u32;\n132         // 18 before incrementing means we’ve just reached 24\n133         if self.buffer_bit_length < 18 {\n134             self.buffer_bit_length += 6;\n135         } else {\n136             // We’ve accumulated four times 6 bits, which equals three times 8 bits.\n137             let byte_buffer = [\n138                 (self.bit_buffer >> 16) as u8,\n139                 (self.bit_buffer >> 8) as u8,\n140                 self.bit_buffer as u8,\n141             ];\n142             (self.write_bytes)(&byte_buffer).map_err(DecodeError::WriteError)?;\n143             self.buffer_bit_length = 0;\n144             // No need to reset bit_buffer,\n145             // since next time we’re only gonna read relevant bits.\n146         }\n147     }\n148     Ok(())\n149 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}