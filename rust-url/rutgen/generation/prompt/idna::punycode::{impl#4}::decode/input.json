{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// idna/src/punycode.rs\n// crate name is idna\nuse alloc::{string::String, vec::Vec};\nuse core::char;\nuse core::fmt::Write;\nuse core::marker::PhantomData;\nconst BASE: u32 = 36;\nconst T_MIN: u32 = 1;\nconst T_MAX: u32 = 26;\nconst SKEW: u32 = 38;\nconst DAMP: u32 = 700;\nconst INITIAL_BIAS: u32 = 72;\nconst INITIAL_N: u32 = 0x80;\npub(crate) trait PunycodeCodeUnit {\n    fn is_delimiter(&self) -> bool;\n    fn is_ascii(&self) -> bool;\n    fn digit(&self) -> Option<u32>;\n    fn char(&self) -> char;\n    fn char_ascii_lower_case(&self) -> char;\n}\n#[derive(Default)]\npub(crate) struct Decoder {\n    insertions: smallvec::SmallVec<[(usize, char); 59]>,\n}\npub(crate) struct Decode<'a, T, C>\nwhere\n    T: PunycodeCodeUnit + Copy,\n    C: PunycodeCaller,\n{\n    base: core::slice::Iter<'a, T>,\n    pub(crate) insertions: &'a [(usize, char)],\n    inserted: usize,\n    position: usize,\n    len: usize,\n    phantom: PhantomData<C>,\n}\nimpl Decoder {\n    pub(crate) fn decode<'a, T: PunycodeCodeUnit + Copy, C: PunycodeCaller>(\n        &'a mut self,\n        input: &'a [T],\n    ) -> Result<Decode<'a, T, C>, ()> {\n        self.insertions.clear();\n        let (base, input) = if let Some(position) = input\n            .iter()\n            .rposition(|c| c.is_delimiter())\n        {\n            (\n                &input[..position],\n                if position > 0 { &input[position + 1..] } else { input },\n            )\n        } else {\n            (&input[..0], input)\n        };\n        if C::EXTERNAL_CALLER && !base.iter().all(|c| c.is_ascii()) {\n            return Err(());\n        }\n        let base_len = base.len();\n        let mut length = base_len as u32;\n        let mut code_point = INITIAL_N;\n        let mut bias = INITIAL_BIAS;\n        let mut i = 0u32;\n        let mut iter = input.iter();\n        loop {\n            let previous_i = i;\n            let mut weight = 1;\n            let mut k = BASE;\n            let mut byte = match iter.next() {\n                None => break,\n                Some(byte) => byte,\n            };\n            loop {\n                let digit = if let Some(digit) = byte.digit() {\n                    digit\n                } else {\n                    return Err(());\n                };\n                let product = digit.checked_mul(weight).ok_or(())?;\n                i = i.checked_add(product).ok_or(())?;\n                let t = if k <= bias {\n                    T_MIN\n                } else if k >= bias + T_MAX {\n                    T_MAX\n                } else {\n                    k - bias\n                };\n                if digit < t {\n                    break;\n                }\n                weight = weight.checked_mul(BASE - t).ok_or(())?;\n                k += BASE;\n                byte = match iter.next() {\n                    None => return Err(()),\n                    Some(byte) => byte,\n                };\n            }\n            bias = adapt(i - previous_i, length + 1, previous_i == 0);\n            code_point = code_point.checked_add(i / (length + 1)).ok_or(())?;\n            i %= length + 1;\n            let c = match char::from_u32(code_point) {\n                Some(c) => c,\n                None => return Err(()),\n            };\n            for (idx, _) in &mut self.insertions {\n                if *idx >= i as usize {\n                    *idx += 1;\n                }\n            }\n            self.insertions.push((i as usize, c));\n            length += 1;\n            i += 1;\n        }\n        self.insertions.sort_by_key(|(i, _)| *i);\n        Ok(Decode {\n            base: base.iter(),\n            insertions: &self.insertions,\n            inserted: 0,\n            position: 0,\n            len: base_len + self.insertions.len(),\n            phantom: PhantomData::<C>,\n        })\n    }\n}\n#[inline]\nfn adapt(mut delta: u32, num_points: u32, first_time: bool) -> u32 {\n    delta /= if first_time { DAMP } else { 2 };\n    delta += delta / num_points;\n    let mut k = 0;\n    while delta > ((BASE - T_MIN) * T_MAX) / 2 {\n        delta /= BASE - T_MIN;\n        k += BASE;\n    }\n    k + (((BASE - T_MIN + 1) * delta) / (delta + SKEW))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Split the input iterator and return a Vec with insertions of encoded characters\n166 pub(crate) fn decode<'a, T: PunycodeCodeUnit + Copy, C: PunycodeCaller>(\n167     &'a mut self,\n168     input: &'a [T],\n169 ) -> Result<Decode<'a, T, C>, ()> {\n170     self.insertions.clear();\n171     // Handle \"basic\" (ASCII) code points.\n172     // They are encoded as-is before the last delimiter, if any.\n173     let (base, input) = if let Some(position) = input.iter().rposition(|c| c.is_delimiter()) {\n174         (\n175             &input[..position],\n176             if position > 0 {\n177                 &input[position + 1..]\n178             } else {\n179                 input\n180             },\n181         )\n182     } else {\n183         (&input[..0], input)\n184     };\n185 \n186     if C::EXTERNAL_CALLER && !base.iter().all(|c| c.is_ascii()) {\n187         return Err(());\n188     }\n189 \n190     let base_len = base.len();\n191     let mut length = base_len as u32;\n192     let mut code_point = INITIAL_N;\n193     let mut bias = INITIAL_BIAS;\n194     let mut i = 0u32;\n195     let mut iter = input.iter();\n196     loop {\n197         let previous_i = i;\n198         let mut weight = 1;\n199         let mut k = BASE;\n200         let mut byte = match iter.next() {\n201             None => break,\n202             Some(byte) => byte,\n203         };\n204 \n205         // Decode a generalized variable-length integer into delta,\n206         // which gets added to i.\n207         loop {\n208             let digit = if let Some(digit) = byte.digit() {\n209                 digit\n210             } else {\n211                 return Err(());\n212             };\n213             let product = digit.checked_mul(weight).ok_or(())?;\n214             i = i.checked_add(product).ok_or(())?;\n215             let t = if k <= bias {\n216                 T_MIN\n217             } else if k >= bias + T_MAX {\n218                 T_MAX\n219             } else {\n220                 k - bias\n221             };\n222             if digit < t {\n223                 break;\n224             }\n225             weight = weight.checked_mul(BASE - t).ok_or(())?;\n226             k += BASE;\n227             byte = match iter.next() {\n228                 None => return Err(()), // End of input before the end of this delta\n229                 Some(byte) => byte,\n230             };\n231         }\n232 \n233         bias = adapt(i - previous_i, length + 1, previous_i == 0);\n234 \n235         // i was supposed to wrap around from length+1 to 0,\n236         // incrementing code_point each time.\n237         code_point = code_point.checked_add(i / (length + 1)).ok_or(())?;\n238         i %= length + 1;\n239         let c = match char::from_u32(code_point) {\n240             Some(c) => c,\n241             None => return Err(()),\n242         };\n243 \n244         // Move earlier insertions farther out in the string\n245         for (idx, _) in &mut self.insertions {\n246             if *idx >= i as usize {\n247                 *idx += 1;\n248             }\n249         }\n250         self.insertions.push((i as usize, c));\n251         length += 1;\n252         i += 1;\n253     }\n254 \n255     self.insertions.sort_by_key(|(i, _)| *i);\n256     Ok(Decode {\n257         base: base.iter(),\n258         insertions: &self.insertions,\n259         inserted: 0,\n260         position: 0,\n261         len: base_len + self.insertions.len(),\n262         phantom: PhantomData::<C>,\n263     })\n264 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}