{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// percent_encoding/src/lib.rs\n// crate name is percent_encoding\n#[cfg(feature = \"alloc\")]\nuse alloc::{\n    borrow::{Cow, ToOwned},\n    string::String, vec::Vec,\n};\nuse core::{fmt, slice, str};\npub use self::ascii_set::{AsciiSet, CONTROLS, NON_ALPHANUMERIC};\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct PercentEncode<'a> {\n    bytes: &'a [u8],\n    ascii_set: &'static AsciiSet,\n}\n#[derive(Debug, PartialEq, Eq)]\npub struct AsciiSet {\n    mask: [Chunk; ASCII_RANGE_LEN / BITS_PER_CHUNK],\n}\nimpl<'a> Iterator for PercentEncode<'a> {\n    type Item = &'a str;\n    fn next(&mut self) -> Option<&'a str> {\n        if let Some((&first_byte, remaining)) = self.bytes.split_first() {\n            if self.ascii_set.should_percent_encode(first_byte) {\n                self.bytes = remaining;\n                Some(percent_encode_byte(first_byte))\n            } else {\n                for (i, &byte) in remaining.iter().enumerate() {\n                    if self.ascii_set.should_percent_encode(byte) {\n                        let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n                        self.bytes = remaining;\n                        return Some(unsafe {\n                            str::from_utf8_unchecked(unchanged_slice)\n                        });\n                    }\n                }\n                let unchanged_slice = self.bytes;\n                self.bytes = &[][..];\n                Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n            }\n        } else {\n            None\n        }\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {}\n}\nimpl AsciiSet {\n    pub const EMPTY: AsciiSet = AsciiSet {\n        mask: [0; ASCII_RANGE_LEN / BITS_PER_CHUNK],\n    };\n    pub(crate) const fn contains(&self, byte: u8) -> bool {}\n    pub(crate) fn should_percent_encode(&self, byte: u8) -> bool {\n        !byte.is_ascii() || self.contains(byte)\n    }\n    pub const fn add(&self, byte: u8) -> Self {\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] |= 1 << (byte as usize % BITS_PER_CHUNK);\n        AsciiSet { mask }\n    }\n    pub const fn remove(&self, byte: u8) -> Self {\n        let mut mask = self.mask;\n        mask[byte as usize / BITS_PER_CHUNK] &= !(1 << (byte as usize % BITS_PER_CHUNK));\n        AsciiSet { mask }\n    }\n    pub const fn union(&self, other: Self) -> Self {\n        let mask = [\n            self.mask[0] | other.mask[0],\n            self.mask[1] | other.mask[1],\n            self.mask[2] | other.mask[2],\n            self.mask[3] | other.mask[3],\n        ];\n        AsciiSet { mask }\n    }\n    pub const fn complement(&self) -> Self {\n        let mask = [!self.mask[0], !self.mask[1], !self.mask[2], !self.mask[3]];\n        AsciiSet { mask }\n    }\n}\n#[inline]\npub fn percent_encode_byte(byte: u8) -> &'static str {\n    static ENC_TABLE: &[u8; 768] = b\"\\\n      %00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F\\\n      %10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F\\\n      %20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F\\\n      %30%31%32%33%34%35%36%37%38%39%3A%3B%3C%3D%3E%3F\\\n      %40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F\\\n      %50%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F\\\n      %60%61%62%63%64%65%66%67%68%69%6A%6B%6C%6D%6E%6F\\\n      %70%71%72%73%74%75%76%77%78%79%7A%7B%7C%7D%7E%7F\\\n      %80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F\\\n      %90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F\\\n      %A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF\\\n      %B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF\\\n      %C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF\\\n      %D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF\\\n      %E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF\\\n      %F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF\\\n      \";\n    let index = usize::from(byte) * 3;\n    unsafe { str::from_utf8_unchecked(&ENC_TABLE[index..index + 3]) }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n150 fn next(&mut self) -> Option<&'a str> {\n151     if let Some((&first_byte, remaining)) = self.bytes.split_first() {\n152         if self.ascii_set.should_percent_encode(first_byte) {\n153             self.bytes = remaining;\n154             Some(percent_encode_byte(first_byte))\n155         } else {\n156             // The unsafe blocks here are appropriate because the bytes are\n157             // confirmed as a subset of UTF-8 in should_percent_encode.\n158             for (i, &byte) in remaining.iter().enumerate() {\n159                 if self.ascii_set.should_percent_encode(byte) {\n160                     // 1 for first_byte + i for previous iterations of this loop\n161                     let (unchanged_slice, remaining) = self.bytes.split_at(1 + i);\n162                     self.bytes = remaining;\n163                     return Some(unsafe { str::from_utf8_unchecked(unchanged_slice) });\n164                 }\n165             }\n166             let unchanged_slice = self.bytes;\n167             self.bytes = &[][..];\n168             Some(unsafe { str::from_utf8_unchecked(unchanged_slice) })\n169         }\n170     } else {\n171         None\n172     }\n173 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}