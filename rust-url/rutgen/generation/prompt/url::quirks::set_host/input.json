{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/quirks.rs\n// crate name is url\nuse crate::parser::{default_port, Context, Input, Parser, SchemeType};\nuse crate::{Host, ParseError, Position, Url};\nuse alloc::string::String;\nuse alloc::string::ToString;\n#[derive(Clone, Debug)]\npub struct Input<'i> {\n    chars: str::Chars<'i>,\n}\n#[derive(Clone)]\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n    scheme_end: u32,\n    username_end: u32,\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,\n    query_start: Option<u32>,\n    fragment_start: Option<u32>,\n}\npub struct Parser<'a> {\n    pub serialization: String,\n    pub base_url: Option<&'a Url>,\n    pub query_encoding_override: EncodingOverride<'a>,\n    pub violation_fn: Option<&'a dyn Fn(SyntaxViolation)>,\n    pub context: Context,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Clone, Debug, Eq, Ord, PartialOrd, Hash)]\npub enum Host<S = String> {\n    /// A DNS domain name, as '.' dot-separated labels.\n    /// Non-ASCII labels are encoded in punycode per IDNA if this is the host of\n    /// a special URL, or percent encoded for non-special URLs. Hosts for\n    /// non-special URLs are also called opaque hosts.\n    Domain(S),\n    /// An IPv4 address.\n    /// `Url::host_str` returns the serialization of this address,\n    /// as four decimal integers separated by `.` dots.\n    Ipv4(Ipv4Addr),\n    /// An IPv6 address.\n    /// `Url::host_str` returns the serialization of that address between `[` and `]` brackets,\n    /// in the format per [RFC 5952 *A Recommendation\n    /// for IPv6 Address Text Representation*](https://tools.ietf.org/html/rfc5952):\n    /// lowercase hexadecimal with maximal `::` compression.\n    Ipv6(Ipv6Addr),\n}\n#[derive(PartialEq, Eq, Copy, Clone)]\npub enum Context {\n    UrlParser,\n    Setter,\n    PathSegmentSetter,\n}\n#[derive(Copy, Clone, PartialEq, Eq)]\npub enum SchemeType {\n    File,\n    SpecialNotFile,\n    NotSpecial,\n}\nimpl<S, T> PartialEq<Host<T>> for Host<S>\nwhere\n    S: PartialEq<T>,\n{\n    fn eq(&self, other: &Host<T>) -> bool {\n        match (self, other) {\n            (Host::Domain(a), Host::Domain(b)) => a == b,\n            (Host::Ipv4(a), Host::Ipv4(b)) => a == b,\n            (Host::Ipv6(a), Host::Ipv6(b)) => a == b,\n            (_, _) => false,\n        }\n    }\n}\nimpl<'i> Input<'i> {\n    pub fn new_no_trim(input: &'i str) -> Self {\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_tab_and_newlines(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(ascii_tab_or_new_line);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_c0_control_and_space(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(c0_control_or_space);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.clone().next().is_none()\n    }\n    #[inline]\n    fn starts_with<P: Pattern>(&self, p: P) -> bool {}\n    #[inline]\n    pub fn split_prefix<P: Pattern>(&self, p: P) -> Option<Self> {\n        let mut remaining = self.clone();\n        if p.split_prefix(&mut remaining) { Some(remaining) } else { None }\n    }\n    #[inline]\n    fn split_first(&self) -> (Option<char>, Self) {\n        let mut remaining = self.clone();\n        (remaining.next(), remaining)\n    }\n    #[inline]\n    fn count_matching<F: Fn(char) -> bool>(&self, f: F) -> (u32, Self) {\n        let mut count = 0;\n        let mut remaining = self.clone();\n        loop {\n            let mut input = remaining.clone();\n            if matches!(input.next(), Some(c) if f(c)) {\n                remaining = input;\n                count += 1;\n            } else {\n                return (count, remaining);\n            }\n        }\n    }\n    #[inline]\n    fn next_utf8(&mut self) -> Option<(char, &'i str)> {}\n}\nimpl Url {\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {}\n    #[inline]\n    pub fn parse_with_params<I, K, V>(\n        input: &str,\n        iter: I,\n    ) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {}\n    fn strip_trailing_spaces_from_opaque_path(&mut self) {}\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {}\n    pub fn make_relative(&self, url: &Url) -> Option<String> {}\n    pub fn options<'a>() -> ParseOptions<'a> {}\n    #[inline]\n    pub fn as_str(&self) -> &str {}\n    #[inline]\n    #[deprecated(since = \"2.3.0\", note = \"use Into<String>\")]\n    pub fn into_string(self) -> String {}\n    pub fn check_invariants(&self) -> Result<(), String> {}\n    #[inline]\n    pub fn origin(&self) -> Origin {}\n    #[inline]\n    pub fn scheme(&self) -> &str {\n        self.slice(..self.scheme_end)\n    }\n    pub fn is_special(&self) -> bool {}\n    #[inline]\n    pub fn has_authority(&self) -> bool {}\n    pub fn authority(&self) -> &str {}\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {\n        !self.slice(self.scheme_end + 1..).starts_with('/')\n    }\n    pub fn username(&self) -> &str {}\n    pub fn password(&self) -> Option<&str> {}\n    pub fn has_host(&self) -> bool {}\n    pub fn host_str(&self) -> Option<&str> {}\n    pub fn host(&self) -> Option<Host<&str>> {}\n    pub fn domain(&self) -> Option<&str> {}\n    #[inline]\n    pub fn port(&self) -> Option<u16> {\n        self.port\n    }\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {}\n    #[cfg(feature = \"std\")]\n    #[cfg(\n        any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\")\n    )]\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<alloc::vec::Vec<SocketAddr>> {}\n    pub fn path(&self) -> &str {}\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {}\n    pub fn query(&self) -> Option<&str> {}\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {}\n    pub fn fragment(&self) -> Option<&str> {}\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {}\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {}\n    fn take_fragment(&mut self) -> Option<String> {}\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {}\n    pub fn set_query(&mut self, query: Option<&str>) {}\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {}\n    fn take_after_path(&mut self) -> String {}\n    pub fn set_path(&mut self, mut path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {}\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {}\n    fn set_port_internal(&mut self, port: Option<u16>) {}\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {}\n    fn set_host_internal(\n        &mut self,\n        host: Host<String>,\n        opt_new_port: Option<Option<u16>>,\n    ) {\n        let old_suffix_pos = if opt_new_port.is_some() {\n            self.path_start\n        } else {\n            self.host_end\n        };\n        let suffix = self.slice(old_suffix_pos..).to_owned();\n        self.serialization.truncate(self.host_start as usize);\n        if !self.has_authority() {\n            debug_assert!(self.slice(self.scheme_end..self.host_start) == \":\");\n            debug_assert!(self.username_end == self.host_start);\n            self.serialization.push('/');\n            self.serialization.push('/');\n            self.username_end += 2;\n            self.host_start += 2;\n        }\n        write!(& mut self.serialization, \"{}\", host).unwrap();\n        self.host_end = to_u32(self.serialization.len()).unwrap();\n        self.host = host.into();\n        if let Some(new_port) = opt_new_port {\n            self.port = new_port;\n            if let Some(port) = new_port {\n                write!(& mut self.serialization, \":{}\", port).unwrap();\n            }\n        }\n        let new_suffix_pos = to_u32(self.serialization.len()).unwrap();\n        self.serialization.push_str(&suffix);\n        let adjust = |index: &mut u32| {\n            *index -= old_suffix_pos;\n            *index += new_suffix_pos;\n        };\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n    }\n    #[allow(clippy::result_unit_err)]\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err, clippy::suspicious_operation_groupings)]\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(Error::custom)?\n        }\n        Ok(url)\n    }\n    #[inline]\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {}\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {}\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {}\n}\nimpl<'a> Parser<'a> {\n    fn log_violation(&self, v: SyntaxViolation) {}\n    fn log_violation_if(&self, v: SyntaxViolation, test: impl FnOnce() -> bool) {}\n    pub fn for_setter(serialization: String) -> Parser<'a> {}\n    pub fn parse_url(mut self, input: &str) -> ParseResult<Url> {}\n    pub fn parse_scheme<'i>(&mut self, mut input: Input<'i>) -> Result<Input<'i>, ()> {}\n    fn parse_with_scheme(mut self, input: Input<'_>) -> ParseResult<Url> {}\n    fn parse_non_special(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {}\n    fn parse_file(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_file_url: Option<&Url>,\n    ) -> ParseResult<Url> {}\n    fn parse_relative(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_url: &Url,\n    ) -> ParseResult<Url> {}\n    fn after_double_slash(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {}\n    fn parse_userinfo<'i>(\n        &mut self,\n        mut input: Input<'i>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, Input<'i>)> {}\n    fn parse_host_and_port<'i>(\n        &mut self,\n        input: Input<'i>,\n        scheme_end: u32,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, HostInternal, Option<u16>, Input<'i>)> {}\n    pub fn parse_host(\n        mut input: Input<'_>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(Host<String>, Input<'_>)> {\n        if scheme_type.is_file() {\n            return Parser::get_file_host(input);\n        }\n        let input_str = input.chars.as_str();\n        let mut inside_square_brackets = false;\n        let mut has_ignored_chars = false;\n        let mut non_ignored_chars = 0;\n        let mut bytes = 0;\n        for c in input_str.chars() {\n            match c {\n                ':' if !inside_square_brackets => break,\n                '\\\\' if scheme_type.is_special() => break,\n                '/' | '?' | '#' => break,\n                ascii_tab_or_new_line_pattern!() => {\n                    has_ignored_chars = true;\n                }\n                '[' => {\n                    inside_square_brackets = true;\n                    non_ignored_chars += 1;\n                }\n                ']' => {\n                    inside_square_brackets = false;\n                    non_ignored_chars += 1;\n                }\n                _ => non_ignored_chars += 1,\n            }\n            bytes += c.len_utf8();\n        }\n        let replaced: String;\n        let host_str;\n        {\n            let host_input = input.by_ref().take(non_ignored_chars);\n            if has_ignored_chars {\n                replaced = host_input.collect();\n                host_str = &*replaced;\n            } else {\n                for _ in host_input {}\n                host_str = &input_str[..bytes];\n            }\n        }\n        if scheme_type == SchemeType::SpecialNotFile && host_str.is_empty() {\n            return Err(ParseError::EmptyHost);\n        }\n        if !scheme_type.is_special() {\n            let host = Host::parse_opaque(host_str)?;\n            return Ok((host, input));\n        }\n        let host = Host::parse(host_str)?;\n        Ok((host, input))\n    }\n    fn get_file_host(input: Input<'_>) -> ParseResult<(Host<String>, Input<'_>)> {}\n    fn parse_file_host<'i>(\n        &mut self,\n        input: Input<'i>,\n    ) -> ParseResult<(bool, HostInternal, Input<'i>)> {}\n    pub fn file_host(input: Input) -> ParseResult<(bool, String, Input)> {}\n    pub fn parse_port<P>(\n        mut input: Input<'_>,\n        default_port: P,\n        context: Context,\n    ) -> ParseResult<(Option<u16>, Input<'_>)>\n    where\n        P: Fn() -> Option<u16>,\n    {}\n    pub fn parse_path_start<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        input: Input<'i>,\n    ) -> Input<'i> {}\n    pub fn parse_path<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        path_start: usize,\n        mut input: Input<'i>,\n    ) -> Input<'i> {}\n    fn last_slash_can_be_removed(serialization: &str, path_start: usize) -> bool {}\n    fn shorten_path(&mut self, scheme_type: SchemeType, path_start: usize) {}\n    fn pop_path(&mut self, scheme_type: SchemeType, path_start: usize) {}\n    pub fn parse_cannot_be_a_base_path<'i>(\n        &mut self,\n        mut input: Input<'i>,\n    ) -> Input<'i> {}\n    #[allow(clippy::too_many_arguments)]\n    fn with_query_and_fragment(\n        mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        username_end: u32,\n        host_start: u32,\n        host_end: u32,\n        host: HostInternal,\n        port: Option<u16>,\n        mut path_start: u32,\n        remaining: Input<'_>,\n    ) -> ParseResult<Url> {}\n    fn parse_query_and_fragment(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        mut input: Input<'_>,\n    ) -> ParseResult<(Option<u32>, Option<u32>)> {}\n    pub fn parse_query<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        input: Input<'i>,\n    ) -> Option<Input<'i>> {}\n    fn fragment_only(\n        mut self,\n        base_url: &Url,\n        mut input: Input<'_>,\n    ) -> ParseResult<Url> {}\n    pub fn parse_fragment(&mut self, input: Input<'_>) {}\n    #[inline]\n    fn check_url_code_point(&self, c: char, input: &Input<'_>) {}\n}\n#[allow(clippy::result_unit_err)]\npub fn set_host(url: &mut Url, new_host: &str) -> Result<(), ()> {\n    if url.cannot_be_a_base() {\n        return Err(());\n    }\n    let input = Input::new_no_trim(new_host);\n    let host;\n    let opt_port;\n    {\n        let scheme = url.scheme();\n        let scheme_type = SchemeType::from(scheme);\n        if scheme_type == SchemeType::File && new_host.is_empty() {\n            url.set_host_internal(Host::Domain(String::new()), None);\n            return Ok(());\n        }\n        if let Ok((h, remaining)) = Parser::parse_host(input, scheme_type) {\n            host = h;\n            opt_port = if let Some(remaining) = remaining.split_prefix(':') {\n                if remaining.is_empty() {\n                    None\n                } else {\n                    Parser::parse_port(\n                            remaining,\n                            || default_port(scheme),\n                            Context::Setter,\n                        )\n                        .ok()\n                        .map(|(port, _remaining)| port)\n                }\n            } else {\n                None\n            };\n        } else {\n            return Err(());\n        }\n    }\n    if host == Host::Domain(\"\".to_string())\n        && (!username(url).is_empty() || matches!(opt_port, Some(Some(_)))\n            || url.port().is_some())\n    {\n        return Err(());\n    }\n    url.set_host_internal(host, opt_port);\n    Ok(())\n}\n#[inline]\npub fn username(url: &Url) -> &str {\n    url.username()\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Setter for <https://url.spec.whatwg.org/#dom-url-host>\n150 pub fn set_host(url: &mut Url, new_host: &str) -> Result<(), ()> {\n151     // If context object’s url’s cannot-be-a-base-URL flag is set, then return.\n152     if url.cannot_be_a_base() {\n153         return Err(());\n154     }\n155     // Host parsing rules are strict,\n156     // We don't want to trim the input\n157     let input = Input::new_no_trim(new_host);\n158     let host;\n159     let opt_port;\n160     {\n161         let scheme = url.scheme();\n162         let scheme_type = SchemeType::from(scheme);\n163         if scheme_type == SchemeType::File && new_host.is_empty() {\n164             url.set_host_internal(Host::Domain(String::new()), None);\n165             return Ok(());\n166         }\n167 \n168         if let Ok((h, remaining)) = Parser::parse_host(input, scheme_type) {\n169             host = h;\n170             opt_port = if let Some(remaining) = remaining.split_prefix(':') {\n171                 if remaining.is_empty() {\n172                     None\n173                 } else {\n174                     Parser::parse_port(remaining, || default_port(scheme), Context::Setter)\n175                         .ok()\n176                         .map(|(port, _remaining)| port)\n177                 }\n178             } else {\n179                 None\n180             };\n181         } else {\n182             return Err(());\n183         }\n184     }\n185     // Make sure we won't set an empty host to a url with a username or a port\n186     if host == Host::Domain(\"\".to_string())\n187         && (!username(url).is_empty() || matches!(opt_port, Some(Some(_))) || url.port().is_some())\n188     {\n189         return Err(());\n190     }\n191     url.set_host_internal(host, opt_port);\n192     Ok(())\n193 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}