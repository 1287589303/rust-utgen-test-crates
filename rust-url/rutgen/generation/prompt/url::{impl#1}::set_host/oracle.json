{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/lib.rs\n// crate name is url\npub use form_urlencoded;\nuse crate::host::HostInternal;\nuse crate::net::IpAddr;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse crate::net::{SocketAddr, ToSocketAddrs};\nuse crate::parser::{to_u32, Context, Parser, SchemeType, USERINFO};\nuse alloc::borrow::ToOwned;\nuse alloc::str;\nuse alloc::string::{String, ToString};\nuse core::borrow::Borrow;\nuse core::convert::TryFrom;\nuse core::fmt::Write;\nuse core::ops::{Range, RangeFrom, RangeTo};\nuse core::{cmp, fmt, hash, mem};\nuse percent_encoding::utf8_percent_encode;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse std::io;\n#[cfg(feature = \"std\")]\nuse std::path::{Path, PathBuf};\npub use crate::host::Host;\npub use crate::origin::{OpaqueOrigin, Origin};\npub use crate::parser::{ParseError, SyntaxViolation};\npub use crate::path_segments::PathSegmentsMut;\npub use crate::slicing::Position;\npub use form_urlencoded::EncodingOverride;\n#[derive(Clone)]\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n    scheme_end: u32,\n    username_end: u32,\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,\n    query_start: Option<u32>,\n    fragment_start: Option<u32>,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Clone, Debug, Eq, Ord, PartialOrd, Hash)]\npub enum Host<S = String> {\n    /// A DNS domain name, as '.' dot-separated labels.\n    /// Non-ASCII labels are encoded in punycode per IDNA if this is the host of\n    /// a special URL, or percent encoded for non-special URLs. Hosts for\n    /// non-special URLs are also called opaque hosts.\n    Domain(S),\n    /// An IPv4 address.\n    /// `Url::host_str` returns the serialization of this address,\n    /// as four decimal integers separated by `.` dots.\n    Ipv4(Ipv4Addr),\n    /// An IPv6 address.\n    /// `Url::host_str` returns the serialization of that address between `[` and `]` brackets,\n    /// in the format per [RFC 5952 *A Recommendation\n    /// for IPv6 Address Text Representation*](https://tools.ietf.org/html/rfc5952):\n    /// lowercase hexadecimal with maximal `::` compression.\n    Ipv6(Ipv6Addr),\n}\n#[derive(Copy, Clone, PartialEq, Eq)]\npub enum SchemeType {\n    File,\n    SpecialNotFile,\n    NotSpecial,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub(crate) enum HostInternal {\n    None,\n    Domain,\n    Ipv4(Ipv4Addr),\n    Ipv6(Ipv6Addr),\n}\nimpl Url {\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {}\n    #[inline]\n    pub fn parse_with_params<I, K, V>(\n        input: &str,\n        iter: I,\n    ) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {}\n    fn strip_trailing_spaces_from_opaque_path(&mut self) {}\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {}\n    pub fn make_relative(&self, url: &Url) -> Option<String> {}\n    pub fn options<'a>() -> ParseOptions<'a> {}\n    #[inline]\n    pub fn as_str(&self) -> &str {}\n    #[inline]\n    #[deprecated(since = \"2.3.0\", note = \"use Into<String>\")]\n    pub fn into_string(self) -> String {}\n    pub fn check_invariants(&self) -> Result<(), String> {}\n    #[inline]\n    pub fn origin(&self) -> Origin {}\n    #[inline]\n    pub fn scheme(&self) -> &str {\n        self.slice(..self.scheme_end)\n    }\n    pub fn is_special(&self) -> bool {}\n    #[inline]\n    pub fn has_authority(&self) -> bool {}\n    pub fn authority(&self) -> &str {}\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {\n        !self.slice(self.scheme_end + 1..).starts_with('/')\n    }\n    pub fn username(&self) -> &str {}\n    pub fn password(&self) -> Option<&str> {}\n    pub fn has_host(&self) -> bool {\n        !matches!(self.host, HostInternal::None)\n    }\n    pub fn host_str(&self) -> Option<&str> {}\n    pub fn host(&self) -> Option<Host<&str>> {}\n    pub fn domain(&self) -> Option<&str> {}\n    #[inline]\n    pub fn port(&self) -> Option<u16> {}\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {}\n    #[cfg(feature = \"std\")]\n    #[cfg(\n        any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\")\n    )]\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<alloc::vec::Vec<SocketAddr>> {}\n    pub fn path(&self) -> &str {}\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {}\n    pub fn query(&self) -> Option<&str> {}\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {}\n    pub fn fragment(&self) -> Option<&str> {}\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {}\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {}\n    fn take_fragment(&mut self) -> Option<String> {}\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {}\n    pub fn set_query(&mut self, query: Option<&str>) {}\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {}\n    fn take_after_path(&mut self) -> String {}\n    pub fn set_path(&mut self, mut path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {}\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {}\n    fn set_port_internal(&mut self, port: Option<u16>) {}\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {\n        if self.cannot_be_a_base() {\n            return Err(ParseError::SetHostOnCannotBeABaseUrl);\n        }\n        let scheme_type = SchemeType::from(self.scheme());\n        if let Some(host) = host {\n            if host.is_empty() && scheme_type.is_special() && !scheme_type.is_file() {\n                return Err(ParseError::EmptyHost);\n            }\n            let mut host_substr = host;\n            if !host.starts_with('[') || !host.ends_with(']') {\n                match host.find(':') {\n                    Some(0) => {\n                        return Err(ParseError::InvalidDomainCharacter);\n                    }\n                    Some(colon_index) => {\n                        host_substr = &host[..colon_index];\n                    }\n                    None => {}\n                }\n            }\n            if SchemeType::from(self.scheme()).is_special() {\n                self.set_host_internal(Host::parse(host_substr)?, None);\n            } else {\n                self.set_host_internal(Host::parse_opaque(host_substr)?, None);\n            }\n        } else if self.has_host() {\n            if scheme_type.is_special() && !scheme_type.is_file() {\n                return Err(ParseError::EmptyHost);\n            } else if self.serialization.len() == self.path_start as usize {\n                self.serialization.push('/');\n            }\n            debug_assert!(self.byte_at(self.scheme_end) == b':');\n            debug_assert!(self.byte_at(self.path_start) == b'/');\n            let new_path_start = if scheme_type.is_file() {\n                self.scheme_end + 3\n            } else {\n                self.scheme_end + 1\n            };\n            self.serialization.drain(new_path_start as usize..self.path_start as usize);\n            let offset = self.path_start - new_path_start;\n            self.path_start = new_path_start;\n            self.username_end = new_path_start;\n            self.host_start = new_path_start;\n            self.host_end = new_path_start;\n            self.port = None;\n            if let Some(ref mut index) = self.query_start {\n                *index -= offset;\n            }\n            if let Some(ref mut index) = self.fragment_start {\n                *index -= offset;\n            }\n        }\n        Ok(())\n    }\n    fn set_host_internal(\n        &mut self,\n        host: Host<String>,\n        opt_new_port: Option<Option<u16>>,\n    ) {\n        let old_suffix_pos = if opt_new_port.is_some() {\n            self.path_start\n        } else {\n            self.host_end\n        };\n        let suffix = self.slice(old_suffix_pos..).to_owned();\n        self.serialization.truncate(self.host_start as usize);\n        if !self.has_authority() {\n            debug_assert!(self.slice(self.scheme_end..self.host_start) == \":\");\n            debug_assert!(self.username_end == self.host_start);\n            self.serialization.push('/');\n            self.serialization.push('/');\n            self.username_end += 2;\n            self.host_start += 2;\n        }\n        write!(& mut self.serialization, \"{}\", host).unwrap();\n        self.host_end = to_u32(self.serialization.len()).unwrap();\n        self.host = host.into();\n        if let Some(new_port) = opt_new_port {\n            self.port = new_port;\n            if let Some(port) = new_port {\n                write!(& mut self.serialization, \":{}\", port).unwrap();\n            }\n        }\n        let new_suffix_pos = to_u32(self.serialization.len()).unwrap();\n        self.serialization.push_str(&suffix);\n        let adjust = |index: &mut u32| {\n            *index -= old_suffix_pos;\n            *index += new_suffix_pos;\n        };\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n    }\n    #[allow(clippy::result_unit_err)]\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err, clippy::suspicious_operation_groupings)]\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(Error::custom)?\n        }\n        Ok(url)\n    }\n    #[inline]\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {}\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {}\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {\n        self.serialization.as_bytes()[i as usize]\n    }\n}\nimpl Host<String> {\n    pub fn parse(input: &str) -> Result<Self, ParseError> {\n        if input.starts_with('[') {\n            if !input.ends_with(']') {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            return parse_ipv6addr(&input[1..input.len() - 1]).map(Host::Ipv6);\n        }\n        let domain: Cow<'_, [u8]> = percent_decode(input.as_bytes()).into();\n        let domain = Self::domain_to_ascii(&domain)?;\n        if domain.is_empty() {\n            return Err(ParseError::EmptyHost);\n        }\n        if ends_in_a_number(&domain) {\n            let address = parse_ipv4addr(&domain)?;\n            Ok(Host::Ipv4(address))\n        } else {\n            Ok(Host::Domain(domain.to_string()))\n        }\n    }\n    pub fn parse_opaque(input: &str) -> Result<Self, ParseError> {\n        if input.starts_with('[') {\n            if !input.ends_with(']') {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            return parse_ipv6addr(&input[1..input.len() - 1]).map(Host::Ipv6);\n        }\n        let is_invalid_host_char = |c| {\n            matches!(\n                c, '\\0' | '\\t' | '\\n' | '\\r' | ' ' | '#' | '/' | ':' | '<' | '>' | '?' |\n                '@' | '[' | '\\\\' | ']' | '^' | '|'\n            )\n        };\n        if input.find(is_invalid_host_char).is_some() {\n            Err(ParseError::InvalidDomainCharacter)\n        } else {\n            Ok(Host::Domain(utf8_percent_encode(input, CONTROLS).to_string()))\n        }\n    }\n    fn domain_to_ascii(domain: &[u8]) -> Result<Cow<'_, str>, ParseError> {}\n}\nimpl SchemeType {\n    pub fn is_special(&self) -> bool {\n        !matches!(* self, SchemeType::NotSpecial)\n    }\n    pub fn is_file(&self) -> bool {\n        matches!(* self, SchemeType::File)\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Change this URLâ€™s host.\n///\n/// Removing the host (calling this with `None`)\n/// will also remove any username, password, and port number.\n///\n/// # Examples\n///\n/// Change host:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_host(Some(\"rust-lang.org\"));\n/// assert!(result.is_ok());\n/// assert_eq!(url.as_str(), \"https://rust-lang.org/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Remove host:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"foo://example.net\")?;\n/// let result = url.set_host(None);\n/// assert!(result.is_ok());\n/// assert_eq!(url.as_str(), \"foo:/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot remove host for 'special' schemes (e.g. `http`):\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_host(None);\n/// assert!(result.is_err());\n/// assert_eq!(url.as_str(), \"https://example.net/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot change or remove host for cannot-be-a-base URLs:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n///\n/// let result = url.set_host(Some(\"rust-lang.org\"));\n/// assert!(result.is_err());\n/// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n///\n/// let result = url.set_host(None);\n/// assert!(result.is_err());\n/// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// # Errors\n///\n/// If this URL is cannot-be-a-base or there is an error parsing the given `host`,\n/// a [`ParseError`] variant will be returned.\n///\n/// [`ParseError`]: enum.ParseError.html\n2008 pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {\n2009     if self.cannot_be_a_base() {\n2010         return Err(ParseError::SetHostOnCannotBeABaseUrl);\n2011     }\n2012 \n2013     let scheme_type = SchemeType::from(self.scheme());\n2014 \n2015     if let Some(host) = host {\n2016         if host.is_empty() && scheme_type.is_special() && !scheme_type.is_file() {\n2017             return Err(ParseError::EmptyHost);\n2018         }\n2019         let mut host_substr = host;\n2020         // Otherwise, if c is U+003A (:) and the [] flag is unset, then\n2021         if !host.starts_with('[') || !host.ends_with(']') {\n2022             match host.find(':') {\n2023                 Some(0) => {\n2024                     // If buffer is the empty string, validation error, return failure.\n2025                     return Err(ParseError::InvalidDomainCharacter);\n2026                 }\n2027                 // Let host be the result of host parsing buffer\n2028                 Some(colon_index) => {\n2029                     host_substr = &host[..colon_index];\n2030                 }\n2031                 None => {}\n2032             }\n2033         }\n2034         if SchemeType::from(self.scheme()).is_special() {\n2035             self.set_host_internal(Host::parse(host_substr)?, None);\n2036         } else {\n2037             self.set_host_internal(Host::parse_opaque(host_substr)?, None);\n2038         }\n2039     } else if self.has_host() {\n2040         if scheme_type.is_special() && !scheme_type.is_file() {\n2041             return Err(ParseError::EmptyHost);\n2042         } else if self.serialization.len() == self.path_start as usize {\n2043             self.serialization.push('/');\n2044         }\n2045         debug_assert!(self.byte_at(self.scheme_end) == b':');\n2046         debug_assert!(self.byte_at(self.path_start) == b'/');\n2047 \n2048         let new_path_start = if scheme_type.is_file() {\n2049             self.scheme_end + 3\n2050         } else {\n2051             self.scheme_end + 1\n2052         };\n2053 \n2054         self.serialization\n2055             .drain(new_path_start as usize..self.path_start as usize);\n2056         let offset = self.path_start - new_path_start;\n2057         self.path_start = new_path_start;\n2058         self.username_end = new_path_start;\n2059         self.host_start = new_path_start;\n2060         self.host_end = new_path_start;\n2061         self.port = None;\n2062         if let Some(ref mut index) = self.query_start {\n2063             *index -= offset\n2064         }\n2065         if let Some(ref mut index) = self.fragment_start {\n2066             *index -= offset\n2067         }\n2068     }\n2069     Ok(())\n2070 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}