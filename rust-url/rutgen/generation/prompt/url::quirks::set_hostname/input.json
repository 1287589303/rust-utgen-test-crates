{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/quirks.rs\n// crate name is url\nuse crate::parser::{default_port, Context, Input, Parser, SchemeType};\nuse crate::{Host, ParseError, Position, Url};\nuse alloc::string::String;\nuse alloc::string::ToString;\n#[derive(Clone)]\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n    scheme_end: u32,\n    username_end: u32,\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,\n    query_start: Option<u32>,\n    fragment_start: Option<u32>,\n}\npub struct Parser<'a> {\n    pub serialization: String,\n    pub base_url: Option<&'a Url>,\n    pub query_encoding_override: EncodingOverride<'a>,\n    pub violation_fn: Option<&'a dyn Fn(SyntaxViolation)>,\n    pub context: Context,\n}\n#[derive(Clone, Debug)]\npub struct Input<'i> {\n    chars: str::Chars<'i>,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Clone, Debug, Eq, Ord, PartialOrd, Hash)]\npub enum Host<S = String> {\n    /// A DNS domain name, as '.' dot-separated labels.\n    /// Non-ASCII labels are encoded in punycode per IDNA if this is the host of\n    /// a special URL, or percent encoded for non-special URLs. Hosts for\n    /// non-special URLs are also called opaque hosts.\n    Domain(S),\n    /// An IPv4 address.\n    /// `Url::host_str` returns the serialization of this address,\n    /// as four decimal integers separated by `.` dots.\n    Ipv4(Ipv4Addr),\n    /// An IPv6 address.\n    /// `Url::host_str` returns the serialization of that address between `[` and `]` brackets,\n    /// in the format per [RFC 5952 *A Recommendation\n    /// for IPv6 Address Text Representation*](https://tools.ietf.org/html/rfc5952):\n    /// lowercase hexadecimal with maximal `::` compression.\n    Ipv6(Ipv6Addr),\n}\n#[derive(Copy, Clone, PartialEq, Eq)]\npub enum SchemeType {\n    File,\n    SpecialNotFile,\n    NotSpecial,\n}\nimpl Url {\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {}\n    #[inline]\n    pub fn parse_with_params<I, K, V>(\n        input: &str,\n        iter: I,\n    ) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {}\n    fn strip_trailing_spaces_from_opaque_path(&mut self) {}\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {}\n    pub fn make_relative(&self, url: &Url) -> Option<String> {}\n    pub fn options<'a>() -> ParseOptions<'a> {}\n    #[inline]\n    pub fn as_str(&self) -> &str {}\n    #[inline]\n    #[deprecated(since = \"2.3.0\", note = \"use Into<String>\")]\n    pub fn into_string(self) -> String {}\n    pub fn check_invariants(&self) -> Result<(), String> {}\n    #[inline]\n    pub fn origin(&self) -> Origin {}\n    #[inline]\n    pub fn scheme(&self) -> &str {\n        self.slice(..self.scheme_end)\n    }\n    pub fn is_special(&self) -> bool {}\n    #[inline]\n    pub fn has_authority(&self) -> bool {}\n    pub fn authority(&self) -> &str {}\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {\n        !self.slice(self.scheme_end + 1..).starts_with('/')\n    }\n    pub fn username(&self) -> &str {\n        let scheme_separator_len = \"://\".len() as u32;\n        if self.has_authority()\n            && self.username_end > self.scheme_end + scheme_separator_len\n        {\n            self.slice(self.scheme_end + scheme_separator_len..self.username_end)\n        } else {\n            \"\"\n        }\n    }\n    pub fn password(&self) -> Option<&str> {\n        if self.has_authority() && self.username_end != self.serialization.len() as u32\n            && self.byte_at(self.username_end) == b':'\n        {\n            debug_assert!(self.byte_at(self.host_start - 1) == b'@');\n            Some(self.slice(self.username_end + 1..self.host_start - 1))\n        } else {\n            None\n        }\n    }\n    pub fn has_host(&self) -> bool {}\n    pub fn host_str(&self) -> Option<&str> {}\n    pub fn host(&self) -> Option<Host<&str>> {}\n    pub fn domain(&self) -> Option<&str> {}\n    #[inline]\n    pub fn port(&self) -> Option<u16> {}\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {}\n    #[cfg(feature = \"std\")]\n    #[cfg(\n        any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\")\n    )]\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<alloc::vec::Vec<SocketAddr>> {}\n    pub fn path(&self) -> &str {}\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {}\n    pub fn query(&self) -> Option<&str> {}\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {}\n    pub fn fragment(&self) -> Option<&str> {}\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {}\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {}\n    fn take_fragment(&mut self) -> Option<String> {}\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {}\n    pub fn set_query(&mut self, query: Option<&str>) {}\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {}\n    fn take_after_path(&mut self) -> String {}\n    pub fn set_path(&mut self, mut path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {}\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {}\n    fn set_port_internal(&mut self, port: Option<u16>) {}\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {}\n    fn set_host_internal(\n        &mut self,\n        host: Host<String>,\n        opt_new_port: Option<Option<u16>>,\n    ) {\n        let old_suffix_pos = if opt_new_port.is_some() {\n            self.path_start\n        } else {\n            self.host_end\n        };\n        let suffix = self.slice(old_suffix_pos..).to_owned();\n        self.serialization.truncate(self.host_start as usize);\n        if !self.has_authority() {\n            debug_assert!(self.slice(self.scheme_end..self.host_start) == \":\");\n            debug_assert!(self.username_end == self.host_start);\n            self.serialization.push('/');\n            self.serialization.push('/');\n            self.username_end += 2;\n            self.host_start += 2;\n        }\n        write!(& mut self.serialization, \"{}\", host).unwrap();\n        self.host_end = to_u32(self.serialization.len()).unwrap();\n        self.host = host.into();\n        if let Some(new_port) = opt_new_port {\n            self.port = new_port;\n            if let Some(port) = new_port {\n                write!(& mut self.serialization, \":{}\", port).unwrap();\n            }\n        }\n        let new_suffix_pos = to_u32(self.serialization.len()).unwrap();\n        self.serialization.push_str(&suffix);\n        let adjust = |index: &mut u32| {\n            *index -= old_suffix_pos;\n            *index += new_suffix_pos;\n        };\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n    }\n    #[allow(clippy::result_unit_err)]\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err, clippy::suspicious_operation_groupings)]\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(Error::custom)?\n        }\n        Ok(url)\n    }\n    #[inline]\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {}\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {}\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {}\n}\nimpl<'a> Parser<'a> {\n    fn log_violation(&self, v: SyntaxViolation) {}\n    fn log_violation_if(&self, v: SyntaxViolation, test: impl FnOnce() -> bool) {}\n    pub fn for_setter(serialization: String) -> Parser<'a> {}\n    pub fn parse_url(mut self, input: &str) -> ParseResult<Url> {}\n    pub fn parse_scheme<'i>(&mut self, mut input: Input<'i>) -> Result<Input<'i>, ()> {}\n    fn parse_with_scheme(mut self, input: Input<'_>) -> ParseResult<Url> {}\n    fn parse_non_special(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {}\n    fn parse_file(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_file_url: Option<&Url>,\n    ) -> ParseResult<Url> {}\n    fn parse_relative(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_url: &Url,\n    ) -> ParseResult<Url> {}\n    fn after_double_slash(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {}\n    fn parse_userinfo<'i>(\n        &mut self,\n        mut input: Input<'i>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, Input<'i>)> {}\n    fn parse_host_and_port<'i>(\n        &mut self,\n        input: Input<'i>,\n        scheme_end: u32,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, HostInternal, Option<u16>, Input<'i>)> {}\n    pub fn parse_host(\n        mut input: Input<'_>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(Host<String>, Input<'_>)> {\n        if scheme_type.is_file() {\n            return Parser::get_file_host(input);\n        }\n        let input_str = input.chars.as_str();\n        let mut inside_square_brackets = false;\n        let mut has_ignored_chars = false;\n        let mut non_ignored_chars = 0;\n        let mut bytes = 0;\n        for c in input_str.chars() {\n            match c {\n                ':' if !inside_square_brackets => break,\n                '\\\\' if scheme_type.is_special() => break,\n                '/' | '?' | '#' => break,\n                ascii_tab_or_new_line_pattern!() => {\n                    has_ignored_chars = true;\n                }\n                '[' => {\n                    inside_square_brackets = true;\n                    non_ignored_chars += 1;\n                }\n                ']' => {\n                    inside_square_brackets = false;\n                    non_ignored_chars += 1;\n                }\n                _ => non_ignored_chars += 1,\n            }\n            bytes += c.len_utf8();\n        }\n        let replaced: String;\n        let host_str;\n        {\n            let host_input = input.by_ref().take(non_ignored_chars);\n            if has_ignored_chars {\n                replaced = host_input.collect();\n                host_str = &*replaced;\n            } else {\n                for _ in host_input {}\n                host_str = &input_str[..bytes];\n            }\n        }\n        if scheme_type == SchemeType::SpecialNotFile && host_str.is_empty() {\n            return Err(ParseError::EmptyHost);\n        }\n        if !scheme_type.is_special() {\n            let host = Host::parse_opaque(host_str)?;\n            return Ok((host, input));\n        }\n        let host = Host::parse(host_str)?;\n        Ok((host, input))\n    }\n    fn get_file_host(input: Input<'_>) -> ParseResult<(Host<String>, Input<'_>)> {}\n    fn parse_file_host<'i>(\n        &mut self,\n        input: Input<'i>,\n    ) -> ParseResult<(bool, HostInternal, Input<'i>)> {}\n    pub fn file_host(input: Input) -> ParseResult<(bool, String, Input)> {}\n    pub fn parse_port<P>(\n        mut input: Input<'_>,\n        default_port: P,\n        context: Context,\n    ) -> ParseResult<(Option<u16>, Input<'_>)>\n    where\n        P: Fn() -> Option<u16>,\n    {}\n    pub fn parse_path_start<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        input: Input<'i>,\n    ) -> Input<'i> {}\n    pub fn parse_path<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        path_start: usize,\n        mut input: Input<'i>,\n    ) -> Input<'i> {}\n    fn last_slash_can_be_removed(serialization: &str, path_start: usize) -> bool {}\n    fn shorten_path(&mut self, scheme_type: SchemeType, path_start: usize) {}\n    fn pop_path(&mut self, scheme_type: SchemeType, path_start: usize) {}\n    pub fn parse_cannot_be_a_base_path<'i>(\n        &mut self,\n        mut input: Input<'i>,\n    ) -> Input<'i> {}\n    #[allow(clippy::too_many_arguments)]\n    fn with_query_and_fragment(\n        mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        username_end: u32,\n        host_start: u32,\n        host_end: u32,\n        host: HostInternal,\n        port: Option<u16>,\n        mut path_start: u32,\n        remaining: Input<'_>,\n    ) -> ParseResult<Url> {}\n    fn parse_query_and_fragment(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        mut input: Input<'_>,\n    ) -> ParseResult<(Option<u32>, Option<u32>)> {}\n    pub fn parse_query<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        input: Input<'i>,\n    ) -> Option<Input<'i>> {}\n    fn fragment_only(\n        mut self,\n        base_url: &Url,\n        mut input: Input<'_>,\n    ) -> ParseResult<Url> {}\n    pub fn parse_fragment(&mut self, input: Input<'_>) {}\n    #[inline]\n    fn check_url_code_point(&self, c: char, input: &Input<'_>) {}\n}\nimpl<'i> Input<'i> {\n    pub fn new_no_trim(input: &'i str) -> Self {\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_tab_and_newlines(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(ascii_tab_or_new_line);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_c0_control_and_space(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(c0_control_or_space);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    fn starts_with<P: Pattern>(&self, p: P) -> bool {}\n    #[inline]\n    pub fn split_prefix<P: Pattern>(&self, p: P) -> Option<Self> {\n        let mut remaining = self.clone();\n        if p.split_prefix(&mut remaining) { Some(remaining) } else { None }\n    }\n    #[inline]\n    fn split_first(&self) -> (Option<char>, Self) {\n        let mut remaining = self.clone();\n        (remaining.next(), remaining)\n    }\n    #[inline]\n    fn count_matching<F: Fn(char) -> bool>(&self, f: F) -> (u32, Self) {\n        let mut count = 0;\n        let mut remaining = self.clone();\n        loop {\n            let mut input = remaining.clone();\n            if matches!(input.next(), Some(c) if f(c)) {\n                remaining = input;\n                count += 1;\n            } else {\n                return (count, remaining);\n            }\n        }\n    }\n    #[inline]\n    fn next_utf8(&mut self) -> Option<(char, &'i str)> {}\n}\n#[allow(clippy::result_unit_err)]\npub fn set_hostname(url: &mut Url, new_hostname: &str) -> Result<(), ()> {\n    if url.cannot_be_a_base() {\n        return Err(());\n    }\n    let input = Input::new_no_trim(new_hostname);\n    let scheme_type = SchemeType::from(url.scheme());\n    if scheme_type == SchemeType::File && new_hostname.is_empty() {\n        url.set_host_internal(Host::Domain(String::new()), None);\n        return Ok(());\n    }\n    if let Ok((host, _remaining)) = Parser::parse_host(input, scheme_type) {\n        if let Host::Domain(h) = &host {\n            if h.is_empty() {\n                if SchemeType::from(url.scheme()) == SchemeType::SpecialNotFile\n                    || !port(url).is_empty() || !url.username().is_empty()\n                    || !url.password().unwrap_or(\"\").is_empty()\n                {\n                    return Err(());\n                }\n            }\n        }\n        url.set_host_internal(host, None);\n        Ok(())\n    } else {\n        Err(())\n    }\n}\n#[inline]\npub fn port(url: &Url) -> &str {\n    &url[Position::BeforePort..Position::AfterPort]\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Setter for <https://url.spec.whatwg.org/#dom-url-hostname>\n203 pub fn set_hostname(url: &mut Url, new_hostname: &str) -> Result<(), ()> {\n204     if url.cannot_be_a_base() {\n205         return Err(());\n206     }\n207     // Host parsing rules are strict we don't want to trim the input\n208     let input = Input::new_no_trim(new_hostname);\n209     let scheme_type = SchemeType::from(url.scheme());\n210     if scheme_type == SchemeType::File && new_hostname.is_empty() {\n211         url.set_host_internal(Host::Domain(String::new()), None);\n212         return Ok(());\n213     }\n214 \n215     if let Ok((host, _remaining)) = Parser::parse_host(input, scheme_type) {\n216         if let Host::Domain(h) = &host {\n217             if h.is_empty() {\n218                 // Empty host on special not file url\n219                 if SchemeType::from(url.scheme()) == SchemeType::SpecialNotFile\n220                     // Port with an empty host\n221                     ||!port(url).is_empty()\n222                     // Empty host that includes credentials\n223                     || !url.username().is_empty()\n224                     || !url.password().unwrap_or(\"\").is_empty()\n225                 {\n226                     return Err(());\n227                 }\n228             }\n229         }\n230         url.set_host_internal(host, None);\n231         Ok(())\n232     } else {\n233         Err(())\n234     }\n235 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}