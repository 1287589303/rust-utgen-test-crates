{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// idna/src/deprecated.rs\n// crate name is idna\nuse alloc::borrow::Cow;\nuse alloc::string::String;\nuse crate::uts46::*;\nuse crate::Errors;\nfn map_transitional(domain: &str, transitional: bool) -> Cow<'_, str> {\n    if !transitional {\n        return Cow::Borrowed(domain);\n    }\n    let mut chars = domain.chars();\n    loop {\n        let prev = chars.clone();\n        if let Some(c) = chars.next() {\n            match c {\n                'ß' | 'ẞ' | 'ς' | '\\u{200C}' | '\\u{200D}' => {\n                    let mut s = String::with_capacity(domain.len());\n                    let tail = prev.as_str();\n                    let head = &domain[..domain.len() - tail.len()];\n                    s.push_str(head);\n                    for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }\n                    return Cow::Owned(s);\n                }\n                _ => {}\n            }\n        } else {\n            break;\n        }\n    }\n    Cow::Borrowed(domain)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Performs preprocessing equivalent to UTS 46 transitional processing\n/// if `transitional` is `true`. If `transitional` is `false`, merely\n/// lets the input pass through as-is (for call site convenience).\n///\n/// The output of this function is to be passed to [`Uts46::process`].\n25 fn map_transitional(domain: &str, transitional: bool) -> Cow<'_, str> {\n26     if !transitional {\n27         return Cow::Borrowed(domain);\n28     }\n29     let mut chars = domain.chars();\n30     loop {\n31         let prev = chars.clone();\n32         if let Some(c) = chars.next() {\n33             match c {\n34                 'ß' | 'ẞ' | 'ς' | '\\u{200C}' | '\\u{200D}' => {\n35                     let mut s = String::with_capacity(domain.len());\n36                     let tail = prev.as_str();\n37                     let head = &domain[..domain.len() - tail.len()];\n38                     s.push_str(head);\n39                     for c in tail.chars() {\n40                         match c {\n41                             'ß' | 'ẞ' => {\n42                                 s.push_str(\"ss\");\n43                             }\n44                             'ς' => {\n45                                 s.push('σ');\n46                             }\n47                             '\\u{200C}' | '\\u{200D}' => {}\n48                             _ => {\n49                                 s.push(c);\n50                             }\n51                         }\n52                     }\n53                     return Cow::Owned(s);\n54                 }\n55                 _ => {}\n56             }\n57         } else {\n58             break;\n59         }\n60     }\n61     Cow::Borrowed(domain)\n62 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}