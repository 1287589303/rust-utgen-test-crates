{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/quirks.rs\n// crate name is url\nuse crate::parser::{default_port, Context, Input, Parser, SchemeType};\nuse crate::{Host, ParseError, Position, Url};\nuse alloc::string::String;\nuse alloc::string::ToString;\n#[derive(Clone)]\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n    scheme_end: u32,\n    username_end: u32,\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,\n    query_start: Option<u32>,\n    fragment_start: Option<u32>,\n}\n#[derive(Clone, Debug)]\npub struct Input<'i> {\n    chars: str::Chars<'i>,\n}\n#[derive(PartialEq, Eq, Copy, Clone)]\npub enum Context {\n    UrlParser,\n    Setter,\n    PathSegmentSetter,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Clone, Debug, Eq, Ord, PartialOrd, Hash)]\npub enum Host<S = String> {\n    /// A DNS domain name, as '.' dot-separated labels.\n    /// Non-ASCII labels are encoded in punycode per IDNA if this is the host of\n    /// a special URL, or percent encoded for non-special URLs. Hosts for\n    /// non-special URLs are also called opaque hosts.\n    Domain(S),\n    /// An IPv4 address.\n    /// `Url::host_str` returns the serialization of this address,\n    /// as four decimal integers separated by `.` dots.\n    Ipv4(Ipv4Addr),\n    /// An IPv6 address.\n    /// `Url::host_str` returns the serialization of that address between `[` and `]` brackets,\n    /// in the format per [RFC 5952 *A Recommendation\n    /// for IPv6 Address Text Representation*](https://tools.ietf.org/html/rfc5952):\n    /// lowercase hexadecimal with maximal `::` compression.\n    Ipv6(Ipv6Addr),\n}\nimpl Url {\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {}\n    #[inline]\n    pub fn parse_with_params<I, K, V>(\n        input: &str,\n        iter: I,\n    ) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {}\n    fn strip_trailing_spaces_from_opaque_path(&mut self) {}\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {}\n    pub fn make_relative(&self, url: &Url) -> Option<String> {}\n    pub fn options<'a>() -> ParseOptions<'a> {}\n    #[inline]\n    pub fn as_str(&self) -> &str {}\n    #[inline]\n    #[deprecated(since = \"2.3.0\", note = \"use Into<String>\")]\n    pub fn into_string(self) -> String {}\n    pub fn check_invariants(&self) -> Result<(), String> {}\n    #[inline]\n    pub fn origin(&self) -> Origin {}\n    #[inline]\n    pub fn scheme(&self) -> &str {\n        self.slice(..self.scheme_end)\n    }\n    pub fn is_special(&self) -> bool {}\n    #[inline]\n    pub fn has_authority(&self) -> bool {}\n    pub fn authority(&self) -> &str {}\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {}\n    pub fn username(&self) -> &str {}\n    pub fn password(&self) -> Option<&str> {}\n    pub fn has_host(&self) -> bool {\n        !matches!(self.host, HostInternal::None)\n    }\n    pub fn host_str(&self) -> Option<&str> {}\n    pub fn host(&self) -> Option<Host<&str>> {\n        match self.host {\n            HostInternal::None => None,\n            HostInternal::Domain => {\n                Some(Host::Domain(self.slice(self.host_start..self.host_end)))\n            }\n            HostInternal::Ipv4(address) => Some(Host::Ipv4(address)),\n            HostInternal::Ipv6(address) => Some(Host::Ipv6(address)),\n        }\n    }\n    pub fn domain(&self) -> Option<&str> {}\n    #[inline]\n    pub fn port(&self) -> Option<u16> {}\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {}\n    #[cfg(feature = \"std\")]\n    #[cfg(\n        any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\")\n    )]\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<alloc::vec::Vec<SocketAddr>> {}\n    pub fn path(&self) -> &str {}\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {}\n    pub fn query(&self) -> Option<&str> {}\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {}\n    pub fn fragment(&self) -> Option<&str> {}\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {}\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {}\n    fn take_fragment(&mut self) -> Option<String> {}\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {}\n    pub fn set_query(&mut self, query: Option<&str>) {}\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {}\n    fn take_after_path(&mut self) -> String {}\n    pub fn set_path(&mut self, mut path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {}\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {}\n    fn set_port_internal(&mut self, port: Option<u16>) {\n        match (self.port, port) {\n            (None, None) => {}\n            (Some(_), None) => {\n                self.serialization\n                    .drain(self.host_end as usize..self.path_start as usize);\n                let offset = self.path_start - self.host_end;\n                self.path_start = self.host_end;\n                if let Some(ref mut index) = self.query_start {\n                    *index -= offset;\n                }\n                if let Some(ref mut index) = self.fragment_start {\n                    *index -= offset;\n                }\n            }\n            (Some(old), Some(new)) if old == new => {}\n            (_, Some(new)) => {\n                let path_and_after = self.slice(self.path_start..).to_owned();\n                self.serialization.truncate(self.host_end as usize);\n                write!(& mut self.serialization, \":{}\", new).unwrap();\n                let old_path_start = self.path_start;\n                let new_path_start = to_u32(self.serialization.len()).unwrap();\n                self.path_start = new_path_start;\n                let adjust = |index: &mut u32| {\n                    *index -= old_path_start;\n                    *index += new_path_start;\n                };\n                if let Some(ref mut index) = self.query_start {\n                    adjust(index)\n                }\n                if let Some(ref mut index) = self.fragment_start {\n                    adjust(index)\n                }\n                self.serialization.push_str(&path_and_after);\n            }\n        }\n        self.port = port;\n    }\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {}\n    fn set_host_internal(\n        &mut self,\n        host: Host<String>,\n        opt_new_port: Option<Option<u16>>,\n    ) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err, clippy::suspicious_operation_groupings)]\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(Error::custom)?\n        }\n        Ok(url)\n    }\n    #[inline]\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {}\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {}\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {}\n}\nimpl<'i> Input<'i> {\n    pub fn new_no_trim(input: &'i str) -> Self {\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_tab_and_newlines(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(ascii_tab_or_new_line);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_c0_control_and_space(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(c0_control_or_space);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    fn starts_with<P: Pattern>(&self, p: P) -> bool {}\n    #[inline]\n    pub fn split_prefix<P: Pattern>(&self, p: P) -> Option<Self> {\n        let mut remaining = self.clone();\n        if p.split_prefix(&mut remaining) { Some(remaining) } else { None }\n    }\n    #[inline]\n    fn split_first(&self) -> (Option<char>, Self) {\n        let mut remaining = self.clone();\n        (remaining.next(), remaining)\n    }\n    #[inline]\n    fn count_matching<F: Fn(char) -> bool>(&self, f: F) -> (u32, Self) {\n        let mut count = 0;\n        let mut remaining = self.clone();\n        loop {\n            let mut input = remaining.clone();\n            if matches!(input.next(), Some(c) if f(c)) {\n                remaining = input;\n                count += 1;\n            } else {\n                return (count, remaining);\n            }\n        }\n    }\n    #[inline]\n    fn next_utf8(&mut self) -> Option<(char, &'i str)> {}\n}\n#[allow(clippy::result_unit_err)]\npub fn set_port(url: &mut Url, new_port: &str) -> Result<(), ()> {\n    let result;\n    {\n        let scheme = url.scheme();\n        if !url.has_host() || url.host() == Some(Host::Domain(\"\")) || scheme == \"file\" {\n            return Err(());\n        }\n        result = Parser::parse_port(\n            Input::new_no_trim(new_port),\n            || default_port(scheme),\n            Context::Setter,\n        );\n    }\n    if let Ok((new_port, _remaining)) = result {\n        url.set_port_internal(new_port);\n        Ok(())\n    } else {\n        Err(())\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Setter for <https://url.spec.whatwg.org/#dom-url-port>\n245 pub fn set_port(url: &mut Url, new_port: &str) -> Result<(), ()> {\n246     let result;\n247     {\n248         // has_host implies !cannot_be_a_base\n249         let scheme = url.scheme();\n250         if !url.has_host() || url.host() == Some(Host::Domain(\"\")) || scheme == \"file\" {\n251             return Err(());\n252         }\n253         result = Parser::parse_port(\n254             Input::new_no_trim(new_port),\n255             || default_port(scheme),\n256             Context::Setter,\n257         )\n258     }\n259     if let Ok((new_port, _remaining)) = result {\n260         url.set_port_internal(new_port);\n261         Ok(())\n262     } else {\n263         Err(())\n264     }\n265 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}