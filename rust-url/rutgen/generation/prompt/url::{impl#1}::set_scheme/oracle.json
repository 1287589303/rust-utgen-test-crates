{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/lib.rs\n// crate name is url\npub use form_urlencoded;\nuse crate::host::HostInternal;\nuse crate::net::IpAddr;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse crate::net::{SocketAddr, ToSocketAddrs};\nuse crate::parser::{to_u32, Context, Parser, SchemeType, USERINFO};\nuse alloc::borrow::ToOwned;\nuse alloc::str;\nuse alloc::string::{String, ToString};\nuse core::borrow::Borrow;\nuse core::convert::TryFrom;\nuse core::fmt::Write;\nuse core::ops::{Range, RangeFrom, RangeTo};\nuse core::{cmp, fmt, hash, mem};\nuse percent_encoding::utf8_percent_encode;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse std::io;\n#[cfg(feature = \"std\")]\nuse std::path::{Path, PathBuf};\npub use crate::host::Host;\npub use crate::origin::{OpaqueOrigin, Origin};\npub use crate::parser::{ParseError, SyntaxViolation};\npub use crate::path_segments::PathSegmentsMut;\npub use crate::slicing::Position;\npub use form_urlencoded::EncodingOverride;\n#[derive(Clone)]\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n    scheme_end: u32,\n    username_end: u32,\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,\n    query_start: Option<u32>,\n    fragment_start: Option<u32>,\n}\n#[derive(Clone, Debug)]\npub struct Input<'i> {\n    chars: str::Chars<'i>,\n}\npub struct Parser<'a> {\n    pub serialization: String,\n    pub base_url: Option<&'a Url>,\n    pub query_encoding_override: EncodingOverride<'a>,\n    pub violation_fn: Option<&'a dyn Fn(SyntaxViolation)>,\n    pub context: Context,\n}\n#[derive(Copy, Clone, PartialEq, Eq)]\npub enum SchemeType {\n    File,\n    SpecialNotFile,\n    NotSpecial,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub(crate) enum HostInternal {\n    None,\n    Domain,\n    Ipv4(Ipv4Addr),\n    Ipv6(Ipv6Addr),\n}\nimpl Url {\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {}\n    #[inline]\n    pub fn parse_with_params<I, K, V>(\n        input: &str,\n        iter: I,\n    ) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {}\n    fn strip_trailing_spaces_from_opaque_path(&mut self) {}\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {}\n    pub fn make_relative(&self, url: &Url) -> Option<String> {}\n    pub fn options<'a>() -> ParseOptions<'a> {}\n    #[inline]\n    pub fn as_str(&self) -> &str {}\n    #[inline]\n    #[deprecated(since = \"2.3.0\", note = \"use Into<String>\")]\n    pub fn into_string(self) -> String {}\n    pub fn check_invariants(&self) -> Result<(), String> {}\n    #[inline]\n    pub fn origin(&self) -> Origin {}\n    #[inline]\n    pub fn scheme(&self) -> &str {\n        self.slice(..self.scheme_end)\n    }\n    pub fn is_special(&self) -> bool {}\n    #[inline]\n    pub fn has_authority(&self) -> bool {\n        debug_assert!(self.byte_at(self.scheme_end) == b':');\n        self.slice(self.scheme_end..).starts_with(\"://\")\n    }\n    pub fn authority(&self) -> &str {}\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {}\n    pub fn username(&self) -> &str {}\n    pub fn password(&self) -> Option<&str> {}\n    pub fn has_host(&self) -> bool {\n        !matches!(self.host, HostInternal::None)\n    }\n    pub fn host_str(&self) -> Option<&str> {}\n    pub fn host(&self) -> Option<Host<&str>> {}\n    pub fn domain(&self) -> Option<&str> {}\n    #[inline]\n    pub fn port(&self) -> Option<u16> {\n        self.port\n    }\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {}\n    #[cfg(feature = \"std\")]\n    #[cfg(\n        any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\")\n    )]\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<alloc::vec::Vec<SocketAddr>> {}\n    pub fn path(&self) -> &str {}\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {}\n    pub fn query(&self) -> Option<&str> {}\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {}\n    pub fn fragment(&self) -> Option<&str> {}\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {}\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {}\n    fn take_fragment(&mut self) -> Option<String> {}\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {}\n    pub fn set_query(&mut self, query: Option<&str>) {}\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {}\n    fn take_after_path(&mut self) -> String {}\n    pub fn set_path(&mut self, mut path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {}\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\"))\n            || self.scheme() == \"file\"\n        {\n            return Err(());\n        }\n        if port.is_some() && port == parser::default_port(self.scheme()) {\n            port = None;\n        }\n        self.set_port_internal(port);\n        Ok(())\n    }\n    fn set_port_internal(&mut self, port: Option<u16>) {}\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {}\n    fn set_host_internal(\n        &mut self,\n        host: Host<String>,\n        opt_new_port: Option<Option<u16>>,\n    ) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err, clippy::suspicious_operation_groupings)]\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {\n        let mut parser = Parser::for_setter(String::new());\n        let remaining = parser.parse_scheme(parser::Input::new_no_trim(scheme))?;\n        let new_scheme_type = SchemeType::from(&parser.serialization);\n        let old_scheme_type = SchemeType::from(self.scheme());\n        if (new_scheme_type.is_special() && !old_scheme_type.is_special())\n            || (!new_scheme_type.is_special() && old_scheme_type.is_special())\n            || (new_scheme_type.is_file() && self.has_authority())\n        {\n            return Err(());\n        }\n        if !remaining.is_empty() || (!self.has_host() && new_scheme_type.is_special()) {\n            return Err(());\n        }\n        let old_scheme_end = self.scheme_end;\n        let new_scheme_end = to_u32(parser.serialization.len()).unwrap();\n        let adjust = |index: &mut u32| {\n            *index -= old_scheme_end;\n            *index += new_scheme_end;\n        };\n        self.scheme_end = new_scheme_end;\n        adjust(&mut self.username_end);\n        adjust(&mut self.host_start);\n        adjust(&mut self.host_end);\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n        parser.serialization.push_str(self.slice(old_scheme_end..));\n        self.serialization = parser.serialization;\n        let previous_port = self.port();\n        let _ = self.set_port(previous_port);\n        Ok(())\n    }\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(Error::custom)?\n        }\n        Ok(url)\n    }\n    #[inline]\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {}\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {}\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {}\n}\nimpl<'i> Input<'i> {\n    pub fn new_no_trim(input: &'i str) -> Self {\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_tab_and_newlines(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(ascii_tab_or_new_line);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    pub fn new_trim_c0_control_and_space(\n        original_input: &'i str,\n        vfn: Option<&dyn Fn(SyntaxViolation)>,\n    ) -> Self {\n        let input = original_input.trim_matches(c0_control_or_space);\n        if let Some(vfn) = vfn {\n            if input.len() < original_input.len() {\n                vfn(SyntaxViolation::C0SpaceIgnored)\n            }\n            if input.chars().any(ascii_tab_or_new_line) {\n                vfn(SyntaxViolation::TabOrNewlineIgnored)\n            }\n        }\n        Input { chars: input.chars() }\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.clone().next().is_none()\n    }\n    #[inline]\n    fn starts_with<P: Pattern>(&self, p: P) -> bool {}\n    #[inline]\n    pub fn split_prefix<P: Pattern>(&self, p: P) -> Option<Self> {\n        let mut remaining = self.clone();\n        if p.split_prefix(&mut remaining) { Some(remaining) } else { None }\n    }\n    #[inline]\n    fn split_first(&self) -> (Option<char>, Self) {\n        let mut remaining = self.clone();\n        (remaining.next(), remaining)\n    }\n    #[inline]\n    fn count_matching<F: Fn(char) -> bool>(&self, f: F) -> (u32, Self) {\n        let mut count = 0;\n        let mut remaining = self.clone();\n        loop {\n            let mut input = remaining.clone();\n            if matches!(input.next(), Some(c) if f(c)) {\n                remaining = input;\n                count += 1;\n            } else {\n                return (count, remaining);\n            }\n        }\n    }\n    #[inline]\n    fn next_utf8(&mut self) -> Option<(char, &'i str)> {}\n}\nimpl SchemeType {\n    pub fn is_special(&self) -> bool {\n        !matches!(* self, SchemeType::NotSpecial)\n    }\n    pub fn is_file(&self) -> bool {\n        matches!(* self, SchemeType::File)\n    }\n}\nimpl<'a> Parser<'a> {\n    fn log_violation(&self, v: SyntaxViolation) {}\n    fn log_violation_if(&self, v: SyntaxViolation, test: impl FnOnce() -> bool) {}\n    pub fn for_setter(serialization: String) -> Parser<'a> {\n        Parser {\n            serialization,\n            base_url: None,\n            query_encoding_override: None,\n            violation_fn: None,\n            context: Context::Setter,\n        }\n    }\n    pub fn parse_url(mut self, input: &str) -> ParseResult<Url> {}\n    pub fn parse_scheme<'i>(&mut self, mut input: Input<'i>) -> Result<Input<'i>, ()> {\n        if !input.starts_with(ascii_alpha) {\n            return Err(());\n        }\n        debug_assert!(self.serialization.is_empty());\n        while let Some(c) = input.next() {\n            match c {\n                'a'..='z' | '0'..='9' | '+' | '-' | '.' => self.serialization.push(c),\n                'A'..='Z' => self.serialization.push(c.to_ascii_lowercase()),\n                ':' => return Ok(input),\n                _ => {\n                    self.serialization.clear();\n                    return Err(());\n                }\n            }\n        }\n        if self.context == Context::Setter {\n            Ok(input)\n        } else {\n            self.serialization.clear();\n            Err(())\n        }\n    }\n    fn parse_with_scheme(mut self, input: Input<'_>) -> ParseResult<Url> {}\n    fn parse_non_special(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {}\n    fn parse_file(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_file_url: Option<&Url>,\n    ) -> ParseResult<Url> {}\n    fn parse_relative(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        base_url: &Url,\n    ) -> ParseResult<Url> {}\n    fn after_double_slash(\n        mut self,\n        input: Input<'_>,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n    ) -> ParseResult<Url> {}\n    fn parse_userinfo<'i>(\n        &mut self,\n        mut input: Input<'i>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, Input<'i>)> {}\n    fn parse_host_and_port<'i>(\n        &mut self,\n        input: Input<'i>,\n        scheme_end: u32,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(u32, HostInternal, Option<u16>, Input<'i>)> {}\n    pub fn parse_host(\n        mut input: Input<'_>,\n        scheme_type: SchemeType,\n    ) -> ParseResult<(Host<String>, Input<'_>)> {}\n    fn get_file_host(input: Input<'_>) -> ParseResult<(Host<String>, Input<'_>)> {}\n    fn parse_file_host<'i>(\n        &mut self,\n        input: Input<'i>,\n    ) -> ParseResult<(bool, HostInternal, Input<'i>)> {}\n    pub fn file_host(input: Input) -> ParseResult<(bool, String, Input)> {}\n    pub fn parse_port<P>(\n        mut input: Input<'_>,\n        default_port: P,\n        context: Context,\n    ) -> ParseResult<(Option<u16>, Input<'_>)>\n    where\n        P: Fn() -> Option<u16>,\n    {}\n    pub fn parse_path_start<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        input: Input<'i>,\n    ) -> Input<'i> {}\n    pub fn parse_path<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        has_host: &mut bool,\n        path_start: usize,\n        mut input: Input<'i>,\n    ) -> Input<'i> {}\n    fn last_slash_can_be_removed(serialization: &str, path_start: usize) -> bool {}\n    fn shorten_path(&mut self, scheme_type: SchemeType, path_start: usize) {}\n    fn pop_path(&mut self, scheme_type: SchemeType, path_start: usize) {}\n    pub fn parse_cannot_be_a_base_path<'i>(\n        &mut self,\n        mut input: Input<'i>,\n    ) -> Input<'i> {}\n    #[allow(clippy::too_many_arguments)]\n    fn with_query_and_fragment(\n        mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        username_end: u32,\n        host_start: u32,\n        host_end: u32,\n        host: HostInternal,\n        port: Option<u16>,\n        mut path_start: u32,\n        remaining: Input<'_>,\n    ) -> ParseResult<Url> {}\n    fn parse_query_and_fragment(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        mut input: Input<'_>,\n    ) -> ParseResult<(Option<u32>, Option<u32>)> {}\n    pub fn parse_query<'i>(\n        &mut self,\n        scheme_type: SchemeType,\n        scheme_end: u32,\n        input: Input<'i>,\n    ) -> Option<Input<'i>> {}\n    fn fragment_only(\n        mut self,\n        base_url: &Url,\n        mut input: Input<'_>,\n    ) -> ParseResult<Url> {}\n    pub fn parse_fragment(&mut self, input: Input<'_>) {}\n    #[inline]\n    fn check_url_code_point(&self, c: char, input: &Input<'_>) {}\n}\n#[inline]\npub fn to_u32(i: usize) -> ParseResult<u32> {\n    if i <= u32::MAX as usize { Ok(i as u32) } else { Err(ParseError::Overflow) }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Change this URL’s scheme.\n///\n/// Do nothing and return `Err` under the following circumstances:\n///\n/// * If the new scheme is not in `[a-zA-Z][a-zA-Z0-9+.-]+`\n/// * If this URL is cannot-be-a-base and the new scheme is one of\n///   `http`, `https`, `ws`, `wss` or `ftp`\n/// * If either the old or new scheme is `http`, `https`, `ws`,\n///   `wss` or `ftp` and the other is not one of these\n/// * If the new scheme is `file` and this URL includes credentials\n///   or has a non-null port\n/// * If this URL's scheme is `file` and its host is empty or null\n///\n/// See also [the URL specification's section on legal scheme state\n/// overrides](https://url.spec.whatwg.org/#scheme-state).\n///\n/// # Examples\n///\n/// Change the URL’s scheme from `https` to `http`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_scheme(\"http\");\n/// assert_eq!(url.as_str(), \"http://example.net/\");\n/// assert!(result.is_ok());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n/// Change the URL’s scheme from `foo` to `bar`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"foo://example.net\")?;\n/// let result = url.set_scheme(\"bar\");\n/// assert_eq!(url.as_str(), \"bar://example.net\");\n/// assert!(result.is_ok());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot change URL’s scheme from `https` to `foõ`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"https://example.net\")?;\n/// let result = url.set_scheme(\"foõ\");\n/// assert_eq!(url.as_str(), \"https://example.net/\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Cannot change URL’s scheme from `mailto` (cannot-be-a-base) to `https`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rms@example.net\")?;\n/// let result = url.set_scheme(\"https\");\n/// assert_eq!(url.as_str(), \"mailto:rms@example.net\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n/// Cannot change the URL’s scheme from `foo` to `https`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"foo://example.net\")?;\n/// let result = url.set_scheme(\"https\");\n/// assert_eq!(url.as_str(), \"foo://example.net\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n/// Cannot change the URL’s scheme from `http` to `foo`:\n///\n/// ```\n/// use url::Url;\n/// # use url::ParseError;\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"http://example.net\")?;\n/// let result = url.set_scheme(\"foo\");\n/// assert_eq!(url.as_str(), \"http://example.net/\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n2449 pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {\n2450     let mut parser = Parser::for_setter(String::new());\n2451     let remaining = parser.parse_scheme(parser::Input::new_no_trim(scheme))?;\n2452     let new_scheme_type = SchemeType::from(&parser.serialization);\n2453     let old_scheme_type = SchemeType::from(self.scheme());\n2454     // If url’s scheme is a special scheme and buffer is not a special scheme, then return.\n2455     if (new_scheme_type.is_special() && !old_scheme_type.is_special()) ||\n2456         // If url’s scheme is not a special scheme and buffer is a special scheme, then return.\n2457         (!new_scheme_type.is_special() && old_scheme_type.is_special()) ||\n2458         // If url includes credentials or has a non-null port, and buffer is \"file\", then return.\n2459         // If url’s scheme is \"file\" and its host is an empty host or null, then return.\n2460         (new_scheme_type.is_file() && self.has_authority())\n2461     {\n2462         return Err(());\n2463     }\n2464 \n2465     if !remaining.is_empty() || (!self.has_host() && new_scheme_type.is_special()) {\n2466         return Err(());\n2467     }\n2468     let old_scheme_end = self.scheme_end;\n2469     let new_scheme_end = to_u32(parser.serialization.len()).unwrap();\n2470     let adjust = |index: &mut u32| {\n2471         *index -= old_scheme_end;\n2472         *index += new_scheme_end;\n2473     };\n2474 \n2475     self.scheme_end = new_scheme_end;\n2476     adjust(&mut self.username_end);\n2477     adjust(&mut self.host_start);\n2478     adjust(&mut self.host_end);\n2479     adjust(&mut self.path_start);\n2480     if let Some(ref mut index) = self.query_start {\n2481         adjust(index)\n2482     }\n2483     if let Some(ref mut index) = self.fragment_start {\n2484         adjust(index)\n2485     }\n2486 \n2487     parser.serialization.push_str(self.slice(old_scheme_end..));\n2488     self.serialization = parser.serialization;\n2489 \n2490     // Update the port so it can be removed\n2491     // If it is the scheme's default\n2492     // we don't mind it silently failing\n2493     // if there was no port in the first place\n2494     let previous_port = self.port();\n2495     let _ = self.set_port(previous_port);\n2496 \n2497     Ok(())\n2498 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}