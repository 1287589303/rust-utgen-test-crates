{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/lib.rs\n// crate name is url\npub use form_urlencoded;\nuse crate::host::HostInternal;\nuse crate::net::IpAddr;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse crate::net::{SocketAddr, ToSocketAddrs};\nuse crate::parser::{to_u32, Context, Parser, SchemeType, USERINFO};\nuse alloc::borrow::ToOwned;\nuse alloc::str;\nuse alloc::string::{String, ToString};\nuse core::borrow::Borrow;\nuse core::convert::TryFrom;\nuse core::fmt::Write;\nuse core::ops::{Range, RangeFrom, RangeTo};\nuse core::{cmp, fmt, hash, mem};\nuse percent_encoding::utf8_percent_encode;\n#[cfg(feature = \"std\")]\n#[cfg(any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\"))]\nuse std::io;\n#[cfg(feature = \"std\")]\nuse std::path::{Path, PathBuf};\npub use crate::host::Host;\npub use crate::origin::{OpaqueOrigin, Origin};\npub use crate::parser::{ParseError, SyntaxViolation};\npub use crate::path_segments::PathSegmentsMut;\npub use crate::slicing::Position;\npub use form_urlencoded::EncodingOverride;\n#[derive(Clone)]\npub struct Url {\n    /// Syntax in pseudo-BNF:\n    ///\n    ///   url = scheme \":\" [ hierarchical | non-hierarchical ] [ \"?\" query ]? [ \"#\" fragment ]?\n    ///   non-hierarchical = non-hierarchical-path\n    ///   non-hierarchical-path = /* Does not start with \"/\" */\n    ///   hierarchical = authority? hierarchical-path\n    ///   authority = \"//\" userinfo? host [ \":\" port ]?\n    ///   userinfo = username [ \":\" password ]? \"@\"\n    ///   hierarchical-path = [ \"/\" path-segment ]+\n    serialization: String,\n    scheme_end: u32,\n    username_end: u32,\n    host_start: u32,\n    host_end: u32,\n    host: HostInternal,\n    port: Option<u16>,\n    path_start: u32,\n    query_start: Option<u32>,\n    fragment_start: Option<u32>,\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Clone, Debug, Eq, Ord, PartialOrd, Hash)]\npub enum Host<S = String> {\n    /// A DNS domain name, as '.' dot-separated labels.\n    /// Non-ASCII labels are encoded in punycode per IDNA if this is the host of\n    /// a special URL, or percent encoded for non-special URLs. Hosts for\n    /// non-special URLs are also called opaque hosts.\n    Domain(S),\n    /// An IPv4 address.\n    /// `Url::host_str` returns the serialization of this address,\n    /// as four decimal integers separated by `.` dots.\n    Ipv4(Ipv4Addr),\n    /// An IPv6 address.\n    /// `Url::host_str` returns the serialization of that address between `[` and `]` brackets,\n    /// in the format per [RFC 5952 *A Recommendation\n    /// for IPv6 Address Text Representation*](https://tools.ietf.org/html/rfc5952):\n    /// lowercase hexadecimal with maximal `::` compression.\n    Ipv6(Ipv6Addr),\n}\n#[cfg_attr(feature = \"serde\", derive(Deserialize, Serialize))]\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub(crate) enum HostInternal {\n    None,\n    Domain,\n    Ipv4(Ipv4Addr),\n    Ipv6(Ipv6Addr),\n}\nimpl Url {\n    #[inline]\n    pub fn parse(input: &str) -> Result<Url, crate::ParseError> {}\n    #[inline]\n    pub fn parse_with_params<I, K, V>(\n        input: &str,\n        iter: I,\n    ) -> Result<Url, crate::ParseError>\n    where\n        I: IntoIterator,\n        I::Item: Borrow<(K, V)>,\n        K: AsRef<str>,\n        V: AsRef<str>,\n    {}\n    fn strip_trailing_spaces_from_opaque_path(&mut self) {}\n    #[inline]\n    pub fn join(&self, input: &str) -> Result<Url, crate::ParseError> {}\n    pub fn make_relative(&self, url: &Url) -> Option<String> {}\n    pub fn options<'a>() -> ParseOptions<'a> {}\n    #[inline]\n    pub fn as_str(&self) -> &str {}\n    #[inline]\n    #[deprecated(since = \"2.3.0\", note = \"use Into<String>\")]\n    pub fn into_string(self) -> String {}\n    pub fn check_invariants(&self) -> Result<(), String> {}\n    #[inline]\n    pub fn origin(&self) -> Origin {}\n    #[inline]\n    pub fn scheme(&self) -> &str {\n        self.slice(..self.scheme_end)\n    }\n    pub fn is_special(&self) -> bool {}\n    #[inline]\n    pub fn has_authority(&self) -> bool {}\n    pub fn authority(&self) -> &str {}\n    #[inline]\n    pub fn cannot_be_a_base(&self) -> bool {}\n    pub fn username(&self) -> &str {}\n    pub fn password(&self) -> Option<&str> {}\n    pub fn has_host(&self) -> bool {\n        !matches!(self.host, HostInternal::None)\n    }\n    pub fn host_str(&self) -> Option<&str> {}\n    pub fn host(&self) -> Option<Host<&str>> {\n        match self.host {\n            HostInternal::None => None,\n            HostInternal::Domain => {\n                Some(Host::Domain(self.slice(self.host_start..self.host_end)))\n            }\n            HostInternal::Ipv4(address) => Some(Host::Ipv4(address)),\n            HostInternal::Ipv6(address) => Some(Host::Ipv6(address)),\n        }\n    }\n    pub fn domain(&self) -> Option<&str> {}\n    #[inline]\n    pub fn port(&self) -> Option<u16> {}\n    #[inline]\n    pub fn port_or_known_default(&self) -> Option<u16> {}\n    #[cfg(feature = \"std\")]\n    #[cfg(\n        any(unix, windows, target_os = \"redox\", target_os = \"wasi\", target_os = \"hermit\")\n    )]\n    pub fn socket_addrs(\n        &self,\n        default_port_number: impl Fn() -> Option<u16>,\n    ) -> io::Result<alloc::vec::Vec<SocketAddr>> {}\n    pub fn path(&self) -> &str {}\n    pub fn path_segments(&self) -> Option<str::Split<'_, char>> {}\n    pub fn query(&self) -> Option<&str> {}\n    #[inline]\n    pub fn query_pairs(&self) -> form_urlencoded::Parse<'_> {}\n    pub fn fragment(&self) -> Option<&str> {}\n    fn mutate<F: FnOnce(&mut Parser<'_>) -> R, R>(&mut self, f: F) -> R {}\n    pub fn set_fragment(&mut self, fragment: Option<&str>) {}\n    fn take_fragment(&mut self) -> Option<String> {}\n    fn restore_already_parsed_fragment(&mut self, fragment: Option<String>) {}\n    pub fn set_query(&mut self, query: Option<&str>) {}\n    pub fn query_pairs_mut(&mut self) -> form_urlencoded::Serializer<'_, UrlQuery<'_>> {}\n    fn take_after_path(&mut self) -> String {}\n    pub fn set_path(&mut self, mut path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn path_segments_mut(&mut self) -> Result<PathSegmentsMut<'_>, ()> {}\n    fn restore_after_path(&mut self, old_after_path_position: u32, after_path: &str) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_port(&mut self, mut port: Option<u16>) -> Result<(), ()> {}\n    fn set_port_internal(&mut self, port: Option<u16>) {}\n    pub fn set_host(&mut self, host: Option<&str>) -> Result<(), ParseError> {}\n    fn set_host_internal(\n        &mut self,\n        host: Host<String>,\n        opt_new_port: Option<Option<u16>>,\n    ) {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_ip_host(&mut self, address: IpAddr) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_password(&mut self, password: Option<&str>) -> Result<(), ()> {}\n    #[allow(clippy::result_unit_err)]\n    pub fn set_username(&mut self, username: &str) -> Result<(), ()> {\n        if !self.has_host() || self.host() == Some(Host::Domain(\"\"))\n            || self.scheme() == \"file\"\n        {\n            return Err(());\n        }\n        let username_start = self.scheme_end + 3;\n        debug_assert!(self.slice(self.scheme_end..username_start) == \"://\");\n        if self.slice(username_start..self.username_end) == username {\n            return Ok(());\n        }\n        let after_username = self.slice(self.username_end..).to_owned();\n        self.serialization.truncate(username_start as usize);\n        self.serialization.extend(utf8_percent_encode(username, USERINFO));\n        let mut removed_bytes = self.username_end;\n        self.username_end = to_u32(self.serialization.len()).unwrap();\n        let mut added_bytes = self.username_end;\n        let new_username_is_empty = self.username_end == username_start;\n        match (new_username_is_empty, after_username.chars().next()) {\n            (true, Some('@')) => {\n                removed_bytes += 1;\n                self.serialization.push_str(&after_username[1..]);\n            }\n            (false, Some('@')) | (_, Some(':')) | (true, _) => {\n                self.serialization.push_str(&after_username);\n            }\n            (false, _) => {\n                added_bytes += 1;\n                self.serialization.push('@');\n                self.serialization.push_str(&after_username);\n            }\n        }\n        let adjust = |index: &mut u32| {\n            *index -= removed_bytes;\n            *index += added_bytes;\n        };\n        adjust(&mut self.host_start);\n        adjust(&mut self.host_end);\n        adjust(&mut self.path_start);\n        if let Some(ref mut index) = self.query_start {\n            adjust(index)\n        }\n        if let Some(ref mut index) = self.fragment_start {\n            adjust(index)\n        }\n        Ok(())\n    }\n    #[allow(clippy::result_unit_err, clippy::suspicious_operation_groupings)]\n    pub fn set_scheme(&mut self, scheme: &str) -> Result<(), ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_file_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn from_directory_path<P: AsRef<std::path::Path>>(path: P) -> Result<Url, ()> {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn serialize_internal<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {}\n    #[cfg(feature = \"serde\")]\n    #[deny(unused)]\n    pub fn deserialize_internal<'de, D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::{Deserialize, Error};\n        let (\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        ) = Deserialize::deserialize(deserializer)?;\n        let url = Url {\n            serialization,\n            scheme_end,\n            username_end,\n            host_start,\n            host_end,\n            host,\n            port,\n            path_start,\n            query_start,\n            fragment_start,\n        };\n        if cfg!(debug_assertions) {\n            url.check_invariants().map_err(Error::custom)?\n        }\n        Ok(url)\n    }\n    #[inline]\n    #[cfg(\n        all(\n            feature = \"std\",\n            any(\n                unix,\n                windows,\n                target_os = \"redox\",\n                target_os = \"wasi\",\n                target_os = \"hermit\"\n            )\n        )\n    )]\n    #[allow(clippy::result_unit_err)]\n    pub fn to_file_path(&self) -> Result<PathBuf, ()> {}\n    #[inline]\n    fn slice<R>(&self, range: R) -> &str\n    where\n        R: RangeArg,\n    {}\n    #[inline]\n    fn byte_at(&self, i: u32) -> u8 {}\n}\n#[inline]\npub fn to_u32(i: usize) -> ParseResult<u32> {\n    if i <= u32::MAX as usize { Ok(i as u32) } else { Err(ParseError::Overflow) }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Change this URLâ€™s username.\n///\n/// If this URL is cannot-be-a-base or does not have a host, do nothing and return `Err`.\n/// # Examples\n///\n/// Cannot setup username from mailto(cannot-be-base)\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"mailto:rmz@example.com\")?;\n/// let result = url.set_username(\"user1\");\n/// assert_eq!(url.as_str(), \"mailto:rmz@example.com\");\n/// assert!(result.is_err());\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n///\n/// Setup username to user1\n///\n/// ```rust\n/// use url::{Url, ParseError};\n///\n/// # fn run() -> Result<(), ParseError> {\n/// let mut url = Url::parse(\"ftp://:secre1@example.com/\")?;\n/// let result = url.set_username(\"user1\");\n/// assert!(result.is_ok());\n/// assert_eq!(url.username(), \"user1\");\n/// assert_eq!(url.as_str(), \"ftp://user1:secre1@example.com/\");\n/// # Ok(())\n/// # }\n/// # run().unwrap();\n/// ```\n2287 pub fn set_username(&mut self, username: &str) -> Result<(), ()> {\n2288     // has_host implies !cannot_be_a_base\n2289     if !self.has_host() || self.host() == Some(Host::Domain(\"\")) || self.scheme() == \"file\" {\n2290         return Err(());\n2291     }\n2292     let username_start = self.scheme_end + 3;\n2293     debug_assert!(self.slice(self.scheme_end..username_start) == \"://\");\n2294     if self.slice(username_start..self.username_end) == username {\n2295         return Ok(());\n2296     }\n2297     let after_username = self.slice(self.username_end..).to_owned();\n2298     self.serialization.truncate(username_start as usize);\n2299     self.serialization\n2300         .extend(utf8_percent_encode(username, USERINFO));\n2301 \n2302     let mut removed_bytes = self.username_end;\n2303     self.username_end = to_u32(self.serialization.len()).unwrap();\n2304     let mut added_bytes = self.username_end;\n2305 \n2306     let new_username_is_empty = self.username_end == username_start;\n2307     match (new_username_is_empty, after_username.chars().next()) {\n2308         (true, Some('@')) => {\n2309             removed_bytes += 1;\n2310             self.serialization.push_str(&after_username[1..]);\n2311         }\n2312         (false, Some('@')) | (_, Some(':')) | (true, _) => {\n2313             self.serialization.push_str(&after_username);\n2314         }\n2315         (false, _) => {\n2316             added_bytes += 1;\n2317             self.serialization.push('@');\n2318             self.serialization.push_str(&after_username);\n2319         }\n2320     }\n2321 \n2322     let adjust = |index: &mut u32| {\n2323         *index -= removed_bytes;\n2324         *index += added_bytes;\n2325     };\n2326     adjust(&mut self.host_start);\n2327     adjust(&mut self.host_end);\n2328     adjust(&mut self.path_start);\n2329     if let Some(ref mut index) = self.query_start {\n2330         adjust(index)\n2331     }\n2332     if let Some(ref mut index) = self.fragment_start {\n2333         adjust(index)\n2334     }\n2335     Ok(())\n2336 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}