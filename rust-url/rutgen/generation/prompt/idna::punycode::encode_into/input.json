{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// idna/src/punycode.rs\n// crate name is idna\nuse alloc::{string::String, vec::Vec};\nuse core::char;\nuse core::fmt::Write;\nuse core::marker::PhantomData;\nconst BASE: u32 = 36;\nconst T_MIN: u32 = 1;\nconst T_MAX: u32 = 26;\nconst SKEW: u32 = 38;\nconst DAMP: u32 = 700;\nconst INITIAL_BIAS: u32 = 72;\nconst INITIAL_N: u32 = 0x80;\npub(crate) enum PunycodeEncodeError {\n    Overflow,\n    Sink,\n}\npub(crate) fn encode_into<I, W, C>(\n    input: I,\n    output: &mut W,\n) -> Result<(), PunycodeEncodeError>\nwhere\n    I: Iterator<Item = char> + Clone,\n    W: Write + ?Sized,\n    C: PunycodeCaller,\n{\n    let (mut input_length, mut basic_length) = (0u32, 0);\n    for c in input.clone() {\n        input_length = input_length.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n        if c.is_ascii() {\n            output.write_char(c)?;\n            basic_length += 1;\n        }\n    }\n    if !C::EXTERNAL_CALLER {\n        let len_plus_one = input_length\n            .checked_add(1)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n        len_plus_one\n            .checked_mul(u32::from(char::MAX) - INITIAL_N)\n            .ok_or(PunycodeEncodeError::Overflow)?;\n    }\n    if basic_length > 0 {\n        output.write_char('-')?;\n    }\n    let mut code_point = INITIAL_N;\n    let mut delta = 0u32;\n    let mut bias = INITIAL_BIAS;\n    let mut processed = basic_length;\n    while processed < input_length {\n        let min_code_point = input\n            .clone()\n            .map(|c| c as u32)\n            .filter(|&c| c >= code_point)\n            .min()\n            .unwrap();\n        if C::EXTERNAL_CALLER {\n            let product = (min_code_point - code_point)\n                .checked_mul(processed + 1)\n                .ok_or(PunycodeEncodeError::Overflow)?;\n            delta = delta.checked_add(product).ok_or(PunycodeEncodeError::Overflow)?;\n        } else {\n            delta += (min_code_point - code_point) * (processed + 1);\n        }\n        code_point = min_code_point;\n        for c in input.clone() {\n            let c = c as u32;\n            if c < code_point {\n                if C::EXTERNAL_CALLER {\n                    delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n                } else {\n                    delta += 1;\n                }\n            }\n            if c == code_point {\n                let mut q = delta;\n                let mut k = BASE;\n                loop {\n                    let t = if k <= bias {\n                        T_MIN\n                    } else if k >= bias + T_MAX {\n                        T_MAX\n                    } else {\n                        k - bias\n                    };\n                    if q < t {\n                        break;\n                    }\n                    let value = t + ((q - t) % (BASE - t));\n                    output.write_char(value_to_digit(value))?;\n                    q = (q - t) / (BASE - t);\n                    k += BASE;\n                }\n                output.write_char(value_to_digit(q))?;\n                bias = adapt(delta, processed + 1, processed == basic_length);\n                delta = 0;\n                processed += 1;\n            }\n        }\n        delta += 1;\n        code_point += 1;\n    }\n    Ok(())\n}\n#[inline]\nfn adapt(mut delta: u32, num_points: u32, first_time: bool) -> u32 {\n    delta /= if first_time { DAMP } else { 2 };\n    delta += delta / num_points;\n    let mut k = 0;\n    while delta > ((BASE - T_MIN) * T_MAX) / 2 {\n        delta /= BASE - T_MIN;\n        k += BASE;\n    }\n    k + (((BASE - T_MIN + 1) * delta) / (delta + SKEW))\n}\n#[inline]\nfn value_to_digit(value: u32) -> char {\n    match value {\n        0..=25 => (value as u8 + b'a') as char,\n        26..=35 => (value as u8 - 26 + b'0') as char,\n        _ => panic!(),\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n357 pub(crate) fn encode_into<I, W, C>(input: I, output: &mut W) -> Result<(), PunycodeEncodeError>\n358 where\n359     I: Iterator<Item = char> + Clone,\n360     W: Write + ?Sized,\n361     C: PunycodeCaller,\n362 {\n363     // Handle \"basic\" (ASCII) code points. They are encoded as-is.\n364     let (mut input_length, mut basic_length) = (0u32, 0);\n365     for c in input.clone() {\n366         input_length = input_length\n367             .checked_add(1)\n368             .ok_or(PunycodeEncodeError::Overflow)?;\n369         if c.is_ascii() {\n370             output.write_char(c)?;\n371             basic_length += 1;\n372         }\n373     }\n374 \n375     if !C::EXTERNAL_CALLER {\n376         // We should never get an overflow here with the internal caller being\n377         // length-limited, but let's check anyway once here trusting the math\n378         // from  RFC 3492 section 6.4 and then omit the overflow checks in the\n379         // loop below.\n380         let len_plus_one = input_length\n381             .checked_add(1)\n382             .ok_or(PunycodeEncodeError::Overflow)?;\n383         len_plus_one\n384             .checked_mul(u32::from(char::MAX) - INITIAL_N)\n385             .ok_or(PunycodeEncodeError::Overflow)?;\n386     }\n387 \n388     if basic_length > 0 {\n389         output.write_char('-')?;\n390     }\n391     let mut code_point = INITIAL_N;\n392     let mut delta = 0u32;\n393     let mut bias = INITIAL_BIAS;\n394     let mut processed = basic_length;\n395     while processed < input_length {\n396         // All code points < code_point have been handled already.\n397         // Find the next larger one.\n398         let min_code_point = input\n399             .clone()\n400             .map(|c| c as u32)\n401             .filter(|&c| c >= code_point)\n402             .min()\n403             .unwrap();\n404         // Increase delta to advance the decoderâ€™s <code_point,i> state to <min_code_point,0>\n405         if C::EXTERNAL_CALLER {\n406             let product = (min_code_point - code_point)\n407                 .checked_mul(processed + 1)\n408                 .ok_or(PunycodeEncodeError::Overflow)?;\n409             delta = delta\n410                 .checked_add(product)\n411                 .ok_or(PunycodeEncodeError::Overflow)?;\n412         } else {\n413             delta += (min_code_point - code_point) * (processed + 1);\n414         }\n415         code_point = min_code_point;\n416         for c in input.clone() {\n417             let c = c as u32;\n418             if c < code_point {\n419                 if C::EXTERNAL_CALLER {\n420                     delta = delta.checked_add(1).ok_or(PunycodeEncodeError::Overflow)?;\n421                 } else {\n422                     delta += 1;\n423                 }\n424             }\n425             if c == code_point {\n426                 // Represent delta as a generalized variable-length integer:\n427                 let mut q = delta;\n428                 let mut k = BASE;\n429                 loop {\n430                     let t = if k <= bias {\n431                         T_MIN\n432                     } else if k >= bias + T_MAX {\n433                         T_MAX\n434                     } else {\n435                         k - bias\n436                     };\n437                     if q < t {\n438                         break;\n439                     }\n440                     let value = t + ((q - t) % (BASE - t));\n441                     output.write_char(value_to_digit(value))?;\n442                     q = (q - t) / (BASE - t);\n443                     k += BASE;\n444                 }\n445                 output.write_char(value_to_digit(q))?;\n446                 bias = adapt(delta, processed + 1, processed == basic_length);\n447                 delta = 0;\n448                 processed += 1;\n449             }\n450         }\n451         delta += 1;\n452         code_point += 1;\n453     }\n454     Ok(())\n455 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}