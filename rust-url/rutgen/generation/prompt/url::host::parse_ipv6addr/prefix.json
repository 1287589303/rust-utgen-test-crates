{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// url/src/host.rs\n// crate name is url\nuse crate::net::{Ipv4Addr, Ipv6Addr};\nuse alloc::borrow::Cow;\nuse alloc::borrow::ToOwned;\nuse alloc::string::String;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse core::cmp;\nuse core::fmt::{self, Formatter};\nuse percent_encoding::{percent_decode, utf8_percent_encode, CONTROLS};\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Serialize};\nuse crate::parser::{ParseError, ParseResult};\nfn parse_ipv6addr(input: &str) -> ParseResult<Ipv6Addr> {\n    let input = input.as_bytes();\n    let len = input.len();\n    let mut is_ip_v4 = false;\n    let mut pieces = [0, 0, 0, 0, 0, 0, 0, 0];\n    let mut piece_pointer = 0;\n    let mut compress_pointer = None;\n    let mut i = 0;\n    if len < 2 {\n        return Err(ParseError::InvalidIpv6Address);\n    }\n    if input[0] == b':' {\n        if input[1] != b':' {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n        i = 2;\n        piece_pointer = 1;\n        compress_pointer = Some(1);\n    }\n    while i < len {\n        if piece_pointer == 8 {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n        if input[i] == b':' {\n            if compress_pointer.is_some() {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n            i += 1;\n            piece_pointer += 1;\n            compress_pointer = Some(piece_pointer);\n            continue;\n        }\n        let start = i;\n        let end = cmp::min(len, start + 4);\n        let mut value = 0u16;\n        while i < end {\n            match (input[i] as char).to_digit(16) {\n                Some(digit) => {\n                    value = value * 0x10 + digit as u16;\n                    i += 1;\n                }\n                None => break,\n            }\n        }\n        if i < len {\n            match input[i] {\n                b'.' => {\n                    if i == start {\n                        return Err(ParseError::InvalidIpv6Address);\n                    }\n                    i = start;\n                    if piece_pointer > 6 {\n                        return Err(ParseError::InvalidIpv6Address);\n                    }\n                    is_ip_v4 = true;\n                }\n                b':' => {\n                    i += 1;\n                    if i == len {\n                        return Err(ParseError::InvalidIpv6Address);\n                    }\n                }\n                _ => return Err(ParseError::InvalidIpv6Address),\n            }\n        }\n        if is_ip_v4 {\n            break;\n        }\n        pieces[piece_pointer] = value;\n        piece_pointer += 1;\n    }\n    if is_ip_v4 {\n        if piece_pointer > 6 {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n        let mut numbers_seen = 0;\n        while i < len {\n            if numbers_seen > 0 {\n                if numbers_seen < 4 && (i < len && input[i] == b'.') {\n                    i += 1\n                } else {\n                    return Err(ParseError::InvalidIpv6Address);\n                }\n            }\n            let mut ipv4_piece = None;\n            while i < len {\n                let digit = match input[i] {\n                    c @ b'0'..=b'9' => c - b'0',\n                    _ => break,\n                };\n                match ipv4_piece {\n                    None => ipv4_piece = Some(digit as u16),\n                    Some(0) => return Err(ParseError::InvalidIpv6Address),\n                    Some(ref mut v) => {\n                        *v = *v * 10 + digit as u16;\n                        if *v > 255 {\n                            return Err(ParseError::InvalidIpv6Address);\n                        }\n                    }\n                }\n                i += 1;\n            }\n            pieces[piece_pointer] = if let Some(v) = ipv4_piece {\n                pieces[piece_pointer] * 0x100 + v\n            } else {\n                return Err(ParseError::InvalidIpv6Address);\n            };\n            numbers_seen += 1;\n            if numbers_seen == 2 || numbers_seen == 4 {\n                piece_pointer += 1;\n            }\n        }\n        if numbers_seen != 4 {\n            return Err(ParseError::InvalidIpv6Address);\n        }\n    }\n    if i < len {\n        return Err(ParseError::InvalidIpv6Address);\n    }\n    match compress_pointer {\n        Some(compress_pointer) => {\n            let mut swaps = piece_pointer - compress_pointer;\n            piece_pointer = 7;\n            while swaps > 0 {\n                pieces.swap(piece_pointer, compress_pointer + swaps - 1);\n                swaps -= 1;\n                piece_pointer -= 1;\n            }\n        }\n        _ => {\n            if piece_pointer != 8 {\n                return Err(ParseError::InvalidIpv6Address);\n            }\n        }\n    }\n    Ok(\n        Ipv6Addr::new(\n            pieces[0],\n            pieces[1],\n            pieces[2],\n            pieces[3],\n            pieces[4],\n            pieces[5],\n            pieces[6],\n            pieces[7],\n        ),\n    )\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// <https://url.spec.whatwg.org/#concept-ipv6-parser>\n329 fn parse_ipv6addr(input: &str) -> ParseResult<Ipv6Addr> {\n330     let input = input.as_bytes();\n331     let len = input.len();\n332     let mut is_ip_v4 = false;\n333     let mut pieces = [0, 0, 0, 0, 0, 0, 0, 0];\n334     let mut piece_pointer = 0;\n335     let mut compress_pointer = None;\n336     let mut i = 0;\n337 \n338     if len < 2 {\n339         return Err(ParseError::InvalidIpv6Address);\n340     }\n341 \n342     if input[0] == b':' {\n343         if input[1] != b':' {\n344             return Err(ParseError::InvalidIpv6Address);\n345         }\n346         i = 2;\n347         piece_pointer = 1;\n348         compress_pointer = Some(1);\n349     }\n350 \n351     while i < len {\n352         if piece_pointer == 8 {\n353             return Err(ParseError::InvalidIpv6Address);\n354         }\n355         if input[i] == b':' {\n356             if compress_pointer.is_some() {\n357                 return Err(ParseError::InvalidIpv6Address);\n358             }\n359             i += 1;\n360             piece_pointer += 1;\n361             compress_pointer = Some(piece_pointer);\n362             continue;\n363         }\n364         let start = i;\n365         let end = cmp::min(len, start + 4);\n366         let mut value = 0u16;\n367         while i < end {\n368             match (input[i] as char).to_digit(16) {\n369                 Some(digit) => {\n370                     value = value * 0x10 + digit as u16;\n371                     i += 1;\n372                 }\n373                 None => break,\n374             }\n375         }\n376         if i < len {\n377             match input[i] {\n378                 b'.' => {\n379                     if i == start {\n380                         return Err(ParseError::InvalidIpv6Address);\n381                     }\n382                     i = start;\n383                     if piece_pointer > 6 {\n384                         return Err(ParseError::InvalidIpv6Address);\n385                     }\n386                     is_ip_v4 = true;\n387                 }\n388                 b':' => {\n389                     i += 1;\n390                     if i == len {\n391                         return Err(ParseError::InvalidIpv6Address);\n392                     }\n393                 }\n394                 _ => return Err(ParseError::InvalidIpv6Address),\n395             }\n396         }\n397         if is_ip_v4 {\n398             break;\n399         }\n400         pieces[piece_pointer] = value;\n401         piece_pointer += 1;\n402     }\n403 \n404     if is_ip_v4 {\n405         if piece_pointer > 6 {\n406             return Err(ParseError::InvalidIpv6Address);\n407         }\n408         let mut numbers_seen = 0;\n409         while i < len {\n410             if numbers_seen > 0 {\n411                 if numbers_seen < 4 && (i < len && input[i] == b'.') {\n412                     i += 1\n413                 } else {\n414                     return Err(ParseError::InvalidIpv6Address);\n415                 }\n416             }\n417 \n418             let mut ipv4_piece = None;\n419             while i < len {\n420                 let digit = match input[i] {\n421                     c @ b'0'..=b'9' => c - b'0',\n422                     _ => break,\n423                 };\n424                 match ipv4_piece {\n425                     None => ipv4_piece = Some(digit as u16),\n426                     Some(0) => return Err(ParseError::InvalidIpv6Address), // No leading zero\n427                     Some(ref mut v) => {\n428                         *v = *v * 10 + digit as u16;\n429                         if *v > 255 {\n430                             return Err(ParseError::InvalidIpv6Address);\n431                         }\n432                     }\n433                 }\n434                 i += 1;\n435             }\n436 \n437             pieces[piece_pointer] = if let Some(v) = ipv4_piece {\n438                 pieces[piece_pointer] * 0x100 + v\n439             } else {\n440                 return Err(ParseError::InvalidIpv6Address);\n441             };\n442             numbers_seen += 1;\n443 \n444             if numbers_seen == 2 || numbers_seen == 4 {\n445                 piece_pointer += 1;\n446             }\n447         }\n448 \n449         if numbers_seen != 4 {\n450             return Err(ParseError::InvalidIpv6Address);\n451         }\n452     }\n453 \n454     if i < len {\n455         return Err(ParseError::InvalidIpv6Address);\n456     }\n457 \n458     match compress_pointer {\n459         Some(compress_pointer) => {\n460             let mut swaps = piece_pointer - compress_pointer;\n461             piece_pointer = 7;\n462             while swaps > 0 {\n463                 pieces.swap(piece_pointer, compress_pointer + swaps - 1);\n464                 swaps -= 1;\n465                 piece_pointer -= 1;\n466             }\n467         }\n468         _ => {\n469             if piece_pointer != 8 {\n470                 return Err(ParseError::InvalidIpv6Address);\n471             }\n472         }\n473     }\n474     Ok(Ipv6Addr::new(\n475         pieces[0], pieces[1], pieces[2], pieces[3], pieces[4], pieces[5], pieces[6], pieces[7],\n476     ))\n477 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}