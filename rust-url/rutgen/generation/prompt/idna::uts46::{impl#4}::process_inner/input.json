{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// idna/src/uts46.rs\n// crate name is idna\nuse crate::punycode::Decoder;\nuse crate::punycode::InternalCaller;\nuse alloc::borrow::Cow;\nuse alloc::string::String;\nuse core::fmt::Write;\nuse idna_adapter::*;\nuse smallvec::SmallVec;\nuse utf8_iter::Utf8CharsEx;\nconst PUNYCODE_DECODE_MAX_INPUT_LENGTH: usize = 2000;\nconst PUNYCODE_ENCODE_MAX_INPUT_LENGTH: usize = 1000;\nconst UPPER_CASE_MASK: u128 = upper_case_mask();\nconst GLYPHLESS_MASK: u128 = glyphless_mask();\nconst DOT_MASK: u128 = 1 << b'.';\nconst PUNYCODE_PREFIX: u32 = ((b'-' as u32) << 24) | ((b'-' as u32) << 16)\n    | ((b'N' as u32) << 8) | b'X' as u32;\nconst PUNYCODE_PREFIX_MASK: u32 = (0xFF << 24) | (0xFF << 16) | (0xDF << 8) | 0xDF;\npub struct Uts46 {\n    data: idna_adapter::Adapter,\n}\n#[derive(PartialEq, Eq, Copy, Clone)]\n#[repr(transparent)]\npub struct AsciiDenyList {\n    bits: u128,\n}\n#[derive(PartialEq, Eq, Copy, Clone)]\n#[non_exhaustive]\npub enum Hyphens {\n    /// _CheckHyphens=false_: Do not place positional restrictions on hyphens.\n    ///\n    /// This mode is used by the WHATWG URL Standard for normal User Agent processing\n    /// (i.e. not conformance checking).\n    Allow,\n    /// Prohibit hyphens in the first and last position in the label but allow in\n    /// the third and fourth position.\n    ///\n    /// Note that this mode rejects real-world names, including some GitHub user pages.\n    CheckFirstLast,\n    /// _CheckHyphens=true_: Prohibit hyphens in the first, third, fourth,\n    /// and last position in the label.\n    ///\n    /// Note that this mode rejects real-world names, including YouTube CDN nodes\n    /// and some GitHub user pages.\n    Check,\n}\n#[derive(Debug, Clone, Copy)]\nenum AlreadyAsciiLabel<'a> {\n    MixedCaseAscii(&'a [u8]),\n    MixedCasePunycode(&'a [u8]),\n    Other,\n}\nimpl Uts46 {\n    #[cfg(feature = \"compiled_data\")]\n    pub const fn new() -> Self {\n        Self {\n            data: idna_adapter::Adapter::new(),\n        }\n    }\n    pub fn to_ascii<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        dns_length: DnsLength,\n    ) -> Result<Cow<'a, str>, crate::Errors> {}\n    pub fn to_unicode<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n    ) -> (Cow<'a, str>, Result<(), crate::Errors>) {}\n    pub fn to_user_interface<'a, OutputUnicode: FnMut(&[char], &[char], bool) -> bool>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        output_as_unicode: OutputUnicode,\n    ) -> (Cow<'a, str>, Result<(), crate::Errors>) {}\n    #[allow(clippy::too_many_arguments)]\n    pub fn process<\n        W: Write + ?Sized,\n        OutputUnicode: FnMut(&[char], &[char], bool) -> bool,\n    >(\n        &self,\n        domain_name: &[u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        error_policy: ErrorPolicy,\n        mut output_as_unicode: OutputUnicode,\n        sink: &mut W,\n        ascii_sink: Option<&mut W>,\n    ) -> Result<ProcessingSuccess, ProcessingError> {}\n    #[inline(always)]\n    fn process_inner<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        fail_fast: bool,\n        domain_buffer: &mut SmallVec<[char; 253]>,\n        already_punycode: &mut SmallVec<[AlreadyAsciiLabel<'a>; 8]>,\n    ) -> (usize, bool, bool) {\n        let mut iter = domain_name.iter();\n        let mut most_recent_label_start = iter.clone();\n        loop {\n            if let Some(&b) = iter.next() {\n                if in_inclusive_range8(b, b'a', b'z') {\n                    continue;\n                }\n                if b == b'.' {\n                    most_recent_label_start = iter.clone();\n                    continue;\n                }\n                return self\n                    .process_innermost(\n                        domain_name,\n                        ascii_deny_list,\n                        hyphens,\n                        fail_fast,\n                        domain_buffer,\n                        already_punycode,\n                        most_recent_label_start.as_slice(),\n                    );\n            } else {\n                return (domain_name.len(), false, false);\n            }\n        }\n    }\n    #[allow(clippy::too_many_arguments)]\n    #[inline(never)]\n    fn process_innermost<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        fail_fast: bool,\n        domain_buffer: &mut SmallVec<[char; 253]>,\n        already_punycode: &mut SmallVec<[AlreadyAsciiLabel<'a>; 8]>,\n        tail: &'a [u8],\n    ) -> (usize, bool, bool) {\n        let deny_list = ascii_deny_list.bits;\n        let deny_list_deny_dot = deny_list | DOT_MASK;\n        let mut had_errors = false;\n        let mut passthrough_up_to = domain_name.len() - tail.len();\n        let mut current_label_start;\n        let mut seen_label = false;\n        let mut in_prefix = true;\n        for label in tail.split(|b| *b == b'.') {\n            if in_prefix && is_passthrough_ascii_label(label) {\n                if seen_label {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                }\n                seen_label = true;\n                passthrough_up_to += label.len();\n                continue;\n            }\n            if seen_label {\n                if in_prefix {\n                    debug_assert_eq!(domain_name[passthrough_up_to], b'.');\n                    passthrough_up_to += 1;\n                } else {\n                    domain_buffer.push('.');\n                }\n            }\n            seen_label = true;\n            in_prefix = false;\n            current_label_start = domain_buffer.len();\n            if !label.is_empty() {\n                let (ascii, non_ascii) = split_ascii_fast_path_prefix(label);\n                let non_punycode_ascii_label = if non_ascii.is_empty() {\n                    if has_punycode_prefix(ascii) {\n                        if (ascii.last() != Some(&b'-'))\n                            && (ascii.len() - 4 <= PUNYCODE_DECODE_MAX_INPUT_LENGTH)\n                        {\n                            if let Ok(decode) = Decoder::default()\n                                .decode::<u8, InternalCaller>(&ascii[4..])\n                            {\n                                let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                label_buffer.extend(decode);\n                                if self\n                                    .after_punycode_decode(\n                                        domain_buffer,\n                                        current_label_start,\n                                        &label_buffer,\n                                        deny_list_deny_dot,\n                                        fail_fast,\n                                        &mut had_errors,\n                                    )\n                                {\n                                    return (0, false, true);\n                                }\n                                if self\n                                    .check_label(\n                                        hyphens,\n                                        &mut domain_buffer[current_label_start..],\n                                        fail_fast,\n                                        &mut had_errors,\n                                        true,\n                                        true,\n                                    )\n                                {\n                                    return (0, false, true);\n                                }\n                            } else {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                domain_buffer.push('\\u{FFFD}');\n                                let mut iter = ascii.iter();\n                                let _ = iter.next();\n                                domain_buffer\n                                    .extend(\n                                        iter\n                                            .map(|c| {\n                                                apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                                                    *c,\n                                                    deny_list,\n                                                )\n                                            }),\n                                    );\n                            };\n                            already_punycode\n                                .push(AlreadyAsciiLabel::MixedCasePunycode(label));\n                            continue;\n                        } else if fail_fast {\n                            return (0, false, true);\n                        }\n                        false\n                    } else {\n                        true\n                    }\n                } else {\n                    false\n                };\n                for c in ascii\n                    .iter()\n                    .map(|c| {\n                        apply_ascii_deny_list_to_potentially_upper_case_ascii(\n                            *c,\n                            deny_list,\n                        )\n                    })\n                {\n                    if c == '\\u{FFFD}' {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                    }\n                    domain_buffer.push(c);\n                }\n                if non_punycode_ascii_label {\n                    if hyphens != Hyphens::Allow\n                        && check_hyphens(\n                            &mut domain_buffer[current_label_start..],\n                            hyphens == Hyphens::CheckFirstLast,\n                            fail_fast,\n                            &mut had_errors,\n                        )\n                    {\n                        return (0, false, true);\n                    }\n                    already_punycode\n                        .push(\n                            if had_errors {\n                                AlreadyAsciiLabel::Other\n                            } else {\n                                AlreadyAsciiLabel::MixedCaseAscii(label)\n                            },\n                        );\n                    continue;\n                }\n                already_punycode.push(AlreadyAsciiLabel::Other);\n                let mut first_needs_combining_mark_check = ascii.is_empty();\n                let mut needs_contextj_check = !non_ascii.is_empty();\n                let mut mapping = self\n                    .data\n                    .map_normalize(non_ascii.chars())\n                    .map(|c| apply_ascii_deny_list_to_lower_cased_unicode(c, deny_list));\n                loop {\n                    let n = mapping.next();\n                    match n {\n                        None | Some('.') => {\n                            if domain_buffer[current_label_start..]\n                                .starts_with(&['x', 'n', '-', '-'])\n                            {\n                                let mut punycode_precondition_failed = false;\n                                for c in domain_buffer[current_label_start + 4..].iter_mut()\n                                {\n                                    if !c.is_ascii() {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                }\n                                if let Some(last) = domain_buffer.last_mut() {\n                                    if *last == '-' {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *last = '\\u{FFFD}';\n                                        punycode_precondition_failed = true;\n                                    }\n                                } else {\n                                    unreachable!();\n                                }\n                                if domain_buffer.len() - current_label_start - 4\n                                    > PUNYCODE_DECODE_MAX_INPUT_LENGTH\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    domain_buffer[current_label_start + 4\n                                        + PUNYCODE_DECODE_MAX_INPUT_LENGTH] = '\\u{FFFD}';\n                                    punycode_precondition_failed = true;\n                                }\n                                if !punycode_precondition_failed {\n                                    if let Ok(decode) = Decoder::default()\n                                        .decode::<\n                                            char,\n                                            InternalCaller,\n                                        >(&domain_buffer[current_label_start + 4..])\n                                    {\n                                        first_needs_combining_mark_check = true;\n                                        needs_contextj_check = true;\n                                        let mut label_buffer = SmallVec::<[char; 59]>::new();\n                                        label_buffer.extend(decode);\n                                        domain_buffer.truncate(current_label_start);\n                                        if self\n                                            .after_punycode_decode(\n                                                domain_buffer,\n                                                current_label_start,\n                                                &label_buffer,\n                                                deny_list_deny_dot,\n                                                fail_fast,\n                                                &mut had_errors,\n                                            )\n                                        {\n                                            return (0, false, true);\n                                        }\n                                    } else {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        domain_buffer[current_label_start] = '\\u{FFFD}';\n                                        needs_contextj_check = false;\n                                        first_needs_combining_mark_check = false;\n                                    };\n                                } else {\n                                    first_needs_combining_mark_check = false;\n                                    needs_contextj_check = false;\n                                }\n                            }\n                            if self\n                                .check_label(\n                                    hyphens,\n                                    &mut domain_buffer[current_label_start..],\n                                    fail_fast,\n                                    &mut had_errors,\n                                    first_needs_combining_mark_check,\n                                    needs_contextj_check,\n                                )\n                            {\n                                return (0, false, true);\n                            }\n                            if n.is_none() {\n                                break;\n                            }\n                            domain_buffer.push('.');\n                            current_label_start = domain_buffer.len();\n                            first_needs_combining_mark_check = true;\n                            needs_contextj_check = true;\n                            already_punycode.push(AlreadyAsciiLabel::Other);\n                        }\n                        Some(c) => {\n                            if c == '\\u{FFFD}' {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                            }\n                            domain_buffer.push(c);\n                        }\n                    }\n                }\n            } else {\n                already_punycode.push(AlreadyAsciiLabel::MixedCaseAscii(label));\n            }\n        }\n        let is_bidi = self.is_bidi(domain_buffer);\n        if is_bidi {\n            for label in domain_buffer.split_mut(|c| *c == '.') {\n                if let Some((first, tail)) = label.split_first_mut() {\n                    let first_bc = self.data.bidi_class(*first);\n                    if !FIRST_BC_MASK.intersects(first_bc.to_mask()) {\n                        if fail_fast {\n                            return (0, false, true);\n                        }\n                        had_errors = true;\n                        *first = '\\u{FFFD}';\n                        continue;\n                    }\n                    let is_ltr = first_bc.is_ltr();\n                    let mut middle = tail;\n                    #[allow(clippy::while_let_loop)]\n                    loop {\n                        if let Some((last, prior)) = middle.split_last_mut() {\n                            let last_bc = self.data.bidi_class(*last);\n                            if last_bc.is_nonspacing_mark() {\n                                middle = prior;\n                                continue;\n                            }\n                            let last_mask = if is_ltr {\n                                LAST_LTR_MASK\n                            } else {\n                                LAST_RTL_MASK\n                            };\n                            if !last_mask.intersects(last_bc.to_mask()) {\n                                if fail_fast {\n                                    return (0, false, true);\n                                }\n                                had_errors = true;\n                                *last = '\\u{FFFD}';\n                            }\n                            if is_ltr {\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_LTR_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    }\n                                }\n                            } else {\n                                let mut numeral_state = RtlNumeralState::Undecided;\n                                for c in prior.iter_mut() {\n                                    let bc = self.data.bidi_class(*c);\n                                    if !MIDDLE_RTL_MASK.intersects(bc.to_mask()) {\n                                        if fail_fast {\n                                            return (0, false, true);\n                                        }\n                                        had_errors = true;\n                                        *c = '\\u{FFFD}';\n                                    } else {\n                                        match numeral_state {\n                                            RtlNumeralState::Undecided => {\n                                                if bc.is_european_number() {\n                                                    numeral_state = RtlNumeralState::European;\n                                                } else if bc.is_arabic_number() {\n                                                    numeral_state = RtlNumeralState::Arabic;\n                                                }\n                                            }\n                                            RtlNumeralState::European => {\n                                                if bc.is_arabic_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                            RtlNumeralState::Arabic => {\n                                                if bc.is_european_number() {\n                                                    if fail_fast {\n                                                        return (0, false, true);\n                                                    }\n                                                    had_errors = true;\n                                                    *c = '\\u{FFFD}';\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                if (numeral_state == RtlNumeralState::European\n                                    && last_bc.is_arabic_number())\n                                    || (numeral_state == RtlNumeralState::Arabic\n                                        && last_bc.is_european_number())\n                                {\n                                    if fail_fast {\n                                        return (0, false, true);\n                                    }\n                                    had_errors = true;\n                                    *last = '\\u{FFFD}';\n                                }\n                            }\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        (passthrough_up_to, is_bidi, had_errors)\n    }\n    #[inline(never)]\n    fn after_punycode_decode(\n        &self,\n        domain_buffer: &mut SmallVec<[char; 253]>,\n        current_label_start: usize,\n        label_buffer: &[char],\n        deny_list_deny_dot: u128,\n        fail_fast: bool,\n        had_errors: &mut bool,\n    ) -> bool {}\n    #[inline(never)]\n    fn check_label(\n        &self,\n        hyphens: Hyphens,\n        mut_label: &mut [char],\n        fail_fast: bool,\n        had_errors: &mut bool,\n        first_needs_combining_mark_check: bool,\n        needs_contextj_check: bool,\n    ) -> bool {}\n    #[inline(always)]\n    fn has_appropriately_joining_char<I: Iterator<Item = char>>(\n        &self,\n        iter: I,\n        required_mask: JoiningTypeMask,\n    ) -> bool {}\n    #[inline(always)]\n    fn is_bidi(&self, buffer: &[char]) -> bool {}\n}\n#[inline(always)]\nfn in_inclusive_range8(u: u8, start: u8, end: u8) -> bool {\n    u.wrapping_sub(start) <= (end - start)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// The part of `process` that doesn't need to be generic over the sink.\n1031 fn process_inner<'a>(\n1032     &self,\n1033     domain_name: &'a [u8],\n1034     ascii_deny_list: AsciiDenyList,\n1035     hyphens: Hyphens,\n1036     fail_fast: bool,\n1037     domain_buffer: &mut SmallVec<[char; 253]>,\n1038     already_punycode: &mut SmallVec<[AlreadyAsciiLabel<'a>; 8]>,\n1039 ) -> (usize, bool, bool) {\n1040     // Sadly, this even faster-path ASCII tier is needed to avoid regressing\n1041     // performance.\n1042     let mut iter = domain_name.iter();\n1043     let mut most_recent_label_start = iter.clone();\n1044     loop {\n1045         if let Some(&b) = iter.next() {\n1046             if in_inclusive_range8(b, b'a', b'z') {\n1047                 continue;\n1048             }\n1049             if b == b'.' {\n1050                 most_recent_label_start = iter.clone();\n1051                 continue;\n1052             }\n1053             return self.process_innermost(\n1054                 domain_name,\n1055                 ascii_deny_list,\n1056                 hyphens,\n1057                 fail_fast,\n1058                 domain_buffer,\n1059                 already_punycode,\n1060                 most_recent_label_start.as_slice(),\n1061             );\n1062         } else {\n1063             // Success! The whole input passes through on the fastest path!\n1064             return (domain_name.len(), false, false);\n1065         }\n1066     }\n1067 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}