[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let deny_list: &str = \"\";",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, AsciiDenyList::EMPTY);",
          "    assert_eq!(result.bits, UPPER_CASE_MASK);",
          "    assert!(result.bits & GLYPHLESS_MASK == 0);",
          "    assert!(result.bits & (1u128 << b'A') == 0);",
          "    assert!(result.bits & (1u128 << b'B') == 0);",
          "    assert!(result.bits & (1u128 << b'C') == 0);",
          "    assert!(result.bits & (1u128 << b'Z') == 0);",
          "    assert!(result.bits & (1u128 << b'0') == 0);",
          "    assert!(result.bits & (1u128 << b'a') == 0);",
          "    assert!(result.bits & (1u128 << b'z') == 0);"
        ],
        "code": [
          "{",
          "    let deny_list: &str = \"\";",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "    assert_eq!(result, AsciiDenyList::EMPTY);",
          "    assert_eq!(result.bits, UPPER_CASE_MASK);",
          "    assert!(result.bits & GLYPHLESS_MASK == 0);",
          "    assert!(result.bits & (1u128 << b'A') == 0);",
          "    assert!(result.bits & (1u128 << b'B') == 0);",
          "    assert!(result.bits & (1u128 << b'C') == 0);",
          "    assert!(result.bits & (1u128 << b'Z') == 0);",
          "    assert!(result.bits & (1u128 << b'0') == 0);",
          "    assert!(result.bits & (1u128 << b'a') == 0);",
          "    assert!(result.bits & (1u128 << b'z') == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let deny_list: &str = \"A\"; // b'A' is used here",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "}"
        ],
        "oracle": [
          "    let deny_list: &str = \"A\"; // b'A' is used here",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "    assert_eq!(result.bits, UPPER_CASE_MASK | (1u128 << b'A'));"
        ],
        "code": [
          "{",
          "    let deny_list: &str = \"A\"; // b'A' is used here",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "    let deny_list: &str = \"A\"; // b'A' is used here",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "    assert_eq!(result.bits, UPPER_CASE_MASK | (1u128 << b'A'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let deny_list: &str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; // b'A' to b'Z'",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "}"
        ],
        "oracle": [
          "    let deny_list: &str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; // b'A' to b'Z'",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "    assert_eq!(result, AsciiDenyList { bits: UPPER_CASE_MASK | (1 << b'A') | (1 << b'B') | (1 << b'C') | (1 << b'D') | (1 << b'E') | (1 << b'F') | (1 << b'G') | (1 << b'H') | (1 << b'I') | (1 << b'J') | (1 << b'K') | (1 << b'L') | (1 << b'M') | (1 << b'N') | (1 << b'O') | (1 << b'P') | (1 << b'Q') | (1 << b'R') | (1 << b'S') | (1 << b'T') | (1 << b'U') | (1 << b'V') | (1 << b'W') | (1 << b'X') | (1 << b'Y') | (1 << b'Z') });",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC.DEF\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC-DEF\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC012\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABCabc\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC@\") }).is_ok());"
        ],
        "code": [
          "{",
          "    let deny_list: &str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; // b'A' to b'Z'",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "    let deny_list: &str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; // b'A' to b'Z'",
          "    let result = AsciiDenyList::new(false, deny_list);",
          "    assert_eq!(result, AsciiDenyList { bits: UPPER_CASE_MASK | (1 << b'A') | (1 << b'B') | (1 << b'C') | (1 << b'D') | (1 << b'E') | (1 << b'F') | (1 << b'G') | (1 << b'H') | (1 << b'I') | (1 << b'J') | (1 << b'K') | (1 << b'L') | (1 << b'M') | (1 << b'N') | (1 << b'O') | (1 << b'P') | (1 << b'Q') | (1 << b'R') | (1 << b'S') | (1 << b'T') | (1 << b'U') | (1 << b'V') | (1 << b'W') | (1 << b'X') | (1 << b'Y') | (1 << b'Z') });",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC.DEF\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC-DEF\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC012\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABCabc\") }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { AsciiDenyList::new(false, \"ABC@\") }).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]