[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"valid.domain\";",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "}"
        ],
        "oracle": [
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    let domain = \"valid.domain\";",
          "    let mut output = String::new();",
          "    assert_eq!(idna.to_ascii(domain, &mut output), Ok(()));",
          "    assert_eq!(output, \"valid.domain\");",
          "    let invalid_domain = \"invalid_domain\";",
          "    assert!(idna.to_ascii(invalid_domain, &mut output).is_err());",
          "    let mut long_domain = \"a\".repeat(255);",
          "    assert!(idna.to_ascii(&long_domain, &mut output).is_err());",
          "    let mut output_sink = String::new();",
          "    idna.to_ascii(\"noconn.local\", &mut output_sink).unwrap();",
          "    assert!(output_sink.contains(\"noconn.local\"));",
          "    idna = Idna::new(Config::default().verify_dns_length(false));",
          "    assert_eq!(idna.to_ascii(domain, &mut output), Ok(()));",
          "    idna.config.verify_dns_length = true;",
          "    assert_ne!(idna.to_ascii(\"..\", &mut output), Ok(()));"
        ],
        "code": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"valid.domain\";",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    let domain = \"valid.domain\";",
          "    let mut output = String::new();",
          "    assert_eq!(idna.to_ascii(domain, &mut output), Ok(()));",
          "    assert_eq!(output, \"valid.domain\");",
          "    let invalid_domain = \"invalid_domain\";",
          "    assert!(idna.to_ascii(invalid_domain, &mut output).is_err());",
          "    let mut long_domain = \"a\".repeat(255);",
          "    assert!(idna.to_ascii(&long_domain, &mut output).is_err());",
          "    let mut output_sink = String::new();",
          "    idna.to_ascii(\"noconn.local\", &mut output_sink).unwrap();",
          "    assert!(output_sink.contains(\"noconn.local\"));",
          "    idna = Idna::new(Config::default().verify_dns_length(false));",
          "    assert_eq!(idna.to_ascii(domain, &mut output), Ok(()));",
          "    idna.config.verify_dns_length = true;",
          "    assert_ne!(idna.to_ascii(\"..\", &mut output), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"valid.channel\";",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "}"
        ],
        "oracle": [
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    let domain_valid = \"valid.channel\";",
          "    let mut output_valid = String::new();",
          "    assert_eq!(idna.to_ascii(domain_valid, &mut output_valid), Ok(()));",
          "    assert_eq!(output_valid, \"valid.channel\");",
          "    let domain_invalid = \"invalid..channel\";",
          "    let mut output_invalid = String::new();",
          "    assert!(idna.to_ascii(domain_invalid, &mut output_invalid).is_err());",
          "    assert!(output_invalid.is_empty());",
          "    let domain_exceeding_length = \"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.abcdefghijklmnopqrstuvwxyz\";",
          "    let mut output_length = String::new();",
          "    assert_eq!(idna.to_ascii(domain_exceeding_length, &mut output_length).unwrap_err(), crate::Errors::default());",
          "    let domain_with_invalid_chars = \"valid$.channel\";",
          "    let mut output_invalid_chars = String::new();",
          "    assert!(idna.to_ascii(domain_with_invalid_chars, &mut output_invalid_chars).is_err());",
          "    assert!(output_invalid_chars.is_empty());",
          "    let domain_with_leading_hyphen = \"-invalid.channel\";",
          "    let mut output_leading_hyphen = String::new();",
          "    assert!(idna.to_ascii(domain_with_leading_hyphen, &mut output_leading_hyphen).is_err());",
          "    assert!(output_leading_hyphen.is_empty());",
          "    let domain_with_trailing_hyphen = \"invalid-channel-\";",
          "    let mut output_trailing_hyphen = String::new();",
          "    assert!(idna.to_ascii(domain_with_trailing_hyphen, &mut output_trailing_hyphen).is_err());",
          "    assert!(output_trailing_hyphen.is_empty());"
        ],
        "code": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"valid.channel\";",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    let domain_valid = \"valid.channel\";",
          "    let mut output_valid = String::new();",
          "    assert_eq!(idna.to_ascii(domain_valid, &mut output_valid), Ok(()));",
          "    assert_eq!(output_valid, \"valid.channel\");",
          "    let domain_invalid = \"invalid..channel\";",
          "    let mut output_invalid = String::new();",
          "    assert!(idna.to_ascii(domain_invalid, &mut output_invalid).is_err());",
          "    assert!(output_invalid.is_empty());",
          "    let domain_exceeding_length = \"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.abcdefghijklmnopqrstuvwxyz\";",
          "    let mut output_length = String::new();",
          "    assert_eq!(idna.to_ascii(domain_exceeding_length, &mut output_length).unwrap_err(), crate::Errors::default());",
          "    let domain_with_invalid_chars = \"valid$.channel\";",
          "    let mut output_invalid_chars = String::new();",
          "    assert!(idna.to_ascii(domain_with_invalid_chars, &mut output_invalid_chars).is_err());",
          "    assert!(output_invalid_chars.is_empty());",
          "    let domain_with_leading_hyphen = \"-invalid.channel\";",
          "    let mut output_leading_hyphen = String::new();",
          "    assert!(idna.to_ascii(domain_with_leading_hyphen, &mut output_leading_hyphen).is_err());",
          "    assert!(output_leading_hyphen.is_empty());",
          "    let domain_with_trailing_hyphen = \"invalid-channel-\";",
          "    let mut output_trailing_hyphen = String::new();",
          "    assert!(idna.to_ascii(domain_with_trailing_hyphen, &mut output_trailing_hyphen).is_err());",
          "    assert!(output_trailing_hyphen.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"invalid!domain\"; // Contains invalid character",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "}"
        ],
        "oracle": [
          "    idna.to_ascii(\"invalid!domain\", &mut output).unwrap();",
          "    assert_eq!(Err(Errors::default()), idna.to_ascii(\"invalid!domain\", &mut output));",
          "    assert!(output.is_empty());",
          "    assert_eq!(Uts46::new().process(\"invalid!domain\".as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).unwrap(), ProcessingSuccess::WroteToSink);",
          "    assert!(!verify_dns_length(&output, true));",
          "    assert!(self.config.verify_dns_length);"
        ],
        "code": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"invalid!domain\"; // Contains invalid character",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "    idna.to_ascii(\"invalid!domain\", &mut output).unwrap();",
          "    assert_eq!(Err(Errors::default()), idna.to_ascii(\"invalid!domain\", &mut output));",
          "    assert!(output.is_empty());",
          "    assert_eq!(Uts46::new().process(\"invalid!domain\".as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).unwrap(), ProcessingSuccess::WroteToSink);",
          "    assert!(!verify_dns_length(&output, true));",
          "    assert!(self.config.verify_dns_length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"too.long.domain.name.exceeding.maximum.length.abcdefghijk\";",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "}"
        ],
        "oracle": [
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    let domain = \"too.long.domain.name.exceeding.maximum.length.abcdefghijk\";",
          "    let mut output = String::new();",
          "    let result = idna.to_ascii(domain, &mut output);",
          "    assert!(result.is_err());",
          "    assert_eq!(result, Err(crate::Errors::default()));",
          "    assert!(output.is_empty());",
          "    assert!(Uts46::new().process(domain.as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).is_err());",
          "    assert!(Uts46::new().process(domain.as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).unwrap() == ProcessingSuccess::WroteToSink);",
          "    assert!(!verify_dns_length(&output, true));"
        ],
        "code": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"too.long.domain.name.exceeding.maximum.length.abcdefghijk\";",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    let domain = \"too.long.domain.name.exceeding.maximum.length.abcdefghijk\";",
          "    let mut output = String::new();",
          "    let result = idna.to_ascii(domain, &mut output);",
          "    assert!(result.is_err());",
          "    assert_eq!(result, Err(crate::Errors::default()));",
          "    assert!(output.is_empty());",
          "    assert!(Uts46::new().process(domain.as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).is_err());",
          "    assert!(Uts46::new().process(domain.as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).unwrap() == ProcessingSuccess::WroteToSink);",
          "    assert!(!verify_dns_length(&output, true));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"invalid..domain\"; // Two consecutive dots indicating empty label",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "}"
        ],
        "oracle": [
          "    let mut output = String::new();",
          "    let domain = \"invalid..domain\";",
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    assert_eq!(idna.to_ascii(domain, &mut output), Err(crate::Errors::default()));",
          "    assert!(Uts46::new().process(domain.as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).is_err());",
          "    assert!(verify_dns_length(&output, true) == false);",
          "    assert!(idna.config.verify_dns_length);"
        ],
        "code": [
          "{",
          "    let mut idna = Idna::new(Config::default()",
          "        .transitional_processing(true)",
          "        .verify_dns_length(true)",
          "        .check_hyphens(false));",
          "    let domain = \"invalid..domain\"; // Two consecutive dots indicating empty label",
          "    let mut output = String::new();",
          "    idna.to_ascii(domain, &mut output).unwrap();",
          "    let mut output = String::new();",
          "    let domain = \"invalid..domain\";",
          "    let mut idna = Idna::new(Config::default().transitional_processing(true).verify_dns_length(true).check_hyphens(false));",
          "    assert_eq!(idna.to_ascii(domain, &mut output), Err(crate::Errors::default()));",
          "    assert!(Uts46::new().process(domain.as_bytes(), idna.config.deny_list(), idna.config.hyphens(), ErrorPolicy::FailFast, |_, _, _| false, &mut output, None).is_err());",
          "    assert!(verify_dns_length(&output, true) == false);",
          "    assert!(idna.config.verify_dns_length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]