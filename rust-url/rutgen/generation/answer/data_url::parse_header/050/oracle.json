[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"\\t\\n\\rhello\\x00world\\x1F\";",
          "    let result = parse_header(input);",
          "}"
        ],
        "oracle": [
          "    let input = \"\\t\\n\\rhello\\x7Fworld\"; // Testing with a byte in the range of 0x7F to 0xFF",
          "    let result = parse_header(input); // Expecting HTML-encoded result for ASCII control characters",
          "    assert_eq!(result.1, false); // base64 should be false",
          "    assert_eq!(result.0.type_, \"text\"); // Default MIME type",
          "    assert_eq!(result.0.subtype, \"plain\"); // Default MIME subtype",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]); // Default parameters",
          "    ",
          "    let input = \"\\t\\n\\r<hello world>\"; // Testing with characters that would trigger percent encoding for '<' and '>'",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, false);",
          "    assert_eq!(result.0.type_, \"text\");",
          "    assert_eq!(result.0.subtype, \"plain\");",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]);",
          "    ",
          "    let input = \"\\t\\n\\r?hello world\"; // Testing with a '?' character to trigger query state",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, false);",
          "    assert_eq!(result.0.type_, \"text\");",
          "    assert_eq!(result.0.subtype, \"plain\");",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]);",
          "    ",
          "    let input = \"\\t\\n\\r\\\"hello world\\\"\"; // Testing with quotes which requires percent encoding",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, false);",
          "    assert_eq!(result.0.type_, \"text\");",
          "    assert_eq!(result.0.subtype, \"plain\");",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]);"
        ],
        "code": [
          "{",
          "    let input = \"\\t\\n\\rhello\\x00world\\x1F\";",
          "    let result = parse_header(input);",
          "    let input = \"\\t\\n\\rhello\\x7Fworld\"; // Testing with a byte in the range of 0x7F to 0xFF",
          "    let result = parse_header(input); // Expecting HTML-encoded result for ASCII control characters",
          "    assert_eq!(result.1, false); // base64 should be false",
          "    assert_eq!(result.0.type_, \"text\"); // Default MIME type",
          "    assert_eq!(result.0.subtype, \"plain\"); // Default MIME subtype",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]); // Default parameters",
          "    ",
          "    let input = \"\\t\\n\\r<hello world>\"; // Testing with characters that would trigger percent encoding for '<' and '>'",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, false);",
          "    assert_eq!(result.0.type_, \"text\");",
          "    assert_eq!(result.0.subtype, \"plain\");",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]);",
          "    ",
          "    let input = \"\\t\\n\\r?hello world\"; // Testing with a '?' character to trigger query state",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, false);",
          "    assert_eq!(result.0.type_, \"text\");",
          "    assert_eq!(result.0.subtype, \"plain\");",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]);",
          "    ",
          "    let input = \"\\t\\n\\r\\\"hello world\\\"\"; // Testing with quotes which requires percent encoding",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, false);",
          "    assert_eq!(result.0.type_, \"text\");",
          "    assert_eq!(result.0.subtype, \"plain\");",
          "    assert_eq!(result.0.parameters, vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"hello world \\\"quoted\\\" <tag>\";",
          "    let result = parse_header(input);",
          "}"
        ],
        "oracle": [
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));"
        ],
        "code": [
          "{",
          "    let input = \"hello world \\\"quoted\\\" <tag>\";",
          "    let result = parse_header(input);",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"query?value\";",
          "    let result = parse_header(input);",
          "}"
        ],
        "oracle": [
          "    let input = \"query?value\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));"
        ],
        "code": [
          "{",
          "    let input = \"query?value\";",
          "    let result = parse_header(input);",
          "    let input = \"query?value\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"example: \\t\\n\\r test\\x7F value\";",
          "    let result = parse_header(input);",
          "}"
        ],
        "oracle": [
          "    let input = \"example: \\t\\n\\r test\\x7F value\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (expected_mime_type, expected_base64));"
        ],
        "code": [
          "{",
          "    let input = \"example: \\t\\n\\r test\\x7F value\";",
          "    let result = parse_header(input);",
          "    let input = \"example: \\t\\n\\r test\\x7F value\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \";application/json\";",
          "    let result = parse_header(input);",
          "}"
        ],
        "oracle": [
          "    let input = \";application/json\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"text/html\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"\\t\\ttext/plain\\r\\n\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"\\x1Fimage/png\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"image/jpeg\\r\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"file;type=\\\"image\\\"\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"text/html; charset=UTF-8\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"application/pdf; name=\\\"document\\\"\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"image/gif; charset=UTF-8\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"video/mp4; param=value\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));"
        ],
        "code": [
          "{",
          "    let input = \";application/json\";",
          "    let result = parse_header(input);",
          "    let input = \";application/json\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"text/html\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"\\t\\ttext/plain\\r\\n\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"\\x1Fimage/png\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"image/jpeg\\r\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"file;type=\\\"image\\\"\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"text/html; charset=UTF-8\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"application/pdf; name=\\\"document\\\"\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"image/gif; charset=UTF-8\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "    ",
          "    let input = \"video/mp4; param=value\";",
          "    let expected_mime_type = mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] };",
          "    let expected_base64 = false;",
          "    assert_eq!(result, (expected_mime_type, expected_base64));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"image/jpeg\";",
          "    let result = parse_header(input);",
          "}"
        ],
        "oracle": [
          "    let input = \";image/jpeg\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \"image/png\\x00\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, true);",
          "    ",
          "    let input = \"image/png\\r\\n\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.type_, \"image\");",
          "    ",
          "    let input = \"image/png\\ncontent-type\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.subtype, \"png\");",
          "    ",
          "    let input = \"application/json\\n\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.parameters.len(), 1);",
          "    ",
          "    let input = \"text/html\\t\";",
          "    let result = parse_header(input);",
          "    assert!(result.0.type_ == \"text\" && result.0.subtype == \"html\");",
          "    ",
          "    let input = \"application/octet-stream\\xFF\";",
          "    let result = parse_header(input);",
          "    assert!(result.1 == false);",
          "    ",
          "    let input = \"image/jpeg<a>\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.parameters.first().unwrap(), &(String::from(\"charset\"), String::from(\"US-ASCII\")));"
        ],
        "code": [
          "{",
          "    let input = \"image/jpeg\";",
          "    let result = parse_header(input);",
          "    let input = \";image/jpeg\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: String::from(\"text\"), subtype: String::from(\"plain\"), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \"image/png\\x00\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.1, true);",
          "    ",
          "    let input = \"image/png\\r\\n\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.type_, \"image\");",
          "    ",
          "    let input = \"image/png\\ncontent-type\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.subtype, \"png\");",
          "    ",
          "    let input = \"application/json\\n\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.parameters.len(), 1);",
          "    ",
          "    let input = \"text/html\\t\";",
          "    let result = parse_header(input);",
          "    assert!(result.0.type_ == \"text\" && result.0.subtype == \"html\");",
          "    ",
          "    let input = \"application/octet-stream\\xFF\";",
          "    let result = parse_header(input);",
          "    assert!(result.1 == false);",
          "    ",
          "    let input = \"image/jpeg<a>\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result.0.parameters.first().unwrap(), &(String::from(\"charset\"), String::from(\"US-ASCII\")));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"\";",
          "    let result = parse_header(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \" ;\\n\\t\\r \";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, true));",
          "    ",
          "    let input = \"\\t\\n\\r\\t\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \"text/plain\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \"application/json; charset=utf-8\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"application\".to_string(), subtype: \"json\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"utf-8\"))] }, false));",
          "    ",
          "    let input = \"text/html; charset=utf-8; attr=value\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"html\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"utf-8\")), (String::from(\"attr\"), String::from(\"value\"))] }, false));"
        ],
        "code": [
          "{",
          "    let input = \"\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \" ;\\n\\t\\r \";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, true));",
          "    ",
          "    let input = \"\\t\\n\\r\\t\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \"text/plain\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"plain\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"US-ASCII\"))] }, false));",
          "    ",
          "    let input = \"application/json; charset=utf-8\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"application\".to_string(), subtype: \"json\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"utf-8\"))] }, false));",
          "    ",
          "    let input = \"text/html; charset=utf-8; attr=value\";",
          "    let result = parse_header(input);",
          "    assert_eq!(result, (mime::Mime { type_: \"text\".to_string(), subtype: \"html\".to_string(), parameters: vec![(String::from(\"charset\"), String::from(\"utf-8\")), (String::from(\"attr\"), String::from(\"value\"))] }, false));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]