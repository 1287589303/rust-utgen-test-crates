[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"/example/type; parameter=\\\"value\\\"; another=param\";",
          "    let result = parse(input);",
          "}"
        ],
        "oracle": [
          "    let input = \"/example/type; parameter=\\\"value\\\"; another=param\";",
          "    let expected = Some(Mime { type_: \"example\".to_string(), subtype: \"type\".to_string(), parameters: vec![(\"parameter\".to_string(), \"value\".to_string()), (\"another\".to_string(), \"param\".to_string())] });",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let input = \"/example/type; parameter=\\\"value\\\"; another=param\";",
          "    let result = parse(input);",
          "    let input = \"/example/type; parameter=\\\"value\\\"; another=param\";",
          "    let expected = Some(Mime { type_: \"example\".to_string(), subtype: \"type\".to_string(), parameters: vec![(\"parameter\".to_string(), \"value\".to_string()), (\"another\".to_string(), \"param\".to_string())] });",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"/another/type; param1=\\\"value1\\\"; param2=\\\"value2\\\"\";",
          "    let result = parse(input);",
          "}"
        ],
        "oracle": [
          "    let input = \"/another/type; param1=\\\"value1\\\"; param2=\\\"value2\\\"\";",
          "    let expected = Some(Mime { type_: \"another\".to_string(), subtype: \"type\".to_string(), parameters: vec![(\"param1\".to_string(), \"value1\".to_string()), (\"param2\".to_string(), \"value2\".to_string())] });",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let input = \"/another/type; param1=\\\"value1\\\"; param2=\\\"value2\\\"\";",
          "    let result = parse(input);",
          "    let input = \"/another/type; param1=\\\"value1\\\"; param2=\\\"value2\\\"\";",
          "    let expected = Some(Mime { type_: \"another\".to_string(), subtype: \"type\".to_string(), parameters: vec![(\"param1\".to_string(), \"value1\".to_string()), (\"param2\".to_string(), \"value2\".to_string())] });",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"/example/type;    parameter=\\\"value\\\"; another=param  \";",
          "    let result = parse(input);",
          "}"
        ],
        "oracle": [
          "    let input = \"/example/type;    parameter=\\\"value\\\"; another=param  \";",
          "    let expected = Some(Mime {",
          "    type_: \"example\".to_owned(),",
          "    subtype: \"type\".to_owned(),",
          "    parameters: vec![(\"parameter\".to_owned(), \"value\".to_owned()), (\"another\".to_owned(), \"param\".to_owned())],",
          "    });",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let input = \"/example/type;    parameter=\\\"value\\\"; another=param  \";",
          "    let result = parse(input);",
          "    let input = \"/example/type;    parameter=\\\"value\\\"; another=param  \";",
          "    let expected = Some(Mime {",
          "    type_: \"example\".to_owned(),",
          "    subtype: \"type\".to_owned(),",
          "    parameters: vec![(\"parameter\".to_owned(), \"value\".to_owned()), (\"another\".to_owned(), \"param\".to_owned())],",
          "    });",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"/example/type\";",
          "    let result = parse(input);",
          "}"
        ],
        "oracle": [
          "    let input = \"/text/html\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"text\");",
          "    assert_eq!(mime.subtype, \"html\");",
          "    assert!(mime.parameters.is_empty());",
          "    ",
          "    let input = \"/application/json; charset=utf-8\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"application\");",
          "    assert_eq!(mime.subtype, \"json\");",
          "    assert_eq!(mime.parameters.len(), 1);",
          "    assert_eq!(mime.parameters[0], (\"charset\".to_string(), \"utf-8\".to_string()));",
          "    ",
          "    let input = \"/image/png; format=lossy\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"image\");",
          "    assert_eq!(mime.subtype, \"png\");",
          "    assert_eq!(mime.parameters.len(), 1);",
          "    assert_eq!(mime.parameters[0], (\"format\".to_string(), \"lossy\".to_string()));",
          "    ",
          "    let input = \"/audio/mpeg; bitrate=128kbps; channels=2\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"audio\");",
          "    assert_eq!(mime.subtype, \"mpeg\");",
          "    assert_eq!(mime.parameters.len(), 2);",
          "    assert_eq!(mime.parameters[0], (\"bitrate\".to_string(), \"128kbps\".to_string()));",
          "    assert_eq!(mime.parameters[1], (\"channels\".to_string(), \"2\".to_string()));"
        ],
        "code": [
          "{",
          "    let input = \"/example/type\";",
          "    let result = parse(input);",
          "    let input = \"/text/html\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"text\");",
          "    assert_eq!(mime.subtype, \"html\");",
          "    assert!(mime.parameters.is_empty());",
          "    ",
          "    let input = \"/application/json; charset=utf-8\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"application\");",
          "    assert_eq!(mime.subtype, \"json\");",
          "    assert_eq!(mime.parameters.len(), 1);",
          "    assert_eq!(mime.parameters[0], (\"charset\".to_string(), \"utf-8\".to_string()));",
          "    ",
          "    let input = \"/image/png; format=lossy\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"image\");",
          "    assert_eq!(mime.subtype, \"png\");",
          "    assert_eq!(mime.parameters.len(), 1);",
          "    assert_eq!(mime.parameters[0], (\"format\".to_string(), \"lossy\".to_string()));",
          "    ",
          "    let input = \"/audio/mpeg; bitrate=128kbps; channels=2\";",
          "    let result = parse(input);",
          "    assert!(result.is_some());",
          "    let mime = result.unwrap();",
          "    assert_eq!(mime.type_, \"audio\");",
          "    assert_eq!(mime.subtype, \"mpeg\");",
          "    assert_eq!(mime.parameters.len(), 2);",
          "    assert_eq!(mime.parameters[0], (\"bitrate\".to_string(), \"128kbps\".to_string()));",
          "    assert_eq!(mime.parameters[1], (\"channels\".to_string(), \"2\".to_string()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]