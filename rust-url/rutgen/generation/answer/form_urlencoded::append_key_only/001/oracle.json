[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "}"
        ],
        "oracle": [
          "    string == \"key\"",
          "    string.len() == 3",
          "    start_position == 0",
          "    encoding.is_none()",
          "    name == \"key\"",
          "    append_separator_if_needed called with start_position 0",
          "    append_encoded called with name \"key\"",
          "    append_encoded modifies string to include encoded name",
          "    string has no '&' prior to the addition of \"key\""
        ],
        "code": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    string == \"key\"",
          "    string.len() == 3",
          "    start_position == 0",
          "    encoding.is_none()",
          "    name == \"key\"",
          "    append_separator_if_needed called with start_position 0",
          "    append_encoded called with name \"key\"",
          "    append_encoded modifies string to include encoded name",
          "    string has no '&' prior to the addition of \"key\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut string = String::from(\"existing=value\");",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(string, \"existing=value&key\");",
          "    assert_eq!(string.len(), 18);",
          "    assert_eq!(string.contains(\"key\"), true);",
          "    assert!(string.starts_with(\"existing=value&\"));",
          "    assert!(string.ends_with(\"key\"));",
          "    assert!(string.contains(\"&\"));"
        ],
        "code": [
          "{",
          "    let mut string = String::from(\"existing=value\");",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    assert_eq!(string, \"existing=value&key\");",
          "    assert_eq!(string.len(), 18);",
          "    assert_eq!(string.contains(\"key\"), true);",
          "    assert!(string.starts_with(\"existing=value&\"));",
          "    assert!(string.ends_with(\"key\"));",
          "    assert!(string.contains(\"&\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut string = String::from(\"existing=value\");",
          "    let start_position = 15; // start_position equal to string.len()",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(string, \"existing=value&key\");",
          "    assert_eq!(string.len(), 20);",
          "    assert!(string.contains(\"key\"));",
          "    assert!(!string.contains(\"&key=\"));",
          "    assert!(string.starts_with(\"existing=value&\"));"
        ],
        "code": [
          "{",
          "    let mut string = String::from(\"existing=value\");",
          "    let start_position = 15; // start_position equal to string.len()",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    assert_eq!(string, \"existing=value&key\");",
          "    assert_eq!(string.len(), 20);",
          "    assert!(string.contains(\"key\"));",
          "    assert!(!string.contains(\"&key=\"));",
          "    assert!(string.starts_with(\"existing=value&\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(string.len(), 0);",
          "    assert_eq!(string, \"\");",
          "    assert!(string.is_empty());",
          "    assert!(string.contains(\"&\") == false);",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    assert_eq!(string.len(), 0);"
        ],
        "code": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    assert_eq!(string.len(), 0);",
          "    assert_eq!(string, \"\");",
          "    assert!(string.is_empty());",
          "    assert!(string.contains(\"&\") == false);",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    assert_eq!(string.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = Some(&|s: &str| s.as_bytes().to_vec().into());",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(string, \"key\");",
          "    assert_eq!(string.len(), 3);",
          "    assert!(string.is_ascii());",
          "    assert!(string.contains(\"&\") == false);",
          "    assert!(string.ends_with(\"key\"));"
        ],
        "code": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = Some(&|s: &str| s.as_bytes().to_vec().into());",
          "    let name = \"key\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    assert_eq!(string, \"key\");",
          "    assert_eq!(string.len(), 3);",
          "    assert!(string.is_ascii());",
          "    assert!(string.contains(\"&\") == false);",
          "    assert!(string.ends_with(\"key\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key with spaces & special#chars!\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "}"
        ],
        "oracle": [
          "    string == \"key%20with%20spaces%20%26%20special%23chars!\"",
          "    string.len() == 39",
          "    string.is_empty() == false",
          "    start_position == 0",
          "    encoding.is_none() == true",
          "    name == \"key with spaces & special#chars!\""
        ],
        "code": [
          "{",
          "    let mut string = String::new();",
          "    let start_position = 0;",
          "    let encoding: EncodingOverride = None;",
          "    let name = \"key with spaces & special#chars!\";",
          "    append_key_only(&mut string, start_position, encoding, name);",
          "    string == \"key%20with%20spaces%20%26%20special%23chars!\"",
          "    string.len() == 39",
          "    string.is_empty() == false",
          "    start_position == 0",
          "    encoding.is_none() == true",
          "    name == \"key with spaces & special#chars!\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]