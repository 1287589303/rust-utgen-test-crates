[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application/json\\\"\"),",
          "        subtype: String::from(\"vnd.api+json\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert!(format!(\"{}\", mime).is_err());",
          "    assert_eq!(format!(\"{}\", mime).unwrap_err().to_string(), \"error message indicating write_str failed\");"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application/json\\\"\"),",
          "        subtype: String::from(\"vnd.api+json\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert!(format!(\"{}\", mime).is_err());",
          "    assert_eq!(format!(\"{}\", mime).unwrap_err().to_string(), \"error message indicating write_str failed\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application\"),",
          "        subtype: String::from(\"json\\\\\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{}\", mime), \"application/json\\\\\");",
          "    ",
          "    let mime_err = Mime {",
          "    type_: String::from(\"\"),",
          "    subtype: String::from(\"json\"),",
          "    parameters: Vec::new(),",
          "    };",
          "    assert!(format!(\"{}\", mime_err).is_err());",
          "    ",
          "    let mime_special_char = Mime {",
          "    type_: String::from(\"text\"),",
          "    subtype: String::from(\"html\"),",
          "    parameters: vec![(String::from(\"charset\"), String::from(\"utf-8\"))],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_special_char), \"text/html;charset=\\\"utf-8\\\"\");",
          "    ",
          "    let mime_empty_value = Mime {",
          "    type_: String::from(\"application\"),",
          "    subtype: String::from(\"json\"),",
          "    parameters: vec![(String::from(\"schema\"), String::from(\"\"))],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_empty_value), \"application/json;schema=\\\"\\\"\");",
          "    ",
          "    let mime_complex = Mime {",
          "    type_: String::from(\"application\"),",
          "    subtype: String::from(\"xml\"),",
          "    parameters: vec![",
          "    (String::from(\"type\"), String::from(\"example\")),",
          "    (String::from(\"version\"), String::from(\"1.0\")),",
          "    ],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_complex), \"application/xml;type=example;version=1.0\");",
          "    ",
          "    let mime_escape = Mime {",
          "    type_: String::from(\"application\"),",
          "    subtype: String::from(\"json\"),",
          "    parameters: vec![(String::from(\"data\"), String::from(\"value\\\"with\\\\escape\"))],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_escape), \"application/json;data=\\\"value\\\\\\\"with\\\\\\\\escape\\\"\");"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application\"),",
          "        subtype: String::from(\"json\\\\\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert_eq!(format!(\"{}\", mime), \"application/json\\\\\");",
          "    ",
          "    let mime_err = Mime {",
          "    type_: String::from(\"\"),",
          "    subtype: String::from(\"json\"),",
          "    parameters: Vec::new(),",
          "    };",
          "    assert!(format!(\"{}\", mime_err).is_err());",
          "    ",
          "    let mime_special_char = Mime {",
          "    type_: String::from(\"text\"),",
          "    subtype: String::from(\"html\"),",
          "    parameters: vec![(String::from(\"charset\"), String::from(\"utf-8\"))],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_special_char), \"text/html;charset=\\\"utf-8\\\"\");",
          "    ",
          "    let mime_empty_value = Mime {",
          "    type_: String::from(\"application\"),",
          "    subtype: String::from(\"json\"),",
          "    parameters: vec![(String::from(\"schema\"), String::from(\"\"))],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_empty_value), \"application/json;schema=\\\"\\\"\");",
          "    ",
          "    let mime_complex = Mime {",
          "    type_: String::from(\"application\"),",
          "    subtype: String::from(\"xml\"),",
          "    parameters: vec![",
          "    (String::from(\"type\"), String::from(\"example\")),",
          "    (String::from(\"version\"), String::from(\"1.0\")),",
          "    ],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_complex), \"application/xml;type=example;version=1.0\");",
          "    ",
          "    let mime_escape = Mime {",
          "    type_: String::from(\"application\"),",
          "    subtype: String::from(\"json\"),",
          "    parameters: vec![(String::from(\"data\"), String::from(\"value\\\"with\\\\escape\"))],",
          "    };",
          "    assert_eq!(format!(\"{}\", mime_escape), \"application/json;data=\\\"value\\\\\\\"with\\\\\\\\escape\\\"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text/plain\"),",
          "        subtype: String::from(\"charset=utf-8\"),",
          "        parameters: vec![(String::from(\"\"), String::from(\"value\"))],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    f.write_str(&self.type_)? == Err",
          "    format!(\"{}\", mime) == \"text/plain/charset=utf-8;=\\\"value\\\"\"",
          "    mime.parameters[0].0.is_empty() == true",
          "    only_http_token_code_points(mime.parameters[0].1) == false"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text/plain\"),",
          "        subtype: String::from(\"charset=utf-8\"),",
          "        parameters: vec![(String::from(\"\"), String::from(\"value\"))],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    f.write_str(&self.type_)? == Err",
          "    format!(\"{}\", mime) == \"text/plain/charset=utf-8;=\\\"value\\\"\"",
          "    mime.parameters[0].0.is_empty() == true",
          "    only_http_token_code_points(mime.parameters[0].1) == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text/html\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{}\", mime), \"text/html\");",
          "    assert!(format!(\"{}\", mime).is_empty());",
          "    assert!(fmt::Result::Ok.into() == Err(fmt::Error));"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text/html\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert_eq!(format!(\"{}\", mime), \"text/html\");",
          "    assert!(format!(\"{}\", mime).is_empty());",
          "    assert!(fmt::Result::Ok.into() == Err(fmt::Error));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application/x-www-form-urlencoded\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: vec![(String::from(\"key\"), String::from(\"value with space\"))],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(f.write_str(&mime.type_), Err(_)));",
          "    assert!(matches!(f.write_str(\"/\"), Err(_)));",
          "    assert!(matches!(f.write_str(&mime.subtype), Err(_)));",
          "    assert!(matches!(f.write_str(\";\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"key\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"=\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"value with space\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_char('v'), Err(_)));",
          "    assert!(matches!(f.write_char('a'), Err(_)));",
          "    assert!(matches!(f.write_char('l'), Err(_)));",
          "    assert!(matches!(f.write_char('u'), Err(_)));",
          "    assert!(matches!(f.write_char('e'), Err(_)));",
          "    assert!(matches!(f.write_char(' '), Err(_)));",
          "    assert!(matches!(f.write_char('w'), Err(_)));",
          "    assert!(matches!(f.write_char('i'), Err(_)));",
          "    assert!(matches!(f.write_char('t'), Err(_)));",
          "    assert!(matches!(f.write_char('h'), Err(_)));",
          "    assert!(matches!(f.write_char(' '), Err(_)));",
          "    assert!(matches!(f.write_char('s'), Err(_)));",
          "    assert!(matches!(f.write_char('p'), Err(_)));",
          "    assert!(matches!(f.write_char('a'), Err(_)));",
          "    assert!(matches!(f.write_char('c'), Err(_)));",
          "    assert!(matches!(f.write_char('e'), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_str(\";\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"key\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"=\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_str(\";\"), Err(_)));"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application/x-www-form-urlencoded\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: vec![(String::from(\"key\"), String::from(\"value with space\"))],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert!(matches!(f.write_str(&mime.type_), Err(_)));",
          "    assert!(matches!(f.write_str(\"/\"), Err(_)));",
          "    assert!(matches!(f.write_str(&mime.subtype), Err(_)));",
          "    assert!(matches!(f.write_str(\";\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"key\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"=\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"value with space\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_char('v'), Err(_)));",
          "    assert!(matches!(f.write_char('a'), Err(_)));",
          "    assert!(matches!(f.write_char('l'), Err(_)));",
          "    assert!(matches!(f.write_char('u'), Err(_)));",
          "    assert!(matches!(f.write_char('e'), Err(_)));",
          "    assert!(matches!(f.write_char(' '), Err(_)));",
          "    assert!(matches!(f.write_char('w'), Err(_)));",
          "    assert!(matches!(f.write_char('i'), Err(_)));",
          "    assert!(matches!(f.write_char('t'), Err(_)));",
          "    assert!(matches!(f.write_char('h'), Err(_)));",
          "    assert!(matches!(f.write_char(' '), Err(_)));",
          "    assert!(matches!(f.write_char('s'), Err(_)));",
          "    assert!(matches!(f.write_char('p'), Err(_)));",
          "    assert!(matches!(f.write_char('a'), Err(_)));",
          "    assert!(matches!(f.write_char('c'), Err(_)));",
          "    assert!(matches!(f.write_char('e'), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_str(\";\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"key\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"=\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_str(\"\\\"\"), Err(_)));",
          "    assert!(matches!(f.write_str(\";\"), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]