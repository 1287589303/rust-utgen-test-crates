[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{}\", mime), \"text/\");",
          "    assert!(format!(\"{}\", mime).is_err());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert_eq!(f.write_str(&self.type_).unwrap(), Ok(()));"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert_eq!(format!(\"{}\", mime), \"text/\");",
          "    assert!(format!(\"{}\", mime).is_err());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert_eq!(f.write_str(&self.type_).unwrap(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application\"),",
          "        subtype: String::from(\"json\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert!(format!(\"{}\", mime).is_err());",
          "    assert_eq!(format!(\"{}\", mime).unwrap_err().kind(), std::io::ErrorKind::Other);"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application\"),",
          "        subtype: String::from(\"json\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert!(format!(\"{}\", mime).is_err());",
          "    assert_eq!(format!(\"{}\", mime).unwrap_err().kind(), std::io::ErrorKind::Other);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text/html\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{}\", mime), \"text/html\");",
          "    assert!(format!(\"{}\", mime).is_ok());",
          "    assert!(f.write_str(&self.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert!(mime.parameters.is_empty());",
          "    assert!(mime.subtype.is_empty());",
          "    assert_eq!(mime.type_, \"text/html\");"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text/html\"),",
          "        subtype: String::from(\"\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert_eq!(format!(\"{}\", mime), \"text/html\");",
          "    assert!(format!(\"{}\", mime).is_ok());",
          "    assert!(f.write_str(&self.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert!(mime.parameters.is_empty());",
          "    assert!(mime.subtype.is_empty());",
          "    assert_eq!(mime.type_, \"text/html\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"\"),",
          "        subtype: String::from(\"plain\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    format!(\"{}\", mime); assert_eq!(err.kind(), fmt::Error);"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"\"),",
          "        subtype: String::from(\"plain\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    format!(\"{}\", mime); assert_eq!(err.kind(), fmt::Error);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"image\"),",
          "        subtype: String::from(\"png\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    f.write_str(&self.type_)? == Ok(());",
          "    f.write_str(\"/\")? == Err(fmt::Error);"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"image\"),",
          "        subtype: String::from(\"png\"),",
          "        parameters: Vec::new(),",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    f.write_str(&self.type_)? == Ok(());",
          "    f.write_str(\"/\")? == Err(fmt::Error);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text\"),",
          "        subtype: String::from(\"plain\"),",
          "        parameters: vec![(",
          "            String::from(\"charset\"),",
          "            String::from(\"utf-8\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(fmt(&mime), Err(fmt::Error));",
          "    assert!(f.write_str(&mime.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert_eq!(fmt(&mime), Ok(()));",
          "    assert_eq!(format!(\"{}\", mime), \"text/plain;charset=\\\"utf-8\\\"\");"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text\"),",
          "        subtype: String::from(\"plain\"),",
          "        parameters: vec![(",
          "            String::from(\"charset\"),",
          "            String::from(\"utf-8\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert_eq!(fmt(&mime), Err(fmt::Error));",
          "    assert!(f.write_str(&mime.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert_eq!(fmt(&mime), Ok(()));",
          "    assert_eq!(format!(\"{}\", mime), \"text/plain;charset=\\\"utf-8\\\"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application\"),",
          "        subtype: String::from(\"json\"),",
          "        parameters: vec![(",
          "            String::from(\"quoter\"),",
          "            String::from(\"\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(fmt(&mime), Err(fmt::Error));",
          "    assert!(f.write_str(&mime.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert_eq!(mime.parameters.len(), 1);",
          "    assert_eq!(mime.parameters[0].0, \"quoter\");",
          "    assert_eq!(mime.parameters[0].1, \"\");"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"application\"),",
          "        subtype: String::from(\"json\"),",
          "        parameters: vec![(",
          "            String::from(\"quoter\"),",
          "            String::from(\"\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert_eq!(fmt(&mime), Err(fmt::Error));",
          "    assert!(f.write_str(&mime.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());",
          "    assert_eq!(mime.parameters.len(), 1);",
          "    assert_eq!(mime.parameters[0].0, \"quoter\");",
          "    assert_eq!(mime.parameters[0].1, \"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"test\"),",
          "        subtype: String::from(\"xml\"),",
          "        parameters: vec![(",
          "            String::from(\"version\"),",
          "            String::from(\"1.0\"),",
          "        ), (",
          "            String::from(\"description\"),",
          "            String::from(\"A \\\"test\\\" with backslash \\\\ and quote\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    f.write_str(&self.type_)? == Ok(())",
          "    f.write_str(\"/\")? == Err(())",
          "    only_http_token_code_points(\"1.0\") == true",
          "    only_http_token_code_points(\"A \\\"test\\\" with backslash \\\\ and quote\") == false",
          "    f.write_str(\";\")? == Ok(())",
          "    f.write_str(\"version\")? == Ok(())",
          "    f.write_str(\"=\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_char('1')? == Ok(())",
          "    f.write_char('.')? == Ok(())",
          "    f.write_char('0')? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\";\")? == Ok(())",
          "    f.write_str(\"description\")? == Ok(())",
          "    f.write_str(\"=\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\"\\\\\")? == Ok(())",
          "    f.write_str(\"A\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\"test\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"with\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"backslash\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"\\\\\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"and\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"quote\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"test\"),",
          "        subtype: String::from(\"xml\"),",
          "        parameters: vec![(",
          "            String::from(\"version\"),",
          "            String::from(\"1.0\"),",
          "        ), (",
          "            String::from(\"description\"),",
          "            String::from(\"A \\\"test\\\" with backslash \\\\ and quote\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    f.write_str(&self.type_)? == Ok(())",
          "    f.write_str(\"/\")? == Err(())",
          "    only_http_token_code_points(\"1.0\") == true",
          "    only_http_token_code_points(\"A \\\"test\\\" with backslash \\\\ and quote\") == false",
          "    f.write_str(\";\")? == Ok(())",
          "    f.write_str(\"version\")? == Ok(())",
          "    f.write_str(\"=\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_char('1')? == Ok(())",
          "    f.write_char('.')? == Ok(())",
          "    f.write_char('0')? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\";\")? == Ok(())",
          "    f.write_str(\"description\")? == Ok(())",
          "    f.write_str(\"=\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\"\\\\\")? == Ok(())",
          "    f.write_str(\"A\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\"test\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"with\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"backslash\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"\\\\\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"and\")? == Ok(())",
          "    f.write_str(\" \")? == Ok(())",
          "    f.write_str(\"quote\")? == Ok(())",
          "    f.write_str(\"\\\"\")? == Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text\"),",
          "        subtype: String::from(\"plain\"),",
          "        parameters: vec![(",
          "            String::from(\"charset\"),",
          "            String::from(\"utf-8\"),",
          "        ), (",
          "            String::from(\"invalid\"),",
          "            String::from(\"value with space\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(fmt(&mime), Err(fmt::Error));",
          "    assert!(f.write_str(&mime.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());"
        ],
        "code": [
          "{",
          "    let mime = Mime {",
          "        type_: String::from(\"text\"),",
          "        subtype: String::from(\"plain\"),",
          "        parameters: vec![(",
          "            String::from(\"charset\"),",
          "            String::from(\"utf-8\"),",
          "        ), (",
          "            String::from(\"invalid\"),",
          "            String::from(\"value with space\"),",
          "        )],",
          "    };",
          "    let _ = format!(\"{}\", mime);",
          "    assert_eq!(fmt(&mime), Err(fmt::Error));",
          "    assert!(f.write_str(&mime.type_).is_ok());",
          "    assert!(f.write_str(\"/\").is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]