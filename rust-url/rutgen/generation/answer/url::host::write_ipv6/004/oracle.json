[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "struct FailingWriter {",
      "    write_calls: usize,",
      "}",
      "",
      "impl fmt::Write for FailingWriter {",
      "    fn write_str(&mut self, s: &str) -> fmt::Result {",
      "        if self.write_calls > 0 {",
      "            self.write_calls -= 1;",
      "            if s == \":\" {",
      "                return Err(fmt::Error);",
      "            }",
      "        }",
      "        Ok(())",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 0, 1, 2, 3, 4, 5, 6], // should trigger compression",
          "    };",
          "",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "}"
        ],
        "oracle": [
          "    let addr = TestIpv6Addr { segments: [0, 0, 1, 2, 3, 4, 5, 6] };",
          "    let mut writer = FailingWriter { write_calls: 1 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Err(fmt::Error));"
        ],
        "code": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 0, 1, 2, 3, 4, 5, 6], // should trigger compression",
          "    };",
          "",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "    let addr = TestIpv6Addr { segments: [0, 0, 1, 2, 3, 4, 5, 6] };",
          "    let mut writer = FailingWriter { write_calls: 1 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Err(fmt::Error));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 0, 0, 0, 1, 2, 3, 4], // triggers multiple segments with a 0 sequence",
          "    };",
          "",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "}"
        ],
        "oracle": [
          "    let mut writer = FailingWriter { write_calls: 1 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Err(fmt::Error));",
          "    let mut writer = FailingWriter { write_calls: 0 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Ok(()));",
          "    let addr = TestIpv6Addr { segments: [0, 0, 0, 0, 0, 0, 0, 1] };",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "    assert_eq!(buf, \"::1\");"
        ],
        "code": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 0, 0, 0, 1, 2, 3, 4], // triggers multiple segments with a 0 sequence",
          "    };",
          "",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "    let mut writer = FailingWriter { write_calls: 1 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Err(fmt::Error));",
          "    let mut writer = FailingWriter { write_calls: 0 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Ok(()));",
          "    let addr = TestIpv6Addr { segments: [0, 0, 0, 0, 0, 0, 0, 1] };",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "    assert_eq!(buf, \"::1\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 0, 0, 0, 0, 1, 2, 3], // compress_start and compress_end below 8",
          "    };",
          "",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "}"
        ],
        "oracle": [
          "    let mut writer = FailingWriter { write_calls: 1 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Ok(()));",
          "    let segments = addr.segments();",
          "    assert_eq!(segments[0], 0);",
          "    assert_eq!(segments[1], 0);",
          "    assert_eq!(segments[2], 0);",
          "    assert_eq!(segments[3], 0);",
          "    assert_eq!(segments[4], 0);",
          "    assert_eq!(segments[5], 1);",
          "    assert_eq!(segments[6], 2);",
          "    assert_eq!(segments[7], 3);",
          "    assert!(writer.write_str(\":\").is_err());",
          "    assert!(writer.write_str(\":\").is_ok());"
        ],
        "code": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 0, 0, 0, 0, 1, 2, 3], // compress_start and compress_end below 8",
          "    };",
          "",
          "    let mut buf = String::new();",
          "    let result = write_ipv6(&addr, &mut buf);",
          "    let mut writer = FailingWriter { write_calls: 1 };",
          "    let result = write_ipv6(&addr, &mut writer);",
          "    assert_eq!(result, Ok(()));",
          "    let segments = addr.segments();",
          "    assert_eq!(segments[0], 0);",
          "    assert_eq!(segments[1], 0);",
          "    assert_eq!(segments[2], 0);",
          "    assert_eq!(segments[3], 0);",
          "    assert_eq!(segments[4], 0);",
          "    assert_eq!(segments[5], 1);",
          "    assert_eq!(segments[6], 2);",
          "    assert_eq!(segments[7], 3);",
          "    assert!(writer.write_str(\":\").is_err());",
          "    assert!(writer.write_str(\":\").is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 1, 0, 0, 0, 1, 2, 3], // will allow for the first colon but fail on second",
          "    };",
          "",
          "    let mut failing_writer = FailingWriter {",
          "        write_calls: 1, // fails after the first call",
          "    };",
          "    ",
          "    let result = write_ipv6(&addr, &mut failing_writer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Err(fmt::Error));",
          "    assert!(failing_writer.write_calls == 0);",
          "    assert!(addr.segments() == [0, 1, 0, 0, 0, 1, 2, 3]);",
          "    assert!(longest_zero_sequence(&addr.segments()).0 == -1);",
          "    assert!(longest_zero_sequence(&addr.segments()).1 == -2);",
          "    assert!(write_ipv6(&addr, &mut failing_writer).is_err());",
          "    assert!(failing_writer.write_calls == 0);",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    struct TestIpv6Addr {",
          "        segments: [u16; 8],",
          "    }",
          "",
          "    impl Ipv6Addr for TestIpv6Addr {",
          "        fn segments(&self) -> &[u16; 8] {",
          "            &self.segments",
          "        }",
          "    }",
          "",
          "    let addr = TestIpv6Addr {",
          "        segments: [0, 1, 0, 0, 0, 1, 2, 3], // will allow for the first colon but fail on second",
          "    };",
          "",
          "    let mut failing_writer = FailingWriter {",
          "        write_calls: 1, // fails after the first call",
          "    };",
          "    ",
          "    let result = write_ipv6(&addr, &mut failing_writer);",
          "    assert_eq!(result, Err(fmt::Error));",
          "    assert!(failing_writer.write_calls == 0);",
          "    assert!(addr.segments() == [0, 1, 0, 0, 0, 1, 2, 3]);",
          "    assert!(longest_zero_sequence(&addr.segments()).0 == -1);",
          "    assert!(longest_zero_sequence(&addr.segments()).1 == -2);",
          "    assert!(write_ipv6(&addr, &mut failing_writer).is_err());",
          "    assert!(failing_writer.write_calls == 0);",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]