[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let invalid_input = Input { chars: \"%G1\".chars() }; // 'G' is not a valid ASCII hex digit",
          "    check_url_code_point(|violation| {",
          "        // This closure will be triggered for SyntaxViolation::PercentDecode",
          "    }, '%', &invalid_input);",
          "}"
        ],
        "oracle": [
          "    let invalid_input = Input { chars: \"%G1\".chars() }; // 'G' is not a valid ASCII hex digit",
          "    check_url_code_point(|violation| assert_eq!(violation, SyntaxViolation::PercentDecode), '%', &invalid_input);"
        ],
        "code": [
          "{",
          "    let invalid_input = Input { chars: \"%G1\".chars() }; // 'G' is not a valid ASCII hex digit",
          "    check_url_code_point(|violation| {",
          "        // This closure will be triggered for SyntaxViolation::PercentDecode",
          "    }, '%', &invalid_input);",
          "    let invalid_input = Input { chars: \"%G1\".chars() }; // 'G' is not a valid ASCII hex digit",
          "    check_url_code_point(|violation| assert_eq!(violation, SyntaxViolation::PercentDecode), '%', &invalid_input);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let invalid_input = Input { chars: \"&%20\".chars() }; // '&' is a valid char but we want to ensure the point is tested",
          "    check_url_code_point(|violation| {",
          "        // This closure will be triggered for SyntaxViolation::NonUrlCodePoint",
          "    }, '%', &invalid_input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"&%20\".chars() }), SyntaxViolation::PercentDecode);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"%41\".chars() }), SyntaxViolation::NonUrlCodePoint);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"a%20\".chars() }), SyntaxViolation::NonUrlCodePoint);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"%ZZ\".chars() }), SyntaxViolation::PercentDecode);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"%G5\".chars() }), SyntaxViolation::PercentDecode);"
        ],
        "code": [
          "{",
          "    let invalid_input = Input { chars: \"&%20\".chars() }; // '&' is a valid char but we want to ensure the point is tested",
          "    check_url_code_point(|violation| {",
          "        // This closure will be triggered for SyntaxViolation::NonUrlCodePoint",
          "    }, '%', &invalid_input);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"&%20\".chars() }), SyntaxViolation::PercentDecode);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"%41\".chars() }), SyntaxViolation::NonUrlCodePoint);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"a%20\".chars() }), SyntaxViolation::NonUrlCodePoint);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"%ZZ\".chars() }), SyntaxViolation::PercentDecode);",
          "    assert_eq!(check_url_code_point(|violation| violation, '%', &Input { chars: \"%G5\".chars() }), SyntaxViolation::PercentDecode);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let invalid_input = Input { chars: \"%@2\".chars() }; // '@' is not a valid URL code point here",
          "    check_url_code_point(|violation| {",
          "        // This closure will be triggered for SyntaxViolation::NonUrlCodePoint",
          "    }, '%', &invalid_input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_url_code_point(|v| v, '%', &Input { chars: \"%@2\".chars() }), SyntaxViolation::NonUrlCodePoint);"
        ],
        "code": [
          "{",
          "    let invalid_input = Input { chars: \"%@2\".chars() }; // '@' is not a valid URL code point here",
          "    check_url_code_point(|violation| {",
          "        // This closure will be triggered for SyntaxViolation::NonUrlCodePoint",
          "    }, '%', &invalid_input);",
          "    assert_eq!(check_url_code_point(|v| v, '%', &Input { chars: \"%@2\".chars() }), SyntaxViolation::NonUrlCodePoint);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]