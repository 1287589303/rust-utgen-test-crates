[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Input {",
          "        chars: \"%%01\".chars(), // '%' followed by two valid ASCII hex digits '01'",
          "    };",
          "    let mock_violation_fn = |violation: SyntaxViolation| {",
          "        panic!(\"Expected no violation, received: {:?}\", violation);",
          "    };",
          "    ",
          "    check_url_code_point(&mock_violation_fn, '%', &input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_url_code_point(&mock_violation_fn, '%', &input), ());",
          "    ",
          "    let input = Input {",
          "    chars: \"%%ab\".chars(), // '%' followed by two valid ASCII hex digits 'ab'",
          "    };",
          "    check_url_code_point(&mock_violation_fn, '%', &input);",
          "    ",
          "    let input = Input {",
          "    chars: \"%%FF\".chars(), // '%' followed by two valid ASCII hex digits 'FF'",
          "    };",
          "    check_url_code_point(&mock_violation_fn, '%', &input);"
        ],
        "code": [
          "{",
          "    let input = Input {",
          "        chars: \"%%01\".chars(), // '%' followed by two valid ASCII hex digits '01'",
          "    };",
          "    let mock_violation_fn = |violation: SyntaxViolation| {",
          "        panic!(\"Expected no violation, received: {:?}\", violation);",
          "    };",
          "    ",
          "    check_url_code_point(&mock_violation_fn, '%', &input);",
          "    assert_eq!(check_url_code_point(&mock_violation_fn, '%', &input), ());",
          "    ",
          "    let input = Input {",
          "    chars: \"%%ab\".chars(), // '%' followed by two valid ASCII hex digits 'ab'",
          "    };",
          "    check_url_code_point(&mock_violation_fn, '%', &input);",
          "    ",
          "    let input = Input {",
          "    chars: \"%%FF\".chars(), // '%' followed by two valid ASCII hex digits 'FF'",
          "    };",
          "    check_url_code_point(&mock_violation_fn, '%', &input);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Input {",
          "        chars: \"%GZ\".chars(), // '%' followed by non-hex characters 'G' and 'Z'",
          "    };",
          "    let mock_violation_fn = |violation: SyntaxViolation| { ",
          "        assert_eq!(violation, SyntaxViolation::PercentDecode); ",
          "    };",
          "    ",
          "    check_url_code_point(&mock_violation_fn, '%', &input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"%GZ\".chars() }), SyntaxViolation::PercentDecode);"
        ],
        "code": [
          "{",
          "    let input = Input {",
          "        chars: \"%GZ\".chars(), // '%' followed by non-hex characters 'G' and 'Z'",
          "    };",
          "    let mock_violation_fn = |violation: SyntaxViolation| { ",
          "        assert_eq!(violation, SyntaxViolation::PercentDecode); ",
          "    };",
          "    ",
          "    check_url_code_point(&mock_violation_fn, '%', &input);",
          "    assert_eq!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"%GZ\".chars() }), SyntaxViolation::PercentDecode);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Input {",
          "        chars: \"A%12\".chars(), // 'A' is a valid URL code point and '%' followed by valid ASCII hex digits",
          "    };",
          "    let mock_violation_fn = |violation: SyntaxViolation| {",
          "        panic!(\"Expected no violation, received: {:?}\", violation);",
          "    };",
          "    ",
          "    check_url_code_point(&mock_violation_fn, 'A', &input);",
          "}"
        ],
        "oracle": [
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &input).is_ok());",
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"%FF\".chars() }).is_err());",
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"A%G1\".chars() }).is_err());",
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"A%4F\".chars() }).is_ok());"
        ],
        "code": [
          "{",
          "    let input = Input {",
          "        chars: \"A%12\".chars(), // 'A' is a valid URL code point and '%' followed by valid ASCII hex digits",
          "    };",
          "    let mock_violation_fn = |violation: SyntaxViolation| {",
          "        panic!(\"Expected no violation, received: {:?}\", violation);",
          "    };",
          "    ",
          "    check_url_code_point(&mock_violation_fn, 'A', &input);",
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &input).is_ok());",
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"%FF\".chars() }).is_err());",
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"A%G1\".chars() }).is_err());",
          "    assert!(check_url_code_point(&mock_violation_fn, '%', &Input { chars: \"A%4F\".chars() }).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]