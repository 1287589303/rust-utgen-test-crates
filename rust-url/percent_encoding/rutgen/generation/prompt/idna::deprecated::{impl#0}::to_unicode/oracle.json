{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// idna/src/deprecated.rs\n// crate name is idna\nuse alloc::borrow::Cow;\nuse alloc::string::String;\nuse crate::uts46::*;\nuse crate::Errors;\n#[derive(Default)]\n#[deprecated]\npub struct Idna {\n    config: Config,\n}\npub struct Uts46 {\n    data: idna_adapter::Adapter,\n}\n#[derive(Clone, Copy)]\n#[must_use]\n#[deprecated]\npub struct Config {\n    use_std3_ascii_rules: bool,\n    transitional_processing: bool,\n    verify_dns_length: bool,\n    check_hyphens: bool,\n}\n#[derive(PartialEq, Eq, Copy, Clone)]\n#[repr(transparent)]\npub struct AsciiDenyList {\n    bits: u128,\n}\n#[derive(Default, Debug)]\n#[non_exhaustive]\npub struct Errors {}\n#[derive(PartialEq, Eq, Copy, Clone, Debug)]\npub enum ProcessingSuccess {\n    /// There were no errors. The caller must consider the input to be the output.\n    ///\n    /// This asserts that the input can be safely passed to [`core::str::from_utf8_unchecked`].\n    ///\n    /// (Distinct from `WroteToSink` in order to allow `Cow` behavior to be implemented on top of\n    /// [`Uts46::process`].)\n    Passthrough,\n    /// There were no errors. The caller must consider what was written to the sink to be the output.\n    ///\n    /// (Distinct from `Passthrough` in order to allow `Cow` behavior to be implemented on top of\n    /// [`Uts46::process`].)\n    WroteToSink,\n}\n#[derive(PartialEq, Eq, Copy, Clone)]\n#[non_exhaustive]\npub enum Hyphens {\n    /// _CheckHyphens=false_: Do not place positional restrictions on hyphens.\n    ///\n    /// This mode is used by the WHATWG URL Standard for normal User Agent processing\n    /// (i.e. not conformance checking).\n    Allow,\n    /// Prohibit hyphens in the first and last position in the label but allow in\n    /// the third and fourth position.\n    ///\n    /// Note that this mode rejects real-world names, including some GitHub user pages.\n    CheckFirstLast,\n    /// _CheckHyphens=true_: Prohibit hyphens in the first, third, fourth,\n    /// and last position in the label.\n    ///\n    /// Note that this mode rejects real-world names, including YouTube CDN nodes\n    /// and some GitHub user pages.\n    Check,\n}\n#[derive(PartialEq, Eq, Copy, Clone, Debug)]\npub enum ProcessingError {\n    /// There was a validity error according to the chosen options.\n    ///\n    /// In case of `Operation::ToAscii`, there is no output. Otherwise, output was written to the\n    /// sink and the output contains at least one U+FFFD REPLACEMENT CHARACTER to denote an error.\n    ValidityError,\n    /// The sink emitted [`core::fmt::Error`]. The partial output written to the sink must not\n    /// be used.\n    SinkError,\n}\n#[derive(PartialEq, Eq, Copy, Clone)]\n#[non_exhaustive]\npub enum ErrorPolicy {\n    /// Return as early as possible without producing output in case of error.\n    FailFast,\n    /// In case of error, mark errors with the REPLACEMENT CHARACTER. (The output\n    /// containing REPLACEMENT CHARACTERs may be show to the user to illustrate\n    /// what was wrong but must not be used for naming in a network protocol.)\n    MarkErrors,\n}\nimpl Idna {\n    pub fn new(config: Config) -> Self {\n        Self { config }\n    }\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_ascii(&mut self, domain: &str, out: &mut String) -> Result<(), Errors> {}\n    #[allow(clippy::wrong_self_convention)]\n    pub fn to_unicode(&mut self, domain: &str, out: &mut String) -> Result<(), Errors> {\n        let mapped = map_transitional(domain, self.config.transitional_processing);\n        match Uts46::new()\n            .process(\n                mapped.as_bytes(),\n                self.config.deny_list(),\n                self.config.hyphens(),\n                ErrorPolicy::MarkErrors,\n                |_, _, _| true,\n                out,\n                None,\n            )\n        {\n            Ok(ProcessingSuccess::Passthrough) => {\n                out.push_str(&mapped);\n                Ok(())\n            }\n            Ok(ProcessingSuccess::WroteToSink) => Ok(()),\n            Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n            Err(ProcessingError::SinkError) => unreachable!(),\n        }\n    }\n}\nimpl Uts46 {\n    #[cfg(feature = \"compiled_data\")]\n    pub const fn new() -> Self {\n        Self {\n            data: idna_adapter::Adapter::new(),\n        }\n    }\n    pub fn to_ascii<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        dns_length: DnsLength,\n    ) -> Result<Cow<'a, str>, crate::Errors> {}\n    pub fn to_unicode<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n    ) -> (Cow<'a, str>, Result<(), crate::Errors>) {}\n    pub fn to_user_interface<'a, OutputUnicode: FnMut(&[char], &[char], bool) -> bool>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        output_as_unicode: OutputUnicode,\n    ) -> (Cow<'a, str>, Result<(), crate::Errors>) {}\n    #[allow(clippy::too_many_arguments)]\n    pub fn process<\n        W: Write + ?Sized,\n        OutputUnicode: FnMut(&[char], &[char], bool) -> bool,\n    >(\n        &self,\n        domain_name: &[u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        error_policy: ErrorPolicy,\n        mut output_as_unicode: OutputUnicode,\n        sink: &mut W,\n        ascii_sink: Option<&mut W>,\n    ) -> Result<ProcessingSuccess, ProcessingError> {\n        let fail_fast = error_policy == ErrorPolicy::FailFast;\n        let mut domain_buffer = SmallVec::<[char; 253]>::new();\n        let mut already_punycode = SmallVec::<[AlreadyAsciiLabel; 8]>::new();\n        let (passthrough_up_to, is_bidi, had_errors) = self\n            .process_inner(\n                domain_name,\n                ascii_deny_list,\n                hyphens,\n                fail_fast,\n                &mut domain_buffer,\n                &mut already_punycode,\n            );\n        if passthrough_up_to == domain_name.len() {\n            debug_assert!(! had_errors);\n            return Ok(ProcessingSuccess::Passthrough);\n        }\n        if fail_fast && had_errors {\n            return Err(ProcessingError::ValidityError);\n        }\n        debug_assert_eq!(had_errors, domain_buffer.contains(&'\\u{FFFD}'));\n        let without_dot = if let Some(without_dot) = domain_buffer.strip_suffix(&['.']) {\n            without_dot\n        } else {\n            &domain_buffer[..]\n        };\n        let tld = without_dot.rsplit(|c| *c == '.').next().unwrap();\n        let mut had_unicode_output = false;\n        let mut seen_label = false;\n        let mut already_punycode_iter = already_punycode.iter();\n        let mut passthrough_up_to_extended = passthrough_up_to;\n        let mut flushed_prefix = false;\n        for label in domain_buffer.split(|c| *c == '.') {\n            let input_punycode = *already_punycode_iter.next().unwrap();\n            if seen_label {\n                if flushed_prefix {\n                    sink.write_char('.')?;\n                } else {\n                    debug_assert_eq!(domain_name[passthrough_up_to_extended], b'.');\n                    passthrough_up_to_extended += 1;\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(! had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            }\n            seen_label = true;\n            if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                if let Some(first_upper_case) = mixed_case\n                    .iter()\n                    .position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(slice_to_write)\n                    })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(mixed_case)\n                    })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(! had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n                continue;\n            }\n            let potentially_punycode = if fail_fast {\n                debug_assert!(\n                    classify_for_punycode(label) != PunycodeClassification::Error\n                );\n                !is_ascii(label)\n            } else {\n                classify_for_punycode(label) == PunycodeClassification::Unicode\n            };\n            let passthrough = if potentially_punycode {\n                let unicode = output_as_unicode(label, tld, is_bidi);\n                had_unicode_output |= unicode;\n                unicode\n            } else {\n                true\n            };\n            if passthrough {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(\n                            &domain_name[..passthrough_up_to_extended],\n                        )\n                    })?;\n                }\n                for c in label.iter().copied() {\n                    sink.write_char(c)?;\n                }\n            } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                if let Some(first_upper_case) = mixed_case\n                    .iter()\n                    .position(|c| c.is_ascii_uppercase())\n                {\n                    let (head, tail) = mixed_case.split_at(first_upper_case);\n                    let slice_to_write = if flushed_prefix {\n                        head\n                    } else {\n                        flushed_prefix = true;\n                        passthrough_up_to_extended += head.len();\n                        debug_assert_ne!(passthrough_up_to_extended, domain_name.len());\n                        &domain_name[..passthrough_up_to_extended]\n                    };\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(slice_to_write)\n                    })?;\n                    for c in tail.iter() {\n                        sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                    }\n                } else if flushed_prefix {\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(mixed_case)\n                    })?;\n                } else {\n                    passthrough_up_to_extended += mixed_case.len();\n                    if passthrough_up_to_extended == domain_name.len() {\n                        debug_assert!(! had_errors);\n                        return Ok(ProcessingSuccess::Passthrough);\n                    }\n                }\n            } else {\n                if !flushed_prefix {\n                    flushed_prefix = true;\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(\n                            &domain_name[..passthrough_up_to_extended],\n                        )\n                    })?;\n                }\n                write_punycode_label(label, sink)?;\n            }\n        }\n        if had_errors {\n            return Err(ProcessingError::ValidityError);\n        }\n        if had_unicode_output {\n            if let Some(sink) = ascii_sink {\n                let mut seen_label = false;\n                let mut already_punycode_iter = already_punycode.iter();\n                let mut passthrough_up_to_extended = passthrough_up_to;\n                let mut flushed_prefix = false;\n                for label in domain_buffer.split(|c| *c == '.') {\n                    let input_punycode = *already_punycode_iter.next().unwrap();\n                    if seen_label {\n                        if flushed_prefix {\n                            sink.write_char('.')?;\n                        } else {\n                            debug_assert_eq!(\n                                domain_name[passthrough_up_to_extended], b'.'\n                            );\n                            passthrough_up_to_extended += 1;\n                        }\n                    }\n                    seen_label = true;\n                    if let AlreadyAsciiLabel::MixedCaseAscii(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) = mixed_case\n                            .iter()\n                            .position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(\n                                    passthrough_up_to_extended, domain_name.len()\n                                );\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(mixed_case)\n                            })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                        continue;\n                    }\n                    if is_ascii(label) {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        for c in label.iter().copied() {\n                            sink.write_char(c)?;\n                        }\n                    } else if let AlreadyAsciiLabel::MixedCasePunycode(mixed_case) = input_punycode {\n                        if let Some(first_upper_case) = mixed_case\n                            .iter()\n                            .position(|c| c.is_ascii_uppercase())\n                        {\n                            let (head, tail) = mixed_case.split_at(first_upper_case);\n                            let slice_to_write = if flushed_prefix {\n                                head\n                            } else {\n                                flushed_prefix = true;\n                                passthrough_up_to_extended += head.len();\n                                debug_assert_ne!(\n                                    passthrough_up_to_extended, domain_name.len()\n                                );\n                                &domain_name[..passthrough_up_to_extended]\n                            };\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(slice_to_write)\n                            })?;\n                            for c in tail.iter() {\n                                sink.write_char(char::from(c.to_ascii_lowercase()))?;\n                            }\n                        } else if flushed_prefix {\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(mixed_case)\n                            })?;\n                        } else {\n                            passthrough_up_to_extended += mixed_case.len();\n                        }\n                    } else {\n                        if !flushed_prefix {\n                            flushed_prefix = true;\n                            sink.write_str(unsafe {\n                                core::str::from_utf8_unchecked(\n                                    &domain_name[..passthrough_up_to_extended],\n                                )\n                            })?;\n                        }\n                        write_punycode_label(label, sink)?;\n                    }\n                }\n                if !flushed_prefix {\n                    sink.write_str(unsafe {\n                        core::str::from_utf8_unchecked(\n                            &domain_name[..passthrough_up_to_extended],\n                        )\n                    })?;\n                }\n            }\n        }\n        Ok(ProcessingSuccess::WroteToSink)\n    }\n    #[inline(always)]\n    fn process_inner<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        fail_fast: bool,\n        domain_buffer: &mut SmallVec<[char; 253]>,\n        already_punycode: &mut SmallVec<[AlreadyAsciiLabel<'a>; 8]>,\n    ) -> (usize, bool, bool) {}\n    #[allow(clippy::too_many_arguments)]\n    #[inline(never)]\n    fn process_innermost<'a>(\n        &self,\n        domain_name: &'a [u8],\n        ascii_deny_list: AsciiDenyList,\n        hyphens: Hyphens,\n        fail_fast: bool,\n        domain_buffer: &mut SmallVec<[char; 253]>,\n        already_punycode: &mut SmallVec<[AlreadyAsciiLabel<'a>; 8]>,\n        tail: &'a [u8],\n    ) -> (usize, bool, bool) {}\n    #[inline(never)]\n    fn after_punycode_decode(\n        &self,\n        domain_buffer: &mut SmallVec<[char; 253]>,\n        current_label_start: usize,\n        label_buffer: &[char],\n        deny_list_deny_dot: u128,\n        fail_fast: bool,\n        had_errors: &mut bool,\n    ) -> bool {}\n    #[inline(never)]\n    fn check_label(\n        &self,\n        hyphens: Hyphens,\n        mut_label: &mut [char],\n        fail_fast: bool,\n        had_errors: &mut bool,\n        first_needs_combining_mark_check: bool,\n        needs_contextj_check: bool,\n    ) -> bool {}\n    #[inline(always)]\n    fn has_appropriately_joining_char<I: Iterator<Item = char>>(\n        &self,\n        iter: I,\n        required_mask: JoiningTypeMask,\n    ) -> bool {}\n    #[inline(always)]\n    fn is_bidi(&self, buffer: &[char]) -> bool {}\n}\nimpl Config {\n    #[inline]\n    pub fn use_std3_ascii_rules(mut self, value: bool) -> Self {\n        self.use_std3_ascii_rules = value;\n        self\n    }\n    #[inline]\n    pub fn transitional_processing(mut self, value: bool) -> Self {\n        self.transitional_processing = value;\n        self\n    }\n    #[inline]\n    pub fn verify_dns_length(mut self, value: bool) -> Self {\n        self.verify_dns_length = value;\n        self\n    }\n    #[inline]\n    pub fn check_hyphens(mut self, value: bool) -> Self {\n        self.check_hyphens = value;\n        self\n    }\n    #[inline]\n    #[allow(unused_mut)]\n    pub fn use_idna_2008_rules(mut self, value: bool) -> Self {\n        assert!(! value, \"IDNA 2008 rules are no longer supported\");\n        self\n    }\n    fn deny_list(&self) -> AsciiDenyList {\n        if self.use_std3_ascii_rules {\n            AsciiDenyList::STD3\n        } else {\n            AsciiDenyList::EMPTY\n        }\n    }\n    fn hyphens(&self) -> Hyphens {\n        if self.check_hyphens { Hyphens::CheckFirstLast } else { Hyphens::Allow }\n    }\n    pub fn to_ascii(self, domain: &str) -> Result<String, Errors> {}\n    pub fn to_unicode(self, domain: &str) -> (String, Result<(), Errors>) {}\n}\nfn map_transitional(domain: &str, transitional: bool) -> Cow<'_, str> {\n    if !transitional {\n        return Cow::Borrowed(domain);\n    }\n    let mut chars = domain.chars();\n    loop {\n        let prev = chars.clone();\n        if let Some(c) = chars.next() {\n            match c {\n                'ß' | 'ẞ' | 'ς' | '\\u{200C}' | '\\u{200D}' => {\n                    let mut s = String::with_capacity(domain.len());\n                    let tail = prev.as_str();\n                    let head = &domain[..domain.len() - tail.len()];\n                    s.push_str(head);\n                    for c in tail.chars() {\n                        match c {\n                            'ß' | 'ẞ' => {\n                                s.push_str(\"ss\");\n                            }\n                            'ς' => {\n                                s.push('σ');\n                            }\n                            '\\u{200C}' | '\\u{200D}' => {}\n                            _ => {\n                                s.push(c);\n                            }\n                        }\n                    }\n                    return Cow::Owned(s);\n                }\n                _ => {}\n            }\n        } else {\n            break;\n        }\n    }\n    Cow::Borrowed(domain)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// [UTS 46 ToUnicode](http://www.unicode.org/reports/tr46/#ToUnicode)\n109 pub fn to_unicode(&mut self, domain: &str, out: &mut String) -> Result<(), Errors> {\n110     let mapped = map_transitional(domain, self.config.transitional_processing);\n111     match Uts46::new().process(\n112         mapped.as_bytes(),\n113         self.config.deny_list(),\n114         self.config.hyphens(),\n115         ErrorPolicy::MarkErrors,\n116         |_, _, _| true,\n117         out,\n118         None,\n119     ) {\n120         Ok(ProcessingSuccess::Passthrough) => {\n121             out.push_str(&mapped);\n122             Ok(())\n123         }\n124         Ok(ProcessingSuccess::WroteToSink) => Ok(()),\n125         Err(ProcessingError::ValidityError) => Err(crate::Errors::default()),\n126         Err(ProcessingError::SinkError) => unreachable!(),\n127     }\n128 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}