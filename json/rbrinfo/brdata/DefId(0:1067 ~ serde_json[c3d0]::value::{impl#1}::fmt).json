{
  "name": "serde_json::value::{impl#1}::fmt",
  "mod_info": {
    "name": "value",
    "loc": "src/lib.rs:426:1:426:15"
  },
  "visible": true,
  "loc": "src/value/mod.rs:222:5:256:6",
  "doc": "/// Display a JSON value as a string.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let json = json!({ \"city\": \"London\", \"street\": \"10 Downing Street\" });\n///\n/// // Compact format:\n/// //\n/// // {\"city\":\"London\",\"street\":\"10 Downing Street\"}\n/// let compact = format!(\"{}\", json);\n/// assert_eq!(compact,\n///     \"{\\\"city\\\":\\\"London\\\",\\\"street\\\":\\\"10 Downing Street\\\"}\");\n///\n/// // Pretty format:\n/// //\n/// // {\n/// //   \"city\": \"London\",\n/// //   \"street\": \"10 Downing Street\"\n/// // }\n/// let pretty = format!(\"{:#}\", json);\n/// assert_eq!(pretty,\n///     \"{\\n  \\\"city\\\": \\\"London\\\",\\n  \\\"street\\\": \\\"10 Downing Street\\\"\\n}\");\n/// ```\n",
  "code": [
    "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
    "    struct WriterFormatter<'a, 'b: 'a> {",
    "        inner: &'a mut fmt::Formatter<'b>,",
    "    }",
    "",
    "    impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {",
    "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
    "            // Safety: the serializer below only emits valid utf8 when using",
    "            // the default formatter.",
    "            let s = unsafe { str::from_utf8_unchecked(buf) };",
    "            tri!(self.inner.write_str(s).map_err(io_error));",
    "            Ok(buf.len())",
    "        }",
    "",
    "        fn flush(&mut self) -> io::Result<()> {",
    "            Ok(())",
    "        }",
    "    }",
    "",
    "    fn io_error(_: fmt::Error) -> io::Error {",
    "        // Error value does not matter because Display impl just maps it",
    "        // back to fmt::Error.",
    "        io::Error::new(io::ErrorKind::Other, \"fmt error\")",
    "    }",
    "",
    "    let alternate = f.alternate();",
    "    let mut wr = WriterFormatter { inner: f };",
    "    if alternate {",
    "        // {:#}",
    "        super::ser::to_writer_pretty(&mut wr, self).map_err(|_| fmt::Error)",
    "    } else {",
    "        // {}",
    "        super::ser::to_writer(&mut wr, self).map_err(|_| fmt::Error)",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "alternate",
          "norm": null,
          "value": "true",
          "line": 249,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        8
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "alternate",
          "norm": null,
          "value": "false",
          "line": 249,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        5,
        6,
        7,
        8
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}