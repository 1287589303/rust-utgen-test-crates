[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"123.456\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, b\"123.456\");",
          "    assert!(writer.output.len() > 0);",
          "    assert_eq!(writer.output.len(), 7);",
          "    assert!(writer.output.iter().all(|&byte| byte.is_ascii()));",
          "    assert!(writer.output.contains(&b'1'));",
          "    assert!(writer.output.contains(&b'2'));",
          "    assert!(writer.output.contains(&b'.'));",
          "    assert!(writer.output.contains(&b'3'));",
          "    assert!(writer.output.contains(&b'4'));",
          "    assert!(writer.output.contains(&b'5'));",
          "    assert!(writer.output.contains(&b'6'));"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"123.456\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"123.456\");",
          "    assert!(writer.output.len() > 0);",
          "    assert_eq!(writer.output.len(), 7);",
          "    assert!(writer.output.iter().all(|&byte| byte.is_ascii()));",
          "    assert!(writer.output.contains(&b'1'));",
          "    assert!(writer.output.contains(&b'2'));",
          "    assert!(writer.output.contains(&b'.'));",
          "    assert!(writer.output.contains(&b'3'));",
          "    assert!(writer.output.contains(&b'4'));",
          "    assert!(writer.output.contains(&b'5'));",
          "    assert!(writer.output.contains(&b'6'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-123.456\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, b\"-123.456\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"0\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"3.14\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"3.14\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"1e10\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"1e10\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-0.0\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"-0.0\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"NaN\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"NaN\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"Infinity\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"Infinity\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-Infinity\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"-Infinity\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"1000000000000000\"; // Testing large number",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"1000000000000000\");"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-123.456\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"-123.456\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"0\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"3.14\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"3.14\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"1e10\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"1e10\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-0.0\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"-0.0\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"NaN\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"NaN\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"Infinity\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"Infinity\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-Infinity\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"-Infinity\");",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"1000000000000000\"; // Testing large number",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"1000000000000000\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"0\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, b\"0\");",
          "    let value = \"-123\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-123\");",
          "    let value = \"3.14159\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.14159\");",
          "    let value = \"\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.14159\");",
          "    let value = \"100000\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.14159100000\");",
          "    let value = \"9999999999999999\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999\");",
          "    let value = \"nan\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999nan\");",
          "    let value = \"inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999nainf\");",
          "    let value = \"-inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999nainf-inf\");"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"0\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0\");",
          "    let value = \"-123\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-123\");",
          "    let value = \"3.14159\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.14159\");",
          "    let value = \"\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.14159\");",
          "    let value = \"100000\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.14159100000\");",
          "    let value = \"9999999999999999\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999\");",
          "    let value = \"nan\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999nan\");",
          "    let value = \"inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999nainf\");",
          "    let value = \"-inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"0-1233.141591000009999999999999999nainf-inf\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"\";",
          "    let expected_output = b\"\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"42\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"42\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-1\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"-1\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"3.14\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"3.14\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"0\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"0\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"100000\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"100000\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"NaN\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"NaN\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"Inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"Inf\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-Inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"-Inf\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"  \";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"  \";",
          "    assert_eq!(writer.output, expected_output);"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"\";",
          "    let expected_output = b\"\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"42\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"42\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-1\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"-1\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"3.14\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"3.14\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"0\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"0\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"100000\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"100000\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"NaN\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"NaN\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"Inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"Inf\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-Inf\";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"-Inf\";",
          "    assert_eq!(writer.output, expected_output);",
          "    ",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"  \";",
          "    write_number_str(&mut writer, value).unwrap();",
          "    let expected_output = b\"  \";",
          "    assert_eq!(writer.output, expected_output);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"NaN\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, b\"NaN\");",
          "    assert!(writer.output.len() > 0);",
          "    assert!(writer.output.iter().all(|&b| b.is_ascii()));",
          "    assert!(writer.output.contains(&b'N'));",
          "    assert!(writer.output.contains(&b'a'));",
          "    assert!(writer.output.contains(&b'n'));",
          "    assert!(writer.output.contains(&b' '));",
          "    assert!(writer.output.contains(&b'\\0'));",
          "    assert!(writer.output.iter().any(|&b| b == b'\\\\'));",
          "    assert!(writer.output.iter().any(|&b| b == b'\"'));"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"NaN\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"NaN\");",
          "    assert!(writer.output.len() > 0);",
          "    assert!(writer.output.iter().all(|&b| b.is_ascii()));",
          "    assert!(writer.output.contains(&b'N'));",
          "    assert!(writer.output.contains(&b'a'));",
          "    assert!(writer.output.contains(&b'n'));",
          "    assert!(writer.output.contains(&b' '));",
          "    assert!(writer.output.contains(&b'\\0'));",
          "    assert!(writer.output.iter().any(|&b| b == b'\\\\'));",
          "    assert!(writer.output.iter().any(|&b| b == b'\"'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"Infinity\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, b\"Infinity\");",
          "    assert!(writer.output.len() > 0);",
          "    assert!(writer.output.contains(&b'I'));",
          "    assert!(writer.output.contains(&b'n'));",
          "    assert!(writer.output.contains(&b'f'));",
          "    assert!(writer.output.contains(&b'i'));",
          "    assert!(writer.output.contains(&b'n'));",
          "    assert!(writer.output.contains(&b'i'));",
          "    assert!(writer.output.contains(&b't'));",
          "    assert!(writer.output.contains(&b'y'));"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"Infinity\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"Infinity\");",
          "    assert!(writer.output.len() > 0);",
          "    assert!(writer.output.contains(&b'I'));",
          "    assert!(writer.output.contains(&b'n'));",
          "    assert!(writer.output.contains(&b'f'));",
          "    assert!(writer.output.contains(&b'i'));",
          "    assert!(writer.output.contains(&b'n'));",
          "    assert!(writer.output.contains(&b'i'));",
          "    assert!(writer.output.contains(&b't'));",
          "    assert!(writer.output.contains(&b'y'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-Infinity\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, b\"-Infinity\");",
          "    assert!(writer.output.len() > 0);",
          "    assert!(writer.output.iter().all(|&b| b.is_ascii()));",
          "    assert!(writer.output.iter().any(|&b| b == b'-'));",
          "    assert!(writer.output.iter().any(|&b| b == b'I'));",
          "    assert!(writer.output.iter().any(|&b| b == b'n'));",
          "    assert!(writer.output.iter().any(|&b| b == b'f'));",
          "    assert!(writer.output.iter().any(|&b| b == b'i'));",
          "    assert!(writer.output.iter().any(|&b| b == b'n'));",
          "    assert!(writer.output.iter().any(|&b| b == b'i'));",
          "    assert!(writer.output.iter().any(|&b| b == b't'));"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"-Infinity\";",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"-Infinity\");",
          "    assert!(writer.output.len() > 0);",
          "    assert!(writer.output.iter().all(|&b| b.is_ascii()));",
          "    assert!(writer.output.iter().any(|&b| b == b'-'));",
          "    assert!(writer.output.iter().any(|&b| b == b'I'));",
          "    assert!(writer.output.iter().any(|&b| b == b'n'));",
          "    assert!(writer.output.iter().any(|&b| b == b'f'));",
          "    assert!(writer.output.iter().any(|&b| b == b'i'));",
          "    assert!(writer.output.iter().any(|&b| b == b'n'));",
          "    assert!(writer.output.iter().any(|&b| b == b'i'));",
          "    assert!(writer.output.iter().any(|&b| b == b't'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"1.7976931348623157E+308\"; // Maximum f64 value",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, b\"1.7976931348623157E+308\");"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: Vec<u8>,",
          "    }",
          "    impl io::Write for MockWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.output.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: Vec::new() };",
          "    let value = \"1.7976931348623157E+308\"; // Maximum f64 value",
          "    // Call the function",
          "    write_number_str(&mut writer, value).unwrap();",
          "    assert_eq!(writer.output, b\"1.7976931348623157E+308\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]