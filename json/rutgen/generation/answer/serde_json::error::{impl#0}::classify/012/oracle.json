[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "// Repeat for other ErrorCode variants that fall under Syntax category"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ErrorImpl {",
          "        code: ErrorCode,",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    struct Error {",
          "        err: Box<ErrorImpl>,",
          "    }",
          "",
          "    enum ErrorCode {",
          "        InvalidNumber,",
          "        // other variants...",
          "    }",
          "",
          "    let error_impl = ErrorImpl {",
          "        code: ErrorCode::InvalidNumber,",
          "        line: 1,",
          "        column: 1,",
          "    };",
          "",
          "    let error = Error {",
          "        err: Box::new(error_impl),",
          "    };",
          "",
          "    let _category = error.classify();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ExpectedColon, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidEscape, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::TrailingComma, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::RecursionLimitExceeded, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);"
        ],
        "code": [
          "{",
          "    struct ErrorImpl {",
          "        code: ErrorCode,",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    struct Error {",
          "        err: Box<ErrorImpl>,",
          "    }",
          "",
          "    enum ErrorCode {",
          "        InvalidNumber,",
          "        // other variants...",
          "    }",
          "",
          "    let error_impl = ErrorImpl {",
          "        code: ErrorCode::InvalidNumber,",
          "        line: 1,",
          "        column: 1,",
          "    };",
          "",
          "    let error = Error {",
          "        err: Box::new(error_impl),",
          "    };",
          "",
          "    let _category = error.classify();",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ExpectedColon, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidEscape, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::TrailingComma, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::RecursionLimitExceeded, line: 1, column: 1 };",
          "    let error = Error { err: Box::new(error_impl) };",
          "    assert_eq!(error.classify(), Category::Syntax);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ErrorImpl {",
          "        code: ErrorCode,",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    struct Error {",
          "        err: Box<ErrorImpl>,",
          "    }",
          "",
          "    enum ErrorCode {",
          "        ExpectedColon,",
          "        // other variants...",
          "    }",
          "",
          "    let error_impl = ErrorImpl {",
          "        code: ErrorCode::ExpectedColon,",
          "        line: 1,",
          "        column: 1,",
          "    };",
          "",
          "    let error = Error {",
          "        err: Box::new(error_impl),",
          "    };",
          "",
          "    let _category = error.classify();",
          "}"
        ],
        "oracle": [
          "    let error_impl_invalid_number = ErrorImpl { code: ErrorCode::InvalidNumber, line: 1, column: 1 };",
          "    let error_invalid_number = Error { err: Box::new(error_impl_invalid_number) };",
          "    assert_eq!(error_invalid_number.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_expected_colon = ErrorImpl { code: ErrorCode::ExpectedColon, line: 1, column: 1 };",
          "    let error_expected_colon = Error { err: Box::new(error_impl_expected_colon) };",
          "    assert_eq!(error_expected_colon.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_expected_list_comma = ErrorImpl { code: ErrorCode::ExpectedListCommaOrEnd, line: 1, column: 1 };",
          "    let error_expected_list_comma = Error { err: Box::new(error_impl_expected_list_comma) };",
          "    assert_eq!(error_expected_list_comma.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_invalid_escape = ErrorImpl { code: ErrorCode::InvalidEscape, line: 1, column: 1 };",
          "    let error_invalid_escape = Error { err: Box::new(error_impl_invalid_escape) };",
          "    assert_eq!(error_invalid_escape.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_number_out_of_range = ErrorImpl { code: ErrorCode::NumberOutOfRange, line: 1, column: 1 };",
          "    let error_number_out_of_range = Error { err: Box::new(error_impl_number_out_of_range) };",
          "    assert_eq!(error_number_out_of_range.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_invalid_unicode_code_point = ErrorImpl { code: ErrorCode::InvalidUnicodeCodePoint, line: 1, column: 1 };",
          "    let error_invalid_unicode_code_point = Error { err: Box::new(error_impl_invalid_unicode_code_point) };",
          "    assert_eq!(error_invalid_unicode_code_point.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_control_character = ErrorImpl { code: ErrorCode::ControlCharacterWhileParsingString, line: 1, column: 1 };",
          "    let error_control_character = Error { err: Box::new(error_impl_control_character) };",
          "    assert_eq!(error_control_character.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_key_must_be_string = ErrorImpl { code: ErrorCode::KeyMustBeAString, line: 1, column: 1 };",
          "    let error_key_must_be_string = Error { err: Box::new(error_impl_key_must_be_string) };",
          "    assert_eq!(error_key_must_be_string.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_expected_numeric_key = ErrorImpl { code: ErrorCode::ExpectedNumericKey, line: 1, column: 1 };",
          "    let error_expected_numeric_key = Error { err: Box::new(error_impl_expected_numeric_key) };",
          "    assert_eq!(error_expected_numeric_key.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_float_key_must_be_finite = ErrorImpl { code: ErrorCode::FloatKeyMustBeFinite, line: 1, column: 1 };",
          "    let error_float_key_must_be_finite = Error { err: Box::new(error_impl_float_key_must_be_finite) };",
          "    assert_eq!(error_float_key_must_be_finite.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_lone_leading_surrogate = ErrorImpl { code: ErrorCode::LoneLeadingSurrogateInHexEscape, line: 1, column: 1 };",
          "    let error_lone_leading_surrogate = Error { err: Box::new(error_impl_lone_leading_surrogate) };",
          "    assert_eq!(error_lone_leading_surrogate.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_trailing_comma = ErrorImpl { code: ErrorCode::TrailingComma, line: 1, column: 1 };",
          "    let error_trailing_comma = Error { err: Box::new(error_impl_trailing_comma) };",
          "    assert_eq!(error_trailing_comma.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_trailing_characters = ErrorImpl { code: ErrorCode::TrailingCharacters, line: 1, column: 1 };",
          "    let error_trailing_characters = Error { err: Box::new(error_impl_trailing_characters) };",
          "    assert_eq!(error_trailing_characters.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_unexpected_end_of_hex_escape = ErrorImpl { code: ErrorCode::UnexpectedEndOfHexEscape, line: 1, column: 1 };",
          "    let error_unexpected_end_of_hex_escape = Error { err: Box::new(error_impl_unexpected_end_of_hex_escape) };",
          "    assert_eq!(error_unexpected_end_of_hex_escape.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_recursion_limit_exceeded = ErrorImpl { code: ErrorCode::RecursionLimitExceeded, line: 1, column: 1 };",
          "    let error_recursion_limit_exceeded = Error { err: Box::new(error_impl_recursion_limit_exceeded) };",
          "    assert_eq!(error_recursion_limit_exceeded.classify(), Category::Syntax);"
        ],
        "code": [
          "{",
          "    struct ErrorImpl {",
          "        code: ErrorCode,",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    struct Error {",
          "        err: Box<ErrorImpl>,",
          "    }",
          "",
          "    enum ErrorCode {",
          "        ExpectedColon,",
          "        // other variants...",
          "    }",
          "",
          "    let error_impl = ErrorImpl {",
          "        code: ErrorCode::ExpectedColon,",
          "        line: 1,",
          "        column: 1,",
          "    };",
          "",
          "    let error = Error {",
          "        err: Box::new(error_impl),",
          "    };",
          "",
          "    let _category = error.classify();",
          "    let error_impl_invalid_number = ErrorImpl { code: ErrorCode::InvalidNumber, line: 1, column: 1 };",
          "    let error_invalid_number = Error { err: Box::new(error_impl_invalid_number) };",
          "    assert_eq!(error_invalid_number.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_expected_colon = ErrorImpl { code: ErrorCode::ExpectedColon, line: 1, column: 1 };",
          "    let error_expected_colon = Error { err: Box::new(error_impl_expected_colon) };",
          "    assert_eq!(error_expected_colon.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_expected_list_comma = ErrorImpl { code: ErrorCode::ExpectedListCommaOrEnd, line: 1, column: 1 };",
          "    let error_expected_list_comma = Error { err: Box::new(error_impl_expected_list_comma) };",
          "    assert_eq!(error_expected_list_comma.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_invalid_escape = ErrorImpl { code: ErrorCode::InvalidEscape, line: 1, column: 1 };",
          "    let error_invalid_escape = Error { err: Box::new(error_impl_invalid_escape) };",
          "    assert_eq!(error_invalid_escape.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_number_out_of_range = ErrorImpl { code: ErrorCode::NumberOutOfRange, line: 1, column: 1 };",
          "    let error_number_out_of_range = Error { err: Box::new(error_impl_number_out_of_range) };",
          "    assert_eq!(error_number_out_of_range.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_invalid_unicode_code_point = ErrorImpl { code: ErrorCode::InvalidUnicodeCodePoint, line: 1, column: 1 };",
          "    let error_invalid_unicode_code_point = Error { err: Box::new(error_impl_invalid_unicode_code_point) };",
          "    assert_eq!(error_invalid_unicode_code_point.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_control_character = ErrorImpl { code: ErrorCode::ControlCharacterWhileParsingString, line: 1, column: 1 };",
          "    let error_control_character = Error { err: Box::new(error_impl_control_character) };",
          "    assert_eq!(error_control_character.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_key_must_be_string = ErrorImpl { code: ErrorCode::KeyMustBeAString, line: 1, column: 1 };",
          "    let error_key_must_be_string = Error { err: Box::new(error_impl_key_must_be_string) };",
          "    assert_eq!(error_key_must_be_string.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_expected_numeric_key = ErrorImpl { code: ErrorCode::ExpectedNumericKey, line: 1, column: 1 };",
          "    let error_expected_numeric_key = Error { err: Box::new(error_impl_expected_numeric_key) };",
          "    assert_eq!(error_expected_numeric_key.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_float_key_must_be_finite = ErrorImpl { code: ErrorCode::FloatKeyMustBeFinite, line: 1, column: 1 };",
          "    let error_float_key_must_be_finite = Error { err: Box::new(error_impl_float_key_must_be_finite) };",
          "    assert_eq!(error_float_key_must_be_finite.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_lone_leading_surrogate = ErrorImpl { code: ErrorCode::LoneLeadingSurrogateInHexEscape, line: 1, column: 1 };",
          "    let error_lone_leading_surrogate = Error { err: Box::new(error_impl_lone_leading_surrogate) };",
          "    assert_eq!(error_lone_leading_surrogate.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_trailing_comma = ErrorImpl { code: ErrorCode::TrailingComma, line: 1, column: 1 };",
          "    let error_trailing_comma = Error { err: Box::new(error_impl_trailing_comma) };",
          "    assert_eq!(error_trailing_comma.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_trailing_characters = ErrorImpl { code: ErrorCode::TrailingCharacters, line: 1, column: 1 };",
          "    let error_trailing_characters = Error { err: Box::new(error_impl_trailing_characters) };",
          "    assert_eq!(error_trailing_characters.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_unexpected_end_of_hex_escape = ErrorImpl { code: ErrorCode::UnexpectedEndOfHexEscape, line: 1, column: 1 };",
          "    let error_unexpected_end_of_hex_escape = Error { err: Box::new(error_impl_unexpected_end_of_hex_escape) };",
          "    assert_eq!(error_unexpected_end_of_hex_escape.classify(), Category::Syntax);",
          "    ",
          "    let error_impl_recursion_limit_exceeded = ErrorImpl { code: ErrorCode::RecursionLimitExceeded, line: 1, column: 1 };",
          "    let error_recursion_limit_exceeded = Error { err: Box::new(error_impl_recursion_limit_exceeded) };",
          "    assert_eq!(error_recursion_limit_exceeded.classify(), Category::Syntax);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ErrorImpl {",
          "        code: ErrorCode,",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    struct Error {",
          "        err: Box<ErrorImpl>,",
          "    }",
          "",
          "    enum ErrorCode {",
          "        ExpectedSomeValue,",
          "        // other variants...",
          "    }",
          "",
          "    let error_impl = ErrorImpl {",
          "        code: ErrorCode::ExpectedSomeValue,",
          "        line: 1,",
          "        column: 1,",
          "    };",
          "",
          "    let error = Error {",
          "        err: Box::new(error_impl),",
          "    };",
          "",
          "    let _category = error.classify();",
          "}"
        ],
        "oracle": [
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidNumber, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ExpectedDoubleQuote, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidEscape, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::NumberOutOfRange, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidUnicodeCodePoint, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ControlCharacterWhileParsingString, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::KeyMustBeAString, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ExpectedNumericKey, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::FloatKeyMustBeFinite, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::LoneLeadingSurrogateInHexEscape, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::TrailingComma, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::TrailingCharacters, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::UnexpectedEndOfHexEscape, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::RecursionLimitExceeded, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);"
        ],
        "code": [
          "{",
          "    struct ErrorImpl {",
          "        code: ErrorCode,",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    struct Error {",
          "        err: Box<ErrorImpl>,",
          "    }",
          "",
          "    enum ErrorCode {",
          "        ExpectedSomeValue,",
          "        // other variants...",
          "    }",
          "",
          "    let error_impl = ErrorImpl {",
          "        code: ErrorCode::ExpectedSomeValue,",
          "        line: 1,",
          "        column: 1,",
          "    };",
          "",
          "    let error = Error {",
          "        err: Box::new(error_impl),",
          "    };",
          "",
          "    let _category = error.classify();",
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidNumber, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ExpectedDoubleQuote, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidEscape, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::NumberOutOfRange, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::InvalidUnicodeCodePoint, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ControlCharacterWhileParsingString, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::KeyMustBeAString, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::ExpectedNumericKey, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::FloatKeyMustBeFinite, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::LoneLeadingSurrogateInHexEscape, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::TrailingComma, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::TrailingCharacters, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::UnexpectedEndOfHexEscape, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "    let error_impl = ErrorImpl { code: ErrorCode::RecursionLimitExceeded, line: 1, column: 1 }; let error = Error { err: Box::new(error_impl) }; assert_eq!(error.classify(), Category::Syntax);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]