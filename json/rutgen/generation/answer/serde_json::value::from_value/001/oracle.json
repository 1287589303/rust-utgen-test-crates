[
  {
    "uses": [
      "use serde::Deserialize;",
      "use serde_json::json;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct User {",
          "        fingerprint: String,",
          "        location: String,",
          "    }",
          "",
          "    let j = json!({",
          "        \"fingerprint\": \"0xF9BA143B95FF6D82\",",
          "        \"location\": \"Menlo Park, CA\"",
          "    });",
          "",
          "    let user: User = from_value(j).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(user.fingerprint, \"0xF9BA143B95FF6D82\");",
          "    assert_eq!(user.location, \"Menlo Park, CA\");",
          "    let invalid_json = json!(null);",
          "    let result: Result<User, Error> = from_value(invalid_json);",
          "    assert!(result.is_err());",
          "    let missing_field_json = json!({",
          "    \"location\": \"Menlo Park, CA\"",
          "    });",
          "    let result_missing_field: Result<User, Error> = from_value(missing_field_json);",
          "    assert!(result_missing_field.is_err());",
          "    let extra_field_json = json!({",
          "    \"fingerprint\": \"0xF9BA143B95FF6D82\",",
          "    \"location\": \"Menlo Park, CA\",",
          "    \"extra_field\": \"unexpected\"",
          "    });",
          "    let result_extra_field: Result<User, Error> = from_value(extra_field_json);",
          "    assert!(result_extra_field.is_ok());",
          "    let invalid_type_json = json!({",
          "    \"fingerprint\": 123,",
          "    \"location\": \"Menlo Park, CA\"",
          "    });",
          "    let result_invalid_type: Result<User, Error> = from_value(invalid_type_json);",
          "    assert!(result_invalid_type.is_err());"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct User {",
          "        fingerprint: String,",
          "        location: String,",
          "    }",
          "",
          "    let j = json!({",
          "        \"fingerprint\": \"0xF9BA143B95FF6D82\",",
          "        \"location\": \"Menlo Park, CA\"",
          "    });",
          "",
          "    let user: User = from_value(j).unwrap();",
          "    assert_eq!(user.fingerprint, \"0xF9BA143B95FF6D82\");",
          "    assert_eq!(user.location, \"Menlo Park, CA\");",
          "    let invalid_json = json!(null);",
          "    let result: Result<User, Error> = from_value(invalid_json);",
          "    assert!(result.is_err());",
          "    let missing_field_json = json!({",
          "    \"location\": \"Menlo Park, CA\"",
          "    });",
          "    let result_missing_field: Result<User, Error> = from_value(missing_field_json);",
          "    assert!(result_missing_field.is_err());",
          "    let extra_field_json = json!({",
          "    \"fingerprint\": \"0xF9BA143B95FF6D82\",",
          "    \"location\": \"Menlo Park, CA\",",
          "    \"extra_field\": \"unexpected\"",
          "    });",
          "    let result_extra_field: Result<User, Error> = from_value(extra_field_json);",
          "    assert!(result_extra_field.is_ok());",
          "    let invalid_type_json = json!({",
          "    \"fingerprint\": 123,",
          "    \"location\": \"Menlo Park, CA\"",
          "    });",
          "    let result_invalid_type: Result<User, Error> = from_value(invalid_type_json);",
          "    assert!(result_invalid_type.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct User {",
          "        fingerprint: String,",
          "        location: String,",
          "    }",
          "",
          "    let j = json!({",
          "        \"fingerprint\": \"0xF9BA143B95FF6D82\",",
          "    });",
          "",
          "    let result: Result<User, _> = from_value(j);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().to_string(), \"missing field `location`\");"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct User {",
          "        fingerprint: String,",
          "        location: String,",
          "    }",
          "",
          "    let j = json!({",
          "        \"fingerprint\": \"0xF9BA143B95FF6D82\",",
          "    });",
          "",
          "    let result: Result<User, _> = from_value(j);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().to_string(), \"missing field `location`\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct User {",
          "        fingerprint: String,",
          "        location: String,",
          "    }",
          "",
          "    let j = json!(42);",
          "",
          "    let result: Result<User, _> = from_value(j);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().to_string(), \"expected a map for `User`, but found a number\");"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct User {",
          "        fingerprint: String,",
          "        location: String,",
          "    }",
          "",
          "    let j = json!(42);",
          "",
          "    let result: Result<User, _> = from_value(j);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().to_string(), \"expected a map for `User`, but found a number\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct Flag {",
          "        active: bool,",
          "    }",
          "",
          "    let j = json!({\"active\": true});",
          "",
          "    let flag: Flag = from_value(j).unwrap();",
          "}"
        ],
        "oracle": [
          "    let j = json!({\"active\": true});",
          "    let flag: Flag = from_value(j).unwrap();",
          "    assert_eq!(flag.active, true);",
          "    ",
          "    let j_invalid = json!({\"active\": \"yes\"});",
          "    let result: Result<Flag, Error> = from_value(j_invalid);",
          "    assert!(result.is_err());",
          "    ",
          "    let j_empty = json!({});",
          "    let result_empty: Result<Flag, Error> = from_value(j_empty);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let j_missing_field = json!({\"inactive\": false});",
          "    let result_missing_field: Result<Flag, Error> = from_value(j_missing_field);",
          "    assert!(result_missing_field.is_err());",
          "    ",
          "    let j_null = json!(null);",
          "    let result_null: Result<Flag, Error> = from_value(j_null);",
          "    assert!(result_null.is_err());"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct Flag {",
          "        active: bool,",
          "    }",
          "",
          "    let j = json!({\"active\": true});",
          "",
          "    let flag: Flag = from_value(j).unwrap();",
          "    let j = json!({\"active\": true});",
          "    let flag: Flag = from_value(j).unwrap();",
          "    assert_eq!(flag.active, true);",
          "    ",
          "    let j_invalid = json!({\"active\": \"yes\"});",
          "    let result: Result<Flag, Error> = from_value(j_invalid);",
          "    assert!(result.is_err());",
          "    ",
          "    let j_empty = json!({});",
          "    let result_empty: Result<Flag, Error> = from_value(j_empty);",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let j_missing_field = json!({\"inactive\": false});",
          "    let result_missing_field: Result<Flag, Error> = from_value(j_missing_field);",
          "    assert!(result_missing_field.is_err());",
          "    ",
          "    let j_null = json!(null);",
          "    let result_null: Result<Flag, Error> = from_value(j_null);",
          "    assert!(result_null.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct NumberHolder {",
          "        value: i32,",
          "    }",
          "",
          "    let j = json!({\"value\": 42});",
          "",
          "    let number_holder: NumberHolder = from_value(j).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(number_holder.value, 42);"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct NumberHolder {",
          "        value: i32,",
          "    }",
          "",
          "    let j = json!({\"value\": 42});",
          "",
          "    let number_holder: NumberHolder = from_value(j).unwrap();",
          "    assert_eq!(number_holder.value, 42);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct NumberHolder {",
          "        value: u8,",
          "    }",
          "",
          "    let j = json!({\"value\": 300}); // Out of range for u8",
          "",
          "    let result: Result<NumberHolder, _> = from_value(j);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert!(result.err().is_some());",
          "    assert_eq!(result.unwrap_err().to_string(), \"out of range for u8\");"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct NumberHolder {",
          "        value: u8,",
          "    }",
          "",
          "    let j = json!({\"value\": 300}); // Out of range for u8",
          "",
          "    let result: Result<NumberHolder, _> = from_value(j);",
          "    assert_eq!(result.is_err(), true);",
          "    assert!(result.err().is_some());",
          "    assert_eq!(result.unwrap_err().to_string(), \"out of range for u8\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct OptionalField {",
          "        data: Option<String>,",
          "    }",
          "",
          "    let j = json!(null);",
          "",
          "    let result: Result<OptionalField, _> = from_value(j);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().to_string(), \"missing field data\");"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct OptionalField {",
          "        data: Option<String>,",
          "    }",
          "",
          "    let j = json!(null);",
          "",
          "    let result: Result<OptionalField, _> = from_value(j);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().to_string(), \"missing field data\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct EmptyStruct;",
          "",
          "    let j = json!({});",
          "",
          "    let empty_struct: EmptyStruct = from_value(j).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(from_value::<EmptyStruct>(json!({})).is_ok(), true);"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct EmptyStruct;",
          "",
          "    let j = json!({});",
          "",
          "    let empty_struct: EmptyStruct = from_value(j).unwrap();",
          "    assert_eq!(from_value::<EmptyStruct>(json!({})).is_ok(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct ArrayHolder {",
          "        items: Vec<String>,",
          "    }",
          "",
          "    let j = json!({\"items\": [\"item1\", \"item2\", \"item3\"]});",
          "",
          "    let array_holder: ArrayHolder = from_value(j).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(array_holder.items.len(), 3);",
          "    assert_eq!(array_holder.items[0], \"item1\");",
          "    assert_eq!(array_holder.items[1], \"item2\");",
          "    assert_eq!(array_holder.items[2], \"item3\");"
        ],
        "code": [
          "{",
          "    use serde::Deserialize;",
          "    use serde_json::json;",
          "",
          "    #[derive(Deserialize, Debug)]",
          "    struct ArrayHolder {",
          "        items: Vec<String>,",
          "    }",
          "",
          "    let j = json!({\"items\": [\"item1\", \"item2\", \"item3\"]});",
          "",
          "    let array_holder: ArrayHolder = from_value(j).unwrap();",
          "    assert_eq!(array_holder.items.len(), 3);",
          "    assert_eq!(array_holder.items[0], \"item1\");",
          "    assert_eq!(array_holder.items[1], \"item2\");",
          "    assert_eq!(array_holder.items[2], \"item3\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]