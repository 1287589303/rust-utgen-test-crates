[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = b\"\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice_read.index, 0);",
          "    assert!(scratch.is_empty());",
          "    assert!(slice_read.slice.is_empty());",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    assert!(slice_read.peek().unwrap().is_none());",
          "    slice_read.discard();",
          "    assert!(slice_read.position() == Position::default());",
          "    assert_eq!(slice_read.byte_offset(), 0);"
        ],
        "code": [
          "{",
          "    let data: &[u8] = b\"\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "    assert_eq!(slice_read.index, 0);",
          "    assert!(scratch.is_empty());",
          "    assert!(slice_read.slice.is_empty());",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    assert!(slice_read.peek().unwrap().is_none());",
          "    slice_read.discard();",
          "    assert!(slice_read.position() == Position::default());",
          "    assert_eq!(slice_read.byte_offset(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = b\"hello\";",
          "    let mut scratch = vec![0; 5]; // Small non-empty scratch",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "}"
        ],
        "oracle": [
          "    let scratch = vec![0; 5];",
          "    let slice_read = SliceRead { slice: b\"hello\", index: 0 };",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    assert!(matches!(result, Reference::Borrowed(_)));",
          "    assert!(matches!(result, Reference::Copied(_)));",
          "    assert_eq!(slice_read.byte_offset(), 0);"
        ],
        "code": [
          "{",
          "    let data: &[u8] = b\"hello\";",
          "    let mut scratch = vec![0; 5]; // Small non-empty scratch",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "    let scratch = vec![0; 5];",
          "    let slice_read = SliceRead { slice: b\"hello\", index: 0 };",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    assert!(matches!(result, Reference::Borrowed(_)));",
          "    assert!(matches!(result, Reference::Copied(_)));",
          "    assert_eq!(slice_read.byte_offset(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = b\"goodbye\";",
          "    let mut scratch = vec![0; 512]; // Large non-empty scratch",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice_read.index, 0);",
          "    assert!(scratch.len() > 0);",
          "    assert!(slice_read.slice.len() == 7); // For b\"goodbye\" including null terminator",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    assert!(matches!(slice_read.parse_str_raw(&mut scratch), Ok(Reference::Borrowed(_))));",
          "    assert!(slice_read.byte_offset() == 0);"
        ],
        "code": [
          "{",
          "    let data: &[u8] = b\"goodbye\";",
          "    let mut scratch = vec![0; 512]; // Large non-empty scratch",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "    assert_eq!(slice_read.index, 0);",
          "    assert!(scratch.len() > 0);",
          "    assert!(slice_read.slice.len() == 7); // For b\"goodbye\" including null terminator",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    assert!(matches!(slice_read.parse_str_raw(&mut scratch), Ok(Reference::Borrowed(_))));",
          "    assert!(slice_read.byte_offset() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = b\"\\xFF\"; // Invalid byte sequence",
          "    let mut scratch = Vec::new(); ",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "}"
        ],
        "oracle": [
          "    let data: &[u8] = b\"\\xFF\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_err());",
          "    ",
          "    let data: &[u8] = b\"\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    ",
          "    let data: &[u8] = b\"valid string\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    assert!(matches!(result, Reference::Borrowed(_)));",
          "    ",
          "    let data: &[u8] = b\"valid string\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    assert_eq!(scratch, b\"valid string\");",
          "    ",
          "    let data: &[u8] = b\"another valid string\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    let ref_data = if let Reference::Borrowed(ref str_data) = result { str_data } else { panic!(\"Expected Borrowed reference\") };",
          "    assert_eq!(ref_data, \"another valid string\");"
        ],
        "code": [
          "{",
          "    let data: &[u8] = b\"\\xFF\"; // Invalid byte sequence",
          "    let mut scratch = Vec::new(); ",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let _ = slice_read.parse_str_raw(&mut scratch);",
          "    let data: &[u8] = b\"\\xFF\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_err());",
          "    ",
          "    let data: &[u8] = b\"\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    assert!(slice_read.parse_str_raw(&mut scratch).is_ok());",
          "    ",
          "    let data: &[u8] = b\"valid string\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    assert!(matches!(result, Reference::Borrowed(_)));",
          "    ",
          "    let data: &[u8] = b\"valid string\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    assert_eq!(scratch, b\"valid string\");",
          "    ",
          "    let data: &[u8] = b\"another valid string\";",
          "    let mut scratch = Vec::new();",
          "    let mut slice_read = SliceRead { slice: data, index: 0 };",
          "    let result = slice_read.parse_str_raw(&mut scratch).unwrap();",
          "    let ref_data = if let Reference::Borrowed(ref str_data) = result { str_data } else { panic!(\"Expected Borrowed reference\") };",
          "    assert_eq!(ref_data, \"another valid string\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]