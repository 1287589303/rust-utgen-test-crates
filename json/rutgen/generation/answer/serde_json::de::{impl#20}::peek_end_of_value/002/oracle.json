[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(self.data[self.index]));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b' '], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "}"
        ],
        "oracle": [
          "    let mut reader_empty = TestReader { data: vec![], index: 0 };",
          "    let mut deserializer_empty = Deserializer::new(reader_empty);",
          "    let mut stream_deserializer_empty = StreamDeserializer::new(&mut deserializer_empty);",
          "    let result_empty = stream_deserializer_empty.peek_end_of_value();",
          "    assert_eq!(result_empty, Ok(()));",
          "    ",
          "    let mut reader_trailing = TestReader { data: vec![b'a'], index: 0 };",
          "    let mut deserializer_trailing = Deserializer::new(reader_trailing);",
          "    let mut stream_deserializer_trailing = StreamDeserializer::new(&mut deserializer_trailing);",
          "    let result_trailing = stream_deserializer_trailing.peek_end_of_value();",
          "    assert_eq!(result_trailing, Err(Error::syntax(ErrorCode::TrailingCharacters, 0, 0)));"
        ],
        "code": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(self.data[self.index]));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b' '], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "    let mut reader_empty = TestReader { data: vec![], index: 0 };",
          "    let mut deserializer_empty = Deserializer::new(reader_empty);",
          "    let mut stream_deserializer_empty = StreamDeserializer::new(&mut deserializer_empty);",
          "    let result_empty = stream_deserializer_empty.peek_end_of_value();",
          "    assert_eq!(result_empty, Ok(()));",
          "    ",
          "    let mut reader_trailing = TestReader { data: vec![b'a'], index: 0 };",
          "    let mut deserializer_trailing = Deserializer::new(reader_trailing);",
          "    let mut stream_deserializer_trailing = StreamDeserializer::new(&mut deserializer_trailing);",
          "    let result_trailing = stream_deserializer_trailing.peek_end_of_value();",
          "    assert_eq!(result_trailing, Err(Error::syntax(ErrorCode::TrailingCharacters, 0, 0)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(self.data[self.index]));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b'\\n'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "}"
        ],
        "oracle": [
          "    let reader = TestReader { data: vec![b'a'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().err.code, ErrorCode::TrailingCharacters);",
          "    ",
          "    let reader = TestReader { data: vec![b'{'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_ok());",
          "    ",
          "    let reader = TestReader { data: vec![b'\\t'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_ok());",
          "    ",
          "    let reader = TestReader { data: vec![], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_ok());",
          "    ",
          "    let reader = TestReader { data: vec![b','], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().err.code, ErrorCode::TrailingCharacters);"
        ],
        "code": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(self.data[self.index]));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b'\\n'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "    let reader = TestReader { data: vec![b'a'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().err.code, ErrorCode::TrailingCharacters);",
          "    ",
          "    let reader = TestReader { data: vec![b'{'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_ok());",
          "    ",
          "    let reader = TestReader { data: vec![b'\\t'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_ok());",
          "    ",
          "    let reader = TestReader { data: vec![], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_ok());",
          "    ",
          "    let reader = TestReader { data: vec![b','], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    let result = stream_deserializer.peek_end_of_value();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().err.code, ErrorCode::TrailingCharacters);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(b'x'));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b'x'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "}"
        ],
        "oracle": [
          "    let mut reader = TestReader { data: vec![b'x'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    assert_eq!(stream_deserializer.peek_end_of_value().unwrap_err(), Error::syntax(ErrorCode::TrailingCharacters, 0, 0));",
          "    ",
          "    let mut reader = TestReader { data: vec![], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    assert!(stream_deserializer.peek_end_of_value().is_ok());",
          "    ",
          "    let mut reader = TestReader { data: vec![b'x'], index: 1 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    assert_eq!(stream_deserializer.peek_end_of_value().unwrap_err(), Error::syntax(ErrorCode::TrailingCharacters, 0, 0));"
        ],
        "code": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(b'x'));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b'x'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "    let mut reader = TestReader { data: vec![b'x'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    assert_eq!(stream_deserializer.peek_end_of_value().unwrap_err(), Error::syntax(ErrorCode::TrailingCharacters, 0, 0));",
          "    ",
          "    let mut reader = TestReader { data: vec![], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    assert!(stream_deserializer.peek_end_of_value().is_ok());",
          "    ",
          "    let mut reader = TestReader { data: vec![b'x'], index: 1 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    assert_eq!(stream_deserializer.peek_end_of_value().unwrap_err(), Error::syntax(ErrorCode::TrailingCharacters, 0, 0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(b'a'));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b'a'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "}"
        ],
        "oracle": [
          "    let mut reader_err = TestReader { data: vec![b'a'], index: 1 };",
          "    let mut deserializer_err = Deserializer::new(reader_err);",
          "    let mut stream_deserializer_err = StreamDeserializer::new(&mut deserializer_err);",
          "    let result_err = stream_deserializer_err.peek_end_of_value();",
          "    assert!(result_err.is_err());",
          "    ",
          "    let mut reader_trailing = TestReader { data: vec![b'a', b'b'], index: 0 };",
          "    let mut deserializer_trailing = Deserializer::new(reader_trailing);",
          "    let mut stream_deserializer_trailing = StreamDeserializer::new(&mut deserializer_trailing);",
          "    let result_trailing = stream_deserializer_trailing.peek_end_of_value();",
          "    assert_eq!(result_trailing, Err(Error::syntax(ErrorCode::TrailingCharacters, position.line, position.column)));"
        ],
        "code": [
          "{",
          "    struct TestReader {",
          "        data: Vec<u8>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl read::Read<'static> for TestReader {",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.index < self.data.len() {",
          "                return Ok(Some(b'a'));",
          "            }",
          "            Ok(None)",
          "        }",
          "        ",
          "        fn byte_offset(&self) -> usize {",
          "            self.index",
          "        }",
          "    }",
          "    ",
          "    let mut reader = TestReader { data: vec![b'a'], index: 0 };",
          "    let mut deserializer = Deserializer::new(reader);",
          "    let mut stream_deserializer = StreamDeserializer::new(&mut deserializer);",
          "    ",
          "    let _ = stream_deserializer.peek_end_of_value();",
          "    let mut reader_err = TestReader { data: vec![b'a'], index: 1 };",
          "    let mut deserializer_err = Deserializer::new(reader_err);",
          "    let mut stream_deserializer_err = StreamDeserializer::new(&mut deserializer_err);",
          "    let result_err = stream_deserializer_err.peek_end_of_value();",
          "    assert!(result_err.is_err());",
          "    ",
          "    let mut reader_trailing = TestReader { data: vec![b'a', b'b'], index: 0 };",
          "    let mut deserializer_trailing = Deserializer::new(reader_trailing);",
          "    let mut stream_deserializer_trailing = StreamDeserializer::new(&mut deserializer_trailing);",
          "    let result_trailing = stream_deserializer_trailing.peek_end_of_value();",
          "    assert_eq!(result_trailing, Err(Error::syntax(ErrorCode::TrailingCharacters, position.line, position.column)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]