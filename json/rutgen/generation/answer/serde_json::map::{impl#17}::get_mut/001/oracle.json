[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "",
          "    match map.entry(\"serde\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            // Further operations can be conducted on value_ref if needed",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "}"
        ],
        "oracle": [
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "    let mut occupied = map.entry(\"serde\").or_insert(Value::Array(vec![]));",
          "    let value_ref = occupied.get_mut();",
          "    assert!(matches!(value_ref, &mut Value::Array(_)));",
          "    assert_eq!(value_ref.as_array_mut().unwrap().len(), 3);"
        ],
        "code": [
          "{",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "",
          "    match map.entry(\"serde\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            // Further operations can be conducted on value_ref if needed",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "    let mut occupied = map.entry(\"serde\").or_insert(Value::Array(vec![]));",
          "    let value_ref = occupied.get_mut();",
          "    assert!(matches!(value_ref, &mut Value::Array(_)));",
          "    assert_eq!(value_ref.as_array_mut().unwrap().len(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "",
          "    match map.entry(\"serde\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            if let Value::Array(arr) = value_ref {",
          "                arr.push(Value::Number(4.0.into()));",
          "            }",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "}"
        ],
        "oracle": [
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "    match map.entry(\"serde\") {",
          "    Entry::Occupied(mut occupied) => {",
          "    let value_ref = occupied.get_mut();",
          "    assert!(matches!(value_ref, Value::Array(_)));",
          "    if let Value::Array(arr) = value_ref {",
          "    arr.push(Value::Number(4.0.into()));",
          "    }",
          "    assert_eq!(arr.len(), 4);",
          "    }",
          "    Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }"
        ],
        "code": [
          "{",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "",
          "    match map.entry(\"serde\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            if let Value::Array(arr) = value_ref {",
          "                arr.push(Value::Number(4.0.into()));",
          "            }",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into()), Value::Number(3.0.into())]));",
          "    match map.entry(\"serde\") {",
          "    Entry::Occupied(mut occupied) => {",
          "    let value_ref = occupied.get_mut();",
          "    assert!(matches!(value_ref, Value::Array(_)));",
          "    if let Value::Array(arr) = value_ref {",
          "    arr.push(Value::Number(4.0.into()));",
          "    }",
          "    assert_eq!(arr.len(), 4);",
          "    }",
          "    Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into())]));",
          "    map.insert(\"rust\".to_owned(), Value::Array(vec![Value::Number(3.0.into())]));",
          "",
          "    match map.entry(\"serde\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            // Potential operations on value_ref",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "",
          "    match map.entry(\"rust\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            // Potential operations on value_ref",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "}"
        ],
        "oracle": [
          "    let mut map = serde_json::Map::new(); map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into())])); assert!(map.entry(\"serde\").is_occupied()); let value_ref = map.entry(\"serde\").get_mut(); assert_eq!(value_ref, &mut Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into())])); value_ref.as_array_mut().unwrap().push(Value::Number(4.0.into())); assert_eq!(map[\"serde\"].as_array().unwrap().len(), 3); let mut map2 = serde_json::Map::new(); map2.insert(\"rust\".to_owned(), Value::Array(vec![Value::Number(3.0.into())])); assert!(map2.entry(\"rust\").is_occupied()); let value_ref2 = map2.entry(\"rust\").get_mut(); assert_eq!(value_ref2, &mut Value::Array(vec![Value::Number(3.0.into())])); value_ref2.as_array_mut().unwrap().push(Value::Number(5.0.into())); assert_eq!(map2[\"rust\"].as_array().unwrap().len(), 2);"
        ],
        "code": [
          "{",
          "    let mut map = serde_json::Map::new();",
          "    map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into())]));",
          "    map.insert(\"rust\".to_owned(), Value::Array(vec![Value::Number(3.0.into())]));",
          "",
          "    match map.entry(\"serde\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            // Potential operations on value_ref",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "",
          "    match map.entry(\"rust\") {",
          "        Entry::Occupied(mut occupied) => {",
          "            let value_ref = occupied.get_mut();",
          "            // Potential operations on value_ref",
          "        }",
          "        Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),",
          "    }",
          "    let mut map = serde_json::Map::new(); map.insert(\"serde\".to_owned(), Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into())])); assert!(map.entry(\"serde\").is_occupied()); let value_ref = map.entry(\"serde\").get_mut(); assert_eq!(value_ref, &mut Value::Array(vec![Value::Number(1.0.into()), Value::Number(2.0.into())])); value_ref.as_array_mut().unwrap().push(Value::Number(4.0.into())); assert_eq!(map[\"serde\"].as_array().unwrap().len(), 3); let mut map2 = serde_json::Map::new(); map2.insert(\"rust\".to_owned(), Value::Array(vec![Value::Number(3.0.into())])); assert!(map2.entry(\"rust\").is_occupied()); let value_ref2 = map2.entry(\"rust\").get_mut(); assert_eq!(value_ref2, &mut Value::Array(vec![Value::Number(3.0.into())])); value_ref2.as_array_mut().unwrap().push(Value::Number(5.0.into())); assert_eq!(map2[\"rust\"].as_array().unwrap().len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]