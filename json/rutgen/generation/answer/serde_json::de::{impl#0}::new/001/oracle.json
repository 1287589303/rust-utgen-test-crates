[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockSliceRead<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'de> read::Read<'de> for MockSliceRead<'_> {",
          "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
          "            let len = buf.len().min(self.data.len());",
          "            buf[..len].copy_from_slice(&self.data[..len]);",
          "            self.data = &self.data[len..];",
          "            Ok(len)",
          "        }",
          "    }",
          "",
          "    let input = b\"{}\";",
          "    let read = MockSliceRead { data: input };",
          "    let deserializer = Deserializer::new(read);",
          "}"
        ],
        "oracle": [
          "    let input = b\"{}\";",
          "    let read = MockSliceRead { data: input };",
          "    let deserializer = Deserializer::new(read);",
          "    assert_eq!(deserializer.remaining_depth, 128);",
          "    assert_eq!(deserializer.scratch, Vec::new());",
          "    #[cfg(feature = \"float_roundtrip\")]",
          "    assert_eq!(deserializer.single_precision, false);",
          "    #[cfg(feature = \"unbounded_depth\")]",
          "    assert_eq!(deserializer.disable_recursion_limit, false);"
        ],
        "code": [
          "{",
          "    struct MockSliceRead<'a> {",
          "        data: &'a [u8],",
          "    }",
          "",
          "    impl<'de> read::Read<'de> for MockSliceRead<'_> {",
          "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
          "            let len = buf.len().min(self.data.len());",
          "            buf[..len].copy_from_slice(&self.data[..len]);",
          "            self.data = &self.data[len..];",
          "            Ok(len)",
          "        }",
          "    }",
          "",
          "    let input = b\"{}\";",
          "    let read = MockSliceRead { data: input };",
          "    let deserializer = Deserializer::new(read);",
          "    let input = b\"{}\";",
          "    let read = MockSliceRead { data: input };",
          "    let deserializer = Deserializer::new(read);",
          "    assert_eq!(deserializer.remaining_depth, 128);",
          "    assert_eq!(deserializer.scratch, Vec::new());",
          "    #[cfg(feature = \"float_roundtrip\")]",
          "    assert_eq!(deserializer.single_precision, false);",
          "    #[cfg(feature = \"unbounded_depth\")]",
          "    assert_eq!(deserializer.disable_recursion_limit, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockStrRead<'a> {",
          "        data: &'a str,",
          "    }",
          "",
          "    impl<'de> read::Read<'de> for MockStrRead<'_> {",
          "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
          "            let len = buf.len().min(self.data.len());",
          "            buf[..len].copy_from_slice(&self.data.as_bytes()[..len]);",
          "            self.data = &self.data[len..];",
          "            Ok(len)",
          "        }",
          "    }",
          "",
          "    let input = \"{}\";",
          "    let read = MockStrRead { data: input };",
          "    let deserializer = Deserializer::new(read);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.remaining_depth, 128);",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert_eq!(deserializer.single_precision, false);",
          "    assert_eq!(deserializer.disable_recursion_limit, false);"
        ],
        "code": [
          "{",
          "    struct MockStrRead<'a> {",
          "        data: &'a str,",
          "    }",
          "",
          "    impl<'de> read::Read<'de> for MockStrRead<'_> {",
          "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
          "            let len = buf.len().min(self.data.len());",
          "            buf[..len].copy_from_slice(&self.data.as_bytes()[..len]);",
          "            self.data = &self.data[len..];",
          "            Ok(len)",
          "        }",
          "    }",
          "",
          "    let input = \"{}\";",
          "    let read = MockStrRead { data: input };",
          "    let deserializer = Deserializer::new(read);",
          "    assert_eq!(deserializer.remaining_depth, 128);",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert_eq!(deserializer.single_precision, false);",
          "    assert_eq!(deserializer.disable_recursion_limit, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockFusedRead {",
          "        position: usize,",
          "        data: Vec<u8>,",
          "    }",
          "",
          "    impl<'de> read::Read<'de> for MockFusedRead {",
          "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
          "            let len = buf.len().min(self.data.len() - self.position);",
          "            buf[..len].copy_from_slice(&self.data[self.position..self.position + len]);",
          "            self.position += len;",
          "            Ok(len)",
          "        }",
          "    }",
          "",
          "    let input = b\"{}\";",
          "    let read = MockFusedRead {",
          "        position: 0,",
          "        data: input.to_vec(),",
          "    };",
          "    let deserializer = Deserializer::new(read);",
          "}"
        ],
        "oracle": [
          "    let mock_read = MockFusedRead { position: 0, data: b\"{}\".to_vec() };",
          "    assert_eq!(deserializer.remaining_depth, 128);",
          "    assert_eq!(deserializer.scratch, Vec::new());",
          "    #[cfg(feature = \"float_roundtrip\")] assert_eq!(deserializer.single_precision, false);",
          "    #[cfg(feature = \"unbounded_depth\")] assert_eq!(deserializer.disable_recursion_limit, false);",
          "    assert_eq!(deserializer.read, mock_read);"
        ],
        "code": [
          "{",
          "    struct MockFusedRead {",
          "        position: usize,",
          "        data: Vec<u8>,",
          "    }",
          "",
          "    impl<'de> read::Read<'de> for MockFusedRead {",
          "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
          "            let len = buf.len().min(self.data.len() - self.position);",
          "            buf[..len].copy_from_slice(&self.data[self.position..self.position + len]);",
          "            self.position += len;",
          "            Ok(len)",
          "        }",
          "    }",
          "",
          "    let input = b\"{}\";",
          "    let read = MockFusedRead {",
          "        position: 0,",
          "        data: input.to_vec(),",
          "    };",
          "    let deserializer = Deserializer::new(read);",
          "    let mock_read = MockFusedRead { position: 0, data: b\"{}\".to_vec() };",
          "    assert_eq!(deserializer.remaining_depth, 128);",
          "    assert_eq!(deserializer.scratch, Vec::new());",
          "    #[cfg(feature = \"float_roundtrip\")] assert_eq!(deserializer.single_precision, false);",
          "    #[cfg(feature = \"unbounded_depth\")] assert_eq!(deserializer.disable_recursion_limit, false);",
          "    assert_eq!(deserializer.read, mock_read);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]