[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 10,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq_access.first, true);",
          "    assert_eq!(seq_access.de as *const Deserializer<MockRead>, &deserializer as *const Deserializer<MockRead>);"
        ],
        "code": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 10,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "    assert_eq!(seq_access.first, true);",
          "    assert_eq!(seq_access.de as *const Deserializer<MockRead>, &deserializer as *const Deserializer<MockRead>);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 255,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "}"
        ],
        "oracle": [
          "    let deserializer = Deserializer { read: MockRead, scratch: Vec::new(), remaining_depth: 255 };",
          "    assert_eq!(seq_access.first, true);",
          "    assert!(std::ptr::eq(seq_access.de, &deserializer_ref));",
          "    assert!(matches!(seq_access, SeqAccess { de: _, first: true }));"
        ],
        "code": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 255,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "    let deserializer = Deserializer { read: MockRead, scratch: Vec::new(), remaining_depth: 255 };",
          "    assert_eq!(seq_access.first, true);",
          "    assert!(std::ptr::eq(seq_access.de, &deserializer_ref));",
          "    assert!(matches!(seq_access, SeqAccess { de: _, first: true }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[cfg(feature = \"float_roundtrip\")]"
        ],
        "prefix": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 128,",
          "        single_precision: true,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq_access.first, true);",
          "    assert!(std::ptr::eq(seq_access.de, &mut deserializer_ref));"
        ],
        "code": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 128,",
          "        single_precision: true,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "    assert_eq!(seq_access.first, true);",
          "    assert!(std::ptr::eq(seq_access.de, &mut deserializer_ref));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[cfg(not(feature = \"unbounded_depth\"))]"
        ],
        "prefix": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 50,",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq_access.de, &mut deserializer_ref);",
          "    assert_eq!(seq_access.first, true);"
        ],
        "code": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 50,",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "    assert_eq!(seq_access.de, &mut deserializer_ref);",
          "    assert_eq!(seq_access.first, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[cfg(feature = \"unbounded_depth\")]"
        ],
        "prefix": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 100,",
          "        single_precision: false,",
          "        disable_recursion_limit: true,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq_access.first, true);",
          "    assert_eq!(seq_access.de.remaining_depth, 100);",
          "    assert_eq!(seq_access.de.scratch.len(), 0);"
        ],
        "code": [
          "{",
          "    struct MockRead;",
          "",
          "    impl std::io::Read for MockRead {",
          "        fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize> {",
          "            Ok(0)",
          "        }",
          "    }",
          "",
          "    let deserializer = Deserializer {",
          "        read: MockRead,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 100,",
          "        single_precision: false,",
          "        disable_recursion_limit: true,",
          "    };",
          "",
          "    let mut deserializer_ref = deserializer;",
          "    let seq_access = SeqAccess::new(&mut deserializer_ref);",
          "    assert_eq!(seq_access.first, true);",
          "    assert_eq!(seq_access.de.remaining_depth, 100);",
          "    assert_eq!(seq_access.de.scratch.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]