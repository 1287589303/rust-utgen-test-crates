[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let code = ErrorCode::Message(\"Test message\".into());",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(String::from_utf8(buf).unwrap(), \"Test message\");"
        ],
        "code": [
          "{",
          "    let code = ErrorCode::Message(\"Test message\".into());",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "    assert_eq!(String::from_utf8(buf).unwrap(), \"Test message\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let io_error = io::Error::new(ErrorKind::Other, \"IO error\");",
          "    let code = ErrorCode::Io(io_error);",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"IO error\");",
          "    assert!(formatter.is_complete());",
          "    assert_eq!(error.line, 0);",
          "    assert_eq!(error.column, 0);",
          "    assert_eq!(error.code, ErrorCode::Io(io_error));"
        ],
        "code": [
          "{",
          "    let io_error = io::Error::new(ErrorKind::Other, \"IO error\");",
          "    let code = ErrorCode::Io(io_error);",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "    assert_eq!(buf, b\"IO error\");",
          "    assert!(formatter.is_complete());",
          "    assert_eq!(error.line, 0);",
          "    assert_eq!(error.column, 0);",
          "    assert_eq!(error.code, ErrorCode::Io(io_error));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let code = ErrorCode::EofWhileParsingList;",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"Eof while parsing a list\");",
          "    assert!(formatter.is_empty());"
        ],
        "code": [
          "{",
          "    let code = ErrorCode::EofWhileParsingList;",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "    assert_eq!(buf, b\"Eof while parsing a list\");",
          "    assert!(formatter.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let code = ErrorCode::TrailingCharacters;",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buf, b\"trailing characters\");",
          "    assert_eq!(error.line, 0);",
          "    assert_eq!(error.column, 0);",
          "    assert!(formatter.is_empty());"
        ],
        "code": [
          "{",
          "    let code = ErrorCode::TrailingCharacters;",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "    assert_eq!(buf, b\"trailing characters\");",
          "    assert_eq!(error.line, 0);",
          "    assert_eq!(error.column, 0);",
          "    assert!(formatter.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let code = ErrorCode::InvalidNumber;",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"invalid number\") == formatter.into_inner() as Result<_, fmt::Error>",
          "    assert_eq!(error.line, 0)",
          "    assert_eq!(error.column, 0)",
          "    assert_eq!(error.code, ErrorCode::InvalidNumber)"
        ],
        "code": [
          "{",
          "    let code = ErrorCode::InvalidNumber;",
          "    let error = ErrorImpl { code, line: 0, column: 0 };",
          "    let mut buf = vec![];",
          "    let mut formatter = fmt::Formatter::new(&mut buf);",
          "    let _ = error.fmt(&mut formatter);",
          "    write!(f, \"invalid number\") == formatter.into_inner() as Result<_, fmt::Error>",
          "    assert_eq!(error.line, 0)",
          "    assert_eq!(error.column, 0)",
          "    assert_eq!(error.code, ErrorCode::InvalidNumber)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]