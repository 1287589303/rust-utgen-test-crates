[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0001f\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x00)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0000\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0001f\");",
          "    ",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x00)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0000\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer == b\"\\\\\\\\\"",
          "    writer == b\"\\\\\\\"\"",
          "    writer == b\"\\\\/\"",
          "    writer == b\"\\\\b\"",
          "    writer == b\"\\\\f\"",
          "    writer == b\"\\\\n\"",
          "    writer == b\"\\\\r\"",
          "    writer == b\"\\\\t\"",
          "    writer == [b'\\\\', b'u', b'0', b'0', b'0', b'0']",
          "    writer == [b'\\\\', b'u', b'0', b'0', b'1', b'2']",
          "    writer == [b'\\\\', b'u', b'0', b'0', b'F', b'E']"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    writer == b\"\\\\\\\\\"",
          "    writer == b\"\\\\\\\"\"",
          "    writer == b\"\\\\/\"",
          "    writer == b\"\\\\b\"",
          "    writer == b\"\\\\f\"",
          "    writer == b\"\\\\n\"",
          "    writer == b\"\\\\r\"",
          "    writer == b\"\\\\t\"",
          "    writer == [b'\\\\', b'u', b'0', b'0', b'0', b'0']",
          "    writer == [b'\\\\', b'u', b'0', b'0', b'1', b'2']",
          "    writer == [b'\\\\', b'u', b'0', b'0', b'F', b'E']",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'/');",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\"');",
          "    assert_eq!(writer, b\"\\\\\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\\');",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'b');",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'n');",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'r');",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b't');",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    writer.clear();",
          "    ",
          "    let ascii_byte: u8 = 0x1F;",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(ascii_byte)).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'u');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    assert_eq!(writer, b\"\\\\u001f\");",
          "    writer.clear();"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'/');",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\"');",
          "    assert_eq!(writer, b\"\\\\\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\\');",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'b');",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'n');",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'r');",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    writer.clear();",
          "    ",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b't');",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    writer.clear();",
          "    ",
          "    let ascii_byte: u8 = 0x1F;",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(ascii_byte)).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'u');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    assert_eq!(writer, b\"\\\\u001f\");",
          "    writer.clear();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer == b\"\\\\b\"",
          "    writer == b\"\\\\f\"",
          "    writer == b\"\\\\n\"",
          "    writer == b\"\\\\r\"",
          "    writer == b\"\\\\t\"",
          "    writer == b\"\\\\\\\"\"",
          "    writer == b\"\\\\\\\\\"",
          "    writer == b\"\\\\/\"",
          "    writer.len() == 6",
          "    writer.len() == 2",
          "    writer.len() == 4",
          "    writer.len() == 2",
          "    writer.len() == 2",
          "    writer.len() == 2",
          "    writer.len() == 6",
          "    writer[0] == b'\\\\'",
          "    writer[1] == b'u'",
          "    writer[2] == b'0'",
          "    writer[3] == b'0'",
          "    writer[4] == writer[5]",
          "    writer[5] >= b'0' && writer[5] <= b'f'",
          "    writer[4] >= b'0' && writer[4] <= b'f'"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer == b\"\\\\b\"",
          "    writer == b\"\\\\f\"",
          "    writer == b\"\\\\n\"",
          "    writer == b\"\\\\r\"",
          "    writer == b\"\\\\t\"",
          "    writer == b\"\\\\\\\"\"",
          "    writer == b\"\\\\\\\\\"",
          "    writer == b\"\\\\/\"",
          "    writer.len() == 6",
          "    writer.len() == 2",
          "    writer.len() == 4",
          "    writer.len() == 2",
          "    writer.len() == 2",
          "    writer.len() == 2",
          "    writer.len() == 6",
          "    writer[0] == b'\\\\'",
          "    writer[1] == b'u'",
          "    writer[2] == b'0'",
          "    writer[3] == b'0'",
          "    writer[4] == writer[5]",
          "    writer[5] >= b'0' && writer[5] <= b'f'",
          "    writer[4] >= b'0' && writer[4] <= b'f'",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\\\\r\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\\\\r\\\\t\\\\u001f\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\\\\r\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\\\\\\\"\\\\\\\\/\\\\b\\\\n\\\\r\\\\t\\\\u001f\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.should_equal(b\"\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    writer.should_equal(b\"\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    writer.should_equal(b\"\\\\\\\\\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    writer.should_equal(b\"\\\\/\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer.should_equal(b\"\\\\b\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    writer.should_equal(b\"\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    writer.should_equal(b\"\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer.should_equal(b\"\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x7F)).unwrap();",
          "    writer.should_equal(b\"\\\\u007f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x20)).unwrap();",
          "    writer.should_equal(b\"\\\\u0020\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    writer.should_equal(b\"\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    writer.should_equal(b\"\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    writer.should_equal(b\"\\\\\\\\\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    writer.should_equal(b\"\\\\/\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer.should_equal(b\"\\\\b\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    writer.should_equal(b\"\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    writer.should_equal(b\"\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer.should_equal(b\"\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x7F)).unwrap();",
          "    writer.should_equal(b\"\\\\u007f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x20)).unwrap();",
          "    writer.should_equal(b\"\\\\u0020\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\r\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    ",
          "    let control_byte: u8 = 0x1F; // ASCII control character",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(control_byte)).unwrap();",
          "    assert_eq!(writer, [b'\\\\', b'u', b'0', b'0', b'1', b'f']);  // Expected output for 0x1F"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    ",
          "    let control_byte: u8 = 0x1F; // ASCII control character",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(control_byte)).unwrap();",
          "    assert_eq!(writer, [b'\\\\', b'u', b'0', b'0', b'1', b'f']);  // Expected output for 0x1F",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x01)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0001\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0xFF)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u00ff\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x01)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0001\");",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0xFF)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u00ff\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0)).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'u');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    assert_eq!(writer, vec![b'\\\\', b'u', b'0', b'0', b'0', b'0']);"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0)).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'u');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    assert_eq!(writer, vec![b'\\\\', b'u', b'0', b'0', b'0', b'0']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(255)).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(255)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u00ff\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(255)).unwrap();",
          "    writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(255)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u00ff\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(128)).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\u0080\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "    ",
          "    let mut formatter = TestFormatter;",
          "    let mut writer = vec![];",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(128)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0080\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]