[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'\"');",
          "    assert_eq!(writer.as_slice(), b\"\\\\\\\"\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\\');",
          "    assert_eq!(writer.as_slice(), b\"\\\\\\\\\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'/');",
          "    assert_eq!(writer.as_slice(), b\"\\\\/\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'b');",
          "    assert_eq!(writer.as_slice(), b\"\\\\b\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    assert_eq!(writer.as_slice(), b\"\\\\f\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'n');",
          "    assert_eq!(writer.as_slice(), b\"\\\\n\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'r');",
          "    assert_eq!(writer.as_slice(), b\"\\\\r\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b't');",
          "    assert_eq!(writer.as_slice(), b\"\\\\t\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1A)).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'u');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    writer.push(b'1');",
          "    writer.push(b'a');",
          "    assert_eq!(writer.as_slice(), b\"\\\\u00da\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\"');",
          "    assert_eq!(writer.as_slice(), b\"\\\\\\\"\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\\');",
          "    assert_eq!(writer.as_slice(), b\"\\\\\\\\\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'/');",
          "    assert_eq!(writer.as_slice(), b\"\\\\/\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'b');",
          "    assert_eq!(writer.as_slice(), b\"\\\\b\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    assert_eq!(writer.as_slice(), b\"\\\\f\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'n');",
          "    assert_eq!(writer.as_slice(), b\"\\\\n\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'r');",
          "    assert_eq!(writer.as_slice(), b\"\\\\r\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b't');",
          "    assert_eq!(writer.as_slice(), b\"\\\\t\");",
          "    ",
          "    writer.clear();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1A)).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'u');",
          "    writer.push(b'0');",
          "    writer.push(b'0');",
          "    writer.push(b'1');",
          "    writer.push(b'a');",
          "    assert_eq!(writer.as_slice(), b\"\\\\u00da\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "}"
        ],
        "oracle": [
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\" );",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\" );",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x07)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0007\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus).unwrap();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\" );",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\" );",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x07)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0007\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\/\");",
          "    assert_eq!(writer.len(), 3);",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u001f\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    assert_eq!(writer.len(), 3);",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\\\\r\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\");",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u001f\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    writer.push(b'\\\\');",
          "    writer.push(b'n');",
          "    writer.push(b'\\\\');",
          "    writer.push(b'r');",
          "    writer.push(b'\\\\');",
          "    writer.push(b't');",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\"');"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    writer.push(b'\\\\');",
          "    writer.push(b'n');",
          "    writer.push(b'\\\\');",
          "    writer.push(b'r');",
          "    writer.push(b'\\\\');",
          "    writer.push(b't');",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\"');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer == b\"\\\\f\""
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    writer == b\"\\\\f\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "}"
        ],
        "oracle": [
          "    write_char_escape(&mut formatter, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    write_char_escape(&mut formatter, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    write_char_escape(&mut formatter, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    write_char_escape(&mut formatter, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    write_char_escape(&mut formatter, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    write_char_escape(&mut formatter, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    write_char_escape(&mut formatter, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    write_char_escape(&mut formatter, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    write_char_escape(&mut formatter, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0001f\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed).unwrap();",
          "    write_char_escape(&mut formatter, CharEscape::Quote).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\"\");",
          "    write_char_escape(&mut formatter, CharEscape::ReverseSolidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    write_char_escape(&mut formatter, CharEscape::Solidus).unwrap();",
          "    assert_eq!(writer, b\"\\\\/\");",
          "    write_char_escape(&mut formatter, CharEscape::Backspace).unwrap();",
          "    assert_eq!(writer, b\"\\\\b\");",
          "    write_char_escape(&mut formatter, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    write_char_escape(&mut formatter, CharEscape::LineFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\n\");",
          "    write_char_escape(&mut formatter, CharEscape::CarriageReturn).unwrap();",
          "    assert_eq!(writer, b\"\\\\r\");",
          "    write_char_escape(&mut formatter, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    write_char_escape(&mut formatter, CharEscape::AsciiControl(0x1F)).unwrap();",
          "    assert_eq!(writer, b\"\\\\u0001f\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    assert_eq!(writer.as_slice(), b\"\\\\f\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn).unwrap();",
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "    assert_eq!(writer.as_slice(), b\"\\\\f\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab).unwrap();",
          "    assert_eq!(writer, b\"\\\\t\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    for byte in 0..=255 {",
          "        formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(byte)).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\u00c0\\\\u00c1\\\\u00c2\\\\u00c3\\\\u00c4\\\\u00c5\\\\u00c6\\\\u00c7\\\\u00c8\\\\u00c9\\\\u00ca\\\\u00cb\\\\u00cc\\\\u00cd\\\\u00ce\\\\u00cf\\\\u00d0\\\\u00d1\\\\u00d2\\\\u00d3\\\\u00d4\\\\u00d5\\\\u00d6\\\\u00d7\\\\u00d8\\\\u00d9\\\\u00da\\\\u00db\\\\u00dc\\\\u00dd\\\\u00de\\\\u00df\\\\u00e0\\\\u00e1\\\\u00e2\\\\u00e3\\\\u00e4\\\\u00e5\\\\u00e6\\\\u00e7\\\\u00e8\\\\u00e9\\\\u00ea\\\\u00eb\\\\u00ec\\\\u00ed\\\\u00ee\\\\u00ef\\\\u00f0\\\\u00f1\\\\u00f2\\\\u00f3\\\\u00f4\\\\u00f5\\\\u00f6\\\\u00f7\\\\u00f8\\\\u00f9\\\\u00fa\\\\u00fb\\\\u00fc\\\\u00fd\\\\u00fe\\\\u00ff\");",
          "    assert_eq!(writer.len(), 512);",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    assert!(formatter.write_char_escape(&mut writer, CharEscape::Tab).is_ok());",
          "    assert_eq!(writer, b\"\\\\f\\\\t\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "    for byte in 0..=255 {",
          "        formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(byte)).unwrap();",
          "    }",
          "    assert_eq!(writer, b\"\\\\u00c0\\\\u00c1\\\\u00c2\\\\u00c3\\\\u00c4\\\\u00c5\\\\u00c6\\\\u00c7\\\\u00c8\\\\u00c9\\\\u00ca\\\\u00cb\\\\u00cc\\\\u00cd\\\\u00ce\\\\u00cf\\\\u00d0\\\\u00d1\\\\u00d2\\\\u00d3\\\\u00d4\\\\u00d5\\\\u00d6\\\\u00d7\\\\u00d8\\\\u00d9\\\\u00da\\\\u00db\\\\u00dc\\\\u00dd\\\\u00de\\\\u00df\\\\u00e0\\\\u00e1\\\\u00e2\\\\u00e3\\\\u00e4\\\\u00e5\\\\u00e6\\\\u00e7\\\\u00e8\\\\u00e9\\\\u00ea\\\\u00eb\\\\u00ec\\\\u00ed\\\\u00ee\\\\u00ef\\\\u00f0\\\\u00f1\\\\u00f2\\\\u00f3\\\\u00f4\\\\u00f5\\\\u00f6\\\\u00f7\\\\u00f8\\\\u00f9\\\\u00fa\\\\u00fb\\\\u00fc\\\\u00fd\\\\u00fe\\\\u00ff\");",
          "    assert_eq!(writer.len(), 512);",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed).unwrap();",
          "    assert_eq!(writer, b\"\\\\f\");",
          "    assert!(formatter.write_char_escape(&mut writer, CharEscape::Tab).is_ok());",
          "    assert_eq!(writer, b\"\\\\f\\\\t\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]