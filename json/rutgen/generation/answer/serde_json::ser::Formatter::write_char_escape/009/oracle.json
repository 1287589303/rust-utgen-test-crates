[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\"');"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    writer.push(b'\\\\');",
          "    writer.push(b'\\\"');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\"\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\\\\\\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\b\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\f\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\n\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\r\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\t\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1A));",
          "    assert_eq!(writer, b\"\\\\\\\\u001a\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "    assert_eq!(writer, b\"\\\\\\\\\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\"\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\\\\\\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\b\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\f\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\n\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\r\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    assert_eq!(writer, b\"\\\\\\\\\\\\t\");",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1A));",
          "    assert_eq!(writer, b\"\\\\\\\\u001a\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'/');",
          "    assert_eq!(writer, vec![b'\\\\', b'/']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, vec![b'\\\\', b'\"']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "    assert_eq!(writer, vec![b'\\\\', b'\\\\']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, vec![b'\\\\', b'b']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, vec![b'\\\\', b'f']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, vec![b'\\\\', b'n']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, vec![b'\\\\', b'r']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    assert_eq!(writer, vec![b'\\\\', b't']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(65));",
          "    assert_eq!(writer, vec![b'\\\\', b'u', b'0', b'0', b'4', b'a']);"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "    writer.push(b'\\\\');",
          "    writer.push(b'/');",
          "    assert_eq!(writer, vec![b'\\\\', b'/']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, vec![b'\\\\', b'\"']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "    assert_eq!(writer, vec![b'\\\\', b'\\\\']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, vec![b'\\\\', b'b']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, vec![b'\\\\', b'f']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, vec![b'\\\\', b'n']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, vec![b'\\\\', b'r']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    assert_eq!(writer, vec![b'\\\\', b't']);",
          "    ",
          "    writer.clear();",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(65));",
          "    assert_eq!(writer, vec![b'\\\\', b'u', b'0', b'0', b'4', b'a']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "}"
        ],
        "oracle": [
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, b\"\\\\\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "    assert_eq!(writer, b\"\\\\\\\\\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "    assert_eq!(writer, b\"\\\\/\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, b\"\\\\b\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, b\"\\\\f\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, b\"\\\\n\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, b\"\\\\r\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    assert_eq!(writer, b\"\\\\t\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(10));",
          "    assert_eq!(writer, b\"\\\\u000a\".to_vec());"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, b\"\\\\\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "    assert_eq!(writer, b\"\\\\\\\\\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "    assert_eq!(writer, b\"\\\\/\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, b\"\\\\b\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, b\"\\\\f\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, b\"\\\\n\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, b\"\\\\r\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    assert_eq!(writer, b\"\\\\t\".to_vec());",
          "    ",
          "    writer = Vec::new();",
          "    formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(10));",
          "    assert_eq!(writer, b\"\\\\u000a\".to_vec());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "}"
        ],
        "oracle": [
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    writer.push(b'\\\\');",
          "    writer.push(b'f');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "}"
        ],
        "oracle": [
          "    writer.as_slice() == b\"\\\\n\"",
          "    ",
          "    writer.as_slice() == b\"\\\\\\\"\"",
          "    ",
          "    writer.as_slice().len() == 2",
          "    ",
          "    writer.clear()",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    ",
          "    writer.as_slice() == b\"\\\\t\"",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    ",
          "    writer.as_slice() == b\"\\\\r\"",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(65));",
          "    ",
          "    writer.as_slice() == b\"\\\\u0041\""
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    writer.as_slice() == b\"\\\\n\"",
          "    ",
          "    writer.as_slice() == b\"\\\\\\\"\"",
          "    ",
          "    writer.as_slice().len() == 2",
          "    ",
          "    writer.clear()",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    ",
          "    writer.as_slice() == b\"\\\\t\"",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    ",
          "    writer.as_slice() == b\"\\\\r\"",
          "    ",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(65));",
          "    ",
          "    writer.as_slice() == b\"\\\\u0041\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "}"
        ],
        "oracle": [
          "    assert!(writer == b\"\\\\r\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert!(writer == b\"\\\\r\\\\\\\"\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert!(writer == b\"\\\\r\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert!(writer == b\"\\\\r\\\\\\\"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, b\"\\\\t\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\\\\\\\\\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\\\\\\\\\\\\\\\"\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1));",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\\\\\\\\\\\\\\\"\\u{0000}\\u{0001}\");"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Tab);",
          "    assert_eq!(writer, b\"\\\\t\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::CarriageReturn);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::LineFeed);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::FormFeed);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Backspace);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Solidus);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::ReverseSolidus);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\\\\\\\\\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::Quote);",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\\\\\\\\\\\\\\\"\");",
          "    let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(0x1));",
          "    assert_eq!(writer, b\"\\\\t\\\\r\\\\n\\\\f\\\\b\\\\/\\\\\\\\\\\\\\\"\\u{0000}\\u{0001}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    for byte in 0..=255 {",
          "        let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(byte));",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer[0..2], b\"\\\\u\");",
          "    assert_eq!(writer[2..4], b\"00\");",
          "    for byte in 0..=255 {",
          "    let hex_high = (byte >> 4) as usize;",
          "    let hex_low = (byte & 0xF) as usize;",
          "    assert_eq!(writer[4], b'0' + hex_high as u8);",
          "    assert_eq!(writer[5], b'0' + hex_low as u8);",
          "    }"
        ],
        "code": [
          "{",
          "    struct TestFormatter;",
          "",
          "    impl Formatter for TestFormatter {}",
          "",
          "    let mut writer = Vec::new();",
          "    let mut formatter = TestFormatter;",
          "",
          "    for byte in 0..=255 {",
          "        let _ = formatter.write_char_escape(&mut writer, CharEscape::AsciiControl(byte));",
          "    }",
          "    assert_eq!(writer[0..2], b\"\\\\u\");",
          "    assert_eq!(writer[2..4], b\"00\");",
          "    for byte in 0..=255 {",
          "    let hex_high = (byte >> 4) as usize;",
          "    let hex_low = (byte & 0xF) as usize;",
          "    assert_eq!(writer[4], b'0' + hex_high as u8);",
          "    assert_eq!(writer[5], b'0' + hex_low as u8);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]