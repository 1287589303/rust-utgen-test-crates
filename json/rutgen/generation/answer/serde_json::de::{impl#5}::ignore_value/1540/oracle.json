[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"null\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(matches!(self.parse_whitespace(), Ok(_)));",
          "    assert!(matches!(self.ignore_integer(), Ok(_)));",
          "    assert!(matches!(self.parse_ident(b\"ull\"), Ok(_)));",
          "    assert!(matches!(self.scratch.pop(), Some(frame) if frame == b'n'));",
          "    assert!(matches!(self.parse_whitespace(), Ok(_)));",
          "    assert!(matches!(self.scratch.pop(), None));"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"null\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(matches!(self.parse_whitespace(), Ok(_)));",
          "    assert!(matches!(self.ignore_integer(), Ok(_)));",
          "    assert!(matches!(self.parse_ident(b\"ull\"), Ok(_)));",
          "    assert!(matches!(self.scratch.pop(), Some(frame) if frame == b'n'));",
          "    assert!(matches!(self.parse_whitespace(), Ok(_)));",
          "    assert!(matches!(self.scratch.pop(), None));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"true\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(deserializer.scratch.is_empty());",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'\\0'))));",
          "    assert!(matches!(deserializer.read.peek(), Ok(Some(b'\\0'))));",
          "    assert!(matches!(deserializer.read.discard(), ()));",
          "    assert!(matches!(deserializer.read.ignore_str(), Ok(())));",
          "    assert!(matches!(self.peek_error(ErrorCode::EofWhileParsingValue), Err(_)));",
          "    assert!(matches!(self.peek_error(ErrorCode::InvalidNumber), Err(_)));",
          "    assert!(matches!(self.peek_error(ErrorCode::ExpectedSomeValue), Err(_)));"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"true\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'\\0'))));",
          "    assert!(matches!(deserializer.read.peek(), Ok(Some(b'\\0'))));",
          "    assert!(matches!(deserializer.read.discard(), ()));",
          "    assert!(matches!(deserializer.read.ignore_str(), Ok(())));",
          "    assert!(matches!(self.peek_error(ErrorCode::EofWhileParsingValue), Err(_)));",
          "    assert!(matches!(self.peek_error(ErrorCode::InvalidNumber), Err(_)));",
          "    assert!(matches!(self.peek_error(ErrorCode::ExpectedSomeValue), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"false\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.peek().is_err());",
          "    assert!(matches!(deserializer.peek_error(ErrorCode::ExpectedSomeValue), Error));",
          "    assert!(matches!(deserializer.peek_error(ErrorCode::EofWhileParsingValue), Error));",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert!(deserializer.read.next().is_err());",
          "    assert!(deserializer.read.peek().is_err());",
          "    assert!(deserializer.read.byte_offset() == 0);"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"false\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.peek().is_err());",
          "    assert!(matches!(deserializer.peek_error(ErrorCode::ExpectedSomeValue), Error));",
          "    assert!(matches!(deserializer.peek_error(ErrorCode::EofWhileParsingValue), Error));",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert!(deserializer.read.next().is_err());",
          "    assert!(deserializer.read.peek().is_err());",
          "    assert!(deserializer.read.byte_offset() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"-42\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.scratch, vec![]);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(deserializer.peek_or_null().is_ok());",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b']'))));",
          "    assert!(matches!(deserializer.parse_whitespace(), Ok(Some(b'd'))));",
          "    assert!(deserializer.ignore_integer().is_ok());",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'0'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'1'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'2'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'3'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'4'))));",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b','))));",
          "    assert_eq!(deserializer.end(), Ok(()));"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"-42\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert_eq!(deserializer.scratch, vec![]);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(deserializer.peek_or_null().is_ok());",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b']'))));",
          "    assert!(matches!(deserializer.parse_whitespace(), Ok(Some(b'd'))));",
          "    assert!(deserializer.ignore_integer().is_ok());",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'0'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'1'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'2'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'3'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'4'))));",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b','))));",
          "    assert_eq!(deserializer.end(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"123\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.scratch, vec![]);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(deserializer.read.peek().is_ok());",
          "    assert!(deserializer.read.next().is_ok());",
          "    assert!(deserializer.peek().is_ok());",
          "    assert!(deserializer.peek_error(ErrorCode::ExpectedSomeValue).err.is_some());",
          "    assert!(deserializer.read.ignore_str().is_ok());",
          "    assert!(deserializer.parse_whitespace().is_ok());",
          "    assert!(deserializer.parse_ident(b\"ull\").is_ok());",
          "    assert!(deserializer.ignore_integer().is_ok());",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b']'))));",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b'}'))));"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"123\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert_eq!(deserializer.scratch, vec![]);",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(deserializer.read.peek().is_ok());",
          "    assert!(deserializer.read.next().is_ok());",
          "    assert!(deserializer.peek().is_ok());",
          "    assert!(deserializer.peek_error(ErrorCode::ExpectedSomeValue).err.is_some());",
          "    assert!(deserializer.read.ignore_str().is_ok());",
          "    assert!(deserializer.parse_whitespace().is_ok());",
          "    assert!(deserializer.parse_ident(b\"ull\").is_ok());",
          "    assert!(deserializer.ignore_integer().is_ok());",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b']'))));",
          "    assert!(matches!(deserializer.peek(), Ok(Some(b'}'))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"{}\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert_eq!(deserializer.read.byte_offset(), 2);",
          "    assert!(deserializer.peek().is_ok());",
          "    assert!(deserializer.read.peek_position().line <= 1);",
          "    assert!(deserializer.read.peek_position().column <= 2);",
          "    assert!(matches!(deserializer.ignore_value(), Ok(_)));"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"{}\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert_eq!(deserializer.remaining_depth, 0);",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert_eq!(deserializer.read.byte_offset(), 2);",
          "    assert!(deserializer.peek().is_ok());",
          "    assert!(deserializer.read.peek_position().line <= 1);",
          "    assert!(deserializer.read.peek_position().column <= 2);",
          "    assert!(matches!(deserializer.ignore_value(), Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"[]\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    self.parse_whitespace() matches core::result::Result::Ok(val) at line 1105 is true",
          "    self.ignore_integer() matches core::result::Result::Ok(val) at line 1130 is true",
          "    self.parse_whitespace() matches core::result::Result::Err(err) at line 1105 is true",
          "    match $e {",
          "    core::result::Result::Ok(val) => val,",
          "    core::result::Result::Err(err) => return core::result::Result::Err(err),",
          "    } matches Some(b) at line 408 is true",
          "    peek matches b'n' at line 1113 is true",
          "    peek matches b'n' at line 1112 is true",
          "    self.parse_ident(b\"ull\") matches core::result::Result::Ok(val) at line 1115 is true",
          "    self.ignore_integer() matches core::result::Result::Ok(val) at line 1130 is true",
          "    frame matches None at line 1150 is true",
          "    enclosing.take() matches None at line 1152 is true",
          "    self.scratch.pop() matches Some(frame) at line 1154 is true",
          "    self.scratch.pop() matches Some(frame) at line 1154 is true",
          "    self.parse_whitespace() matches core::result::Result::Ok(val) at line 1162 is true",
          "    self.ignore_integer() matches core::result::Result::Ok(val) at line 1130 is true",
          "    self.parse_whitespace() matches core::result::Result::Err(err) at line 1162 is true",
          "    self.parse_whitespace() matches at line 1162 is true",
          "    match $e {",
          "    core::result::Result::Ok(val) => val,",
          "    core::result::Result::Err(err) => return core::result::Result::Err(err),",
          "    } matches Some(b']') at line 408 is true",
          "    frame == b'[' at line 1167 is false",
          "    self.scratch.pop() matches None at line 1190 is true",
          "    Ok(())"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"[]\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    self.parse_whitespace() matches core::result::Result::Ok(val) at line 1105 is true",
          "    self.ignore_integer() matches core::result::Result::Ok(val) at line 1130 is true",
          "    self.parse_whitespace() matches core::result::Result::Err(err) at line 1105 is true",
          "    match $e {",
          "    core::result::Result::Ok(val) => val,",
          "    core::result::Result::Err(err) => return core::result::Result::Err(err),",
          "    } matches Some(b) at line 408 is true",
          "    peek matches b'n' at line 1113 is true",
          "    peek matches b'n' at line 1112 is true",
          "    self.parse_ident(b\"ull\") matches core::result::Result::Ok(val) at line 1115 is true",
          "    self.ignore_integer() matches core::result::Result::Ok(val) at line 1130 is true",
          "    frame matches None at line 1150 is true",
          "    enclosing.take() matches None at line 1152 is true",
          "    self.scratch.pop() matches Some(frame) at line 1154 is true",
          "    self.scratch.pop() matches Some(frame) at line 1154 is true",
          "    self.parse_whitespace() matches core::result::Result::Ok(val) at line 1162 is true",
          "    self.ignore_integer() matches core::result::Result::Ok(val) at line 1130 is true",
          "    self.parse_whitespace() matches core::result::Result::Err(err) at line 1162 is true",
          "    self.parse_whitespace() matches at line 1162 is true",
          "    match $e {",
          "    core::result::Result::Ok(val) => val,",
          "    core::result::Result::Err(err) => return core::result::Result::Err(err),",
          "    } matches Some(b']') at line 408 is true",
          "    frame == b'[' at line 1167 is false",
          "    self.scratch.pop() matches None at line 1190 is true",
          "    Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"{\\\"key\\\": {\\\"nested\\\": true}}\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert!(matches!(deserializer.remaining_depth, 0));",
          "    assert!(deserializer.peek().is_ok());",
          "    assert!(deserializer.read.position().is_valid());",
          "    assert_eq!(deserializer.read.byte_offset(), expected_byte_offset);",
          "    assert!(deserializer.peek_position().line > 0);",
          "    assert!(deserializer.peek_position().column > 0);",
          "    assert_eq!(deserializer.read.next().unwrap(), None);",
          "    assert!(deserializer.read.discard().is_ok());",
          "    assert_eq!(deserializer.end().is_ok(), true);"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"{\\\"key\\\": {\\\"nested\\\": true}}\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert!(matches!(deserializer.remaining_depth, 0));",
          "    assert!(deserializer.peek().is_ok());",
          "    assert!(deserializer.read.position().is_valid());",
          "    assert_eq!(deserializer.read.byte_offset(), expected_byte_offset);",
          "    assert!(deserializer.peek_position().line > 0);",
          "    assert!(deserializer.peek_position().column > 0);",
          "    assert_eq!(deserializer.read.next().unwrap(), None);",
          "    assert!(deserializer.read.discard().is_ok());",
          "    assert_eq!(deserializer.end().is_ok(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"  \\n\\t   null   \\t  \"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    self.scratch.clear();",
          "    let peek = match tri!(self.parse_whitespace()) {",
          "    Some(b'n') => b'n',",
          "    _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),",
          "    };",
          "    self.eat_char();",
          "    tri!(self.parse_ident(b\"ull\"));",
          "    self.ignore_integer();",
          "    let frame = None;",
          "    let accept_comma = true;",
          "    let enclosing = None;",
          "    self.scratch.pop().unwrap();",
          "    self.eat_char();",
          "    let new_peek = match tri!(self.parse_whitespace()) {",
          "    Some(b']') => b']',",
          "    _ => return Ok(()),",
          "    };",
          "    self.scratch.pop().is_none();",
          "    Ok(())"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"  \\n\\t   null   \\t  \"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    self.scratch.clear();",
          "    let peek = match tri!(self.parse_whitespace()) {",
          "    Some(b'n') => b'n',",
          "    _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),",
          "    };",
          "    self.eat_char();",
          "    tri!(self.parse_ident(b\"ull\"));",
          "    self.ignore_integer();",
          "    let frame = None;",
          "    let accept_comma = true;",
          "    let enclosing = None;",
          "    self.scratch.pop().unwrap();",
          "    self.eat_char();",
          "    let new_peek = match tri!(self.parse_whitespace()) {",
          "    Some(b']') => b']',",
          "    _ => return Ok(()),",
          "    };",
          "    self.scratch.pop().is_none();",
          "    Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"invalid\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(deserializer.ignore_value(), Err(deserializer.peek_error(ErrorCode::EofWhileParsingValue)));",
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert!(deserializer.remaining_depth == 0);",
          "    assert!(deserializer.read.position().byte_offset() == 0);",
          "    assert!(deserializer.read.peek().is_err());",
          "    assert!(deserializer.read.next().is_err());",
          "    assert!(deserializer.read.peek_position().line == 1);",
          "    assert!(deserializer.read.peek_position().column == 1);"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"invalid\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert_eq!(deserializer.ignore_value(), Err(deserializer.peek_error(ErrorCode::EofWhileParsingValue)));",
          "    assert_eq!(deserializer.scratch.len(), 0);",
          "    assert!(deserializer.remaining_depth == 0);",
          "    assert!(deserializer.read.position().byte_offset() == 0);",
          "    assert!(deserializer.read.peek().is_err());",
          "    assert!(deserializer.read.next().is_err());",
          "    assert!(deserializer.read.peek_position().line == 1);",
          "    assert!(deserializer.read.peek_position().column == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"[1, 2, 3,]\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(deserializer.ignore_value(), Err(ErrorCode::ExpectedListCommaOrEnd)));",
          "    assert!(matches!(deserializer.ignore_value(), Ok(())));",
          "    assert!(matches!(deserializer.read.byte_offset(), 0));",
          "    assert!(matches!(deserializer.remaining_depth, 0));",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert!(deserializer.read.peek().is_ok());",
          "    assert!(deserializer.read.next().is_ok());",
          "    assert!(deserializer.read.position().line > 0);",
          "    assert!(deserializer.read.position().column > 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(matches!(deserializer.parse_whitespace(), Ok(Some(b','))));",
          "    assert!(matches!(deserializer.read.ignore_str(), Ok(())));",
          "    assert!(matches!(deserializer.ignore_integer(), Ok(())));",
          "    assert!(matches!(deserializer.parse_ident(b\"ull\"), Ok(())));",
          "    assert!(matches!(deserializer.scratch.len(), 0));",
          "    assert!(matches!(deserializer.remaining_depth, 0));",
          "    assert!(matches!(deserializer.peek_or_null(), Ok(b']')));",
          "    assert!(matches!(deserializer.next_char_or_null(), Ok(Some(b'1'))));",
          "    assert!(matches!(deserializer.next_char(), Ok(Some(b','))));",
          "    assert!(matches!(deserializer.eat_char(), ()));",
          "    assert!(matches!(deserializer.parse_whitespace(), Err(ErrorCode::EofWhileParsingValue)));",
          "    assert!(matches!(deserializer.scratch.pop(), None));"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"[1, 2, 3,]\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert!(matches!(deserializer.ignore_value(), Err(ErrorCode::ExpectedListCommaOrEnd)));",
          "    assert!(matches!(deserializer.ignore_value(), Ok(())));",
          "    assert!(matches!(deserializer.read.byte_offset(), 0));",
          "    assert!(matches!(deserializer.remaining_depth, 0));",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert!(deserializer.read.peek().is_ok());",
          "    assert!(deserializer.read.next().is_ok());",
          "    assert!(deserializer.read.position().line > 0);",
          "    assert!(deserializer.read.position().column > 0);",
          "    assert!(deserializer.read.byte_offset() > 0);",
          "    assert!(matches!(deserializer.parse_whitespace(), Ok(Some(b','))));",
          "    assert!(matches!(deserializer.read.ignore_str(), Ok(())));",
          "    assert!(matches!(deserializer.ignore_integer(), Ok(())));",
          "    assert!(matches!(deserializer.parse_ident(b\"ull\"), Ok(())));",
          "    assert!(matches!(deserializer.scratch.len(), 0));",
          "    assert!(matches!(deserializer.remaining_depth, 0));",
          "    assert!(matches!(deserializer.peek_or_null(), Ok(b']')));",
          "    assert!(matches!(deserializer.next_char_or_null(), Ok(Some(b'1'))));",
          "    assert!(matches!(deserializer.next_char(), Ok(Some(b','))));",
          "    assert!(matches!(deserializer.eat_char(), ()));",
          "    assert!(matches!(deserializer.parse_whitespace(), Err(ErrorCode::EofWhileParsingValue)));",
          "    assert!(matches!(deserializer.scratch.pop(), None));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"{\\\"key\\\": \\\"value\\\",}\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(deserializer.scratch.is_empty());",
          "    assert!(deserializer.remaining_depth == 0);",
          "    assert!(matches!(deserializer.ignore_value(), Err(ErrorCode::TrailingComma)));"
        ],
        "code": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::new(\"{\\\"key\\\": \\\"value\\\",}\"),",
          "        scratch: vec![],",
          "        remaining_depth: 0,",
          "    };",
          "    deserializer.ignore_value().unwrap();",
          "    assert!(deserializer.scratch.is_empty());",
          "    assert!(deserializer.remaining_depth == 0);",
          "    assert!(matches!(deserializer.ignore_value(), Err(ErrorCode::TrailingComma)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]