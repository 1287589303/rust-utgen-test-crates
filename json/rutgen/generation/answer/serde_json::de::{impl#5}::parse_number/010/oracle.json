[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"123.45\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(true, 123);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(ParserNumber::F64(123.45)));",
          "    assert!(matches!(deserializer.read.peek(), Ok(Some(b'.'))));",
          "    assert!(matches!(deserializer.read.peek(), Ok(Some(b'e'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'4'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'5'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(None)));"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"123.45\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(true, 123);",
          "    assert_eq!(result, Ok(ParserNumber::F64(123.45)));",
          "    assert!(matches!(deserializer.read.peek(), Ok(Some(b'.'))));",
          "    assert!(matches!(deserializer.read.peek(), Ok(Some(b'e'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'4'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(Some(b'5'))));",
          "    assert!(matches!(deserializer.read.next(), Ok(None)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"1e10\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(true, 1);",
          "}"
        ],
        "oracle": [
          "    let expected_result = Ok(ParserNumber::F64(1e10));",
          "    assert_eq!(result, expected_result);",
          "    ",
          "    let input = b\"1.5\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(true, 15);",
          "    let expected_result = Ok(ParserNumber::F64(1.5));",
          "    assert_eq!(result, expected_result);",
          "    ",
          "    let input = b\"-2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(false, 2);",
          "    let expected_result = Ok(ParserNumber::I64(-2));",
          "    assert_eq!(result, expected_result);",
          "    ",
          "    let input = b\"0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(false, 0);",
          "    let expected_result = Ok(ParserNumber::F64(-0.0));",
          "    assert_eq!(result, expected_result);"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"1e10\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(true, 1);",
          "    let expected_result = Ok(ParserNumber::F64(1e10));",
          "    assert_eq!(result, expected_result);",
          "    ",
          "    let input = b\"1.5\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(true, 15);",
          "    let expected_result = Ok(ParserNumber::F64(1.5));",
          "    assert_eq!(result, expected_result);",
          "    ",
          "    let input = b\"-2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(false, 2);",
          "    let expected_result = Ok(ParserNumber::I64(-2));",
          "    assert_eq!(result, expected_result);",
          "    ",
          "    let input = b\"0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(false, 0);",
          "    let expected_result = Ok(ParserNumber::F64(-0.0));",
          "    assert_eq!(result, expected_result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(true, 0);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::U64(val) => assert_eq!(val, 0),",
          "    _ => panic!(\"Expected ParserNumber::U64(0), found {:?}\", number),",
          "    }",
          "    ",
          "    let input = b\".5\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(true, 5);",
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::F64(val) => assert_eq!(val, 0.5),",
          "    _ => panic!(\"Expected ParserNumber::F64(0.5), found {:?}\", number),",
          "    }",
          "    ",
          "    let input = b\"5e2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(true, 5);",
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::F64(val) => assert_eq!(val, 500.0),",
          "    _ => panic!(\"Expected ParserNumber::F64(500.0), found {:?}\", number),",
          "    }",
          "    ",
          "    let input = b\"-5\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(false, 5);",
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::I64(val) => assert_eq!(val, -5),",
          "    _ => panic!(\"Expected ParserNumber::I64(-5), found {:?}\", number),",
          "    }"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(true, 0);",
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::U64(val) => assert_eq!(val, 0),",
          "    _ => panic!(\"Expected ParserNumber::U64(0), found {:?}\", number),",
          "    }",
          "    ",
          "    let input = b\".5\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(true, 5);",
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::F64(val) => assert_eq!(val, 0.5),",
          "    _ => panic!(\"Expected ParserNumber::F64(0.5), found {:?}\", number),",
          "    }",
          "    ",
          "    let input = b\"5e2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(true, 5);",
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::F64(val) => assert_eq!(val, 500.0),",
          "    _ => panic!(\"Expected ParserNumber::F64(500.0), found {:?}\", number),",
          "    }",
          "    ",
          "    let input = b\"-5\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    let result = deserializer.parse_number(false, 5);",
          "    assert!(result.is_ok());",
          "    let number = result.unwrap();",
          "    match number {",
          "    ParserNumber::I64(val) => assert_eq!(val, -5),",
          "    _ => panic!(\"Expected ParserNumber::I64(-5), found {:?}\", number),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"-0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(false, 0);",
          "}"
        ],
        "oracle": [
          "    let input = b\"-0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(false, 0);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, 0.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for negative zero\");",
          "    }",
          "    let input = b\"123\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(true, 123);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::U64(val)) => {",
          "    assert_eq!(val, 123);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::U64 for positive integer\");",
          "    }",
          "    let input = b\"1.23\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(true, 123);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, 1.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for decimal\");",
          "    }",
          "    let input = b\"1e2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(true, 1);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, 100.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for scientific notation\");",
          "    }",
          "    let input = b\"-1e2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(false, 1);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, -100.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for negative scientific notation\");",
          "    }"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        bytes: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                let byte = self.bytes[self.position];",
          "                self.position += 1;",
          "                Ok(Some(byte))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.bytes.len() {",
          "                Ok(Some(self.bytes[self.position]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        fn position(&self) -> Position { Position::default() }",
          "        fn peek_position(&self) -> Position { Position::default() }",
          "        fn byte_offset(&self) -> usize { self.position }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "        fn parse_str_raw<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> { unimplemented!() }",
          "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
          "        fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }",
          "    }",
          "",
          "    let input = b\"-0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "",
          "    let result = deserializer.parse_number(false, 0);",
          "    let input = b\"-0\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(false, 0);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, 0.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for negative zero\");",
          "    }",
          "    let input = b\"123\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(true, 123);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::U64(val)) => {",
          "    assert_eq!(val, 123);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::U64 for positive integer\");",
          "    }",
          "    let input = b\"1.23\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(true, 123);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, 1.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for decimal\");",
          "    }",
          "    let input = b\"1e2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(true, 1);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, 100.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for scientific notation\");",
          "    }",
          "    let input = b\"-1e2\";",
          "    let mut reader = MockRead { bytes: input.to_vec(), position: 0 };",
          "    let mut deserializer = Deserializer { read: reader, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.parse_number(false, 1);",
          "    assert!(result.is_ok());",
          "    match result {",
          "    Ok(ParserNumber::F64(val)) => {",
          "    assert_eq!(val, -100.0);",
          "    }",
          "    _ => panic!(\"Expected ParserNumber::F64 for negative scientific notation\");",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]