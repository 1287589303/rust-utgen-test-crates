[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_i128(42).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 42.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert!(value.matches(Value::Number(number)));",
          "    let number_neg = Number::from_i128(-42).unwrap();",
          "    let value_neg = Value::Number(number_neg);",
          "    let result_neg = eq_f32(&value_neg, -42.0);",
          "    assert_eq!(result_neg, true);",
          "    let number_float = Number::from_f64(42.0).unwrap();",
          "    let value_float = Value::Number(number_float);",
          "    let result_float = eq_f32(&value_float, 42.0);",
          "    assert_eq!(result_float, true);",
          "    let result_non_match = eq_f32(&value_float, 43.0);",
          "    assert_eq!(result_non_match, false);",
          "    let result_other_type = eq_f32(&Value::Bool(true), 42.0);",
          "    assert_eq!(result_other_type, false);"
        ],
        "code": [
          "{",
          "    let number = Number::from_i128(42).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 42.0);",
          "    assert_eq!(result, true);",
          "    assert!(value.matches(Value::Number(number)));",
          "    let number_neg = Number::from_i128(-42).unwrap();",
          "    let value_neg = Value::Number(number_neg);",
          "    let result_neg = eq_f32(&value_neg, -42.0);",
          "    assert_eq!(result_neg, true);",
          "    let number_float = Number::from_f64(42.0).unwrap();",
          "    let value_float = Value::Number(number_float);",
          "    let result_float = eq_f32(&value_float, 42.0);",
          "    assert_eq!(result_float, true);",
          "    let result_non_match = eq_f32(&value_float, 43.0);",
          "    assert_eq!(result_non_match, false);",
          "    let result_other_type = eq_f32(&Value::Bool(true), 42.0);",
          "    assert_eq!(result_other_type, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_i128(-42).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -42.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(-42.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -42.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(42.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 42.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(42.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 42.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(42.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 100.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 42.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 42.0);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let number = Number::from_i128(-42).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -42.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(-42.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -42.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(42.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 42.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(42.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 42.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(42.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 100.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 42.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 42.0);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_i128(0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(1.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 1.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(-1.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -1.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(3.14).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 3.14);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(2.71).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.71);",
          "    assert_eq!(result, true);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::String(\"test\".to_string());",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Array(vec![]);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Object(Map::new());",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let number = Number::from_i128(0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(1.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 1.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(-1.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -1.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(3.14).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 3.14);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f32(2.71).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.71);",
          "    assert_eq!(result, true);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::String(\"test\".to_string());",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Array(vec![]);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Object(Map::new());",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.34);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.0);",
          "    assert_eq!(result, false);",
          "    let number = Number::from_f64(-5.67).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -5.67);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(3.14).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 3.14159);",
          "    assert_eq!(result, false);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.34);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.0);",
          "    assert_eq!(result, false);",
          "    let number = Number::from_f64(-5.67).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -5.67);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(3.14).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 3.14159);",
          "    assert_eq!(result, false);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_f64(-12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -12.34);",
          "}"
        ],
        "oracle": [
          "    assert!(result);"
        ],
        "code": [
          "{",
          "    let number = Number::from_f64(-12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -12.34);",
          "    assert!(result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);"
        ],
        "code": [
          "{",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_f64(f32::NAN as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::NAN);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false);",
          "    let number = Number::from_f64(1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(-1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -1.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(2.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(1.1).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.1);",
          "    assert_eq!(result, false);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::String(String::from(\"test\"));",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Array(vec![]);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Object(std::collections::BTreeMap::new());",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let number = Number::from_f64(f32::NAN as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::NAN);",
          "    assert_eq!(result, false);",
          "    let number = Number::from_f64(1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(-1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, -1.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(2.5).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.5);",
          "    assert_eq!(result, true);",
          "    let number = Number::from_f64(1.1).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.1);",
          "    assert_eq!(result, false);",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Bool(true);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::String(String::from(\"test\"));",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Array(vec![]);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "    let value = Value::Object(std::collections::BTreeMap::new());",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::INFINITY);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::NEG_INFINITY);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.0);",
          "    assert_eq!(result, false);",
          "    ",
          "    let value_not_number = Value::Null;",
          "    let result = eq_f32(&value_not_number, f32::INFINITY);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::INFINITY);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::NEG_INFINITY);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 1.0);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(1.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 2.0);",
          "    assert_eq!(result, false);",
          "    ",
          "    let value_not_number = Value::Null;",
          "    let result = eq_f32(&value_not_number, f32::INFINITY);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::NEG_INFINITY);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::INFINITY);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.34);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.35);",
          "    assert_eq!(result, false);",
          "    ",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 12.34);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::NEG_INFINITY);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, f32::INFINITY);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(0.0).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 0.0);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.34);",
          "    assert_eq!(result, true);",
          "    ",
          "    let number = Number::from_f64(12.34).unwrap();",
          "    let value = Value::Number(number);",
          "    let result = eq_f32(&value, 12.35);",
          "    assert_eq!(result, false);",
          "    ",
          "    let value = Value::Null;",
          "    let result = eq_f32(&value, 12.34);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]