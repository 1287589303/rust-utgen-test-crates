[
  {
    "uses": [
      "use serde::Serialize;",
      "use std::collections::HashMap;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct EmptyStruct;",
          "",
          "    let value = EmptyStruct;",
          "    let _result = serde_json::to_string_pretty(&value);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(serde_json::to_string_pretty(&EmptyStruct), Ok(String::from(\"{}\")))"
        ],
        "code": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct EmptyStruct;",
          "",
          "    let value = EmptyStruct;",
          "    let _result = serde_json::to_string_pretty(&value);",
          "    assert_eq!(serde_json::to_string_pretty(&EmptyStruct), Ok(String::from(\"{}\")))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct SimpleStruct {",
          "        field1: String,",
          "        field2: u32,",
          "    }",
          "",
          "    let value = SimpleStruct {",
          "        field1: String::from(\"test\"),",
          "        field2: 42,",
          "    };",
          "    let _result = serde_json::to_string_pretty(&value);",
          "}"
        ],
        "oracle": [
          "    assert!(_result.is_ok());",
          "    let result_value = _result.unwrap();",
          "    assert_eq!(result_value, r#\"{ \"field1\": \"test\", \"field2\": 42 }\"#);"
        ],
        "code": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct SimpleStruct {",
          "        field1: String,",
          "        field2: u32,",
          "    }",
          "",
          "    let value = SimpleStruct {",
          "        field1: String::from(\"test\"),",
          "        field2: 42,",
          "    };",
          "    let _result = serde_json::to_string_pretty(&value);",
          "    assert!(_result.is_ok());",
          "    let result_value = _result.unwrap();",
          "    assert_eq!(result_value, r#\"{ \"field1\": \"test\", \"field2\": 42 }\"#);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct NestedStruct {",
          "        name: String,",
          "        age: u32,",
          "    }",
          "",
          "    #[derive(serde::Serialize)]",
          "    struct ParentStruct {",
          "        child: NestedStruct,",
          "    }",
          "",
          "    let value = ParentStruct {",
          "        child: NestedStruct {",
          "            name: String::from(\"child\"),",
          "            age: 5,",
          "        },",
          "    };",
          "    let _result = serde_json::to_string_pretty(&value);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Ok(r#\"{ \"child\": { \"name\": \"child\", \"age\": 5 } }\"#));"
        ],
        "code": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct NestedStruct {",
          "        name: String,",
          "        age: u32,",
          "    }",
          "",
          "    #[derive(serde::Serialize)]",
          "    struct ParentStruct {",
          "        child: NestedStruct,",
          "    }",
          "",
          "    let value = ParentStruct {",
          "        child: NestedStruct {",
          "            name: String::from(\"child\"),",
          "            age: 5,",
          "        },",
          "    };",
          "    let _result = serde_json::to_string_pretty(&value);",
          "    assert_eq!(_result, Ok(r#\"{ \"child\": { \"name\": \"child\", \"age\": 5 } }\"#));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Serialize;",
          "    use std::collections::HashMap;",
          "",
          "    let value: HashMap<String, String> = HashMap::new();",
          "    let _result = serde_json::to_string_pretty(&value);",
          "}"
        ],
        "oracle": [
          "    let value: HashMap<String, String> = HashMap::new();",
          "    let result = serde_json::to_string_pretty(&value);",
          "    assert_eq!(result, Ok(String::from(\"{}\")));"
        ],
        "code": [
          "{",
          "    use serde::Serialize;",
          "    use std::collections::HashMap;",
          "",
          "    let value: HashMap<String, String> = HashMap::new();",
          "    let _result = serde_json::to_string_pretty(&value);",
          "    let value: HashMap<String, String> = HashMap::new();",
          "    let result = serde_json::to_string_pretty(&value);",
          "    assert_eq!(result, Ok(String::from(\"{}\")));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use serde::Serialize;",
          "    use std::collections::HashMap;",
          "",
          "    let mut value = HashMap::new();",
          "    value.insert(String::from(\"key1\"), String::from(\"value1\"));",
          "    value.insert(String::from(\"key2\"), String::from(\"value2\"));",
          "    let _result = serde_json::to_string_pretty(&value);",
          "}"
        ],
        "oracle": [
          "    assert!(_result.is_ok());",
          "    assert_eq!(_result.unwrap(), r#\"{ \"key1\": \"value1\", \"key2\": \"value2\" }\"#);",
          "    assert!(_result.unwrap().contains(\"key1\"));",
          "    assert!(_result.unwrap().contains(\"value1\"));",
          "    assert!(_result.unwrap().contains(\"key2\"));",
          "    assert!(_result.unwrap().contains(\"value2\"));"
        ],
        "code": [
          "{",
          "    use serde::Serialize;",
          "    use std::collections::HashMap;",
          "",
          "    let mut value = HashMap::new();",
          "    value.insert(String::from(\"key1\"), String::from(\"value1\"));",
          "    value.insert(String::from(\"key2\"), String::from(\"value2\"));",
          "    let _result = serde_json::to_string_pretty(&value);",
          "    assert!(_result.is_ok());",
          "    assert_eq!(_result.unwrap(), r#\"{ \"key1\": \"value1\", \"key2\": \"value2\" }\"#);",
          "    assert!(_result.unwrap().contains(\"key1\"));",
          "    assert!(_result.unwrap().contains(\"value1\"));",
          "    assert!(_result.unwrap().contains(\"key2\"));",
          "    assert!(_result.unwrap().contains(\"value2\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct LargeStruct {",
          "        data: Vec<u32>,",
          "    }",
          "",
          "    let value = LargeStruct {",
          "        data: (0..1000).collect(),",
          "    };",
          "    let _result = serde_json::to_string_pretty(&value);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.is_ok(), true);",
          "    assert!(matches!(_result, Ok(_)));",
          "    assert!(matches!(_result.unwrap(), String(_)));",
          "    assert!(!_result.unwrap().is_empty());",
          "    assert_eq!(_result.unwrap().lines().count() > 1, true);",
          "    assert_eq!(_result.unwrap().contains(\"\\n\"), true);"
        ],
        "code": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct LargeStruct {",
          "        data: Vec<u32>,",
          "    }",
          "",
          "    let value = LargeStruct {",
          "        data: (0..1000).collect(),",
          "    };",
          "    let _result = serde_json::to_string_pretty(&value);",
          "    assert_eq!(_result.is_ok(), true);",
          "    assert!(matches!(_result, Ok(_)));",
          "    assert!(matches!(_result.unwrap(), String(_)));",
          "    assert!(!_result.unwrap().is_empty());",
          "    assert_eq!(_result.unwrap().lines().count() > 1, true);",
          "    assert_eq!(_result.unwrap().contains(\"\\n\"), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct NonSerializable;",
          "",
          "    let value = NonSerializable;",
          "    let _result = serde_json::to_string_pretty(&value);",
          "}"
        ],
        "oracle": [
          "    assert!(serde_json::to_string_pretty(&NonSerializable).is_err());"
        ],
        "code": [
          "{",
          "    struct NonSerializable;",
          "",
          "    let value = NonSerializable;",
          "    let _result = serde_json::to_string_pretty(&value);",
          "    assert!(serde_json::to_string_pretty(&NonSerializable).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]