[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(0);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(Number::from(0)));",
          "    assert!(matches!(x, Value::Number(_)));"
        ],
        "code": [
          "{",
          "    let n = Number::from(0);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(Number::from(0)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(42);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(Number::from(42)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    assert!(matches!(Value::from(None::<Number>), Value::Null));",
          "    let n_negative = Number::from(-10);",
          "    let x_negative: Value = Value::from(n_negative);",
          "    assert_eq!(x_negative, Value::Number(Number::from(-10)));"
        ],
        "code": [
          "{",
          "    let n = Number::from(42);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(Number::from(42)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    assert!(matches!(Value::from(None::<Number>), Value::Null));",
          "    let n_negative = Number::from(-10);",
          "    let x_negative: Value = Value::from(n_negative);",
          "    assert_eq!(x_negative, Value::Number(Number::from(-10)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(-42);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(Number::from(-42)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    assert!(std::mem::discriminant(&x) == std::mem::discriminant(&Value::Number(Number::from(-42))));"
        ],
        "code": [
          "{",
          "    let n = Number::from(-42);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(Number::from(-42)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    assert!(std::mem::discriminant(&x) == std::mem::discriminant(&Value::Number(Number::from(-42))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(1_000_000);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(Number::from(1_000_000)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    assert!(x == Value::Number(Number::from(1_000_000)));",
          "    assert!(x.is_number());",
          "    assert!(x.as_number().unwrap() == Number::from(1_000_000));",
          "    assert!(format!(\"{:?}\", x) == \"Number(Number { n: ... })\");"
        ],
        "code": [
          "{",
          "    let n = Number::from(1_000_000);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(Number::from(1_000_000)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    assert!(x == Value::Number(Number::from(1_000_000)));",
          "    assert!(x.is_number());",
          "    assert!(x.as_number().unwrap() == Number::from(1_000_000));",
          "    assert!(format!(\"{:?}\", x) == \"Number(Number { n: ... })\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(-1_000_000);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(Number::from(-1_000_000)));"
        ],
        "code": [
          "{",
          "    let n = Number::from(-1_000_000);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(Number::from(-1_000_000)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(0.1);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(Number::from(0.1)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    let n = Number::from(-3.5);",
          "    let x2: Value = Value::from(n);",
          "    assert_eq!(x2, Value::Number(Number::from(-3.5)));",
          "    let n3 = Number::from(100);",
          "    let x3: Value = Value::from(n3);",
          "    assert_eq!(x3, Value::Number(Number::from(100)));",
          "    let n4 = Number::from(0);",
          "    let x4: Value = Value::from(n4);",
          "    assert_eq!(x4, Value::Number(Number::from(0)));",
          "    let n5 = Number::from(1.234);",
          "    let x5: Value = Value::from(n5);",
          "    assert_eq!(x5, Value::Number(Number::from(1.234)));",
          "    let n6 = Number::from(-1);",
          "    let x6: Value = Value::from(n6);",
          "    assert_eq!(x6, Value::Number(Number::from(-1)));",
          "    let n7 = Number::from(f64::INFINITY);",
          "    let x7: Value = Value::from(n7);",
          "    assert_eq!(x7, Value::Number(Number::from(f64::INFINITY)));",
          "    let n8 = Number::from(f64::NAN);",
          "    let x8: Value = Value::from(n8);",
          "    assert!(matches!(x8, Value::Number(Number::from(f64::NAN))));"
        ],
        "code": [
          "{",
          "    let n = Number::from(0.1);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(Number::from(0.1)));",
          "    assert!(matches!(x, Value::Number(_)));",
          "    let n = Number::from(-3.5);",
          "    let x2: Value = Value::from(n);",
          "    assert_eq!(x2, Value::Number(Number::from(-3.5)));",
          "    let n3 = Number::from(100);",
          "    let x3: Value = Value::from(n3);",
          "    assert_eq!(x3, Value::Number(Number::from(100)));",
          "    let n4 = Number::from(0);",
          "    let x4: Value = Value::from(n4);",
          "    assert_eq!(x4, Value::Number(Number::from(0)));",
          "    let n5 = Number::from(1.234);",
          "    let x5: Value = Value::from(n5);",
          "    assert_eq!(x5, Value::Number(Number::from(1.234)));",
          "    let n6 = Number::from(-1);",
          "    let x6: Value = Value::from(n6);",
          "    assert_eq!(x6, Value::Number(Number::from(-1)));",
          "    let n7 = Number::from(f64::INFINITY);",
          "    let x7: Value = Value::from(n7);",
          "    assert_eq!(x7, Value::Number(Number::from(f64::INFINITY)));",
          "    let n8 = Number::from(f64::NAN);",
          "    let x8: Value = Value::from(n8);",
          "    assert!(matches!(x8, Value::Number(Number::from(f64::NAN))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(1_000_000.123456);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(n));",
          "    assert!(matches!(x, Value::Number(_)));"
        ],
        "code": [
          "{",
          "    let n = Number::from(1_000_000.123456);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(n));",
          "    assert!(matches!(x, Value::Number(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n = Number::from(-1_000_000.123456);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Number(Number::from(-1_000_000.123456)));"
        ],
        "code": [
          "{",
          "    let n = Number::from(-1_000_000.123456);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(x, Value::Number(Number::from(-1_000_000.123456)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let n = Number::from(f64::NAN);",
          "    let x: Value = Value::from(n);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Value::from(Number::from(7.0)), Value::Number(Number::from(7.0)));",
          "    assert_eq!(Value::from(Number::from(0.0)), Value::Number(Number::from(0.0)));",
          "    assert_eq!(Value::from(Number::from(-5.5)), Value::Number(Number::from(-5.5)));",
          "    #[should_panic] assert_eq!(Value::from(Number::from(f64::NAN)), Value::Number(Number::from(f64::NAN)));",
          "    assert_eq!(Value::from(Number::from(1E10)), Value::Number(Number::from(1E10)));",
          "    assert_eq!(Value::from(Number::from(3.14)), Value::Number(Number::from(3.14)));",
          "    assert_eq!(Value::from(Number::from(-1E-10)), Value::Number(Number::from(-1E-10)));"
        ],
        "code": [
          "{",
          "    let n = Number::from(f64::NAN);",
          "    let x: Value = Value::from(n);",
          "    assert_eq!(Value::from(Number::from(7.0)), Value::Number(Number::from(7.0)));",
          "    assert_eq!(Value::from(Number::from(0.0)), Value::Number(Number::from(0.0)));",
          "    assert_eq!(Value::from(Number::from(-5.5)), Value::Number(Number::from(-5.5)));",
          "    #[should_panic] assert_eq!(Value::from(Number::from(f64::NAN)), Value::Number(Number::from(f64::NAN)));",
          "    assert_eq!(Value::from(Number::from(1E10)), Value::Number(Number::from(1E10)));",
          "    assert_eq!(Value::from(Number::from(3.14)), Value::Number(Number::from(3.14)));",
          "    assert_eq!(Value::from(Number::from(-1E-10)), Value::Number(Number::from(-1E-10)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]