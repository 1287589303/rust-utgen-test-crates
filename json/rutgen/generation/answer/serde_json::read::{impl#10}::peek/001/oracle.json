[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = &[];",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "}"
        ],
        "oracle": [
          "    str_read.peek().unwrap_err();",
          "    str_read.delegate.index == 0;",
          "    slice.is_empty();",
          "    str_read.peek().is_ok();",
          "    str_read.peek().unwrap() == None;"
        ],
        "code": [
          "{",
          "    let slice = &[];",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "    str_read.peek().unwrap_err();",
          "    str_read.delegate.index == 0;",
          "    slice.is_empty();",
          "    str_read.peek().is_ok();",
          "    str_read.peek().unwrap() == None;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = &[42]; // valid byte value",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(str_read.peek().unwrap(), Some(42));",
          "    assert_eq!(str_read.delegate.index, 0);",
          "    assert!(str_read.peek().is_ok());",
          "    assert!(str_read.peek().unwrap().is_some());",
          "    let result = str_read.peek();",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Some(42));",
          "    assert_eq!(str_read.delegate.slice, &[42]);",
          "    assert_eq!(str_read.delegate.index, 0);"
        ],
        "code": [
          "{",
          "    let slice = &[42]; // valid byte value",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "    assert_eq!(str_read.peek().unwrap(), Some(42));",
          "    assert_eq!(str_read.delegate.index, 0);",
          "    assert!(str_read.peek().is_ok());",
          "    assert!(str_read.peek().unwrap().is_some());",
          "    let result = str_read.peek();",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap(), Some(42));",
          "    assert_eq!(str_read.delegate.slice, &[42]);",
          "    assert_eq!(str_read.delegate.index, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = &[1, 2, 3, 4, 5]; // valid byte values",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(str_read.peek().is_ok(), true);",
          "    assert_eq!(str_read.peek().unwrap(), Some(1));",
          "    str_read.delegate.index = 1; // Move to next byte",
          "    assert_eq!(str_read.peek().unwrap(), Some(2));",
          "    str_read.delegate.index = slice.len(); // Move index beyond slice length",
          "    assert_eq!(str_read.peek().is_ok(), true);",
          "    assert_eq!(str_read.peek().unwrap(), None);",
          "    str_read.delegate.index = 0; // Reset index to check again",
          "    assert_eq!(str_read.delegate.peek().is_ok(), true);"
        ],
        "code": [
          "{",
          "    let slice = &[1, 2, 3, 4, 5]; // valid byte values",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "    assert_eq!(str_read.peek().is_ok(), true);",
          "    assert_eq!(str_read.peek().unwrap(), Some(1));",
          "    str_read.delegate.index = 1; // Move to next byte",
          "    assert_eq!(str_read.peek().unwrap(), Some(2));",
          "    str_read.delegate.index = slice.len(); // Move index beyond slice length",
          "    assert_eq!(str_read.peek().is_ok(), true);",
          "    assert_eq!(str_read.peek().unwrap(), None);",
          "    str_read.delegate.index = 0; // Reset index to check again",
          "    assert_eq!(str_read.delegate.peek().is_ok(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = &[10, 20, 30]; // valid byte values",
          "    let mut delegate = SliceRead { slice, index: 3 }; // out-of-bounds index",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "}"
        ],
        "oracle": [
          "    let slice = &[10, 20, 30]; // valid byte values",
          "    let delegate = SliceRead { slice, index: 3 }; // out-of-bounds index",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Err(Error::new(ErrorCode::OutOfBounds)));",
          "    ",
          "    let slice = &[0, 1, 2]; // valid byte values",
          "    let delegate = SliceRead { slice, index: 2 }; // valid index (last element)",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(Some(2)));",
          "    ",
          "    let slice = &[100, 200, 255]; // valid byte values",
          "    let delegate = SliceRead { slice, index: 0 }; // valid index (first element)",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(Some(100)));",
          "    ",
          "    let slice = &[]; // empty slice",
          "    let delegate = SliceRead { slice, index: 0 }; // index in empty slice",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(None));",
          "    ",
          "    let slice = &[7, 14, 21]; // valid byte values",
          "    let mut delegate = SliceRead { slice, index: 1 }; // valid index",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(Some(14)));"
        ],
        "code": [
          "{",
          "    let slice = &[10, 20, 30]; // valid byte values",
          "    let mut delegate = SliceRead { slice, index: 3 }; // out-of-bounds index",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "    let slice = &[10, 20, 30]; // valid byte values",
          "    let delegate = SliceRead { slice, index: 3 }; // out-of-bounds index",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Err(Error::new(ErrorCode::OutOfBounds)));",
          "    ",
          "    let slice = &[0, 1, 2]; // valid byte values",
          "    let delegate = SliceRead { slice, index: 2 }; // valid index (last element)",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(Some(2)));",
          "    ",
          "    let slice = &[100, 200, 255]; // valid byte values",
          "    let delegate = SliceRead { slice, index: 0 }; // valid index (first element)",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(Some(100)));",
          "    ",
          "    let slice = &[]; // empty slice",
          "    let delegate = SliceRead { slice, index: 0 }; // index in empty slice",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(None));",
          "    ",
          "    let slice = &[7, 14, 21]; // valid byte values",
          "    let mut delegate = SliceRead { slice, index: 1 }; // valid index",
          "    let str_read = StrRead { delegate };",
          "    assert_eq!(str_read.peek(), Ok(Some(14)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = &[0, 255]; // valid boundary values",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "}"
        ],
        "oracle": [
          "    assert!(str_read.peek().is_ok());",
          "    assert_eq!(str_read.peek().unwrap(), Some(0));",
          "    assert_eq!(str_read.delegate.index, 0);",
          "    delegate.index += 1;",
          "    assert_eq!(str_read.peek().unwrap(), Some(255));",
          "    assert_eq!(str_read.delegate.index, 1);",
          "    assert!(str_read.peek().unwrap().is_some());",
          "    assert_eq!(str_read.peek().unwrap(), None);",
          "    delegate.index = 2;",
          "    assert!(str_read.peek().is_err());"
        ],
        "code": [
          "{",
          "    let slice = &[0, 255]; // valid boundary values",
          "    let mut delegate = SliceRead { slice, index: 0 };",
          "    let mut str_read = StrRead { delegate };",
          "",
          "    let _ = str_read.peek();",
          "    assert!(str_read.peek().is_ok());",
          "    assert_eq!(str_read.peek().unwrap(), Some(0));",
          "    assert_eq!(str_read.delegate.index, 0);",
          "    delegate.index += 1;",
          "    assert_eq!(str_read.peek().unwrap(), Some(255));",
          "    assert_eq!(str_read.delegate.index, 1);",
          "    assert!(str_read.peek().unwrap().is_some());",
          "    assert_eq!(str_read.peek().unwrap(), None);",
          "    delegate.index = 2;",
          "    assert!(str_read.peek().is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]