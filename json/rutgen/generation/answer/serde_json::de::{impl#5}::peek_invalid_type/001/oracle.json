[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "    ",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'n', b'u', b'l', b'l'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "}"
        ],
        "oracle": [
          "    let mut read = MockRead {",
          "    data: vec![b'n', b'u', b'l', b'l'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"unit\")), de::Error::invalid_type(Unexpected::Unit, _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b't', b'r', b'u', b'e'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"boolean\")), de::Error::invalid_type(Unexpected::Bool(true), _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'f', b'a', b'l', b's', b'e'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"boolean\")), de::Error::invalid_type(Unexpected::Bool(false), _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'-', b'1'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"number\")), _));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'1', b'0'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"number\")), _));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'\"', b'h', b'e', b'l', b'l', b'o', b'\"'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"string\")), de::Error::invalid_type(Unexpected::Str(\"hello\"), _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'[', b'1'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"sequence\")), de::Error::invalid_type(Unexpected::Seq, _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'{', b'\"', b'k', b'e', b'y', b'\"'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"map\")), de::Error::invalid_type(Unexpected::Map, _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'1', b'0'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.peek_or_null = || Ok(Some(b'1'));",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"number\")), _));"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "    ",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'n', b'u', b'l', b'l'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    let mut read = MockRead {",
          "    data: vec![b'n', b'u', b'l', b'l'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"unit\")), de::Error::invalid_type(Unexpected::Unit, _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b't', b'r', b'u', b'e'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"boolean\")), de::Error::invalid_type(Unexpected::Bool(true), _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'f', b'a', b'l', b's', b'e'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"boolean\")), de::Error::invalid_type(Unexpected::Bool(false), _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'-', b'1'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"number\")), _));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'1', b'0'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"number\")), _));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'\"', b'h', b'e', b'l', b'l', b'o', b'\"'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"string\")), de::Error::invalid_type(Unexpected::Str(\"hello\"), _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'[', b'1'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"sequence\")), de::Error::invalid_type(Unexpected::Seq, _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'{', b'\"', b'k', b'e', b'y', b'\"'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"map\")), de::Error::invalid_type(Unexpected::Map, _)));",
          "    ",
          "    let mut read = MockRead {",
          "    data: vec![b'1', b'0'],",
          "    pos: 0,",
          "    };",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.peek_or_null = || Ok(Some(b'1'));",
          "    assert!(matches!(deserializer.peek_invalid_type(&Expected::new(\"number\")), _));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b't', b'r', b'u', b'e'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "}"
        ],
        "oracle": [
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'n', b'u', b'l', b'l'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Unit, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'f', b'a', b'l', b's', b'e'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Bool(false), _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'['], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Seq, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'-', b'1'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(matches!(result, Error::invalid_type(_, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'\"', b't', b'e', b's', b't'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Str(_), _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b't', b'r', b'u', b'e'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'{'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Map, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'1'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(matches!(result, Error::invalid_type(_, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'2'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(matches!(result, Error::invalid_type(_, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'0'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.peek_invalid_type(&Expected::new(\"number\"));"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b't', b'r', b'u', b'e'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'n', b'u', b'l', b'l'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Unit, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'f', b'a', b'l', b's', b'e'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Bool(false), _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'['], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Seq, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'-', b'1'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(matches!(result, Error::invalid_type(_, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'\"', b't', b'e', b's', b't'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Str(_), _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b't', b'r', b'u', b'e'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'{'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(matches!(result, Error::invalid_type(Unexpected::Map, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'1'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(matches!(result, Error::invalid_type(_, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'2'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(matches!(result, Error::invalid_type(_, _)));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'0'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'f', b'a', b'l', b's', b'e'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "}"
        ],
        "oracle": [
          "    let mut read = MockRead { data: vec![b'n', b'u', b'l', b'l'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'f', b'a', b'l', b's', b'e'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(result.is_ok());",
          "    ",
          "    let mut read = MockRead { data: vec![b'[', b'1', b',', b'2'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'-', b'1'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'\"', b'test'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b't', b'r', b'u', b'e'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(result.is_ok());",
          "    ",
          "    let mut read = MockRead { data: vec![b'{', b'\"', b'k', b'e', b'y', b'\"', b':', b'1'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'0'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_ok());",
          "    ",
          "    let mut read = MockRead { data: vec![b'9', b'9'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'f', b'a', b'l', b's', b'e'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    let mut read = MockRead { data: vec![b'n', b'u', b'l', b'l'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'f', b'a', b'l', b's', b'e'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(result.is_ok());",
          "    ",
          "    let mut read = MockRead { data: vec![b'[', b'1', b',', b'2'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'-', b'1'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'\"', b'test'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b't', b'r', b'u', b'e'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(result.is_ok());",
          "    ",
          "    let mut read = MockRead { data: vec![b'{', b'\"', b'k', b'e', b'y', b'\"', b':', b'1'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'0'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_ok());",
          "    ",
          "    let mut read = MockRead { data: vec![b'9', b'9'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'['],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "}"
        ],
        "oracle": [
          "    let mut read = MockRead { data: vec![b'n'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"unit\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b't'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"bool\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'f'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"bool\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'-'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"number\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'\"'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"string\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'['], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'{'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"map\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'0'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"number\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'9'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"number\")); assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'['],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    let mut read = MockRead { data: vec![b'n'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"unit\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b't'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"bool\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'f'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"bool\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'-'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"number\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'\"'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"string\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'['], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'{'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"map\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'0'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"number\")); assert!(result.is_err());",
          "    ",
          "    let mut read = MockRead { data: vec![b'9'], pos: 0 }; let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 }; let result = deserializer.peek_invalid_type(&Expected::new(\"number\")); assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'-', b'1'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "}"
        ],
        "oracle": [
          "    let mock_read = MockRead { data: vec![b'n', b'u', b'll'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"unit\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b't', b'r', b'ue'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'f', b'a', b'lse'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'['], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"seq\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'{'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"map\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'\"', b'test'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"string\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'-', b'1'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'0'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'1', b'0'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'8'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'9'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'1', b'2', b'3'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'-', b'1'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    let mock_read = MockRead { data: vec![b'n', b'u', b'll'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"unit\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b't', b'r', b'ue'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'f', b'a', b'lse'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'['], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"seq\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'{'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"map\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'\"', b'test'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"string\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'-', b'1'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'0'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'1', b'0'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'8'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'9'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mock_read = MockRead { data: vec![b'1', b'2', b'3'], pos: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'\"', b'h', b'e', b'l', b'l', b'o'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "}"
        ],
        "oracle": [
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.read = MockRead { data: vec![b'n'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'f'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"bool\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'['], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'-'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'\"', b'h', b'e', b'l', b'l', b'o'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b't'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"bool\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'{'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'0'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'9'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'\"', b'h', b'e', b'l', b'l', b'o'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    deserializer.read = MockRead { data: vec![b'n'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'f'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"bool\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'['], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'-'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'\"', b'h', b'e', b'l', b'l', b'o'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b't'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"bool\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'{'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'0'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());",
          "    ",
          "    deserializer.read = MockRead { data: vec![b'9'], pos: 0 };",
          "    let result = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'{'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "}"
        ],
        "oracle": [
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'n'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"unit\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b't'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'f'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'-'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'0'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'\"'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"string\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'['], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert_eq!(deserializer.peek_invalid_type(&Expected::new(\"sequence\")), de::Error::invalid_type(Unexpected::Seq, &Expected::new(\"sequence\")));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'{'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert_eq!(deserializer.peek_invalid_type(&Expected::new(\"map\")), de::Error::invalid_type(Unexpected::Map, &Expected::new(\"map\")));"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'{'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "",
          "    deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'n'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"unit\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b't'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'f'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"bool\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'-'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'0'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"number\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'\"'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert!(deserializer.peek_invalid_type(&Expected::new(\"string\")).is_err());",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'['], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert_eq!(deserializer.peek_invalid_type(&Expected::new(\"sequence\")), de::Error::invalid_type(Unexpected::Seq, &Expected::new(\"sequence\")));",
          "    ",
          "    let mut deserializer = Deserializer { read: MockRead { data: vec![b'{'], pos: 0 }, scratch: vec![], remaining_depth: 0 };",
          "    assert_eq!(deserializer.peek_invalid_type(&Expected::new(\"map\")), de::Error::invalid_type(Unexpected::Map, &Expected::new(\"map\")));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'1', b'2', b'3'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "}"
        ],
        "oracle": [
          "    let mut read = MockRead { data: vec![b'n', b'u', b'll'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(err.is_some(), \"Expected error for 'null'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b't', b'r', b'ue'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(err.is_some(), \"Expected error for 'true'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'f', b'a', b'l', b's', b'e'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(err.is_some(), \"Expected error for 'false'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'-', b'1', b'2'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(err.is_some(), \"Expected error for negative number\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'\"', b'abc', b'\"'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(err.is_some(), \"Expected error for string\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'[', b'1', b',', b'2'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(err.is_some(), \"Expected error for '['\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'{', b'\"', b'a', b'\"', b':', b'1'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(err.is_some(), \"Expected error for '{'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'1', b'2', b'3'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(err.is_some(), \"Expected error for digit\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'0', b'1', b'2'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(err.is_some(), \"Expected error for digit\");"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        data: Vec<u8>,",
          "        pos: usize,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        const should_early_return_if_failed: bool = false;",
          "",
          "        fn next(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                self.pos += 1;",
          "                Ok(Some(self.data[self.pos - 1]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            if self.pos < self.data.len() {",
          "                Ok(Some(self.data[self.pos]))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {",
          "            self.next().ok();",
          "        }",
          "",
          "        fn position(&self) -> Position { unimplemented!() }",
          "        fn peek_position(&self) -> Position { unimplemented!() }",
          "        fn byte_offset(&self) -> usize { self.pos }",
          "        fn parse_str<'s>(&mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> { unimplemented!() }",
          "    }",
          "",
          "    let mut read = MockRead {",
          "        data: vec![b'1', b'2', b'3'],",
          "        pos: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer { read, scratch: vec![], remaining_depth: 0 };",
          "    ",
          "    deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    let mut read = MockRead { data: vec![b'n', b'u', b'll'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"unit\"));",
          "    assert!(err.is_some(), \"Expected error for 'null'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b't', b'r', b'ue'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(err.is_some(), \"Expected error for 'true'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'f', b'a', b'l', b's', b'e'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"boolean\"));",
          "    assert!(err.is_some(), \"Expected error for 'false'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'-', b'1', b'2'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(err.is_some(), \"Expected error for negative number\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'\"', b'abc', b'\"'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"string\"));",
          "    assert!(err.is_some(), \"Expected error for string\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'[', b'1', b',', b'2'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"sequence\"));",
          "    assert!(err.is_some(), \"Expected error for '['\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'{', b'\"', b'a', b'\"', b':', b'1'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"map\"));",
          "    assert!(err.is_some(), \"Expected error for '{'\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'1', b'2', b'3'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(err.is_some(), \"Expected error for digit\");",
          "    ",
          "    let mut read = MockRead { data: vec![b'0', b'1', b'2'], pos: 0 };",
          "    let err = deserializer.peek_invalid_type(&Expected::new(\"number\"));",
          "    assert!(err.is_some(), \"Expected error for digit\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]