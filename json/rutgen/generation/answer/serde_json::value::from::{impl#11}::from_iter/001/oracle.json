[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let v: Vec<i32> = vec![];",
          "    let x: Value = v.into_iter().collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Array(Vec::new()));",
          "    let v_single: Vec<i32> = vec![1];",
          "    let x_single: Value = v_single.into_iter().collect();",
          "    assert_eq!(x_single, Value::Array(vec![Value::Number(Number { n: 1.into() }]));",
          "    let v_multiple: Vec<i32> = vec![1, 2, 3];",
          "    let x_multiple: Value = v_multiple.into_iter().collect();",
          "    assert_eq!(x_multiple, Value::Array(vec![Value::Number(Number { n: 1.into() }), Value::Number(Number { n: 2.into() }), Value::Number(Number { n: 3.into() })]));",
          "    let v_strings: Vec<&str> = vec![\"a\", \"b\", \"c\"];",
          "    let x_strings: Value = v_strings.into_iter().collect();",
          "    assert_eq!(x_strings, Value::Array(vec![Value::String(\"a\".to_owned()), Value::String(\"b\".to_owned()), Value::String(\"c\".to_owned())]));",
          "    let v_mixed: Vec<Box<dyn ToNumber + Send>> = vec![Box::new(1.5), Box::new(2)];",
          "    let x_mixed: Value = v_mixed.into_iter().collect();",
          "    assert_eq!(x_mixed, Value::Array(vec![Value::Number(Number { n: 1.5.into() }), Value::Number(Number { n: 2.into() })]));"
        ],
        "code": [
          "{",
          "    let v: Vec<i32> = vec![];",
          "    let x: Value = v.into_iter().collect();",
          "    assert_eq!(x, Value::Array(Vec::new()));",
          "    let v_single: Vec<i32> = vec![1];",
          "    let x_single: Value = v_single.into_iter().collect();",
          "    assert_eq!(x_single, Value::Array(vec![Value::Number(Number { n: 1.into() }]));",
          "    let v_multiple: Vec<i32> = vec![1, 2, 3];",
          "    let x_multiple: Value = v_multiple.into_iter().collect();",
          "    assert_eq!(x_multiple, Value::Array(vec![Value::Number(Number { n: 1.into() }), Value::Number(Number { n: 2.into() }), Value::Number(Number { n: 3.into() })]));",
          "    let v_strings: Vec<&str> = vec![\"a\", \"b\", \"c\"];",
          "    let x_strings: Value = v_strings.into_iter().collect();",
          "    assert_eq!(x_strings, Value::Array(vec![Value::String(\"a\".to_owned()), Value::String(\"b\".to_owned()), Value::String(\"c\".to_owned())]));",
          "    let v_mixed: Vec<Box<dyn ToNumber + Send>> = vec![Box::new(1.5), Box::new(2)];",
          "    let x_mixed: Value = v_mixed.into_iter().collect();",
          "    assert_eq!(x_mixed, Value::Array(vec![Value::Number(Number { n: 1.5.into() }), Value::Number(Number { n: 2.into() })]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let v: Vec<i32> = vec![1, 2, 3, 4, 5];",
          "    let x: Value = v.into_iter().collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Array(vec![Value::Number(Number { n: 1 }), Value::Number(Number { n: 2 }), Value::Number(Number { n: 3 }), Value::Number(Number { n: 4 }), Value::Number(Number { n: 5 })]));"
        ],
        "code": [
          "{",
          "    let v: Vec<i32> = vec![1, 2, 3, 4, 5];",
          "    let x: Value = v.into_iter().collect();",
          "    assert_eq!(x, Value::Array(vec![Value::Number(Number { n: 1 }), Value::Number(Number { n: 2 }), Value::Number(Number { n: 3 }), Value::Number(Number { n: 4 }), Value::Number(Number { n: 5 })]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let v: Vec<bool> = vec![true, false, true];",
          "    let x: Value = v.into_iter().collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(x, Value::Array(vec![Value::Bool(true), Value::Bool(false), Value::Bool(true)]));"
        ],
        "code": [
          "{",
          "    let v: Vec<bool> = vec![true, false, true];",
          "    let x: Value = v.into_iter().collect();",
          "    assert_eq!(x, Value::Array(vec![Value::Bool(true), Value::Bool(false), Value::Bool(true)]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let v: Vec<&str> = vec![\"a\", \"b\", \"c\"];",
          "    let x: Value = v.into_iter().collect();",
          "}"
        ],
        "oracle": [
          "    let v: Vec<&str> = vec![\"a\", \"b\", \"c\"];",
          "    let x: Value = v.into_iter().collect();",
          "    assert_eq!(x, Value::Array(vec![Value::String(\"a\".to_owned()), Value::String(\"b\".to_owned()), Value::String(\"c\".to_owned())]));"
        ],
        "code": [
          "{",
          "    let v: Vec<&str> = vec![\"a\", \"b\", \"c\"];",
          "    let x: Value = v.into_iter().collect();",
          "    let v: Vec<&str> = vec![\"a\", \"b\", \"c\"];",
          "    let x: Value = v.into_iter().collect();",
          "    assert_eq!(x, Value::Array(vec![Value::String(\"a\".to_owned()), Value::String(\"b\".to_owned()), Value::String(\"c\".to_owned())]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let v: Vec<Box<dyn std::fmt::Display>> = vec![\"text\".to_owned().into_boxed_str(), 42.into()];",
          "    let x: Value = v.into_iter().map(|v| v.to_string()).collect();",
          "}"
        ],
        "oracle": [
          "    let v: Vec<Box<dyn std::fmt::Display>> = vec![\"text\".to_owned().into_boxed_str(), 42.into()];",
          "    let x: Value = v.into_iter().map(|v| v.to_string()).collect();",
          "    assert_eq!(x, Value::Array(vec![Value::String(\"text\".to_owned()), Value::String(\"42\".to_owned())]));",
          "    ",
          "    let v_empty: Vec<Box<dyn std::fmt::Display>> = vec![];",
          "    let x_empty: Value = v_empty.into_iter().map(|v| v.to_string()).collect();",
          "    assert_eq!(x_empty, Value::Array(vec![]));",
          "    ",
          "    let v_mixed: Vec<Box<dyn std::fmt::Display>> = vec![\"string\".to_owned().into_boxed_str(), 3.14.into()];",
          "    let x_mixed: Value = v_mixed.into_iter().map(|v| v.to_string()).collect();",
          "    assert_eq!(x_mixed, Value::Array(vec![Value::String(\"string\".to_owned()), Value::String(\"3.14\".to_owned())]));"
        ],
        "code": [
          "{",
          "    let v: Vec<Box<dyn std::fmt::Display>> = vec![\"text\".to_owned().into_boxed_str(), 42.into()];",
          "    let x: Value = v.into_iter().map(|v| v.to_string()).collect();",
          "    let v: Vec<Box<dyn std::fmt::Display>> = vec![\"text\".to_owned().into_boxed_str(), 42.into()];",
          "    let x: Value = v.into_iter().map(|v| v.to_string()).collect();",
          "    assert_eq!(x, Value::Array(vec![Value::String(\"text\".to_owned()), Value::String(\"42\".to_owned())]));",
          "    ",
          "    let v_empty: Vec<Box<dyn std::fmt::Display>> = vec![];",
          "    let x_empty: Value = v_empty.into_iter().map(|v| v.to_string()).collect();",
          "    assert_eq!(x_empty, Value::Array(vec![]));",
          "    ",
          "    let v_mixed: Vec<Box<dyn std::fmt::Display>> = vec![\"string\".to_owned().into_boxed_str(), 3.14.into()];",
          "    let x_mixed: Value = v_mixed.into_iter().map(|v| v.to_string()).collect();",
          "    assert_eq!(x_mixed, Value::Array(vec![Value::String(\"string\".to_owned()), Value::String(\"3.14\".to_owned())]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]