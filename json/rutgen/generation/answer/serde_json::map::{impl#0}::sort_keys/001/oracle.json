[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Map::with_capacity(10);",
          "    map.insert(\"b\".to_string(), Value::String(\"value_b\".to_string()));",
          "    map.insert(\"a\".to_string(), Value::String(\"value_a\".to_string()));",
          "    map.insert(\"c\".to_string(), Value::String(\"value_c\".to_string()));",
          "    map.sort_keys();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.keys().collect::<Vec<_>>(), vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()]);",
          "    assert_eq!(map.get(\"a\"), Some(&Value::String(\"value_a\".to_string())));",
          "    assert_eq!(map.get(\"b\"), Some(&Value::String(\"value_b\".to_string())));",
          "    assert_eq!(map.get(\"c\"), Some(&Value::String(\"value_c\".to_string())));"
        ],
        "code": [
          "{",
          "    let mut map = Map::with_capacity(10);",
          "    map.insert(\"b\".to_string(), Value::String(\"value_b\".to_string()));",
          "    map.insert(\"a\".to_string(), Value::String(\"value_a\".to_string()));",
          "    map.insert(\"c\".to_string(), Value::String(\"value_c\".to_string()));",
          "    map.sort_keys();",
          "    assert_eq!(map.keys().collect::<Vec<_>>(), vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()]);",
          "    assert_eq!(map.get(\"a\"), Some(&Value::String(\"value_a\".to_string())));",
          "    assert_eq!(map.get(\"b\"), Some(&Value::String(\"value_b\".to_string())));",
          "    assert_eq!(map.get(\"c\"), Some(&Value::String(\"value_c\".to_string())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Map::with_capacity(10);",
          "    map.insert(\"b\".to_string(), Value::String(\"value_b\".to_string()));",
          "    map.insert(\"a\".to_string(), Value::String(\"value_a\".to_string()));",
          "    map.insert(\"c\".to_string(), Value::String(\"value_c\".to_string()));",
          "    map.sort_keys(); // Should effectively do nothing",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.get(&\"a\".to_string()), Some(&Value::String(\"value_a\".to_string())));",
          "    assert_eq!(map.get(&\"b\".to_string()), Some(&Value::String(\"value_b\".to_string())));",
          "    assert_eq!(map.get(&\"c\".to_string()), Some(&Value::String(\"value_c\".to_string())));",
          "    assert_eq!(map.len(), 3);",
          "    assert!(!map.is_empty());",
          "    assert_eq!(map.keys().collect::<Vec<_>>(), vec![\"b\".to_string(), \"a\".to_string(), \"c\".to_string()]);"
        ],
        "code": [
          "{",
          "    let mut map = Map::with_capacity(10);",
          "    map.insert(\"b\".to_string(), Value::String(\"value_b\".to_string()));",
          "    map.insert(\"a\".to_string(), Value::String(\"value_a\".to_string()));",
          "    map.insert(\"c\".to_string(), Value::String(\"value_c\".to_string()));",
          "    map.sort_keys(); // Should effectively do nothing",
          "    assert_eq!(map.get(&\"a\".to_string()), Some(&Value::String(\"value_a\".to_string())));",
          "    assert_eq!(map.get(&\"b\".to_string()), Some(&Value::String(\"value_b\".to_string())));",
          "    assert_eq!(map.get(&\"c\".to_string()), Some(&Value::String(\"value_c\".to_string())));",
          "    assert_eq!(map.len(), 3);",
          "    assert!(!map.is_empty());",
          "    assert_eq!(map.keys().collect::<Vec<_>>(), vec![\"b\".to_string(), \"a\".to_string(), \"c\".to_string()]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Map::new();",
          "    map.sort_keys();",
          "}"
        ],
        "oracle": [
          "    assert!(map.is_empty());",
          "    let mut map = Map::with_capacity(10);",
          "    map.insert(\"b\".to_string(), Value::String(\"value1\".to_string()));",
          "    map.insert(\"a\".to_string(), Value::String(\"value2\".to_string()));",
          "    map.sort_keys();",
          "    let keys: Vec<String> = map.keys().cloned().collect();",
          "    assert_eq!(keys, vec![\"a\", \"b\"]);",
          "    #[cfg(feature = \"preserve_order\")]",
          "    let ordered_map = Map::new();",
          "    assert!(ordered_map.is_empty());",
          "    assert_eq!(map.len(), 2);",
          "    map.clear();",
          "    assert!(map.is_empty());",
          "    map.insert(\"c\".to_string(), Value::String(\"value3\".to_string()));",
          "    map.sort_keys();",
          "    assert_eq!(map.len(), 1);",
          "    assert_eq!(map.keys().next().unwrap(), &\"c\".to_string());"
        ],
        "code": [
          "{",
          "    let mut map = Map::new();",
          "    map.sort_keys();",
          "    assert!(map.is_empty());",
          "    let mut map = Map::with_capacity(10);",
          "    map.insert(\"b\".to_string(), Value::String(\"value1\".to_string()));",
          "    map.insert(\"a\".to_string(), Value::String(\"value2\".to_string()));",
          "    map.sort_keys();",
          "    let keys: Vec<String> = map.keys().cloned().collect();",
          "    assert_eq!(keys, vec![\"a\", \"b\"]);",
          "    #[cfg(feature = \"preserve_order\")]",
          "    let ordered_map = Map::new();",
          "    assert!(ordered_map.is_empty());",
          "    assert_eq!(map.len(), 2);",
          "    map.clear();",
          "    assert!(map.is_empty());",
          "    map.insert(\"c\".to_string(), Value::String(\"value3\".to_string()));",
          "    map.sort_keys();",
          "    assert_eq!(map.len(), 1);",
          "    assert_eq!(map.keys().next().unwrap(), &\"c\".to_string());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Map::new();",
          "    map.sort_keys(); // Should effectively do nothing",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.len(), 0);",
          "    assert!(map.is_empty());",
          "    map.sort_keys();",
          "    assert_eq!(map.len(), 0);",
          "    assert!(map.is_empty());"
        ],
        "code": [
          "{",
          "    let mut map = Map::new();",
          "    map.sort_keys(); // Should effectively do nothing",
          "    assert_eq!(map.len(), 0);",
          "    assert!(map.is_empty());",
          "    map.sort_keys();",
          "    assert_eq!(map.len(), 0);",
          "    assert!(map.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Map::with_capacity(1000);",
          "    for i in 0..1000 {",
          "        map.insert(format!(\"key_{}\", 1000 - i), Value::Number(Number::from(i)));",
          "    }",
          "    map.sort_keys(); // Sorting should occur",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.iter().next().map(|(k, _)| k), Some(&\"key_0\".to_string())); // Verify first key after sorting",
          "    assert_eq!(map.iter().last().map(|(k, _)| k), Some(&\"key_999\".to_string())); // Verify last key after sorting",
          "    assert!(map.keys().zip(0..1000).all(|(k, i)| k == &format!(\"key_{}\", i))); // Check if keys are in correct sorted order",
          "    assert!(map.values().zip(0..1000).all(|(v, i)| *v == Value::Number(Number::from(i)))); // Verify values remain unchanged after sorting",
          "    assert_eq!(map.len(), 1000); // Verify length remains unchanged after sorting",
          "    assert!(!map.is_empty()); // Verify the map is not empty after sorting"
        ],
        "code": [
          "{",
          "    let mut map = Map::with_capacity(1000);",
          "    for i in 0..1000 {",
          "        map.insert(format!(\"key_{}\", 1000 - i), Value::Number(Number::from(i)));",
          "    }",
          "    map.sort_keys(); // Sorting should occur",
          "    assert_eq!(map.iter().next().map(|(k, _)| k), Some(&\"key_0\".to_string())); // Verify first key after sorting",
          "    assert_eq!(map.iter().last().map(|(k, _)| k), Some(&\"key_999\".to_string())); // Verify last key after sorting",
          "    assert!(map.keys().zip(0..1000).all(|(k, i)| k == &format!(\"key_{}\", i))); // Check if keys are in correct sorted order",
          "    assert!(map.values().zip(0..1000).all(|(v, i)| *v == Value::Number(Number::from(i)))); // Verify values remain unchanged after sorting",
          "    assert_eq!(map.len(), 1000); // Verify length remains unchanged after sorting",
          "    assert!(!map.is_empty()); // Verify the map is not empty after sorting",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Map::with_capacity(1000);",
          "    for i in 0..1000 {",
          "        map.insert(format!(\"key_{}\", 1000 - i), Value::Number(Number::from(i)));",
          "    }",
          "    map.sort_keys(); // Should effectively do nothing",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.len(), 1000);",
          "    assert!(map.keys().zip(0..1000).all(|(key, value)| key == format!(\"key_{}\", value)));",
          "    assert!(map.values().zip(0..1000).all(|(value, index)| *value == Value::Number(Number::from(index))));",
          "    assert!(!map.values().any(|v| match v {",
          "    Value::Object(_) => true,",
          "    _ => false,",
          "    }));",
          "    assert!(map.keys().collect::<Vec<_>>() == (0..1000).rev().map(|i| format!(\"key_{}\", i)).collect::<Vec<_>>());"
        ],
        "code": [
          "{",
          "    let mut map = Map::with_capacity(1000);",
          "    for i in 0..1000 {",
          "        map.insert(format!(\"key_{}\", 1000 - i), Value::Number(Number::from(i)));",
          "    }",
          "    map.sort_keys(); // Should effectively do nothing",
          "    assert_eq!(map.len(), 1000);",
          "    assert!(map.keys().zip(0..1000).all(|(key, value)| key == format!(\"key_{}\", value)));",
          "    assert!(map.values().zip(0..1000).all(|(value, index)| *value == Value::Number(Number::from(index))));",
          "    assert!(!map.values().any(|v| match v {",
          "    Value::Object(_) => true,",
          "    _ => false,",
          "    }));",
          "    assert!(map.keys().collect::<Vec<_>>() == (0..1000).rev().map(|i| format!(\"key_{}\", i)).collect::<Vec<_>>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]