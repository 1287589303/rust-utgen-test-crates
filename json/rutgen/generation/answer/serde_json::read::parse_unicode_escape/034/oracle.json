[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        hex_escape_val: Result<u16, Error>,",
          "        peek_val: Result<u8, Error>,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        fn decode_hex_escape(&mut self) -> Result<u16> {",
          "            self.hex_escape_val.clone()",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            self.peek_val.clone().map(Some)",
          "        }",
          "",
          "        fn discard(&mut self) { /* no-op */ }",
          "    }",
          "",
          "    let mut scratch = Vec::new();",
          "    let mut read = MockRead {",
          "        hex_escape_val: Ok(0xD800), // n == 0xD800",
          "        peek_val: Err(Error::from(ErrorCode::EofWhileParsingString)), // EOF on peek",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_, Err(Error::from(ErrorCode::UnexpectedEndOfHexEscape)));",
          "    assert_eq!(scratch.len(), 0);",
          "    assert!(matches!(_, ErrorCode::EofWhileParsingString));",
          "    assert!(matches!(read.peek(), Err(Error::from(ErrorCode::EofWhileParsingString))));",
          "    assert!(matches!(read.decode_hex_escape(), Ok(0xD800)));",
          "    assert!(read.peek().is_err());",
          "    assert!(scratch.is_empty());",
          "    assert!(read.peek_val.is_err());",
          "    assert!(read.hex_escape_val.is_ok());"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        hex_escape_val: Result<u16, Error>,",
          "        peek_val: Result<u8, Error>,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        fn decode_hex_escape(&mut self) -> Result<u16> {",
          "            self.hex_escape_val.clone()",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            self.peek_val.clone().map(Some)",
          "        }",
          "",
          "        fn discard(&mut self) { /* no-op */ }",
          "    }",
          "",
          "    let mut scratch = Vec::new();",
          "    let mut read = MockRead {",
          "        hex_escape_val: Ok(0xD800), // n == 0xD800",
          "        peek_val: Err(Error::from(ErrorCode::EofWhileParsingString)), // EOF on peek",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "    assert_eq!(_, Err(Error::from(ErrorCode::UnexpectedEndOfHexEscape)));",
          "    assert_eq!(scratch.len(), 0);",
          "    assert!(matches!(_, ErrorCode::EofWhileParsingString));",
          "    assert!(matches!(read.peek(), Err(Error::from(ErrorCode::EofWhileParsingString))));",
          "    assert!(matches!(read.decode_hex_escape(), Ok(0xD800)));",
          "    assert!(read.peek().is_err());",
          "    assert!(scratch.is_empty());",
          "    assert!(read.peek_val.is_err());",
          "    assert!(read.hex_escape_val.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        hex_escape_val: Result<u16, Error>,",
          "        peek_val: Result<u8, Error>,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        fn decode_hex_escape(&mut self) -> Result<u16> {",
          "            self.hex_escape_val.clone()",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            self.peek_val.clone().map(Some)",
          "        }",
          "",
          "        fn discard(&mut self) { /* no-op */ }",
          "    }",
          "",
          "    let mut scratch = Vec::new();",
          "    let mut read = MockRead {",
          "        hex_escape_val: Ok(0xDBFF), // n == 0xDBFF",
          "        peek_val: Err(Error::from(ErrorCode::EofWhileParsingString)), // EOF on peek",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parse_unicode_escape(&mut read, false, &mut scratch), Err(Error::from(ErrorCode::UnexpectedEndOfHexEscape)));",
          "    assert!(scratch.is_empty());",
          "    assert!(matches!(read.peek_val, Err(Error::from(ErrorCode::EofWhileParsingString))));",
          "    assert!(matches!(read.hex_escape_val, Ok(0xDBFF)));",
          "    assert_eq!(parse_unicode_escape(&mut read, false, &mut scratch), Err(Error::from(ErrorCode::LoneLeadingSurrogateInHexEscape)));",
          "    assert_eq!(scratch.len(), 0);",
          "    assert!(matches!(read.peek_val, Err(Error::from(ErrorCode::EofWhileParsingString))));",
          "    assert_eq!(read.hex_escape_val, Ok(0xDBFF));"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        hex_escape_val: Result<u16, Error>,",
          "        peek_val: Result<u8, Error>,",
          "    }",
          "",
          "    impl<'de> Read<'de> for MockRead {",
          "        fn decode_hex_escape(&mut self) -> Result<u16> {",
          "            self.hex_escape_val.clone()",
          "        }",
          "",
          "        fn peek(&mut self) -> Result<Option<u8>> {",
          "            self.peek_val.clone().map(Some)",
          "        }",
          "",
          "        fn discard(&mut self) { /* no-op */ }",
          "    }",
          "",
          "    let mut scratch = Vec::new();",
          "    let mut read = MockRead {",
          "        hex_escape_val: Ok(0xDBFF), // n == 0xDBFF",
          "        peek_val: Err(Error::from(ErrorCode::EofWhileParsingString)), // EOF on peek",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "    assert_eq!(parse_unicode_escape(&mut read, false, &mut scratch), Err(Error::from(ErrorCode::UnexpectedEndOfHexEscape)));",
          "    assert!(scratch.is_empty());",
          "    assert!(matches!(read.peek_val, Err(Error::from(ErrorCode::EofWhileParsingString))));",
          "    assert!(matches!(read.hex_escape_val, Ok(0xDBFF)));",
          "    assert_eq!(parse_unicode_escape(&mut read, false, &mut scratch), Err(Error::from(ErrorCode::LoneLeadingSurrogateInHexEscape)));",
          "    assert_eq!(scratch.len(), 0);",
          "    assert!(matches!(read.peek_val, Err(Error::from(ErrorCode::EofWhileParsingString))));",
          "    assert_eq!(read.hex_escape_val, Ok(0xDBFF));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]