[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        hex_value: u16,",
          "        next_char: u8,",
          "    }",
          "    ",
          "    impl MockRead {",
          "        fn decode_hex_escape(&self) -> Result<u16> {",
          "            Ok(self.hex_value)",
          "        }",
          "",
          "        fn peek(&self) -> Result<Option<u8>> {",
          "            Ok(Some(self.next_char))",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "    }",
          "    ",
          "    let mut scratch = Vec::new();",
          "",
          "    let mut read = MockRead {",
          "        hex_value: 0xD800, // Leading surrogate",
          "        next_char: b'\\\\',   // Valid escape character",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "}"
        ],
        "oracle": [
          "    assert!(scratch.is_empty());",
          "    assert_eq!(read.next_char, b'\\\\');",
          "    assert!(matches!(parse_unicode_escape(&mut read, true, &mut scratch), Err(ErrorCode::UnexpectedEndOfHexEscape)));",
          "    ",
          "    read.hex_value = 0xDBFF; // Set to trailing surrogate",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "    assert!(scratch.is_empty());",
          "    assert_eq!(read.next_char, b'\\\\');",
          "    assert!(matches!(parse_unicode_escape(&mut read, true, &mut scratch), Err(ErrorCode::UnexpectedEndOfHexEscape)));"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        hex_value: u16,",
          "        next_char: u8,",
          "    }",
          "    ",
          "    impl MockRead {",
          "        fn decode_hex_escape(&self) -> Result<u16> {",
          "            Ok(self.hex_value)",
          "        }",
          "",
          "        fn peek(&self) -> Result<Option<u8>> {",
          "            Ok(Some(self.next_char))",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "    }",
          "    ",
          "    let mut scratch = Vec::new();",
          "",
          "    let mut read = MockRead {",
          "        hex_value: 0xD800, // Leading surrogate",
          "        next_char: b'\\\\',   // Valid escape character",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "    assert!(scratch.is_empty());",
          "    assert_eq!(read.next_char, b'\\\\');",
          "    assert!(matches!(parse_unicode_escape(&mut read, true, &mut scratch), Err(ErrorCode::UnexpectedEndOfHexEscape)));",
          "    ",
          "    read.hex_value = 0xDBFF; // Set to trailing surrogate",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "    assert!(scratch.is_empty());",
          "    assert_eq!(read.next_char, b'\\\\');",
          "    assert!(matches!(parse_unicode_escape(&mut read, true, &mut scratch), Err(ErrorCode::UnexpectedEndOfHexEscape)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockRead {",
          "        hex_value: u16,",
          "        next_char: u8,",
          "    }",
          "    ",
          "    impl MockRead {",
          "        fn decode_hex_escape(&self) -> Result<u16> {",
          "            Ok(self.hex_value)",
          "        }",
          "",
          "        fn peek(&self) -> Result<Option<u8>> {",
          "            Ok(Some(self.next_char))",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "    }",
          "    ",
          "    let mut scratch = Vec::new();",
          "",
          "    let mut read = MockRead {",
          "        hex_value: 0xDBFF, // Trailing surrogate",
          "        next_char: b'\\\\',   // Valid escape character",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "}"
        ],
        "oracle": [
          "    assert!(parse_unicode_escape(&mut read, false, &mut scratch).is_ok());",
          "    assert_eq!(scratch.len(), expected_length);",
          "    assert_eq!(scratch, expected_output);",
          "    assert!(matches!(read.decode_hex_escape(), Ok(0xDBFF)));",
          "    assert!(matches!(peek_or_eof(&mut read), Ok(b'\\\\')));",
          "    assert!(matches!(peek_or_eof(&mut read), Ok(b'u')));"
        ],
        "code": [
          "{",
          "    struct MockRead {",
          "        hex_value: u16,",
          "        next_char: u8,",
          "    }",
          "    ",
          "    impl MockRead {",
          "        fn decode_hex_escape(&self) -> Result<u16> {",
          "            Ok(self.hex_value)",
          "        }",
          "",
          "        fn peek(&self) -> Result<Option<u8>> {",
          "            Ok(Some(self.next_char))",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "    }",
          "    ",
          "    let mut scratch = Vec::new();",
          "",
          "    let mut read = MockRead {",
          "        hex_value: 0xDBFF, // Trailing surrogate",
          "        next_char: b'\\\\',   // Valid escape character",
          "    };",
          "",
          "    let _ = parse_unicode_escape(&mut read, false, &mut scratch);",
          "    assert!(parse_unicode_escape(&mut read, false, &mut scratch).is_ok());",
          "    assert_eq!(scratch.len(), expected_length);",
          "    assert_eq!(scratch, expected_output);",
          "    assert!(matches!(read.decode_hex_escape(), Ok(0xDBFF)));",
          "    assert!(matches!(peek_or_eof(&mut read), Ok(b'\\\\')));",
          "    assert!(matches!(peek_or_eof(&mut read), Ok(b'u')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]