[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[Value] = &[Value::Null];",
          "    let result = SeqRefDeserializer::new(slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter.len(), 1);",
          "    assert_eq!(result.iter.next(), Some(&Value::Null));",
          "    assert!(result.iter().clone().collect::<Vec<_>>() == vec![Value::Null]);",
          "    assert!(result.iter().next().is_some());",
          "    assert!(result.iter().next().unwrap() == &Value::Null);"
        ],
        "code": [
          "{",
          "    let slice: &[Value] = &[Value::Null];",
          "    let result = SeqRefDeserializer::new(slice);",
          "    assert_eq!(result.iter.len(), 1);",
          "    assert_eq!(result.iter.next(), Some(&Value::Null));",
          "    assert!(result.iter().clone().collect::<Vec<_>>() == vec![Value::Null]);",
          "    assert!(result.iter().next().is_some());",
          "    assert!(result.iter().next().unwrap() == &Value::Null);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[Value] = &[Value::Bool(true)];",
          "    let result = SeqRefDeserializer::new(slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter.len(), 1);",
          "    assert_eq!(result.iter.next(), Some(&Value::Bool(true)));",
          "    assert!(result.iter.as_slice() == slice);",
          "    assert_eq!(result.iter.as_slice(), &[Value::Bool(true)]);",
          "    assert!(result.iter.clone().collect::<Vec<_>>() == slice.to_vec());"
        ],
        "code": [
          "{",
          "    let slice: &[Value] = &[Value::Bool(true)];",
          "    let result = SeqRefDeserializer::new(slice);",
          "    assert_eq!(result.iter.len(), 1);",
          "    assert_eq!(result.iter.next(), Some(&Value::Bool(true)));",
          "    assert!(result.iter.as_slice() == slice);",
          "    assert_eq!(result.iter.as_slice(), &[Value::Bool(true)]);",
          "    assert!(result.iter.clone().collect::<Vec<_>>() == slice.to_vec());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[Value] = &[Value::Number(Number::from(42))];",
          "    let result = SeqRefDeserializer::new(slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter.len(), 1);",
          "    assert!(matches!(result.iter.clone().next(), Some(&Value::Number(Number::from(42)))));",
          "    assert_eq!(result.iter.clone().count(), slice.len());",
          "    assert!(result.iter.as_slice() == slice);"
        ],
        "code": [
          "{",
          "    let slice: &[Value] = &[Value::Number(Number::from(42))];",
          "    let result = SeqRefDeserializer::new(slice);",
          "    assert_eq!(result.iter.len(), 1);",
          "    assert!(matches!(result.iter.clone().next(), Some(&Value::Number(Number::from(42)))));",
          "    assert_eq!(result.iter.clone().count(), slice.len());",
          "    assert!(result.iter.as_slice() == slice);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[Value] = &[Value::String(String::from(\"test\"))];",
          "    let result = SeqRefDeserializer::new(slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter.len(), 1);",
          "    assert!(matches!(result.iter.next(), Some(&Value::String(ref s)) if s == \"test\"));",
          "    assert_eq!(result.iter.as_slice(), slice);"
        ],
        "code": [
          "{",
          "    let slice: &[Value] = &[Value::String(String::from(\"test\"))];",
          "    let result = SeqRefDeserializer::new(slice);",
          "    assert_eq!(result.iter.len(), 1);",
          "    assert!(matches!(result.iter.next(), Some(&Value::String(ref s)) if s == \"test\"));",
          "    assert_eq!(result.iter.as_slice(), slice);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[Value] = &[Value::Array(vec![Value::Bool(false)])];",
          "    let result = SeqRefDeserializer::new(slice);",
          "}"
        ],
        "oracle": [
          "    result.iter.len() == 1",
          "    result.iter.next() == Some(&Value::Array(vec![Value::Bool(false)]))"
        ],
        "code": [
          "{",
          "    let slice: &[Value] = &[Value::Array(vec![Value::Bool(false)])];",
          "    let result = SeqRefDeserializer::new(slice);",
          "    result.iter.len() == 1",
          "    result.iter.next() == Some(&Value::Array(vec![Value::Bool(false)]))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Map::new();",
          "    map.insert(String::from(\"key\"), Value::String(String::from(\"value\")));",
          "    let slice: &[Value] = &[Value::Object(map)];",
          "    let result = SeqRefDeserializer::new(slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter.len(), 1);",
          "    assert_eq!(result.iter[0], Value::Object(map));",
          "    assert!(result.iter as *const _ == slice.iter() as *const _);"
        ],
        "code": [
          "{",
          "    let mut map = Map::new();",
          "    map.insert(String::from(\"key\"), Value::String(String::from(\"value\")));",
          "    let slice: &[Value] = &[Value::Object(map)];",
          "    let result = SeqRefDeserializer::new(slice);",
          "    assert_eq!(result.iter.len(), 1);",
          "    assert_eq!(result.iter[0], Value::Object(map));",
          "    assert!(result.iter as *const _ == slice.iter() as *const _);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[Value] = &[",
          "        Value::Null,",
          "        Value::Bool(false),",
          "        Value::Number(Number::from(3.14)),",
          "        Value::String(String::from(\"another test\")),",
          "        Value::Array(vec![Value::Number(Number::from(1))]),",
          "        {",
          "            let mut map = Map::new();",
          "            map.insert(String::from(\"key\"), Value::String(String::from(\"value\")));",
          "            Value::Object(map)",
          "        }",
          "    ];",
          "    let result = SeqRefDeserializer::new(slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter.len(), 6);",
          "    assert!(matches!(result.iter.next(), Some(Value::Null)));",
          "    assert!(matches!(result.iter.next(), Some(Value::Bool(false))));",
          "    assert!(matches!(result.iter.next(), Some(Value::Number(Number::from(3.14)))));",
          "    assert!(matches!(result.iter.next(), Some(Value::String(ref s)) if s == \"another test\"));",
          "    assert!(matches!(result.iter.next(), Some(Value::Array(ref a)) if a.len() == 1 && matches!(a[0], Value::Number(Number::from(1)))));",
          "    assert!(matches!(result.iter.next(), Some(Value::Object(ref m)) if m.len() == 1 && m.contains_key(\"key\") && matches!(m.get(\"key\"), Some(Value::String(ref v)) if v == \"value\")));"
        ],
        "code": [
          "{",
          "    let slice: &[Value] = &[",
          "        Value::Null,",
          "        Value::Bool(false),",
          "        Value::Number(Number::from(3.14)),",
          "        Value::String(String::from(\"another test\")),",
          "        Value::Array(vec![Value::Number(Number::from(1))]),",
          "        {",
          "            let mut map = Map::new();",
          "            map.insert(String::from(\"key\"), Value::String(String::from(\"value\")));",
          "            Value::Object(map)",
          "        }",
          "    ];",
          "    let result = SeqRefDeserializer::new(slice);",
          "    assert_eq!(result.iter.len(), 6);",
          "    assert!(matches!(result.iter.next(), Some(Value::Null)));",
          "    assert!(matches!(result.iter.next(), Some(Value::Bool(false))));",
          "    assert!(matches!(result.iter.next(), Some(Value::Number(Number::from(3.14)))));",
          "    assert!(matches!(result.iter.next(), Some(Value::String(ref s)) if s == \"another test\"));",
          "    assert!(matches!(result.iter.next(), Some(Value::Array(ref a)) if a.len() == 1 && matches!(a[0], Value::Number(Number::from(1)))));",
          "    assert!(matches!(result.iter.next(), Some(Value::Object(ref m)) if m.len() == 1 && m.contains_key(\"key\") && matches!(m.get(\"key\"), Some(Value::String(ref v)) if v == \"value\")));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Vec<Value> = Vec::new();",
          "    for i in 0..100 {",
          "        slice.push(Value::Number(Number::from(i)));",
          "    }",
          "    let result = SeqRefDeserializer::new(&slice);",
          "}"
        ],
        "oracle": [
          "    let expected_iter = slice.iter();",
          "    assert_eq!(result.iter, expected_iter);",
          "    assert_eq!(slice.len(), 100);",
          "    assert!(!slice.is_empty());",
          "    assert!(matches!(result.iter.next(), Some(Value::Number(Number::from(0))));",
          "    assert!(matches!(result.iter.next(), Some(Value::Number(Number::from(99))));",
          "    assert!(result.iter.size_hint().0 == 100);",
          "    assert!(result.iter.size_hint().1.is_none());"
        ],
        "code": [
          "{",
          "    let mut slice: Vec<Value> = Vec::new();",
          "    for i in 0..100 {",
          "        slice.push(Value::Number(Number::from(i)));",
          "    }",
          "    let result = SeqRefDeserializer::new(&slice);",
          "    let expected_iter = slice.iter();",
          "    assert_eq!(result.iter, expected_iter);",
          "    assert_eq!(slice.len(), 100);",
          "    assert!(!slice.is_empty());",
          "    assert!(matches!(result.iter.next(), Some(Value::Number(Number::from(0))));",
          "    assert!(matches!(result.iter.next(), Some(Value::Number(Number::from(99))));",
          "    assert!(result.iter.size_hint().0 == 100);",
          "    assert!(result.iter.size_hint().1.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]