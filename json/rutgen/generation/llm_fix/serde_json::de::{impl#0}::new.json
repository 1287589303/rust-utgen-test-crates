{
  "name": "serde_json::de::{impl#0}::new",
  "mod_info": {
    "name": "de",
    "loc": "src/lib.rs:418:1:418:12"
  },
  "visible": true,
  "loc": "src/de.rs:59:5:69:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Deserializer {\n            read,\n            scratch: Vec::new(),\n            remaining_depth: 128,\n            #[cfg(feature = \"float_roundtrip\")]\n            single_precision: false,\n            #[cfg(feature = \"unbounded_depth\")]\n            disable_recursion_limit: false,\n        }\n"
      ],
      "input_infer": "Read input must be a valid type implementing the `Read` trait, scratch must be an empty Vec<u8>, remaining_depth must be set to 128, single_precision (if applicable) must be false, disable_recursion_limit (if applicable) must be false.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockSliceRead<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'de> read::Read<'de> for MockSliceRead<'_> {",
                "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
                "            let len = buf.len().min(self.data.len());",
                "            buf[..len].copy_from_slice(&self.data[..len]);",
                "            self.data = &self.data[len..];",
                "            Ok(len)",
                "        }",
                "    }",
                "",
                "    let input = b\"{}\";",
                "    let read = MockSliceRead { data: input };",
                "    let deserializer = Deserializer::new(read);",
                "}"
              ],
              "oracle": [
                "    let input = b\"{}\";",
                "    let read = MockSliceRead { data: input };",
                "    let deserializer = Deserializer::new(read);",
                "    assert_eq!(deserializer.remaining_depth, 128);",
                "    assert_eq!(deserializer.scratch, Vec::new());",
                "    #[cfg(feature = \"float_roundtrip\")]",
                "    assert_eq!(deserializer.single_precision, false);",
                "    #[cfg(feature = \"unbounded_depth\")]",
                "    assert_eq!(deserializer.disable_recursion_limit, false);"
              ],
              "code": [
                "{",
                "    struct MockSliceRead<'a> {",
                "        data: &'a [u8],",
                "    }",
                "",
                "    impl<'de> read::Read<'de> for MockSliceRead<'_> {",
                "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
                "            let len = buf.len().min(self.data.len());",
                "            buf[..len].copy_from_slice(&self.data[..len]);",
                "            self.data = &self.data[len..];",
                "            Ok(len)",
                "        }",
                "    }",
                "",
                "    let input = b\"{}\";",
                "    let read = MockSliceRead { data: input };",
                "    let deserializer = Deserializer::new(read);",
                "    let input = b\"{}\";",
                "    let read = MockSliceRead { data: input };",
                "    let deserializer = Deserializer::new(read);",
                "    assert_eq!(deserializer.remaining_depth, 128);",
                "    assert_eq!(deserializer.scratch, Vec::new());",
                "    #[cfg(feature = \"float_roundtrip\")]",
                "    assert_eq!(deserializer.single_precision, false);",
                "    #[cfg(feature = \"unbounded_depth\")]",
                "    assert_eq!(deserializer.disable_recursion_limit, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockStrRead<'a> {",
                "        data: &'a str,",
                "    }",
                "",
                "    impl<'de> read::Read<'de> for MockStrRead<'_> {",
                "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
                "            let len = buf.len().min(self.data.len());",
                "            buf[..len].copy_from_slice(&self.data.as_bytes()[..len]);",
                "            self.data = &self.data[len..];",
                "            Ok(len)",
                "        }",
                "    }",
                "",
                "    let input = \"{}\";",
                "    let read = MockStrRead { data: input };",
                "    let deserializer = Deserializer::new(read);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(deserializer.remaining_depth, 128);",
                "    assert!(deserializer.scratch.is_empty());",
                "    assert_eq!(deserializer.single_precision, false);",
                "    assert_eq!(deserializer.disable_recursion_limit, false);"
              ],
              "code": [
                "{",
                "    struct MockStrRead<'a> {",
                "        data: &'a str,",
                "    }",
                "",
                "    impl<'de> read::Read<'de> for MockStrRead<'_> {",
                "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
                "            let len = buf.len().min(self.data.len());",
                "            buf[..len].copy_from_slice(&self.data.as_bytes()[..len]);",
                "            self.data = &self.data[len..];",
                "            Ok(len)",
                "        }",
                "    }",
                "",
                "    let input = \"{}\";",
                "    let read = MockStrRead { data: input };",
                "    let deserializer = Deserializer::new(read);",
                "    assert_eq!(deserializer.remaining_depth, 128);",
                "    assert!(deserializer.scratch.is_empty());",
                "    assert_eq!(deserializer.single_precision, false);",
                "    assert_eq!(deserializer.disable_recursion_limit, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockFusedRead {",
                "        position: usize,",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl<'de> read::Read<'de> for MockFusedRead {",
                "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
                "            let len = buf.len().min(self.data.len() - self.position);",
                "            buf[..len].copy_from_slice(&self.data[self.position..self.position + len]);",
                "            self.position += len;",
                "            Ok(len)",
                "        }",
                "    }",
                "",
                "    let input = b\"{}\";",
                "    let read = MockFusedRead {",
                "        position: 0,",
                "        data: input.to_vec(),",
                "    };",
                "    let deserializer = Deserializer::new(read);",
                "}"
              ],
              "oracle": [
                "    let mock_read = MockFusedRead { position: 0, data: b\"{}\".to_vec() };",
                "    assert_eq!(deserializer.remaining_depth, 128);",
                "    assert_eq!(deserializer.scratch, Vec::new());",
                "    #[cfg(feature = \"float_roundtrip\")] assert_eq!(deserializer.single_precision, false);",
                "    #[cfg(feature = \"unbounded_depth\")] assert_eq!(deserializer.disable_recursion_limit, false);",
                "    assert_eq!(deserializer.read, mock_read);"
              ],
              "code": [
                "{",
                "    struct MockFusedRead {",
                "        position: usize,",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl<'de> read::Read<'de> for MockFusedRead {",
                "        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {",
                "            let len = buf.len().min(self.data.len() - self.position);",
                "            buf[..len].copy_from_slice(&self.data[self.position..self.position + len]);",
                "            self.position += len;",
                "            Ok(len)",
                "        }",
                "    }",
                "",
                "    let input = b\"{}\";",
                "    let read = MockFusedRead {",
                "        position: 0,",
                "        data: input.to_vec(),",
                "    };",
                "    let deserializer = Deserializer::new(read);",
                "    let mock_read = MockFusedRead { position: 0, data: b\"{}\".to_vec() };",
                "    assert_eq!(deserializer.remaining_depth, 128);",
                "    assert_eq!(deserializer.scratch, Vec::new());",
                "    #[cfg(feature = \"float_roundtrip\")] assert_eq!(deserializer.single_precision, false);",
                "    #[cfg(feature = \"unbounded_depth\")] assert_eq!(deserializer.disable_recursion_limit, false);",
                "    assert_eq!(deserializer.read, mock_read);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}