{
  "name": "serde_json::map::{impl#0}::entry",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:420:1:420:13"
  },
  "visible": true,
  "loc": "src/map.rs:274:5:287:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.map.entry(key.into()) matches EntryImpl::Occupied(occupied) at line 283 is true\n",
        "expected return value/type: Entry::Occupied(OccupiedEntry { occupied })\n"
      ],
      "input_infer": "self.map must contain at least one key-value pair with a key matching the type String, where key is any String that exists in the map\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"existing_key\".to_string(), Value::Bool(true));",
                "    let entry = map.entry(\"existing_key\");",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert_eq!(map.get(\"existing_key\"), Some(&Value::Bool(true)));",
                "    assert!(map.len() == 1);",
                "    assert!(!map.is_empty());",
                "    assert!(map.contains_key(\"existing_key\"));",
                "    assert!(map.get(\"non_existing_key\").is_none());",
                "    assert!(map.entry(\"non_existing_key\").is_err());"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"existing_key\".to_string(), Value::Bool(true));",
                "    let entry = map.entry(\"existing_key\");",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert_eq!(map.get(\"existing_key\"), Some(&Value::Bool(true)));",
                "    assert!(map.len() == 1);",
                "    assert!(!map.is_empty());",
                "    assert!(map.contains_key(\"existing_key\"));",
                "    assert!(map.get(\"non_existing_key\").is_none());",
                "    assert!(map.entry(\"non_existing_key\").is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"numeric_key\".to_string(), Value::Number(Number::from(42)));",
                "    let entry = map.entry(\"numeric_key\");",
                "}"
              ],
              "oracle": [
                "    let entry = map.entry(\"numeric_key\");",
                "    assert!(matches!(entry, Entry::Occupied(_)));"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"numeric_key\".to_string(), Value::Number(Number::from(42)));",
                "    let entry = map.entry(\"numeric_key\");",
                "    let entry = map.entry(\"numeric_key\");",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"string_key\".to_string(), Value::String(\"sample_value\".to_string()));",
                "    let entry = map.entry(\"string_key\");",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert_eq!(entry.occupied, map.map.get(\"string_key\").unwrap());"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"string_key\".to_string(), Value::String(\"sample_value\".to_string()));",
                "    let entry = map.entry(\"string_key\");",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert_eq!(entry.occupied, map.map.get(\"string_key\").unwrap());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"boolean_key\".to_string(), Value::Bool(false));",
                "    let entry = map.entry(\"boolean_key\");",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry, Entry::Occupied(_)));"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"boolean_key\".to_string(), Value::Bool(false));",
                "    let entry = map.entry(\"boolean_key\");",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"null_key\".to_string(), Value::Null);",
                "    let entry = map.entry(\"null_key\");",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry, Entry::Occupied(_)));"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"null_key\".to_string(), Value::Null);",
                "    let entry = map.entry(\"null_key\");",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.map.entry(key.into()) matches EntryImpl::Vacant(vacant) at line 283 is true\n",
        "precondition: self.map.entry(key.into()) matches EntryImpl::Vacant(vacant) at line 283 is true\n",
        "expected return value/type: Entry::Vacant(VacantEntry { vacant })\n"
      ],
      "input_infer": "S: Into<String> where key is a String that does not exist in the map\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    let entry = map.entry(\"non_existent_key\");",
                "}"
              ],
              "oracle": [
                "    let mut map = Map::new();",
                "    let entry = map.entry(\"non_existent_key\");",
                "    assert!(matches!(entry, Entry::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    let entry = map.entry(\"non_existent_key\");",
                "    let mut map = Map::new();",
                "    let entry = map.entry(\"non_existent_key\");",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"another_key\".to_string(), Value::Null);",
                "    let entry = map.entry(\"yet_another_key\");",
                "}"
              ],
              "oracle": [
                "    let mut map = Map::new();",
                "    map.insert(\"another_key\".to_string(), Value::Null);",
                "    let entry = map.entry(\"yet_another_key\");",
                "    assert!(matches!(entry, Entry::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"another_key\".to_string(), Value::Null);",
                "    let entry = map.entry(\"yet_another_key\");",
                "    let mut map = Map::new();",
                "    map.insert(\"another_key\".to_string(), Value::Null);",
                "    let entry = map.entry(\"yet_another_key\");",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::with_capacity(10);",
                "    let entry = map.entry(\"missing_key\");",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry, Entry::Vacant(VacantEntry { vacant: _ }));",
                "    assert!(map.len() == 0);",
                "    assert!(map.is_empty());",
                "    assert!(map.contains_key(\"missing_key\") == false);"
              ],
              "code": [
                "{",
                "    let mut map = Map::with_capacity(10);",
                "    let entry = map.entry(\"missing_key\");",
                "    assert_eq!(entry, Entry::Vacant(VacantEntry { vacant: _ }));",
                "    assert!(map.len() == 0);",
                "    assert!(map.is_empty());",
                "    assert!(map.contains_key(\"missing_key\") == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"existing_key\".to_string(), Value::Bool(true));",
                "    let entry = map.entry(\"key_that_does_not_exist\");",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry, Entry::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map = Map::new();",
                "    map.insert(\"existing_key\".to_string(), Value::Bool(true));",
                "    let entry = map.entry(\"key_that_does_not_exist\");",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}