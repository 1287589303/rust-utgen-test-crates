{
  "name": "serde_json::value::partial_eq::eq_f32",
  "mod_info": {
    "name": "value::partial_eq",
    "loc": "src/value/mod.rs:930:1:930:16"
  },
  "visible": false,
  "loc": "src/value/partial_eq.rs:12:1:17:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: value matches Value::Number(n) at line 14 is false\n",
        "precondition: value matches _ at line 15 is true\n",
        "expected return value/type: false\n"
      ],
      "input_infer": "value must be of type Value::Null, Value::Bool, Value::String, Value::Array, or Value::Object, other must be any f32 value\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = Value::Null;",
                "    let other = 1.0f32;",
                "    eq_f32(&value, other);",
                "}"
              ],
              "oracle": [
                "    let value = Value::Null;",
                "    let other = 1.0f32;",
                "    assert_eq!(eq_f32(&value, other), false);"
              ],
              "code": [
                "{",
                "    let value = Value::Null;",
                "    let other = 1.0f32;",
                "    eq_f32(&value, other);",
                "    let value = Value::Null;",
                "    let other = 1.0f32;",
                "    assert_eq!(eq_f32(&value, other), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = Value::Bool(true);",
                "    let other = 3.14f32;",
                "    eq_f32(&value, other);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(eq_f32(&Value::Bool(true), 3.14f32), false);"
              ],
              "code": [
                "{",
                "    let value = Value::Bool(true);",
                "    let other = 3.14f32;",
                "    eq_f32(&value, other);",
                "    assert_eq!(eq_f32(&Value::Bool(true), 3.14f32), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = Value::String(\"not a number\".to_string());",
                "    let other = 2.71f32;",
                "    eq_f32(&value, other);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(eq_f32(&Value::String(\"not a number\".to_string()), 2.71f32), false);"
              ],
              "code": [
                "{",
                "    let value = Value::String(\"not a number\".to_string());",
                "    let other = 2.71f32;",
                "    eq_f32(&value, other);",
                "    assert_eq!(eq_f32(&Value::String(\"not a number\".to_string()), 2.71f32), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = Value::Array(vec![Value::Bool(false), Value::String(\"test\".to_string())]);",
                "    let other = 0.0f32;",
                "    eq_f32(&value, other);",
                "}"
              ],
              "oracle": [
                "    let value = Value::Array(vec![Value::Bool(false), Value::String(\"test\".to_string())]);",
                "    let other = 0.0f32;",
                "    assert_eq!(eq_f32(&value, other), false);"
              ],
              "code": [
                "{",
                "    let value = Value::Array(vec![Value::Bool(false), Value::String(\"test\".to_string())]);",
                "    let other = 0.0f32;",
                "    eq_f32(&value, other);",
                "    let value = Value::Array(vec![Value::Bool(false), Value::String(\"test\".to_string())]);",
                "    let other = 0.0f32;",
                "    assert_eq!(eq_f32(&value, other), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = Value::Object(std::collections::BTreeMap::new());",
                "    let other = -1.0f32;",
                "    eq_f32(&value, other);",
                "}"
              ],
              "oracle": [
                "    assert!(!eq_f32(&Value::Object(std::collections::BTreeMap::new()), -1.0f32));"
              ],
              "code": [
                "{",
                "    let value = Value::Object(std::collections::BTreeMap::new());",
                "    let other = -1.0f32;",
                "    eq_f32(&value, other);",
                "    assert!(!eq_f32(&Value::Object(std::collections::BTreeMap::new()), -1.0f32));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: value matches Value::Number(n) at line 13 is true\n",
        "precondition: value matches Value::Number(n) at line 13 is true\n"
      ],
      "input_infer": "Value is a Number variant, where Number can hold positive, negative, or floating-point values; other parameter f32 should include positive, negative, zero, and special float cases like NaN and infinity.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_i128(42).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 42.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    assert!(value.matches(Value::Number(number)));",
                "    let number_neg = Number::from_i128(-42).unwrap();",
                "    let value_neg = Value::Number(number_neg);",
                "    let result_neg = eq_f32(&value_neg, -42.0);",
                "    assert_eq!(result_neg, true);",
                "    let number_float = Number::from_f64(42.0).unwrap();",
                "    let value_float = Value::Number(number_float);",
                "    let result_float = eq_f32(&value_float, 42.0);",
                "    assert_eq!(result_float, true);",
                "    let result_non_match = eq_f32(&value_float, 43.0);",
                "    assert_eq!(result_non_match, false);",
                "    let result_other_type = eq_f32(&Value::Bool(true), 42.0);",
                "    assert_eq!(result_other_type, false);"
              ],
              "code": [
                "{",
                "    let number = Number::from_i128(42).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 42.0);",
                "    assert_eq!(result, true);",
                "    assert!(value.matches(Value::Number(number)));",
                "    let number_neg = Number::from_i128(-42).unwrap();",
                "    let value_neg = Value::Number(number_neg);",
                "    let result_neg = eq_f32(&value_neg, -42.0);",
                "    assert_eq!(result_neg, true);",
                "    let number_float = Number::from_f64(42.0).unwrap();",
                "    let value_float = Value::Number(number_float);",
                "    let result_float = eq_f32(&value_float, 42.0);",
                "    assert_eq!(result_float, true);",
                "    let result_non_match = eq_f32(&value_float, 43.0);",
                "    assert_eq!(result_non_match, false);",
                "    let result_other_type = eq_f32(&Value::Bool(true), 42.0);",
                "    assert_eq!(result_other_type, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_i128(-42).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -42.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(-42.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -42.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(42.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 42.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(42.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 42.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(42.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 100.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 42.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 42.0);",
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let number = Number::from_i128(-42).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -42.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(-42.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -42.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(42.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 42.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(42.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 42.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(42.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 100.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 42.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 42.0);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_i128(0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(1.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 1.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(-1.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -1.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(3.14).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 3.14);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(2.71).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.71);",
                "    assert_eq!(result, true);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::String(\"test\".to_string());",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Array(vec![]);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Object(Map::new());",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let number = Number::from_i128(0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(1.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 1.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(-1.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -1.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(3.14).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 3.14);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f32(2.71).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.71);",
                "    assert_eq!(result, true);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::String(\"test\".to_string());",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Array(vec![]);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Object(Map::new());",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.34);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.0);",
                "    assert_eq!(result, false);",
                "    let number = Number::from_f64(-5.67).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -5.67);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(3.14).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 3.14159);",
                "    assert_eq!(result, false);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.34);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.0);",
                "    assert_eq!(result, false);",
                "    let number = Number::from_f64(-5.67).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -5.67);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(3.14).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 3.14159);",
                "    assert_eq!(result, false);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_f64(-12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -12.34);",
                "}"
              ],
              "oracle": [
                "    assert!(result);"
              ],
              "code": [
                "{",
                "    let number = Number::from_f64(-12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -12.34);",
                "    assert!(result);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_f64(f32::NAN as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::NAN);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);",
                "    let number = Number::from_f64(1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(-1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -1.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(2.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(1.1).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.1);",
                "    assert_eq!(result, false);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::String(String::from(\"test\"));",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Array(vec![]);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Object(std::collections::BTreeMap::new());",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let number = Number::from_f64(f32::NAN as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::NAN);",
                "    assert_eq!(result, false);",
                "    let number = Number::from_f64(1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(-1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, -1.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(2.5).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.5);",
                "    assert_eq!(result, true);",
                "    let number = Number::from_f64(1.1).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.1);",
                "    assert_eq!(result, false);",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Bool(true);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::String(String::from(\"test\"));",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Array(vec![]);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "    let value = Value::Object(std::collections::BTreeMap::new());",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::INFINITY);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::NEG_INFINITY);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.0);",
                "    assert_eq!(result, false);",
                "    ",
                "    let value_not_number = Value::Null;",
                "    let result = eq_f32(&value_not_number, f32::INFINITY);",
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::INFINITY);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::NEG_INFINITY);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 1.0);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(1.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 2.0);",
                "    assert_eq!(result, false);",
                "    ",
                "    let value_not_number = Value::Null;",
                "    let result = eq_f32(&value_not_number, f32::INFINITY);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::NEG_INFINITY);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::INFINITY);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.34);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.35);",
                "    assert_eq!(result, false);",
                "    ",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 12.34);",
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let number = Number::from_f64(f32::NEG_INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::NEG_INFINITY);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(f32::INFINITY as f64).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, f32::INFINITY);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(0.0).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 0.0);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.34);",
                "    assert_eq!(result, true);",
                "    ",
                "    let number = Number::from_f64(12.34).unwrap();",
                "    let value = Value::Number(number);",
                "    let result = eq_f32(&value, 12.35);",
                "    assert_eq!(result, false);",
                "    ",
                "    let value = Value::Null;",
                "    let result = eq_f32(&value, 12.34);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}