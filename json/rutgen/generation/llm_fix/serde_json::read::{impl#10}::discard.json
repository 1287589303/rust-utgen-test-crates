{
  "name": "serde_json::read::{impl#10}::discard",
  "mod_info": {
    "name": "read",
    "loc": "src/lib.rs:434:1:434:10"
  },
  "visible": true,
  "loc": "src/read.rs:693:5:695:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "slice: non-empty byte array of up to 4096 bytes, index: valid range from 0 to slice length, raw_buffering_start_index: valid range from 0 to slice length when feature \"raw_value\" is enabled, ensure delegate is correctly initialized.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 0;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(str_read.delegate.index, 0);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    str_read.delegate.discard();",
                "    assert!(str_read.delegate.index == 0);"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 0;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "    assert_eq!(str_read.delegate.index, 0);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    str_read.delegate.discard();",
                "    assert!(str_read.delegate.index == 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 2;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(str_read.delegate.index, 2);",
                "    str_read.delegate.discard();",
                "    assert_eq!(str_read.delegate.index, 3);",
                "    assert!(str_read.delegate.slice[2..].len() == 3);",
                "    assert!(str_read.delegate.slice[0..2] == &[1, 2]);",
                "    assert!(str_read.delegate.slice[3..] == &[4, 5]);"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 2;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "    assert_eq!(str_read.delegate.index, 2);",
                "    str_read.delegate.discard();",
                "    assert_eq!(str_read.delegate.index, 3);",
                "    assert!(str_read.delegate.slice[2..].len() == 3);",
                "    assert!(str_read.delegate.slice[0..2] == &[1, 2]);",
                "    assert!(str_read.delegate.slice[3..] == &[4, 5]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 5;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(str_read.delegate.index, 5);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    assert!(str_read.delegate.slice.len() == 5);",
                "    assert!(str_read.delegate.index <= str_read.delegate.slice.len());"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 5;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "    assert_eq!(str_read.delegate.index, 5);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    assert!(str_read.delegate.slice.len() == 5);",
                "    assert!(str_read.delegate.index <= str_read.delegate.slice.len());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: Vec<u8> = (0..4096).map(|x| x as u8).collect();",
                "    let index = 0;",
                "    let delegate = SliceRead { slice: &slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(str_read.delegate.index, 0);",
                "    assert!(str_read.delegate.slice.iter().all(|&byte| byte == slice[byte as usize]));",
                "    assert_eq!(str_read.delegate.slice.len(), 4096);"
              ],
              "code": [
                "{",
                "    let slice: Vec<u8> = (0..4096).map(|x| x as u8).collect();",
                "    let index = 0;",
                "    let delegate = SliceRead { slice: &slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "    assert_eq!(str_read.delegate.index, 0);",
                "    assert!(str_read.delegate.slice.iter().all(|&byte| byte == slice[byte as usize]));",
                "    assert_eq!(str_read.delegate.slice.len(), 4096);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[cfg(feature = \"raw_value\")]"
              ],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 0;",
                "    let raw_buffering_start_index = 0;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(str_read.delegate.index, 0);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    assert_eq!(str_read.delegate.raw_buffering_start_index, 0);",
                "    str_read.set_failed(&mut false);",
                "    assert!(str_read.delegate.slice.len() == 5);",
                "    str_read.delegate.discard();",
                "    assert!(str_read.delegate.index <= 5);"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 0;",
                "    let raw_buffering_start_index = 0;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "    assert_eq!(str_read.delegate.index, 0);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    assert_eq!(str_read.delegate.raw_buffering_start_index, 0);",
                "    str_read.set_failed(&mut false);",
                "    assert!(str_read.delegate.slice.len() == 5);",
                "    str_read.delegate.discard();",
                "    assert!(str_read.delegate.index <= 5);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [
                "#[cfg(feature = \"raw_value\")]"
              ],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 2;",
                "    let raw_buffering_start_index = 2;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(str_read.delegate.index, 2);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    assert_eq!(str_read.delegate.raw_buffering_start_index, 2);",
                "    assert!(str_read.delegate.slice.len() > str_read.delegate.index);",
                "    str_read.discard();",
                "    assert!(str_read.delegate.index <= str_read.delegate.slice.len());"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5];",
                "    let index = 2;",
                "    let raw_buffering_start_index = 2;",
                "    let delegate = SliceRead { slice, index };",
                "    let mut str_read = StrRead { delegate };",
                "",
                "    str_read.discard();",
                "    assert_eq!(str_read.delegate.index, 2);",
                "    assert_eq!(str_read.delegate.slice, &[1, 2, 3, 4, 5]);",
                "    assert_eq!(str_read.delegate.raw_buffering_start_index, 2);",
                "    assert!(str_read.delegate.slice.len() > str_read.delegate.index);",
                "    str_read.discard();",
                "    assert!(str_read.delegate.index <= str_read.delegate.slice.len());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}