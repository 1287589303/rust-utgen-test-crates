{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/de.rs\n// crate name is serde_json\nuse crate::error::{Error, ErrorCode, Result};\n#[cfg(feature = \"float_roundtrip\")]\nuse crate::lexical;\nuse crate::number::Number;\nuse crate::read::{self, Fused, Reference};\nuse alloc::string::String;\nuse alloc::vec::Vec;\n#[cfg(feature = \"float_roundtrip\")]\nuse core::iter;\nuse core::iter::FusedIterator;\nuse core::marker::PhantomData;\nuse core::result;\nuse core::str::FromStr;\nuse serde::de::{self, Expected, Unexpected};\nuse serde::forward_to_deserialize_any;\n#[cfg(feature = \"arbitrary_precision\")]\nuse crate::number::NumberDeserializer;\npub use crate::read::{Read, SliceRead, StrRead};\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\npub use crate::read::IoRead;\n#[cfg(not(feature = \"float_roundtrip\"))]\nstatic POW10: [f64; 309] = [\n    1e000,\n    1e001,\n    1e002,\n    1e003,\n    1e004,\n    1e005,\n    1e006,\n    1e007,\n    1e008,\n    1e009,\n    1e010,\n    1e011,\n    1e012,\n    1e013,\n    1e014,\n    1e015,\n    1e016,\n    1e017,\n    1e018,\n    1e019,\n    1e020,\n    1e021,\n    1e022,\n    1e023,\n    1e024,\n    1e025,\n    1e026,\n    1e027,\n    1e028,\n    1e029,\n    1e030,\n    1e031,\n    1e032,\n    1e033,\n    1e034,\n    1e035,\n    1e036,\n    1e037,\n    1e038,\n    1e039,\n    1e040,\n    1e041,\n    1e042,\n    1e043,\n    1e044,\n    1e045,\n    1e046,\n    1e047,\n    1e048,\n    1e049,\n    1e050,\n    1e051,\n    1e052,\n    1e053,\n    1e054,\n    1e055,\n    1e056,\n    1e057,\n    1e058,\n    1e059,\n    1e060,\n    1e061,\n    1e062,\n    1e063,\n    1e064,\n    1e065,\n    1e066,\n    1e067,\n    1e068,\n    1e069,\n    1e070,\n    1e071,\n    1e072,\n    1e073,\n    1e074,\n    1e075,\n    1e076,\n    1e077,\n    1e078,\n    1e079,\n    1e080,\n    1e081,\n    1e082,\n    1e083,\n    1e084,\n    1e085,\n    1e086,\n    1e087,\n    1e088,\n    1e089,\n    1e090,\n    1e091,\n    1e092,\n    1e093,\n    1e094,\n    1e095,\n    1e096,\n    1e097,\n    1e098,\n    1e099,\n    1e100,\n    1e101,\n    1e102,\n    1e103,\n    1e104,\n    1e105,\n    1e106,\n    1e107,\n    1e108,\n    1e109,\n    1e110,\n    1e111,\n    1e112,\n    1e113,\n    1e114,\n    1e115,\n    1e116,\n    1e117,\n    1e118,\n    1e119,\n    1e120,\n    1e121,\n    1e122,\n    1e123,\n    1e124,\n    1e125,\n    1e126,\n    1e127,\n    1e128,\n    1e129,\n    1e130,\n    1e131,\n    1e132,\n    1e133,\n    1e134,\n    1e135,\n    1e136,\n    1e137,\n    1e138,\n    1e139,\n    1e140,\n    1e141,\n    1e142,\n    1e143,\n    1e144,\n    1e145,\n    1e146,\n    1e147,\n    1e148,\n    1e149,\n    1e150,\n    1e151,\n    1e152,\n    1e153,\n    1e154,\n    1e155,\n    1e156,\n    1e157,\n    1e158,\n    1e159,\n    1e160,\n    1e161,\n    1e162,\n    1e163,\n    1e164,\n    1e165,\n    1e166,\n    1e167,\n    1e168,\n    1e169,\n    1e170,\n    1e171,\n    1e172,\n    1e173,\n    1e174,\n    1e175,\n    1e176,\n    1e177,\n    1e178,\n    1e179,\n    1e180,\n    1e181,\n    1e182,\n    1e183,\n    1e184,\n    1e185,\n    1e186,\n    1e187,\n    1e188,\n    1e189,\n    1e190,\n    1e191,\n    1e192,\n    1e193,\n    1e194,\n    1e195,\n    1e196,\n    1e197,\n    1e198,\n    1e199,\n    1e200,\n    1e201,\n    1e202,\n    1e203,\n    1e204,\n    1e205,\n    1e206,\n    1e207,\n    1e208,\n    1e209,\n    1e210,\n    1e211,\n    1e212,\n    1e213,\n    1e214,\n    1e215,\n    1e216,\n    1e217,\n    1e218,\n    1e219,\n    1e220,\n    1e221,\n    1e222,\n    1e223,\n    1e224,\n    1e225,\n    1e226,\n    1e227,\n    1e228,\n    1e229,\n    1e230,\n    1e231,\n    1e232,\n    1e233,\n    1e234,\n    1e235,\n    1e236,\n    1e237,\n    1e238,\n    1e239,\n    1e240,\n    1e241,\n    1e242,\n    1e243,\n    1e244,\n    1e245,\n    1e246,\n    1e247,\n    1e248,\n    1e249,\n    1e250,\n    1e251,\n    1e252,\n    1e253,\n    1e254,\n    1e255,\n    1e256,\n    1e257,\n    1e258,\n    1e259,\n    1e260,\n    1e261,\n    1e262,\n    1e263,\n    1e264,\n    1e265,\n    1e266,\n    1e267,\n    1e268,\n    1e269,\n    1e270,\n    1e271,\n    1e272,\n    1e273,\n    1e274,\n    1e275,\n    1e276,\n    1e277,\n    1e278,\n    1e279,\n    1e280,\n    1e281,\n    1e282,\n    1e283,\n    1e284,\n    1e285,\n    1e286,\n    1e287,\n    1e288,\n    1e289,\n    1e290,\n    1e291,\n    1e292,\n    1e293,\n    1e294,\n    1e295,\n    1e296,\n    1e297,\n    1e298,\n    1e299,\n    1e300,\n    1e301,\n    1e302,\n    1e303,\n    1e304,\n    1e305,\n    1e306,\n    1e307,\n    1e308,\n];\npub trait Read<'de>: private::Sealed {\n    const should_early_return_if_failed: bool;\n    fn next(&mut self) -> Result<Option<u8>>;\n    fn peek(&mut self) -> Result<Option<u8>>;\n    fn discard(&mut self);\n    fn position(&self) -> Position;\n    fn peek_position(&self) -> Position;\n    fn byte_offset(&self) -> usize;\n    fn parse_str<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, str>>;\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>;\n    fn ignore_str(&mut self) -> Result<()>;\n    fn decode_hex_escape(&mut self) -> Result<u16>;\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self);\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>;\n    fn set_failed(&mut self, failed: &mut bool);\n}\npub trait Index: private::Sealed {\n    fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>;\n    fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>;\n    fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value;\n}\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n    fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n    fn flush(&mut self) -> Result<()>;\n}\npub trait Float: Number {\n    type Unsigned: Integer;\n    const ZERO: Self;\n    const MAX_DIGITS: usize;\n    const EXPONENT_MASK: Self::Unsigned;\n    const HIDDEN_BIT_MASK: Self::Unsigned;\n    const MANTISSA_MASK: Self::Unsigned;\n    const INFINITY_BITS: Self::Unsigned;\n    const MANTISSA_SIZE: i32;\n    const EXPONENT_BIAS: i32;\n    const DENORMAL_EXPONENT: i32;\n    const MAX_EXPONENT: i32;\n    const DEFAULT_SHIFT: i32;\n    const CARRY_MASK: u64;\n    fn exponent_limit() -> (i32, i32);\n    fn mantissa_limit() -> i32;\n    fn pow10(self, n: i32) -> Self;\n    fn from_bits(u: Self::Unsigned) -> Self;\n    fn to_bits(self) -> Self::Unsigned;\n    fn is_sign_positive(self) -> bool;\n    #[inline]\n    fn is_denormal(self) -> bool;\n    #[inline]\n    fn is_special(self) -> bool;\n    #[inline]\n    fn is_inf(self) -> bool;\n    #[inline]\n    fn exponent(self) -> i32;\n    #[inline]\n    fn mantissa(self) -> Self::Unsigned {\n        let bits = self.to_bits();\n        let s = bits & Self::MANTISSA_MASK;\n        if !self.is_denormal() { s + Self::HIDDEN_BIT_MASK } else { s }\n    }\n    #[inline]\n    fn next_positive(self) -> Self {\n        debug_assert!(self.is_sign_positive() && ! self.is_inf());\n        Self::from_bits(self.to_bits() + Self::Unsigned::as_cast(1u32))\n    }\n    #[inline]\n    fn round_positive_even(self) -> Self {\n        if self.mantissa() & Self::Unsigned::as_cast(1u32)\n            == Self::Unsigned::as_cast(1u32)\n        {\n            self.next_positive()\n        } else {\n            self\n        }\n    }\n}\npub(crate) trait FloatErrors {\n    fn error_scale() -> u32;\n    fn error_halfscale() -> u32;\n    fn error_is_accurate<F: Float>(count: u32, fp: &ExtendedFloat) -> bool;\n}\ntrait Hi64<T>: AsRef<[T]> {\n    fn hi64_1(&self) -> (u64, bool);\n    fn hi64_2(&self) -> (u64, bool);\n    fn hi64_3(&self) -> (u64, bool);\n    #[inline]\n    fn hi64(&self) -> (u64, bool);\n}\npub struct Deserializer<R> {\n    read: R,\n    scratch: Vec<u8>,\n    remaining_depth: u8,\n    #[cfg(feature = \"float_roundtrip\")]\n    single_precision: bool,\n    #[cfg(feature = \"unbounded_depth\")]\n    disable_recursion_limit: bool,\n}\npub struct Serializer;\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\npub struct Serializer<W, F = CompactFormatter> {\n    writer: W,\n    formatter: F,\n}\npub struct Error;\npub struct Error {\n    /// This `Box` allows us to keep the size of `Error` as small as possible. A\n    /// larger `Error` type was substantially slower due to all the functions\n    /// that pass around `Result<T, Error>`.\n    err: Box<ErrorImpl>,\n}\npub(crate) enum ErrorCode {\n    /// Catchall for syntax error messages\n    Message(Box<str>),\n    /// Some I/O error occurred while serializing or deserializing.\n    Io(io::Error),\n    /// EOF while parsing a list.\n    EofWhileParsingList,\n    /// EOF while parsing an object.\n    EofWhileParsingObject,\n    /// EOF while parsing a string.\n    EofWhileParsingString,\n    /// EOF while parsing a JSON value.\n    EofWhileParsingValue,\n    /// Expected this character to be a `':'`.\n    ExpectedColon,\n    /// Expected this character to be either a `','` or a `']'`.\n    ExpectedListCommaOrEnd,\n    /// Expected this character to be either a `','` or a `'}'`.\n    ExpectedObjectCommaOrEnd,\n    /// Expected to parse either a `true`, `false`, or a `null`.\n    ExpectedSomeIdent,\n    /// Expected this character to start a JSON value.\n    ExpectedSomeValue,\n    /// Expected this character to be a `\"`.\n    ExpectedDoubleQuote,\n    /// Invalid hex escape code.\n    InvalidEscape,\n    /// Invalid number.\n    InvalidNumber,\n    /// Number is bigger than the maximum value of its type.\n    NumberOutOfRange,\n    /// Invalid unicode code point.\n    InvalidUnicodeCodePoint,\n    /// Control character found while parsing a string.\n    ControlCharacterWhileParsingString,\n    /// Object key is not a string.\n    KeyMustBeAString,\n    /// Contents of key were supposed to be a number.\n    ExpectedNumericKey,\n    /// Object key is a non-finite float value.\n    FloatKeyMustBeFinite,\n    /// Lone leading surrogate in hex escape.\n    LoneLeadingSurrogateInHexEscape,\n    /// JSON has a comma after the last value in an array or map.\n    TrailingComma,\n    /// JSON has non-whitespace trailing characters after the value.\n    TrailingCharacters,\n    /// Unexpected end of hex escape.\n    UnexpectedEndOfHexEscape,\n    /// Encountered nesting of JSON maps and arrays more than 128 layers deep.\n    RecursionLimitExceeded,\n}\npub enum Reference<'b, 'c, T>\nwhere\n    T: ?Sized + 'static,\n{\n    Borrowed(&'b T),\n    Copied(&'c T),\n}\nimpl<'de, R: Read<'de>> de::Deserializer<'de> for &mut Deserializer<R> {\n    type Error = Error;\n    #[inline]\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n        let value = match peek {\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match tri!(self.read.parse_str_raw(& mut self.scratch)) {\n                    Reference::Borrowed(b) => visitor.visit_borrowed_bytes(b),\n                    Reference::Copied(b) => visitor.visit_bytes(b),\n                }\n            }\n            b'[' => self.deserialize_seq(visitor),\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }\n    #[inline]\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    #[inline]\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_unit_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    #[inline]\n    fn deserialize_newtype_struct<V>(self, name: &str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n}\nimpl<'de, R: Read<'de>> Deserializer<R> {\n    pub fn end(&mut self) -> Result<()> {}\n    pub fn into_iter<T>(self) -> StreamDeserializer<'de, R, T>\n    where\n        T: de::Deserialize<'de>,\n    {}\n    #[cfg(feature = \"unbounded_depth\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unbounded_depth\")))]\n    pub fn disable_recursion_limit(&mut self) {}\n    pub(crate) fn peek(&mut self) -> Result<Option<u8>> {}\n    fn peek_or_null(&mut self) -> Result<u8> {}\n    fn eat_char(&mut self) {\n        self.read.discard();\n    }\n    fn next_char(&mut self) -> Result<Option<u8>> {}\n    fn next_char_or_null(&mut self) -> Result<u8> {}\n    #[cold]\n    fn error(&self, reason: ErrorCode) -> Error {}\n    #[cold]\n    fn peek_error(&self, reason: ErrorCode) -> Error {\n        let position = self.read.peek_position();\n        Error::syntax(reason, position.line, position.column)\n    }\n    fn parse_whitespace(&mut self) -> Result<Option<u8>> {\n        loop {\n            match tri!(self.peek()) {\n                Some(b' ' | b'\\n' | b'\\t' | b'\\r') => {\n                    self.eat_char();\n                }\n                other => {\n                    return Ok(other);\n                }\n            }\n        }\n    }\n    #[cold]\n    fn peek_invalid_type(&mut self, exp: &dyn Expected) -> Error {\n        let err = match self.peek_or_null().unwrap_or(b'\\x00') {\n            b'n' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"ull\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Unit, exp)\n            }\n            b't' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"rue\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(true), exp)\n            }\n            b'f' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"alse\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(false), exp)\n            }\n            b'-' => {\n                self.eat_char();\n                match self.parse_any_number(false) {\n                    Ok(n) => n.invalid_type(exp),\n                    Err(err) => return err,\n                }\n            }\n            b'0'..=b'9' => {\n                match self.parse_any_number(true) {\n                    Ok(n) => n.invalid_type(exp),\n                    Err(err) => return err,\n                }\n            }\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match self.read.parse_str(&mut self.scratch) {\n                    Ok(s) => de::Error::invalid_type(Unexpected::Str(&s), exp),\n                    Err(err) => return err,\n                }\n            }\n            b'[' => de::Error::invalid_type(Unexpected::Seq, exp),\n            b'{' => de::Error::invalid_type(Unexpected::Map, exp),\n            _ => self.peek_error(ErrorCode::ExpectedSomeValue),\n        };\n        self.fix_position(err)\n    }\n    pub(crate) fn deserialize_number<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {}\n    #[cfg(feature = \"float_roundtrip\")]\n    pub(crate) fn do_deserialize_f32<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {}\n    pub(crate) fn do_deserialize_i128<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {}\n    pub(crate) fn do_deserialize_u128<'any, V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'any>,\n    {}\n    fn scan_integer128(&mut self, buf: &mut String) -> Result<()> {}\n    #[cold]\n    fn fix_position(&self, err: Error) -> Error {\n        err.fix_position(move |code| self.error(code))\n    }\n    fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {}\n    fn parse_integer(&mut self, positive: bool) -> Result<ParserNumber> {}\n    fn parse_number(\n        &mut self,\n        positive: bool,\n        significand: u64,\n    ) -> Result<ParserNumber> {}\n    fn parse_decimal(\n        &mut self,\n        positive: bool,\n        mut significand: u64,\n        exponent_before_decimal_point: i32,\n    ) -> Result<f64> {}\n    fn parse_exponent(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        starting_exp: i32,\n    ) -> Result<f64> {}\n    #[cfg(feature = \"float_roundtrip\")]\n    fn f64_from_parts(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64> {}\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    fn f64_from_parts(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        mut exponent: i32,\n    ) -> Result<f64> {}\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    #[inline(never)]\n    fn parse_long_integer(\n        &mut self,\n        positive: bool,\n        partial_significand: u64,\n    ) -> Result<f64> {}\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    #[cold]\n    #[inline(never)]\n    fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {}\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    fn parse_long_decimal(&mut self, positive: bool, integer_end: usize) -> Result<f64> {}\n    #[cfg(feature = \"float_roundtrip\")]\n    fn parse_long_exponent(\n        &mut self,\n        positive: bool,\n        integer_end: usize,\n    ) -> Result<f64> {}\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    #[inline(never)]\n    fn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64> {}\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    #[cold]\n    #[inline(never)]\n    fn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64> {}\n    #[cold]\n    #[inline(never)]\n    fn parse_exponent_overflow(\n        &mut self,\n        positive: bool,\n        zero_significand: bool,\n        positive_exp: bool,\n    ) -> Result<f64> {}\n    #[cfg(feature = \"float_roundtrip\")]\n    fn f64_long_from_parts(\n        &mut self,\n        positive: bool,\n        integer_end: usize,\n        exponent: i32,\n    ) -> Result<f64> {}\n    fn parse_any_signed_number(&mut self) -> Result<ParserNumber> {}\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {}\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {}\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_or_eof(&mut self, buf: &mut String) -> Result<u8> {}\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_integer(&mut self, buf: &mut String) -> Result<()> {}\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_number(&mut self, buf: &mut String) -> Result<()> {}\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_decimal(&mut self, buf: &mut String) -> Result<()> {}\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_exponent(&mut self, e: char, buf: &mut String) -> Result<()> {}\n    fn parse_object_colon(&mut self) -> Result<()> {}\n    fn end_seq(&mut self) -> Result<()> {}\n    fn end_map(&mut self) -> Result<()> {}\n    fn ignore_value(&mut self) -> Result<()> {}\n    fn ignore_integer(&mut self) -> Result<()> {}\n    fn ignore_decimal(&mut self) -> Result<()> {}\n    fn ignore_exponent(&mut self) -> Result<()> {}\n    #[cfg(feature = \"raw_value\")]\n    fn deserialize_raw_value<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Parses a JSON string as bytes. Note that this function does not check\n/// whether the bytes represent a valid UTF-8 string.\n///\n/// The relevant part of the JSON specification is Section 8.2 of [RFC\n/// 7159]:\n///\n/// > When all the strings represented in a JSON text are composed entirely\n/// > of Unicode characters (however escaped), then that JSON text is\n/// > interoperable in the sense that all software implementations that\n/// > parse it will agree on the contents of names and of string values in\n/// > objects and arrays.\n/// >\n/// > However, the ABNF in this specification allows member names and string\n/// > values to contain bit sequences that cannot encode Unicode characters;\n/// > for example, \"\\uDEAD\" (a single unpaired UTF-16 surrogate). Instances\n/// > of this have been observed, for example, when a library truncates a\n/// > UTF-16 string without checking whether the truncation split a\n/// > surrogate pair.  The behavior of software that receives JSON texts\n/// > containing such values is unpredictable; for example, implementations\n/// > might return different values for the length of a string value or even\n/// > suffer fatal runtime exceptions.\n///\n/// [RFC 7159]: https://tools.ietf.org/html/rfc7159\n///\n/// The behavior of serde_json is specified to fail on non-UTF-8 strings\n/// when deserializing into Rust UTF-8 string types such as String, and\n/// succeed with the bytes representing the [WTF-8] encoding of code points\n/// when deserializing using this method.\n///\n/// [WTF-8]: https://simonsapin.github.io/wtf-8\n///\n/// Escape sequences are processed as usual, and for `\\uXXXX` escapes it is\n/// still checked if the hex number represents a valid Unicode code point.\n///\n/// # Examples\n///\n/// You can use this to parse JSON strings containing invalid UTF-8 bytes,\n/// or unpaired surrogates.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"some bytes: \\xe5\\x00\\xe5\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///\n///     assert_eq!(b'\\xe5', bytes[12]);\n///     assert_eq!(b'\\0', bytes[13]);\n///     assert_eq!(b'\\xe5', bytes[14]);\n///\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes().unwrap();\n/// ```\n///\n/// Backslash escape sequences like `\\n` are still interpreted and required\n/// to be valid. `\\u` escape sequences are required to represent a valid\n/// Unicode code point or lone surrogate.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"lone surrogate: \\\\uD801\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///     let expected = b\"lone surrogate: \\xED\\xA0\\x81\";\n///     assert_eq!(expected, bytes.as_slice());\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes();\n/// ```\n1631 fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n1632 where\n1633     V: de::Visitor<'de>,\n1634 {\n1635     let peek = match tri!(self.parse_whitespace()) {\n1636         Some(b) => b,\n1637         None => {\n1638             return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n1639         }\n1640     };\n1641 \n1642     let value = match peek {\n1643         b'\"' => {\n1644             self.eat_char();\n1645             self.scratch.clear();\n1646             match tri!(self.read.parse_str_raw(&mut self.scratch)) {\n1647                 Reference::Borrowed(b) => visitor.visit_borrowed_bytes(b),\n1648                 Reference::Copied(b) => visitor.visit_bytes(b),\n1649             }\n1650         }\n1651         b'[' => self.deserialize_seq(visitor),\n1652         _ => Err(self.peek_invalid_type(&visitor)),\n1653     };\n1654 \n1655     match value {\n1656         Ok(value) => Ok(value),\n1657         Err(err) => Err(self.fix_position(err)),\n1658     }\n1659 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}