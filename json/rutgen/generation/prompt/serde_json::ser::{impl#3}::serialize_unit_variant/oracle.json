{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/ser.rs\n// crate name is serde_json\nuse crate::error::{Error, ErrorCode, Result};\nuse crate::io;\nuse alloc::string::String;\n#[cfg(feature = \"raw_value\")]\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse core::fmt::{self, Display};\nuse core::num::FpCategory;\nuse serde::ser::{self, Impossible, Serialize};\nstatic ESCAPE: [u8; 256] = [\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    BB,\n    TT,\n    NN,\n    UU,\n    FF,\n    RR,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    UU,\n    __,\n    __,\n    QU,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    BS,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n    __,\n];\nconst BB: u8 = b'b';\nconst TT: u8 = b't';\nconst NN: u8 = b'n';\nconst FF: u8 = b'f';\nconst RR: u8 = b'r';\nconst QU: u8 = b'\"';\nconst BS: u8 = b'\\\\';\nconst UU: u8 = b'u';\nconst __: u8 = 0;\npub trait Read<'de>: private::Sealed {\n    const should_early_return_if_failed: bool;\n    fn next(&mut self) -> Result<Option<u8>>;\n    fn peek(&mut self) -> Result<Option<u8>>;\n    fn discard(&mut self);\n    fn position(&self) -> Position;\n    fn peek_position(&self) -> Position;\n    fn byte_offset(&self) -> usize;\n    fn parse_str<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, str>>;\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>;\n    fn ignore_str(&mut self) -> Result<()>;\n    fn decode_hex_escape(&mut self) -> Result<u16>;\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self);\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>;\n    fn set_failed(&mut self, failed: &mut bool);\n}\npub trait Index: private::Sealed {\n    fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>;\n    fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>;\n    fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value;\n}\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n    fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n    fn flush(&mut self) -> Result<()>;\n}\npub trait Float: Number {\n    type Unsigned: Integer;\n    const ZERO: Self;\n    const MAX_DIGITS: usize;\n    const EXPONENT_MASK: Self::Unsigned;\n    const HIDDEN_BIT_MASK: Self::Unsigned;\n    const MANTISSA_MASK: Self::Unsigned;\n    const INFINITY_BITS: Self::Unsigned;\n    const MANTISSA_SIZE: i32;\n    const EXPONENT_BIAS: i32;\n    const DENORMAL_EXPONENT: i32;\n    const MAX_EXPONENT: i32;\n    const DEFAULT_SHIFT: i32;\n    const CARRY_MASK: u64;\n    fn exponent_limit() -> (i32, i32);\n    fn mantissa_limit() -> i32;\n    fn pow10(self, n: i32) -> Self;\n    fn from_bits(u: Self::Unsigned) -> Self;\n    fn to_bits(self) -> Self::Unsigned;\n    fn is_sign_positive(self) -> bool;\n    #[inline]\n    fn is_denormal(self) -> bool;\n    #[inline]\n    fn is_special(self) -> bool;\n    #[inline]\n    fn is_inf(self) -> bool;\n    #[inline]\n    fn exponent(self) -> i32;\n    #[inline]\n    fn mantissa(self) -> Self::Unsigned {\n        let bits = self.to_bits();\n        let s = bits & Self::MANTISSA_MASK;\n        if !self.is_denormal() { s + Self::HIDDEN_BIT_MASK } else { s }\n    }\n    #[inline]\n    fn next_positive(self) -> Self {\n        debug_assert!(self.is_sign_positive() && ! self.is_inf());\n        Self::from_bits(self.to_bits() + Self::Unsigned::as_cast(1u32))\n    }\n    #[inline]\n    fn round_positive_even(self) -> Self {\n        if self.mantissa() & Self::Unsigned::as_cast(1u32)\n            == Self::Unsigned::as_cast(1u32)\n        {\n            self.next_positive()\n        } else {\n            self\n        }\n    }\n}\npub(crate) trait FloatErrors {\n    fn error_scale() -> u32;\n    fn error_halfscale() -> u32;\n    fn error_is_accurate<F: Float>(count: u32, fp: &ExtendedFloat) -> bool;\n}\ntrait Hi64<T>: AsRef<[T]> {\n    fn hi64_1(&self) -> (u64, bool);\n    fn hi64_2(&self) -> (u64, bool);\n    fn hi64_3(&self) -> (u64, bool);\n    #[inline]\n    fn hi64(&self) -> (u64, bool);\n}\npub struct Serializer;\npub struct Error {\n    /// This `Box` allows us to keep the size of `Error` as small as possible. A\n    /// larger `Error` type was substantially slower due to all the functions\n    /// that pass around `Result<T, Error>`.\n    err: Box<ErrorImpl>,\n}\npub struct Deserializer<R> {\n    read: R,\n    scratch: Vec<u8>,\n    remaining_depth: u8,\n    #[cfg(feature = \"float_roundtrip\")]\n    single_precision: bool,\n    #[cfg(feature = \"unbounded_depth\")]\n    disable_recursion_limit: bool,\n}\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\npub struct Serializer<W, F = CompactFormatter> {\n    writer: W,\n    formatter: F,\n}\npub struct Error;\npub enum Compound<'a, W: 'a, F: 'a> {\n    Map { ser: &'a mut Serializer<W, F>, state: State },\n    #[cfg(feature = \"arbitrary_precision\")]\n    Number { ser: &'a mut Serializer<W, F> },\n    #[cfg(feature = \"raw_value\")]\n    RawValue { ser: &'a mut Serializer<W, F> },\n}\nimpl<'a, W, F> ser::Serializer for &'a mut Serializer<W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n    type SerializeSeq = Compound<'a, W, F>;\n    type SerializeTuple = Compound<'a, W, F>;\n    type SerializeTupleStruct = Compound<'a, W, F>;\n    type SerializeTupleVariant = Compound<'a, W, F>;\n    type SerializeMap = Compound<'a, W, F>;\n    type SerializeStruct = Compound<'a, W, F>;\n    type SerializeStructVariant = Compound<'a, W, F>;\n    #[inline]\n    fn serialize_bool(self, value: bool) -> Result<()> {}\n    #[inline]\n    fn serialize_i8(self, value: i8) -> Result<()> {}\n    #[inline]\n    fn serialize_i16(self, value: i16) -> Result<()> {}\n    #[inline]\n    fn serialize_i32(self, value: i32) -> Result<()> {}\n    #[inline]\n    fn serialize_i64(self, value: i64) -> Result<()> {}\n    fn serialize_i128(self, value: i128) -> Result<()> {}\n    #[inline]\n    fn serialize_u8(self, value: u8) -> Result<()> {}\n    #[inline]\n    fn serialize_u16(self, value: u16) -> Result<()> {}\n    #[inline]\n    fn serialize_u32(self, value: u32) -> Result<()> {}\n    #[inline]\n    fn serialize_u64(self, value: u64) -> Result<()> {}\n    fn serialize_u128(self, value: u128) -> Result<()> {}\n    #[inline]\n    fn serialize_f32(self, value: f32) -> Result<()> {}\n    #[inline]\n    fn serialize_f64(self, value: f64) -> Result<()> {}\n    #[inline]\n    fn serialize_char(self, value: char) -> Result<()> {}\n    #[inline]\n    fn serialize_str(self, value: &str) -> Result<()> {}\n    #[inline]\n    fn serialize_bytes(self, value: &[u8]) -> Result<()> {}\n    #[inline]\n    fn serialize_unit(self) -> Result<()> {}\n    #[inline]\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {}\n    #[inline]\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<()> {\n        self.serialize_str(variant)\n    }\n    #[inline]\n    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {}\n    #[inline]\n    fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {}\n    #[inline]\n    fn serialize_none(self) -> Result<()> {}\n    #[inline]\n    fn serialize_some<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {}\n    #[inline]\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {\n        tri!(self.formatter.begin_array(& mut self.writer).map_err(Error::io));\n        if len == Some(0) {\n            tri!(self.formatter.end_array(& mut self.writer).map_err(Error::io));\n            Ok(Compound::Map {\n                ser: self,\n                state: State::Empty,\n            })\n        } else {\n            Ok(Compound::Map {\n                ser: self,\n                state: State::First,\n            })\n        }\n    }\n    #[inline]\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {\n        self.serialize_seq(Some(len))\n    }\n    #[inline]\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct> {\n        self.serialize_seq(Some(len))\n    }\n    #[inline]\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant> {\n        tri!(self.formatter.begin_object(& mut self.writer).map_err(Error::io));\n        tri!(\n            self.formatter.begin_object_key(& mut self.writer, true).map_err(Error::io)\n        );\n        tri!(self.serialize_str(variant));\n        tri!(self.formatter.end_object_key(& mut self.writer).map_err(Error::io));\n        tri!(self.formatter.begin_object_value(& mut self.writer).map_err(Error::io));\n        self.serialize_seq(Some(len))\n    }\n    #[inline]\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap> {\n        tri!(self.formatter.begin_object(& mut self.writer).map_err(Error::io));\n        if len == Some(0) {\n            tri!(self.formatter.end_object(& mut self.writer).map_err(Error::io));\n            Ok(Compound::Map {\n                ser: self,\n                state: State::Empty,\n            })\n        } else {\n            Ok(Compound::Map {\n                ser: self,\n                state: State::First,\n            })\n        }\n    }\n    #[inline]\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct> {\n        match name {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(Compound::Number { ser: self }),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(Compound::RawValue { ser: self }),\n            _ => self.serialize_map(Some(len)),\n        }\n    }\n    #[inline]\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant> {\n        tri!(self.formatter.begin_object(& mut self.writer).map_err(Error::io));\n        tri!(\n            self.formatter.begin_object_key(& mut self.writer, true).map_err(Error::io)\n        );\n        tri!(self.serialize_str(variant));\n        tri!(self.formatter.end_object_key(& mut self.writer).map_err(Error::io));\n        tri!(self.formatter.begin_object_value(& mut self.writer).map_err(Error::io));\n        self.serialize_map(Some(len))\n    }\n    fn collect_str<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Display,\n    {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n212 fn serialize_unit_variant(\n213     self,\n214     _name: &'static str,\n215     _variant_index: u32,\n216     variant: &'static str,\n217 ) -> Result<()> {\n218     self.serialize_str(variant)\n219 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}