{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/de.rs\n// crate name is serde_json\nuse crate::error::{Error, ErrorCode, Result};\n#[cfg(feature = \"float_roundtrip\")]\nuse crate::lexical;\nuse crate::number::Number;\nuse crate::read::{self, Fused, Reference};\nuse alloc::string::String;\nuse alloc::vec::Vec;\n#[cfg(feature = \"float_roundtrip\")]\nuse core::iter;\nuse core::iter::FusedIterator;\nuse core::marker::PhantomData;\nuse core::result;\nuse core::str::FromStr;\nuse serde::de::{self, Expected, Unexpected};\nuse serde::forward_to_deserialize_any;\n#[cfg(feature = \"arbitrary_precision\")]\nuse crate::number::NumberDeserializer;\npub use crate::read::{Read, SliceRead, StrRead};\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\npub use crate::read::IoRead;\n#[cfg(not(feature = \"float_roundtrip\"))]\nstatic POW10: [f64; 309] = [\n    1e000,\n    1e001,\n    1e002,\n    1e003,\n    1e004,\n    1e005,\n    1e006,\n    1e007,\n    1e008,\n    1e009,\n    1e010,\n    1e011,\n    1e012,\n    1e013,\n    1e014,\n    1e015,\n    1e016,\n    1e017,\n    1e018,\n    1e019,\n    1e020,\n    1e021,\n    1e022,\n    1e023,\n    1e024,\n    1e025,\n    1e026,\n    1e027,\n    1e028,\n    1e029,\n    1e030,\n    1e031,\n    1e032,\n    1e033,\n    1e034,\n    1e035,\n    1e036,\n    1e037,\n    1e038,\n    1e039,\n    1e040,\n    1e041,\n    1e042,\n    1e043,\n    1e044,\n    1e045,\n    1e046,\n    1e047,\n    1e048,\n    1e049,\n    1e050,\n    1e051,\n    1e052,\n    1e053,\n    1e054,\n    1e055,\n    1e056,\n    1e057,\n    1e058,\n    1e059,\n    1e060,\n    1e061,\n    1e062,\n    1e063,\n    1e064,\n    1e065,\n    1e066,\n    1e067,\n    1e068,\n    1e069,\n    1e070,\n    1e071,\n    1e072,\n    1e073,\n    1e074,\n    1e075,\n    1e076,\n    1e077,\n    1e078,\n    1e079,\n    1e080,\n    1e081,\n    1e082,\n    1e083,\n    1e084,\n    1e085,\n    1e086,\n    1e087,\n    1e088,\n    1e089,\n    1e090,\n    1e091,\n    1e092,\n    1e093,\n    1e094,\n    1e095,\n    1e096,\n    1e097,\n    1e098,\n    1e099,\n    1e100,\n    1e101,\n    1e102,\n    1e103,\n    1e104,\n    1e105,\n    1e106,\n    1e107,\n    1e108,\n    1e109,\n    1e110,\n    1e111,\n    1e112,\n    1e113,\n    1e114,\n    1e115,\n    1e116,\n    1e117,\n    1e118,\n    1e119,\n    1e120,\n    1e121,\n    1e122,\n    1e123,\n    1e124,\n    1e125,\n    1e126,\n    1e127,\n    1e128,\n    1e129,\n    1e130,\n    1e131,\n    1e132,\n    1e133,\n    1e134,\n    1e135,\n    1e136,\n    1e137,\n    1e138,\n    1e139,\n    1e140,\n    1e141,\n    1e142,\n    1e143,\n    1e144,\n    1e145,\n    1e146,\n    1e147,\n    1e148,\n    1e149,\n    1e150,\n    1e151,\n    1e152,\n    1e153,\n    1e154,\n    1e155,\n    1e156,\n    1e157,\n    1e158,\n    1e159,\n    1e160,\n    1e161,\n    1e162,\n    1e163,\n    1e164,\n    1e165,\n    1e166,\n    1e167,\n    1e168,\n    1e169,\n    1e170,\n    1e171,\n    1e172,\n    1e173,\n    1e174,\n    1e175,\n    1e176,\n    1e177,\n    1e178,\n    1e179,\n    1e180,\n    1e181,\n    1e182,\n    1e183,\n    1e184,\n    1e185,\n    1e186,\n    1e187,\n    1e188,\n    1e189,\n    1e190,\n    1e191,\n    1e192,\n    1e193,\n    1e194,\n    1e195,\n    1e196,\n    1e197,\n    1e198,\n    1e199,\n    1e200,\n    1e201,\n    1e202,\n    1e203,\n    1e204,\n    1e205,\n    1e206,\n    1e207,\n    1e208,\n    1e209,\n    1e210,\n    1e211,\n    1e212,\n    1e213,\n    1e214,\n    1e215,\n    1e216,\n    1e217,\n    1e218,\n    1e219,\n    1e220,\n    1e221,\n    1e222,\n    1e223,\n    1e224,\n    1e225,\n    1e226,\n    1e227,\n    1e228,\n    1e229,\n    1e230,\n    1e231,\n    1e232,\n    1e233,\n    1e234,\n    1e235,\n    1e236,\n    1e237,\n    1e238,\n    1e239,\n    1e240,\n    1e241,\n    1e242,\n    1e243,\n    1e244,\n    1e245,\n    1e246,\n    1e247,\n    1e248,\n    1e249,\n    1e250,\n    1e251,\n    1e252,\n    1e253,\n    1e254,\n    1e255,\n    1e256,\n    1e257,\n    1e258,\n    1e259,\n    1e260,\n    1e261,\n    1e262,\n    1e263,\n    1e264,\n    1e265,\n    1e266,\n    1e267,\n    1e268,\n    1e269,\n    1e270,\n    1e271,\n    1e272,\n    1e273,\n    1e274,\n    1e275,\n    1e276,\n    1e277,\n    1e278,\n    1e279,\n    1e280,\n    1e281,\n    1e282,\n    1e283,\n    1e284,\n    1e285,\n    1e286,\n    1e287,\n    1e288,\n    1e289,\n    1e290,\n    1e291,\n    1e292,\n    1e293,\n    1e294,\n    1e295,\n    1e296,\n    1e297,\n    1e298,\n    1e299,\n    1e300,\n    1e301,\n    1e302,\n    1e303,\n    1e304,\n    1e305,\n    1e306,\n    1e307,\n    1e308,\n];\npub trait Read<'de>: private::Sealed {\n    const should_early_return_if_failed: bool;\n    fn next(&mut self) -> Result<Option<u8>>;\n    fn peek(&mut self) -> Result<Option<u8>>;\n    fn discard(&mut self);\n    fn position(&self) -> Position;\n    fn peek_position(&self) -> Position;\n    fn byte_offset(&self) -> usize;\n    fn parse_str<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, str>>;\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>;\n    fn ignore_str(&mut self) -> Result<()>;\n    fn decode_hex_escape(&mut self) -> Result<u16>;\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self);\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>;\n    fn set_failed(&mut self, failed: &mut bool);\n}\nstruct SeqAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n    first: bool,\n}\npub struct Error;\npub struct Error {\n    /// This `Box` allows us to keep the size of `Error` as small as possible. A\n    /// larger `Error` type was substantially slower due to all the functions\n    /// that pass around `Result<T, Error>`.\n    err: Box<ErrorImpl>,\n}\npub struct Deserializer<R> {\n    read: R,\n    scratch: Vec<u8>,\n    remaining_depth: u8,\n    #[cfg(feature = \"float_roundtrip\")]\n    single_precision: bool,\n    #[cfg(feature = \"unbounded_depth\")]\n    disable_recursion_limit: bool,\n}\nimpl<'de, 'a, R: Read<'de> + 'a> de::SeqAccess<'de> for SeqAccess<'a, R> {\n    type Error = Error;\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        fn has_next_element<'de, 'a, R: Read<'de> + 'a>(\n            seq: &mut SeqAccess<'a, R>,\n        ) -> Result<bool> {\n            let peek = match tri!(seq.de.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(seq.de.peek_error(ErrorCode::EofWhileParsingList));\n                }\n            };\n            if peek == b']' {\n                Ok(false)\n            } else if seq.first {\n                seq.first = false;\n                Ok(true)\n            } else if peek == b',' {\n                seq.de.eat_char();\n                match tri!(seq.de.parse_whitespace()) {\n                    Some(b']') => Err(seq.de.peek_error(ErrorCode::TrailingComma)),\n                    Some(_) => Ok(true),\n                    None => Err(seq.de.peek_error(ErrorCode::EofWhileParsingValue)),\n                }\n            } else {\n                Err(seq.de.peek_error(ErrorCode::ExpectedListCommaOrEnd))\n            }\n        }\n        if tri!(has_next_element(self)) {\n            Ok(Some(tri!(seed.deserialize(& mut * self.de))))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1931 fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n1932 where\n1933     T: de::DeserializeSeed<'de>,\n1934 {\n1935     fn has_next_element<'de, 'a, R: Read<'de> + 'a>(\n1936         seq: &mut SeqAccess<'a, R>,\n1937     ) -> Result<bool> {\n1938         let peek = match tri!(seq.de.parse_whitespace()) {\n1939             Some(b) => b,\n1940             None => {\n1941                 return Err(seq.de.peek_error(ErrorCode::EofWhileParsingList));\n1942             }\n1943         };\n1944 \n1945         if peek == b']' {\n1946             Ok(false)\n1947         } else if seq.first {\n1948             seq.first = false;\n1949             Ok(true)\n1950         } else if peek == b',' {\n1951             seq.de.eat_char();\n1952             match tri!(seq.de.parse_whitespace()) {\n1953                 Some(b']') => Err(seq.de.peek_error(ErrorCode::TrailingComma)),\n1954                 Some(_) => Ok(true),\n1955                 None => Err(seq.de.peek_error(ErrorCode::EofWhileParsingValue)),\n1956             }\n1957         } else {\n1958             Err(seq.de.peek_error(ErrorCode::ExpectedListCommaOrEnd))\n1959         }\n1960     }\n1961 \n1962     if tri!(has_next_element(self)) {\n1963         Ok(Some(tri!(seed.deserialize(&mut *self.de))))\n1964     } else {\n1965         Ok(None)\n1966     }\n1967 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}