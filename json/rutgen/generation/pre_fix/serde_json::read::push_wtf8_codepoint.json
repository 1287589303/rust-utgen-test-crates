{
  "name": "serde_json::read::push_wtf8_codepoint",
  "mod_info": {
    "name": "read",
    "loc": "src/lib.rs:434:1:434:10"
  },
  "visible": false,
  "loc": "src/read.rs:978:1:1021:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: n < 0x80 at line 979 is true\n"
      ],
      "input_infer": "n: 0 to 127, scratch: existing Vec<u8> with sufficient capacity to accommodate additional bytes\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    for n in 0..=127 {",
                "        push_wtf8_codepoint(n, &mut scratch);",
                "    }",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 128",
                "    scratch[0..128] == (0..=127).map(|x| x as u8).collect::<Vec<u8>>()"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    for n in 0..=127 {",
                "        push_wtf8_codepoint(n, &mut scratch);",
                "    }",
                "    scratch.len() == 128",
                "    scratch[0..128] == (0..=127).map(|x| x as u8).collect::<Vec<u8>>()",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 1);",
                "    assert_eq!(scratch[0], 0);",
                "    assert_eq!(scratch.capacity(), 4);",
                "    assert!(scratch.is_empty() == false);",
                "    assert_eq!(scratch, vec![0]);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0, &mut scratch);",
                "    assert_eq!(scratch.len(), 1);",
                "    assert_eq!(scratch[0], 0);",
                "    assert_eq!(scratch.capacity(), 4);",
                "    assert!(scratch.is_empty() == false);",
                "    assert_eq!(scratch, vec![0]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(127, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 1);",
                "    assert_eq!(scratch[0], 127);",
                "    assert_eq!(scratch.capacity(), 4);",
                "    assert!(scratch.is_empty() == false);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(127, &mut scratch);",
                "    assert_eq!(scratch.len(), 1);",
                "    assert_eq!(scratch[0], 127);",
                "    assert_eq!(scratch.capacity(), 4);",
                "    assert!(scratch.is_empty() == false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: n < 0x80 at line 979 is false, with bound n == 0x80\n",
        "precondition: n matches 0..=0x7F at line 995 is true\n",
        "precondition: n matches 0..=0x7F at line 995 is true\n",
        "precondition: n matches 0..=0x7F at line 994 is true\n"
      ],
      "input_infer": "n in the ranges [0x80, 0xFFFF] inclusive, and [0x10000, 0x10FFFF] inclusive, scratch with capacities of at least 4 bytes or more to accommodate maximum encoding.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0x80;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0000",
                "    scratch[1] == 0b1000_0000",
                "    scratch.capacity() >= 4",
                "    scratch.is_empty() == false"
              ],
              "code": [
                "{",
                "    let n = 0x80;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0000",
                "    scratch[1] == 0b1000_0000",
                "    scratch.capacity() >= 4",
                "    scratch.is_empty() == false",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0x7FF;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0001",
                "    scratch[1] == 0b1000_0000"
              ],
              "code": [
                "{",
                "    let n = 0x7FF;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0001",
                "    scratch[1] == 0b1000_0000",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0xFFFF;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 4",
                "    scratch[0] == 0b11101111",
                "    scratch[1] == 0b10011111",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10000000"
              ],
              "code": [
                "{",
                "    let n = 0xFFFF;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    scratch.len() == 4",
                "    scratch[0] == 0b11101111",
                "    scratch[1] == 0b10011111",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10000000",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0x10FFFF;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10010000",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10111111"
              ],
              "code": [
                "{",
                "    let n = 0x10FFFF;",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    scratch.len() == 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10010000",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10111111",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 26,
      "prompt_conds": [
        "precondition: n < 0x80 at line 979 is false, with bound n == 0x80\n",
        "precondition: n matches 0..=0x7F at line 995 is false\n",
        "precondition: n matches 0x80..=0x7FF at line 996 is true\n",
        "precondition: n matches 0x80..=0x7FF at line 996 is true\n",
        "precondition: n matches 0x80..=0x7FF at line 994 is true\n"
      ],
      "input_infer": "n in the range 0x80 to 0x7FF, inclusive; scratch is a mutable Vec<u8> with at least 4 bytes reserved.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 2);",
                "    assert_eq!(scratch[0], 0b1100_0000 | (0x80 >> 6) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "    assert_eq!(scratch.len(), 2);",
                "    assert_eq!(scratch[0], 0b1100_0000 | (0x80 >> 6) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x1FF, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "    assert_eq!(scratch.len(), 2);",
                "    assert_eq!(scratch[0], 0b1100_0000 | (0x80 >> 6) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);",
                "    assert_eq!(scratch, vec![0b1100_0000 | (0x80 >> 6) as u8, 0b1000_0000 | (0x80 & 0b0011_1111) as u8]);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x1FF, &mut scratch);",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "    assert_eq!(scratch.len(), 2);",
                "    assert_eq!(scratch[0], 0b1100_0000 | (0x80 >> 6) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);",
                "    assert_eq!(scratch, vec![0b1100_0000 | (0x80 >> 6) as u8, 0b1000_0000 | (0x80 & 0b0011_1111) as u8]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 2);",
                "    assert_eq!(scratch[0], 0b1100_0011);",
                "    assert_eq!(scratch[1], 0b1000_0001);",
                "    assert_eq!(scratch.capacity(), 4);",
                "    assert!(scratch[0] & 0b1100_0000 == 0b1100_0000);",
                "    assert!(scratch[1] & 0b1000_0000 == 0b1000_0000);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "    assert_eq!(scratch.len(), 2);",
                "    assert_eq!(scratch[0], 0b1100_0011);",
                "    assert_eq!(scratch[1], 0b1000_0001);",
                "    assert_eq!(scratch.capacity(), 4);",
                "    assert!(scratch[0] & 0b1100_0000 == 0b1100_0000);",
                "    assert!(scratch[1] & 0b1000_0000 == 0b1000_0000);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 38,
      "prompt_conds": [
        "precondition: n < 0x80 at line 979 is false, with bound n == 0x80\n",
        "precondition: n matches 0..=0x7F at line 995 is false\n",
        "precondition: n matches 0x80..=0x7FF at line 996 is false\n",
        "precondition: n matches 0x800..=0xFFFF at line 1000 is true\n",
        "precondition: n matches 0x800..=0xFFFF at line 1000 is true\n",
        "precondition: n matches 0x800..=0xFFFF at line 994 is true\n"
      ],
      "input_infer": "n must be in the range 0x800 to 0xFFFF, and scratch must be a mutable Vec<u8> with at least 4 bytes reserved.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFFF >> 12) & 0b0000_1111) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFFF >> 6) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[2], 0b1000_0000 | (0xFFFF & 0b0011_1111) as u8);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFFF >> 12) & 0b0000_1111) as u8);",
                "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFFF >> 6) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[2], 0b1000_0000 | (0xFFFF & 0b0011_1111) as u8);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xCFFF, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xCFFF, &mut scratch);",
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0011);",
                "    assert_eq!(scratch[1], 0b1000_1111);",
                "    assert_eq!(scratch[2], 0b1000_1111);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xCFFF, &mut scratch);",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xCFFF, &mut scratch);",
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0011);",
                "    assert_eq!(scratch[1], 0b1000_1111);",
                "    assert_eq!(scratch[2], 0b1000_1111);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xD800, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xD800, &mut scratch);",
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0010);",
                "    assert_eq!(scratch[1], 0b1000_0000 | ((0xD800 >> 12) & 0b0011_1111));",
                "    assert_eq!(scratch[2], 0b1000_0000 | ((0xD800 >> 6) & 0b0011_1111));",
                "    assert_eq!(scratch[3], 0b1000_0000 | (0xD800 & 0b0011_1111));"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xD800, &mut scratch);",
                "    let mut scratch = Vec::with_capacity(4);",
                "    push_wtf8_codepoint(0xD800, &mut scratch);",
                "    assert_eq!(scratch.len(), 3);",
                "    assert_eq!(scratch[0], 0b1110_0010);",
                "    assert_eq!(scratch[1], 0b1000_0000 | ((0xD800 >> 12) & 0b0011_1111));",
                "    assert_eq!(scratch[2], 0b1000_0000 | ((0xD800 >> 6) & 0b0011_1111));",
                "    assert_eq!(scratch[3], 0b1000_0000 | (0xD800 & 0b0011_1111));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 44,
      "prompt_conds": [
        "precondition: n < 0x80 at line 979 is false, with bound n == 0x80\n",
        "precondition: n matches 0..=0x7F at line 995 is false\n",
        "precondition: n matches 0x80..=0x7FF at line 996 is false\n",
        "precondition: n matches 0x800..=0xFFFF at line 1000 is false\n",
        "precondition: n matches 0x1_0000..=0x10_FFFF at line 1006 is true\n",
        "precondition: n matches 0x1_0000..=0x10_FFFF at line 1006 is true\n",
        "precondition: n matches 0x1_0000..=0x10_FFFF at line 994 is true\n"
      ],
      "input_infer": "n = 0x10000 to n = 0x10FFFF, with specified scratch capacity.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x10000; // The first valid codepoint in the range",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0xF0);",
                "    assert_eq!(scratch[1], 0x90);",
                "    assert_eq!(scratch[2], 0x80);",
                "    assert_eq!(scratch[3], 0x80);",
                "    assert!(scratch.capacity() >= 4);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x10000; // The first valid codepoint in the range",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0xF0);",
                "    assert_eq!(scratch[1], 0x90);",
                "    assert_eq!(scratch[2], 0x80);",
                "    assert_eq!(scratch[3], 0x80);",
                "    assert!(scratch.capacity() >= 4);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x20000; // A codepoint in the middle of the range",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x20000;",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0b11110000 | ((n >> 18) & 0b00000111) as u8);",
                "    assert_eq!(scratch[1], 0b10000000 | ((n >> 12) & 0b00111111) as u8);",
                "    assert_eq!(scratch[2], 0b10000000 | ((n >> 6) & 0b00111111) as u8);",
                "    assert_eq!(scratch[3], 0b10000000 | (n & 0b00111111) as u8);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x20000; // A codepoint in the middle of the range",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x20000;",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0b11110000 | ((n >> 18) & 0b00000111) as u8);",
                "    assert_eq!(scratch[1], 0b10000000 | ((n >> 12) & 0b00111111) as u8);",
                "    assert_eq!(scratch[2], 0b10000000 | ((n >> 6) & 0b00111111) as u8);",
                "    assert_eq!(scratch[3], 0b10000000 | (n & 0b00111111) as u8);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x10FFFF; // The last valid codepoint in the range",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0b11110000 | ((n >> 18) & 0b0000_0111) as u8);",
                "    assert_eq!(scratch[1], 0b10000000 | ((n >> 12) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[2], 0b10000000 | ((n >> 6) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[3], 0b10000000 | (n & 0b0011_1111) as u8);"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x10FFFF; // The last valid codepoint in the range",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0b11110000 | ((n >> 18) & 0b0000_0111) as u8);",
                "    assert_eq!(scratch[1], 0b10000000 | ((n >> 12) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[2], 0b10000000 | ((n >> 6) & 0b0011_1111) as u8);",
                "    assert_eq!(scratch[3], 0b10000000 | (n & 0b0011_1111) as u8);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 47,
      "prompt_conds": [
        "precondition: n < 0x80 at line 979 is false, with bound n == 0x80\n",
        "precondition: n matches 0..=0x7F at line 995 is false\n",
        "precondition: n matches 0x80..=0x7FF at line 996 is false\n",
        "precondition: n matches 0x800..=0xFFFF at line 1000 is false\n",
        "precondition: n matches 0x1_0000..=0x10_FFFF at line 1006 is false\n",
        "precondition: n matches 0x11_0000.. at line 1014 is true\n"
      ],
      "input_infer": "n = 0x11_0000 to 0x10_FFFFFF (inclusive)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x11_0000; // Minimum value that matches the precondition for unsuccessful encoding.",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10000000",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10000000",
                "    scratch.len() == 4",
                "    scratch[0..4] == [0b11110000, 0b10000000, 0b10000000, 0b10000000]"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x11_0000; // Minimum value that matches the precondition for unsuccessful encoding.",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10000000",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10000000",
                "    scratch.len() == 4",
                "    scratch[0..4] == [0b11110000, 0b10000000, 0b10000000, 0b10000000]",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x10_FFFFFF; // Maximum value that matches the precondition for unsuccessful encoding.",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b1111_0000",
                "    scratch[1] == 0b1000_0000",
                "    scratch[2] == 0b1000_0000",
                "    scratch[3] == 0b1000_0000",
                "    scratch.len() == 4"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x10_FFFFFF; // Maximum value that matches the precondition for unsuccessful encoding.",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b1111_0000",
                "    scratch[1] == 0b1000_0000",
                "    scratch[2] == 0b1000_0000",
                "    scratch[3] == 0b1000_0000",
                "    scratch.len() == 4",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x20_0000; // A value just above 0x10_FFFF to ensure encoding is still not valid.",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 0);  // Expecting no bytes in scratch since input is out of valid range",
                "    assert!(scratch.is_empty());     // The scratch buffer should still be empty after the call",
                "    assert!(matches!(std::panic::catch_unwind(|| push_wtf8_codepoint(0x11_0000, &mut scratch)), Err(_))); // Should panic for n >= 0x11_0000"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    let n: u32 = 0x20_0000; // A value just above 0x10_FFFF to ensure encoding is still not valid.",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "    assert_eq!(scratch.len(), 0);  // Expecting no bytes in scratch since input is out of valid range",
                "    assert!(scratch.is_empty());     // The scratch buffer should still be empty after the call",
                "    assert!(matches!(std::panic::catch_unwind(|| push_wtf8_codepoint(0x11_0000, &mut scratch)), Err(_))); // Should panic for n >= 0x11_0000",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 48,
      "prompt_conds": [
        "precondition: n < 0x80 at line 979 is false, with bound n == 0x80\n",
        "precondition: n matches 0..=0x7F at line 995 is false\n",
        "precondition: n matches 0x80..=0x7FF at line 996 is false\n",
        "precondition: n matches 0x800..=0xFFFF at line 1000 is false\n",
        "precondition: n matches 0x1_0000..=0x10_FFFF at line 1006 is false\n",
        "precondition: n matches 0x11_0000.. at line 1014 is false\n"
      ],
      "input_infer": "n values in the range [0x80, 0x10FFFF] excluding 0x110000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0000",
                "    scratch[1] == 0b1000_0000",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10000, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x110000, &mut scratch);",
                "    }"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0000",
                "    scratch[1] == 0b1000_0000",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10000, &mut scratch);",
                "    }",
                "    ",
                "    #[test]",
                "    fn test() {",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x110000, &mut scratch);",
                "    }",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0000 | ((0x7FF >> 6) & 0b0001_1111) as u8",
                "    scratch[1] == 0b1000_0000 | (0x7FF & 0b0011_1111) as u8"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "    scratch.len() == 2",
                "    scratch[0] == 0b1100_0000 | ((0x7FF >> 6) & 0b0001_1111) as u8",
                "    scratch[1] == 0b1000_0000 | (0x7FF & 0b0011_1111) as u8",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b1110_0000",
                "    scratch[1] == 0b1000_0000",
                "    scratch[2] == 0b1000_0000",
                "    scratch.len() == 3"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b1110_0000",
                "    scratch[1] == 0b1000_0000",
                "    scratch[2] == 0b1000_0000",
                "    scratch.len() == 3",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 2",
                "    scratch[0] == 0xEF",
                "    scratch[1] == 0xBF",
                "    scratch[2] == 0xBF",
                "    scratch.len() == 3",
                "    scratch[0] == 0xE0",
                "    scratch[1] == 0x9F",
                "    scratch[2] == 0xBF",
                "    scratch.len() == 4",
                "    scratch[0] == 0xF4",
                "    scratch[1] == 0x8F",
                "    scratch[2] == 0xBF",
                "    scratch[3] == 0xBF"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "    scratch.len() == 2",
                "    scratch[0] == 0xEF",
                "    scratch[1] == 0xBF",
                "    scratch[2] == 0xBF",
                "    scratch.len() == 3",
                "    scratch[0] == 0xE0",
                "    scratch[1] == 0x9F",
                "    scratch[2] == 0xBF",
                "    scratch.len() == 4",
                "    scratch[0] == 0xF4",
                "    scratch[1] == 0x8F",
                "    scratch[2] == 0xBF",
                "    scratch[3] == 0xBF",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10000, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0xF0 | ((0x10000 >> 18) & 0b0000_0111));",
                "    assert_eq!(scratch[1], 0x80 | ((0x10000 >> 12) & 0b0011_1111));",
                "    assert_eq!(scratch[2], 0x80 | ((0x10000 >> 6) & 0b0011_1111));",
                "    assert_eq!(scratch[3], 0x80 | (0x10000 & 0b0011_1111));"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10000, &mut scratch);",
                "    assert_eq!(scratch.len(), 4);",
                "    assert_eq!(scratch[0], 0xF0 | ((0x10000 >> 18) & 0b0000_0111));",
                "    assert_eq!(scratch[1], 0x80 | ((0x10000 >> 12) & 0b0011_1111));",
                "    assert_eq!(scratch[2], 0x80 | ((0x10000 >> 6) & 0b0011_1111));",
                "    assert_eq!(scratch[3], 0x80 | (0x10000 & 0b0011_1111));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10011111",
                "    scratch[2] == 0b10011000",
                "    scratch[3] == 0b10000000",
                "    scratch.len() == 4"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                "    scratch.len() == 0",
                "    scratch.capacity() >= 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10011111",
                "    scratch[2] == 0b10011000",
                "    scratch[3] == 0b10000000",
                "    scratch.len() == 4",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x110000, &mut scratch);",
                "}"
              ],
              "oracle": [
                "    scratch.len() == 0",
                "    scratch.is_empty() == true",
                "    scratch.capacity() >= 4",
                "    scratch.push(0x80 as u8) == false",
                "    scratch.push(0xC0) == true",
                "    scratch.push(0x80) == true",
                "    scratch.len() == 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10000000",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10000000",
                "    Error occurs due to invalid codepoint 0x110000",
                "    result.is_err() == true"
              ],
              "code": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x110000, &mut scratch);",
                "    scratch.len() == 0",
                "    scratch.is_empty() == true",
                "    scratch.capacity() >= 4",
                "    scratch.push(0x80 as u8) == false",
                "    scratch.push(0xC0) == true",
                "    scratch.push(0x80) == true",
                "    scratch.len() == 4",
                "    scratch[0] == 0b11110000",
                "    scratch[1] == 0b10000000",
                "    scratch[2] == 0b10000000",
                "    scratch[3] == 0b10000000",
                "    Error occurs due to invalid codepoint 0x110000",
                "    result.is_err() == true",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}