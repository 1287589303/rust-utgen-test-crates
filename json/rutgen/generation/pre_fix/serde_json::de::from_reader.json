{
  "name": "serde_json::de::from_reader",
  "mod_info": {
    "name": "de",
    "loc": "src/lib.rs:418:1:418:12"
  },
  "visible": true,
  "loc": "src/de.rs:2612:1:2618:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid JSON input stream from a buffer producing at least one complete, correctly formatted instance of type T, error cases with malformed JSON or types not matching T, including empty input and inputs exceeding size or structural limits acceptable for type T.\n",
      "answers": [
        {
          "uses": [
            "use serde::Deserialize;",
            "use std::io::Cursor;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "    ",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "    ",
                "    let data = r#\"{\"fingerprint\": \"abc123\", \"location\": \"Earth\"}\"#;",
                "    let reader = Cursor::new(data);",
                "    let user: User = serde_json::from_reader(reader).unwrap();",
                "}"
              ],
              "oracle": [
                "    let reader = Cursor::new(r#\"{\"fingerprint\": \"abc123\", \"location\": \"Earth\"}\"#);",
                "    let user: User = serde_json::from_reader(reader).unwrap();",
                "    assert_eq!(user.fingerprint, \"abc123\");",
                "    assert_eq!(user.location, \"Earth\");"
              ],
              "code": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "    ",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "    ",
                "    let data = r#\"{\"fingerprint\": \"abc123\", \"location\": \"Earth\"}\"#;",
                "    let reader = Cursor::new(data);",
                "    let user: User = serde_json::from_reader(reader).unwrap();",
                "    let reader = Cursor::new(r#\"{\"fingerprint\": \"abc123\", \"location\": \"Earth\"}\"#);",
                "    let user: User = serde_json::from_reader(reader).unwrap();",
                "    assert_eq!(user.fingerprint, \"abc123\");",
                "    assert_eq!(user.location, \"Earth\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "    ",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "    ",
                "    let data = r#\"\"#;",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::InvalidData);",
                "    ",
                "    let data = r#\"{\"fingerprint\": \"abc123\", \"location\": \"test_location\"}\"#;",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_ok());",
                "    let user = result.unwrap();",
                "    assert_eq!(user.fingerprint, \"abc123\");",
                "    assert_eq!(user.location, \"test_location\");",
                "    ",
                "    let incomplete_data = r#\"{\"fingerprint\": \"abc123\"\"#;",
                "    let reader = Cursor::new(incomplete_data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::Io);",
                "    ",
                "    let malformed_data = r#\"{fingerprint: \"abc123\", location: \"test_location\"}\"#;",
                "    let reader = Cursor::new(malformed_data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::Syntax);",
                "    ",
                "    let empty_data = r#\"\"#;",
                "    let reader = Cursor::new(empty_data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::InvalidData);"
              ],
              "code": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "    ",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "    ",
                "    let data = r#\"\"#;",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::InvalidData);",
                "    ",
                "    let data = r#\"{\"fingerprint\": \"abc123\", \"location\": \"test_location\"}\"#;",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_ok());",
                "    let user = result.unwrap();",
                "    assert_eq!(user.fingerprint, \"abc123\");",
                "    assert_eq!(user.location, \"test_location\");",
                "    ",
                "    let incomplete_data = r#\"{\"fingerprint\": \"abc123\"\"#;",
                "    let reader = Cursor::new(incomplete_data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::Io);",
                "    ",
                "    let malformed_data = r#\"{fingerprint: \"abc123\", location: \"test_location\"}\"#;",
                "    let reader = Cursor::new(malformed_data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::Syntax);",
                "    ",
                "    let empty_data = r#\"\"#;",
                "    let reader = Cursor::new(empty_data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().code(), ErrorCode::InvalidData);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "",
                "    let data = r#\"{\"fingerprint\": \"abc123\", \"location\": \"Earth\"\"#; // Missing closing brace",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().classify(), ErrorCode::InvalidData);",
                "    assert_eq!(result.unwrap_err().to_string(), \"EOF while parsing a string at line 1 column 41\");"
              ],
              "code": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "",
                "    let data = r#\"{\"fingerprint\": \"abc123\", \"location\": \"Earth\"\"#; // Missing closing brace",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().classify(), ErrorCode::InvalidData);",
                "    assert_eq!(result.unwrap_err().to_string(), \"EOF while parsing a string at line 1 column 41\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "",
                "    let data = r#\"[{\"fingerprint\": \"abc123\", \"location\": \"Earth\"}]\"#; // Expected object, got array",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().classify(), ErrorCode::Unexpected);",
                "    assert_eq!(result.unwrap_err().to_string(), \"expected a JSON object, but found an array\");"
              ],
              "code": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct User {",
                "        fingerprint: String,",
                "        location: String,",
                "    }",
                "",
                "    let data = r#\"[{\"fingerprint\": \"abc123\", \"location\": \"Earth\"}]\"#; // Expected object, got array",
                "    let reader = Cursor::new(data);",
                "    let result: Result<User, _> = serde_json::from_reader(reader);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().classify(), ErrorCode::Unexpected);",
                "    assert_eq!(result.unwrap_err().to_string(), \"expected a JSON object, but found an array\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct LargeUser {",
                "        number: Vec<u8>,",
                "    }",
                "",
                "    let data = r#\"{\"number\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]}\"#;",
                "    let reader = Cursor::new(data);",
                "    let large_user: LargeUser = serde_json::from_reader(reader).unwrap();",
                "}"
              ],
              "oracle": [
                "    let data = r#\"{\"number\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]}\"#;",
                "    let reader = Cursor::new(data);",
                "    let large_user: LargeUser = serde_json::from_reader(reader).unwrap();",
                "    assert_eq!(large_user.number, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);",
                "    let invalid_data = r#\"{\"number\": \"not an array\"}\"#;",
                "    let invalid_reader = Cursor::new(invalid_data);",
                "    let result: Result<LargeUser> = serde_json::from_reader(invalid_reader);",
                "    assert!(result.is_err());",
                "    let empty_data = r#\"{}\"#;",
                "    let empty_reader = Cursor::new(empty_data);",
                "    let empty_result: Result<LargeUser> = serde_json::from_reader(empty_reader);",
                "    assert!(empty_result.is_err());",
                "    let large_array_data = r#\"{\"number\": [0, 1, 2, ..., 255]}\"#;",
                "    let large_array_reader = Cursor::new(large_array_data);",
                "    let large_array_user: LargeUser = serde_json::from_reader(large_array_reader).unwrap();",
                "    assert_eq!(large_array_user.number.len(), 256);",
                "    let error_data = r#\"{\"number\": [1, 2, 3, 4, \"five\"]}\"#;",
                "    let error_reader = Cursor::new(error_data);",
                "    let error_result: Result<LargeUser> = serde_json::from_reader(error_reader);",
                "    assert!(error_result.is_err());"
              ],
              "code": [
                "{",
                "    use std::io::Cursor;",
                "    use serde::Deserialize;",
                "",
                "    #[derive(Deserialize, Debug, PartialEq)]",
                "    struct LargeUser {",
                "        number: Vec<u8>,",
                "    }",
                "",
                "    let data = r#\"{\"number\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]}\"#;",
                "    let reader = Cursor::new(data);",
                "    let large_user: LargeUser = serde_json::from_reader(reader).unwrap();",
                "    let data = r#\"{\"number\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]}\"#;",
                "    let reader = Cursor::new(data);",
                "    let large_user: LargeUser = serde_json::from_reader(reader).unwrap();",
                "    assert_eq!(large_user.number, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);",
                "    let invalid_data = r#\"{\"number\": \"not an array\"}\"#;",
                "    let invalid_reader = Cursor::new(invalid_data);",
                "    let result: Result<LargeUser> = serde_json::from_reader(invalid_reader);",
                "    assert!(result.is_err());",
                "    let empty_data = r#\"{}\"#;",
                "    let empty_reader = Cursor::new(empty_data);",
                "    let empty_result: Result<LargeUser> = serde_json::from_reader(empty_reader);",
                "    assert!(empty_result.is_err());",
                "    let large_array_data = r#\"{\"number\": [0, 1, 2, ..., 255]}\"#;",
                "    let large_array_reader = Cursor::new(large_array_data);",
                "    let large_array_user: LargeUser = serde_json::from_reader(large_array_reader).unwrap();",
                "    assert_eq!(large_array_user.number.len(), 256);",
                "    let error_data = r#\"{\"number\": [1, 2, 3, 4, \"five\"]}\"#;",
                "    let error_reader = Cursor::new(error_data);",
                "    let error_result: Result<LargeUser> = serde_json::from_reader(error_reader);",
                "    assert!(error_result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}