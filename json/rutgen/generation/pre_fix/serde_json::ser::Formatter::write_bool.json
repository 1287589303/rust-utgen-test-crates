{
  "name": "serde_json::ser::Formatter::write_bool",
  "mod_info": {
    "name": "ser",
    "loc": "src/lib.rs:423:1:423:13"
  },
  "visible": true,
  "loc": "src/ser.rs:1568:5:1578:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: value at line 1572 is true\n"
      ],
      "input_infer": "value is true or false; writer is a mutable reference to any type implementing io::Write, including edge cases like an empty writer, a writer with a buffer limit, and a writer that returns an error on write operations.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct Buffer {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl io::Write for Buffer {",
                "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
                "            self.data.extend_from_slice(buf);",
                "            Ok(buf.len())",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut buffer = Buffer { data: Vec::new() };",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut buffer, true);",
                "}"
              ],
              "oracle": [
                "    let mut buffer = Buffer { data: Vec::new() };",
                "    let mut formatter = MyFormatter;",
                "    let _ = formatter.write_bool(&mut buffer, true);",
                "    assert_eq!(buffer.data, b\"true\");"
              ],
              "code": [
                "{",
                "    struct Buffer {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl io::Write for Buffer {",
                "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
                "            self.data.extend_from_slice(buf);",
                "            Ok(buf.len())",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut buffer = Buffer { data: Vec::new() };",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut buffer, true);",
                "    let mut buffer = Buffer { data: Vec::new() };",
                "    let mut formatter = MyFormatter;",
                "    let _ = formatter.write_bool(&mut buffer, true);",
                "    assert_eq!(buffer.data, b\"true\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct Buffer {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl io::Write for Buffer {",
                "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
                "            self.data.extend_from_slice(buf);",
                "            Ok(buf.len())",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut buffer = Buffer { data: Vec::new() };",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut buffer, false);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(buffer.data, b\"false\");",
                "    assert!(buffer.data.contains(&b'f'));",
                "    assert!(buffer.data.contains(&b'a'));",
                "    assert!(buffer.data.contains(&b'l'));",
                "    assert!(buffer.data.contains(&b's'));",
                "    assert!(buffer.data.contains(&b'e'));"
              ],
              "code": [
                "{",
                "    struct Buffer {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl io::Write for Buffer {",
                "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
                "            self.data.extend_from_slice(buf);",
                "            Ok(buf.len())",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut buffer = Buffer { data: Vec::new() };",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut buffer, false);",
                "    assert_eq!(buffer.data, b\"false\");",
                "    assert!(buffer.data.contains(&b'f'));",
                "    assert!(buffer.data.contains(&b'a'));",
                "    assert!(buffer.data.contains(&b'l'));",
                "    assert!(buffer.data.contains(&b's'));",
                "    assert!(buffer.data.contains(&b'e'));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct EmptyWriter;",
                "",
                "    impl io::Write for EmptyWriter {",
                "        fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {",
                "            Ok(0)",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut empty_writer = EmptyWriter;",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut empty_writer, true);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(empty_writer.write_all(b\"true\").unwrap(), 0);",
                "    assert_eq!(formatter.write_bool(&mut empty_writer, true).is_ok(), true);"
              ],
              "code": [
                "{",
                "    struct EmptyWriter;",
                "",
                "    impl io::Write for EmptyWriter {",
                "        fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {",
                "            Ok(0)",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut empty_writer = EmptyWriter;",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut empty_writer, true);",
                "    assert_eq!(empty_writer.write_all(b\"true\").unwrap(), 0);",
                "    assert_eq!(formatter.write_bool(&mut empty_writer, true).is_ok(), true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct ErrorWriter;",
                "",
                "    impl io::Write for ErrorWriter {",
                "        fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {",
                "            Err(io::Error::new(io::ErrorKind::Other, \"write error\"))",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut error_writer = ErrorWriter;",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut error_writer, true);",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(formatter.write_bool(&mut error_writer, true), Err(_)));"
              ],
              "code": [
                "{",
                "    struct ErrorWriter;",
                "",
                "    impl io::Write for ErrorWriter {",
                "        fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {",
                "            Err(io::Error::new(io::ErrorKind::Other, \"write error\"))",
                "        }",
                "        ",
                "        fn flush(&mut self) -> io::Result<()> {",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut error_writer = ErrorWriter;",
                "    let mut formatter = MyFormatter; // Assuming MyFormatter implements Formatter",
                "    let _ = formatter.write_bool(&mut error_writer, true);",
                "    assert!(matches!(formatter.write_bool(&mut error_writer, true), Err(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: value at line 1572 is false\n"
      ],
      "input_infer": "value = false, writer = valid writable stream (e.g., a File, Buffer)\n",
      "answers": [
        {
          "uses": [
            "use std::io::Cursor;"
          ],
          "has_test_mod": false,
          "common": [
            "struct TestFormatter;",
            "",
            "impl Formatter for TestFormatter {",
            "    // Implementations of Formatter methods can be empty for testing.",
            "    fn write_null<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_i8<W>(&mut self, _writer: &mut W, _value: i8) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_i16<W>(&mut self, _writer: &mut W, _value: i16) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_i32<W>(&mut self, _writer: &mut W, _value: i32) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_i64<W>(&mut self, _writer: &mut W, _value: i64) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_i128<W>(&mut self, _writer: &mut W, _value: i128) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_u8<W>(&mut self, _writer: &mut W, _value: u8) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_u16<W>(&mut self, _writer: &mut W, _value: u16) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_u32<W>(&mut self, _writer: &mut W, _value: u32) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_u64<W>(&mut self, _writer: &mut W, _value: u64) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_u128<W>(&mut self, _writer: &mut W, _value: u128) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_f32<W>(&mut self, _writer: &mut W, _value: f32) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_f64<W>(&mut self, _writer: &mut W, _value: f64) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_number_str<W>(&mut self, _writer: &mut W, _value: &str) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn begin_string<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn end_string<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_string_fragment<W>(&mut self, _writer: &mut W, _fragment: &str) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_char_escape<W>(&mut self, _writer: &mut W, _char_escape: CharEscape) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_byte_array<W>(&mut self, _writer: &mut W, _value: &[u8]) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn begin_array<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn end_array<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn begin_array_value<W>(&mut self, _writer: &mut W, _first: bool) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn begin_object<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn end_object<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn begin_object_key<W>(&mut self, _writer: &mut W, _first: bool) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn end_object_key<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn begin_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "",
            "    fn write_raw_fragment<W>(&mut self, _writer: &mut W, _fragment: &str) -> io::Result<()>",
            "    where W: ?Sized + io::Write { Ok(()) }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buffer = vec![];",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut buffer, false);",
                "}"
              ],
              "oracle": [
                "    let mut buffer = vec![];",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut buffer, false);",
                "    assert_eq!(buffer, b\"false\");",
                "    buffer.clear();",
                "    let _ = formatter.write_bool(&mut buffer, true);",
                "    assert_eq!(buffer, b\"true\");",
                "    buffer.clear();"
              ],
              "code": [
                "{",
                "    let mut buffer = vec![];",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut buffer, false);",
                "    let mut buffer = vec![];",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut buffer, false);",
                "    assert_eq!(buffer, b\"false\");",
                "    buffer.clear();",
                "    let _ = formatter.write_bool(&mut buffer, true);",
                "    assert_eq!(buffer, b\"true\");",
                "    buffer.clear();",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::io::Cursor;",
                "",
                "    let mut cursor = Cursor::new(vec![]);",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut cursor, false);",
                "}"
              ],
              "oracle": [
                "    let mut cursor = Cursor::new(vec![]);",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut cursor, false);",
                "    assert_eq!(cursor.get_ref(), &vec![102, 97, 108, 115, 101]);"
              ],
              "code": [
                "{",
                "    use std::io::Cursor;",
                "",
                "    let mut cursor = Cursor::new(vec![]);",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut cursor, false);",
                "    let mut cursor = Cursor::new(vec![]);",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut cursor, false);",
                "    assert_eq!(cursor.get_ref(), &vec![102, 97, 108, 115, 101]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::io::Cursor;",
                "",
                "    let mut string_writer = Cursor::new(String::new());",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut string_writer, false);",
                "}"
              ],
              "oracle": [
                "    let mut string_writer = Cursor::new(String::new());",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut string_writer, false);",
                "    assert_eq!(string_writer.get_ref().as_str(), \"false\");"
              ],
              "code": [
                "{",
                "    use std::io::Cursor;",
                "",
                "    let mut string_writer = Cursor::new(String::new());",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut string_writer, false);",
                "    let mut string_writer = Cursor::new(String::new());",
                "    let mut formatter = TestFormatter {};",
                "    let _ = formatter.write_bool(&mut string_writer, false);",
                "    assert_eq!(string_writer.get_ref().as_str(), \"false\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}