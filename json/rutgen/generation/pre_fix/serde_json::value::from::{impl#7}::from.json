{
  "name": "serde_json::value::from::{impl#7}::from",
  "mod_info": {
    "name": "value::from",
    "loc": "src/value/mod.rs:928:1:928:10"
  },
  "visible": true,
  "loc": "src/value/from.rs:165:5:167:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Value::Object(f)\n"
      ],
      "input_infer": "Map with string keys containing zero to n elements of type (String, Value) where Value can be any of Null, Bool, Number, String, Array, or Object.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut m: Map<String, Value> = Map::new();",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(Map::new()));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key1\".to_owned(), Value::Bool(true));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key2\".to_owned(), Value::Number(Number { n: 10 }));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key3\".to_owned(), Value::String(\"test\".to_owned()));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key4\".to_owned(), Value::Array(vec![Value::String(\"item\".to_owned())]));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key5\".to_owned(), Value::Null);",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));"
              ],
              "code": [
                "{",
                "    let mut m: Map<String, Value> = Map::new();",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(Map::new()));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key1\".to_owned(), Value::Bool(true));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key2\".to_owned(), Value::Number(Number { n: 10 }));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key3\".to_owned(), Value::String(\"test\".to_owned()));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key4\".to_owned(), Value::Array(vec![Value::String(\"item\".to_owned())]));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    let mut m: Map<String, Value> = Map::new();",
                "    m.insert(\"Key5\".to_owned(), Value::Null);",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_null\".to_owned(), Value::Null);",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(m));"
              ],
              "code": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_null\".to_owned(), Value::Null);",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_bool\".to_owned(), Value::Bool(true));",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(m));"
              ],
              "code": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_bool\".to_owned(), Value::Bool(true));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_number\".to_owned(), Value::Number(Number { n: 5.into() }));",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(m));",
                "    assert!(matches!(x, Value::Object(_)));",
                "    assert!(x.is_object());",
                "    assert_eq!(m.get(\"key_number\"), Some(&Value::Number(Number { n: 5.into() })));",
                "    assert!(x.as_object().unwrap().contains_key(\"key_number\"));"
              ],
              "code": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_number\".to_owned(), Value::Number(Number { n: 5.into() }));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    assert!(matches!(x, Value::Object(_)));",
                "    assert!(x.is_object());",
                "    assert_eq!(m.get(\"key_number\"), Some(&Value::Number(Number { n: 5.into() })));",
                "    assert!(x.as_object().unwrap().contains_key(\"key_number\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_string\".to_owned(), Value::String(\"a string\".to_owned()));",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(m));"
              ],
              "code": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_string\".to_owned(), Value::String(\"a string\".to_owned()));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_array\".to_owned(), Value::Array(vec![Value::String(\"element\".to_owned())]));",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(m));"
              ],
              "code": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key_array\".to_owned(), Value::Array(vec![Value::String(\"element\".to_owned())]));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key1\".to_owned(), Value::Bool(false));",
                "    m.insert(\"key2\".to_owned(), Value::Number(Number { n: 3.14.into() }));",
                "    m.insert(\"key3\".to_owned(), Value::String(\"value\".to_owned()));",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(m));",
                "    assert!(matches!(x, Value::Object(_)));",
                "    assert_eq!(m.get(\"key1\"), Some(&Value::Bool(false)));",
                "    assert_eq!(m.get(\"key2\"), Some(&Value::Number(Number { n: 3.14.into() })));",
                "    assert_eq!(m.get(\"key3\"), Some(&Value::String(\"value\".to_owned())));",
                "    assert!(matches!(x, Value::Object(obj) if obj.len() == 3));",
                "    assert!(x.is_object());"
              ],
              "code": [
                "{",
                "    let mut m = Map::new();",
                "    m.insert(\"key1\".to_owned(), Value::Bool(false));",
                "    m.insert(\"key2\".to_owned(), Value::Number(Number { n: 3.14.into() }));",
                "    m.insert(\"key3\".to_owned(), Value::String(\"value\".to_owned()));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    assert!(matches!(x, Value::Object(_)));",
                "    assert_eq!(m.get(\"key1\"), Some(&Value::Bool(false)));",
                "    assert_eq!(m.get(\"key2\"), Some(&Value::Number(Number { n: 3.14.into() })));",
                "    assert_eq!(m.get(\"key3\"), Some(&Value::String(\"value\".to_owned())));",
                "    assert!(matches!(x, Value::Object(obj) if obj.len() == 3));",
                "    assert!(x.is_object());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut inner_m = Map::new();",
                "    inner_m.insert(\"inner_key\".to_owned(), Value::Number(Number { n: 10.into() }));",
                "",
                "    let mut m = Map::new();",
                "    m.insert(\"outer_key\".to_owned(), Value::Object(inner_m));",
                "    let x: Value = m.into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(x, Value::Object(m));",
                "    assert!(matches!(x, Value::Object(_)));",
                "    assert_eq!(if let Value::Object(ref obj) = x { obj.keys().len() } else { 0 }, 1);",
                "    assert_eq!(if let Value::Object(ref obj) = x { obj.get(\"outer_key\") } else { None }, Some(&Value::Object(inner_m)));",
                "    assert!(matches!(if let Value::Object(ref obj) = x { obj.get(\"outer_key\") } else { None }, Some(Value::Object(_))));"
              ],
              "code": [
                "{",
                "    let mut inner_m = Map::new();",
                "    inner_m.insert(\"inner_key\".to_owned(), Value::Number(Number { n: 10.into() }));",
                "",
                "    let mut m = Map::new();",
                "    m.insert(\"outer_key\".to_owned(), Value::Object(inner_m));",
                "    let x: Value = m.into();",
                "    assert_eq!(x, Value::Object(m));",
                "    assert!(matches!(x, Value::Object(_)));",
                "    assert_eq!(if let Value::Object(ref obj) = x { obj.keys().len() } else { 0 }, 1);",
                "    assert_eq!(if let Value::Object(ref obj) = x { obj.get(\"outer_key\") } else { None }, Some(&Value::Object(inner_m)));",
                "    assert!(matches!(if let Value::Object(ref obj) = x { obj.get(\"outer_key\") } else { None }, Some(Value::Object(_))));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}