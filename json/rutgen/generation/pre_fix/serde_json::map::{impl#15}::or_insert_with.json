{
  "name": "serde_json::map::{impl#15}::or_insert_with",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:420:1:420:13"
  },
  "visible": true,
  "loc": "src/map.rs:700:5:708:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches Entry::Occupied(entry) at line 704 is true\n",
        "expected return value/type: match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n"
      ],
      "input_infer": "self must be an Entry variant that is Occupied, hence a valid test input condition is: Entry::Occupied(OccupiedEntry) with an existing key-value pair where key is a String and value is a Value type (e.g., Value::Bool(true), Value::String(\"test\".to_string()), Value::Number(Number::from(42))).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"test\".to_string(), Value::Bool(true));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"test\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::Bool(false));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map[\"test\"], Value::Bool(true));",
                "    assert_eq!(_ , &mut Value::Bool(true));",
                "    assert!(!map.contains_key(\"new_key\"));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"test\".to_string(), Value::Bool(true));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"test\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::Bool(false));",
                "    assert_eq!(map[\"test\"], Value::Bool(true));",
                "    assert_eq!(_ , &mut Value::Bool(true));",
                "    assert!(!map.contains_key(\"new_key\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key\".to_string(), Value::String(\"initial\".to_string()));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::String(\"new value\".to_string()));",
                "}"
              ],
              "oracle": [
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key\".to_string(), Value::String(\"initial\".to_string()));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key\").unwrap() });",
                "    let result = entry.or_insert_with(|| Value::String(\"new value\".to_string()));",
                "    assert_eq!(result, &Value::String(\"initial\".to_string()));",
                "    assert_eq!(map.get(\"key\").unwrap(), &Value::String(\"initial\".to_string()));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key\".to_string(), Value::String(\"initial\".to_string()));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::String(\"new value\".to_string()));",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key\".to_string(), Value::String(\"initial\".to_string()));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key\").unwrap() });",
                "    let result = entry.or_insert_with(|| Value::String(\"new value\".to_string()));",
                "    assert_eq!(result, &Value::String(\"initial\".to_string()));",
                "    assert_eq!(map.get(\"key\").unwrap(), &Value::String(\"initial\".to_string()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"number\".to_string(), Value::Number(Number::from(100)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"number\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::Number(Number::from(200)));",
                "}"
              ],
              "oracle": [
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"number\".to_string(), Value::Number(Number::from(100)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"number\").unwrap() });",
                "    let result = entry.or_insert_with(|| Value::Number(Number::from(200)));",
                "    assert_eq!(result, &mut Value::Number(Number::from(100)));",
                "    assert_eq!(map[\"number\"], Value::Number(Number::from(100)));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"number\".to_string(), Value::Number(Number::from(100)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"number\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::Number(Number::from(200)));",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"number\".to_string(), Value::Number(Number::from(100)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"number\").unwrap() });",
                "    let result = entry.or_insert_with(|| Value::Number(Number::from(200)));",
                "    assert_eq!(result, &mut Value::Number(Number::from(100)));",
                "    assert_eq!(map[\"number\"], Value::Number(Number::from(100)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"null_key\".to_string(), Value::Null);",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"null_key\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::String(\"should not replace\".to_string()));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry.get(), &Value::Null);",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.get(\"null_key\"), Some(&Value::Null));",
                "    assert!(matches!(entry, Entry::Occupied(_)));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"null_key\".to_string(), Value::Null);",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"null_key\").unwrap() });",
                "    let _ = entry.or_insert_with(|| Value::String(\"should not replace\".to_string()));",
                "    assert_eq!(entry.get(), &Value::Null);",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.get(\"null_key\"), Some(&Value::Null));",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches Entry::Vacant(entry) at line 704 is true\n",
        "precondition: self matches Entry::Vacant(entry) at line 704 is true\n",
        "expected return value/type: match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n"
      ],
      "input_infer": "self should match Entry::Vacant with a valid string key, default should be a closure returning a Value type (e.g., json!(null), json!(true), json!(42), json!(\"a string\"), json!([]), json!({}));\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key1\".to_string()) });",
                "    entry.or_insert_with(|| Value::Null);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map[\"key1\"], Value::Null);",
                "    assert!(map.contains_key(\"key1\"));",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(matches!(entry.or_insert_with(|| Value::Null), &mut Value::Null));",
                "    assert_eq!(entry.key(), &\"key1\".to_string());"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key1\".to_string()) });",
                "    entry.or_insert_with(|| Value::Null);",
                "    assert_eq!(map[\"key1\"], Value::Null);",
                "    assert!(map.contains_key(\"key1\"));",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(matches!(entry.or_insert_with(|| Value::Null), &mut Value::Null));",
                "    assert_eq!(entry.key(), &\"key1\".to_string());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key2\".to_string()) });",
                "    entry.or_insert_with(|| Value::Bool(true));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry.key(), \"key2\");",
                "    assert_eq!(map[\"key2\"], Value::Bool(true));",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(map.contains_key(\"key2\"));",
                "    assert_eq!(map.len(), 1);"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key2\".to_string()) });",
                "    entry.or_insert_with(|| Value::Bool(true));",
                "    assert_eq!(entry.key(), \"key2\");",
                "    assert_eq!(map[\"key2\"], Value::Bool(true));",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(map.contains_key(\"key2\"));",
                "    assert_eq!(map.len(), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key3\".to_string()) });",
                "    entry.or_insert_with(|| Value::Number(serde_json::Number::from(42)));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry.key(), \"key3\");",
                "    assert_eq!(map.get(\"key3\").unwrap(), &Value::Number(serde_json::Number::from(42)));",
                "    assert!(matches!(entry, Entry::Vacant(_)) == false);",
                "    assert!(map.contains_key(\"key3\"));",
                "    assert_eq!(entry.get_mut(), &mut Value::Number(serde_json::Number::from(42)));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key3\".to_string()) });",
                "    entry.or_insert_with(|| Value::Number(serde_json::Number::from(42)));",
                "    assert_eq!(entry.key(), \"key3\");",
                "    assert_eq!(map.get(\"key3\").unwrap(), &Value::Number(serde_json::Number::from(42)));",
                "    assert!(matches!(entry, Entry::Vacant(_)) == false);",
                "    assert!(map.contains_key(\"key3\"));",
                "    assert_eq!(entry.get_mut(), &mut Value::Number(serde_json::Number::from(42)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key4\".to_string()) });",
                "    entry.or_insert_with(|| Value::String(\"a string\".to_string()));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.get(\"key4\"), Some(&Value::String(\"a string\".to_string())));",
                "    assert!(map.contains_key(\"key4\"));",
                "    assert_eq!(entry.key(), &\"key4\".to_string());",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(matches!(entry.or_insert_with(|| Value::String(\"another string\".to_string())), &mut Value::String(_)));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key4\".to_string()) });",
                "    entry.or_insert_with(|| Value::String(\"a string\".to_string()));",
                "    assert_eq!(map.get(\"key4\"), Some(&Value::String(\"a string\".to_string())));",
                "    assert!(map.contains_key(\"key4\"));",
                "    assert_eq!(entry.key(), &\"key4\".to_string());",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(matches!(entry.or_insert_with(|| Value::String(\"another string\".to_string())), &mut Value::String(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key5\".to_string()) });",
                "    entry.or_insert_with(|| Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())]));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry.key(), \"key5\");",
                "    assert_eq!(entry.or_insert_with(|| Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())])), &mut Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())]));",
                "    assert!(map.contains_key(\"key5\"));",
                "    assert_eq!(map[\"key5\"], Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())]));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key5\".to_string()) });",
                "    entry.or_insert_with(|| Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())]));",
                "    assert_eq!(entry.key(), \"key5\");",
                "    assert_eq!(entry.or_insert_with(|| Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())])), &mut Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())]));",
                "    assert!(map.contains_key(\"key5\"));",
                "    assert_eq!(map[\"key5\"], Value::Array(vec![Value::String(\"item1\".to_string()), Value::String(\"item2\".to_string())]));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key6\".to_string()) });",
                "    entry.or_insert_with(|| Value::Object(serde_json::Map::new()));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry.key(), \"key6\");",
                "    assert_eq!(entry.or_insert_with(|| Value::Object(serde_json::Map::new())), &mut Value::Object(serde_json::Map::new()));",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert!(map.contains_key(\"key6\"));",
                "    assert!(map.get(\"key6\").unwrap().is_object());",
                "    assert_eq!(map.get(\"key6\").unwrap(), &Value::Object(serde_json::Map::new()));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    let entry = Entry::Vacant(VacantEntry { vacant: map.entry(\"key6\".to_string()) });",
                "    entry.or_insert_with(|| Value::Object(serde_json::Map::new()));",
                "    assert_eq!(entry.key(), \"key6\");",
                "    assert_eq!(entry.or_insert_with(|| Value::Object(serde_json::Map::new())), &mut Value::Object(serde_json::Map::new()));",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert!(map.contains_key(\"key6\"));",
                "    assert!(map.get(\"key6\").unwrap().is_object());",
                "    assert_eq!(map.get(\"key6\").unwrap(), &Value::Object(serde_json::Map::new()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}