{
  "name": "serde_json::map::{impl#15}::and_modify",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:420:1:420:13"
  },
  "visible": true,
  "loc": "src/map.rs:731:5:742:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches Entry::Occupied(mut entry) at line 735 is true\n",
        "precondition: self matches Entry::Occupied(mut entry) at line 735 is true\n",
        "expected return value/type: Entry::Occupied(entry)\n"
      ],
      "input_infer": "self must be of type Entry::Occupied containing any string key and Value type variants such as Bool(true), Number(12), String(\"test\"), or Array(vec![Value::Bool(false)]) while ensuring the map is not empty.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key1\".to_string(), Value::Bool(true));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key1\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::Bool(v) = e {",
                "            *v = false;",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry.get(), &Value::Bool(false));",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert!(map.contains_key(\"key1\"));",
                "    assert_eq!(map[\"key1\"], Value::Bool(false));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key1\".to_string(), Value::Bool(true));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key1\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::Bool(v) = e {",
                "            *v = false;",
                "        }",
                "    });",
                "    assert_eq!(entry.get(), &Value::Bool(false));",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert!(map.contains_key(\"key1\"));",
                "    assert_eq!(map[\"key1\"], Value::Bool(false));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key2\".to_string(), Value::Number(serde_json::Number::from(12)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key2\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::Number(v) = e {",
                "            *v = serde_json::Number::from(20);",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map[\"key2\"], Value::Number(serde_json::Number::from(20)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key2\").unwrap() });",
                "    let original_value = entry.get();",
                "    assert_eq!(original_value, &Value::Number(serde_json::Number::from(20)));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key2\".to_string(), Value::Number(serde_json::Number::from(12)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key2\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::Number(v) = e {",
                "            *v = serde_json::Number::from(20);",
                "        }",
                "    });",
                "    assert_eq!(map[\"key2\"], Value::Number(serde_json::Number::from(20)));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key2\").unwrap() });",
                "    let original_value = entry.get();",
                "    assert_eq!(original_value, &Value::Number(serde_json::Number::from(20)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key3\".to_string(), Value::String(\"test\".to_string()));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key3\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::String(v) = e {",
                "            *v = \"modified\".to_string();",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry.and_modify(|e| *e = Value::String(\"modified\".to_string())), Entry::Occupied(_)));",
                "    assert_eq!(map.get(\"key3\"), Some(&Value::String(\"modified\".to_string())));",
                "    assert_eq!(map.len(), 1);",
                "    assert!(map.contains_key(\"key3\"));",
                "    assert!(matches!(entry, Entry::Occupied(_)));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key3\".to_string(), Value::String(\"test\".to_string()));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key3\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::String(v) = e {",
                "            *v = \"modified\".to_string();",
                "        }",
                "    });",
                "    assert!(matches!(entry.and_modify(|e| *e = Value::String(\"modified\".to_string())), Entry::Occupied(_)));",
                "    assert_eq!(map.get(\"key3\"), Some(&Value::String(\"modified\".to_string())));",
                "    assert_eq!(map.len(), 1);",
                "    assert!(map.contains_key(\"key3\"));",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key4\".to_string(), Value::Array(vec![Value::Bool(false)]));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key4\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::Array(v) = e {",
                "            v.push(Value::Bool(true));",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert_eq!(if let Entry::Occupied(occupied) = entry { occupied.get() } else { &Value::Null }, &Value::Array(vec![Value::Bool(false), Value::Bool(true)]));"
              ],
              "code": [
                "{",
                "    let mut map = serde_json::Map::new();",
                "    map.insert(\"key4\".to_string(), Value::Array(vec![Value::Bool(false)]));",
                "    let entry = Entry::Occupied(OccupiedEntry { occupied: map.get_mut(\"key4\").unwrap() });",
                "    ",
                "    entry.and_modify(|e| {",
                "        if let Value::Array(v) = e {",
                "            v.push(Value::Bool(true));",
                "        }",
                "    });",
                "    assert!(matches!(entry, Entry::Occupied(_)));",
                "    assert_eq!(if let Entry::Occupied(occupied) = entry { occupied.get() } else { &Value::Null }, &Value::Array(vec![Value::Bool(false), Value::Bool(true)]));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches Entry::Vacant(entry) at line 735 is true\n",
        "expected return value/type: Entry::Vacant(entry)\n"
      ],
      "input_infer": "self = Entry::Vacant(entry) with entry being a valid VacantEntry containing a key of type String and a value of type Value equal to either Null, Bool(bool), Number(Number), String(String), Array(Vec<Value>), or Object(Map<String, Value>)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        inner: MapImpl<String, Value>,",
                "    }",
                "",
                "    impl TestMap {",
                "        fn new() -> Self {",
                "            TestMap {",
                "                inner: MapImpl::new(),",
                "            }",
                "        }",
                "",
                "        fn entry(&mut self, key: &str) -> Entry {",
                "            if self.inner.contains_key(key) {",
                "                Entry::Occupied(OccupiedEntry {",
                "                    occupied: self.inner.get_mut(key).unwrap(),",
                "                })",
                "            } else {",
                "                let vacant = VacantEntry {",
                "                    vacant: self.inner.entry(String::from(key)).or_insert(Value::Null),",
                "                };",
                "                Entry::Vacant(vacant)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut map = TestMap::new();",
                "    let entry = map.entry(\"vacant_key\");",
                "",
                "    let _ = entry.and_modify(|e| *e = Value::Bool(true));",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert_eq!(map.inner.get(\"vacant_key\"), Some(&Value::Null));",
                "    assert_eq!(map.inner.len(), 1);",
                "    assert!(map.inner.contains_key(\"vacant_key\"));"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        inner: MapImpl<String, Value>,",
                "    }",
                "",
                "    impl TestMap {",
                "        fn new() -> Self {",
                "            TestMap {",
                "                inner: MapImpl::new(),",
                "            }",
                "        }",
                "",
                "        fn entry(&mut self, key: &str) -> Entry {",
                "            if self.inner.contains_key(key) {",
                "                Entry::Occupied(OccupiedEntry {",
                "                    occupied: self.inner.get_mut(key).unwrap(),",
                "                })",
                "            } else {",
                "                let vacant = VacantEntry {",
                "                    vacant: self.inner.entry(String::from(key)).or_insert(Value::Null),",
                "                };",
                "                Entry::Vacant(vacant)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut map = TestMap::new();",
                "    let entry = map.entry(\"vacant_key\");",
                "",
                "    let _ = entry.and_modify(|e| *e = Value::Bool(true));",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert_eq!(map.inner.get(\"vacant_key\"), Some(&Value::Null));",
                "    assert_eq!(map.inner.len(), 1);",
                "    assert!(map.inner.contains_key(\"vacant_key\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        inner: MapImpl<String, Value>,",
                "    }",
                "",
                "    impl TestMap {",
                "        fn new() -> Self {",
                "            TestMap {",
                "                inner: MapImpl::new(),",
                "            }",
                "        }",
                "",
                "        fn entry(&mut self, key: &str) -> Entry {",
                "            if self.inner.contains_key(key) {",
                "                Entry::Occupied(OccupiedEntry {",
                "                    occupied: self.inner.get_mut(key).unwrap(),",
                "                })",
                "            } else {",
                "                let vacant = VacantEntry {",
                "                    vacant: self.inner.entry(String::from(key)).or_insert(Value::Object(MapImpl::new())),",
                "                };",
                "                Entry::Vacant(vacant)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut map = TestMap::new();",
                "    let entry = map.entry(\"vacant_object_entry\");",
                "",
                "    let _ = entry.and_modify(|e| *e = Value::Object(MapImpl::new()));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry, Entry::Vacant(vacant));",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert_eq!(map.inner.get(\"vacant_object_entry\"), Some(&Value::Object(MapImpl::new())));"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        inner: MapImpl<String, Value>,",
                "    }",
                "",
                "    impl TestMap {",
                "        fn new() -> Self {",
                "            TestMap {",
                "                inner: MapImpl::new(),",
                "            }",
                "        }",
                "",
                "        fn entry(&mut self, key: &str) -> Entry {",
                "            if self.inner.contains_key(key) {",
                "                Entry::Occupied(OccupiedEntry {",
                "                    occupied: self.inner.get_mut(key).unwrap(),",
                "                })",
                "            } else {",
                "                let vacant = VacantEntry {",
                "                    vacant: self.inner.entry(String::from(key)).or_insert(Value::Object(MapImpl::new())),",
                "                };",
                "                Entry::Vacant(vacant)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut map = TestMap::new();",
                "    let entry = map.entry(\"vacant_object_entry\");",
                "",
                "    let _ = entry.and_modify(|e| *e = Value::Object(MapImpl::new()));",
                "    assert_eq!(entry, Entry::Vacant(vacant));",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert_eq!(map.inner.get(\"vacant_object_entry\"), Some(&Value::Object(MapImpl::new())));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        inner: MapImpl<String, Value>,",
                "    }",
                "",
                "    impl TestMap {",
                "        fn new() -> Self {",
                "            TestMap {",
                "                inner: MapImpl::new(),",
                "            }",
                "        }",
                "",
                "        fn entry(&mut self, key: &str) -> Entry {",
                "            if self.inner.contains_key(key) {",
                "                Entry::Occupied(OccupiedEntry {",
                "                    occupied: self.inner.get_mut(key).unwrap(),",
                "                })",
                "            } else {",
                "                let vacant = VacantEntry {",
                "                    vacant: self.inner.entry(String::from(key)).or_insert(Value::Array(vec![])),",
                "                };",
                "                Entry::Vacant(vacant)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut map = TestMap::new();",
                "    let entry = map.entry(\"vacant_array_entry\");",
                "",
                "    let _ = entry.and_modify(|e| *e = Value::Array(vec![Value::Number(1.into()), Value::Number(2.into())]));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.inner.len(), 1);",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(matches!(entry.or_insert(Value::Array(vec![])), &mut Value::Array(_)));",
                "    assert_eq!(entry.key(), \"vacant_array_entry\");",
                "    assert!(entry.or_insert_with(|| Value::Array(vec![])).is_empty());",
                "    assert_eq!(entry.and_modify(|e| *e = Value::Array(vec![Value::Number(1.into()), Value::Number(2.into())])).key(), \"vacant_array_entry\");",
                "    assert!(matches!(map.inner.get(\"vacant_array_entry\"), Some(Value::Array(ref arr)) if arr.len() == 2));"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        inner: MapImpl<String, Value>,",
                "    }",
                "",
                "    impl TestMap {",
                "        fn new() -> Self {",
                "            TestMap {",
                "                inner: MapImpl::new(),",
                "            }",
                "        }",
                "",
                "        fn entry(&mut self, key: &str) -> Entry {",
                "            if self.inner.contains_key(key) {",
                "                Entry::Occupied(OccupiedEntry {",
                "                    occupied: self.inner.get_mut(key).unwrap(),",
                "                })",
                "            } else {",
                "                let vacant = VacantEntry {",
                "                    vacant: self.inner.entry(String::from(key)).or_insert(Value::Array(vec![])),",
                "                };",
                "                Entry::Vacant(vacant)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut map = TestMap::new();",
                "    let entry = map.entry(\"vacant_array_entry\");",
                "",
                "    let _ = entry.and_modify(|e| *e = Value::Array(vec![Value::Number(1.into()), Value::Number(2.into())]));",
                "    assert_eq!(map.inner.len(), 1);",
                "    assert!(matches!(entry, Entry::Vacant(_)));",
                "    assert!(matches!(entry.or_insert(Value::Array(vec![])), &mut Value::Array(_)));",
                "    assert_eq!(entry.key(), \"vacant_array_entry\");",
                "    assert!(entry.or_insert_with(|| Value::Array(vec![])).is_empty());",
                "    assert_eq!(entry.and_modify(|e| *e = Value::Array(vec![Value::Number(1.into()), Value::Number(2.into())])).key(), \"vacant_array_entry\");",
                "    assert!(matches!(map.inner.get(\"vacant_array_entry\"), Some(Value::Array(ref arr)) if arr.len() == 2));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}