{
  "name": "either::{impl#12}::poll",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1561:2"
  },
  "visible": true,
  "loc": "src/lib.rs:1149:5:1154:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.as_pin_mut() matches $crate::Either::Right($pattern) at line 1153 is true\n"
      ],
      "input_infer": "self is a Pin<&mut Either<L, R>> where L and R are valid Future types and cx is a mutable reference of type &mut core::task::Context with appropriate context for polling.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct RightFuture;",
                "    impl Future for RightFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Ready(42)",
                "        }",
                "    }",
                "",
                "    struct LeftFuture;",
                "    impl Future for LeftFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Pending",
                "        }",
                "    }",
                "",
                "    let right_future = RightFuture;",
                "    let either = Either::Right(right_future);",
                "    ",
                "    let mut cx = core::task::Context::from_waker(futures::task::noop_waker_ref());",
                "    let mut pinned_either = Pin::new(&mut either);",
                "    let result = pinned_either.poll(&mut cx);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, core::task::Poll::Ready(42));"
              ],
              "code": [
                "{",
                "    struct RightFuture;",
                "    impl Future for RightFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Ready(42)",
                "        }",
                "    }",
                "",
                "    struct LeftFuture;",
                "    impl Future for LeftFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Pending",
                "        }",
                "    }",
                "",
                "    let right_future = RightFuture;",
                "    let either = Either::Right(right_future);",
                "    ",
                "    let mut cx = core::task::Context::from_waker(futures::task::noop_waker_ref());",
                "    let mut pinned_either = Pin::new(&mut either);",
                "    let result = pinned_either.poll(&mut cx);",
                "    assert_eq!(result, core::task::Poll::Ready(42));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct RightFuture;",
                "    impl Future for RightFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Pending",
                "        }",
                "    }",
                "",
                "    struct LeftFuture;",
                "    impl Future for LeftFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Ready(36)",
                "        }",
                "    }",
                "",
                "    let left_future = LeftFuture;",
                "    let either = Either::Left(left_future);",
                "    ",
                "    let mut cx = core::task::Context::from_waker(futures::task::noop_waker_ref());",
                "    let mut pinned_either = Pin::new(&mut either);",
                "    let result = pinned_either.poll(&mut cx);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ready());",
                "    assert_eq!(result.unwrap(), 36);"
              ],
              "code": [
                "{",
                "    struct RightFuture;",
                "    impl Future for RightFuture {",
                "   type Output = i32;",
                "   fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "           core::task::Poll::Pending",
                "       }",
                "   }",
                "",
                "   struct LeftFuture;",
                "   impl Future for LeftFuture {",
                "       type Output = i32;",
                "       fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "           core::task::Poll::Ready(36)",
                "       }",
                "   }",
                "",
                "   let left_future = LeftFuture;",
                "   let either = Either::Left(left_future);",
                "   ",
                "   let mut cx = core::task::Context::from_waker(futures::task::noop_waker_ref());",
                "   let mut pinned_either = Pin::new(&mut either);",
                "   let result = pinned_either.poll(&mut cx);",
                "   assert!(result.is_ready());",
                "   if let core::task::Poll::Ready(value) = result { assert_eq!(value, 36); } else { panic!(\"Expected Poll::Ready\"); }",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct BothReadyFuture;",
                "    impl Future for BothReadyFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Ready(100)",
                "        }",
                "    }",
                "",
                "    let either = Either::Right(BothReadyFuture);",
                "    ",
                "    let mut cx = core::task::Context::from_waker(futures::task::noop_waker_ref());",
                "    let mut pinned_either = Pin::new(&mut either);",
                "    let result = pinned_either.poll(&mut cx);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, core::task::Poll::Ready(100));"
              ],
              "code": [
                "{",
                "    struct BothReadyFuture;",
                "    impl Future for BothReadyFuture {",
                "        type Output = i32;",
                "        fn poll(self: Pin<&mut Self>, _: &mut core::task::Context<'_>) -> core::task::Poll<Self::Output> {",
                "            core::task::Poll::Ready(100)",
                "        }",
                "    }",
                "",
                "    let either = Either::Right(BothReadyFuture);",
                "    ",
                "    let mut cx = core::task::Context::from_waker(futures::task::noop_waker_ref());",
                "    let mut pinned_either = Pin::new(&mut either);",
                "    let result = pinned_either.poll(&mut cx);",
                "    assert_eq!(result, core::task::Poll::Ready(100));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.as_pin_mut() matches $crate::Either::Left($pattern) at line 1153 is true\n",
        "precondition: self.as_pin_mut() matches $crate::Either::Left($pattern) at line 1153 is true\n"
      ],
      "input_infer": "Pin<&mut Self> must be an instance of Either<L, R> where L is a Future, R is another Future that outputs L::Output; context must have an initialized core::task::Context.\n",
      "answers": [
        {
          "uses": [
            "use core::pin::Pin;",
            "use core::future::Future;",
            "use core::task::Context;",
            "use std::task::Poll;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use core::pin::Pin;",
                "    use core::future::Future;",
                "    use core::task::Context;",
                "    use std::task::Poll;",
                "",
                "    struct MockFuture;",
                "",
                "    impl Future for MockFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(42)",
                "        }",
                "    }",
                "",
                "    struct AnotherFuture;",
                "",
                "    impl Future for AnotherFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(100)",
                "        }",
                "    }",
                "",
                "    let future_left = MockFuture;",
                "    let future_right = AnotherFuture;",
                "",
                "    let either_instance = Either::Left(future_left);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let mut context = Context::from_waker(futures::task::noop_waker_ref());",
                "",
                "    let _ = pinned_either.poll(&mut context);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(pinned_either.poll(&mut context), Poll::Ready(42));",
                "    let either_instance = Either::Right(future_right);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    assert_eq!(pinned_either.poll(&mut context), Poll::Ready(100));"
              ],
              "code": [
                "{",
                "    use core::pin::Pin;",
                "    use core::future::Future;",
                "    use core::task::Context;",
                "    use std::task::Poll;",
                "",
                "    struct MockFuture;",
                "",
                "    impl Future for MockFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(42)",
                "        }",
                "    }",
                "",
                "    struct AnotherFuture;",
                "",
                "    impl Future for AnotherFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(100)",
                "        }",
                "    }",
                "",
                "    let future_left = MockFuture;",
                "    let future_right = AnotherFuture;",
                "",
                "    let either_instance = Either::Left(future_left);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let mut context = Context::from_waker(futures::task::noop_waker_ref());",
                "",
                "    let _ = pinned_either.poll(&mut context);",
                "    assert_eq!(pinned_either.poll(&mut context), Poll::Ready(42));",
                "    let either_instance = Either::Right(future_right);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    assert_eq!(pinned_either.poll(&mut context), Poll::Ready(100));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use core::pin::Pin;",
                "    use core::future::Future;",
                "    use core::task::Context;",
                "    use std::task::Poll;",
                "",
                "    struct AnotherFuture;",
                "",
                "    impl Future for AnotherFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(100)",
                "        }",
                "    }",
                "",
                "    struct MockFuture;",
                "",
                "    impl Future for MockFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(42)",
                "        }",
                "    }",
                "",
                "    let future_left = AnotherFuture;",
                "    let future_right = MockFuture;",
                "",
                "    let either_instance = Either::Right(future_right);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let mut context = Context::from_waker(futures::task::noop_waker_ref());",
                "",
                "    let _ = pinned_either.poll(&mut context);",
                "}"
              ],
              "oracle": [
                "    let future_left = AnotherFuture;",
                "    let future_right = MockFuture;",
                "    let either_instance = Either::Left(future_left);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let mut context = Context::from_waker(futures::task::noop_waker_ref());",
                "    let result = pinned_either.poll(&mut context);",
                "    assert_eq!(result, Poll::Ready(100));",
                "    ",
                "    let either_instance = Either::Right(future_right);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let result = pinned_either.poll(&mut context);",
                "    assert_eq!(result, Poll::Ready(42));"
              ],
              "code": [
                "{",
                "    use core::pin::Pin;",
                "    use core::future::Future;",
                "    use core::task::Context;",
                "    use std::task::Poll;",
                "",
                "    struct AnotherFuture;",
                "",
                "    impl Future for AnotherFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(100)",
                "        }",
                "    }",
                "",
                "    struct MockFuture;",
                "",
                "    impl Future for MockFuture {",
                "        type Output = i32;",
                "",
                "        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {",
                "            Poll::Ready(42)",
                "        }",
                "    }",
                "",
                "    let future_left = AnotherFuture;",
                "    let future_right = MockFuture;",
                "",
                "    let either_instance = Either::Right(future_right);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let mut context = Context::from_waker(futures::task::noop_waker_ref());",
                "",
                "    let _ = pinned_either.poll(&mut context);",
                "    let future_left = AnotherFuture;",
                "    let future_right = MockFuture;",
                "    let either_instance = Either::Left(future_left);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let mut context = Context::from_waker(futures::task::noop_waker_ref());",
                "    let result = pinned_either.poll(&mut context);",
                "    assert_eq!(result, Poll::Ready(100));",
                "    ",
                "    let either_instance = Either::Right(future_right);",
                "    let pinned_either = Pin::new(&mut either_instance);",
                "    let result = pinned_either.poll(&mut context);",
                "    assert_eq!(result, Poll::Ready(42));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}