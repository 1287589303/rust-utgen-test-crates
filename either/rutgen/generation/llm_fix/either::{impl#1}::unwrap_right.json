{
  "name": "either::{impl#1}::unwrap_right",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1561:2"
  },
  "visible": true,
  "loc": "src/lib.rs:841:5:849:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches Either::Right(r) at line 845 is true\n",
        "precondition: self matches Either::Right(r) at line 845 is true\n",
        "expected return value/type: r\n"
      ],
      "input_infer": "self should be an instance of Either where the variant is Right containing a value of type R.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<(), i32> = Right(3);",
                "    let result = right.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(right.unwrap_right(), 3);",
                "    let left: Either<i32, ()> = Left(3);",
                "    let _result = left.unwrap_right(); // This should panic",
                "    assert!(matches!(left.unwrap_right(), Either::Right(_)), \"Expected Either to be Right\");",
                "    assert!(!left.is_left(), \"Expected Either to not be Left after unwrap_right\");"
              ],
              "code": [
                "{",
                "#[should_panic]",
                "fn test_unwrap_right_should_panic_on_left() {",
                "    let left: Either<i32, ()> = Left(3);",
                "    let _result = left.unwrap_right();",
                "}",
                "    let right: Either<(), i32> = Right(3);",
                "    let result = right.unwrap_right();",
                "    assert_eq!(right.unwrap_right(), 3);",
                "    let left: Either<i32, ()> = Left(3);",
                "    let _result = left.unwrap_right(); // This should panic",
                "    assert!(matches!(left.unwrap_right(), Either::Right(_)), \"Expected Either to be Right\");",
                "    assert!(!left.is_left(), \"Expected Either to not be Left after unwrap_right\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<(), String> = Right(String::from(\"hello\"));",
                "    let result = right.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(left.unwrap_right(), None);",
                "    let right: Either<(), String> = Right(String::from(\"hello\"));",
                "    assert_eq!(result, String::from(\"hello\"));",
                "    let right: Either<i32, f64> = Right(5.5);",
                "    assert_eq!(right.unwrap_right(), 5.5);",
                "    let right: Either<i32, u32> = Right(10u32);",
                "    assert_eq!(right.unwrap_right(), 10u32);",
                "    #[should_panic] left: Either<i32, f64> = Left(3);",
                "    left.expect_right(\"Expected Right value, found Left\");",
                "    assert_eq!(left.unwrap_right(), Err(\"panic\"));",
                "    let right: Either<(), _> = Right(3);"
              ],
              "code": [
                "{",
                "#[should_panic]",
                "fn test_unwrap_right_should_panic_on_left() {",
                "    let left: Either<i32, ()> = Left(3);",
                "    let _result = left.unwrap_right();",
                "}",
                "    let right: Either<(), String> = Right(String::from(\"hello\"));",
                "    let result = right.unwrap_right();",
                "    assert_eq!(left.unwrap_right(), None);",
                "    let right: Either<(), String> = Right(String::from(\"hello\"));",
                "    assert_eq!(result, String::from(\"hello\"));",
                "    let right: Either<i32, f64> = Right(5.5);",
                "    assert_eq!(right.unwrap_right(), 5.5);",
                "    let right: Either<i32, u32> = Right(10u32);",
                "    assert_eq!(right.unwrap_right(), 10u32);",
                "    #[should_panic] left: Either<i32, f64> = Left(3);",
                "    left.expect_right(\"Expected Right value, found Left\");",
                "    assert_eq!(left.unwrap_right(), Err(\"panic\"));",
                "    let right: Either<(), _> = Right(3);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<(), f64> = Right(3.14);",
                "    let result = right.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(right.unwrap_right(), 3.14);",
                "    let left: Either<i32, ()> = Left(3);",
                "    let panic_result = std::panic::catch_unwind(|| left.unwrap_right());",
                "    assert!(panic_result.is_err());"
              ],
              "code": [
                "{",
                "#[should_panic]",
                "fn test_unwrap_right_should_panic_on_left() {",
                "    let left: Either<i32, ()> = Left(3);",
                "    let _result = left.unwrap_right();",
                "}",
                "    let right: Either<(), f64> = Right(3.14);",
                "    let result = right.unwrap_right();",
                "    assert_eq!(right.unwrap_right(), 3.14);",
                "    let left: Either<i32, ()> = Left(3);",
                "    let panic_result = std::panic::catch_unwind(|| left.unwrap_right());",
                "    assert!(panic_result.is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<(), bool> = Right(true);",
                "    let result = right.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(Right(3).unwrap_right(), 3);",
                "    assert_eq!(Right(true).unwrap_right(), true);",
                "    let left: Either<i32, ()> = Left(3);",
                "    let panic_msg = format!(\"called `Either::unwrap_right()` on a `Left` value: {:?}\", 3);",
                "    assert!(std::panic::catch_unwind(|| left.unwrap_right()).is_err());",
                "    assert!(matches!(std::panic::catch_unwind(|| left.unwrap_right()), Err(panic) if panic.downcast_ref::<String>() == Some(&panic_msg)));"
              ],
              "code": [
                "{",
                "#[should_panic]",
                "fn test_unwrap_right_should_panic_on_left() {",
                "    let left: Either<i32, ()> = Left(3);",
                "    let _result = left.unwrap_right();",
                "}",
                "    let right: Either<(), bool> = Right(true);",
                "    let result = right.unwrap_right();",
                "    assert_eq!(Right(3).unwrap_right(), 3);",
                "    assert_eq!(Right(true).unwrap_right(), true);",
                "    let left: Either<i32, ()> = Left(3);",
                "    let panic_msg = format!(\"called `Either::unwrap_right()` on a `Left` value: {:?}\", 3);",
                "    assert!(std::panic::catch_unwind(|| left.unwrap_right()).is_err());",
                "    assert!(matches!(std::panic::catch_unwind(|| left.unwrap_right()), Err(panic) if panic.downcast_ref::<String>() == Some(&panic_msg)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches Either::Left(l) at line 845 is true\n"
      ],
      "input_infer": "self must be an instance of Either::Left with any value type for L that implements Debug, and R can be any type.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: Either<i32, ()> = Left(3);",
                "    left.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert_panics!(test, \"called `Either::unwrap_right()` on a `Left` value: 3\");"
              ],
              "code": [
                "{",
                "    let left: Either<i32, ()> = Left(3);",
                "    left.unwrap_right();",
                "    assert_panics!(test, \"called `Either::unwrap_right()` on a `Left` value: 3\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: Either<String, ()> = Left(String::from(\"error\"));",
                "    left.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert_panics!(test, || {",
                "    let left: Either<String, ()> = Left(String::from(\"error\"));",
                "    left.unwrap_right();",
                "    });"
              ],
              "code": [
                "{",
                "    let left: Either<String, ()> = Left(String::from(\"error\"));",
                "    left.unwrap_right();",
                "    assert_panics!(test, || {",
                "    let left: Either<String, ()> = Left(String::from(\"error\"));",
                "    left.unwrap_right();",
                "    });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: Either<f64, ()> = Left(3.14);",
                "    left.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert_panics!(left.unwrap_right());"
              ],
              "code": [
                "{",
                "    let left: Either<f64, ()> = Left(3.14);",
                "    left.unwrap_right();",
                "    assert_panics!(left.unwrap_right());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Debug)]",
                "    struct TestStruct {",
                "        value: i32,",
                "    }",
                "    let left: Either<TestStruct, ()> = Left(TestStruct { value: 42 });",
                "    left.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    panic!(\"called `Either::unwrap_right()` on a `Left` value: TestStruct { value: 42 }\");"
              ],
              "code": [
                "{",
                "    #[derive(Debug)]",
                "    struct TestStruct {",
                "        value: i32,",
                "    }",
                "    let left: Either<TestStruct, ()> = Left(TestStruct { value: 42 });",
                "    left.unwrap_right();",
                "    panic!(\"called `Either::unwrap_right()` on a `Left` value: TestStruct { value: 42 }\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: Either<(i32, i32), ()> = Left((1, 2));",
                "    left.unwrap_right();",
                "}"
              ],
              "oracle": [
                "    assert!(std::panic::catch_unwind(|| {",
                "    let left: Either<(i32, i32), ()> = Left((1, 2));",
                "    left.unwrap_right();",
                "    }).is_err());"
              ],
              "code": [
                "{",
                "    let left: Either<(i32, i32), ()> = Left((1, 2));",
                "    left.unwrap_right();",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let left: Either<(i32, i32), ()> = Left((1, 2));",
                "    left.unwrap_right();",
                "    }).is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}