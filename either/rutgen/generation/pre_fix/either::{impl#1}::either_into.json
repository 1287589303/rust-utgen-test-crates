{
  "name": "either::{impl#1}::either_into",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1561:2"
  },
  "visible": true,
  "loc": "src/lib.rs:921:5:927:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches $crate::Either::Right($pattern) at line 926 is true\n"
      ],
      "input_infer": "Either::Right variants with types convertible to T, e.g., Right(u8), Right(i32), Right(String) or custom types with Into<T> implemented, covering cases like numeric limits, empty containers, and various types implementing Into<T>.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<u16, u32> = Right(255u32);",
                "    let result: u8 = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 255u8);"
              ],
              "code": [
                "{",
                "    let right: Either<u16, u32> = Right(255u32);",
                "    let result: u8 = right.either_into();",
                "    assert_eq!(result, 255u8);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<u16, u32> = Right(123456789u32);",
                "    let result: i32 = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 123456789u32);"
              ],
              "code": [
                "{",
                "    let right: Either<u16, u32> = Right(123456789u32);",
                "    let result: i32 = right.either_into();",
                "    assert_eq!(result, 123456789u32);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<&str, &str> = Right(\"test\");",
                "    let result: String = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, \"test\".to_string());"
              ],
              "code": [
                "{",
                "    let right: Either<&str, &str> = Right(\"test\");",
                "    let result: String = right.either_into();",
                "    assert_eq!(result, \"test\".to_string());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<Vec<u8>, Vec<u8>> = Right(Vec::new());",
                "    let result: Vec<u8> = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Vec::<u8>::new());"
              ],
              "code": [
                "{",
                "    let right: Either<Vec<u8>, Vec<u8>> = Right(Vec::new());",
                "    let result: Vec<u8> = right.either_into();",
                "    assert_eq!(result, Vec::<u8>::new());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<u16, u64> = Right(1_000_000_000_000_000_000u64);",
                "    let result: u64 = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 1_000_000_000_000_000_000u64);"
              ],
              "code": [
                "{",
                "    let right: Either<u16, u64> = Right(1_000_000_000_000_000_000u64);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 1_000_000_000_000_000_000u64);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches $crate::Either::Left($pattern) at line 926 is true\n",
        "precondition: self matches $crate::Either::Left($pattern) at line 926 is true\n"
      ],
      "input_infer": "Either::Left and Either::Right must be instances of types that can be converted into the same target type T using Into<T>, covering edge cases for maximum/minimum values and typical usage scenarios for both types.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: Either<u16, u32> = Left(3u16);",
                "    let result: u64 = left.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 3u64);",
                "    assert_eq!(result, left.either_into::<u64>());",
                "    assert!(matches!(left, Left(3u16)));",
                "    assert!(matches!(left.either_into(), 3u64));",
                "    assert!(matches!(left.either_into::<u64>(), 3u64));"
              ],
              "code": [
                "{",
                "    let left: Either<u16, u32> = Left(3u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 3u64);",
                "    assert_eq!(result, left.either_into::<u64>());",
                "    assert!(matches!(left, Left(3u16)));",
                "    assert!(matches!(left.either_into(), 3u64));",
                "    assert!(matches!(left.either_into::<u64>(), 3u64));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<u16, u32> = Right(7u32);",
                "    let result: u64 = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 7u64);",
                "    let left: Either<u16, u32> = Left(3u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 3u64);"
              ],
              "code": [
                "{",
                "    let right: Either<u16, u32> = Right(7u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 7u64);",
                "    let left: Either<u16, u32> = Left(3u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 3u64);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: Either<u16, u32> = Left(0u16);",
                "    let result: u64 = left.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 0u64);",
                "    let right: Either<u16, u32> = Right(0u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let left: Either<u16, u32> = Left(5u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 5u64);",
                "    let right: Either<u16, u32> = Right(10u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 10u64);",
                "    let left: Either<u16, u32> = Left(u16::MAX);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, u16::MAX as u64);",
                "    let right: Either<u16, u32> = Right(u32::MAX);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, u32::MAX as u64);"
              ],
              "code": [
                "{",
                "    let left: Either<u16, u32> = Left(0u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let right: Either<u16, u32> = Right(0u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let left: Either<u16, u32> = Left(5u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 5u64);",
                "    let right: Either<u16, u32> = Right(10u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 10u64);",
                "    let left: Either<u16, u32> = Left(u16::MAX);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, u16::MAX as u64);",
                "    let right: Either<u16, u32> = Right(u32::MAX);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, u32::MAX as u64);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<u16, u32> = Right(0u32);",
                "    let result: u64 = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, 0u64);",
                "    let left: Either<u16, u32> = Left(10u16);",
                "    let result_left: u64 = left.either_into();",
                "    assert_eq!(result_left, 10u64);",
                "    let left_negative: Either<i16, u32> = Left(-5i16);",
                "    let result_left_negative: u64 = left_negative.either_into();",
                "    assert_eq!(result_left_negative, -5i16 as u64);",
                "    let right_large: Either<u16, u32> = Right(1000u32);",
                "    let result_right_large: u64 = right_large.either_into();",
                "    assert_eq!(result_right_large, 1000u64);"
              ],
              "code": [
                "{",
                "    let right: Either<u16, u32> = Right(0u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let left: Either<u16, u32> = Left(10u16);",
                "    let result_left: u64 = left.either_into();",
                "    assert_eq!(result_left, 10u64);",
                "    let left_negative: Either<i16, u32> = Left(-5i16);",
                "    let result_left_negative: u64 = left_negative.either_into();",
                "    assert_eq!(result_left_negative, -5i16 as u64);",
                "    let right_large: Either<u16, u32> = Right(1000u32);",
                "    let result_right_large: u64 = right_large.either_into();",
                "    assert_eq!(result_right_large, 1000u64);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: Either<u16, u32> = Left(u16::MAX);",
                "    let result: u64 = left.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, u64::from(u16::MAX));",
                "    let right: Either<u16, u32> = Right(u32::MAX);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, u64::from(u32::MAX));",
                "    let left_zero: Either<u16, u32> = Left(0u16);",
                "    let result: u64 = left_zero.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let right_zero: Either<u16, u32> = Right(0u32);",
                "    let result: u64 = right_zero.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let left_small: Either<u16, u32> = Left(1u16);",
                "    let result: u64 = left_small.either_into();",
                "    assert_eq!(result, 1u64);",
                "    let right_small: Either<u16, u32> = Right(1u32);",
                "    let result: u64 = right_small.either_into();",
                "    assert_eq!(result, 1u64);",
                "    let large_left: Either<u16, u32> = Left(u16::MAX - 1);",
                "    let result: u64 = large_left.either_into();",
                "    assert_eq!(result, u64::from(u16::MAX - 1));",
                "    let large_right: Either<u16, u32> = Right(u32::MAX - 1);",
                "    let result: u64 = large_right.either_into();",
                "    assert_eq!(result, u64::from(u32::MAX - 1));"
              ],
              "code": [
                "{",
                "    let left: Either<u16, u32> = Left(u16::MAX);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, u64::from(u16::MAX));",
                "    let right: Either<u16, u32> = Right(u32::MAX);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, u64::from(u32::MAX));",
                "    let left_zero: Either<u16, u32> = Left(0u16);",
                "    let result: u64 = left_zero.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let right_zero: Either<u16, u32> = Right(0u32);",
                "    let result: u64 = right_zero.either_into();",
                "    assert_eq!(result, 0u64);",
                "    let left_small: Either<u16, u32> = Left(1u16);",
                "    let result: u64 = left_small.either_into();",
                "    assert_eq!(result, 1u64);",
                "    let right_small: Either<u16, u32> = Right(1u32);",
                "    let result: u64 = right_small.either_into();",
                "    assert_eq!(result, 1u64);",
                "    let large_left: Either<u16, u32> = Left(u16::MAX - 1);",
                "    let result: u64 = large_left.either_into();",
                "    assert_eq!(result, u64::from(u16::MAX - 1));",
                "    let large_right: Either<u16, u32> = Right(u32::MAX - 1);",
                "    let result: u64 = large_right.either_into();",
                "    assert_eq!(result, u64::from(u32::MAX - 1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let right: Either<u16, u32> = Right(u32::MAX);",
                "    let result: u64 = right.either_into();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, u32::MAX.into());",
                "    ",
                "    let left: Either<u16, u32> = Left(3u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 3u64);",
                "    ",
                "    let left: Either<u16, u32> = Left(0u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 0u64);",
                "    ",
                "    let right: Either<u16, u32> = Right(7u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 7u64);"
              ],
              "code": [
                "{",
                "    let right: Either<u16, u32> = Right(u32::MAX);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, u32::MAX.into());",
                "    ",
                "    let left: Either<u16, u32> = Left(3u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 3u64);",
                "    ",
                "    let left: Either<u16, u32> = Left(0u16);",
                "    let result: u64 = left.either_into();",
                "    assert_eq!(result, 0u64);",
                "    ",
                "    let right: Either<u16, u32> = Right(7u32);",
                "    let result: u64 = right.either_into();",
                "    assert_eq!(result, 7u64);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}