[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct EmptyIterator;",
          "",
          "    impl Iterator for EmptyIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            None",
          "        }",
          "    }",
          "",
          "    let left_iter = EmptyIterator;",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "",
          "    let predicate = |&x: &Either<i32, i32>| match x {",
          "        Either::Left(val) => val > 0,",
          "        Either::Right(_) => false,",
          "    };",
          "",
          "    iter_either.partition(predicate);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(iter_either.partition(predicate), (Vec::<Either<i32, i32>>::new(), vec![Either::Right(1)]));",
          "    let iter_either_full = IterEither { inner: Either::Left(std::iter::once(5)) };",
          "    assert_eq!(iter_either_full.partition(predicate), (vec![Either::Left(5)], Vec::<Either<i32, i32>>::new()));",
          "    let iter_either_mixed = IterEither { inner: Either::Left(std::iter::once(0)) };",
          "    assert_eq!(iter_either_mixed.partition(predicate), (Vec::<Either<i32, i32>>::new(), Vec::<Either<i32, i32>>::new()));",
          "    let iter_either_empty = IterEither { inner: Either::Left(EmptyIterator) };",
          "    assert_eq!(iter_either_empty.partition(predicate), (Vec::<Either<i32, i32>>::new(), Vec::<Either<i32, i32>>::new()));",
          "    let iter_either_right = IterEither { inner: Either::Right(std::iter::once(2)) };",
          "    assert_eq!(iter_either_right.partition(predicate), (Vec::<Either<i32, i32>>::new(), vec![Either::Right(2)]));"
        ],
        "code": [
          "{",
          "    struct EmptyIterator;",
          "",
          "    impl Iterator for EmptyIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            None",
          "        }",
          "    }",
          "",
          "    let left_iter = EmptyIterator;",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "",
          "    let predicate = |&x: &Either<i32, i32>| match x {",
          "        Either::Left(val) => val > 0,",
          "        Either::Right(_) => false,",
          "    };",
          "",
          "    iter_either.partition(predicate);",
          "    assert_eq!(iter_either.partition(predicate), (Vec::<Either<i32, i32>>::new(), vec![Either::Right(1)]));",
          "    let iter_either_full = IterEither { inner: Either::Left(std::iter::once(5)) };",
          "    assert_eq!(iter_either_full.partition(predicate), (vec![Either::Left(5)], Vec::<Either<i32, i32>>::new()));",
          "    let iter_either_mixed = IterEither { inner: Either::Left(std::iter::once(0)) };",
          "    assert_eq!(iter_either_mixed.partition(predicate), (Vec::<Either<i32, i32>>::new(), Vec::<Either<i32, i32>>::new()));",
          "    let iter_either_empty = IterEither { inner: Either::Left(EmptyIterator) };",
          "    assert_eq!(iter_either_empty.partition(predicate), (Vec::<Either<i32, i32>>::new(), Vec::<Either<i32, i32>>::new()));",
          "    let iter_either_right = IterEither { inner: Either::Right(std::iter::once(2)) };",
          "    assert_eq!(iter_either_right.partition(predicate), (Vec::<Either<i32, i32>>::new(), vec![Either::Right(2)]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct SingleItemIterator {",
          "        item: i32,",
          "        called: bool,",
          "    }",
          "",
          "    impl Iterator for SingleItemIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.called {",
          "                None",
          "            } else {",
          "                self.called = true;",
          "                Some(self.item)",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = SingleItemIterator { item: 5, called: false };",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "",
          "    let predicate = |&x: &Either<i32, i32>| match x {",
          "        Either::Left(val) => val > 0,",
          "        Either::Right(_) => false,",
          "    };",
          "",
          "    iter_either.partition(predicate);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(iter_either.partition(predicate), (vec![Either::Left(5)], vec![]));",
          "    assert_eq!(iter_either.partition(|x| matches!(x, Either::Left(_))), (vec![Either::Left(5)], vec![]));",
          "    assert_eq!(iter_either.partition(|x| matches!(x, Either::Right(_))), (vec![], vec![Either::Left(5)]));",
          "    assert_eq!(iter_either.partition(|x| if let Either::Left(val) = x { val < 10 } else { false }), (vec![Either::Left(5)], vec![]));",
          "    assert_eq!(iter_either.partition(|x| if let Either::Left(val) = x { val > 10 } else { false }), (vec![], vec![Either::Left(5)]));",
          "    assert_eq!(iter_either.partition(|x| true), (vec![Either::Left(5)], vec![]));"
        ],
        "code": [
          "{",
          "    struct SingleItemIterator {",
          "        item: i32,",
          "        called: bool,",
          "    }",
          "",
          "    impl Iterator for SingleItemIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.called {",
          "                None",
          "            } else {",
          "                self.called = true;",
          "                Some(self.item)",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = SingleItemIterator { item: 5, called: false };",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "",
          "    let predicate = |&x: &Either<i32, i32>| match x {",
          "        Either::Left(val) => val > 0,",
          "        Either::Right(_) => false,",
          "    };",
          "",
          "    iter_either.partition(predicate);",
          "    assert_eq!(iter_either.partition(predicate), (vec![Either::Left(5)], vec![]));",
          "    assert_eq!(iter_either.partition(|x| matches!(x, Either::Left(_))), (vec![Either::Left(5)], vec![]));",
          "    assert_eq!(iter_either.partition(|x| matches!(x, Either::Right(_))), (vec![], vec![Either::Left(5)]));",
          "    assert_eq!(iter_either.partition(|x| if let Either::Left(val) = x { val < 10 } else { false }), (vec![Either::Left(5)], vec![]));",
          "    assert_eq!(iter_either.partition(|x| if let Either::Left(val) = x { val > 10 } else { false }), (vec![], vec![Either::Left(5)]));",
          "    assert_eq!(iter_either.partition(|x| true), (vec![Either::Left(5)], vec![]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MixedIterator {",
          "        count: usize,",
          "    }",
          "",
          "    impl Iterator for MixedIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.count < 5 {",
          "                self.count += 1;",
          "                if self.count % 2 == 0 {",
          "                    Some(self.count as i32) // Valid item",
          "                } else {",
          "                    Some(-(self.count as i32)) // Invalid item",
          "                }",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = MixedIterator { count: 0 };",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "",
          "    let predicate = |&x: &Either<i32, i32>| match x {",
          "        Either::Left(val) => val > 0,",
          "        Either::Right(_) => false,",
          "    };",
          "",
          "    iter_either.partition(predicate);",
          "}"
        ],
        "oracle": [
          "    let left_iter = MixedIterator { count: 0 };",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "    let predicate = |&x: &Either<i32, i32>| match x { Either::Left(val) => val > 0, Either::Right(_) => false, };",
          "    let (left_result, right_result) = iter_either.partition(predicate);",
          "    assert_eq!(left_result.len(), 2);",
          "    assert_eq!(right_result.len(), 0);",
          "    assert!(left_result.iter().all(|&x| matches!(x, Either::Left(val) if val > 0)));",
          "    assert!(right_result.iter().all(|&x| matches!(x, Either::Right(_))));"
        ],
        "code": [
          "{",
          "    struct MixedIterator {",
          "        count: usize,",
          "    }",
          "",
          "    impl Iterator for MixedIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.count < 5 {",
          "                self.count += 1;",
          "                if self.count % 2 == 0 {",
          "                    Some(self.count as i32) // Valid item",
          "                } else {",
          "                    Some(-(self.count as i32)) // Invalid item",
          "                }",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = MixedIterator { count: 0 };",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "",
          "    let predicate = |&x: &Either<i32, i32>| match x {",
          "        Either::Left(val) => val > 0,",
          "        Either::Right(_) => false,",
          "    };",
          "",
          "    iter_either.partition(predicate);",
          "    let left_iter = MixedIterator { count: 0 };",
          "    let right_iter = std::iter::once(1);",
          "    let iter_either = IterEither { inner: Either::Left(left_iter) };",
          "    let predicate = |&x: &Either<i32, i32>| match x { Either::Left(val) => val > 0, Either::Right(_) => false, };",
          "    let (left_result, right_result) = iter_either.partition(predicate);",
          "    assert_eq!(left_result.len(), 2);",
          "    assert_eq!(right_result.len(), 0);",
          "    assert!(left_result.iter().all(|&x| matches!(x, Either::Left(val) if val > 0)));",
          "    assert!(right_result.iter().all(|&x| matches!(x, Either::Right(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]