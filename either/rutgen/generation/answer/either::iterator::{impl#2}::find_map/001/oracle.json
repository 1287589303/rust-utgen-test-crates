[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct RightIterator {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for RightIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let right_iter = RightIterator { values: vec![1, 2, 3], index: 0 };",
          "    let either = Either::Right(right_iter);",
          "    ",
          "    let closure = |x| if x % 2 == 0 { Some(x * 2) } else { None };",
          "",
          "    let _result = either.find_map(closure);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(either.find_map(|x| if x % 2 == 0 { Some(x * 2) } else { None }), Some(4));",
          "    assert_eq!(either.find_map(|x| if x > 3 { Some(x * 2) } else { None }), None);",
          "    assert_eq!(either.find_map(|x| Some(x)), Some(1));",
          "    assert_eq!(either.find_map(|x| if x == 2 { Some(x * 2) } else { None }), Some(4));",
          "    assert_eq!(either.find_map(|x| if x < 1 { Some(x * 2) } else { None }), None);"
        ],
        "code": [
          "{",
          "    struct RightIterator {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for RightIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let right_iter = RightIterator { values: vec![1, 2, 3], index: 0 };",
          "    let either = Either::Right(right_iter);",
          "    ",
          "    let closure = |x| if x % 2 == 0 { Some(x * 2) } else { None };",
          "",
          "    let _result = either.find_map(closure);",
          "    assert_eq!(either.find_map(|x| if x % 2 == 0 { Some(x * 2) } else { None }), Some(4));",
          "    assert_eq!(either.find_map(|x| if x > 3 { Some(x * 2) } else { None }), None);",
          "    assert_eq!(either.find_map(|x| Some(x)), Some(1));",
          "    assert_eq!(either.find_map(|x| if x == 2 { Some(x * 2) } else { None }), Some(4));",
          "    assert_eq!(either.find_map(|x| if x < 1 { Some(x * 2) } else { None }), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct LeftIterator {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for LeftIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIterator { values: vec![4, 5, 6], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "    ",
          "    let closure = |x| if x > 5 { Some(x * 2) } else { None };",
          "",
          "    let _result = either.find_map(closure);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(either.find_map(closure), None);",
          "    let right_iter = RightIterator { values: vec![1, 2, 3], index: 0 };",
          "    let either_with_right = Either::Right(right_iter);",
          "    assert_eq!(either_with_right.find_map(closure), Some(6));",
          "    let closure_with_none = |x| if x < 1 { None } else { Some(x) };",
          "    assert_eq!(either_with_right.find_map(closure_with_none), Some(1));"
        ],
        "code": [
          "{",
          "    struct LeftIterator {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for LeftIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIterator { values: vec![4, 5, 6], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "    ",
          "    let closure = |x| if x > 5 { Some(x * 2) } else { None };",
          "",
          "    let _result = either.find_map(closure);",
          "    assert_eq!(either.find_map(closure), None);",
          "    let right_iter = RightIterator { values: vec![1, 2, 3], index: 0 };",
          "    let either_with_right = Either::Right(right_iter);",
          "    assert_eq!(either_with_right.find_map(closure), Some(6));",
          "    let closure_with_none = |x| if x < 1 { None } else { Some(x) };",
          "    assert_eq!(either_with_right.find_map(closure_with_none), Some(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct LeftIterator {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for LeftIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIterator { values: vec![1, 3, 5], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "    ",
          "    let closure = |x| if x % 2 == 0 { Some(x * 2) } else { None };",
          "",
          "    let _result = either.find_map(closure);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, None);",
          "    let right_iter = RightIterator { values: vec![2, 4, 6], index: 0 };",
          "    let either_with_right = Either::Right(right_iter);",
          "    let _result_with_right = either_with_right.find_map(closure);",
          "    assert_eq!(_result_with_right, Some(4));",
          "    assert_eq!(_result_with_right, Some(8));",
          "    assert_eq!(_result_with_right, None);"
        ],
        "code": [
          "{",
          "    struct LeftIterator {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "    ",
          "    impl Iterator for LeftIterator {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIterator { values: vec![1, 3, 5], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "    ",
          "    let closure = |x| if x % 2 == 0 { Some(x * 2) } else { None };",
          "",
          "    let _result = either.find_map(closure);",
          "    assert_eq!(_result, None);",
          "    let right_iter = RightIterator { values: vec![2, 4, 6], index: 0 };",
          "    let either_with_right = Either::Right(right_iter);",
          "    let _result_with_right = either_with_right.find_map(closure);",
          "    assert_eq!(_result_with_right, Some(4));",
          "    assert_eq!(_result_with_right, Some(8));",
          "    assert_eq!(_result_with_right, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]