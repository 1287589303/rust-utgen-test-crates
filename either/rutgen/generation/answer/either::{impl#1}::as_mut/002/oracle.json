[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut left = Left(123);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "        *l = 999;",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(left.as_mut(), Either::Left(&mut 999));",
          "    assert_eq!(right.as_mut(), Either::Right(&mut 123));",
          "    assert!(matches!(left.as_mut(), Either::Left(_)));",
          "    assert!(matches!(right.as_mut(), Either::Right(_)));",
          "    let mut result = left.as_mut();",
          "    assert!(result.is_left());",
          "    assert!(!result.is_right());"
        ],
        "code": [
          "{",
          "    let mut left = Left(123);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "        *l = 999;",
          "    }",
          "    assert_eq!(left.as_mut(), Either::Left(&mut 999));",
          "    assert_eq!(right.as_mut(), Either::Right(&mut 123));",
          "    assert!(matches!(left.as_mut(), Either::Left(_)));",
          "    assert!(matches!(right.as_mut(), Either::Right(_)));",
          "    let mut result = left.as_mut();",
          "    assert!(result.is_left());",
          "    assert!(!result.is_right());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut right = Right(123);",
          "    let result = right.as_mut();",
          "    if let Either::Right(r) = result {",
          "        // This should not mutate the right value",
          "        *r = 999; // This will be effectively ignored since it's a Right",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Right(123));",
          "    assert_eq!(right, Right(123));",
          "    let mut left = Left(123);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "    *l = 999;",
          "    }",
          "    assert_eq!(result, Left(999));",
          "    assert_eq!(left, Left(999));"
        ],
        "code": [
          "{",
          "    let mut right = Right(123);",
          "    let result = right.as_mut();",
          "    if let Either::Right(r) = result {",
          "        // This should not mutate the right value",
          "        *r = 999; // This will be effectively ignored since it's a Right",
          "    }",
          "    assert_eq!(result, Right(123));",
          "    assert_eq!(right, Right(123));",
          "    let mut left = Left(123);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "    *l = 999;",
          "    }",
          "    assert_eq!(result, Left(999));",
          "    assert_eq!(left, Left(999));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut left = Left(0u32);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "        *l = 999;",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(left, Left(999));"
        ],
        "code": [
          "{",
          "    let mut left = Left(0u32);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "        *l = 999;",
          "    }",
          "    assert_eq!(left, Left(999));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut left = Left(999u32);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "        *l = 999;",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Left(&mut 999u32));",
          "    assert_eq!(left, Left(999));",
          "    assert!(result.is_left());",
          "    assert!(!result.is_right());",
          "    assert_eq!(left.as_mut().left(), Some(&mut 999u32));",
          "    assert_eq!(left.as_mut().right(), None);"
        ],
        "code": [
          "{",
          "    let mut left = Left(999u32);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "        *l = 999;",
          "    }",
          "    assert_eq!(result, Left(&mut 999u32));",
          "    assert_eq!(left, Left(999));",
          "    assert!(result.is_left());",
          "    assert!(!result.is_right());",
          "    assert_eq!(left.as_mut().left(), Some(&mut 999u32));",
          "    assert_eq!(left.as_mut().right(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut right = Right(0u32);",
          "    let result = right.as_mut();",
          "    if let Either::Right(r) = result {",
          "        // This should not mutate the right value",
          "        *r = 999; // This will be effectively ignored since it's a Right",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Right(&mut 0));",
          "    assert_eq!(right, Right(0));",
          "    let mut left = Left(123u32);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "    *l = 999;",
          "    }",
          "    assert_eq!(result, Left(&mut 999));",
          "    assert_eq!(left, Left(999));"
        ],
        "code": [
          "{",
          "    let mut right = Right(0u32);",
          "    let result = right.as_mut();",
          "    if let Either::Right(r) = result {",
          "        // This should not mutate the right value",
          "        *r = 999; // This will be effectively ignored since it's a Right",
          "    }",
          "    assert_eq!(result, Right(&mut 0));",
          "    assert_eq!(right, Right(0));",
          "    let mut left = Left(123u32);",
          "    let result = left.as_mut();",
          "    if let Either::Left(l) = result {",
          "    *l = 999;",
          "    }",
          "    assert_eq!(result, Left(&mut 999));",
          "    assert_eq!(left, Left(999));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut right = Right(999u32);",
          "    let result = right.as_mut();",
          "    if let Either::Right(r) = result {",
          "        // This should not mutate the right value",
          "        *r = 999; // This will be effectively ignored since it's a Right",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Right(999));",
          "    assert_eq!(right, Right(999));",
          "    let mut left = Left(123u32);",
          "    let result_left = left.as_mut();",
          "    if let Either::Left(l) = result_left {",
          "    *l = 999;",
          "    }",
          "    assert_eq!(left, Left(999));",
          "    assert_eq!(result_left, Left(&mut 999));",
          "    assert_eq!(right.is_left(), false);",
          "    assert_eq!(left.is_left(), true);"
        ],
        "code": [
          "{",
          "    let mut right = Right(999u32);",
          "    let result = right.as_mut();",
          "    if let Either::Right(r) = result {",
          "        // This should not mutate the right value",
          "        *r = 999; // This will be effectively ignored since it's a Right",
          "    }",
          "    assert_eq!(result, Right(999));",
          "    assert_eq!(right, Right(999));",
          "    let mut left = Left(123u32);",
          "    let result_left = left.as_mut();",
          "    if let Either::Left(l) = result_left {",
          "    *l = 999;",
          "    }",
          "    assert_eq!(left, Left(999));",
          "    assert_eq!(result_left, Left(&mut 999));",
          "    assert_eq!(right.is_left(), false);",
          "    assert_eq!(left.is_left(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]