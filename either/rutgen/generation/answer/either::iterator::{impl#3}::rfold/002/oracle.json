[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct LeftIter {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for LeftIter {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for LeftIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "",
          "        fn rfold<Acc, G>(self, init: Acc, f: G) -> Acc",
          "        where",
          "            G: FnMut(Acc, Self::Item) -> Acc {",
          "            let mut acc = init;",
          "            for value in self.values.iter().rev() {",
          "                acc = f(acc, *value);",
          "            }",
          "            acc",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIter { values: vec![1, 2, 3], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "",
          "    let result = either.rfold(0, |acc, x| acc + x);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 6);",
          "    ",
          "    let empty_iter = LeftIter { values: vec![], index: 0 };",
          "    let either_empty = Either::Left(empty_iter);",
          "    let result_empty = either_empty.rfold(10, |acc, x| acc + x);",
          "    assert_eq!(result_empty, 10);",
          "    ",
          "    let single_value_iter = LeftIter { values: vec![42], index: 0 };",
          "    let either_single = Either::Left(single_value_iter);",
          "    let result_single = either_single.rfold(0, |acc, x| acc + x);",
          "    assert_eq!(result_single, 42);",
          "    ",
          "    let negative_iter = LeftIter { values: vec![-1, -2, -3], index: 0 };",
          "    let either_negative = Either::Left(negative_iter);",
          "    let result_negative = either_negative.rfold(0, |acc, x| acc + x);",
          "    assert_eq!(result_negative, -6);"
        ],
        "code": [
          "{",
          "    struct LeftIter {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for LeftIter {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for LeftIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "",
          "        fn rfold<Acc, G>(self, init: Acc, f: G) -> Acc",
          "        where",
          "            G: FnMut(Acc, Self::Item) -> Acc {",
          "            let mut acc = init;",
          "            for value in self.values.iter().rev() {",
          "                acc = f(acc, *value);",
          "            }",
          "            acc",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIter { values: vec![1, 2, 3], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "",
          "    let result = either.rfold(0, |acc, x| acc + x);",
          "    assert_eq!(result, 6);",
          "    ",
          "    let empty_iter = LeftIter { values: vec![], index: 0 };",
          "    let either_empty = Either::Left(empty_iter);",
          "    let result_empty = either_empty.rfold(10, |acc, x| acc + x);",
          "    assert_eq!(result_empty, 10);",
          "    ",
          "    let single_value_iter = LeftIter { values: vec![42], index: 0 };",
          "    let either_single = Either::Left(single_value_iter);",
          "    let result_single = either_single.rfold(0, |acc, x| acc + x);",
          "    assert_eq!(result_single, 42);",
          "    ",
          "    let negative_iter = LeftIter { values: vec![-1, -2, -3], index: 0 };",
          "    let either_negative = Either::Left(negative_iter);",
          "    let result_negative = either_negative.rfold(0, |acc, x| acc + x);",
          "    assert_eq!(result_negative, -6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct RightIter {",
          "        values: Vec<f32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for RightIter {",
          "        type Item = f32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for RightIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "",
          "        fn rfold<Acc, G>(self, init: Acc, f: G) -> Acc",
          "        where",
          "            G: FnMut(Acc, Self::Item) -> Acc {",
          "            let mut acc = init;",
          "            for value in self.values.iter().rev() {",
          "                acc = f(acc, *value);",
          "            }",
          "            acc",
          "        }",
          "    }",
          "",
          "    let right_iter = RightIter { values: vec![1.0, 2.0, 3.0], index: 0 };",
          "    let either = Either::Right(right_iter);",
          "",
          "    let result = either.rfold(0.0, |acc, x| acc + x);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, 6.0);",
          "    let left_iter = LeftIter { values: vec![4.0, 5.0], index: 0 };",
          "    let either_left = Either::Left(left_iter);",
          "    let result_left = either_left.rfold(10.0, |acc, x| acc + x);",
          "    assert_eq!(result_left, 19.0);",
          "    let both_iter = Either::Right(RightIter { values: vec![1.0, 2.0, 3.0], index: 0 });",
          "    let result_both = both_iter.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(result_both, 6.0);",
          "    let empty_iter = RightIter { values: vec![], index: 0 };",
          "    let either_empty = Either::Right(empty_iter);",
          "    let result_empty = either_empty.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(result_empty, 0.0);",
          "    let mixed_iter = Either::Left(LeftIter { values: vec![1.0], index: 0 });",
          "    let result_mixed = mixed_iter.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(result_mixed, 1.0);"
        ],
        "code": [
          "{",
          "    struct RightIter {",
          "        values: Vec<f32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for RightIter {",
          "        type Item = f32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for RightIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "",
          "        fn rfold<Acc, G>(self, init: Acc, f: G) -> Acc",
          "        where",
          "            G: FnMut(Acc, Self::Item) -> Acc {",
          "            let mut acc = init;",
          "            for value in self.values.iter().rev() {",
          "                acc = f(acc, *value);",
          "            }",
          "            acc",
          "        }",
          "    }",
          "",
          "    let right_iter = RightIter { values: vec![1.0, 2.0, 3.0], index: 0 };",
          "    let either = Either::Right(right_iter);",
          "",
          "    let result = either.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(result, 6.0);",
          "    let left_iter = LeftIter { values: vec![4.0, 5.0], index: 0 };",
          "    let either_left = Either::Left(left_iter);",
          "    let result_left = either_left.rfold(10.0, |acc, x| acc + x);",
          "    assert_eq!(result_left, 19.0);",
          "    let both_iter = Either::Right(RightIter { values: vec![1.0, 2.0, 3.0], index: 0 });",
          "    let result_both = both_iter.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(result_both, 6.0);",
          "    let empty_iter = RightIter { values: vec![], index: 0 };",
          "    let either_empty = Either::Right(empty_iter);",
          "    let result_empty = either_empty.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(result_empty, 0.0);",
          "    let mixed_iter = Either::Left(LeftIter { values: vec![1.0], index: 0 });",
          "    let result_mixed = mixed_iter.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(result_mixed, 1.0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct LeftIter {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for LeftIter {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for LeftIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "    ",
          "    struct RightIter {",
          "        values: Vec<f32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for RightIter {",
          "        type Item = f32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for RightIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIter { values: vec![1, 2], index: 0 };",
          "    let right_iter = RightIter { values: vec![3.0, 4.0], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "",
          "    let result = either.rfold(0, |acc, x| acc + x);",
          "    ",
          "    let either = Either::Right(right_iter);",
          "    ",
          "    let result = either.rfold(0.0, |acc, x| acc + x);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Either::Left(LeftIter { values: vec![1, 2], index: 0 }).rfold(0, |acc, x| acc + x), 3);",
          "    assert_eq!(Either::Right(RightIter { values: vec![3.0, 4.0], index: 0 }).rfold(0.0, |acc, x| acc + x), 7.0);"
        ],
        "code": [
          "{",
          "    struct LeftIter {",
          "        values: Vec<i32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for LeftIter {",
          "        type Item = i32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for LeftIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "    ",
          "    struct RightIter {",
          "        values: Vec<f32>,",
          "        index: usize,",
          "    }",
          "",
          "    impl Iterator for RightIter {",
          "        type Item = f32;",
          "",
          "        fn next(&mut self) -> Option<Self::Item> {",
          "            if self.index < self.values.len() {",
          "                let value = self.values[self.index];",
          "                self.index += 1;",
          "                Some(value)",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    impl DoubleEndedIterator for RightIter {",
          "        fn next_back(&mut self) -> Option<Self::Item> {",
          "            if self.index > 0 {",
          "                self.index -= 1;",
          "                Some(self.values[self.index])",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "",
          "    let left_iter = LeftIter { values: vec![1, 2], index: 0 };",
          "    let right_iter = RightIter { values: vec![3.0, 4.0], index: 0 };",
          "    let either = Either::Left(left_iter);",
          "",
          "    let result = either.rfold(0, |acc, x| acc + x);",
          "    ",
          "    let either = Either::Right(right_iter);",
          "    ",
          "    let result = either.rfold(0.0, |acc, x| acc + x);",
          "    assert_eq!(Either::Left(LeftIter { values: vec![1, 2], index: 0 }).rfold(0, |acc, x| acc + x), 3);",
          "    assert_eq!(Either::Right(RightIter { values: vec![3.0, 4.0], index: 0 }).rfold(0.0, |acc, x| acc + x), 7.0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]