{
  "name": "hashbrown::raw::{impl#6}::to_base_index",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:74:1:74:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:336:5:364:6",
  "doc": "/// Calculates the index of a [`Bucket`] as distance between two pointers\n/// (convenience for `base.as_ptr().offset_from(self.ptr.as_ptr()) as usize`).\n/// The returned value is in units of T: the distance in bytes divided by\n/// [`core::mem::size_of::<T>()`].\n///\n/// If the `T` is a ZST, then we return the index of the element in\n/// the table so that `erase` works properly (return `self.ptr.as_ptr() as usize - 1`).\n///\n/// This function is the inverse of [`from_base_index`].\n///\n/// # Safety\n///\n/// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived\n/// from the safety rules for [`<*const T>::offset_from`] method of `*const T`.\n///\n/// Thus, in order to uphold the safety contracts for [`<*const T>::offset_from`]\n/// method, as well as for the correct logic of the work of this crate, the\n/// following rules are necessary and sufficient:\n///\n/// * `base` contained pointer must not be `dangling` and must point to the\n///   end of the first `element` from the `data part` of the table, i.e.\n///   must be a pointer that returns by [`RawTable::data_end`] or by\n///   [`RawTableInner::data_end<T>`];\n///\n/// * `self` also must not contain dangling pointer;\n///\n/// * both `self` and `base` must be created from the same [`RawTable`]\n///   (or [`RawTableInner`]).\n///\n/// If `mem::size_of::<T>() == 0`, this function is always safe.\n///\n/// [`Bucket`]: crate::raw::Bucket\n/// [`from_base_index`]: crate::raw::Bucket::from_base_index\n/// [`RawTable::data_end`]: crate::raw::RawTable::data_end\n/// [`RawTableInner::data_end<T>`]: RawTableInner::data_end<T>\n/// [`RawTable`]: crate::raw::RawTable\n/// [`RawTableInner`]: RawTableInner\n/// [`<*const T>::offset_from`]: https://doc.rust-lang.org/nightly/core/primitive.pointer.html#method.offset_from\n",
  "code": [
    "unsafe fn to_base_index(&self, base: NonNull<T>) -> usize {",
    "    // If mem::size_of::<T>() != 0 then return an index under which we used to store the",
    "    // `element` in the data part of the table (we start counting from \"0\", so",
    "    // that in the expression T[last], the \"last\" index actually is one less than the",
    "    // \"buckets\" number in the table, i.e. \"last = RawTableInner.bucket_mask\").",
    "    // For example for 5th element in table calculation is performed like this:",
    "    //",
    "    //                        mem::size_of::<T>()",
    "    //                          |",
    "    //                          |         `self = from_base_index(base, 5)` that returns pointer",
    "    //                          |         that points here in the data part of the table",
    "    //                          |         (to the end of T5)",
    "    //                          |           |                    `base: NonNull<T>` must point here",
    "    //                          v           |                    (to the end of T0 or to the start of C0)",
    "    //                        /???\\         v                      v",
    "    // [Padding], Tlast, ..., |T10|, ..., T5|, T4, T3, T2, T1, T0, |C0, C1, C2, C3, C4, C5, ..., C10, ..., Clast",
    "    //                                      \\__________  __________/",
    "    //                                                 \\/",
    "    //                                     `bucket.to_base_index(base)` = 5",
    "    //                                     (base.as_ptr() as usize - self.ptr.as_ptr() as usize) / mem::size_of::<T>()",
    "    //",
    "    // where: T0...Tlast - our stored data; C0...Clast - control bytes or metadata for data.",
    "    if T::IS_ZERO_SIZED {",
    "        // this can not be UB",
    "        self.ptr.as_ptr() as usize - 1",
    "    } else {",
    "        offset_from(base.as_ptr(), self.ptr.as_ptr())",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "T::IS_ZERO_SIZED",
          "norm": null,
          "value": "true",
          "line": 358,
          "bound": null
        }
      ],
      "ret": "self.ptr.as_ptr() as usize - 1",
      "path": [
        0,
        1,
        2,
        3,
        8
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "T::IS_ZERO_SIZED",
          "norm": null,
          "value": "false",
          "line": 358,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        4,
        5,
        6,
        7,
        8
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}