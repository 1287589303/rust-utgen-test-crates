{
  "name": "hashbrown::raw::{impl#12}::replace_ctrl_hash",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:74:1:74:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:2389:5:2394:6",
  "doc": "/// Replaces the hash in the control byte at the given index with the provided one,\n/// and possibly also replicates the new control byte at the end of the array of control\n/// bytes, returning the old control byte.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// The safety rules are directly derived from the safety rules for [`RawTableInner::set_ctrl_hash`]\n/// and [`RawTableInner::ctrl`] methods. Thus, in order to uphold the safety contracts for both\n/// methods, you must observe the following rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n///\n/// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`RawTableInner::set_ctrl_hash`]: RawTableInner::set_ctrl_hash\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "code": [
    "unsafe fn replace_ctrl_hash(&mut self, index: usize, hash: u64) -> Tag {",
    "    // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::replace_ctrl_hash`]",
    "    let prev_ctrl = *self.ctrl(index);",
    "    self.set_ctrl_hash(index, hash);",
    "    prev_ctrl",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "prev_ctrl",
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}