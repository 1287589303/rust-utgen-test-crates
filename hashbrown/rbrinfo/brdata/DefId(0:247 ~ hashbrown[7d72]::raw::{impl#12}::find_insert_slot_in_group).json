{
  "name": "hashbrown::raw::{impl#12}::find_insert_slot_in_group",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:74:1:74:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:1602:5:1612:6",
  "doc": "/// Finds the position to insert something in a group.\n///\n/// **This may have false positives and must be fixed up with `fix_insert_slot`\n/// before it's used.**\n///\n/// The function is guaranteed to return the index of an empty or deleted [`Bucket`]\n/// in the range `0..self.buckets()` (`0..=self.bucket_mask`).\n",
  "code": [
    "fn find_insert_slot_in_group(&self, group: &Group, probe_seq: &ProbeSeq) -> Option<usize> {",
    "    let bit = group.match_empty_or_deleted().lowest_set_bit();",
    "",
    "    if likely(bit.is_some()) {",
    "        // This is the same as `(probe_seq.pos + bit) % self.buckets()` because the number",
    "        // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.",
    "        Some((probe_seq.pos + bit.unwrap()) & self.bucket_mask)",
    "    } else {",
    "        None",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "likely(bit.is_some())",
          "norm": null,
          "value": "true",
          "line": 1605,
          "bound": null
        }
      ],
      "ret": "Some((probe_seq.pos + bit.unwrap()) & self.bucket_mask)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        9
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "likely(bit.is_some())",
          "norm": null,
          "value": "false",
          "line": 1605,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        8,
        9
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}