{
  "name": "hashbrown::raw::{impl#8}::find_or_find_insert_slot",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:74:1:74:9"
  },
  "visible": true,
  "loc": "src/raw/mod.rs:1111:5:1136:6",
  "doc": "/// Searches for an element in the table. If the element is not found,\n/// returns `Err` with the position of a slot where an element with the\n/// same hash could be inserted.\n///\n/// This function may resize the table if additional space is required for\n/// inserting an element.\n",
  "code": [
    "pub fn find_or_find_insert_slot(",
    "    &mut self,",
    "    hash: u64,",
    "    mut eq: impl FnMut(&T) -> bool,",
    "    hasher: impl Fn(&T) -> u64,",
    ") -> Result<Bucket<T>, InsertSlot> {",
    "    self.reserve(1, hasher);",
    "",
    "    unsafe {",
    "        // SAFETY:",
    "        // 1. We know for sure that there is at least one empty `bucket` in the table.",
    "        // 2. The [`RawTableInner`] must already have properly initialized control bytes since we will",
    "        //    never expose `RawTable::new_uninitialized` in a public API.",
    "        // 3. The `find_or_find_insert_slot_inner` function returns the `index` of only the full bucket,",
    "        //    which is in the range `0..self.buckets()` (since there is at least one empty `bucket` in",
    "        //    the table), so calling `self.bucket(index)` and `Bucket::as_ref` is safe.",
    "        match self",
    "            .table",
    "            .find_or_find_insert_slot_inner(hash, &mut |index| eq(self.bucket(index).as_ref()))",
    "        {",
    "            // SAFETY: See explanation above.",
    "            Ok(index) => Ok(self.bucket(index)),",
    "            Err(slot) => Err(slot),",
    "        }",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self\n                .table\n                .find_or_find_insert_slot_inner(hash, &mut |index| eq(self.bucket(index).as_ref())) matches Err(slot)",
          "norm": null,
          "value": "true",
          "line": 1127,
          "bound": null
        }
      ],
      "ret": "Err(slot)",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self\n                .table\n                .find_or_find_insert_slot_inner(hash, &mut |index| eq(self.bucket(index).as_ref())) matches Ok(index)",
          "norm": null,
          "value": "true",
          "line": 1127,
          "bound": null
        },
        {
          "cond": "self\n                .table\n                .find_or_find_insert_slot_inner(hash, &mut |index| eq(self.bucket(index).as_ref())) matches Ok(index)",
          "norm": null,
          "value": "true",
          "line": 1127,
          "bound": null
        }
      ],
      "ret": "Ok(self.bucket(index))",
      "path": [
        0,
        1,
        2,
        4,
        6,
        7,
        8,
        9,
        10
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}