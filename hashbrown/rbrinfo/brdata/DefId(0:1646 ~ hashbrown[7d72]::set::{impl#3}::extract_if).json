{
  "name": "hashbrown::set::{impl#3}::extract_if",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:84:1:84:9"
  },
  "visible": true,
  "loc": "src/set.rs:404:5:415:6",
  "doc": "/// Drains elements which are true under the given predicate,\n/// and returns an iterator over the removed items.\n///\n/// In other words, move all elements `e` such that `f(&e)` returns `true` out\n/// into another iterator.\n///\n/// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n/// or the iteration short-circuits, then the remaining elements will be retained.\n/// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n///\n/// [`retain()`]: HashSet::retain\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<i32> = (0..8).collect();\n/// let drained: HashSet<i32> = set.extract_if(|v| v % 2 == 0).collect();\n///\n/// let mut evens = drained.into_iter().collect::<Vec<_>>();\n/// let mut odds = set.into_iter().collect::<Vec<_>>();\n/// evens.sort();\n/// odds.sort();\n///\n/// assert_eq!(evens, vec![0, 2, 4, 6]);\n/// assert_eq!(odds, vec![1, 3, 5, 7]);\n/// ```\n",
  "code": [
    "pub fn extract_if<F>(&mut self, f: F) -> ExtractIf<'_, T, F, A>",
    "where",
    "    F: FnMut(&T) -> bool,",
    "{",
    "    ExtractIf {",
    "        f,",
    "        inner: RawExtractIf {",
    "            iter: unsafe { self.map.table.iter() },",
    "            table: &mut self.map.table,",
    "        },",
    "    }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.map.table.iter() },\n                table: &mut self.map.table,\n            },\n        }",
      "path": [
        0,
        1,
        2,
        3
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}