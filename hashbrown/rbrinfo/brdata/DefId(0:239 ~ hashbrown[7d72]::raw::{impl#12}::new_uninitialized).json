{
  "name": "hashbrown::raw::{impl#12}::new_uninitialized",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:74:1:74:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:1430:5:1460:6",
  "doc": "/// Allocates a new [`RawTableInner`] with the given number of buckets.\n/// The control bytes and buckets are left uninitialized.\n///\n/// # Safety\n///\n/// The caller of this function must ensure that the `buckets` is power of two\n/// and also initialize all control bytes of the length `self.bucket_mask + 1 +\n/// Group::WIDTH` with the [`Tag::EMPTY`] bytes.\n///\n/// See also [`Allocator`] API for other safety concerns.\n///\n/// [`Allocator`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html\n",
  "code": [
    "unsafe fn new_uninitialized<A>(",
    "    alloc: &A,",
    "    table_layout: TableLayout,",
    "    buckets: usize,",
    "    fallibility: Fallibility,",
    ") -> Result<Self, TryReserveError>",
    "where",
    "    A: Allocator,",
    "{",
    "    debug_assert!(buckets.is_power_of_two());",
    "",
    "    // Avoid `Option::ok_or_else` because it bloats LLVM IR.",
    "    let (layout, ctrl_offset) = match table_layout.calculate_layout_for(buckets) {",
    "        Some(lco) => lco,",
    "        None => return Err(fallibility.capacity_overflow()),",
    "    };",
    "",
    "    let ptr: NonNull<u8> = match do_alloc(alloc, layout) {",
    "        Ok(block) => block.cast(),",
    "        Err(_) => return Err(fallibility.alloc_err(layout)),",
    "    };",
    "",
    "    // SAFETY: null pointer will be caught in above check",
    "    let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));",
    "    Ok(Self {",
    "        ctrl,",
    "        bucket_mask: buckets - 1,",
    "        items: 0,",
    "        growth_left: bucket_mask_to_capacity(buckets - 1),",
    "    })",
    "}"
  ],
  "size": {
    "chain": 4,
    "contra": 0,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "buckets.is_power_of_two()",
          "norm": null,
          "value": "true",
          "line": 1439,
          "bound": null
        },
        {
          "cond": "table_layout.calculate_layout_for(buckets) matches Some(lco)",
          "norm": null,
          "value": "true",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "table_layout.calculate_layout_for(buckets) matches Some(lco)",
          "norm": null,
          "value": "true",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "do_alloc(alloc, layout) matches Err(_)",
          "norm": null,
          "value": "true",
          "line": 1447,
          "bound": null
        }
      ],
      "ret": "Err(fallibility.alloc_err(layout))",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        9,
        11,
        13,
        16,
        19,
        26
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "buckets.is_power_of_two()",
          "norm": null,
          "value": "true",
          "line": 1439,
          "bound": null
        },
        {
          "cond": "table_layout.calculate_layout_for(buckets) matches Some(lco)",
          "norm": null,
          "value": "true",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "table_layout.calculate_layout_for(buckets) matches Some(lco)",
          "norm": null,
          "value": "true",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "do_alloc(alloc, layout) matches Ok(block)",
          "norm": null,
          "value": "true",
          "line": 1447,
          "bound": null
        },
        {
          "cond": "do_alloc(alloc, layout) matches Ok(block)",
          "norm": null,
          "value": "true",
          "line": 1447,
          "bound": null
        }
      ],
      "ret": "Ok(Self {\n            ctrl,\n            bucket_mask: buckets - 1,\n            items: 0,\n            growth_left: bucket_mask_to_capacity(buckets - 1),\n        })",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        9,
        11,
        13,
        15,
        17,
        18,
        20,
        21,
        22,
        23,
        24,
        25,
        26
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "buckets.is_power_of_two()",
          "norm": null,
          "value": "true",
          "line": 1439,
          "bound": null
        },
        {
          "cond": "table_layout.calculate_layout_for(buckets) matches None",
          "norm": null,
          "value": "true",
          "line": 1442,
          "bound": null
        }
      ],
      "ret": "Err(fallibility.capacity_overflow())",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        10,
        12,
        26
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "buckets.is_power_of_two()",
          "norm": null,
          "value": "false",
          "line": 1439,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        27
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}