{
  "name": "hashbrown::map::{impl#5}::try_insert",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:78:1:78:9"
  },
  "visible": true,
  "loc": "src/map.rs:1915:5:1924:6",
  "doc": "/// Tries to insert a key-value pair into the map, and returns\n/// a mutable reference to the value in the entry.\n///\n/// # Errors\n///\n/// If the map already had this key present, nothing is updated, and\n/// an error containing the occupied entry and the value is returned.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::OccupiedError;\n///\n/// let mut map = HashMap::new();\n/// assert_eq!(map.try_insert(37, \"a\").unwrap(), &\"a\");\n///\n/// match map.try_insert(37, \"b\") {\n///     Err(OccupiedError { entry, value }) => {\n///         assert_eq!(entry.key(), &37);\n///         assert_eq!(entry.get(), &\"a\");\n///         assert_eq!(value, \"b\");\n///     }\n///     _ => panic!()\n/// }\n/// ```\n",
  "code": [
    "pub fn try_insert(",
    "    &mut self,",
    "    key: K,",
    "    value: V,",
    ") -> Result<&mut V, OccupiedError<'_, K, V, S, A>> {",
    "    match self.entry(key) {",
    "        Entry::Occupied(entry) => Err(OccupiedError { entry, value }),",
    "        Entry::Vacant(entry) => Ok(entry.insert(value)),",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.entry(key) matches Entry::Vacant(entry)",
          "norm": null,
          "value": "true",
          "line": 1920,
          "bound": null
        }
      ],
      "ret": "Ok(entry.insert(value))",
      "path": [
        0,
        1,
        4,
        8,
        9,
        10,
        11,
        12,
        13
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.entry(key) matches Entry::Occupied(entry)",
          "norm": null,
          "value": "true",
          "line": 1920,
          "bound": null
        },
        {
          "cond": "self.entry(key) matches Entry::Occupied(entry)",
          "norm": null,
          "value": "true",
          "line": 1920,
          "bound": null
        }
      ],
      "ret": "Err(OccupiedError { entry, value })",
      "path": [
        0,
        1,
        3,
        5,
        6,
        7,
        10,
        11,
        12,
        13
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}