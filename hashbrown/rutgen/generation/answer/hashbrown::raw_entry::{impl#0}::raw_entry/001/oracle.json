[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HashMap<String, i32> = HashMap::new();",
          "    map.insert(\"key1\".to_string(), 10);",
          "    map.insert(\"key2\".to_string(), 20);",
          "    map.insert(\"key3\".to_string(), 30);",
          "",
          "    let entry_builder = map.raw_entry();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entry_builder.map, &map);",
          "    assert!(entry_builder.map.table.table.is_empty() == false);",
          "    assert!(entry_builder.map.hash_builder.is_some());",
          "    assert!(map.raw_entry().is::<RawEntryBuilder<String, i32, DefaultHashBuilder, Global>>());",
          "    assert!(entry_builder.map.raw_entry().map.is::<HashMap<String, i32>>());"
        ],
        "code": [
          "{",
          "    let mut map: HashMap<String, i32> = HashMap::new();",
          "    map.insert(\"key1\".to_string(), 10);",
          "    map.insert(\"key2\".to_string(), 20);",
          "    map.insert(\"key3\".to_string(), 30);",
          "",
          "    let entry_builder = map.raw_entry();",
          "    assert_eq!(entry_builder.map, &map);",
          "    assert!(entry_builder.map.table.table.is_empty() == false);",
          "    assert!(entry_builder.map.hash_builder.is_some());",
          "    assert!(map.raw_entry().is::<RawEntryBuilder<String, i32, DefaultHashBuilder, Global>>());",
          "    assert!(entry_builder.map.raw_entry().map.is::<HashMap<String, i32>>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HashMap<i32, String> = HashMap::new();",
          "    map.insert(1, \"value1\".to_string());",
          "    map.insert(2, \"value2\".to_string());",
          "    map.insert(3, \"value3\".to_string());",
          "",
          "    let entry_builder = map.raw_entry();",
          "}"
        ],
        "oracle": [
          "    assert!(entry_builder.map.is_some());",
          "    assert_eq!(entry_builder.map.table.len(), 3);",
          "    assert_eq!(entry_builder.map.hash_builder, map.hash_builder);",
          "    assert_eq!(entry_builder.map.alloc, map.alloc);"
        ],
        "code": [
          "{",
          "    let mut map: HashMap<i32, String> = HashMap::new();",
          "    map.insert(1, \"value1\".to_string());",
          "    map.insert(2, \"value2\".to_string());",
          "    map.insert(3, \"value3\".to_string());",
          "",
          "    let entry_builder = map.raw_entry();",
          "    assert!(entry_builder.map.is_some());",
          "    assert_eq!(entry_builder.map.table.len(), 3);",
          "    assert_eq!(entry_builder.map.hash_builder, map.hash_builder);",
          "    assert_eq!(entry_builder.map.alloc, map.alloc);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HashMap<(i32, i32), f64> = HashMap::new();",
          "    map.insert((1, 2), 1.5);",
          "    map.insert((3, 4), 2.5);",
          "    map.insert((5, 6), 3.5);",
          "",
          "    let entry_builder = map.raw_entry();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entry_builder.map, &map);",
          "    assert!(entry_builder.map.table.is_empty() == false);",
          "    assert!(entry_builder.map.hash_builder.is_some());",
          "    assert_eq!(map.raw_entry().from_key(&(1, 2)), Some((&(1, 2), &1.5)));",
          "    assert_eq!(map.raw_entry().from_hash(0, |&(x, y)| (x, y) == (1, 2)), Some((&(1, 2), &1.5)));",
          "    assert_eq!(map.raw_entry().from_key_hashed_nocheck(0, &(1, 2)), Some((&(1, 2), &1.5)));",
          "    assert_eq!(map.raw_entry().from_key(&(3, 4)), Some((&(3, 4), &2.5)));",
          "    assert_eq!(map.raw_entry().from_key(&(5, 6)), Some((&(5, 6), &3.5)));",
          "    assert_eq!(map.raw_entry().from_key(&(7, 8)), None);"
        ],
        "code": [
          "{",
          "    let mut map: HashMap<(i32, i32), f64> = HashMap::new();",
          "    map.insert((1, 2), 1.5);",
          "    map.insert((3, 4), 2.5);",
          "    map.insert((5, 6), 3.5);",
          "",
          "    let entry_builder = map.raw_entry();",
          "    assert_eq!(entry_builder.map, &map);",
          "    assert!(entry_builder.map.table.is_empty() == false);",
          "    assert!(entry_builder.map.hash_builder.is_some());",
          "    assert_eq!(map.raw_entry().from_key(&(1, 2)), Some((&(1, 2), &1.5)));",
          "    assert_eq!(map.raw_entry().from_hash(0, |&(x, y)| (x, y) == (1, 2)), Some((&(1, 2), &1.5)));",
          "    assert_eq!(map.raw_entry().from_key_hashed_nocheck(0, &(1, 2)), Some((&(1, 2), &1.5)));",
          "    assert_eq!(map.raw_entry().from_key(&(3, 4)), Some((&(3, 4), &2.5)));",
          "    assert_eq!(map.raw_entry().from_key(&(5, 6)), Some((&(5, 6), &3.5)));",
          "    assert_eq!(map.raw_entry().from_key(&(7, 8)), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HashMap<String, String> = HashMap::new();",
          "    map.insert(\"\".to_string(), \"\".to_string());",
          "",
          "    let entry_builder = map.raw_entry();",
          "}"
        ],
        "oracle": [
          "    assert!(entry_builder.map == &map);",
          "    assert_eq!(std::mem::size_of::<RawEntryBuilder<String, String>>(), std::mem::size_of::<RawEntryBuilder<String, String>>());",
          "    assert_eq!(std::mem::align_of::<RawEntryBuilder<String, String>>(), std::mem::align_of::<RawEntryBuilder<String, String>>());",
          "    assert!(entry_builder.map.table.table.is_empty());"
        ],
        "code": [
          "{",
          "    let mut map: HashMap<String, String> = HashMap::new();",
          "    map.insert(\"\".to_string(), \"\".to_string());",
          "",
          "    let entry_builder = map.raw_entry();",
          "    assert!(entry_builder.map == &map);",
          "    assert_eq!(std::mem::size_of::<RawEntryBuilder<String, String>>(), std::mem::size_of::<RawEntryBuilder<String, String>>());",
          "    assert_eq!(std::mem::align_of::<RawEntryBuilder<String, String>>(), std::mem::align_of::<RawEntryBuilder<String, String>>());",
          "    assert!(entry_builder.map.table.table.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HashMap<Vec<u8>, Vec<u8>> = HashMap::new();",
          "    let large_key = vec![0u8; 1000];",
          "    let large_value = vec![1u8; 1000];",
          "    map.insert(large_key.clone(), large_value.clone());",
          "",
          "    let entry_builder = map.raw_entry();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entry_builder.map, &map);",
          "    assert!(entry_builder.map.table.is_empty());",
          "    assert!(entry_builder.map.hash_builder.is_some());",
          "    assert!(entry_builder.map.alloc.is_initialized());",
          "    assert_eq!(entry_builder.map.table.capacity(), 0);",
          "    assert!(entry_builder.map.table.len() == 0);"
        ],
        "code": [
          "{",
          "    let mut map: HashMap<Vec<u8>, Vec<u8>> = HashMap::new();",
          "    let large_key = vec![0u8; 1000];",
          "    let large_value = vec![1u8; 1000];",
          "    map.insert(large_key.clone(), large_value.clone());",
          "",
          "    let entry_builder = map.raw_entry();",
          "    assert_eq!(entry_builder.map, &map);",
          "    assert!(entry_builder.map.table.is_empty());",
          "    assert!(entry_builder.map.hash_builder.is_some());",
          "    assert!(entry_builder.map.alloc.is_initialized());",
          "    assert_eq!(entry_builder.map.table.capacity(), 0);",
          "    assert!(entry_builder.map.table.len() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]