[
  {
    "uses": [
      "use hashbrown::HashTable;",
      "use hashbrown::DefaultHashBuilder;",
      "use std::hash::BuildHasher;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<&str> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    let entry = table",
          "        .entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher)",
          "        .insert(\"test_value\");",
          "",
          "    let retrieved_value = entry.get();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(retrieved_value, &\"test_value\");",
          "    assert!(table.entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher).is_occupied());",
          "    assert!(table.entry(hasher(&\"not_exist_key\"), |&x| x == \"not_exist_key\", hasher).is_vacant());",
          "    assert_eq!(table.len(), 1);",
          "    assert!(table.entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher).is_occupied());",
          "    entry.insert(\"new_value\");",
          "    assert_eq!(entry.get(), &\"new_value\");"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<&str> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    let entry = table",
          "        .entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher)",
          "        .insert(\"test_value\");",
          "",
          "    let retrieved_value = entry.get();",
          "    assert_eq!(retrieved_value, &\"test_value\");",
          "    assert!(table.entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher).is_occupied());",
          "    assert!(table.entry(hasher(&\"not_exist_key\"), |&x| x == \"not_exist_key\", hasher).is_vacant());",
          "    assert_eq!(table.len(), 1);",
          "    assert!(table.entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher).is_occupied());",
          "    entry.insert(\"new_value\");",
          "    assert_eq!(entry.get(), &\"new_value\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<i32> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    let entry = table",
          "        .entry(hasher(&1), |&x| x == &1, hasher)",
          "        .insert(100);",
          "",
          "    let retrieved_value = entry.get();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(retrieved_value, &100);",
          "    assert!(matches!(entry, Entry::Occupied(_)));",
          "    assert_eq!(table.len(), 1);",
          "    assert!(table.contains_key(&1));",
          "    assert_eq!(table.get(&1), Some(&100));",
          "    table.insert(hasher(&2), 200);",
          "    let entry2 = table.entry(hasher(&2), |&x| x == &2, hasher).insert(300);",
          "    assert_eq!(entry2.get(), &300);",
          "    assert!(matches!(entry2, Entry::Occupied(_)));"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<i32> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    let entry = table",
          "        .entry(hasher(&1), |&x| x == &1, hasher)",
          "        .insert(100);",
          "",
          "    let retrieved_value = entry.get();",
          "    assert_eq!(retrieved_value, &100);",
          "    assert!(matches!(entry, Entry::Occupied(_)));",
          "    assert_eq!(table.len(), 1);",
          "    assert!(table.contains_key(&1));",
          "    assert_eq!(table.get(&1), Some(&100));",
          "    table.insert(hasher(&2), 200);",
          "    let entry2 = table.entry(hasher(&2), |&x| x == &2, hasher).insert(300);",
          "    assert_eq!(entry2.get(), &300);",
          "    assert!(matches!(entry2, Entry::Occupied(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(i32, i32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    let entry = table",
          "        .entry(hasher(&(1, 2)), |&x| x == &(1, 2), hasher)",
          "        .insert((1, 2));",
          "",
          "    let retrieved_value = entry.get();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(retrieved_value, &(1, 2));",
          "    assert_eq!(table.len(), 1);",
          "    assert!(matches!(table.entry(hasher(&(1, 2)), |&x| x == &(1, 2), hasher), Entry::Occupied(_)));",
          "    let entry_after_insert = table.entry(hasher(&(1, 2)), |&x| x == &(1, 2), hasher);",
          "    assert!(matches!(entry_after_insert, Entry::Occupied(_)));",
          "    let entry_for_different_key = table.entry(hasher(&(2, 3)), |&x| x == &(2, 3), hasher);",
          "    assert!(matches!(entry_for_different_key, Entry::Vacant(_)));"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(i32, i32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    let entry = table",
          "        .entry(hasher(&(1, 2)), |&x| x == &(1, 2), hasher)",
          "        .insert((1, 2));",
          "",
          "    let retrieved_value = entry.get();",
          "    assert_eq!(retrieved_value, &(1, 2));",
          "    assert_eq!(table.len(), 1);",
          "    assert!(matches!(table.entry(hasher(&(1, 2)), |&x| x == &(1, 2), hasher), Entry::Occupied(_)));",
          "    let entry_after_insert = table.entry(hasher(&(1, 2)), |&x| x == &(1, 2), hasher);",
          "    assert!(matches!(entry_after_insert, Entry::Occupied(_)));",
          "    let entry_for_different_key = table.entry(hasher(&(2, 3)), |&x| x == &(2, 3), hasher);",
          "    assert!(matches!(entry_for_different_key, Entry::Vacant(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]