[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    ",
          "    impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
          "            Ok(NonNull::dangling())",
          "        }",
          "",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "    ",
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 12);",
          "    ",
          "    if let OccupiedEntry { elem: Bucket { ptr }, .. } = map.entry(\"poneyland\").or_insert(12) {",
          "        let mut entry = OccupiedEntry {",
          "            hash: 0,",
          "            elem: Bucket { ptr },",
          "            table: &mut map,",
          "        };",
          "",
          "        unsafe {",
          "            let val_mut: &mut u32 = entry.get_mut();",
          "            *val_mut += 10;",
          "        }",
          "    }",
          "}"
        ],
        "oracle": [
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 12);",
          "    let mut entry = OccupiedEntry { hash: 0, elem: Bucket { ptr: NonNull::dangling() }, table: &mut map };",
          "    let val_mut: &mut u32 = entry.get_mut();",
          "    assert_eq!(*val_mut, 12);",
          "    *val_mut += 10;",
          "    assert_eq!(*val_mut, 22);",
          "    let val_mut2: &mut u32 = entry.get_mut();",
          "    assert_eq!(*val_mut2, 22);",
          "    *val_mut2 += 2;",
          "    assert_eq!(*val_mut2, 24);",
          "    assert_eq!(map[\"poneyland\"], 24);"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    ",
          "    impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
          "            Ok(NonNull::dangling())",
          "        }",
          "",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "    ",
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 12);",
          "    ",
          "    if let OccupiedEntry { elem: Bucket { ptr }, .. } = map.entry(\"poneyland\").or_insert(12) {",
          "        let mut entry = OccupiedEntry {",
          "            hash: 0,",
          "            elem: Bucket { ptr },",
          "            table: &mut map,",
          "        };",
          "",
          "        unsafe {",
          "            let val_mut: &mut u32 = entry.get_mut();",
          "            *val_mut += 10;",
          "        }",
          "    }",
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 12);",
          "    let mut entry = OccupiedEntry { hash: 0, elem: Bucket { ptr: NonNull::dangling() }, table: &mut map };",
          "    let val_mut: &mut u32 = entry.get_mut();",
          "    assert_eq!(*val_mut, 12);",
          "    *val_mut += 10;",
          "    assert_eq!(*val_mut, 22);",
          "    let val_mut2: &mut u32 = entry.get_mut();",
          "    assert_eq!(*val_mut2, 22);",
          "    *val_mut2 += 2;",
          "    assert_eq!(*val_mut2, 24);",
          "    assert_eq!(map[\"poneyland\"], 24);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    ",
          "    impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
          "            Ok(NonNull::dangling())",
          "        }",
          "",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 12);",
          "    ",
          "    if let OccupiedEntry { elem: Bucket { ptr }, .. } = map.entry(\"poneyland\").or_insert(12) {",
          "        let mut entry = OccupiedEntry {",
          "            hash: 0,",
          "            elem: Bucket { ptr },",
          "            table: &mut map,",
          "        };",
          "",
          "        unsafe {",
          "            for _ in 0..3 {",
          "                let val_mut: &mut u32 = entry.get_mut();",
          "                *val_mut += 5;",
          "            }",
          "        }",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(*entry.get(), 27);",
          "    let val_mut = entry.get_mut();",
          "    assert_eq!(val_mut as *mut _, unsafe { &mut entry.elem.as_mut().1 as *mut _ });",
          "    assert_eq!(std::mem::size_of_val(val_mut), std::mem::size_of::<u32>());",
          "    assert!(!val_mut.is_null());",
          "    let initial_value = entry.get_mut();",
          "    *initial_value += 3;",
          "    assert_eq!(*entry.get(), 30);",
          "    assert_eq!(entry.get_mut() as *mut _, initial_value as *mut _);",
          "    let value_pointer: *mut u32 = entry.get_mut();",
          "    assert_eq!(*value_pointer, 30);",
          "    assert_ne!(value_pointer, unsafe { &mut entry.elem.as_mut().1 as *mut _ });"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    ",
          "    impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
          "            Ok(NonNull::dangling())",
          "        }",
          "",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 12);",
          "    ",
          "    if let OccupiedEntry { elem: Bucket { ptr }, .. } = map.entry(\"poneyland\").or_insert(12) {",
          "        let mut entry = OccupiedEntry {",
          "            hash: 0,",
          "            elem: Bucket { ptr },",
          "            table: &mut map,",
          "        };",
          "",
          "        unsafe {",
          "            for _ in 0..3 {",
          "                let val_mut: &mut u32 = entry.get_mut();",
          "                *val_mut += 5;",
          "            }",
          "        }",
          "    }",
          "    assert_eq!(*entry.get(), 27);",
          "    let val_mut = entry.get_mut();",
          "    assert_eq!(val_mut as *mut _, unsafe { &mut entry.elem.as_mut().1 as *mut _ });",
          "    assert_eq!(std::mem::size_of_val(val_mut), std::mem::size_of::<u32>());",
          "    assert!(!val_mut.is_null());",
          "    let initial_value = entry.get_mut();",
          "    *initial_value += 3;",
          "    assert_eq!(*entry.get(), 30);",
          "    assert_eq!(entry.get_mut() as *mut _, initial_value as *mut _);",
          "    let value_pointer: *mut u32 = entry.get_mut();",
          "    assert_eq!(*value_pointer, 30);",
          "    assert_ne!(value_pointer, unsafe { &mut entry.elem.as_mut().1 as *mut _ });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    ",
          "    impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
          "            Ok(NonNull::dangling())",
          "        }",
          "",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 0); // boundary case with initial value of 0",
          "    ",
          "    if let OccupiedEntry { elem: Bucket { ptr }, .. } = map.entry(\"poneyland\").or_insert(0) {",
          "        let mut entry = OccupiedEntry {",
          "            hash: 0,",
          "            elem: Bucket { ptr },",
          "            table: &mut map,",
          "        };",
          "",
          "        unsafe {",
          "            let val_mut: &mut u32 = entry.get_mut();",
          "            *val_mut += 1; // should still be safe as it is occupied.",
          "        }",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map[\"poneyland\"], 1);",
          "    assert!(matches!(map.entry(\"poneyland\").or_insert(0), OccupiedEntry { .. }));",
          "    let mut entry = map.entry(\"poneyland\").or_insert(0);",
          "    let val_mut: &mut u32 = entry.get_mut();",
          "    *val_mut += 5;",
          "    assert_eq!(map[\"poneyland\"], 6);",
          "    let val_mut2: &mut u32 = entry.get_mut();",
          "    *val_mut2 += 3;",
          "    assert_eq!(map[\"poneyland\"], 9);",
          "    let val_mut3: &mut u32 = entry.get_mut();",
          "    *val_mut3 += 10;",
          "    assert_eq!(map[\"poneyland\"], 19);"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    ",
          "    impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
          "            Ok(NonNull::dangling())",
          "        }",
          "",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let mut map: HashMap<&str, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
          "    map.insert(\"poneyland\", 0); // boundary case with initial value of 0",
          "    ",
          "    if let OccupiedEntry { elem: Bucket { ptr }, .. } = map.entry(\"poneyland\").or_insert(0) {",
          "        let mut entry = OccupiedEntry {",
          "            hash: 0,",
          "            elem: Bucket { ptr },",
          "            table: &mut map,",
          "        };",
          "",
          "        unsafe {",
          "            let val_mut: &mut u32 = entry.get_mut();",
          "            *val_mut += 1; // should still be safe as it is occupied.",
          "        }",
          "    }",
          "    assert_eq!(map[\"poneyland\"], 1);",
          "    assert!(matches!(map.entry(\"poneyland\").or_insert(0), OccupiedEntry { .. }));",
          "    let mut entry = map.entry(\"poneyland\").or_insert(0);",
          "    let val_mut: &mut u32 = entry.get_mut();",
          "    *val_mut += 5;",
          "    assert_eq!(map[\"poneyland\"], 6);",
          "    let val_mut2: &mut u32 = entry.get_mut();",
          "    *val_mut2 += 3;",
          "    assert_eq!(map[\"poneyland\"], 9);",
          "    let val_mut3: &mut u32 = entry.get_mut();",
          "    *val_mut3 += 10;",
          "    assert_eq!(map[\"poneyland\"], 19);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]