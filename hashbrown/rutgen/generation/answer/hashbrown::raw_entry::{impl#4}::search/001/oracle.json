[
  {
    "uses": [
      "use crate::hashbrown::HashMap;",
      "use std::hash::Hash;",
      "use std::hash::Hasher;",
      "use std::collections::hash_map::DefaultHasher;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::hashbrown::HashMap;",
          "    use std::collections::hash_map::DefaultHasher;",
          "    use std::hash::{Hash, Hasher};",
          "",
          "    let mut map: HashMap<&str, i32> = HashMap::new();",
          "    map.insert(\"a\", 100);",
          "",
          "    let hash = {",
          "        let mut hasher = DefaultHasher::new();",
          "        \"a\".hash(&mut hasher);",
          "        hasher.finish()",
          "    };",
          "",
          "    let result = {",
          "        let builder = RawEntryBuilderMut { map: &mut map };",
          "        builder.search(hash, |key| key == &\"a\")",
          "    };",
          "",
          "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(result, RawEntryMut::Occupied(_)));",
          "    let occupied_entry = if let RawEntryMut::Occupied(entry) = result { entry } else { panic!(\"Expected an occupied entry\") };",
          "    assert_eq!(occupied_entry.elem.ptr.as_ref(), &(\"a\", 100));",
          "    assert_eq!(occupied_entry.table, &mut map.table);",
          "    assert_eq!(occupied_entry.hash_builder, &map.hash_builder);"
        ],
        "code": [
          "{",
          "    use crate::hashbrown::HashMap;",
          "    use std::collections::hash_map::DefaultHasher;",
          "    use std::hash::{Hash, Hasher};",
          "",
          "    let mut map: HashMap<&str, i32> = HashMap::new();",
          "    map.insert(\"a\", 100);",
          "",
          "    let hash = {",
          "        let mut hasher = DefaultHasher::new();",
          "        \"a\".hash(&mut hasher);",
          "        hasher.finish()",
          "    };",
          "",
          "    let result = {",
          "        let builder = RawEntryBuilderMut { map: &mut map };",
          "        builder.search(hash, |key| key == &\"a\")",
          "    };",
          "",
          "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
          "    assert!(matches!(result, RawEntryMut::Occupied(_)));",
          "    let occupied_entry = if let RawEntryMut::Occupied(entry) = result { entry } else { panic!(\"Expected an occupied entry\") };",
          "    assert_eq!(occupied_entry.elem.ptr.as_ref(), &(\"a\", 100));",
          "    assert_eq!(occupied_entry.table, &mut map.table);",
          "    assert_eq!(occupied_entry.hash_builder, &map.hash_builder);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::hashbrown::HashMap;",
          "    use std::collections::hash_map::DefaultHasher;",
          "    use std::hash::{Hash, Hasher};",
          "",
          "    let mut map: HashMap<&str, i32> = HashMap::new();",
          "    map.insert(\"b\", 200);",
          "",
          "    let hash = {",
          "        let mut hasher = DefaultHasher::new();",
          "        \"b\".hash(&mut hasher);",
          "        hasher.finish()",
          "    };",
          "",
          "    let result = {",
          "        let builder = RawEntryBuilderMut { map: &mut map };",
          "        builder.search(hash, |key| key == &\"b\")",
          "    };",
          "",
          "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(result, RawEntryMut::Occupied(_)));",
          "    assert_eq!(if let RawEntryMut::Occupied(entry) = result { entry.elem } else { panic!(\"Expected Occupied entry\") }, /* expected occupied entry value here */);",
          "    assert_eq!(result.hash_builder, &map.hash_builder);",
          "    assert_eq!(result.table, &mut map.table);"
        ],
        "code": [
          "{",
          "    use crate::hashbrown::HashMap;",
          "    use std::collections::hash_map::DefaultHasher;",
          "    use std::hash::{Hash, Hasher};",
          "",
          "    let mut map: HashMap<&str, i32> = HashMap::new();",
          "    map.insert(\"b\", 200);",
          "",
          "    let hash = {",
          "        let mut hasher = DefaultHasher::new();",
          "        \"b\".hash(&mut hasher);",
          "        hasher.finish()",
          "    };",
          "",
          "    let result = {",
          "        let builder = RawEntryBuilderMut { map: &mut map };",
          "        builder.search(hash, |key| key == &\"b\")",
          "    };",
          "",
          "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
          "    assert!(matches!(result, RawEntryMut::Occupied(_)));",
          "    assert_eq!(if let RawEntryMut::Occupied(entry) = result { entry.elem } else { panic!(\"Expected Occupied entry\") }, /* expected occupied entry value here */);",
          "    assert_eq!(result.hash_builder, &map.hash_builder);",
          "    assert_eq!(result.table, &mut map.table);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]