[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    unsafe impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> { Ok(NonNull::dangling()) }",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let allocator = TestAllocator;",
          "    let buckets = 3; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "        RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(std::panic::catch_unwind(|| {",
          "    let allocator = TestAllocator;",
          "    let buckets = 3; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "    let _table = RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "    }).is_err(), true);"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    unsafe impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> { Ok(NonNull::dangling()) }",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let allocator = TestAllocator;",
          "    let buckets = 3; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "        RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "    assert_eq!(std::panic::catch_unwind(|| {",
          "    let allocator = TestAllocator;",
          "    let buckets = 3; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "    let _table = RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "    }).is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    unsafe impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> { Ok(NonNull::dangling()) }",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let allocator = TestAllocator;",
          "    let buckets = 6; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "        RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(std::panic::catch_unwind(|| {",
          "    let allocator = TestAllocator;",
          "    let buckets = 6; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "    RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "    }).is_err(), true);"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    unsafe impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> { Ok(NonNull::dangling()) }",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let allocator = TestAllocator;",
          "    let buckets = 6; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "        RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "    assert_eq!(std::panic::catch_unwind(|| {",
          "    let allocator = TestAllocator;",
          "    let buckets = 6; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "    RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "    }).is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    unsafe impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> { Ok(NonNull::dangling()) }",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let allocator = TestAllocator;",
          "    let buckets = 10; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "        RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buckets.is_power_of_two(), false);",
          "    assert!(matches!(_table, Err(TryReserveError::CapacityOverflow)));"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    unsafe impl Allocator for TestAllocator {",
          "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> { Ok(NonNull::dangling()) }",
          "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}",
          "    }",
          "",
          "    let allocator = TestAllocator;",
          "    let buckets = 10; // Not a power of two",
          "    let fallibility = Fallibility::Fallible;",
          "",
          "    let _table: Result<RawTable<usize, TestAllocator>, TryReserveError> =",
          "        RawTable::new_uninitialized(allocator, buckets, fallibility);",
          "    assert_eq!(buckets.is_power_of_two(), false);",
          "    assert!(matches!(_table, Err(TryReserveError::CapacityOverflow)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]