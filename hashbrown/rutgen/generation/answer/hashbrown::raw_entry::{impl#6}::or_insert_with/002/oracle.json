[
  {
    "uses": [
      "use hashbrown::HashMap;",
      "use std::hash::BuildHasherDefault;",
      "use hashbrown::hash_map::RawEntryMut;",
      "use std::hash::Hash;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashMap, hash_map::RawEntryMut};",
          "    use std::hash::{BuildHasherDefault, Hash};",
          "    ",
          "    // Define a simple struct and implement Hash for it",
          "    #[derive(Hash, PartialEq, Eq)]",
          "    struct Key {",
          "        id: i32,",
          "    }",
          "    ",
          "    // Provide a default hasher",
          "    type DefaultHasher = BuildHasherDefault<core::hash::SipHasher>;",
          "",
          "    let mut map: HashMap<Key, String, DefaultHasher> = HashMap::new();",
          "    ",
          "    // Insert an initial key-value pair",
          "    map.insert(Key { id: 1 }, \"occupied\".to_string());",
          "    ",
          "    // Obtain a RawEntryMut and test or_insert_with on an occupied entry",
          "    let entry = map.raw_entry_mut().from_key(&Key { id: 1 });",
          "    match entry {",
          "        RawEntryMut::Occupied(entry) => {",
          "            entry.or_insert_with(|| (Key { id: 2 }, \"new_value\".to_string()));",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(entry.get_key_value().0 == &Key { id: 1 });",
          "    assert!(entry.get_key_value().1 == \"occupied\");",
          "    assert!(entry.get_mut() == &mut \"occupied\");",
          "    assert!(entry.key() == &Key { id: 1 });",
          "    assert!(entry.get() == &\"occupied\");"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashMap, hash_map::RawEntryMut};",
          "    use std::hash::{BuildHasherDefault, Hash};",
          "    ",
          "    // Define a simple struct and implement Hash for it",
          "    #[derive(Hash, PartialEq, Eq)]",
          "    struct Key {",
          "        id: i32,",
          "    }",
          "    ",
          "    // Provide a default hasher",
          "    type DefaultHasher = BuildHasherDefault<core::hash::SipHasher>;",
          "",
          "    let mut map: HashMap<Key, String, DefaultHasher> = HashMap::new();",
          "    ",
          "    // Insert an initial key-value pair",
          "    map.insert(Key { id: 1 }, \"occupied\".to_string());",
          "    ",
          "    // Obtain a RawEntryMut and test or_insert_with on an occupied entry",
          "    let entry = map.raw_entry_mut().from_key(&Key { id: 1 });",
          "    match entry {",
          "        RawEntryMut::Occupied(entry) => {",
          "            entry.or_insert_with(|| (Key { id: 2 }, \"new_value\".to_string()));",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "    assert!(entry.get_key_value().0 == &Key { id: 1 });",
          "    assert!(entry.get_key_value().1 == \"occupied\");",
          "    assert!(entry.get_mut() == &mut \"occupied\");",
          "    assert!(entry.key() == &Key { id: 1 });",
          "    assert!(entry.get() == &\"occupied\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashMap, hash_map::RawEntryMut};",
          "    use std::hash::{BuildHasherDefault, Hash};",
          "    ",
          "    #[derive(Hash, PartialEq, Eq)]",
          "    struct Key {",
          "        id: i32,",
          "    }",
          "",
          "    type DefaultHasher = BuildHasherDefault<core::hash::SipHasher>;",
          "",
          "    let mut map: HashMap<Key, String, DefaultHasher> = HashMap::new();",
          "    ",
          "    // Ensure there is a key-value pair so we can access an occupied entry",
          "    map.insert(Key { id: 1 }, \"occupied\".to_string());",
          "    ",
          "    // Access an existing occupied entry",
          "    let entry = map.raw_entry_mut().from_key(&Key { id: 1 });",
          "    match entry {",
          "        RawEntryMut::Occupied(entry) => {",
          "            entry.or_insert_with(|| (Key { id: 2 }, \"default_value\".to_string()));",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map[Key { id: 1 }], \"occupied\".to_string());",
          "    assert!(map.contains_key(&Key { id: 2 }));",
          "    assert_eq!(map[Key { id: 2 }], \"default_value\".to_string());",
          "    let entry_after = map.raw_entry_mut().from_key(&Key { id: 1 });",
          "    if let RawEntryMut::Occupied(entry) = entry_after {",
          "    assert_eq!(entry.get(), &\"occupied\".to_string());",
          "    assert!(entry.get_key_value().0.eq(&Key { id: 1 }));",
          "    } else {",
          "    unreachable!();",
          "    }"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashMap, hash_map::RawEntryMut};",
          "    use std::hash::{BuildHasherDefault, Hash};",
          "    ",
          "    #[derive(Hash, PartialEq, Eq)]",
          "    struct Key {",
          "        id: i32,",
          "    }",
          "",
          "    type DefaultHasher = BuildHasherDefault<core::hash::SipHasher>;",
          "",
          "    let mut map: HashMap<Key, String, DefaultHasher> = HashMap::new();",
          "    ",
          "    // Ensure there is a key-value pair so we can access an occupied entry",
          "    map.insert(Key { id: 1 }, \"occupied\".to_string());",
          "    ",
          "    // Access an existing occupied entry",
          "    let entry = map.raw_entry_mut().from_key(&Key { id: 1 });",
          "    match entry {",
          "        RawEntryMut::Occupied(entry) => {",
          "            entry.or_insert_with(|| (Key { id: 2 }, \"default_value\".to_string()));",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "    assert_eq!(map[Key { id: 1 }], \"occupied\".to_string());",
          "    assert!(map.contains_key(&Key { id: 2 }));",
          "    assert_eq!(map[Key { id: 2 }], \"default_value\".to_string());",
          "    let entry_after = map.raw_entry_mut().from_key(&Key { id: 1 });",
          "    if let RawEntryMut::Occupied(entry) = entry_after {",
          "    assert_eq!(entry.get(), &\"occupied\".to_string());",
          "    assert!(entry.get_key_value().0.eq(&Key { id: 1 }));",
          "    } else {",
          "    unreachable!();",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]