[
  {
    "uses": [
      "use hashbrown::HashMap;",
      "use hashbrown::raw_map::RawEntryMut;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashMap, raw_map::RawEntryMut};",
          "",
          "    let mut map: HashMap<&str, u32> = HashMap::new();",
          "    map.insert(\"k1\", 1);",
          "    map.insert(\"k2\", 2);",
          "",
          "    match map.raw_entry_mut().from_key(\"k1\") {",
          "        RawEntryMut::Occupied(entry) => {",
          "            let (key, value) = entry.or_insert(\"default_key\", 42);",
          "            // Function call doesn't need assertions as per instructions.",
          "            let _ = (key, value);",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map[\"k1\"], 1);",
          "    assert_eq!(map[\"k2\"], 2);",
          "    assert_eq!(map[\"default_key\"], 42);  // if \"default_key\" was accidentally inserted",
          "    assert_eq!(entry.get().1, &1);  // ensuring that value for \"k1\" remains unchanged",
          "    let (key, value) = entry.or_insert(\"new_key\", 100);",
          "    assert_eq!(key, &mut \"k1\");  // checking that the key returned is the original key",
          "    assert_eq!(value, &mut 1);  // ensuring value returned is still 1"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashMap, raw_map::RawEntryMut};",
          "",
          "    let mut map: HashMap<&str, u32> = HashMap::new();",
          "    map.insert(\"k1\", 1);",
          "    map.insert(\"k2\", 2);",
          "",
          "    match map.raw_entry_mut().from_key(\"k1\") {",
          "        RawEntryMut::Occupied(entry) => {",
          "            let (key, value) = entry.or_insert(\"default_key\", 42);",
          "            // Function call doesn't need assertions as per instructions.",
          "            let _ = (key, value);",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "    assert_eq!(map[\"k1\"], 1);",
          "    assert_eq!(map[\"k2\"], 2);",
          "    assert_eq!(map[\"default_key\"], 42);  // if \"default_key\" was accidentally inserted",
          "    assert_eq!(entry.get().1, &1);  // ensuring that value for \"k1\" remains unchanged",
          "    let (key, value) = entry.or_insert(\"new_key\", 100);",
          "    assert_eq!(key, &mut \"k1\");  // checking that the key returned is the original key",
          "    assert_eq!(value, &mut 1);  // ensuring value returned is still 1",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashMap, raw_map::RawEntryMut};",
          "",
          "    let mut map: HashMap<&str, u32> = HashMap::new();",
          "",
          "    match map.raw_entry_mut().from_key(\"k3\") {",
          "        RawEntryMut::Occupied(_) => unreachable!(),",
          "        RawEntryMut::Vacant(entry) => {",
          "            let (key, value) = entry.or_insert(\"k3\", 3);",
          "            // Function call doesn't need assertions as per instructions.",
          "            let _ = (key, value);",
          "        },",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(map.get(\"k3\").is_some());",
          "    assert_eq!(map[\"k3\"], 3);",
          "    ",
          "    match map.raw_entry_mut().from_key(\"k3\") {",
          "    RawEntryMut::Occupied(entry) => {",
          "    let (key, value) = entry.or_insert(\"k3\", 10);",
          "    assert_eq!(key, &\"k3\");",
          "    assert_eq!(*value, 3); // Ensure the value has not changed",
          "    },",
          "    RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "    ",
          "    *map.raw_entry_mut().from_key(\"k3\").or_insert(\"k3\", 10).1 *= 2;",
          "    assert_eq!(map[\"k3\"], 6);"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashMap, raw_map::RawEntryMut};",
          "",
          "    let mut map: HashMap<&str, u32> = HashMap::new();",
          "",
          "    match map.raw_entry_mut().from_key(\"k3\") {",
          "        RawEntryMut::Occupied(_) => unreachable!(),",
          "        RawEntryMut::Vacant(entry) => {",
          "            let (key, value) = entry.or_insert(\"k3\", 3);",
          "            // Function call doesn't need assertions as per instructions.",
          "            let _ = (key, value);",
          "        },",
          "    }",
          "    assert!(map.get(\"k3\").is_some());",
          "    assert_eq!(map[\"k3\"], 3);",
          "    ",
          "    match map.raw_entry_mut().from_key(\"k3\") {",
          "    RawEntryMut::Occupied(entry) => {",
          "    let (key, value) = entry.or_insert(\"k3\", 10);",
          "    assert_eq!(key, &\"k3\");",
          "    assert_eq!(*value, 3); // Ensure the value has not changed",
          "    },",
          "    RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "    ",
          "    *map.raw_entry_mut().from_key(\"k3\").or_insert(\"k3\", 10).1 *= 2;",
          "    assert_eq!(map[\"k3\"], 6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashMap, raw_map::RawEntryMut};",
          "",
          "    let mut map: HashMap<&str, u32> = HashMap::new();",
          "    map.insert(\"existing_key\", 10);",
          "",
          "    match map.raw_entry_mut().from_key(\"existing_key\") {",
          "        RawEntryMut::Occupied(entry) => {",
          "            let (key, value) = entry.or_insert(\"not_used\", 20);",
          "            // Function call doesn't need assertions as per instructions.",
          "            let _ = (key, value);",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "}"
        ],
        "oracle": [
          "    let map: HashMap<&str, u32> = HashMap::new();",
          "    map.insert(\"existing_key\", 10);",
          "    match map.raw_entry_mut().from_key(\"existing_key\") {",
          "    RawEntryMut::Occupied(entry) => {",
          "    let (key, value) = entry.or_insert(\"not_used\", 20);",
          "    assert_eq!(key, &\"existing_key\");",
          "    assert_eq!(*value, 10);",
          "    },",
          "    RawEntryMut::Vacant(_) => unreachable!(),",
          "    }"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashMap, raw_map::RawEntryMut};",
          "",
          "    let mut map: HashMap<&str, u32> = HashMap::new();",
          "    map.insert(\"existing_key\", 10);",
          "",
          "    match map.raw_entry_mut().from_key(\"existing_key\") {",
          "        RawEntryMut::Occupied(entry) => {",
          "            let (key, value) = entry.or_insert(\"not_used\", 20);",
          "            // Function call doesn't need assertions as per instructions.",
          "            let _ = (key, value);",
          "        },",
          "        RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "    let map: HashMap<&str, u32> = HashMap::new();",
          "    map.insert(\"existing_key\", 10);",
          "    match map.raw_entry_mut().from_key(\"existing_key\") {",
          "    RawEntryMut::Occupied(entry) => {",
          "    let (key, value) = entry.or_insert(\"not_used\", 20);",
          "    assert_eq!(key, &\"existing_key\");",
          "    assert_eq!(*value, 10);",
          "    },",
          "    RawEntryMut::Vacant(_) => unreachable!(),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]