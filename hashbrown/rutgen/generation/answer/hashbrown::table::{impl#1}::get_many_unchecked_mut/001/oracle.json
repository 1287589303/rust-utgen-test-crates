[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64; // simplistic hasher based on length",
          "    table.insert_unique(hasher(\"key1\"), (\"key1\", 1), |(k, _)| hasher(k));",
          "    table.insert_unique(hasher(\"key2\"), (\"key2\", 2), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"key1\", \"key2\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key2\")], |i, val| keys[i] == val.0);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(got, [Some(&mut (\"key1\", 1)), Some(&mut (\"key2\", 2))]);",
          "    let missing_keys = [\"key1\", \"key3\"];",
          "    let got_missing = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key3\")], |i, val| missing_keys[i] == val.0);",
          "    assert_eq!(got_missing, [Some(&mut (\"key1\", 1)), None]);",
          "    let empty_keys: [&str; 0] = [];",
          "    let got_empty = table.get_many_unchecked_mut([], |_, _| false);",
          "    assert_eq!(got_empty, []);",
          "    let overlapping_keys = [\"key1\", \"key1\"];",
          "    let got_overlapping = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key1\")], |i, val| overlapping_keys[i] == val.0);",
          "    // undefined behavior should not crash the test, simply do not assert anything specific for this case.",
          "    let keys_with_nonexistent = [\"key1\", \"nonexistent_key\"];",
          "    let got_nonexistent = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"nonexistent_key\")], |i, val| keys_with_nonexistent[i] == val.0);",
          "    assert_eq!(got_nonexistent, [Some(&mut (\"key1\", 1)), None]);"
        ],
        "code": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64; // simplistic hasher based on length",
          "    table.insert_unique(hasher(\"key1\"), (\"key1\", 1), |(k, _)| hasher(k));",
          "    table.insert_unique(hasher(\"key2\"), (\"key2\", 2), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"key1\", \"key2\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key2\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [Some(&mut (\"key1\", 1)), Some(&mut (\"key2\", 2))]);",
          "    let missing_keys = [\"key1\", \"key3\"];",
          "    let got_missing = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key3\")], |i, val| missing_keys[i] == val.0);",
          "    assert_eq!(got_missing, [Some(&mut (\"key1\", 1)), None]);",
          "    let empty_keys: [&str; 0] = [];",
          "    let got_empty = table.get_many_unchecked_mut([], |_, _| false);",
          "    assert_eq!(got_empty, []);",
          "    let overlapping_keys = [\"key1\", \"key1\"];",
          "    let got_overlapping = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key1\")], |i, val| overlapping_keys[i] == val.0);",
          "    // undefined behavior should not crash the test, simply do not assert anything specific for this case.",
          "    let keys_with_nonexistent = [\"key1\", \"nonexistent_key\"];",
          "    let got_nonexistent = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"nonexistent_key\")], |i, val| keys_with_nonexistent[i] == val.0);",
          "    assert_eq!(got_nonexistent, [Some(&mut (\"key1\", 1)), None]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64; // simplistic hasher based on length",
          "    table.insert_unique(hasher(\"key1\"), (\"key1\", 1), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"key1\", \"missing_key\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"missing_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(got, [Some(&mut (\"key1\", 1)), None]);"
        ],
        "code": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64; // simplistic hasher based on length",
          "    table.insert_unique(hasher(\"key1\"), (\"key1\", 1), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"key1\", \"missing_key\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"missing_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [Some(&mut (\"key1\", 1)), None]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64;",
          "    table.insert_unique(hasher(\"key1\"), (\"key1\", 1), |(k, _)| hasher(k));",
          "    table.insert_unique(hasher(\"key2\"), (\"key2\", 2), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"key1\", \"key1\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key1\")], |i, val| keys[i] == val.0);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(got[0], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got[1], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got.len(), 2);",
          "    ",
          "    let keys = [\"key1\", \"key3\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key3\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got[0], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got[1], None);",
          "    assert_eq!(got.len(), 2);",
          "    ",
          "    let keys = [\"key2\", \"key2\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"key2\"), hasher(\"key2\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got[0], Some(&mut (\"key2\", 2)));",
          "    assert_eq!(got[1], Some(&mut (\"key2\", 2)));",
          "    assert_eq!(got.len(), 2);",
          "    ",
          "    let keys = [\"key1\", \"key2\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key2\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got[0], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got[1], Some(&mut (\"key2\", 2)));",
          "    assert_eq!(got.len(), 2);"
        ],
        "code": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64;",
          "    table.insert_unique(hasher(\"key1\"), (\"key1\", 1), |(k, _)| hasher(k));",
          "    table.insert_unique(hasher(\"key2\"), (\"key2\", 2), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"key1\", \"key1\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key1\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got[0], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got[1], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got.len(), 2);",
          "    ",
          "    let keys = [\"key1\", \"key3\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key3\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got[0], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got[1], None);",
          "    assert_eq!(got.len(), 2);",
          "    ",
          "    let keys = [\"key2\", \"key2\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"key2\"), hasher(\"key2\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got[0], Some(&mut (\"key2\", 2)));",
          "    assert_eq!(got[1], Some(&mut (\"key2\", 2)));",
          "    assert_eq!(got.len(), 2);",
          "    ",
          "    let keys = [\"key1\", \"key2\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"key1\"), hasher(\"key2\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got[0], Some(&mut (\"key1\", 1)));",
          "    assert_eq!(got[1], Some(&mut (\"key2\", 2)));",
          "    assert_eq!(got.len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64;",
          "    table.insert_unique(hasher(\"boundary_key\"), (\"boundary_key\", 100), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"boundary_key\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"boundary_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(got, [Some(&mut (\"boundary_key\", 100))]);",
          "    let keys = [\"boundary_key\", \"non_existent_key\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"boundary_key\"), hasher(\"non_existent_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [Some(&mut (\"boundary_key\", 100)), None]);",
          "    let keys = [\"non_existent_key\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"non_existent_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [None]);",
          "    let keys = [\"boundary_key\", \"boundary_key\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"boundary_key\"), hasher(\"boundary_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [Some(&mut (\"boundary_key\", 100)), Some(&mut (\"boundary_key\", 100))]);"
        ],
        "code": [
          "{",
          "    struct Allocator;",
          "    let mut table: HashTable<(&str, u32), Allocator> = HashTable::new_in(Allocator);",
          "    let hasher = |val: &_| val.len() as u64;",
          "    table.insert_unique(hasher(\"boundary_key\"), (\"boundary_key\", 100), |(k, _)| hasher(k));",
          "    ",
          "    let keys = [\"boundary_key\"];",
          "    unsafe {",
          "        let got = table.get_many_unchecked_mut([hasher(\"boundary_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [Some(&mut (\"boundary_key\", 100))]);",
          "    let keys = [\"boundary_key\", \"non_existent_key\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"boundary_key\"), hasher(\"non_existent_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [Some(&mut (\"boundary_key\", 100)), None]);",
          "    let keys = [\"non_existent_key\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"non_existent_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [None]);",
          "    let keys = [\"boundary_key\", \"boundary_key\"];",
          "    unsafe {",
          "    let got = table.get_many_unchecked_mut([hasher(\"boundary_key\"), hasher(\"boundary_key\")], |i, val| keys[i] == val.0);",
          "    }",
          "    assert_eq!(got, [Some(&mut (\"boundary_key\", 100)), Some(&mut (\"boundary_key\", 100))]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]