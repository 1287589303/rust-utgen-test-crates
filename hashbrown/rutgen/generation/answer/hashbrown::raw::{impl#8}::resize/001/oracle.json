[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with some items",
          "    for i in 0..10 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let old_capacity = table.capacity();",
          "    let new_capacity = old_capacity + 10; // Higher than current items, valid",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.len(), 10);",
          "    assert!(table.capacity() > old_capacity);",
          "    assert!(unsafe { table.is_empty() } == false);",
          "    assert!(unsafe { table.bucket(0).is_full() });",
          "    assert!(unsafe { table.bucket(1).is_full() });",
          "    assert!(unsafe { table.bucket(2).is_full() });",
          "    assert!(unsafe { table.bucket(3).is_full() });",
          "    assert!(unsafe { table.bucket(4).is_full() });",
          "    assert!(unsafe { table.bucket(5).is_full() });",
          "    assert!(unsafe { table.bucket(6).is_full() });",
          "    assert!(unsafe { table.bucket(7).is_full() });",
          "    assert!(unsafe { table.bucket(8).is_full() });",
          "    assert!(unsafe { table.bucket(9).is_full() });",
          "    assert!(unsafe { table.bucket(10).is_empty() });",
          "    assert!(unsafe { table.bucket(11).is_empty() });",
          "    assert!(unsafe { table.bucket(12).is_empty() });",
          "    assert!(unsafe { table.bucket(13).is_empty() });",
          "    assert!(unsafe { table.bucket(14).is_empty() });",
          "    assert!(unsafe { table.bucket(15).is_empty() });"
        ],
        "code": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with some items",
          "    for i in 0..10 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let old_capacity = table.capacity();",
          "    let new_capacity = old_capacity + 10; // Higher than current items, valid",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "    assert_eq!(table.len(), 10);",
          "    assert!(table.capacity() > old_capacity);",
          "    assert!(unsafe { table.is_empty() } == false);",
          "    assert!(unsafe { table.bucket(0).is_full() });",
          "    assert!(unsafe { table.bucket(1).is_full() });",
          "    assert!(unsafe { table.bucket(2).is_full() });",
          "    assert!(unsafe { table.bucket(3).is_full() });",
          "    assert!(unsafe { table.bucket(4).is_full() });",
          "    assert!(unsafe { table.bucket(5).is_full() });",
          "    assert!(unsafe { table.bucket(6).is_full() });",
          "    assert!(unsafe { table.bucket(7).is_full() });",
          "    assert!(unsafe { table.bucket(8).is_full() });",
          "    assert!(unsafe { table.bucket(9).is_full() });",
          "    assert!(unsafe { table.bucket(10).is_empty() });",
          "    assert!(unsafe { table.bucket(11).is_empty() });",
          "    assert!(unsafe { table.bucket(12).is_empty() });",
          "    assert!(unsafe { table.bucket(13).is_empty() });",
          "    assert!(unsafe { table.bucket(14).is_empty() });",
          "    assert!(unsafe { table.bucket(15).is_empty() });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with some items",
          "    for i in 0..5 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = 0; // Invalid, as items are non-zero",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| {",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    for i in 0..5 {",
          "    unsafe {",
          "    table.insert(i as u64, i, |x| *x);",
          "    }",
          "    }",
          "    table.resize(0, |x| *x, Fallibility::Infallible).unwrap();",
          "    }).is_err());"
        ],
        "code": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with some items",
          "    for i in 0..5 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = 0; // Invalid, as items are non-zero",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "    assert!(std::panic::catch_unwind(|| {",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    for i in 0..5 {",
          "    unsafe {",
          "    table.insert(i as u64, i, |x| *x);",
          "    }",
          "    }",
          "    table.resize(0, |x| *x, Fallibility::Infallible).unwrap();",
          "    }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with items such that current items > capacity buckets allowed",
          "    for i in 0..20 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = 1; // Invalid, current items exceed capacity buckets",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.len(), 20);",
          "    assert!(table.capacity() > 20);",
          "    assert!(!table.is_empty());",
          "    assert!(unsafe { table.is_bucket_full(0) });",
          "    assert!(unsafe { !table.is_bucket_full(1) });",
          "    assert!(unsafe { table.bucket(0).is_some() });",
          "    assert!(unsafe { table.bucket(1).is_none() });",
          "    assert_eq!(table.data_end().as_ptr() as usize % table.allocation_size(), 0);",
          "    assert!(table.clone().is_err());",
          "    assert!(table.try_reserve(21, |x| *x).is_err());",
          "    assert_eq!(table.capacity(), 2);",
          "    assert!(matches!(table.clear_no_drop(), ()));"
        ],
        "code": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with items such that current items > capacity buckets allowed",
          "    for i in 0..20 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = 1; // Invalid, current items exceed capacity buckets",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "    assert_eq!(table.len(), 20);",
          "    assert!(table.capacity() > 20);",
          "    assert!(!table.is_empty());",
          "    assert!(unsafe { table.is_bucket_full(0) });",
          "    assert!(unsafe { !table.is_bucket_full(1) });",
          "    assert!(unsafe { table.bucket(0).is_some() });",
          "    assert!(unsafe { table.bucket(1).is_none() });",
          "    assert_eq!(table.data_end().as_ptr() as usize % table.allocation_size(), 0);",
          "    assert!(table.clone().is_err());",
          "    assert!(table.try_reserve(21, |x| *x).is_err());",
          "    assert_eq!(table.capacity(), 2);",
          "    assert!(matches!(table.clear_no_drop(), ()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    let new_capacity = 16; // Valid as table is empty",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.len(), 0);",
          "    assert_eq!(table.capacity(), 16);",
          "    assert!(table.is_empty());",
          "    assert!(unsafe { table.iter().next().is_none() });",
          "    assert!(unsafe { table.get(1, |&item| item == &0).is_none() });"
        ],
        "code": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    let new_capacity = 16; // Valid as table is empty",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "    assert_eq!(table.len(), 0);",
          "    assert_eq!(table.capacity(), 16);",
          "    assert!(table.is_empty());",
          "    assert!(unsafe { table.iter().next().is_none() });",
          "    assert!(unsafe { table.get(1, |&item| item == &0).is_none() });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with some items",
          "    for i in 0..8 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = 8; // Valid case where new capacity equals current items",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.len(), 8);",
          "    assert_eq!(table.capacity(), 8);",
          "    assert!(!table.is_empty());",
          "    assert_eq!(unsafe { table.bucket(0) }.as_ref(), &0);",
          "    assert_eq!(unsafe { table.bucket(1) }.as_ref(), &1);",
          "    assert_eq!(unsafe { table.bucket(2) }.as_ref(), &2);",
          "    assert_eq!(unsafe { table.bucket(3) }.as_ref(), &3);",
          "    assert_eq!(unsafe { table.bucket(4) }.as_ref(), &4);",
          "    assert_eq!(unsafe { table.bucket(5) }.as_ref(), &5);",
          "    assert_eq!(unsafe { table.bucket(6) }.as_ref(), &6);",
          "    assert_eq!(unsafe { table.bucket(7) }.as_ref(), &7);",
          "    assert!(unsafe { table.is_bucket_full(0) });",
          "    assert!(unsafe { table.is_bucket_full(1) });",
          "    assert!(unsafe { table.is_bucket_full(2) });",
          "    assert!(unsafe { table.is_bucket_full(3) });",
          "    assert!(unsafe { table.is_bucket_full(4) });",
          "    assert!(unsafe { table.is_bucket_full(5) });",
          "    assert!(unsafe { table.is_bucket_full(6) });",
          "    assert!(unsafe { table.is_bucket_full(7) });",
          "    unsafe { table.clear(); }",
          "    assert_eq!(table.len(), 0);",
          "    assert!(table.is_empty());",
          "    assert!(table.capacity() >= 8);"
        ],
        "code": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Initialize table with some items",
          "    for i in 0..8 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = 8; // Valid case where new capacity equals current items",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "    assert_eq!(table.len(), 8);",
          "    assert_eq!(table.capacity(), 8);",
          "    assert!(!table.is_empty());",
          "    assert_eq!(unsafe { table.bucket(0) }.as_ref(), &0);",
          "    assert_eq!(unsafe { table.bucket(1) }.as_ref(), &1);",
          "    assert_eq!(unsafe { table.bucket(2) }.as_ref(), &2);",
          "    assert_eq!(unsafe { table.bucket(3) }.as_ref(), &3);",
          "    assert_eq!(unsafe { table.bucket(4) }.as_ref(), &4);",
          "    assert_eq!(unsafe { table.bucket(5) }.as_ref(), &5);",
          "    assert_eq!(unsafe { table.bucket(6) }.as_ref(), &6);",
          "    assert_eq!(unsafe { table.bucket(7) }.as_ref(), &7);",
          "    assert!(unsafe { table.is_bucket_full(0) });",
          "    assert!(unsafe { table.is_bucket_full(1) });",
          "    assert!(unsafe { table.is_bucket_full(2) });",
          "    assert!(unsafe { table.is_bucket_full(3) });",
          "    assert!(unsafe { table.is_bucket_full(4) });",
          "    assert!(unsafe { table.is_bucket_full(5) });",
          "    assert!(unsafe { table.is_bucket_full(6) });",
          "    assert!(unsafe { table.is_bucket_full(7) });",
          "    unsafe { table.clear(); }",
          "    assert_eq!(table.len(), 0);",
          "    assert!(table.is_empty());",
          "    assert!(table.capacity() >= 8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Fill the table with items",
          "    for i in 0..10 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = isize::MAX as usize; // Maximum value, still valid",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(table.len() == 10);",
          "    assert!(table.capacity() >= new_capacity);",
          "    assert!(table.is_empty() == false);",
          "    assert!(table.get(0, |x| *x).is_some());",
          "    assert!(table.get(9, |x| *x).is_some());",
          "    assert!(table.get(10, |x| *x).is_none());",
          "    assert_eq!(table.data_end().as_ptr() as usize % table.allocation_size(), 0);",
          "    assert!(unsafe { table.is_bucket_full(0) });",
          "    assert!(unsafe { table.is_bucket_full(1) });",
          "    assert!(unsafe { table.is_bucket_full(2) });",
          "    assert!(unsafe { table.is_bucket_full(3) });",
          "    assert!(unsafe { table.is_bucket_full(4) });",
          "    assert!(unsafe { table.is_bucket_full(5) });",
          "    assert!(unsafe { table.is_bucket_full(6) });",
          "    assert!(unsafe { table.is_bucket_full(7) });",
          "    assert!(unsafe { table.is_bucket_full(8) });",
          "    assert!(unsafe { table.is_bucket_full(9) });"
        ],
        "code": [
          "{",
          "    let mut table: RawTable<u32> = RawTable::new_in(Global);",
          "    // Fill the table with items",
          "    for i in 0..10 {",
          "        unsafe {",
          "            table.insert(i as u64, i, |x| *x);",
          "        }",
          "    }",
          "    let new_capacity = isize::MAX as usize; // Maximum value, still valid",
          "    unsafe {",
          "        table.resize(new_capacity, |x| *x, Fallibility::Infallible).unwrap();",
          "    }",
          "    assert!(table.len() == 10);",
          "    assert!(table.capacity() >= new_capacity);",
          "    assert!(table.is_empty() == false);",
          "    assert!(table.get(0, |x| *x).is_some());",
          "    assert!(table.get(9, |x| *x).is_some());",
          "    assert!(table.get(10, |x| *x).is_none());",
          "    assert_eq!(table.data_end().as_ptr() as usize % table.allocation_size(), 0);",
          "    assert!(unsafe { table.is_bucket_full(0) });",
          "    assert!(unsafe { table.is_bucket_full(1) });",
          "    assert!(unsafe { table.is_bucket_full(2) });",
          "    assert!(unsafe { table.is_bucket_full(3) });",
          "    assert!(unsafe { table.is_bucket_full(4) });",
          "    assert!(unsafe { table.is_bucket_full(5) });",
          "    assert!(unsafe { table.is_bucket_full(6) });",
          "    assert!(unsafe { table.is_bucket_full(7) });",
          "    assert!(unsafe { table.is_bucket_full(8) });",
          "    assert!(unsafe { table.is_bucket_full(9) });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]