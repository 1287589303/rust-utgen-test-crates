[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default();",
          "    let capacity = 16;",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
          "",
          "    let index = 0; // Assuming index 0 is full",
          "    raw_table.items = 1; // Set items greater than 0",
          "",
          "    // Pre-fill the control byte to be full to satisfy is_bucket_full",
          "    raw_table.set_ctrl(index, Tag(0xff)); // Simulate full",
          "",
          "    raw_table.erase(index); // Call function being tested",
          "}"
        ],
        "oracle": [
          "    assert!(!raw_table.is_empty_singleton());",
          "    assert_eq!(raw_table.items, 0);",
          "    assert_eq!(raw_table.growth_left, 1);",
          "    assert_eq!(unsafe { *raw_table.ctrl(index) }, Tag::EMPTY);"
        ],
        "code": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default();",
          "    let capacity = 16;",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
          "",
          "    let index = 0; // Assuming index 0 is full",
          "    raw_table.items = 1; // Set items greater than 0",
          "",
          "    // Pre-fill the control byte to be full to satisfy is_bucket_full",
          "    raw_table.set_ctrl(index, Tag(0xff)); // Simulate full",
          "",
          "    raw_table.erase(index); // Call function being tested",
          "    assert!(!raw_table.is_empty_singleton());",
          "    assert_eq!(raw_table.items, 0);",
          "    assert_eq!(raw_table.growth_left, 1);",
          "    assert_eq!(unsafe { *raw_table.ctrl(index) }, Tag::EMPTY);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default();",
          "    let capacity = 16;",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
          "",
          "    let index = raw_table.bucket_mask; // Highest index",
          "    raw_table.items = 1; // Set items greater than 0",
          "",
          "    // Pre-fill the control byte to be full to satisfy is_bucket_full",
          "    raw_table.set_ctrl(index, Tag(0xff)); // Simulate full",
          "",
          "    raw_table.erase(index); // Call function being tested",
          "}"
        ],
        "oracle": [
          "    assert_eq!(raw_table.items, 0);",
          "    assert!(raw_table.is_empty_singleton());",
          "    assert!(raw_table.is_bucket_full(index) == false);",
          "    assert_eq!(Group::load(raw_table.ctrl(index)).match_empty(), true);",
          "    assert_eq!(raw_table.growth_left, bucket_mask_to_capacity(raw_table.bucket_mask) + 1);",
          "    assert!(raw_table.ctrl(index).read() == Tag::DELETED || raw_table.ctrl(index).read() == Tag::EMPTY);",
          "    assert!(raw_table.items >= 0);",
          "    assert!(raw_table.ctrl(raw_table.bucket_mask).is_null() || Group::load(raw_table.ctrl(raw_table.bucket_mask)).match_empty() == false);",
          "    assert!(raw_table.ctrl(index).is_full() == false);"
        ],
        "code": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default();",
          "    let capacity = 16;",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
          "",
          "    let index = raw_table.bucket_mask; // Highest index",
          "    raw_table.items = 1; // Set items greater than 0",
          "",
          "    // Pre-fill the control byte to be full to satisfy is_bucket_full",
          "    raw_table.set_ctrl(index, Tag(0xff)); // Simulate full",
          "",
          "    raw_table.erase(index); // Call function being tested",
          "    assert_eq!(raw_table.items, 0);",
          "    assert!(raw_table.is_empty_singleton());",
          "    assert!(raw_table.is_bucket_full(index) == false);",
          "    assert_eq!(Group::load(raw_table.ctrl(index)).match_empty(), true);",
          "    assert_eq!(raw_table.growth_left, bucket_mask_to_capacity(raw_table.bucket_mask) + 1);",
          "    assert!(raw_table.ctrl(index).read() == Tag::DELETED || raw_table.ctrl(index).read() == Tag::EMPTY);",
          "    assert!(raw_table.items >= 0);",
          "    assert!(raw_table.ctrl(raw_table.bucket_mask).is_null() || Group::load(raw_table.ctrl(raw_table.bucket_mask)).match_empty() == false);",
          "    assert!(raw_table.ctrl(index).is_full() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default();",
          "    let capacity = 32;",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
          "",
          "    let index = 15; // Assuming index 15 is full",
          "    raw_table.items = 5; // Set items greater than 0",
          "",
          "    // Pre-fill the control byte to be full to satisfy is_bucket_full",
          "    raw_table.set_ctrl(index, Tag(0xff)); // Simulate full",
          "",
          "    raw_table.erase(index); // Call function being tested",
          "}"
        ],
        "oracle": [
          "    assert!(!raw_table.is_empty_singleton(), \"Expected raw_table to not be an empty singleton after erase\");",
          "    assert_eq!(raw_table.items, 4, \"Expected items to decrease by 1 after erase\");",
          "    assert_eq!(raw_table.ctrl(index), Tag::DELETED, \"Expected control byte at index to be marked as DELETED\");",
          "    assert!(raw_table.growth_left > 0, \"Expected growth_left to be increased after erase\");",
          "    assert!(!raw_table.is_bucket_full(index), \"Expected control byte at index to not be full after erase\");"
        ],
        "code": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default();",
          "    let capacity = 32;",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
          "",
          "    let index = 15; // Assuming index 15 is full",
          "    raw_table.items = 5; // Set items greater than 0",
          "",
          "    // Pre-fill the control byte to be full to satisfy is_bucket_full",
          "    raw_table.set_ctrl(index, Tag(0xff)); // Simulate full",
          "",
          "    raw_table.erase(index); // Call function being tested",
          "    assert!(!raw_table.is_empty_singleton(), \"Expected raw_table to not be an empty singleton after erase\");",
          "    assert_eq!(raw_table.items, 4, \"Expected items to decrease by 1 after erase\");",
          "    assert_eq!(raw_table.ctrl(index), Tag::DELETED, \"Expected control byte at index to be marked as DELETED\");",
          "    assert!(raw_table.growth_left > 0, \"Expected growth_left to be increased after erase\");",
          "    assert!(!raw_table.is_bucket_full(index), \"Expected control byte at index to not be full after erase\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]