[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestType {",
          "        value: i32,",
          "    }",
          "",
          "    unsafe {",
          "        let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 2);",
          "        raw_table.items = 0;",
          "        raw_table.drop_elements::<TestType>();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(std::mem::size_of::<TestType>(), 4);",
          "    assert!(!TestType::NEEDS_DROP);",
          "    assert_eq!(raw_table.items, 0);",
          "    assert!(std::panic::catch_unwind(|| raw_table.drop_elements::<TestType>()).is_ok());"
        ],
        "code": [
          "{",
          "    struct TestType {",
          "        value: i32,",
          "    }",
          "",
          "    unsafe {",
          "        let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 2);",
          "        raw_table.items = 0;",
          "        raw_table.drop_elements::<TestType>();",
          "    }",
          "    assert_eq!(std::mem::size_of::<TestType>(), 4);",
          "    assert!(!TestType::NEEDS_DROP);",
          "    assert_eq!(raw_table.items, 0);",
          "    assert!(std::panic::catch_unwind(|| raw_table.drop_elements::<TestType>()).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestType {",
          "        value: i32,",
          "    }",
          "",
          "    unsafe {",
          "        let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 2);",
          "        raw_table.items = 1; // simulate having one item",
          "        raw_table.drop_elements::<TestType>();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(raw_table.items, 1);",
          "    assert_eq!(raw_table.ctrl_slice().len(), 2);",
          "    assert!(raw_table.is_empty_singleton());",
          "    assert!(raw_table.ctrl_slice().iter().all(|ctrl| ctrl.is_empty()));",
          "    assert!(std::mem::size_of::<TestType>() > 0);",
          "    assert!(unsafe { raw_table.bucket(0).as_ptr().is_null() });",
          "    assert!(unsafe { raw_table.bucket(1).as_ptr().is_null() });",
          "    assert!(raw_table.ctrl_slice()[0].is_empty());",
          "    assert!(raw_table.ctrl_slice()[1].is_empty());"
        ],
        "code": [
          "{",
          "    struct TestType {",
          "        value: i32,",
          "    }",
          "",
          "    unsafe {",
          "        let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 2);",
          "        raw_table.items = 1; // simulate having one item",
          "        raw_table.drop_elements::<TestType>();",
          "    }",
          "    assert_eq!(raw_table.items, 1);",
          "    assert_eq!(raw_table.ctrl_slice().len(), 2);",
          "    assert!(raw_table.is_empty_singleton());",
          "    assert!(raw_table.ctrl_slice().iter().all(|ctrl| ctrl.is_empty()));",
          "    assert!(std::mem::size_of::<TestType>() > 0);",
          "    assert!(unsafe { raw_table.bucket(0).as_ptr().is_null() });",
          "    assert!(unsafe { raw_table.bucket(1).as_ptr().is_null() });",
          "    assert!(raw_table.ctrl_slice()[0].is_empty());",
          "    assert!(raw_table.ctrl_slice()[1].is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]