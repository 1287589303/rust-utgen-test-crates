[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<i32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i32| *val as u64;",
          "    let hash = hasher(&1);",
          "    table.insert_unique(hash, 1, hasher);",
          "}"
        ],
        "oracle": [
          "    assert!(table.len() == 1);",
          "    assert!(table.find(hash, |&v| v == 1).is_some());",
          "    let entry = table.find_entry(hash, |&v| v == 1).unwrap();",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(*entry.table.raw.table.get(entry.bucket.ptr), 1);"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<i32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i32| *val as u64;",
          "    let hash = hasher(&1);",
          "    table.insert_unique(hash, 1, hasher);",
          "    assert!(table.len() == 1);",
          "    assert!(table.find(hash, |&v| v == 1).is_some());",
          "    let entry = table.find_entry(hash, |&v| v == 1).unwrap();",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(*entry.table.raw.table.get(entry.bucket.ptr), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<i64, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i64| *val as u64;",
          "    let hash = hasher(&i64::MAX);",
          "    table.insert_unique(hash, i64::MAX, hasher);",
          "}"
        ],
        "oracle": [
          "    let mut table: HashTable<i64, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i64| *val as u64;",
          "    let hash = hasher(&i64::MAX);",
          "    let entry = table.insert_unique(hash, i64::MAX, hasher);",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(entry.table.len(), 1);",
          "    assert!(entry.bucket.ptr.is_some());"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<i64, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i64| *val as u64;",
          "    let hash = hasher(&i64::MAX);",
          "    table.insert_unique(hash, i64::MAX, hasher);",
          "    let mut table: HashTable<i64, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i64| *val as u64;",
          "    let hash = hasher(&i64::MAX);",
          "    let entry = table.insert_unique(hash, i64::MAX, hasher);",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(entry.table.len(), 1);",
          "    assert!(entry.bucket.ptr.is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<i32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i32| *val as u64;",
          "    let hash = hasher(&-1);",
          "    table.insert_unique(hash, -1, hasher);",
          "}"
        ],
        "oracle": [
          "    let mut table: HashTable<i32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i32| *val as u64;",
          "    let hash = hasher(&-1);",
          "    let entry = table.insert_unique(hash, -1, hasher);",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(entry.bucket.ptr.as_ref(), &-1);",
          "    assert_eq!(entry.table.len(), 1);",
          "    assert!(!entry.table.is_empty());"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<i32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i32| *val as u64;",
          "    let hash = hasher(&-1);",
          "    table.insert_unique(hash, -1, hasher);",
          "    let mut table: HashTable<i32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &i32| *val as u64;",
          "    let hash = hasher(&-1);",
          "    let entry = table.insert_unique(hash, -1, hasher);",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(entry.bucket.ptr.as_ref(), &-1);",
          "    assert_eq!(entry.table.len(), 1);",
          "    assert!(!entry.table.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<u32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &u32| *val as u64;",
          "    let hash = hasher(&0);",
          "    table.insert_unique(hash, 0, hasher);",
          "}"
        ],
        "oracle": [
          "    let mut table: HashTable<u32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &u32| *val as u64;",
          "    let hash = hasher(&0);",
          "    let entry = table.insert_unique(hash, 0, hasher);",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(unsafe { *entry.bucket.ptr.as_ref() }, 0);",
          "    assert_eq!(entry.table.len(), 1);",
          "    assert!(!entry.table.is_empty());",
          "    assert_eq!(entry.table.capacity(), 1);"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<u32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &u32| *val as u64;",
          "    let hash = hasher(&0);",
          "    table.insert_unique(hash, 0, hasher);",
          "    let mut table: HashTable<u32, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &u32| *val as u64;",
          "    let hash = hasher(&0);",
          "    let entry = table.insert_unique(hash, 0, hasher);",
          "    assert_eq!(entry.hash, hash);",
          "    assert_eq!(unsafe { *entry.bucket.ptr.as_ref() }, 0);",
          "    assert_eq!(entry.table.len(), 1);",
          "    assert!(!entry.table.is_empty());",
          "    assert_eq!(entry.table.capacity(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<u64, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &u64| *val;",
          "    let min_hash = 1u64;",
          "    let max_hash = u64::MAX;",
          "    table.insert_unique(min_hash, 1, hasher);",
          "    table.insert_unique(max_hash, 2, hasher);",
          "}"
        ],
        "oracle": [
          "    OccupiedEntry {",
          "    hash: 1,",
          "    bucket: table.raw,",
          "    table: &mut table,",
          "    }",
          "    ",
          "    OccupiedEntry {",
          "    hash: u64::MAX,",
          "    bucket: table.raw,",
          "    table: &mut table,",
          "    }"
        ],
        "code": [
          "{",
          "    struct TestAllocator;",
          "    impl Allocator for TestAllocator {}",
          "",
          "    let mut table: HashTable<u64, TestAllocator> = HashTable::new_in(TestAllocator);",
          "    let hasher = |val: &u64| *val;",
          "    let min_hash = 1u64;",
          "    let max_hash = u64::MAX;",
          "    table.insert_unique(min_hash, 1, hasher);",
          "    table.insert_unique(max_hash, 2, hasher);",
          "    OccupiedEntry {",
          "    hash: 1,",
          "    bucket: table.raw,",
          "    table: &mut table,",
          "    }",
          "    ",
          "    OccupiedEntry {",
          "    hash: u64::MAX,",
          "    bucket: table.raw,",
          "    table: &mut table,",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]