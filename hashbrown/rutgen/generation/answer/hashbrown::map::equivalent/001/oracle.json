[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct IntEquivalent;",
          "    ",
          "    impl Equivalent<i32> for IntEquivalent {",
          "        fn equivalent(&self, other: &i32) -> bool {",
          "            *other == 42",
          "        }",
          "    }",
          "    ",
          "    let eq = IntEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&42);",
          "}"
        ],
        "oracle": [
          "    assert!(result);",
          "    let result_false = closure(&10);",
          "    assert!(!result_false);",
          "    assert_eq!(closure(&42), true);",
          "    assert_eq!(closure(&0), false);",
          "    let closure_other = equivalent(&eq);",
          "    assert!(closure_other(&42));",
          "    assert!(!closure_other(&100));"
        ],
        "code": [
          "{",
          "    struct IntEquivalent;",
          "    ",
          "    impl Equivalent<i32> for IntEquivalent {",
          "        fn equivalent(&self, other: &i32) -> bool {",
          "            *other == 42",
          "        }",
          "    }",
          "    ",
          "    let eq = IntEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&42);",
          "    assert!(result);",
          "    let result_false = closure(&10);",
          "    assert!(!result_false);",
          "    assert_eq!(closure(&42), true);",
          "    assert_eq!(closure(&0), false);",
          "    let closure_other = equivalent(&eq);",
          "    assert!(closure_other(&42));",
          "    assert!(!closure_other(&100));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct StrEquivalent;",
          "    ",
          "    impl Equivalent<String> for StrEquivalent {",
          "        fn equivalent(&self, other: &String) -> bool {",
          "            other == \"hello\"",
          "        }",
          "    }",
          "    ",
          "    let eq = StrEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&\"hello\".to_string());",
          "}"
        ],
        "oracle": [
          "    let eq = StrEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result_1 = closure(&\"hello\".to_string());",
          "    assert!(result_1);",
          "    let result_2 = closure(&\"world\".to_string());",
          "    assert!(!result_2);"
        ],
        "code": [
          "{",
          "    struct StrEquivalent;",
          "    ",
          "    impl Equivalent<String> for StrEquivalent {",
          "        fn equivalent(&self, other: &String) -> bool {",
          "            other == \"hello\"",
          "        }",
          "    }",
          "    ",
          "    let eq = StrEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&\"hello\".to_string());",
          "    let eq = StrEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result_1 = closure(&\"hello\".to_string());",
          "    assert!(result_1);",
          "    let result_2 = closure(&\"world\".to_string());",
          "    assert!(!result_2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct FloatEquivalent;",
          "",
          "    impl Equivalent<f32> for FloatEquivalent {",
          "        fn equivalent(&self, other: &f32) -> bool {",
          "            *other == 3.14",
          "        }",
          "    }",
          "    ",
          "    let eq = FloatEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&3.14);",
          "}"
        ],
        "oracle": [
          "    let eq = FloatEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&3.14);",
          "    assert_eq!(result, true);",
          "    let result_false = closure(&2.71);",
          "    assert_eq!(result_false, false);",
          "    let closure_generic: Box<dyn Fn(&f32) -> bool> = Box::new(closure);",
          "    assert_eq!(closure_generic(&3.14), true);",
          "    assert_eq!(closure_generic(&0.0), false);",
          "    let closure_another = equivalent(&FloatEquivalent);",
          "    assert_eq!(closure_another(&3.14), true);",
          "    assert_eq!(closure_another(&4.14), false);"
        ],
        "code": [
          "{",
          "    struct FloatEquivalent;",
          "",
          "    impl Equivalent<f32> for FloatEquivalent {",
          "        fn equivalent(&self, other: &f32) -> bool {",
          "            *other == 3.14",
          "        }",
          "    }",
          "    ",
          "    let eq = FloatEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&3.14);",
          "    let eq = FloatEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&3.14);",
          "    assert_eq!(result, true);",
          "    let result_false = closure(&2.71);",
          "    assert_eq!(result_false, false);",
          "    let closure_generic: Box<dyn Fn(&f32) -> bool> = Box::new(closure);",
          "    assert_eq!(closure_generic(&3.14), true);",
          "    assert_eq!(closure_generic(&0.0), false);",
          "    let closure_another = equivalent(&FloatEquivalent);",
          "    assert_eq!(closure_another(&3.14), true);",
          "    assert_eq!(closure_another(&4.14), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct AlwaysFalseEquivalent;",
          "",
          "    impl Equivalent<i32> for AlwaysFalseEquivalent {",
          "        fn equivalent(&self, _: &i32) -> bool {",
          "            false",
          "        }",
          "    }",
          "    ",
          "    let eq = AlwaysFalseEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&100);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false);",
          "    assert!(closure(42).is_false());",
          "    assert!(closure(-1).is_false());",
          "    assert!(closure(&0).is_false());",
          "    assert!(closure(&100).is_false());",
          "    assert!(closure(&101).is_false());"
        ],
        "code": [
          "{",
          "    struct AlwaysFalseEquivalent;",
          "",
          "    impl Equivalent<i32> for AlwaysFalseEquivalent {",
          "        fn equivalent(&self, _: &i32) -> bool {",
          "            false",
          "        }",
          "    }",
          "    ",
          "    let eq = AlwaysFalseEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&100);",
          "    assert_eq!(result, false);",
          "    assert!(closure(42).is_false());",
          "    assert!(closure(-1).is_false());",
          "    assert!(closure(&0).is_false());",
          "    assert!(closure(&100).is_false());",
          "    assert!(closure(&101).is_false());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct BoundEquivalent;",
          "",
          "    impl Equivalent<u32> for BoundEquivalent {",
          "        fn equivalent(&self, other: &u32) -> bool {",
          "            *other == 0",
          "        }",
          "    }",
          "    ",
          "    let eq = BoundEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&0);",
          "}"
        ],
        "oracle": [
          "    assert!(result);"
        ],
        "code": [
          "{",
          "    struct BoundEquivalent;",
          "",
          "    impl Equivalent<u32> for BoundEquivalent {",
          "        fn equivalent(&self, other: &u32) -> bool {",
          "            *other == 0",
          "        }",
          "    }",
          "    ",
          "    let eq = BoundEquivalent;",
          "    let closure = equivalent(&eq);",
          "    let result = closure(&0);",
          "    assert!(result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]