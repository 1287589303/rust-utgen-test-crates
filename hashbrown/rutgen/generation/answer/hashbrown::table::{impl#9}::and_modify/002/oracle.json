[
  {
    "uses": [
      "use hashbrown::HashTable;",
      "use std::hash::BuildHasher;",
      "use hashbrown::DefaultHashBuilder;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"example\"), (\"example\", 10), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"example\"),",
          "            |&(x, _)| x == \"example\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 5);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.find(hasher(&\"example\"), |&(k, _)| k == \"example\"), Some(&(\"example\", 15)));",
          "    assert!(matches!(table.entry(hasher(&\"example\"), |&(x, _)| x == \"example\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5), Entry::Occupied(_)));",
          "    table.insert_unique(hasher(&\"sample\"), (\"sample\", 20), hasher);",
          "    assert!(matches!(table.entry(hasher(&\"sample\"), |&(x, _)| x == \"sample\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5), Entry::Occupied(_)));",
          "    assert_eq!(table.find(hasher(&\"sample\"), |&(k, _)| k == \"sample\"), Some(&(\"sample\", 25)));",
          "    assert!(matches!(table.entry(hasher(&\"nonexistent\"), |&(x, _)| x == \"nonexistent\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5), Entry::Vacant(_)));",
          "    table.insert_unique(hasher(&\"another\"), (\"another\", 30), hasher);",
          "    table.entry(hasher(&\"another\"), |&(x, _)| x == \"another\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 10);",
          "    assert_eq!(table.find(hasher(&\"another\"), |&(k, _)| k == \"another\"), Some(&(\"another\", 40)));"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"example\"), (\"example\", 10), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"example\"),",
          "            |&(x, _)| x == \"example\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 5);",
          "    assert_eq!(table.find(hasher(&\"example\"), |&(k, _)| k == \"example\"), Some(&(\"example\", 15)));",
          "    assert!(matches!(table.entry(hasher(&\"example\"), |&(x, _)| x == \"example\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5), Entry::Occupied(_)));",
          "    table.insert_unique(hasher(&\"sample\"), (\"sample\", 20), hasher);",
          "    assert!(matches!(table.entry(hasher(&\"sample\"), |&(x, _)| x == \"sample\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5), Entry::Occupied(_)));",
          "    assert_eq!(table.find(hasher(&\"sample\"), |&(k, _)| k == \"sample\"), Some(&(\"sample\", 25)));",
          "    assert!(matches!(table.entry(hasher(&\"nonexistent\"), |&(x, _)| x == \"nonexistent\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5), Entry::Vacant(_)));",
          "    table.insert_unique(hasher(&\"another\"), (\"another\", 30), hasher);",
          "    table.entry(hasher(&\"another\"), |&(x, _)| x == \"another\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 10);",
          "    assert_eq!(table.find(hasher(&\"another\"), |&(k, _)| k == \"another\"), Some(&(\"another\", 40)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"item1\"), (\"item1\", 20), hasher);",
          "    table.insert_unique(hasher(&\"item2\"), (\"item2\", 30), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"item1\"),",
          "            |&(x, _)| x == \"item1\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 10);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"item2\"),",
          "            |&(x, _)| x == \"item2\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 15);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.find(hasher(&\"item1\"), |&(k, _)| k == \"item1\"), Some(&(\"item1\", 30)));",
          "    assert_eq!(table.find(hasher(&\"item2\"), |&(k, _)| k == \"item2\"), Some(&(\"item2\", 45)));",
          "    table.entry(hasher(&\"item3\"), |&(x, _)| x == \"item3\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5);",
          "    assert_eq!(table.find(hasher(&\"item3\"), |&(k, _)| k == \"item3\"), None);"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"item1\"), (\"item1\", 20), hasher);",
          "    table.insert_unique(hasher(&\"item2\"), (\"item2\", 30), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"item1\"),",
          "            |&(x, _)| x == \"item1\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 10);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"item2\"),",
          "            |&(x, _)| x == \"item2\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 15);",
          "    assert_eq!(table.find(hasher(&\"item1\"), |&(k, _)| k == \"item1\"), Some(&(\"item1\", 30)));",
          "    assert_eq!(table.find(hasher(&\"item2\"), |&(k, _)| k == \"item2\"), Some(&(\"item2\", 45)));",
          "    table.entry(hasher(&\"item3\"), |&(x, _)| x == \"item3\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 5);",
          "    assert_eq!(table.find(hasher(&\"item3\"), |&(k, _)| k == \"item3\"), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"custom\"), (\"custom\", 1), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"custom\"),",
          "            |&(x, _)| x == \"custom\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v *= 2);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(",
          "    table.entry(hasher(&\"custom\"), |&(x, _)| x == \"custom\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v *= 2),",
          "    Entry::Occupied(_)",
          "    ));",
          "    let entry = table.entry(hasher(&\"custom\"), |&(x, _)| x == \"custom\", |(k, _)| hasher(&k));",
          "    if let Entry::Occupied(occupied) = entry {",
          "    assert_eq!(occupied.get(), &(\"custom\", 2));",
          "    }",
          "    assert_eq!(",
          "    table.find(hasher(&\"custom\"), |&(k, _)| k == \"custom\"),",
          "    Some(&(\"custom\", 2))",
          "    );",
          "    table.insert_unique(hasher(&\"custom\"), (\"custom\", 3), hasher);",
          "    let entry = table.entry(hasher(&\"custom\"), |&(x, _)| x == \"custom\", |(k, _)| hasher(&k));",
          "    if let Entry::Occupied(occupied) = entry {",
          "    assert_eq!(occupied.get_mut(), &mut (\"custom\", 3));",
          "    }"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"custom\"), (\"custom\", 1), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"custom\"),",
          "            |&(x, _)| x == \"custom\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v *= 2);",
          "    assert!(matches!(",
          "    table.entry(hasher(&\"custom\"), |&(x, _)| x == \"custom\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v *= 2),",
          "    Entry::Occupied(_)",
          "    ));",
          "    let entry = table.entry(hasher(&\"custom\"), |&(x, _)| x == \"custom\", |(k, _)| hasher(&k));",
          "    if let Entry::Occupied(occupied) = entry {",
          "    assert_eq!(occupied.get(), &(\"custom\", 2));",
          "    }",
          "    assert_eq!(",
          "    table.find(hasher(&\"custom\"), |&(k, _)| k == \"custom\"),",
          "    Some(&(\"custom\", 2))",
          "    );",
          "    table.insert_unique(hasher(&\"custom\"), (\"custom\", 3), hasher);",
          "    let entry = table.entry(hasher(&\"custom\"), |&(x, _)| x == \"custom\", |(k, _)| hasher(&k));",
          "    if let Entry::Occupied(occupied) = entry {",
          "    assert_eq!(occupied.get_mut(), &mut (\"custom\", 3));",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"zero\"), (\"zero\", 0), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"zero\"),",
          "            |&(x, _)| x == \"zero\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 100);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.find(hasher(&\"zero\"), |&(k, _)| k == \"zero\"), Some(&(\"zero\", 100)));",
          "    let entry = table.entry(hasher(&\"zero\"), |&(x, _)| x == \"zero\", |(k, _)| hasher(&k));",
          "    let modified_entry = entry.and_modify(|(_, v)| *v += 100);",
          "    assert!(matches!(modified_entry, Entry::Occupied(_)));",
          "    let entry_after_modification = table.find(hasher(&\"zero\"), |&(k, _)| k == \"zero\").unwrap();",
          "    assert_eq!(entry_after_modification, &(\"zero\", 100));"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"zero\"), (\"zero\", 0), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"zero\"),",
          "            |&(x, _)| x == \"zero\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v += 100);",
          "    assert_eq!(table.find(hasher(&\"zero\"), |&(k, _)| k == \"zero\"), Some(&(\"zero\", 100)));",
          "    let entry = table.entry(hasher(&\"zero\"), |&(x, _)| x == \"zero\", |(k, _)| hasher(&k));",
          "    let modified_entry = entry.and_modify(|(_, v)| *v += 100);",
          "    assert!(matches!(modified_entry, Entry::Occupied(_)));",
          "    let entry_after_modification = table.find(hasher(&\"zero\"), |&(k, _)| k == \"zero\").unwrap();",
          "    assert_eq!(entry_after_modification, &(\"zero\", 100));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"dynamic\"), (\"dynamic\", 5), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"dynamic\"),",
          "            |&(x, _)| x == \"dynamic\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v -= 3)",
          "        .or_insert((\"dynamic\", 10));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.find(hasher(&\"dynamic\"), |&(k, _)| k == \"dynamic\"), Some(&(\"dynamic\", 2)));",
          "    let result = table.entry(hasher(&\"dynamic\"), |&(x, _)| x == \"dynamic\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 4);",
          "    assert!(matches!(result, Entry::Occupied(_)));",
          "    let result = table.entry(hasher(&\"not_present\"), |&(x, _)| x == \"not_present\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v -= 1);",
          "    assert!(matches!(result, Entry::Vacant(_)));",
          "    let result = table.entry(hasher(&\"dynamic\"), |&(x, _)| x == \"dynamic\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v *= 2);",
          "    assert!(matches!(result, Entry::Occupied(_)));"
        ],
        "code": [
          "{",
          "    use hashbrown::{HashTable, DefaultHashBuilder};",
          "    use std::hash::BuildHasher;",
          "",
          "    let mut table: HashTable<(&str, u32)> = HashTable::new();",
          "    let hasher = DefaultHashBuilder::default();",
          "    let hasher = |val: &_| hasher.hash_one(val);",
          "",
          "    table.insert_unique(hasher(&\"dynamic\"), (\"dynamic\", 5), hasher);",
          "",
          "    table",
          "        .entry(",
          "            hasher(&\"dynamic\"),",
          "            |&(x, _)| x == \"dynamic\",",
          "            |(k, _)| hasher(&k),",
          "        )",
          "        .and_modify(|(_, v)| *v -= 3)",
          "        .or_insert((\"dynamic\", 10));",
          "    assert_eq!(table.find(hasher(&\"dynamic\"), |&(k, _)| k == \"dynamic\"), Some(&(\"dynamic\", 2)));",
          "    let result = table.entry(hasher(&\"dynamic\"), |&(x, _)| x == \"dynamic\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v += 4);",
          "    assert!(matches!(result, Entry::Occupied(_)));",
          "    let result = table.entry(hasher(&\"not_present\"), |&(x, _)| x == \"not_present\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v -= 1);",
          "    assert!(matches!(result, Entry::Vacant(_)));",
          "    let result = table.entry(hasher(&\"dynamic\"), |&(x, _)| x == \"dynamic\", |(k, _)| hasher(&k)).and_modify(|(_, v)| *v *= 2);",
          "    assert!(matches!(result, Entry::Occupied(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]