{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map.rs\n// crate name is hashbrown\nuse crate::raw::{\n    Allocator, Bucket, Global, RawDrain, RawExtractIf, RawIntoIter, RawIter, RawTable,\n};\nuse crate::{DefaultHashBuilder, Equivalent, TryReserveError};\nuse core::borrow::Borrow;\nuse core::fmt::{self, Debug};\nuse core::hash::{BuildHasher, Hash};\nuse core::iter::FusedIterator;\nuse core::marker::PhantomData;\nuse core::mem;\nuse core::ops::Index;\n#[cfg(feature = \"raw-entry\")]\npub use crate::raw_entry::*;\n#[allow(clippy::missing_safety_doc)]\npub unsafe trait Allocator {\n    fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()>;\n    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);\n}\npub struct HashMap<K, V, S = DefaultHashBuilder, A: Allocator = Global> {\n    pub(crate) hash_builder: S,\n    pub(crate) table: RawTable<(K, V), A>,\n}\npub struct Bucket<T> {\n    ptr: NonNull<T>,\n}\npub struct InsertSlot {\n    index: usize,\n}\npub struct RawTable<T, A: Allocator = Global> {\n    table: RawTableInner,\n    alloc: A,\n    marker: PhantomData<T>,\n}\nimpl<K, V, S, A> HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn reserve(&mut self, additional: usize) {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn shrink_to_fit(&mut self) {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn shrink_to(&mut self, min_capacity: usize) {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V, S, A> {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn entry_ref<'a, 'b, Q>(\n        &'a mut self,\n        key: &'b Q,\n    ) -> EntryRef<'a, 'b, K, Q, V, S, A>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[inline]\n    pub fn get<Q>(&self, k: &Q) -> Option<&V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[inline]\n    pub fn get_key_value<Q>(&self, k: &Q) -> Option<(&K, &V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[inline]\n    fn get_inner<Q>(&self, k: &Q) -> Option<&(K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[inline]\n    pub fn get_key_value_mut<Q>(&mut self, k: &Q) -> Option<(&K, &mut V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn contains_key<Q>(&self, k: &Q) -> bool\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn get_mut<Q>(&mut self, k: &Q) -> Option<&mut V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[inline]\n    fn get_inner_mut<Q>(&mut self, k: &Q) -> Option<&mut (K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    pub fn get_many_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&'_ mut V>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    pub unsafe fn get_many_unchecked_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&'_ mut V>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    pub fn get_many_key_value_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<(&'_ K, &'_ mut V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    pub unsafe fn get_many_key_value_unchecked_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<(&'_ K, &'_ mut V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    fn get_many_mut_inner<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&'_ mut (K, V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    unsafe fn get_many_unchecked_mut_inner<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&'_ mut (K, V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    fn build_hashes_inner<Q, const N: usize>(&self, ks: [&Q; N]) -> [u64; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n        let hash = make_hash::<K, S>(&self.hash_builder, &k);\n        match self.find_or_find_insert_slot(hash, &k) {\n            Ok(bucket) => Some(mem::replace(unsafe { &mut bucket.as_mut().1 }, v)),\n            Err(slot) => {\n                unsafe {\n                    self.table.insert_in_slot(hash, slot, (k, v));\n                }\n                None\n            }\n        }\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub(crate) fn find_or_find_insert_slot<Q>(\n        &mut self,\n        hash: u64,\n        key: &Q,\n    ) -> Result<Bucket<(K, V)>, crate::raw::InsertSlot>\n    where\n        Q: Equivalent<K> + ?Sized,\n    {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub unsafe fn insert_unique_unchecked(&mut self, k: K, v: V) -> (&K, &mut V) {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn try_insert(\n        &mut self,\n        key: K,\n        value: V,\n    ) -> Result<&mut V, OccupiedError<'_, K, V, S, A>> {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn remove<Q>(&mut self, k: &Q) -> Option<V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn remove_entry<Q>(&mut self, k: &Q) -> Option<(K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {}\n    #[inline]\n    pub fn allocation_size(&self) -> usize {}\n}\n#[cfg(feature = \"nightly\")]\n#[cfg_attr(feature = \"inline-more\", inline)]\npub(crate) fn make_hash<Q, S>(hash_builder: &S, val: &Q) -> u64\nwhere\n    Q: Hash + ?Sized,\n    S: BuildHasher,\n{\n    hash_builder.hash_one(val)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Inserts a key-value pair into the map.\n///\n/// If the map did not have this key present, [`None`] is returned.\n///\n/// If the map did have this key present, the value is updated, and the old\n/// value is returned. The key is not updated, though; this matters for\n/// types that can be `==` without being identical. See the [`std::collections`]\n/// [module-level documentation] for more.\n///\n/// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n/// [`std::collections`]: https://doc.rust-lang.org/std/collections/index.html\n/// [module-level documentation]: https://doc.rust-lang.org/std/collections/index.html#insert-and-complex-keys\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// assert_eq!(map.insert(37, \"a\"), None);\n/// assert_eq!(map.is_empty(), false);\n///\n/// map.insert(37, \"b\");\n/// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n/// assert_eq!(map[&37], \"c\");\n/// ```\n1790 pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n1791     let hash = make_hash::<K, S>(&self.hash_builder, &k);\n1792     match self.find_or_find_insert_slot(hash, &k) {\n1793         Ok(bucket) => Some(mem::replace(unsafe { &mut bucket.as_mut().1 }, v)),\n1794         Err(slot) => {\n1795             unsafe {\n1796                 self.table.insert_in_slot(hash, slot, (k, v));\n1797             }\n1798             None\n1799         }\n1800     }\n1801 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}