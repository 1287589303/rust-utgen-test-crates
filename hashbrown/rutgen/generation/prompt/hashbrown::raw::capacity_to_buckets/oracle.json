{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/raw/mod.rs\n// crate name is hashbrown\nuse crate::alloc::alloc::{handle_alloc_error, Layout};\nuse crate::control::{BitMaskIter, Group, Tag, TagSliceExt};\nuse crate::scopeguard::{guard, ScopeGuard};\nuse crate::util::{invalid_mut, likely, unlikely};\nuse crate::TryReserveError;\nuse core::array;\nuse core::iter::FusedIterator;\nuse core::marker::PhantomData;\nuse core::mem;\nuse core::ptr::NonNull;\nuse core::slice;\nuse core::{hint, ptr};\n#[cfg(test)]\npub(crate) use self::alloc::AllocError;\npub(crate) use self::alloc::{do_alloc, Allocator, Global};\n#[cfg_attr(target_os = \"emscripten\", inline(never))]\n#[cfg_attr(not(target_os = \"emscripten\"), inline)]\nfn capacity_to_buckets(cap: usize) -> Option<usize> {\n    debug_assert_ne!(cap, 0);\n    if cap < 8 {\n        return Some(if cap < 4 { 4 } else { 8 });\n    }\n    let adjusted_cap = cap.checked_mul(8)? / 7;\n    Some(adjusted_cap.next_power_of_two())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the number of buckets needed to hold the given number of items,\n/// taking the maximum load factor into account.\n///\n/// Returns `None` if an overflow occurs.\n103 fn capacity_to_buckets(cap: usize) -> Option<usize> {\n104     debug_assert_ne!(cap, 0);\n105 \n106     // For small tables we require at least 1 empty bucket so that lookups are\n107     // guaranteed to terminate if an element doesn't exist in the table.\n108     if cap < 8 {\n109         // We don't bother with a table size of 2 buckets since that can only\n110         // hold a single element. Instead we skip directly to a 4 bucket table\n111         // which can hold 3 elements.\n112         return Some(if cap < 4 { 4 } else { 8 });\n113     }\n114 \n115     // Otherwise require 1/8 buckets to be empty (87.5% load)\n116     //\n117     // Be careful when modifying this, calculate_layout relies on the\n118     // overflow check here.\n119     let adjusted_cap = cap.checked_mul(8)? / 7;\n120 \n121     // Any overflows will have been caught by the checked_mul. Also, any\n122     // rounding errors from the division above will be cleaned up by\n123     // next_power_of_two (which can't overflow because of the previous division).\n124     Some(adjusted_cap.next_power_of_two())\n125 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}