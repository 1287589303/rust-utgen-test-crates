{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/raw_entry.rs\n// crate name is hashbrown\nuse crate::hash_map::{equivalent, make_hash, make_hasher};\nuse crate::raw::{Allocator, Bucket, Global, RawTable};\nuse crate::{Equivalent, HashMap};\nuse core::fmt::{self, Debug};\nuse core::hash::{BuildHasher, Hash};\nuse core::mem;\n#[allow(clippy::missing_safety_doc)]\npub unsafe trait Allocator {\n    fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()>;\n    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);\n}\npub struct HashMap<K, V, S = DefaultHashBuilder, A: Allocator = Global> {\n    pub(crate) hash_builder: S,\n    pub(crate) table: RawTable<(K, V), A>,\n}\npub struct RawTable<T, A: Allocator = Global> {\n    table: RawTableInner,\n    alloc: A,\n    marker: PhantomData<T>,\n}\npub struct RawEntryBuilder<'a, K, V, S, A: Allocator = Global> {\n    map: &'a HashMap<K, V, S, A>,\n}\nimpl<K, V, S, A: Allocator> HashMap<K, V, S, A> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<'_, K, V, S, A> {}\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn raw_entry(&self) -> RawEntryBuilder<'_, K, V, S, A> {\n        RawEntryBuilder { map: self }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Creates a raw immutable entry builder for the `HashMap`.\n///\n/// Raw entries provide the lowest level of control for searching and\n/// manipulating a map. They must be manually initialized with a hash and\n/// then manually searched.\n///\n/// This is useful for\n/// * Hash memoization\n/// * Using a search key that doesn't work with the Borrow trait\n/// * Using custom comparison logic without newtype wrappers\n///\n/// Unless you are in such a situation, higher-level and more foolproof APIs like\n/// `get` should be preferred.\n///\n/// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.extend([(\"a\", 100), (\"b\", 200), (\"c\", 300)]);\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// for k in [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] {\n///     let hash = compute_hash(map.hasher(), k);\n///     let v = map.get(&k).cloned();\n///     let kv = v.as_ref().map(|v| (&k, v));\n///\n///     println!(\"Key: {} and value: {:?}\", k, v);\n///\n///     assert_eq!(map.raw_entry().from_key(&k), kv);\n///     assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n///     assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n/// }\n/// ```\n156 pub fn raw_entry(&self) -> RawEntryBuilder<'_, K, V, S, A> {\n157     RawEntryBuilder { map: self }\n158 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}