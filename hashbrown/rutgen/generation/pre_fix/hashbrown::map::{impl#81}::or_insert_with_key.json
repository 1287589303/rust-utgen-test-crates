{
  "name": "hashbrown::map::{impl#81}::or_insert_with_key",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:78:1:78:9"
  },
  "visible": true,
  "loc": "src/map.rs:4226:5:4238:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches EntryRef::Vacant(entry) at line 4231 is true\n",
        "expected return value/type: match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => {\n                let value = default(entry.key);\n                entry.insert(value)\n            }\n        }\n"
      ],
      "input_infer": "self should match EntryRef::Vacant with a key that is not present in the HashMap, and the default function must accept a reference to type Q (borrowed form of key) to return a value of type V.\n",
      "answers": [
        {
          "uses": [
            "use hashbrown::HashMap;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, usize> = HashMap::new();",
                "    ",
                "    map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count());",
                "",
                "    // This is to ensure that after inserting using the or_insert_with_key,",
                "    // the value should be 9 as \"poneyland\" has 9 characters.",
                "    let value: &mut usize = map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*value, 9);",
                "    assert_eq!(map[\"poneyland\"], 9);",
                "    let value_existing: &mut usize = map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count() * 10);",
                "    assert_eq!(*value_existing, 9);",
                "    *value_existing *= 2;",
                "    assert_eq!(map[\"poneyland\"], 18);"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, usize> = HashMap::new();",
                "    ",
                "    map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count());",
                "",
                "    // This is to ensure that after inserting using the or_insert_with_key,",
                "    // the value should be 9 as \"poneyland\" has 9 characters.",
                "    let value: &mut usize = map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count());",
                "    assert_eq!(*value, 9);",
                "    assert_eq!(map[\"poneyland\"], 9);",
                "    let value_existing: &mut usize = map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count() * 10);",
                "    assert_eq!(*value_existing, 9);",
                "    *value_existing *= 2;",
                "    assert_eq!(map[\"poneyland\"], 18);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, usize> = HashMap::new();",
                "    ",
                "    // Inserting a value which is not present in the HashMap",
                "    map.entry_ref(\"unicorn\").or_insert_with_key(|key| key.chars().count());",
                "",
                "    // Checking a second nonexistent key",
                "    map.entry_ref(\"dragon\").or_insert_with_key(|key| key.chars().count());",
                "",
                "    // Ensure both inserted values are as expected",
                "    let value1: &mut usize = map.entry_ref(\"unicorn\").or_insert_with_key(|key| key.chars().count());",
                "    let value2: &mut usize = map.entry_ref(\"dragon\").or_insert_with_key(|key| key.chars().count());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*map.get(\"unicorn\").unwrap(), 7);",
                "    assert_eq!(*map.get(\"dragon\").unwrap(), 6);",
                "    assert_eq!(map.entry_ref(\"unicorn\").or_insert_with_key(|key| key.chars().count()), value1);",
                "    assert_eq!(map.entry_ref(\"dragon\").or_insert_with_key(|key| key.chars().count()), value2);"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, usize> = HashMap::new();",
                "    ",
                "    // Inserting a value which is not present in the HashMap",
                "    map.entry_ref(\"unicorn\").or_insert_with_key(|key| key.chars().count());",
                "",
                "    // Checking a second nonexistent key",
                "    map.entry_ref(\"dragon\").or_insert_with_key(|key| key.chars().count());",
                "",
                "    // Ensure both inserted values are as expected",
                "    let value1: &mut usize = map.entry_ref(\"unicorn\").or_insert_with_key(|key| key.chars().count());",
                "    let value2: &mut usize = map.entry_ref(\"dragon\").or_insert_with_key(|key| key.chars().count());",
                "    assert_eq!(*map.get(\"unicorn\").unwrap(), 7);",
                "    assert_eq!(*map.get(\"dragon\").unwrap(), 6);",
                "    assert_eq!(map.entry_ref(\"unicorn\").or_insert_with_key(|key| key.chars().count()), value1);",
                "    assert_eq!(map.entry_ref(\"dragon\").or_insert_with_key(|key| key.chars().count()), value2);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, f64> = HashMap::new();",
                "",
                "    // Key with a value that matches the default function's expected return type",
                "    map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "    ",
                "    let value: &mut f64 = map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map[\"floaty\"], 9.0);",
                "    let value: &mut f64 = map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "    assert_eq!(*value, 9.0);",
                "    *value += 10.0;",
                "    assert_eq!(map[\"floaty\"], 19.0);",
                "    let value: &mut f64 = map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "    assert_eq!(*value, 19.0);"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, f64> = HashMap::new();",
                "",
                "    // Key with a value that matches the default function's expected return type",
                "    map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "    ",
                "    let value: &mut f64 = map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "    assert_eq!(map[\"floaty\"], 9.0);",
                "    let value: &mut f64 = map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "    assert_eq!(*value, 9.0);",
                "    *value += 10.0;",
                "    assert_eq!(map[\"floaty\"], 19.0);",
                "    let value: &mut f64 = map.entry_ref(\"floaty\").or_insert_with_key(|key| key.chars().count() as f64 * 1.5);",
                "    assert_eq!(*value, 19.0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches EntryRef::Occupied(entry) at line 4231 is true\n",
        "precondition: self matches EntryRef::Occupied(entry) at line 4231 is true\n",
        "expected return value/type: match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => {\n                let value = default(entry.key);\n                entry.insert(value)\n            }\n        }\n"
      ],
      "input_infer": "self must be of type EntryRef::Occupied with K implementing Hash and Borrow<Q>, V being insertable type, and S being a valid BuildHasher; additionally, K must be convertible from &Q to satisfy preconditions and expected return types.\n",
      "answers": [
        {
          "uses": [
            "use std::hash::Hasher;",
            "use std::borrow::Borrow;",
            "use hashbrown::HashMap;",
            "use std::hash::BuildHasher;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::borrow::Borrow;",
                "",
                "    struct CustomHasher; // Placeholder struct for a custom hasher",
                "    use std::hash::{Hasher, BuildHasher};",
                "",
                "    impl Hasher for CustomHasher {",
                "        fn write(&mut self, _bytes: &[u8]) {}",
                "        fn finish(&self) -> u64 { 0 }",
                "    }",
                "",
                "    struct CustomBuildHasher;",
                "",
                "    impl BuildHasher for CustomBuildHasher {",
                "        type Hasher = CustomHasher;",
                "        fn build_hasher(&self) -> Self::Hasher { CustomHasher }",
                "    }",
                "",
                "    let mut map: HashMap<String, usize, CustomBuildHasher> = HashMap::new();",
                "    map.insert(\"occupied\".to_owned(), 42); // Existing key",
                "",
                "    match map.entry_ref(\"occupied\") {",
                "        EntryRef::Occupied(mut entry) => {",
                "            let result = entry.or_insert_with_key(|key| key.len());",
                "            // Further actions can be performed with `result`, which is `&mut usize`",
                "            *result += 1; // Modify the value at that entry",
                "        },",
                "        EntryRef::Vacant(_) => panic!(\"Entry should be occupied\"),",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*map.get(\"occupied\").unwrap(), 43);",
                "    assert_eq!(map.len(), 1);"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::borrow::Borrow;",
                "",
                "    struct CustomHasher; // Placeholder struct for a custom hasher",
                "    use std::hash::{Hasher, BuildHasher};",
                "",
                "    impl Hasher for CustomHasher {",
                "        fn write(&mut self, _bytes: &[u8]) {}",
                "        fn finish(&self) -> u64 { 0 }",
                "    }",
                "",
                "    struct CustomBuildHasher;",
                "",
                "    impl BuildHasher for CustomBuildHasher {",
                "        type Hasher = CustomHasher;",
                "        fn build_hasher(&self) -> Self::Hasher { CustomHasher }",
                "    }",
                "",
                "    let mut map: HashMap<String, usize, CustomBuildHasher> = HashMap::new();",
                "    map.insert(\"occupied\".to_owned(), 42); // Existing key",
                "",
                "    match map.entry_ref(\"occupied\") {",
                "        EntryRef::Occupied(mut entry) => {",
                "            let result = entry.or_insert_with_key(|key| key.len());",
                "            // Further actions can be performed with `result`, which is `&mut usize`",
                "            *result += 1; // Modify the value at that entry",
                "        },",
                "        EntryRef::Vacant(_) => panic!(\"Entry should be occupied\"),",
                "    }",
                "    assert_eq!(*map.get(\"occupied\").unwrap(), 43);",
                "    assert_eq!(map.len(), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::borrow::Borrow;",
                "",
                "    struct CustomHasher; // Placeholder struct for a custom hasher",
                "    use std::hash::{Hasher, BuildHasher};",
                "",
                "    impl Hasher for CustomHasher {",
                "        fn write(&mut self, _bytes: &[u8]) {}",
                "        fn finish(&self) -> u64 { 0 }",
                "    }",
                "",
                "    struct CustomBuildHasher;",
                "",
                "    impl BuildHasher for CustomBuildHasher {",
                "        type Hasher = CustomHasher;",
                "        fn build_hasher(&self) -> Self::Hasher { CustomHasher }",
                "    }",
                "",
                "    let mut map: HashMap<String, usize, CustomBuildHasher> = HashMap::new();",
                "    ",
                "    match map.entry_ref(\"vacant\") {",
                "        EntryRef::Occupied(_) => panic!(\"Entry should be vacant\"),",
                "        EntryRef::Vacant(entry) => {",
                "            let result = entry.or_insert_with_key(|key| key.chars().count());",
                "            // `result` is now a mutable reference to the inserted value",
                "            *result += 5; // Modify the value at that entry",
                "        },",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(map.entry_ref(\"vacant\"), EntryRef::Vacant(_)));",
                "    assert!(matches!(map.entry_ref(\"vacant\"), EntryRef::Occupied(_)) == false);",
                "    assert_eq!(map[\"vacant\"], 5);",
                "    assert_eq!(map.entry_ref(\"vacant\").or_insert_with_key(|key| key.chars().count()), &mut 5);",
                "    *map.entry_ref(\"vacant\").or_insert_with_key(|key| key.chars().count()) += 5;",
                "    assert_eq!(map[\"vacant\"], 10);",
                "    assert!(map.entry_ref(\"vacant\").or_insert_with_key(|key| key.chars().count()) == &mut 10);"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::borrow::Borrow;",
                "",
                "    struct CustomHasher; // Placeholder struct for a custom hasher",
                "    use std::hash::{Hasher, BuildHasher};",
                "",
                "    impl Hasher for CustomHasher {",
                "        fn write(&mut self, _bytes: &[u8]) {}",
                "        fn finish(&self) -> u64 { 0 }",
                "    }",
                "",
                "    struct CustomBuildHasher;",
                "",
                "    impl BuildHasher for CustomBuildHasher {",
                "        type Hasher = CustomHasher;",
                "        fn build_hasher(&self) -> Self::Hasher { CustomHasher }",
                "    }",
                "",
                "    let mut map: HashMap<String, usize, CustomBuildHasher> = HashMap::new();",
                "    ",
                "    match map.entry_ref(\"vacant\") {",
                "        EntryRef::Occupied(_) => panic!(\"Entry should be vacant\"),",
                "        EntryRef::Vacant(entry) => {",
                "            let result = entry.or_insert_with_key(|key| key.chars().count());",
                "            // `result` is now a mutable reference to the inserted value",
                "            *result += 5; // Modify the value at that entry",
                "        },",
                "    }",
                "    assert!(matches!(map.entry_ref(\"vacant\"), EntryRef::Vacant(_)));",
                "    assert!(matches!(map.entry_ref(\"vacant\"), EntryRef::Occupied(_)) == false);",
                "    assert_eq!(map[\"vacant\"], 5);",
                "    assert_eq!(map.entry_ref(\"vacant\").or_insert_with_key(|key| key.chars().count()), &mut 5);",
                "    *map.entry_ref(\"vacant\").or_insert_with_key(|key| key.chars().count()) += 5;",
                "    assert_eq!(map[\"vacant\"], 10);",
                "    assert!(map.entry_ref(\"vacant\").or_insert_with_key(|key| key.chars().count()) == &mut 10);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}