{
  "name": "hashbrown::raw::{impl#6}::write",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:74:1:74:9"
  },
  "visible": true,
  "loc": "src/raw/mod.rs:512:5:514:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "valid NonNull pointer for `self.ptr` and valid `T` value that adheres to `Hash` and `Eq` traits\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestType {",
                "        data: i32,",
                "    }",
                "    ",
                "    let value = TestType { data: 42 };",
                "    let ptr = Box::into_raw(Box::new(value));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(TestType { data: 100 });",
                "    }",
                "}"
              ],
              "oracle": [
                "    let value = TestType { data: 42 };",
                "    let ptr = Box::into_raw(Box::new(value));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "    unsafe { bucket.write(TestType { data: 100 }); }",
                "    let written_value = unsafe { *(bucket.as_ptr() as *const TestType) };",
                "    assert_eq!(written_value.data, 100);",
                "    unsafe { Box::from_raw(ptr) };"
              ],
              "code": [
                "{",
                "    struct TestType {",
                "        data: i32,",
                "    }",
                "    ",
                "    let value = TestType { data: 42 };",
                "    let ptr = Box::into_raw(Box::new(value));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(TestType { data: 100 });",
                "    }",
                "    let value = TestType { data: 42 };",
                "    let ptr = Box::into_raw(Box::new(value));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "    unsafe { bucket.write(TestType { data: 100 }); }",
                "    let written_value = unsafe { *(bucket.as_ptr() as *const TestType) };",
                "    assert_eq!(written_value.data, 100);",
                "    unsafe { Box::from_raw(ptr) };",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[repr(C)]",
                "    struct ZST;",
                "",
                "    let ptr = Box::into_raw(Box::new(ZST));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(ZST);",
                "    }",
                "}"
              ],
              "oracle": [
                "    let zst_instance = ZST;",
                "    let ptr_address = bucket.as_ptr();",
                "    let written_value = unsafe { ptr_address.read() };",
                "    assert_eq!(written_value, zst_instance);",
                "    let new_non_null = NonNull::new(ptr_address).unwrap();",
                "    let updated_bucket = Bucket { ptr: new_non_null };",
                "    assert_eq!(updated_bucket.as_ptr(), ptr_address);"
              ],
              "code": [
                "{",
                "    #[repr(C)]",
                "    struct ZST;",
                "",
                "    let ptr = Box::into_raw(Box::new(ZST));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(ZST);",
                "    }",
                "    let zst_instance = ZST;",
                "    let ptr_address = bucket.as_ptr();",
                "    let written_value = unsafe { ptr_address.read() };",
                "    assert_eq!(written_value, zst_instance);",
                "    let new_non_null = NonNull::new(ptr_address).unwrap();",
                "    let updated_bucket = Bucket { ptr: new_non_null };",
                "    assert_eq!(updated_bucket.as_ptr(), ptr_address);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestType {",
                "        data: i32,",
                "    }",
                "    ",
                "    let value = TestType { data: 7 };",
                "    let ptr = Box::into_raw(Box::new(value));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(TestType { data: 99 });",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(unsafe { *(bucket.as_ptr() as *const TestType) }.data, 99);"
              ],
              "code": [
                "{",
                "    struct TestType {",
                "        data: i32,",
                "    }",
                "    ",
                "    let value = TestType { data: 7 };",
                "    let ptr = Box::into_raw(Box::new(value));",
                "    let non_null = NonNull::new(ptr).unwrap();",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(TestType { data: 99 });",
                "    }",
                "    assert_eq!(unsafe { *(bucket.as_ptr() as *const TestType) }.data, 99);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct Uninitialized;",
                "",
                "    let ptr: *mut Uninitialized = std::ptr::null_mut();",
                "    let non_null = NonNull::new(ptr).unwrap_or_else(|| panic!(\"Pointer is null\"));",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(Uninitialized);",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(std::ptr::null_mut(), bucket.as_ptr());",
                "    assert!(std::mem::size_of::<Uninitialized>() == 0);",
                "    assert!(std::ptr::null_mut() != bucket.ptr.as_ptr());",
                "    assert!(std::panic::catch_unwind(|| {",
                "    unsafe { bucket.write(Uninitialized) };",
                "    }).is_err());"
              ],
              "code": [
                "{",
                "    struct Uninitialized;",
                "",
                "    let ptr: *mut Uninitialized = std::ptr::null_mut();",
                "    let non_null = NonNull::new(ptr).unwrap_or_else(|| panic!(\"Pointer is null\"));",
                "    let bucket = Bucket { ptr: non_null };",
                "",
                "    unsafe {",
                "        bucket.write(Uninitialized);",
                "    }",
                "    assert_eq!(std::ptr::null_mut(), bucket.as_ptr());",
                "    assert!(std::mem::size_of::<Uninitialized>() == 0);",
                "    assert!(std::ptr::null_mut() != bucket.ptr.as_ptr());",
                "    assert!(std::panic::catch_unwind(|| {",
                "    unsafe { bucket.write(Uninitialized) };",
                "    }).is_err());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}