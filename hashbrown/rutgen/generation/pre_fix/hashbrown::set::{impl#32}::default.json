{
  "name": "hashbrown::set::{impl#32}::default",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:84:1:84:9"
  },
  "visible": true,
  "loc": "src/set.rs:1833:5:1837:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: IntoIter {\n            iter: Default::default(),\n        }\n"
      ],
      "input_infer": "K: Any type that implements core::hash::Hash; A: Any type that implements the Allocator trait, including Global; also test with default values for K and A.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let iter: IntoIter<u32, Global> = IntoIter::default();",
                "    let _ = iter;",
                "}"
              ],
              "oracle": [
                "    assert_eq!(iter.iter, Default::default());",
                "    assert!(std::mem::size_of_val(&iter) > 0);",
                "    assert!(iter.iter.is_empty());",
                "    assert_eq!(iter.iter.len(), 0);",
                "    assert!(iter.iter.clone().collect::<Vec<u32>>().is_empty());",
                "    assert!(iter.iter().next().is_none());"
              ],
              "code": [
                "{",
                "    let iter: IntoIter<u32, Global> = IntoIter::default();",
                "    let _ = iter;",
                "    assert_eq!(iter.iter, Default::default());",
                "    assert!(std::mem::size_of_val(&iter) > 0);",
                "    assert!(iter.iter.is_empty());",
                "    assert_eq!(iter.iter.len(), 0);",
                "    assert!(iter.iter.clone().collect::<Vec<u32>>().is_empty());",
                "    assert!(iter.iter().next().is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct CustomAllocator;",
                "    unsafe impl Allocator for CustomAllocator {",
                "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "    let iter: IntoIter<String, CustomAllocator> = IntoIter::default();",
                "    let _ = iter;",
                "}"
              ],
              "oracle": [
                "    assert_eq!(iter.iter, Default::default());",
                "    assert!(matches!(iter.iter, map::IntoIter::<String, ()>::default()));",
                "    assert!(iter.iter.is_empty());",
                "    assert_eq!(iter.iter.len(), 0);",
                "    assert!(iter.iter.clone().is_fused());",
                "    assert!(iter.iter.next().is_none());"
              ],
              "code": [
                "{",
                "    struct CustomAllocator;",
                "    unsafe impl Allocator for CustomAllocator {",
                "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "    let iter: IntoIter<String, CustomAllocator> = IntoIter::default();",
                "    let _ = iter;",
                "    assert_eq!(iter.iter, Default::default());",
                "    assert!(matches!(iter.iter, map::IntoIter::<String, ()>::default()));",
                "    assert!(iter.iter.is_empty());",
                "    assert_eq!(iter.iter.len(), 0);",
                "    assert!(iter.iter.clone().is_fused());",
                "    assert!(iter.iter.next().is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let iter: IntoIter<String, Global> = IntoIter::default();",
                "    let _ = iter;",
                "}"
              ],
              "oracle": [
                "    let expected: IntoIter<String, Global> = IntoIter {",
                "    iter: Default::default(),",
                "    };",
                "    assert_eq!(iter, expected);"
              ],
              "code": [
                "{",
                "    let iter: IntoIter<String, Global> = IntoIter::default();",
                "    let _ = iter;",
                "    let expected: IntoIter<String, Global> = IntoIter {",
                "    iter: Default::default(),",
                "    };",
                "    assert_eq!(iter, expected);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let iter: IntoIter<i32, Global> = IntoIter::default();",
                "    let _ = iter;",
                "}"
              ],
              "oracle": [
                "    assert_eq!(iter.iter, Default::default());"
              ],
              "code": [
                "{",
                "    let iter: IntoIter<i32, Global> = IntoIter::default();",
                "    let _ = iter;",
                "    assert_eq!(iter.iter, Default::default());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}