{
  "name": "hashbrown::map::{impl#81}::or_insert",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:78:1:78:9"
  },
  "visible": true,
  "loc": "src/map.rs:4165:5:4174:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches EntryRef::Vacant(entry) at line 4170 is true\n",
        "expected return value/type: match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(default),\n        }\n"
      ],
      "input_infer": "self must be an instance of EntryRef::Vacant with a key of type K that is hashable, a value of type V, and the default value must be of type V to insert; additionally, ensure that K can be created from the key reference type Q.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<String, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
                "    let key = \"new_key\";",
                "    ",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "",
                "    entry_ref.or_insert(42);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map[\"new_key\"], 42);",
                "    assert!(map.contains_key(\"new_key\"));",
                "    let entry_ref_occupied = EntryRef::Occupied(OccupiedEntry { /* initialize with valid parameters */ });",
                "    let value_mut = entry_ref_occupied.or_insert(100);",
                "    assert_eq!(*value_mut, 100);",
                "    *value_mut += 1;",
                "    assert_eq!(map[\"new_key\"], 43);",
                "    let entry_ref_vacant_again = EntryRef::Vacant(VacantEntryRef { /* initialize with valid parameters */ });",
                "    assert_eq!(entry_ref_vacant_again.or_insert(10), &mut map[\"new_key\"]);",
                "    assert_eq!(map[\"new_key\"], 43);"
              ],
              "code": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<String, u32, DefaultHashBuilder, TestAllocator> = HashMap::new();",
                "    let key = \"new_key\";",
                "    ",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "",
                "    entry_ref.or_insert(42);",
                "    assert_eq!(map[\"new_key\"], 42);",
                "    assert!(map.contains_key(\"new_key\"));",
                "    let entry_ref_occupied = EntryRef::Occupied(OccupiedEntry { /* initialize with valid parameters */ });",
                "    let value_mut = entry_ref_occupied.or_insert(100);",
                "    assert_eq!(*value_mut, 100);",
                "    *value_mut += 1;",
                "    assert_eq!(map[\"new_key\"], 43);",
                "    let entry_ref_vacant_again = EntryRef::Vacant(VacantEntryRef { /* initialize with valid parameters */ });",
                "    assert_eq!(entry_ref_vacant_again.or_insert(10), &mut map[\"new_key\"]);",
                "    assert_eq!(map[\"new_key\"], 43);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<u32, String, DefaultHashBuilder, TestAllocator> = HashMap::new();",
                "    let key = 1;",
                "    ",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "",
                "    entry_ref.or_insert(\"new_value\".to_string());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.get(&1), Some(&\"new_value\".to_string()));",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.entry_ref(1).or_insert(\"another_value\".to_string()), &mut \"new_value\".to_string());",
                "    assert_eq!(map.get(&1), Some(&\"new_value\".to_string()));",
                "    assert_eq!(map.entry_ref(1).or_insert(\"updated_value\".to_string()), &mut \"new_value\".to_string());",
                "    assert_eq!(map.get(&1), Some(&\"new_value\".to_string()));"
              ],
              "code": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<u32, String, DefaultHashBuilder, TestAllocator> = HashMap::new();",
                "    let key = 1;",
                "    ",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "",
                "    entry_ref.or_insert(\"new_value\".to_string());",
                "    assert_eq!(map.get(&1), Some(&\"new_value\".to_string()));",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.entry_ref(1).or_insert(\"another_value\".to_string()), &mut \"new_value\".to_string());",
                "    assert_eq!(map.get(&1), Some(&\"new_value\".to_string()));",
                "    assert_eq!(map.entry_ref(1).or_insert(\"updated_value\".to_string()), &mut \"new_value\".to_string());",
                "    assert_eq!(map.get(&1), Some(&\"new_value\".to_string()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<f64, String, DefaultHashBuilder, TestAllocator> = HashMap::new();",
                "    let key = 3.14;",
                "    ",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "",
                "    entry_ref.or_insert(\"pi_value\".to_string());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map[\"poneyland\"], \"pi_value\".to_string());",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.get(&3.14), Some(&\"pi_value\".to_string()));",
                "    assert!(map.contains_key(&3.14));",
                "    assert_eq!(entry_ref.key(), &3.14);"
              ],
              "code": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            unimplemented!()",
                "        }",
                "        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<f64, String, DefaultHashBuilder, TestAllocator> = HashMap::new();",
                "    let key = 3.14;",
                "    ",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "",
                "    entry_ref.or_insert(\"pi_value\".to_string());",
                "    assert_eq!(map[\"poneyland\"], \"pi_value\".to_string());",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.get(&3.14), Some(&\"pi_value\".to_string()));",
                "    assert!(map.contains_key(&3.14));",
                "    assert_eq!(entry_ref.key(), &3.14);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches EntryRef::Occupied(entry) at line 4170 is true\n",
        "precondition: self matches EntryRef::Occupied(entry) at line 4170 is true\n",
        "expected return value/type: match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(default),\n        }\n"
      ],
      "input_infer": "`self` must be an instance of `EntryRef::Occupied` containing a key that hashes to an occupied slot in a `HashMap` with a key type that implements `Hash + From<&'b Q>`, and provide a mutable reference to a value type `V` in the given `HashMap`.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: hashbrown::HashMap<String, u32> = hashbrown::HashMap::new();",
                "    map.insert(\"poneyland\".to_string(), 3);",
                "    ",
                "    // Create an EntryRef::Occupied variant",
                "    let entry_ref = {",
                "        let key: &str = \"poneyland\";",
                "        map.entry_ref(key)",
                "    };",
                "",
                "    // Call or_insert on the occupied entry",
                "    let value_mut_ref = entry_ref.or_insert(10);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*value_mut_ref, 3);",
                "    assert_eq!(map[\"poneyland\"], 3);",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(value_mut_ref, &mut map[\"poneyland\"]);",
                "    assert_eq!(*value_mut_ref, 3);"
              ],
              "code": [
                "{",
                "    let mut map: hashbrown::HashMap<String, u32> = hashbrown::HashMap::new();",
                "    map.insert(\"poneyland\".to_string(), 3);",
                "    ",
                "    // Create an EntryRef::Occupied variant",
                "    let entry_ref = {",
                "        let key: &str = \"poneyland\";",
                "        map.entry_ref(key)",
                "    };",
                "",
                "    // Call or_insert on the occupied entry",
                "    let value_mut_ref = entry_ref.or_insert(10);",
                "    assert_eq!(*value_mut_ref, 3);",
                "    assert_eq!(map[\"poneyland\"], 3);",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(value_mut_ref, &mut map[\"poneyland\"]);",
                "    assert_eq!(*value_mut_ref, 3);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: hashbrown::HashMap<String, u32> = hashbrown::HashMap::new();",
                "    map.insert(\"poneyland\".to_string(), 5);",
                "    map.insert(\"rainbowland\".to_string(), 7);",
                "    ",
                "    // Create EntryRef::Occupied variants",
                "    let entry_ref_poneyland = {",
                "        let key: &str = \"poneyland\";",
                "        map.entry_ref(key)",
                "    };",
                "    let entry_ref_rainbowland = {",
                "        let key: &str = \"rainbowland\";",
                "        map.entry_ref(key)",
                "    };",
                "",
                "    // Call or_insert on the occupied entries",
                "    let value_mut_ref_poneyland = entry_ref_poneyland.or_insert(10);",
                "    let value_mut_ref_rainbowland = entry_ref_rainbowland.or_insert(12);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*value_mut_ref_poneyland, 5);",
                "    assert_eq!(*value_mut_ref_rainbowland, 7);",
                "    assert_eq!(map[\"poneyland\"], 5);",
                "    assert_eq!(map[\"rainbowland\"], 7);",
                "    assert_eq!(map.len(), 2);"
              ],
              "code": [
                "{",
                "    let mut map: hashbrown::HashMap<String, u32> = hashbrown::HashMap::new();",
                "    map.insert(\"poneyland\".to_string(), 5);",
                "    map.insert(\"rainbowland\".to_string(), 7);",
                "    ",
                "    // Create EntryRef::Occupied variants",
                "    let entry_ref_poneyland = {",
                "        let key: &str = \"poneyland\";",
                "        map.entry_ref(key)",
                "    };",
                "    let entry_ref_rainbowland = {",
                "        let key: &str = \"rainbowland\";",
                "        map.entry_ref(key)",
                "    };",
                "",
                "    // Call or_insert on the occupied entries",
                "    let value_mut_ref_poneyland = entry_ref_poneyland.or_insert(10);",
                "    let value_mut_ref_rainbowland = entry_ref_rainbowland.or_insert(12);",
                "    assert_eq!(*value_mut_ref_poneyland, 5);",
                "    assert_eq!(*value_mut_ref_rainbowland, 7);",
                "    assert_eq!(map[\"poneyland\"], 5);",
                "    assert_eq!(map[\"rainbowland\"], 7);",
                "    assert_eq!(map.len(), 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: hashbrown::HashMap<String, i32> = hashbrown::HashMap::new();",
                "    map.insert(\"poneyland\".to_string(), 3);",
                "    ",
                "    // Create EntryRef::Occupied variant",
                "    let entry_ref = {",
                "        let key: &str = \"poneyland\";",
                "        map.entry_ref(key)",
                "    };",
                "",
                "    // Call or_insert on the occupied entry with a different value",
                "    let value_mut_ref = entry_ref.or_insert(6);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*value_mut_ref, 3);",
                "    assert_eq!(map[\"poneyland\"], 3);",
                "    let value_mut_ref2 = entry_ref.or_insert(10);",
                "    assert_eq!(*value_mut_ref2, 3);",
                "    assert_eq!(map[\"poneyland\"], 3);",
                "    *value_mut_ref2 *= 2;",
                "    assert_eq!(map[\"poneyland\"], 6);",
                "    let value_mut_ref3 = entry_ref.or_insert(6);",
                "    assert_eq!(*value_mut_ref3, 6);",
                "    assert_eq!(map[\"poneyland\"], 6);"
              ],
              "code": [
                "{",
                "    let mut map: hashbrown::HashMap<String, i32> = hashbrown::HashMap::new();",
                "    map.insert(\"poneyland\".to_string(), 3);",
                "    ",
                "    // Create EntryRef::Occupied variant",
                "    let entry_ref = {",
                "        let key: &str = \"poneyland\";",
                "        map.entry_ref(key)",
                "    };",
                "",
                "    // Call or_insert on the occupied entry with a different value",
                "    let value_mut_ref = entry_ref.or_insert(6);",
                "    assert_eq!(*value_mut_ref, 3);",
                "    assert_eq!(map[\"poneyland\"], 3);",
                "    let value_mut_ref2 = entry_ref.or_insert(10);",
                "    assert_eq!(*value_mut_ref2, 3);",
                "    assert_eq!(map[\"poneyland\"], 3);",
                "    *value_mut_ref2 *= 2;",
                "    assert_eq!(map[\"poneyland\"], 6);",
                "    let value_mut_ref3 = entry_ref.or_insert(6);",
                "    assert_eq!(*value_mut_ref3, 6);",
                "    assert_eq!(map[\"poneyland\"], 6);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}