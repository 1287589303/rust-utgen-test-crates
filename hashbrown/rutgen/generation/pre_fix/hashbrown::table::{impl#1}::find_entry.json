{
  "name": "hashbrown::table::{impl#1}::find_entry",
  "mod_info": {
    "name": "table",
    "loc": "src/lib.rs:85:1:85:11"
  },
  "visible": true,
  "loc": "src/table.rs:299:5:312:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.raw.find(hash, eq) matches Some(bucket) at line 304 is true\n",
        "precondition: self.raw.find(hash, eq) matches Some(bucket) at line 304 is true\n",
        "expected return value/type: Ok(OccupiedEntry {\n                hash,\n                bucket,\n                table: self,\n            })\n"
      ],
      "input_infer": "hash: valid u64 value that is currently in the table, eq: a function that returns true for an existing entry matching the hash\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value = (1, \"a\");",
                "    let hash = 123456789;",
                "",
                "    table.insert_unique(hash, value.clone(), |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash, |val| val.0 == 1);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "}"
              ],
              "oracle": [
                "    assert!(entry_result.is_ok());",
                "    assert_eq!(_entry.hash, hash);",
                "    assert_eq!(_entry.bucket.ptr.as_ref(), &value);",
                "    assert_eq!(_entry.table.allocator(), &TestAllocator);"
              ],
              "code": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value = (1, \"a\");",
                "    let hash = 123456789;",
                "",
                "    table.insert_unique(hash, value.clone(), |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash, |val| val.0 == 1);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "    assert!(entry_result.is_ok());",
                "    assert_eq!(_entry.hash, hash);",
                "    assert_eq!(_entry.bucket.ptr.as_ref(), &value);",
                "    assert_eq!(_entry.table.allocator(), &TestAllocator);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let values = [(1, \"a\"), (2, \"b\"), (1, \"c\")];",
                "    let hash1 = 123456789;",
                "    let hash2 = 987654321;",
                "",
                "    table.insert_unique(hash1, values[0], |val| val.0);",
                "    table.insert_unique(hash2, values[1], |val| val.0);",
                "    table.insert_unique(hash1, values[2], |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash1, |val| val.0 == 1);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "}"
              ],
              "oracle": [
                "    table.find_entry(hash1, |val| val.0 == 1).is_ok();",
                "    let entry = table.find_entry(hash1, |val| val.0 == 1).unwrap();",
                "    assert_eq!(entry.hash, hash1);",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &values[0]);",
                "    assert_eq!(entry.table.allocator(), &TestAllocator);",
                "    assert!(table.raw.find(hash1, |val| val.0 == 1).is_some());",
                "    assert_eq!(table.len(), 3);",
                "    assert!(!table.is_empty());"
              ],
              "code": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let values = [(1, \"a\"), (2, \"b\"), (1, \"c\")];",
                "    let hash1 = 123456789;",
                "    let hash2 = 987654321;",
                "",
                "    table.insert_unique(hash1, values[0], |val| val.0);",
                "    table.insert_unique(hash2, values[1], |val| val.0);",
                "    table.insert_unique(hash1, values[2], |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash1, |val| val.0 == 1);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "    table.find_entry(hash1, |val| val.0 == 1).is_ok();",
                "    let entry = table.find_entry(hash1, |val| val.0 == 1).unwrap();",
                "    assert_eq!(entry.hash, hash1);",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &values[0]);",
                "    assert_eq!(entry.table.allocator(), &TestAllocator);",
                "    assert!(table.raw.find(hash1, |val| val.0 == 1).is_some());",
                "    assert_eq!(table.len(), 3);",
                "    assert!(!table.is_empty());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value = (5, \"test\");",
                "    let hash = 1122334455;",
                "",
                "    table.insert_unique(hash, value.clone(), |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash, |val| val.0 == 5);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "}"
              ],
              "oracle": [
                "    let hash = 1122334455;",
                "    let value = (5, \"test\");",
                "    let entry_result = table.find_entry(hash, |val| val.0 == 5);",
                "    assert!(entry_result.is_ok());",
                "    let entry = entry_result.unwrap();",
                "    assert_eq!(entry.hash, hash);",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &value);"
              ],
              "code": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value = (5, \"test\");",
                "    let hash = 1122334455;",
                "",
                "    table.insert_unique(hash, value.clone(), |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash, |val| val.0 == 5);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "    let hash = 1122334455;",
                "    let value = (5, \"test\");",
                "    let entry_result = table.find_entry(hash, |val| val.0 == 5);",
                "    assert!(entry_result.is_ok());",
                "    let entry = entry_result.unwrap();",
                "    assert_eq!(entry.hash, hash);",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &value);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value1 = (9, \"first\");",
                "    let value2 = (10, \"second\");",
                "    let hash1 = 1000;",
                "    let hash2 = 2000;",
                "",
                "    table.insert_unique(hash1, value1.clone(), |val| val.0);",
                "    table.insert_unique(hash2, value2.clone(), |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash1, |val| val.0 == 9);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "}"
              ],
              "oracle": [
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value1 = (9, \"first\");",
                "    let hash1 = 1000;",
                "    table.insert_unique(hash1, value1.clone(), |val| val.0);",
                "    let entry_result = table.find_entry(hash1, |val| val.0 == 9);",
                "    assert!(entry_result.is_ok());",
                "    let entry = entry_result.unwrap();",
                "    assert_eq!(entry.hash, hash1);",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &value1);",
                "    assert_eq!(entry.table, &table);"
              ],
              "code": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Implement required methods here, or use a no-op for testing",
                "    }",
                "",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value1 = (9, \"first\");",
                "    let value2 = (10, \"second\");",
                "    let hash1 = 1000;",
                "    let hash2 = 2000;",
                "",
                "    table.insert_unique(hash1, value1.clone(), |val| val.0);",
                "    table.insert_unique(hash2, value2.clone(), |val| val.0);",
                "    ",
                "    let entry_result = table.find_entry(hash1, |val| val.0 == 9);",
                "    let _entry = entry_result.unwrap(); // Test we get the Ok variant",
                "    let mut table = HashTable::new_in(TestAllocator);",
                "    let value1 = (9, \"first\");",
                "    let hash1 = 1000;",
                "    table.insert_unique(hash1, value1.clone(), |val| val.0);",
                "    let entry_result = table.find_entry(hash1, |val| val.0 == 9);",
                "    assert!(entry_result.is_ok());",
                "    let entry = entry_result.unwrap();",
                "    assert_eq!(entry.hash, hash1);",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &value1);",
                "    assert_eq!(entry.table, &table);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.raw.find(hash, eq) matches None at line 304 is true\n",
        "expected return value/type: Err(AbsentEntry { table: self })\n"
      ],
      "input_infer": "hash: any u64 value that does not correspond to an entry in the hash table, eq: any function that evaluates to false for all entries in the table\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut table = HashTable::new_in(Global);",
                "    let hash = 123456789; // A hash value not in the table.",
                "    let eq = |_: &i32| false; // Function that always evaluates to false.",
                "    ",
                "    let result = table.find_entry(hash, eq);",
                "}"
              ],
              "oracle": [
                "    let table = HashTable::new_in(Global);",
                "    let hash = 123456789;",
                "    let eq = |_: &i32| false;",
                "    let result = table.find_entry(hash, eq);",
                "    assert!(result.is_err());",
                "    if let Err(entry) = result {",
                "    assert_eq!(entry.table, &table);",
                "    }"
              ],
              "code": [
                "{",
                "    let mut table = HashTable::new_in(Global);",
                "    let hash = 123456789; // A hash value not in the table.",
                "    let eq = |_: &i32| false; // Function that always evaluates to false.",
                "    ",
                "    let result = table.find_entry(hash, eq);",
                "    let table = HashTable::new_in(Global);",
                "    let hash = 123456789;",
                "    let eq = |_: &i32| false;",
                "    let result = table.find_entry(hash, eq);",
                "    assert!(result.is_err());",
                "    if let Err(entry) = result {",
                "    assert_eq!(entry.table, &table);",
                "    }",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut table = HashTable::new_in(Global);",
                "    let hash = 987654321; // Another hash value not in the empty table.",
                "    let eq = |_: &i32| false; // Function that still evaluates to false.",
                "    ",
                "    let result = table.find_entry(hash, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.is_err(), true);",
                "    assert!(matches!(result, Err(_)));"
              ],
              "code": [
                "{",
                "    let mut table = HashTable::new_in(Global);",
                "    let hash = 987654321; // Another hash value not in the empty table.",
                "    let eq = |_: &i32| false; // Function that still evaluates to false.",
                "    ",
                "    let result = table.find_entry(hash, eq);",
                "    assert_eq!(result.is_err(), true);",
                "    assert!(matches!(result, Err(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut table = HashTable::new_in(Global);",
                "    // Insert a different value to ensure the hash we are testing doesn't exist",
                "    table.insert_unique(888888888, 42, |val| val); // This entry has a different hash.",
                "    let hash = 999999999; // Hash that does not correspond to existing entries.",
                "    let eq = |_: &i32| false; // Function that returns false.",
                "    ",
                "    let result = table.find_entry(hash, eq);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().table, &mut table);"
              ],
              "code": [
                "{",
                "    let mut table = HashTable::new_in(Global);",
                "    // Insert a different value to ensure the hash we are testing doesn't exist",
                "    table.insert_unique(888888888, 42, |val| val); // This entry has a different hash.",
                "    let hash = 999999999; // Hash that does not correspond to existing entries.",
                "    let eq = |_: &i32| false; // Function that returns false.",
                "    ",
                "    let result = table.find_entry(hash, eq);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().table, &mut table);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}