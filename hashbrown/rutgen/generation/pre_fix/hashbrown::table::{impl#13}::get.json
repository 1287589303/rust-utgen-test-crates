{
  "name": "hashbrown::table::{impl#13}::get",
  "mod_info": {
    "name": "table",
    "loc": "src/lib.rs:85:1:85:11"
  },
  "visible": true,
  "loc": "src/table.rs:1658:5:1660:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: self.bucket.as_ref()\n"
      ],
      "input_infer": "Valid bucket pointer (NonNull<T>) in OccupiedEntry, valid reference value of type &T, table with at least one entry, valid hash function implementation, non-empty table state, occupied entry state.\n",
      "answers": [
        {
          "uses": [
            "use hashbrown::HashTable;",
            "use hashbrown::DefaultHashBuilder;",
            "use std::ptr::NonNull;",
            "use std::hash::BuildHasher;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::{HashTable, DefaultHashBuilder};",
                "    use std::hash::BuildHasher;",
                "    use std::ptr::NonNull;",
                "",
                "    let mut table: HashTable<&str> = HashTable::new();",
                "    let hasher = DefaultHashBuilder::default();",
                "    let hasher = |val: &_| hasher.hash_one(val);",
                "    table.insert_unique(hasher(&\"testkey\"), \"testvalue\", hasher);",
                "",
                "    let capacity = table.raw.capacity();",
                "    let bucket = NonNull::new(table.raw.buckets.as_mut_ptr() as *mut &str).unwrap();",
                "    ",
                "    let entry = OccupiedEntry {",
                "        hash: hasher(&\"testkey\"),",
                "        bucket: Bucket { ptr: bucket },",
                "        table: &mut table,",
                "    };",
                "    ",
                "    let value = entry.get();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(value, &\"testvalue\");"
              ],
              "code": [
                "{",
                "    use hashbrown::{HashTable, DefaultHashBuilder};",
                "    use std::hash::BuildHasher;",
                "    use std::ptr::NonNull;",
                "",
                "    let mut table: HashTable<&str> = HashTable::new();",
                "    let hasher = DefaultHashBuilder::default();",
                "    let hasher = |val: &_| hasher.hash_one(val);",
                "    table.insert_unique(hasher(&\"testkey\"), \"testvalue\", hasher);",
                "",
                "    let capacity = table.raw.capacity();",
                "    let bucket = NonNull::new(table.raw.buckets.as_mut_ptr() as *mut &str).unwrap();",
                "    ",
                "    let entry = OccupiedEntry {",
                "        hash: hasher(&\"testkey\"),",
                "        bucket: Bucket { ptr: bucket },",
                "        table: &mut table,",
                "    };",
                "    ",
                "    let value = entry.get();",
                "    assert_eq!(value, &\"testvalue\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::{HashTable, DefaultHashBuilder};",
                "    use std::hash::BuildHasher;",
                "    use std::ptr::NonNull;",
                "",
                "    let mut table: HashTable<&str> = HashTable::new();",
                "    let hasher = DefaultHashBuilder::default();",
                "    let hasher = |val: &_| hasher.hash_one(val);",
                "    ",
                "    table.insert_unique(hasher(&\"key1\"), \"value1\", hasher);",
                "    table.insert_unique(hasher(&\"key2\"), \"value2\", hasher);",
                "    ",
                "    let capacity = table.raw.capacity();",
                "    ",
                "    let bucket1 = NonNull::new(table.raw.buckets.as_mut_ptr() as *mut &str).unwrap();",
                "    let entry1 = OccupiedEntry {",
                "        hash: hasher(&\"key1\"),",
                "        bucket: Bucket { ptr: bucket1 },",
                "        table: &mut table,",
                "    };",
                "    let value1 = entry1.get();",
                "",
                "    let bucket2 = NonNull::new(table.raw.buckets.as_mut_ptr().add(1) as *mut &str).unwrap();",
                "    let entry2 = OccupiedEntry {",
                "        hash: hasher(&\"key2\"),",
                "        bucket: Bucket { ptr: bucket2 },",
                "        table: &mut table,",
                "    };",
                "    let value2 = entry2.get();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(value1, &\"value1\");",
                "    assert_eq!(value2, &\"value2\");"
              ],
              "code": [
                "{",
                "    use hashbrown::{HashTable, DefaultHashBuilder};",
                "    use std::hash::BuildHasher;",
                "    use std::ptr::NonNull;",
                "",
                "    let mut table: HashTable<&str> = HashTable::new();",
                "    let hasher = DefaultHashBuilder::default();",
                "    let hasher = |val: &_| hasher.hash_one(val);",
                "    ",
                "    table.insert_unique(hasher(&\"key1\"), \"value1\", hasher);",
                "    table.insert_unique(hasher(&\"key2\"), \"value2\", hasher);",
                "    ",
                "    let capacity = table.raw.capacity();",
                "    ",
                "    let bucket1 = NonNull::new(table.raw.buckets.as_mut_ptr() as *mut &str).unwrap();",
                "    let entry1 = OccupiedEntry {",
                "        hash: hasher(&\"key1\"),",
                "        bucket: Bucket { ptr: bucket1 },",
                "        table: &mut table,",
                "    };",
                "    let value1 = entry1.get();",
                "",
                "    let bucket2 = NonNull::new(table.raw.buckets.as_mut_ptr().add(1) as *mut &str).unwrap();",
                "    let entry2 = OccupiedEntry {",
                "        hash: hasher(&\"key2\"),",
                "        bucket: Bucket { ptr: bucket2 },",
                "        table: &mut table,",
                "    };",
                "    let value2 = entry2.get();",
                "    assert_eq!(value1, &\"value1\");",
                "    assert_eq!(value2, &\"value2\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::{HashTable, DefaultHashBuilder};",
                "    use std::hash::BuildHasher;",
                "    use std::ptr::NonNull;",
                "",
                "    let mut table: HashTable<&str> = HashTable::with_capacity(1);",
                "    let hasher = DefaultHashBuilder::default();",
                "    let hasher = |val: &_| hasher.hash_one(val);",
                "    table.insert_unique(hasher(&\"boundary_case\"), \"boundary_value\", hasher);",
                "",
                "    let capacity = table.raw.capacity();",
                "    let bucket = NonNull::new(table.raw.buckets.as_mut_ptr() as *mut &str).unwrap();",
                "    ",
                "    let entry = OccupiedEntry {",
                "        hash: hasher(&\"boundary_case\"),",
                "        bucket: Bucket { ptr: bucket },",
                "        table: &mut table,",
                "    };",
                "    ",
                "    let value = entry.get();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(value, &\"boundary_value\");",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &\"boundary_value\");",
                "    assert!(std::ptr::eq(value, &\"boundary_value\"));"
              ],
              "code": [
                "{",
                "    use hashbrown::{HashTable, DefaultHashBuilder};",
                "    use std::hash::BuildHasher;",
                "    use std::ptr::NonNull;",
                "",
                "    let mut table: HashTable<&str> = HashTable::with_capacity(1);",
                "    let hasher = DefaultHashBuilder::default();",
                "    let hasher = |val: &_| hasher.hash_one(val);",
                "    table.insert_unique(hasher(&\"boundary_case\"), \"boundary_value\", hasher);",
                "",
                "    let capacity = table.raw.capacity();",
                "    let bucket = NonNull::new(table.raw.buckets.as_mut_ptr() as *mut &str).unwrap();",
                "    ",
                "    let entry = OccupiedEntry {",
                "        hash: hasher(&\"boundary_case\"),",
                "        bucket: Bucket { ptr: bucket },",
                "        table: &mut table,",
                "    };",
                "    ",
                "    let value = entry.get();",
                "    assert_eq!(value, &\"boundary_value\");",
                "    assert_eq!(entry.bucket.ptr.as_ref(), &\"boundary_value\");",
                "    assert!(std::ptr::eq(value, &\"boundary_value\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}