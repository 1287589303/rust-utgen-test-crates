{
  "name": "hashbrown::map::{impl#78}::or_default",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:78:1:78:9"
  },
  "visible": true,
  "loc": "src/map.rs:3740:5:3749:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches Entry::Vacant(entry) at line 3745 is true\n",
        "expected return value/type: match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(Default::default()),\n        }\n"
      ],
      "input_infer": "self must be an Entry::Vacant, with K being a type that implements Hash, V being a type that implements Default, and the HashMap containing no prior entries for the key being accessed.\n",
      "answers": [
        {
          "uses": [
            "use std::hash::Hash;",
            "use std::hash::BuildHasher;",
            "use hashbrown::HashMap;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::BuildHasher;",
                "",
                "    // Setup a HashMap and ensure it is empty",
                "    struct CustomHashBuilder; ",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    // Create a VacantEntry using a macro or explicit constructor that adheres to the Entry structure",
                "    // Here we assume we can create a VacantEntry",
                "    let key = \"new_entry\";",
                "    let hash = 12345; // Example hash value",
                "    // Create a VacantEntry using hypothetical data structures, as creating one directly may involve internals",
                "    let vacant_entry = Entry::Vacant(VacantEntry {",
                "        hash,",
                "        key,",
                "        table: &mut map,",
                "    });",
                "",
                "    // Call the or_default function",
                "    let value_ref = vacant_entry.or_default();",
                "",
                "    // This is where the value would be returned, and the HashMap would now contain the key with a Default value",
                "}"
              ],
              "oracle": [
                "    let map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    assert_eq!(map.entry(\"new_entry\").or_default(), &mut None);",
                "    map.insert(\"existing_entry\", Some(42));",
                "    assert_eq!(map.entry(\"existing_entry\").or_default(), &mut Some(42));"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::BuildHasher;",
                "",
                "    // Setup a HashMap and ensure it is empty",
                "    struct CustomHashBuilder; ",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    // Create a VacantEntry using a macro or explicit constructor that adheres to the Entry structure",
                "    // Here we assume we can create a VacantEntry",
                "    let key = \"new_entry\";",
                "    let hash = 12345; // Example hash value",
                "    // Create a VacantEntry using hypothetical data structures, as creating one directly may involve internals",
                "    let vacant_entry = Entry::Vacant(VacantEntry {",
                "        hash,",
                "        key,",
                "        table: &mut map,",
                "    });",
                "",
                "    // Call the or_default function",
                "    let value_ref = vacant_entry.or_default();",
                "",
                "    // This is where the value would be returned, and the HashMap would now contain the key with a Default value",
                "    let map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    assert_eq!(map.entry(\"new_entry\").or_default(), &mut None);",
                "    map.insert(\"existing_entry\", Some(42));",
                "    assert_eq!(map.entry(\"existing_entry\").or_default(), &mut Some(42));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::{BuildHasher, Hash};",
                "",
                "    struct CustomHashBuilder;",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    let key1 = \"entry_one\";",
                "    let hash1 = 123; // Example hash value",
                "    // Create first VacantEntry",
                "    let vacant_entry1 = Entry::Vacant(VacantEntry {",
                "        hash: hash1,",
                "        key: key1,",
                "        table: &mut map,",
                "    });",
                "    ",
                "    let value_ref1 = vacant_entry1.or_default();",
                "",
                "    let key2 = \"entry_two\";",
                "    let hash2 = 456; // Example hash value",
                "    // Create second VacantEntry",
                "    let vacant_entry2 = Entry::Vacant(VacantEntry {",
                "        hash: hash2,",
                "        key: key2,",
                "        table: &mut map,",
                "    });",
                "",
                "    let value_ref2 = vacant_entry2.or_default();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*value_ref1, None);",
                "    assert_eq!(*value_ref2, None);",
                "    assert_eq!(map[\"entry_one\"], None);",
                "    assert_eq!(map[\"entry_two\"], None);",
                "    assert_eq!(value_ref1, &mut map[\"entry_one\"]);",
                "    assert_eq!(value_ref2, &mut map[\"entry_two\"]);",
                "    assert_eq!(value_ref1 as *mut _, &mut map[\"entry_one\"] as *mut _);",
                "    assert_eq!(value_ref2 as *mut _, &mut map[\"entry_two\"] as *mut _);",
                "    assert!(map.contains_key(\"entry_one\"));",
                "    assert!(map.contains_key(\"entry_two\"));",
                "    assert_eq!(map.len(), 2);",
                "    let default_value1 = Default::default();",
                "    *value_ref1 = Some(5);",
                "    *value_ref2 = Some(10);",
                "    assert_eq!(map[\"entry_one\"], Some(5));",
                "    assert_eq!(map[\"entry_two\"], Some(10));"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::{BuildHasher, Hash};",
                "",
                "    struct CustomHashBuilder;",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    let key1 = \"entry_one\";",
                "    let hash1 = 123; // Example hash value",
                "    // Create first VacantEntry",
                "    let vacant_entry1 = Entry::Vacant(VacantEntry {",
                "        hash: hash1,",
                "        key: key1,",
                "        table: &mut map,",
                "    });",
                "    ",
                "    let value_ref1 = vacant_entry1.or_default();",
                "",
                "    let key2 = \"entry_two\";",
                "    let hash2 = 456; // Example hash value",
                "    // Create second VacantEntry",
                "    let vacant_entry2 = Entry::Vacant(VacantEntry {",
                "        hash: hash2,",
                "        key: key2,",
                "        table: &mut map,",
                "    });",
                "",
                "    let value_ref2 = vacant_entry2.or_default();",
                "    assert_eq!(*value_ref1, None);",
                "    assert_eq!(*value_ref2, None);",
                "    assert_eq!(map[\"entry_one\"], None);",
                "    assert_eq!(map[\"entry_two\"], None);",
                "    assert_eq!(value_ref1, &mut map[\"entry_one\"]);",
                "    assert_eq!(value_ref2, &mut map[\"entry_two\"]);",
                "    assert_eq!(value_ref1 as *mut _, &mut map[\"entry_one\"] as *mut _);",
                "    assert_eq!(value_ref2 as *mut _, &mut map[\"entry_two\"] as *mut _);",
                "    assert!(map.contains_key(\"entry_one\"));",
                "    assert!(map.contains_key(\"entry_two\"));",
                "    assert_eq!(map.len(), 2);",
                "    let default_value1 = Default::default();",
                "    *value_ref1 = Some(5);",
                "    *value_ref2 = Some(10);",
                "    assert_eq!(map[\"entry_one\"], Some(5));",
                "    assert_eq!(map[\"entry_two\"], Some(10));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::{BuildHasher, Hash};",
                "",
                "    struct CustomHashBuilder;",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    let key = \"same_hash_key\";",
                "    let hash = 789; // Example hash value",
                "    // Create a VacantEntry",
                "    let vacant_entry = Entry::Vacant(VacantEntry {",
                "        hash,",
                "        key,",
                "        table: &mut map,",
                "    });",
                "",
                "    // Call the or_default function",
                "    let value_ref = vacant_entry.or_default();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(value_ref, &mut None);",
                "    assert_eq!(map[\"same_hash_key\"], None);",
                "    let new_value_ref = vacant_entry.or_default();",
                "    assert_eq!(new_value_ref, &mut Some(0));",
                "    assert_eq!(map[\"same_hash_key\"], Some(0));"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::{BuildHasher, Hash};",
                "",
                "    struct CustomHashBuilder;",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<u32, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    let key = \"same_hash_key\";",
                "    let hash = 789; // Example hash value",
                "    // Create a VacantEntry",
                "    let vacant_entry = Entry::Vacant(VacantEntry {",
                "        hash,",
                "        key,",
                "        table: &mut map,",
                "    });",
                "",
                "    // Call the or_default function",
                "    let value_ref = vacant_entry.or_default();",
                "    assert_eq!(value_ref, &mut None);",
                "    assert_eq!(map[\"same_hash_key\"], None);",
                "    let new_value_ref = vacant_entry.or_default();",
                "    assert_eq!(new_value_ref, &mut Some(0));",
                "    assert_eq!(map[\"same_hash_key\"], Some(0));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::{BuildHasher, Hash};",
                "",
                "    struct CustomHashBuilder;",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<String, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    let key = \"string_entry\";",
                "    let hash = 999; // Example hash value",
                "    // Create a VacantEntry",
                "    let vacant_entry = Entry::Vacant(VacantEntry {",
                "        hash,",
                "        key,",
                "        table: &mut map,",
                "    });",
                "",
                "    // Call the or_default function",
                "    let value_ref = vacant_entry.or_default();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(value_ref, &mut None);",
                "    assert_eq!(map[\"string_entry\"], None);",
                "    assert_eq!(map.entry(\"string_entry\").or_default(), &mut None);",
                "    assert_eq!(map[\"string_entry\"], None);",
                "    let value_ref_existing = map.entry(\"string_entry\").or_default();",
                "    assert_eq!(value_ref_existing, &mut None);",
                "    *value_ref_existing = Some(\"default_value\".to_string());",
                "    assert_eq!(map[\"string_entry\"], Some(\"default_value\".to_string()));"
              ],
              "code": [
                "{",
                "    use hashbrown::HashMap;",
                "    use std::hash::{BuildHasher, Hash};",
                "",
                "    struct CustomHashBuilder;",
                "    impl BuildHasher for CustomHashBuilder {",
                "        type Hasher = std::collections::hash_map::DefaultHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut map: HashMap<&str, Option<String, CustomHashBuilder>> = HashMap::with_hasher(CustomHashBuilder);",
                "    ",
                "    let key = \"string_entry\";",
                "    let hash = 999; // Example hash value",
                "    // Create a VacantEntry",
                "    let vacant_entry = Entry::Vacant(VacantEntry {",
                "        hash,",
                "        key,",
                "        table: &mut map,",
                "    });",
                "",
                "    // Call the or_default function",
                "    let value_ref = vacant_entry.or_default();",
                "    assert_eq!(value_ref, &mut None);",
                "    assert_eq!(map[\"string_entry\"], None);",
                "    assert_eq!(map.entry(\"string_entry\").or_default(), &mut None);",
                "    assert_eq!(map[\"string_entry\"], None);",
                "    let value_ref_existing = map.entry(\"string_entry\").or_default();",
                "    assert_eq!(value_ref_existing, &mut None);",
                "    *value_ref_existing = Some(\"default_value\".to_string());",
                "    assert_eq!(map[\"string_entry\"], Some(\"default_value\".to_string()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches Entry::Occupied(entry) at line 3745 is true\n",
        "precondition: self matches Entry::Occupied(entry) at line 3745 is true\n",
        "expected return value/type: match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(Default::default()),\n        }\n"
      ],
      "input_infer": "Test input conditions: self must be an instance of Entry::Occupied with a valid key of type K and an associated value of type V, where K implements Hash and S is a valid BuildHasher implementation; key must be an existing key in the HashMap with an associated non-default value.\n",
      "answers": [
        {
          "uses": [
            "use hashbrown::hash_map::HashMap;",
            "use hashbrown::hash_map::Entry;",
            "use std::collections::hash_map::RandomState;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::hash_map::{Entry, HashMap};",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut map: HashMap<&str, Option<u32>> = HashMap::new();",
                "    map.insert(\"occupied_key\", Some(42));",
                "",
                "    let entry = map.entry(\"occupied_key\");",
                "    let value = entry.or_default();",
                "    let result = *value;",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Some(42));",
                "    assert_eq!(map[\"occupied_key\"], Some(42));",
                "    assert_eq!(map.entry(\"occupied_key\").or_default(), &mut Some(42));",
                "    assert_eq!(map.get(\"occupied_key\"), Some(&Some(42)));",
                "    assert!(map.contains_key(\"occupied_key\"));"
              ],
              "code": [
                "{",
                "    use hashbrown::hash_map::{Entry, HashMap};",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut map: HashMap<&str, Option<u32>> = HashMap::new();",
                "    map.insert(\"occupied_key\", Some(42));",
                "",
                "    let entry = map.entry(\"occupied_key\");",
                "    let value = entry.or_default();",
                "    let result = *value;",
                "    assert_eq!(result, Some(42));",
                "    assert_eq!(map[\"occupied_key\"], Some(42));",
                "    assert_eq!(map.entry(\"occupied_key\").or_default(), &mut Some(42));",
                "    assert_eq!(map.get(\"occupied_key\"), Some(&Some(42)));",
                "    assert!(map.contains_key(\"occupied_key\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::hash_map::{Entry, HashMap};",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut map: HashMap<u32, String, RandomState> = HashMap::new();",
                "    map.insert(1, String::from(\"value\"));",
                "",
                "    let entry = map.entry(1);",
                "    let value = entry.or_default();",
                "    let result = value.clone();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, String::from(\"value\"));",
                "    assert_eq!(value, &mut String::from(\"value\"));",
                "    assert!(map.get(&1).is_some());",
                "    assert_eq!(map.entry(1).or_default(), &mut String::from(\"value\"));"
              ],
              "code": [
                "{",
                "    use hashbrown::hash_map::{Entry, HashMap};",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut map: HashMap<u32, String, RandomState> = HashMap::new();",
                "    map.insert(1, String::from(\"value\"));",
                "",
                "    let entry = map.entry(1);",
                "    let value = entry.or_default();",
                "    let result = value.clone();",
                "    assert_eq!(result, String::from(\"value\"));",
                "    assert_eq!(value, &mut String::from(\"value\"));",
                "    assert!(map.get(&1).is_some());",
                "    assert_eq!(map.entry(1).or_default(), &mut String::from(\"value\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}