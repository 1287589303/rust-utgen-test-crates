{
  "name": "hashbrown::map::{impl#81}::key",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:78:1:78:9"
  },
  "visible": true,
  "loc": "src/map.rs:4255:5:4263:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: *self matches EntryRef::Vacant(ref entry) at line 4259 is true\n",
        "expected return value/type: match *self {\n            EntryRef::Occupied(ref entry) => entry.key().borrow(),\n            EntryRef::Vacant(ref entry) => entry.key(),\n        }\n"
      ],
      "input_infer": "EntryRef::Vacant with a key of type Q that is Borrowed and a valid reference to an empty HashMap or a specific non-existent key in a populated HashMap.\n",
      "answers": [
        {
          "uses": [
            "use hashbrown::HashMap;",
            "use hashbrown::hash_map::EntryRef;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::hash_map::EntryRef;",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "    let key = \"nonexistent_key\";",
                "",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "    let result = entry_ref.key();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, \"nonexistent_key\");"
              ],
              "code": [
                "{",
                "    use hashbrown::hash_map::EntryRef;",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "    let key = \"nonexistent_key\";",
                "",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "    let result = entry_ref.key();",
                "    assert_eq!(result, \"nonexistent_key\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::hash_map::EntryRef;",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "    map.insert(\"existing_key\".to_owned(), 1);",
                "    let key = \"nonexistent_key\";",
                "",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "    let result = entry_ref.key();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, \"nonexistent_key\");"
              ],
              "code": [
                "{",
                "    use hashbrown::hash_map::EntryRef;",
                "    use hashbrown::HashMap;",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "    map.insert(\"existing_key\".to_owned(), 1);",
                "    let key = \"nonexistent_key\";",
                "",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &key,",
                "        table: &mut map,",
                "    });",
                "    let result = entry_ref.key();",
                "    assert_eq!(result, \"nonexistent_key\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: *self matches EntryRef::Occupied(ref entry) at line 4259 is true\n",
        "precondition: *self matches EntryRef::Occupied(ref entry) at line 4259 is true\n",
        "expected return value/type: match *self {\n            EntryRef::Occupied(ref entry) => entry.key().borrow(),\n            EntryRef::Vacant(ref entry) => entry.key(),\n        }\n"
      ],
      "input_infer": "EntryRef::Occupied with a key of type K implementing Borrow<Q> and V, and EntryRef::Vacant with a key of type K implementing Borrow<Q> and V where K is a string or similar type, and Q is a compatible type; test with existing keys in the map and a key that is not present.\n",
      "answers": [
        {
          "uses": [
            "use hashbrown::hash_map::HashMap;",
            "use hashbrown::hash_map::EntryRef;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::hash_map::{EntryRef, HashMap};",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "    map.insert(\"poneyland\".to_owned(), 3);",
                "",
                "    let entry_ref = EntryRef::Occupied(OccupiedEntry {",
                "        hash: 0,",
                "        elem: Bucket::new((String::from(\"poneyland\"), 3)),",
                "        table: &mut map,",
                "    });",
                "",
                "    let key = entry_ref.key();",
                "    let key_borrowed: &str = key.borrow();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(key_borrowed, \"poneyland\");",
                "    assert_eq!(entry_ref.key(), \"poneyland\");"
              ],
              "code": [
                "{",
                "    use hashbrown::hash_map::{EntryRef, HashMap};",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "    map.insert(\"poneyland\".to_owned(), 3);",
                "",
                "    let entry_ref = EntryRef::Occupied(OccupiedEntry {",
                "        hash: 0,",
                "        elem: Bucket::new((String::from(\"poneyland\"), 3)),",
                "        table: &mut map,",
                "    });",
                "",
                "    let key = entry_ref.key();",
                "    let key_borrowed: &str = key.borrow();",
                "    assert_eq!(key_borrowed, \"poneyland\");",
                "    assert_eq!(entry_ref.key(), \"poneyland\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::hash_map::{EntryRef, HashMap};",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &\"horseland\",",
                "        table: &mut map,",
                "    });",
                "",
                "    let key = entry_ref.key();",
                "    let key_borrowed: &str = key.borrow();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(key_borrowed, \"horseland\");",
                "    assert_eq!(map.entry_ref(\"horseland\").key(), \"horseland\");",
                "    let entry_ref_occupied = EntryRef::Occupied(OccupiedEntry {",
                "    hash: 1,",
                "    elem: Bucket::new((\"poneyland\", 3)),",
                "    table: &mut map",
                "    });",
                "    let key_occupied = entry_ref_occupied.key();",
                "    let key_borrowed_occupied: &str = key_occupied.borrow();",
                "    assert_eq!(key_borrowed_occupied, \"poneyland\");",
                "    map.insert(\"poneyland\".to_owned(), 3);",
                "    assert_eq!(map.entry_ref(\"poneyland\").key(), \"poneyland\");"
              ],
              "code": [
                "{",
                "    use hashbrown::hash_map::{EntryRef, HashMap};",
                "",
                "    let mut map: HashMap<String, u32> = HashMap::new();",
                "",
                "    let entry_ref = EntryRef::Vacant(VacantEntryRef {",
                "        hash: 0,",
                "        key: &\"horseland\",",
                "        table: &mut map,",
                "    });",
                "",
                "    let key = entry_ref.key();",
                "    let key_borrowed: &str = key.borrow();",
                "    assert_eq!(key_borrowed, \"horseland\");",
                "    assert_eq!(map.entry_ref(\"horseland\").key(), \"horseland\");",
                "    let entry_ref_occupied = EntryRef::Occupied(OccupiedEntry {",
                "    hash: 1,",
                "    elem: Bucket::new((\"poneyland\", 3)),",
                "    table: &mut map",
                "    });",
                "    let key_occupied = entry_ref_occupied.key();",
                "    let key_borrowed_occupied: &str = key_occupied.borrow();",
                "    assert_eq!(key_borrowed_occupied, \"poneyland\");",
                "    map.insert(\"poneyland\".to_owned(), 3);",
                "    assert_eq!(map.entry_ref(\"poneyland\").key(), \"poneyland\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}