{
  "name": "hashbrown::raw_entry::{impl#4}::search",
  "mod_info": {
    "name": "raw_entry",
    "loc": "src/lib.rs:80:1:80:15"
  },
  "visible": false,
  "loc": "src/raw_entry.rs:599:5:614:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.map.table.find(hash, |(k, _)| is_match(k)) matches Some(elem) at line 603 is true\n",
        "precondition: self.map.table.find(hash, |(k, _)| is_match(k)) matches Some(elem) at line 603 is true\n",
        "expected return value/type: RawEntryMut::Occupied(RawOccupiedEntryMut {\n                elem,\n                table: &mut self.map.table,\n                hash_builder: &self.map.hash_builder,\n            })\n"
      ],
      "input_infer": "self.map.table must be populated with at least one key-value pair, hash must correspond to an existing entry's hash, and is_match must return true for that existing key\n",
      "answers": [
        {
          "uses": [
            "use crate::hashbrown::HashMap;",
            "use std::hash::Hash;",
            "use std::hash::Hasher;",
            "use std::collections::hash_map::DefaultHasher;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::hashbrown::HashMap;",
                "    use std::collections::hash_map::DefaultHasher;",
                "    use std::hash::{Hash, Hasher};",
                "",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"a\", 100);",
                "",
                "    let hash = {",
                "        let mut hasher = DefaultHasher::new();",
                "        \"a\".hash(&mut hasher);",
                "        hasher.finish()",
                "    };",
                "",
                "    let result = {",
                "        let builder = RawEntryBuilderMut { map: &mut map };",
                "        builder.search(hash, |key| key == &\"a\")",
                "    };",
                "",
                "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, RawEntryMut::Occupied(_)));",
                "    let occupied_entry = if let RawEntryMut::Occupied(entry) = result { entry } else { panic!(\"Expected an occupied entry\") };",
                "    assert_eq!(occupied_entry.elem.ptr.as_ref(), &(\"a\", 100));",
                "    assert_eq!(occupied_entry.table, &mut map.table);",
                "    assert_eq!(occupied_entry.hash_builder, &map.hash_builder);"
              ],
              "code": [
                "{",
                "    use crate::hashbrown::HashMap;",
                "    use std::collections::hash_map::DefaultHasher;",
                "    use std::hash::{Hash, Hasher};",
                "",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"a\", 100);",
                "",
                "    let hash = {",
                "        let mut hasher = DefaultHasher::new();",
                "        \"a\".hash(&mut hasher);",
                "        hasher.finish()",
                "    };",
                "",
                "    let result = {",
                "        let builder = RawEntryBuilderMut { map: &mut map };",
                "        builder.search(hash, |key| key == &\"a\")",
                "    };",
                "",
                "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
                "    assert!(matches!(result, RawEntryMut::Occupied(_)));",
                "    let occupied_entry = if let RawEntryMut::Occupied(entry) = result { entry } else { panic!(\"Expected an occupied entry\") };",
                "   assert_eq!(occupied_entry.elem.as_ref(), &(\"a\", 100));",
                "   assert_eq!(occupied_entry.table, &mut map.table);",
                "    assert_eq!(occupied_entry.hash_builder, &map.hash_builder);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::hashbrown::HashMap;",
                "    use std::collections::hash_map::DefaultHasher;",
                "    use std::hash::{Hash, Hasher};",
                "",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"b\", 200);",
                "",
                "    let hash = {",
                "        let mut hasher = DefaultHasher::new();",
                "        \"b\".hash(&mut hasher);",
                "        hasher.finish()",
                "    };",
                "",
                "    let result = {",
                "        let builder = RawEntryBuilderMut { map: &mut map };",
                "        builder.search(hash, |key| key == &\"b\")",
                "    };",
                "",
                "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, RawEntryMut::Occupied(_)));",
                "    assert_eq!(if let RawEntryMut::Occupied(entry) = result { entry.elem } else { panic!(\"Expected Occupied entry\") }, /* expected occupied entry value here */);",
                "    assert_eq!(result.hash_builder, &map.hash_builder);",
                "    assert_eq!(result.table, &mut map.table);"
              ],
              "code": [
                "{",
                "    use crate::hashbrown::HashMap;",
                "    use std::collections::hash_map::DefaultHasher;",
                "    use std::hash::{Hash, Hasher};",
                "",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"b\", 200);",
                "",
                "    let hash = {",
                "        let mut hasher = DefaultHasher::new();",
                "        \"b\".hash(&mut hasher);",
                "        hasher.finish()",
                "    };",
                "",
                "    let result = {",
                "        let builder = RawEntryBuilderMut { map: &mut map };",
                "        builder.search(hash, |key| key == &\"b\")",
                "    };",
                "",
                "    // Implicitly verified that result is of type `RawEntryMut::Occupied`",
                "   assert!(matches!(result, RawEntryMut::Occupied(_)));",
                "   assert_eq!(if let RawEntryMut::Occupied(entry) = result { entry.get() } else { panic!(\"Expected Occupied entry\") }, &200);",
                "  assert!(matches!(result, RawEntryMut::Occupied(_))); // This will ensure we have an occupied entry",
                "  // Removed access to non-existent `hash_builder` field.",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.map.table.find(hash, |(k, _)| is_match(k)) matches None at line 603 is true\n",
        "expected return value/type: RawEntryMut::Vacant(RawVacantEntryMut {\n                table: &mut self.map.table,\n                hash_builder: &self.map.hash_builder,\n            })\n"
      ],
      "input_infer": "hash: any u64 value where no key K satisfies is_match implementation from the HashMap, self.map.table must be empty or contain keys not matching the is_match predicate\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    let hash = 12345; // some arbitrary u64",
                "    let is_match = |key: &&str| *key == \"nonexistent_key\";",
                "    let builder = RawEntryBuilderMut { map: &mut map };",
                "    let result = builder.search(hash, is_match);",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    let hash = 12345; // some arbitrary u64",
                "    let is_match = |key: &&str| *key == \"nonexistent_key\";",
                "    let builder = RawEntryBuilderMut { map: &mut map };",
                "    let result = builder.search(hash, is_match);",
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"a\", 100);",
                "    map.insert(\"b\", 200);",
                "    let hash = 12345; // some arbitrary u64",
                "    let is_match = |key: &&str| *key == \"nonexistent_key\";",
                "    let builder = RawEntryBuilderMut { map: &mut map };",
                "    let result = builder.search(hash, is_match);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, RawEntryMut::Vacant(RawVacantEntryMut { table: &mut map.table, hash_builder: &map.hash_builder }));"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"a\", 100);",
                "    map.insert(\"b\", 200);",
                "    let hash = 12345; // some arbitrary u64",
                "    let is_match = |key: &&str| *key == \"nonexistent_key\";",
                "    let builder = RawEntryBuilderMut { map: &mut map };",
                "    let result = builder.search(hash, is_match);",
                "    assert_eq!(result, RawEntryMut::Vacant(RawVacantEntryMut { table: &mut map.table, hash_builder: &map.hash_builder }));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"a\", 100);",
                "    let hash = 67890; // a hash that doesn't match any existing keys",
                "    let is_match = |key: &&str| *key == \"a\";",
                "    let builder = RawEntryBuilderMut { map: &mut map };",
                "    let result = builder.search(hash, is_match);",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));",
                "    assert_eq!(result, RawEntryMut::Vacant(RawVacantEntryMut { table: &mut map.table, hash_builder: &map.hash_builder }));"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<&str, i32> = HashMap::new();",
                "    map.insert(\"a\", 100);",
                "    let hash = 67890; // a hash that doesn't match any existing keys",
                "    let is_match = |key: &&str| *key == \"a\";",
                "    let builder = RawEntryBuilderMut { map: &mut map };",
                "    let result = builder.search(hash, is_match);",
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));",
                "    assert_eq!(result, RawEntryMut::Vacant(RawVacantEntryMut { table: &mut map.table, hash_builder: &map.hash_builder }));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}