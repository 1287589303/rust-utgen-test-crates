{
  "name": "hashbrown::map::{impl#5}::contains_key",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:78:1:78:9"
  },
  "visible": true,
  "loc": "src/map.rs:1414:5:1419:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "K must implement Eq and Hash; Q must implement Hash and Equivalent<K>; k can be a reference of type &Q; tested keys include valid keys, invalid keys, and edge cases like None or empty key (if applicable).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<i32, &str> = HashMap::new();",
                "    map.insert(1, \"a\");",
                "    map.insert(2, \"b\");",
                "    let result = map.contains_key(&1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    let result_false = map.contains_key(&3);",
                "    assert_eq!(result_false, false);",
                "    let result_borrowed = map.contains_key(&2);",
                "    assert_eq!(result_borrowed, true);"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<i32, &str> = HashMap::new();",
                "    map.insert(1, \"a\");",
                "    map.insert(2, \"b\");",
                "    let result = map.contains_key(&1);",
                "    assert_eq!(result, true);",
                "    let result_false = map.contains_key(&3);",
                "    assert_eq!(result_false, false);",
                "    let result_borrowed = map.contains_key(&2);",
                "    assert_eq!(result_borrowed, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<i32, &str> = HashMap::new();",
                "    map.insert(1, \"a\");",
                "    map.insert(2, \"b\");",
                "    let result = map.contains_key(&3);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<i32, &str> = HashMap::new();",
                "    map.insert(1, \"a\");",
                "    map.insert(2, \"b\");",
                "    let result = map.contains_key(&3);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<String, &str> = HashMap::new();",
                "    map.insert(\"test\".to_string(), \"a\");",
                "    let result = map.contains_key(&\"test\".to_string());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    ",
                "    let result_false = map.contains_key(&\"nonexistent\".to_string());",
                "    assert_eq!(result_false, false);",
                "    ",
                "    let result_not_borrowed = map.contains_key(&\"test\");",
                "    assert_eq!(result_not_borrowed, true);",
                "    ",
                "    let empty_map: HashMap<String, &str> = HashMap::new();",
                "    let result_empty = empty_map.contains_key(&\"test\".to_string());",
                "    assert_eq!(result_empty, false);",
                "    ",
                "    let different_type_key = map.contains_key(&String::from(\"test\"));",
                "    assert_eq!(different_type_key, true);",
                "    ",
                "    let result_key_with_different_case = map.contains_key(&\"Test\".to_string());",
                "    assert_eq!(result_key_with_different_case, false);"
              ],
              "code": [
                "{",
                "  use std::string::String;  ",
                "  let mut map: HashMap<String, &str> = HashMap::new();  ",
                "   map.insert(\"test\".to_string(), \"a\");",
                "   let result = map.contains_key(\"test\");",
                "   assert_eq!(result, true);",
                "   ",
                "   let result_false = map.contains_key(\"nonexistent\");",
                "   assert_eq!(result_false, false);",
                "   ",
                "   let result_not_borrowed = map.contains_key(\"test\");",
                "   assert_eq!(result_not_borrowed, true);",
                "   ",
                "   let empty_map: HashMap<String, &str> = HashMap::new();",
                "   let result_empty = empty_map.contains_key(\"test\");",
                "   assert_eq!(result_empty, false);",
                "   ",
                "   let different_type_key = map.contains_key(&String::from(\"test\"));",
                "   assert_eq!(different_type_key, true);",
                "   ",
                "   let result_key_with_different_case = map.contains_key(\"Test\");",
                "   assert_eq!(result_key_with_different_case, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<String, &str> = HashMap::new();",
                "    map.insert(\"test\".to_string(), \"a\");",
                "    let result = map.contains_key(&None::<String>);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "      let mut map: HashMap<std::string::String, &str> = HashMap::new();  ",
                "      map.insert(\"test\".to_string(), \"a\");  ",
                "      let result = map.contains_key(&None::<std::string::String>);  ",
                "      assert_eq!(result, false);  ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}