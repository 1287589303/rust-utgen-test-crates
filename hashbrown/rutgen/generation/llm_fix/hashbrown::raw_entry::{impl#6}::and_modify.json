{
  "name": "hashbrown::raw_entry::{impl#6}::and_modify",
  "mod_info": {
    "name": "raw_entry",
    "loc": "src/lib.rs:80:1:80:15"
  },
  "visible": true,
  "loc": "src/raw_entry.rs:821:5:835:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches RawEntryMut::Vacant(entry) at line 825 is true\n",
        "expected return value/type: RawEntryMut::Vacant(entry)\n"
      ],
      "input_infer": "RawEntryMut::Vacant for keys not present in the HashMap, with types K (Hashable) and V (Any Value Type), where F is a function that takes mutable references to K and V primarily.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(\"missing_key\");",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "}"
              ],
              "oracle": [
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(\"missing_key\");",
                "    assert!(matches!(entry, RawEntryMut::Vacant(_)));",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(\"missing_key\");",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(\"missing_key\");",
                "    assert!(matches!(entry, RawEntryMut::Vacant(_)));",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<i32, i32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(&42);",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<i32, i32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(&42);",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<String, i32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(&\"non_existent_key\".to_string());",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<String, i32> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(&\"non_existent_key\".to_string());",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: HashMap<&str, f64> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(\"absent_key\");",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));"
              ],
              "code": [
                "{",
                "    let mut map: HashMap<&str, f64> = HashMap::new();",
                "    let entry = map.raw_entry_mut().from_key(\"absent_key\");",
                "    let result = entry.and_modify(|_k, _v| { /* no-op */ });",
                "    assert!(matches!(result, RawEntryMut::Vacant(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches RawEntryMut::Occupied(mut entry) at line 825 is true\n",
        "precondition: self matches RawEntryMut::Occupied(mut entry) at line 825 is true\n",
        "expected return value/type: RawEntryMut::Occupied(entry)\n"
      ],
      "input_infer": "self should be of type RawEntryMut::Occupied with a valid key and value present in the HashMap, where K implements Hash and V is mutable.\n",
      "answers": [
        {
          "uses": [
            "use hashbrown::hash_map::RawEntryMut;",
            "use std::hash::BuildHasherDefault;",
            "use hashbrown::HashMap;",
            "use std::collections::hash_map::DefaultHasher;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::{hash_map::RawEntryMut, HashMap};",
                "    use std::hash::BuildHasherDefault;",
                "    use std::collections::hash_map::DefaultHasher;",
                "",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 41);",
                "",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "        elem: Bucket::new(&(map[\"poneyland\"], 41)),",
                "        table: &mut map.raw_table,",
                "        hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "",
                "    entry.and_modify(|_k, v| {",
                "        *v += 1;",
                "    });",
                "}"
              ],
              "oracle": [
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 41);",
                "    assert!(matches!(entry, RawEntryMut::Occupied(_)));",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "    elem: Bucket::new(&(map[\"poneyland\"], 41)),",
                "    table: &mut map.raw_table,",
                "    hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "    let modified_entry = entry.and_modify(|_k, v| {",
                "    *v += 1;",
                "    });",
                "    assert!(matches!(modified_entry, RawEntryMut::Occupied(_)));",
                "    assert_eq!(map[\"poneyland\"], 42);",
                "    entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "    elem: Bucket::new(&(map[\"poneyland\"], 42)),",
                "    table: &mut map.raw_table,",
                "    hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "    let modified_entry = entry.and_modify(|_k, v| {",
                "    *v += 1;",
                "    });",
                "    assert!(matches!(modified_entry, RawEntryMut::Occupied(_)));",
                "    assert_eq!(map[\"poneyland\"], 43);"
              ],
              "code": [
                "{",
                "    use hashbrown::{hash_map::RawEntryMut, HashMap};",
                "    use std::hash::BuildHasherDefault;",
                "    use std::collections::hash_map::DefaultHasher;",
                "",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 41);",
                "",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "        elem: Bucket::new(&(map[\"poneyland\"], 41)),",
                "        table: &mut map.raw_table,",
                "        hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "",
                "    entry.and_modify(|_k, v| {",
                "        *v += 1;",
                "    });",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 41);",
                "    assert!(matches!(entry, RawEntryMut::Occupied(_)));",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "    elem: Bucket::new(&(map[\"poneyland\"], 41)),",
                "    table: &mut map.raw_table,",
                "    hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "    let modified_entry = entry.and_modify(|_k, v| {",
                "    *v += 1;",
                "    });",
                "    assert!(matches!(modified_entry, RawEntryMut::Occupied(_)));",
                "    assert_eq!(map[\"poneyland\"], 42);",
                "    entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "    elem: Bucket::new(&(map[\"poneyland\"], 42)),",
                "    table: &mut map.raw_table,",
                "    hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "    let modified_entry = entry.and_modify(|_k, v| {",
                "    *v += 1;",
                "    });",
                "    assert!(matches!(modified_entry, RawEntryMut::Occupied(_)));",
                "    assert_eq!(map[\"poneyland\"], 43);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use hashbrown::{hash_map::RawEntryMut, HashMap};",
                "    use std::hash::BuildHasherDefault;",
                "    use std::collections::hash_map::DefaultHasher;",
                "",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 10);",
                "    ",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "        elem: Bucket::new(&(map[\"poneyland\"], 10)),",
                "        table: &mut map.raw_table,",
                "        hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "",
                "    entry.and_modify(|_k, v| {",
                "        *v += 5;",
                "    });",
                "}"
              ],
              "oracle": [
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 10);",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "    elem: Bucket::new(&(map[\"poneyland\"], 10)),",
                "    table: &mut map.raw_table,",
                "    hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "    let expected_value = 15;",
                "    entry.and_modify(|_k, v| { *v += 5; });",
                "    assert_eq!(map[\"poneyland\"], expected_value);"
              ],
              "code": [
                "{",
                "    use hashbrown::{hash_map::RawEntryMut, HashMap};",
                "    use std::hash::BuildHasherDefault;",
                "    use std::collections::hash_map::DefaultHasher;",
                "",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 10);",
                "    ",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "        elem: Bucket::new(&(map[\"poneyland\"], 10)),",
                "        table: &mut map.raw_table,",
                "        hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "",
                "    entry.and_modify(|_k, v| {",
                "        *v += 5;",
                "    });",
                "    let mut map: HashMap<&str, u32> = HashMap::new();",
                "    map.insert(\"poneyland\", 10);",
                "    let mut entry = RawEntryMut::Occupied(RawOccupiedEntryMut {",
                "    elem: Bucket::new(&(map[\"poneyland\"], 10)),",
                "    table: &mut map.raw_table,",
                "    hash_builder: &BuildHasherDefault::<DefaultHasher>::default(),",
                "    });",
                "    let expected_value = 15;",
                "    entry.and_modify(|_k, v| { *v += 5; });",
                "    assert_eq!(map[\"poneyland\"], expected_value);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}