{
  "name": "hashbrown::raw::{impl#2}::move_next",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:74:1:74:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:83:5:93:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.stride <= bucket_mask at line 86 is true, with bound self.stride == bucket_mask\n"
      ],
      "input_infer": "self.stride values in the range [0, bucket_mask] and bucket_mask must be a non-negative integer\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 10 };",
                "    let bucket_mask = 10; // self.stride == bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 20);",
                "    assert!((0..=bucket_mask).contains(&probe_seq.pos));",
                "    assert!(probe_seq.stride > 10);"
              ],
              "code": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 10 };",
                "    let bucket_mask = 10; // self.stride == bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 20);",
                "    assert!((0..=bucket_mask).contains(&probe_seq.pos));",
                "    assert!(probe_seq.stride > 10);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 0 };",
                "    let bucket_mask = 0; // self.stride <= bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "}"
              ],
              "oracle": [
                "    debug_assert!(probe_seq.stride <= bucket_mask, \"Stride should be equal to bucket_mask\");",
                "    debug_assert_eq!(probe_seq.stride, Group::WIDTH);",
                "    debug_assert_eq!(probe_seq.pos, Group::WIDTH);",
                "    debug_assert_eq!(probe_seq.pos & bucket_mask, 0);"
              ],
              "code": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 0 };",
                "    let bucket_mask = 0; // self.stride <= bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "    debug_assert!(probe_seq.stride <= bucket_mask, \"Stride should be equal to bucket_mask\");",
                "    debug_assert_eq!(probe_seq.stride, Group::WIDTH);",
                "    debug_assert_eq!(probe_seq.pos, Group::WIDTH);",
                "    debug_assert_eq!(probe_seq.pos & bucket_mask, 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 5, stride: 5 };",
                "    let bucket_mask = 5; // self.stride == bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 10);",
                "    assert!(probe_seq.stride > bucket_mask);",
                "    assert!(probe_seq.pos <= bucket_mask);",
                "    assert_eq!(probe_seq.pos & bucket_mask, 0);"
              ],
              "code": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 5, stride: 5 };",
                "    let bucket_mask = 5; // self.stride == bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 10);",
                "    assert!(probe_seq.stride > bucket_mask);",
                "    assert!(probe_seq.pos <= bucket_mask);",
                "    assert_eq!(probe_seq.pos & bucket_mask, 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 2, stride: 2 };",
                "    let bucket_mask = 10; // self.stride < bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(probe_seq.stride, 12);",
                "    assert_eq!(probe_seq.pos, 4);",
                "    assert_eq!(probe_seq.pos & bucket_mask, 4);",
                "    assert!(probe_seq.stride <= bucket_mask + Group::WIDTH);"
              ],
              "code": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 2, stride: 2 };",
                "    let bucket_mask = 10; // self.stride < bucket_mask",
                "    probe_seq.move_next(bucket_mask);",
                "    assert_eq!(probe_seq.stride, 12);",
                "    assert_eq!(probe_seq.pos, 4);",
                "    assert_eq!(probe_seq.pos & bucket_mask, 4);",
                "    assert!(probe_seq.stride <= bucket_mask + Group::WIDTH);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.stride <= bucket_mask at line 86 is false\n"
      ],
      "input_infer": "self.stride > bucket_mask and self.stride is a non-negative integer; bucket_mask is a non-negative integer greater than or equal to 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 10 }; // striding greater than bucket_mask",
                "    let bucket_mask = 5; // bucket_mask is less than stride",
                "    probe_seq.move_next(bucket_mask);",
                "}"
              ],
              "oracle": [
                "    debug_assert!(probe_seq.stride > bucket_mask, \"Stride should be greater than bucket_mask to trigger panic\");",
                "    assert!(std::panic::catch_unwind(|| probe_seq.move_next(bucket_mask)).is_err(), \"Expected panic when stride is greater than bucket_mask\");"
              ],
              "code": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 10 }; // striding greater than bucket_mask",
                "    let bucket_mask = 5; // bucket_mask is less than stride",
                "    probe_seq.move_next(bucket_mask);",
                "    debug_assert!(probe_seq.stride > bucket_mask, \"Stride should be greater than bucket_mask to trigger panic\");",
                "    assert!(std::panic::catch_unwind(|| probe_seq.move_next(bucket_mask)).is_err(), \"Expected panic when stride is greater than bucket_mask\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 5 }; // striding equal to bucket_mask",
                "    let bucket_mask = 5; // bucket_mask is equal to stride",
                "    probe_seq.move_next(bucket_mask);",
                "}"
              ],
              "oracle": [
                "    debug_assert!(probe_seq.stride <= bucket_mask, \"Went past end of probe sequence\");",
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 5 + Group::WIDTH);",
                "    assert_eq!(probe_seq.pos & bucket_mask, 0);",
                "    assert!(std::panic::catch_unwind(|| { probe_seq.move_next(bucket_mask); }).is_err());"
              ],
              "code": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 5 }; // striding equal to bucket_mask",
                "    let bucket_mask = 5; // bucket_mask is equal to stride",
                "    probe_seq.move_next(bucket_mask);",
                "    debug_assert!(probe_seq.stride <= bucket_mask, \"Went past end of probe sequence\");",
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 5 + Group::WIDTH);",
                "    assert_eq!(probe_seq.pos & bucket_mask, 0);",
                "    assert!(std::panic::catch_unwind(|| { probe_seq.move_next(bucket_mask); }).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 100 }; // striding much greater than bucket_mask",
                "    let bucket_mask = 50; // bucket_mask is less than stride",
                "    probe_seq.move_next(bucket_mask);",
                "}"
              ],
              "oracle": [
                "    debug_assert!(probe_seq.stride > bucket_mask);",
                "    assert!(std::panic::catch_unwind(|| probe_seq.move_next(bucket_mask)).is_err());",
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 100);"
              ],
              "code": [
                "{",
                "    let mut probe_seq = ProbeSeq { pos: 0, stride: 100 }; // striding much greater than bucket_mask",
                "    let bucket_mask = 50; // bucket_mask is less than stride",
                "    probe_seq.move_next(bucket_mask);",
                "    debug_assert!(probe_seq.stride > bucket_mask);",
                "    assert!(std::panic::catch_unwind(|| probe_seq.move_next(bucket_mask)).is_err());",
                "    assert_eq!(probe_seq.pos, 0);",
                "    assert_eq!(probe_seq.stride, 100);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}