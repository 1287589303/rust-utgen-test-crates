[
  {
    "uses": [
      "use std::thread;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockProcMacro;",
          "",
          "    impl MockProcMacro {",
          "        fn is_available() -> bool {",
          "            true",
          "        }",
          "    }",
          "",
          "    let available = MockProcMacro::is_available();",
          "    WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "}"
        ],
        "oracle": [
          "    WORKS.load(Ordering::Relaxed) == 2",
          "    WORKS.load(Ordering::Relaxed) == 1",
          "    WORKS.load(Ordering::Relaxed) == 0",
          "    WORKS.load(Ordering::Relaxed) == 3",
          "    WORKS.load(Ordering::Relaxed) < 2",
          "    WORKS.load(Ordering::Relaxed) > 0"
        ],
        "code": [
          "{",
          "    struct MockProcMacro;",
          "",
          "    impl MockProcMacro {",
          "        fn is_available() -> bool {",
          "            true",
          "        }",
          "    }",
          "",
          "    let available = MockProcMacro::is_available();",
          "    WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "    WORKS.load(Ordering::Relaxed) == 2",
          "    WORKS.load(Ordering::Relaxed) == 1",
          "    WORKS.load(Ordering::Relaxed) == 0",
          "    WORKS.load(Ordering::Relaxed) == 3",
          "    WORKS.load(Ordering::Relaxed) < 2",
          "    WORKS.load(Ordering::Relaxed) > 0",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockProcMacro;",
          "",
          "    impl MockProcMacro {",
          "        fn is_available() -> bool {",
          "            false",
          "        }",
          "    }",
          "",
          "    let available = MockProcMacro::is_available();",
          "    WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(WORKS.load(Ordering::Relaxed), 1);",
          "    assert_eq!(MockProcMacro::is_available(), false);",
          "    WORKS.store(1, Ordering::Relaxed);"
        ],
        "code": [
          "{",
          "    struct MockProcMacro;",
          "",
          "    impl MockProcMacro {",
          "        fn is_available() -> bool {",
          "            false",
          "        }",
          "    }",
          "",
          "    let available = MockProcMacro::is_available();",
          "    WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "    assert_eq!(WORKS.load(Ordering::Relaxed), 1);",
          "    assert_eq!(MockProcMacro::is_available(), false);",
          "    WORKS.store(1, Ordering::Relaxed);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::thread;",
          "",
          "    let handles: Vec<_> = (0..10)",
          "        .map(|_| {",
          "            thread::spawn(|| {",
          "                struct MockProcMacro;",
          "",
          "                impl MockProcMacro {",
          "                    fn is_available() -> bool {",
          "                        true",
          "                    }",
          "                }",
          "",
          "                let available = MockProcMacro::is_available();",
          "                WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "            })",
          "        })",
          "        .collect();",
          "",
          "    for handle in handles {",
          "        handle.join().unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    WORKS.load(Ordering::Relaxed) == 11",
          "    WORKS.load(Ordering::Relaxed) == 10",
          "    WORKS.load(Ordering::Relaxed) >= 1",
          "    WORKS.load(Ordering::Relaxed) <= 11",
          "    WORKS.load(Ordering::Relaxed) % 1 == 0",
          "    WORKS.load(Ordering::Relaxed) != 0"
        ],
        "code": [
          "{",
          "    use std::thread;",
          "",
          "    let handles: Vec<_> = (0..10)",
          "        .map(|_| {",
          "            thread::spawn(|| {",
          "                struct MockProcMacro;",
          "",
          "                impl MockProcMacro {",
          "                    fn is_available() -> bool {",
          "                        true",
          "                    }",
          "                }",
          "",
          "                let available = MockProcMacro::is_available();",
          "                WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "            })",
          "        })",
          "        .collect();",
          "",
          "    for handle in handles {",
          "        handle.join().unwrap();",
          "    }",
          "    WORKS.load(Ordering::Relaxed) == 11",
          "    WORKS.load(Ordering::Relaxed) == 10",
          "    WORKS.load(Ordering::Relaxed) >= 1",
          "    WORKS.load(Ordering::Relaxed) <= 11",
          "    WORKS.load(Ordering::Relaxed) % 1 == 0",
          "    WORKS.load(Ordering::Relaxed) != 0",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::thread;",
          "",
          "    let handles: Vec<_> = (0..10)",
          "        .map(|_| {",
          "            thread::spawn(|| {",
          "                struct MockProcMacro;",
          "",
          "                impl MockProcMacro {",
          "                    fn is_available() -> bool {",
          "                        false",
          "                    }",
          "                }",
          "",
          "                let available = MockProcMacro::is_available();",
          "                WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "            })",
          "        })",
          "        .collect();",
          "",
          "    for handle in handles {",
          "        handle.join().unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    WORKS.load(Ordering::Relaxed) == 1",
          "    WORKS.load(Ordering::Relaxed) == 10",
          "    WORKS.load(Ordering::Relaxed) >= 1",
          "    WORKS.load(Ordering::Relaxed) <= 10",
          "    assert_eq!(WORKS.load(Ordering::Relaxed), 1 + 1);",
          "    assert_eq!(WORKS.load(Ordering::Relaxed), 0 + 1);",
          "    assert!(WORKS.load(Ordering::Relaxed) > 0);",
          "    assert!(WORKS.load(Ordering::Relaxed) < 11);",
          "    assert!(WORKS.load(Ordering::Relaxed) != 0);",
          "    assert!(WORKS.load(Ordering::Relaxed) == 2 || WORKS.load(Ordering::Relaxed) == 1);"
        ],
        "code": [
          "{",
          "    use std::thread;",
          "",
          "    let handles: Vec<_> = (0..10)",
          "        .map(|_| {",
          "            thread::spawn(|| {",
          "                struct MockProcMacro;",
          "",
          "                impl MockProcMacro {",
          "                    fn is_available() -> bool {",
          "                        false",
          "                    }",
          "                }",
          "",
          "                let available = MockProcMacro::is_available();",
          "                WORKS.store(available as usize + 1, Ordering::Relaxed);",
          "            })",
          "        })",
          "        .collect();",
          "",
          "    for handle in handles {",
          "        handle.join().unwrap();",
          "    }",
          "    WORKS.load(Ordering::Relaxed) == 1",
          "    WORKS.load(Ordering::Relaxed) == 10",
          "    WORKS.load(Ordering::Relaxed) >= 1",
          "    WORKS.load(Ordering::Relaxed) <= 10",
          "    assert_eq!(WORKS.load(Ordering::Relaxed), 1 + 1);",
          "    assert_eq!(WORKS.load(Ordering::Relaxed), 0 + 1);",
          "    assert!(WORKS.load(Ordering::Relaxed) > 0);",
          "    assert!(WORKS.load(Ordering::Relaxed) < 11);",
          "    assert!(WORKS.load(Ordering::Relaxed) != 0);",
          "    assert!(WORKS.load(Ordering::Relaxed) == 2 || WORKS.load(Ordering::Relaxed) == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]