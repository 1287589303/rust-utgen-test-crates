[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\t \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\ \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\'' \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\"\" \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\0 \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\ \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\t \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\ \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\'' \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\"\" \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\0 \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\ \"# };",
          "    assert!(matches!(cooked_string(input), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# };",
          "    let expected = Err(Reject);",
          "    let result = cooked_string(input);",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# };",
          "    let expected = Err(Reject);",
          "    let result = cooked_string(input);",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    assert!(_result.is_err());",
          "    assert_eq!(_result.unwrap_err(), Reject);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n \"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    assert_eq!(_result.unwrap_err(), Reject);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\u \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\x \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\n \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\r \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\t \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\0 \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r\\n \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a trailing backslash: \\ \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"text with escaped character: \\\\' \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\u \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\x \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\n \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\r \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\t \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\0 \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r\\n \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"some text with a trailing backslash: \\ \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "    ",
          "    let input = Cursor { rest: r#\"text with escaped character: \\\\' \"# };",
          "    let _result = cooked_string(input);",
          "    assert_eq!(_result, Err(Reject));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\t \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\t \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\\"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\ \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text that ends with a backslash: \\ \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with invalid escape: \\z \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text ends with '\\\\'#; \"# }; assert!(cooked_string(input).is_err());"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\t \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\t \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\\"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\ \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text that ends with a backslash: \\ \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text with invalid escape: \\z \"# }; assert!(cooked_string(input).is_err());",
          "    let input = Cursor { rest: r#\"some text ends with '\\\\'#; \"# }; assert!(cooked_string(input).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\\\"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\\\"# };",
          "    assert_eq!(_result, Err(Reject));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\\\"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\\\"# };",
          "    assert_eq!(_result, Err(Reject));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\'' \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\u'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\x'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\n'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\r'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\t'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\\\''\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\\\\"\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\0'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\\\N'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\'' \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\u'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\x'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\n'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\r'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\t'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\\\''\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\\\\"\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\0'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: '\\\\\\N'\"# }; let _result = cooked_string(input); assert_eq!(_result, Err(Reject));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\"\" \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\\\" \"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\u{}\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\x\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\n\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\r\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with ending backslash: \"\\\\\"# }; assert_eq!(cooked_string(input), Err(Reject));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\"\" \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\\\\" \"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\u{}\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\x\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\n\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with a backslash: \"\\r\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "    let input = Cursor { rest: r#\"some text with ending backslash: \"\\\\\"# }; assert_eq!(cooked_string(input), Err(Reject));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\0 \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\0 \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\\\\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\x\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\n\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\r\"# };",
          "    let _result = cooked_string(input);",
          "    assert!(_result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u     \"# };",
          "    let _result = cooked_string(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u     \"# };",
          "    assert_eq!(_result, Err(Reject));",
          "    assert!(input.starts_with_char('\\\\'));",
          "    assert!(input.rest.contains(\"\\\\u\"));",
          "    assert!(input.is_empty() == false);",
          "    assert!(chars.next().is_some());",
          "    assert!(chars.next().is_some());",
          "    assert!(matches!(chars.next(), Some((_, 'u'))));",
          "    assert!(trailing_backslash(&mut input, b' ') == Ok(()));",
          "    assert!(chars.next().is_some());"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u     \"# };",
          "    let _result = cooked_string(input);",
          "    let input = Cursor { rest: r#\"some text with a backslash: \\u     \"# };",
          "    assert_eq!(_result, Err(Reject));",
          "    assert!(input.starts_with_char('\\\\'));",
          "    assert!(input.rest.contains(\"\\\\u\"));",
          "    assert!(input.is_empty() == false);",
          "    assert!(chars.next().is_some());",
          "    assert!(chars.next().is_some());",
          "    assert!(matches!(chars.next(), Some((_, 'u'))));",
          "    assert!(trailing_backslash(&mut input, b' ') == Ok(()));",
          "    assert!(chars.next().is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]