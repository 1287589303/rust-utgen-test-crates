[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let token_tree = TokenTree::Ident(Ident::new(\"single_ident\", Span::call_site()));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "}"
        ],
        "oracle": [
          "    assert!(stream.is_empty() == false);",
          "    assert_eq!(stream.inner.len(), 1);",
          "    assert!(matches!(stream.inner[0], TokenTree::Ident(_)));",
          "    assert_eq!(stream.inner[0].to_string(), \"single_ident\");",
          "    assert!(TokenStream::from_iter(Vec::<TokenTree>::new()).is_empty());"
        ],
        "code": [
          "{",
          "    let token_tree = TokenTree::Ident(Ident::new(\"single_ident\", Span::call_site()));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "    assert!(stream.is_empty() == false);",
          "    assert_eq!(stream.inner.len(), 1);",
          "    assert!(matches!(stream.inner[0], TokenTree::Ident(_)));",
          "    assert_eq!(stream.inner[0].to_string(), \"single_ident\");",
          "    assert!(TokenStream::from_iter(Vec::<TokenTree>::new()).is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let token_tree = TokenTree::Literal(Literal::new(\"literal_value\", Span::call_site()));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(stream.inner.len(), 1);",
          "    assert!(matches!(stream.inner[0], TokenTree::Literal(_)));",
          "    assert!(stream.inner[0].to_string() == \"literal_value\");",
          "    assert!(!stream.is_empty());",
          "    assert_eq!(TokenStream::new().is_empty(), true);",
          "    assert_eq!(TokenStream::from_iter(vec![]).inner.len(), 0);"
        ],
        "code": [
          "{",
          "    let token_tree = TokenTree::Literal(Literal::new(\"literal_value\", Span::call_site()));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "    assert_eq!(stream.inner.len(), 1);",
          "    assert!(matches!(stream.inner[0], TokenTree::Literal(_)));",
          "    assert!(stream.inner[0].to_string() == \"literal_value\");",
          "    assert!(!stream.is_empty());",
          "    assert_eq!(TokenStream::new().is_empty(), true);",
          "    assert_eq!(TokenStream::from_iter(vec![]).inner.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let token_tree = TokenTree::Punct(Punct::new('+', Spacing::Alone));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "}"
        ],
        "oracle": [
          "    let token_tree = TokenTree::Punct(Punct::new('+', Spacing::Alone));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "    assert!(!stream.is_empty());",
          "    assert_eq!(stream.inner.len(), 1);",
          "    assert!(matches!(stream.inner[0], TokenTree::Punct(_)));"
        ],
        "code": [
          "{",
          "    let token_tree = TokenTree::Punct(Punct::new('+', Spacing::Alone));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "    let token_tree = TokenTree::Punct(Punct::new('+', Spacing::Alone));",
          "    let stream = TokenStream::from_iter(vec![token_tree]);",
          "    assert!(!stream.is_empty());",
          "    assert_eq!(stream.inner.len(), 1);",
          "    assert!(matches!(stream.inner[0], TokenTree::Punct(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let token_trees = vec![",
          "        TokenTree::Ident(Ident::new(\"id\", Span::call_site())),",
          "        TokenTree::Literal(Literal::new(\"2\", Span::call_site())),",
          "        TokenTree::Punct(Punct::new(',', Spacing::Joint)),",
          "        TokenTree::Group(Group::new(Delimiter::Bracket, TokenStream::new())),",
          "    ];",
          "    let stream = TokenStream::from_iter(token_trees);",
          "}"
        ],
        "oracle": [
          "    assert!(stream.inner.len() == 4);",
          "    assert!(matches!(stream.inner[0], TokenTree::Ident(_)));",
          "    assert!(matches!(stream.inner[1], TokenTree::Literal(_)));",
          "    assert!(matches!(stream.inner[2], TokenTree::Punct(_)));",
          "    assert!(matches!(stream.inner[3], TokenTree::Group(_)));",
          "    assert!(!stream.is_empty());"
        ],
        "code": [
          "{",
          "    let token_trees = vec![",
          "        TokenTree::Ident(Ident::new(\"id\", Span::call_site())),",
          "        TokenTree::Literal(Literal::new(\"2\", Span::call_site())),",
          "        TokenTree::Punct(Punct::new(',', Spacing::Joint)),",
          "        TokenTree::Group(Group::new(Delimiter::Bracket, TokenStream::new())),",
          "    ];",
          "    let stream = TokenStream::from_iter(token_trees);",
          "    assert!(stream.inner.len() == 4);",
          "    assert!(matches!(stream.inner[0], TokenTree::Ident(_)));",
          "    assert!(matches!(stream.inner[1], TokenTree::Literal(_)));",
          "    assert!(matches!(stream.inner[2], TokenTree::Punct(_)));",
          "    assert!(matches!(stream.inner[3], TokenTree::Group(_)));",
          "    assert!(!stream.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let stream = TokenStream::from_iter(vec![]);",
          "}"
        ],
        "oracle": [
          "    let stream = TokenStream::from_iter(vec![]);",
          "    assert!(stream.is_empty());"
        ],
        "code": [
          "{",
          "    let stream = TokenStream::from_iter(vec![]);",
          "    let stream = TokenStream::from_iter(vec![]);",
          "    assert!(stream.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let token_trees: Vec<TokenTree> = (0..1000).map(|i| TokenTree::Ident(Ident::new(&format!(\"ident{}\", i), Span::call_site()))).collect();",
          "    let stream = TokenStream::from_iter(token_trees);",
          "}"
        ],
        "oracle": [
          "    assert!(stream.is_empty() == false);",
          "    assert_eq!(stream.inner.len(), 1000);",
          "    assert!(stream.inner.iter().all(|token| matches!(token, TokenTree::Ident(_))));",
          "    assert_eq!(stream.inner[0], TokenTree::Ident(Ident::new(\"ident0\", Span::call_site())));",
          "    assert_eq!(stream.inner[999], TokenTree::Ident(Ident::new(\"ident999\", Span::call_site())));"
        ],
        "code": [
          "{",
          "    let token_trees: Vec<TokenTree> = (0..1000).map(|i| TokenTree::Ident(Ident::new(&format!(\"ident{}\", i), Span::call_site()))).collect();",
          "    let stream = TokenStream::from_iter(token_trees);",
          "    assert!(stream.is_empty() == false);",
          "    assert_eq!(stream.inner.len(), 1000);",
          "    assert!(stream.inner.iter().all(|token| matches!(token, TokenTree::Ident(_))));",
          "    assert_eq!(stream.inner[0], TokenTree::Ident(Ident::new(\"ident0\", Span::call_site())));",
          "    assert_eq!(stream.inner[999], TokenTree::Ident(Ident::new(\"ident999\", Span::call_site())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let token_trees = vec![",
          "        TokenTree::Ident(Ident::new(\"dup\", Span::call_site())),",
          "        TokenTree::Ident(Ident::new(\"dup\", Span::call_site())),",
          "    ];",
          "    let stream = TokenStream::from_iter(token_trees);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(stream.is_empty(), false);",
          "    assert_eq!(stream.inner.len(), 2);",
          "    assert!(matches!(stream.inner.get(0), Some(TokenTree::Ident(_))));",
          "    assert!(matches!(stream.inner.get(1), Some(TokenTree::Ident(_))));"
        ],
        "code": [
          "{",
          "    let token_trees = vec![",
          "        TokenTree::Ident(Ident::new(\"dup\", Span::call_site())),",
          "        TokenTree::Ident(Ident::new(\"dup\", Span::call_site())),",
          "    ];",
          "    let stream = TokenStream::from_iter(token_trees);",
          "    assert_eq!(stream.is_empty(), false);",
          "    assert_eq!(stream.inner.len(), 2);",
          "    assert!(matches!(stream.inner.get(0), Some(TokenTree::Ident(_))));",
          "    assert!(matches!(stream.inner.get(1), Some(TokenTree::Ident(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]