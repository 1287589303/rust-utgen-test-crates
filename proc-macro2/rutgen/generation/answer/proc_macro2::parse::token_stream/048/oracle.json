[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// This is a doc comment\\n( )\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"/// This is a doc comment\\n( )\", off: 0 };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err(), lex_error(input));"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// This is a doc comment\\n( )\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "    let input = Cursor { rest: \"/// This is a doc comment\\n( )\", off: 0 };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err(), lex_error(input));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// This is a doc comment\\n[ ]\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"/// This is a doc comment\\n[ ]\", off: 0 };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert!(result.is_err());",
          "    let error = result.unwrap_err();",
          "    assert_eq!(error.span.lo, 0);",
          "    assert_eq!(error.span.hi, 0);"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// This is a doc comment\\n[ ]\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "    let input = Cursor { rest: \"/// This is a doc comment\\n[ ]\", off: 0 };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert!(result.is_err());",
          "    let error = result.unwrap_err();",
          "    assert_eq!(error.span.lo, 0);",
          "    assert_eq!(error.span.hi, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// This is a doc comment\\n{ }\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"/// This is a doc comment\\n{ }\", off: 0 };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().span.lo, result.unwrap_err().span.hi);"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// This is a doc comment\\n{ }\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "    let input = Cursor { rest: \"/// This is a doc comment\\n{ }\", off: 0 };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().span.lo, result.unwrap_err().span.hi);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"   /*ERROR*/  )\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().span.lo, 0);",
          "    assert_eq!(result.unwrap_err().span.hi, 0);",
          "    assert!(matches!(result.unwrap_err().span, Span { .. }));"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"   /*ERROR*/  )\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().span.lo, 0);",
          "    assert_eq!(result.unwrap_err().span.hi, 0);",
          "    assert!(matches!(result.unwrap_err().span, Span { .. }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"    /*ERROR*/ [ ]\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_, Err(lex_error(Cursor { rest: \"    /*ERROR*/ [ ]\", off: 0 })));"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"    /*ERROR*/ [ ]\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let _ = token_stream(input);",
          "    assert_eq!(_, Err(lex_error(Cursor { rest: \"    /*ERROR*/ [ ]\", off: 0 })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"   )\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    if let Err(error) = result {",
          "    assert_eq!(error.span.lo, 0);",
          "    assert_eq!(error.span.hi, 0);",
          "    }"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"   )\",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert!(result.is_err());",
          "    if let Err(error) = result {",
          "    assert_eq!(error.span.lo, 0);",
          "    assert_eq!(error.span.hi, 0);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"   )    )   \",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().span.lo, 0);",
          "    assert_eq!(result.unwrap_err().span.hi, 0);",
          "    assert!(result.unwrap_err().span == lex_error(Cursor { rest: \"   )    )   \", off: 0 }));",
          "    assert!(stack.is_empty());",
          "    assert_eq!(builder.inner.build().inner.len(), 0);"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"   )    )   \",",
          "        off: 0,",
          "    };",
          "    let mut builder = TokenStreamBuilder::new();",
          "    let result = token_stream(input);",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().span.lo, 0);",
          "    assert_eq!(result.unwrap_err().span.hi, 0);",
          "    assert!(result.unwrap_err().span == lex_error(Cursor { rest: \"   )    )   \", off: 0 }));",
          "    assert!(stack.is_empty());",
          "    assert_eq!(builder.inner.build().inner.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]