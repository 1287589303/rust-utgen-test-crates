[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\n\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "}"
        ],
        "oracle": [
          "    let cursor = Cursor { rest: \"\\\\n\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Err(Reject)));",
          "    let cursor = Cursor { rest: \"\\\\xFF\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\r\\\\n\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\t\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\n\\\\t\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));"
        ],
        "code": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\n\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "    let cursor = Cursor { rest: \"\\\\n\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Err(Reject)));",
          "    let cursor = Cursor { rest: \"\\\\xFF\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\r\\\\n\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\t\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\n\\\\t\".to_string().as_str() }; assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\r\\n\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\\n\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\xAB\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\n\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\\\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\0\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\'\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\"\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\x\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\\\\n\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\\\\x\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\AB\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\n\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\r\" }), Ok(_)));"
        ],
        "code": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\r\\n\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\\n\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\xAB\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\n\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\\\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\0\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\'\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\"\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\x\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\\\\n\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\\\\x\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\AB\" }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\n\" }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\r\" }), Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\\\\\x\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "}"
        ],
        "oracle": [
          "    let cursor = Cursor { rest: \"\\\\\\\\x\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"x\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\n\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"n\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\\\\\\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"\\\\\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\0\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"0\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\b\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Err(Reject));",
          "    let cursor = Cursor { rest: \"\\\\\\\\z\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Err(Reject));",
          "    let cursor = Cursor { rest: \"\\\\\\\\r\\\\n\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"\" }));"
        ],
        "code": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\\\\\x\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "    let cursor = Cursor { rest: \"\\\\\\\\x\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"x\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\n\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"n\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\\\\\\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"\\\\\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\0\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"0\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"\" }));",
          "    let cursor = Cursor { rest: \"\\\\\\\\b\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Err(Reject));",
          "    let cursor = Cursor { rest: \"\\\\\\\\z\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Err(Reject));",
          "    let cursor = Cursor { rest: \"\\\\\\\\r\\\\n\".to_string().as_str() };",
          "    assert_eq!(cooked_byte_string(cursor), Ok(Cursor { rest: \"\" }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\t\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\".as_ref() }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\x\".as_ref() }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\n\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\\\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\0\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\'\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\"\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\\\\\\n  \".as_ref() }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\\\\\\r  \".as_ref() }), Err(Reject)));"
        ],
        "code": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\t\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\".as_ref() }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\x\".as_ref() }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\r\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\n\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\\\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\0\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\'\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\\\\"\".as_ref() }), Ok(_)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\\\\\\n  \".as_ref() }), Err(Reject)));",
          "    assert!(matches!(cooked_byte_string(Cursor { rest: \"\\\\t\\\\\\r  \".as_ref() }), Err(Reject)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "}"
        ],
        "oracle": [
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Err(Reject)));",
          "    let cursor = Cursor { rest: \"\\\\x\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\n\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\r\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\t\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\0\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\'\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\\\\"\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\\\n\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Err(Reject)));"
        ],
        "code": [
          "{",
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() };",
          "    let _ = cooked_byte_string(cursor);",
          "    let cursor = Cursor { rest: \"\\\\\\\\\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Err(Reject)));",
          "    let cursor = Cursor { rest: \"\\\\x\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\n\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\r\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\t\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\0\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\'\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\\\\"\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Ok(_)));",
          "    let cursor = Cursor { rest: \"\\\\\\n\".to_string().as_str() };",
          "    assert!(matches!(cooked_byte_string(cursor), Err(Reject)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]