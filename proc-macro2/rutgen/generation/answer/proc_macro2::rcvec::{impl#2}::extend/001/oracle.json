[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![4, 5, 6]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);"
        ],
        "code": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![4, 5, 6]);",
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(vec, vec![1, 2, 3]);",
          "    rc_vec_mut.extend(vec![4, 5, 6]);",
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);",
          "    rc_vec_mut.extend(vec![7]);",
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);",
          "    let empty_iterator: Vec<i32> = vec![];",
          "    rc_vec_mut.extend(empty_iterator.into_iter());",
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);"
        ],
        "code": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![]);",
          "    assert_eq!(vec, vec![1, 2, 3]);",
          "    rc_vec_mut.extend(vec![4, 5, 6]);",
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);",
          "    rc_vec_mut.extend(vec![7]);",
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);",
          "    let empty_iterator: Vec<i32> = vec![];",
          "    rc_vec_mut.extend(empty_iterator.into_iter());",
          "    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![4]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(vec.len(), 4);",
          "    assert_eq!(vec[3], 4);",
          "    assert_eq!(vec[0], 1);",
          "    assert_eq!(vec[1], 2);",
          "    assert_eq!(vec[2], 3);"
        ],
        "code": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![4]);",
          "    assert_eq!(vec.len(), 4);",
          "    assert_eq!(vec[3], 4);",
          "    assert_eq!(vec[0], 1);",
          "    assert_eq!(vec[1], 2);",
          "    assert_eq!(vec[2], 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![7.0, 8.0]); // This will fail at compile-time due to type mismatch as Vec<T> is inferred as Vec<i32> from above.",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(std::panic::catch_unwind(|| {",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![7.0, 8.0]);",
          "    }), Err(_)));"
        ],
        "code": [
          "{",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![7.0, 8.0]); // This will fail at compile-time due to type mismatch as Vec<T> is inferred as Vec<i32> from above.",
          "    assert!(matches!(std::panic::catch_unwind(|| {",
          "    let mut vec = vec![1, 2, 3];",
          "    let mut rc_vec_mut = RcVecMut { inner: &mut vec };",
          "    rc_vec_mut.extend(vec![7.0, 8.0]);",
          "    }), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]