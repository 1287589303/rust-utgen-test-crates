[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! This is a comment\\r\\nNext line\".as_ref(),",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (rest, _) = result.unwrap();",
          "    assert_eq!(rest, \"Next line\");",
          "    assert_eq!(trees.inner.len(), 2);",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })));"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! This is a comment\\r\\nNext line\".as_ref(),",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "    assert!(result.is_ok());",
          "    let (rest, _) = result.unwrap();",
          "    assert_eq!(rest, \"Next line\");",
          "    assert_eq!(trees.inner.len(), 2);",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! Comment before bare CR\\r\\nSecond line\".as_ref(),",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"//! Comment before bare CR\\r\\nSecond line\".as_ref(), off: 0 };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "    assert!(result.is_ok());",
          "    let (rest, _) = result.unwrap();",
          "    assert_eq!(rest, \"Second line\");",
          "    assert_eq!(trees.inner.len(), 1);",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[2], TokenTree::Group(Group { delimiter: Delimiter::Bracket, .. })));",
          "    assert!(trees.inner.iter().any(|tt| matches!(tt, TokenTree::Ident(Ident { sym, .. }) if &**sym == \"doc\")));"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! Comment before bare CR\\r\\nSecond line\".as_ref(),",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "    let input = Cursor { rest: \"//! Comment before bare CR\\r\\nSecond line\".as_ref(), off: 0 };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "    assert!(result.is_ok());",
          "    let (rest, _) = result.unwrap();",
          "    assert_eq!(rest, \"Second line\");",
          "    assert_eq!(trees.inner.len(), 1);",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[2], TokenTree::Group(Group { delimiter: Delimiter::Bracket, .. })));",
          "    assert!(trees.inner.iter().any(|tt| matches!(tt, TokenTree::Ident(Ident { sym, .. }) if &**sym == \"doc\")));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]