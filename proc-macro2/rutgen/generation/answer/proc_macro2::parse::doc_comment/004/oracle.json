[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! This is a documentation comment.\\r\\nNext line\".as_ref(),",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((rest, ())));",
          "    assert_eq!(rest, \"Next line\");",
          "    assert_eq!(trees.inner.len(), 3);",
          "    assert_eq!(trees.inner[0], TokenTree::Punct(Punct::new('#', Spacing::Alone)));",
          "    assert_eq!(trees.inner[1], TokenTree::Punct(Punct::new('!', Spacing::Alone)));",
          "    assert_eq!(trees.inner[2], TokenTree::Group(Group::new(Delimiter::Bracket, TokenStream { inner: vec![TokenTree::Ident(Ident::_new_fallback(Ident::new_unchecked(\"doc\", fallback_span))), TokenTree::Punct(Punct::new('=', Spacing::Alone)), TokenTree::Literal(Literal::_new_fallback(Literal::string(\" This is a documentation comment.\")))]})));"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! This is a documentation comment.\\r\\nNext line\".as_ref(),",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "    assert_eq!(result, Ok((rest, ())));",
          "    assert_eq!(rest, \"Next line\");",
          "    assert_eq!(trees.inner.len(), 3);",
          "    assert_eq!(trees.inner[0], TokenTree::Punct(Punct::new('#', Spacing::Alone)));",
          "    assert_eq!(trees.inner[1], TokenTree::Punct(Punct::new('!', Spacing::Alone)));",
          "    assert_eq!(trees.inner[2], TokenTree::Group(Group::new(Delimiter::Bracket, TokenStream { inner: vec![TokenTree::Ident(Ident::_new_fallback(Ident::new_unchecked(\"doc\", fallback_span))), TokenTree::Punct(Punct::new('=', Spacing::Alone)), TokenTree::Literal(Literal::_new_fallback(Literal::string(\" This is a documentation comment.\")))]})));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// Line1\\r\\nLine2\",",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (rest, _) = result.unwrap();",
          "    assert_eq!(rest, \"Line2\");",
          "    assert_eq!(trees.inner.len(), 3);",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[2], TokenTree::Group(Group { delimiter: Delimiter::Bracket, .. })));"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"/// Line1\\r\\nLine2\",",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "    assert!(result.is_ok());",
          "    let (rest, _) = result.unwrap();",
          "    assert_eq!(rest, \"Line2\");",
          "    assert_eq!(trees.inner.len(), 3);",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })));",
          "    assert!(matches!(trees.inner[2], TokenTree::Group(Group { delimiter: Delimiter::Bracket, .. })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! Valid comment with a carriage return.\\r\\n\",",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((rest, ())))",
          "    assert!(trees.inner.len() > 0)",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })))",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })))",
          "    assert!(matches!(trees.inner[2], TokenTree::Group(Group { delimiter: Delimiter::Bracket, .. })))",
          "    assert_eq!(trees.inner[1].span(), trees.inner[0].span())",
          "    assert!(rest.ends_with(\"\\n\"))"
        ],
        "code": [
          "{",
          "    let input = Cursor {",
          "        rest: \"//! Valid comment with a carriage return.\\r\\n\",",
          "        off: 0,",
          "    };",
          "    let mut trees = TokenStreamBuilder::new();",
          "    let result = doc_comment(input, &mut trees);",
          "    assert_eq!(result, Ok((rest, ())))",
          "    assert!(trees.inner.len() > 0)",
          "    assert!(matches!(trees.inner[0], TokenTree::Punct(Punct { ch: '#', spacing: Spacing::Alone, .. })))",
          "    assert!(matches!(trees.inner[1], TokenTree::Punct(Punct { ch: '!', spacing: Spacing::Alone, .. })))",
          "    assert!(matches!(trees.inner[2], TokenTree::Group(Group { delimiter: Delimiter::Bracket, .. })))",
          "    assert_eq!(trees.inner[1].span(), trees.inner[0].span())",
          "    assert!(rest.ends_with(\"\\n\"))",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]