[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut token_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    let streams = vec![",
          "        TokenStream::Compiler(DeferredTokenStream::new()),",
          "        TokenStream::Fallback(fallback::TokenStream::new()),",
          "    ];",
          "    token_stream.extend(streams.into_iter());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(token_stream.inner.len(), 2);",
          "    assert!(matches!(token_stream, TokenStream::Compiler(_)));",
          "    assert!(matches!(streams[0], TokenStream::Compiler(_)));",
          "    assert!(matches!(streams[1], TokenStream::Fallback(_)));"
        ],
        "code": [
          "{",
          "    let mut token_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    let streams = vec![",
          "        TokenStream::Compiler(DeferredTokenStream::new()),",
          "        TokenStream::Fallback(fallback::TokenStream::new()),",
          "    ];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 2);",
          "    assert!(matches!(token_stream, TokenStream::Compiler(_)));",
          "    assert!(matches!(streams[0], TokenStream::Compiler(_)));",
          "    assert!(matches!(streams[1], TokenStream::Fallback(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![];",
          "    token_stream.extend(streams.into_iter());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(token_stream.inner.len(), 0);",
          "    ",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![TokenStream::Fallback(fallback::TokenStream::new())];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 1);",
          "    ",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![TokenStream::Compiler(DeferredTokenStream::new())];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 1);"
        ],
        "code": [
          "{",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 0);",
          "    ",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![TokenStream::Fallback(fallback::TokenStream::new())];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 1);",
          "    ",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![TokenStream::Compiler(DeferredTokenStream::new())];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut token_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    let streams = vec![TokenStream::Fallback(fallback::TokenStream::new())];",
          "    token_stream.extend(streams.into_iter());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(token_stream.inner.len(), 1);",
          "    assert!(matches!(token_stream, TokenStream::Compiler(_)));",
          "    assert!(matches!(token_stream.inner[0], TokenStream::Fallback(_)));",
          "    assert!(token_stream.inner[0].is::<fallback::TokenStream>());",
          "    assert!(token_stream.inner.iter().all(|stream| stream.is::<fall::TokenStream>()));",
          "    assert!(token_stream.inner.is_empty() == false);",
          "    assert!(token_stream.inner.contains(&(TokenStream::Fallback(fallback::TokenStream::new()))));",
          "    assert!(token_stream.inner.len() > 0);",
          "    assert!(streams.into_iter().count() == 1);"
        ],
        "code": [
          "{",
          "    let mut token_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    let streams = vec![TokenStream::Fallback(fallback::TokenStream::new())];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 1);",
          "    assert!(matches!(token_stream, TokenStream::Compiler(_)));",
          "    assert!(matches!(token_stream.inner[0], TokenStream::Fallback(_)));",
          "    assert!(token_stream.inner[0].is::<fallback::TokenStream>());",
          "    assert!(token_stream.inner.iter().all(|stream| stream.is::<fall::TokenStream>()));",
          "    assert!(token_stream.inner.is_empty() == false);",
          "    assert!(token_stream.inner.contains(&(TokenStream::Fallback(fallback::TokenStream::new()))));",
          "    assert!(token_stream.inner.len() > 0);",
          "    assert!(streams.into_iter().count() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams = vec![",
          "        TokenStream::Compiler(DeferredTokenStream::new()),",
          "        TokenStream::Fallback(fallback::TokenStream::new()),",
          "        TokenStream::Compiler(DeferredTokenStream::new()),",
          "    ];",
          "    token_stream.extend(streams.into_iter());",
          "}"
        ],
        "oracle": [
          "    assert!(token_stream.inner.len() == 3);",
          "    assert!(matches!(token_stream, TokenStream::Fallback(_)));",
          "    assert_eq!(token_stream.inner[0].variant(), Some(Variant::Compiler));",
          "    assert_eq!(token_stream.inner[1].variant(), Some(Variant::Fallback));",
          "    assert_eq!(token_stream.inner[2].variant(), Some(Variant::Compiler));"
        ],
        "code": [
          "{",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams = vec![",
          "        TokenStream::Compiler(DeferredTokenStream::new()),",
          "        TokenStream::Fallback(fallback::TokenStream::new()),",
          "        TokenStream::Compiler(DeferredTokenStream::new()),",
          "    ];",
          "    token_stream.extend(streams.into_iter());",
          "    assert!(token_stream.inner.len() == 3);",
          "    assert!(matches!(token_stream, TokenStream::Fallback(_)));",
          "    assert_eq!(token_stream.inner[0].variant(), Some(Variant::Compiler));",
          "    assert_eq!(token_stream.inner[1].variant(), Some(Variant::Fallback));",
          "    assert_eq!(token_stream.inner[2].variant(), Some(Variant::Compiler));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut token_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    let streams: Vec<TokenStream> = (0..1000)",
          "        .map(|_| TokenStream::Fallback(fallback::TokenStream::new()))",
          "        .collect();",
          "    token_stream.extend(streams.into_iter());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(token_stream.inner.len(), 1000);",
          "    assert!(token_stream.inner.iter().all(|stream| matches!(stream, TokenStream::Fallback(_))));",
          "    assert!(token_stream.inner.iter().count() == 1000);",
          "    assert!(token_stream.inner.is_empty() == false);",
          "    let mut empty_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    assert!(empty_stream.inner.is_empty());",
          "    empty_stream.extend(vec![TokenStream::Fallback(fallback::TokenStream::new())].into_iter());",
          "    assert!(empty_stream.inner.len() == 1);",
          "    assert!(matches!(empty_stream.inner[0], TokenStream::Fallback(_)));",
          "    let custom_streams: Vec<TokenStream> = vec![TokenStream::Fallback(fallback::TokenStream::new())];",
          "    let initial_length = token_stream.inner.len();",
          "    token_stream.extend(custom_streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), initial_length + 1);",
          "    assert!(matches!(token_stream.inner[initial_length], TokenStream::Fallback(_)));"
        ],
        "code": [
          "{",
          "    let mut token_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    let streams: Vec<TokenStream> = (0..1000)",
          "        .map(|_| TokenStream::Fallback(fallback::TokenStream::new()))",
          "        .collect();",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 1000);",
          "    assert!(token_stream.inner.iter().all(|stream| matches!(stream, TokenStream::Fallback(_))));",
          "    assert!(token_stream.inner.iter().count() == 1000);",
          "    assert!(token_stream.inner.is_empty() == false);",
          "    let mut empty_stream = TokenStream::Compiler(DeferredTokenStream::new());",
          "    assert!(empty_stream.inner.is_empty());",
          "    empty_stream.extend(vec![TokenStream::Fallback(fallback::TokenStream::new())].into_iter());",
          "    assert!(empty_stream.inner.len() == 1);",
          "    assert!(matches!(empty_stream.inner[0], TokenStream::Fallback(_)));",
          "    let custom_streams: Vec<TokenStream> = vec![TokenStream::Fallback(fallback::TokenStream::new())];",
          "    let initial_length = token_stream.inner.len();",
          "    token_stream.extend(custom_streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), initial_length + 1);",
          "    assert!(matches!(token_stream.inner[initial_length], TokenStream::Fallback(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![];",
          "    token_stream.extend(streams.into_iter());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(token_stream.inner.len(), 0);",
          "    assert!(matches!(token_stream, TokenStream::Fallback(_)));",
          "    let empty_streams: Vec<TokenStream> = vec![];",
          "    assert!(token_stream.inner.is_empty());",
          "    assert!(token_stream.inner.iter().count() == 0);"
        ],
        "code": [
          "{",
          "    let mut token_stream = TokenStream::Fallback(fallback::TokenStream::new());",
          "    let streams: Vec<TokenStream> = vec![];",
          "    token_stream.extend(streams.into_iter());",
          "    assert_eq!(token_stream.inner.len(), 0);",
          "    assert!(matches!(token_stream, TokenStream::Fallback(_)));",
          "    let empty_streams: Vec<TokenStream> = vec![];",
          "    assert!(token_stream.inner.is_empty());",
          "    assert!(token_stream.inner.iter().count() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]