[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"   // comment\\n   /* block comment */\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.rest, \"   // comment\\n   /* block comment */\");",
          "    assert!(!result.is_empty());",
          "    assert!(result.starts_with(\"// comment\"));",
          "    assert!(result.starts_with(\"   \"));",
          "    assert!(result.starts_with_char(' '));",
          "    assert!(result.starts_with_fn(|ch| ch.is_ascii()));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"   // comment\\n   /* block comment */\" };",
          "    let result = skip_whitespace(input);",
          "    assert_eq!(result.rest, \"   // comment\\n   /* block comment */\");",
          "    assert!(!result.is_empty());",
          "    assert!(result.starts_with(\"// comment\"));",
          "    assert!(result.starts_with(\"   \"));",
          "    assert!(result.starts_with_char(' '));",
          "    assert!(result.starts_with_fn(|ch| ch.is_ascii()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"/// this is a comment\\n   // another comment\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.rest == \" this is a comment\\n   // another comment\");",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.starts_with(\"//\") == true);",
          "    assert!(result.starts_with(\"///\") == true);",
          "    assert!(result.starts_with(\"//!\") == true);",
          "    assert!(result.starts_with(\"/**/\") == false);",
          "    assert!(result.starts_with(\"/*\") == false);",
          "    assert!(result.starts_with(\"/**\") == false);",
          "    assert!(result.starts_with(\"/***\") == false);",
          "    assert!(result.starts_with(\"/*!\") == false);",
          "    assert!(result.as_bytes()[0] == b' ' || result.as_bytes()[0] == 0x09 || result.as_bytes()[0] == 0x0a || result.as_bytes()[0] == 0x0b || result.as_bytes()[0] == 0x0c || result.as_bytes()[0] == 0x0d);",
          "    assert!(result.chars().next().unwrap().is_whitespace() == false);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"/// this is a comment\\n   // another comment\" };",
          "    let result = skip_whitespace(input);",
          "    assert!(result.rest == \" this is a comment\\n   // another comment\");",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.starts_with(\"//\") == true);",
          "    assert!(result.starts_with(\"///\") == true);",
          "    assert!(result.starts_with(\"//!\") == true);",
          "    assert!(result.starts_with(\"/**/\") == false);",
          "    assert!(result.starts_with(\"/*\") == false);",
          "    assert!(result.starts_with(\"/**\") == false);",
          "    assert!(result.starts_with(\"/***\") == false);",
          "    assert!(result.starts_with(\"/*!\") == false);",
          "    assert!(result.as_bytes()[0] == b' ' || result.as_bytes()[0] == 0x09 || result.as_bytes()[0] == 0x0a || result.as_bytes()[0] == 0x0b || result.as_bytes()[0] == 0x0c || result.as_bytes()[0] == 0x0d);",
          "    assert!(result.chars().next().unwrap().is_whitespace() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"   /* start of block comment\\n   still in block comment */   code\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.starts_with(\"/* start of block comment\\n   still in block comment */   code\"));",
          "    assert!(result.rest.len() == 42);",
          "    assert!(!result.is_empty());",
          "    assert!(result.as_bytes()[0] == b'c');",
          "    assert!(result.starts_with(\"code\"));",
          "    assert!(result.starts_with_char('c'));",
          "    assert!(result.len() == 42);",
          "    assert!(result.rest.ends_with(\"code\"));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"   /* start of block comment\\n   still in block comment */   code\" };",
          "    let result = skip_whitespace(input);",
          "    assert!(result.starts_with(\"/* start of block comment\\n   still in block comment */   code\"));",
          "    assert!(result.rest.len() == 42);",
          "    assert!(!result.is_empty());",
          "    assert!(result.as_bytes()[0] == b'c');",
          "    assert!(result.starts_with(\"code\"));",
          "    assert!(result.starts_with_char('c'));",
          "    assert!(result.len() == 42);",
          "    assert!(result.rest.ends_with(\"code\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"// comment only\\n\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"// comment only\\n\" };",
          "    let result = skip_whitespace(input);",
          "    assert!(result.starts_with(\"// comment only\\n\") == false);",
          "    assert!(result.starts_with(\"//\") == true);",
          "    assert!(result.starts_with(\"///\") == true);",
          "    assert!(result.starts_with(\"////\") == true);",
          "    assert!(result.starts_with(\"//!\") == true);",
          "    assert!(result.starts_with(\"/**/\") == false);",
          "    assert!(result.starts_with(\"/*\") == true);",
          "    assert!(result.starts_with(\"/**\") == true);",
          "    assert!(result.starts_with(\"/***\") == true);",
          "    assert!(result.starts_with(\"/*!\") == true);",
          "    assert!(result.as_bytes()[0] == b' ');",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.rest.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"// comment only\\n\" };",
          "    let result = skip_whitespace(input);",
          "    let input = Cursor { rest: \"// comment only\\n\" };",
          "    let result = skip_whitespace(input);",
          "    assert!(result.starts_with(\"// comment only\\n\") == false);",
          "    assert!(result.starts_with(\"//\") == true);",
          "    assert!(result.starts_with(\"///\") == true);",
          "    assert!(result.starts_with(\"////\") == true);",
          "    assert!(result.starts_with(\"//!\") == true);",
          "    assert!(result.starts_with(\"/**/\") == false);",
          "    assert!(result.starts_with(\"/*\") == true);",
          "    assert!(result.starts_with(\"/**\") == true);",
          "    assert!(result.starts_with(\"/***\") == true);",
          "    assert!(result.starts_with(\"/*!\") == true);",
          "    assert!(result.as_bytes()[0] == b' ');",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.rest.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"\\t\\t   // beginning with tabs and spaces\\nint x = 0;\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.starts_with(\"int x = 0;\"));",
          "    assert!(result.starts_with_char('i'));",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.len() == 11);",
          "    assert!(result.as_bytes() == b\"int x = 0;\");",
          "    assert!(result.chars().next().unwrap() == 'i');",
          "    assert!(result.char_indices().next().unwrap().1 == 'i');",
          "    assert!(result.rest == \"int x = 0;\");",
          "    assert!(result.rest.ends_with(';'));",
          "    assert!(result.starts_with(\"//\") == false);",
          "    assert!(result.starts_with(\"/*\") == false);",
          "    assert!(result.starts_with(\"/**/\") == false);",
          "    assert!(result.starts_with(\"//!\") == false);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"\\t\\t   // beginning with tabs and spaces\\nint x = 0;\" };",
          "    let result = skip_whitespace(input);",
          "    assert!(result.starts_with(\"int x = 0;\"));",
          "    assert!(result.starts_with_char('i'));",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.len() == 11);",
          "    assert!(result.as_bytes() == b\"int x = 0;\");",
          "    assert!(result.chars().next().unwrap() == 'i');",
          "    assert!(result.char_indices().next().unwrap().1 == 'i');",
          "    assert!(result.rest == \"int x = 0;\");",
          "    assert!(result.rest.ends_with(';'));",
          "    assert!(result.starts_with(\"//\") == false);",
          "    assert!(result.starts_with(\"/*\") == false);",
          "    assert!(result.starts_with(\"/**/\") == false);",
          "    assert!(result.starts_with(\"//!\") == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"   /* comment start /* nested comment */ end */   code\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.starts_with(\"/* comment start /* nested comment */ end */   code\"));",
          "    assert!(result.rest == \"   code\");",
          "    assert_eq!(result.as_bytes(), b\"   code\");",
          "    assert!(!result.is_empty());",
          "    assert!(result.rest.len() == 16);",
          "    assert!(result.chars().next() == Some(' '));",
          "    assert_eq!(result.len(), 16);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"   /* comment start /* nested comment */ end */   code\" };",
          "    let result = skip_whitespace(input);",
          "    assert!(result.starts_with(\"/* comment start /* nested comment */ end */   code\"));",
          "    assert!(result.rest == \"   code\");",
          "    assert_eq!(result.as_bytes(), b\"   code\");",
          "    assert!(!result.is_empty());",
          "    assert!(result.rest.len() == 16);",
          "    assert!(result.chars().next() == Some(' '));",
          "    assert_eq!(result.len(), 16);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"   // single-line comment with trailing spaces    \\n   int y = 1;\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"   // single-line comment with trailing spaces    \\n   int y = 1;\" };",
          "    let expected_output = Cursor { rest: \"int y = 1;\" };",
          "    assert_eq!(skip_whitespace(input), expected_output);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"   // single-line comment with trailing spaces    \\n   int y = 1;\" };",
          "    let result = skip_whitespace(input);",
          "    let input = Cursor { rest: \"   // single-line comment with trailing spaces    \\n   int y = 1;\" };",
          "    let expected_output = Cursor { rest: \"int y = 1;\" };",
          "    assert_eq!(skip_whitespace(input), expected_output);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"   \\\"string with \\n new line\\\" // comment after string\" };",
          "    let result = skip_whitespace(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"   \\\"string with \\n new line\\\" // comment after string\" };",
          "    assert!(result.starts_with(\"   \\\"string with \\n new line\\\"\") == true);",
          "    assert!(result.starts_with(\"//\") == false);",
          "    assert!(result.starts_with(\"\\n\") == false);",
          "    assert!(result.starts_with(\"/*\") == false);",
          "    assert!(result.starts_with(\"//!\") == false);",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.as_bytes()[0] == b'\"');",
          "    assert!(result.chars().next().unwrap() == ' ');",
          "    assert!(result.len() == 37);",
          "    assert!(result.rest == \"   \\\"string with \\n new line\\\" // comment after string\");"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"   \\\"string with \\n new line\\\" // comment after string\" };",
          "    let result = skip_whitespace(input);",
          "    let input = Cursor { rest: \"   \\\"string with \\n new line\\\" // comment after string\" };",
          "    assert!(result.starts_with(\"   \\\"string with \\n new line\\\"\") == true);",
          "    assert!(result.starts_with(\"//\") == false);",
          "    assert!(result.starts_with(\"\\n\") == false);",
          "    assert!(result.starts_with(\"/*\") == false);",
          "    assert!(result.starts_with(\"//!\") == false);",
          "    assert!(result.is_empty() == false);",
          "    assert!(result.as_bytes()[0] == b'\"');",
          "    assert!(result.chars().next().unwrap() == ' ');",
          "    assert!(result.len() == 37);",
          "    assert!(result.rest == \"   \\\"string with \\n new line\\\" // comment after string\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]