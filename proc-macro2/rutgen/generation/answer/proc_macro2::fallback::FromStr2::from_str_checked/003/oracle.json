[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestType;",
          "",
          "    impl FromStr2 for TestType {",
          "        fn valid(src: &str) -> bool {",
          "            src.starts_with(\"valid_token\")",
          "        }",
          "",
          "        fn from_str(src: &str) -> Result<Self, proc_macro::LexError> {",
          "            if src.contains(\"valid_token\") {",
          "                Ok(TestType)",
          "            } else {",
          "                Err(proc_macro::LexError)",
          "            }",
          "        }",
          "    }",
          "",
          "    let valid_input = \"valid_token_example\";",
          "    let result = TestType::from_str_checked(valid_input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(TestType));",
          "    assert!(TestType::valid(valid_input));",
          "    assert!(panic::catch_unwind(|| TestType::from_str(valid_input)).is_ok());",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(valid_input)), Ok(Ok(_))));",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(valid_input)), Ok(Err(_))));"
        ],
        "code": [
          "{",
          "    struct TestType;",
          "",
          "    impl FromStr2 for TestType {",
          "        fn valid(src: &str) -> bool {",
          "            src.starts_with(\"valid_token\")",
          "        }",
          "",
          "        fn from_str(src: &str) -> Result<Self, proc_macro::LexError> {",
          "            if src.contains(\"valid_token\") {",
          "                Ok(TestType)",
          "            } else {",
          "                Err(proc_macro::LexError)",
          "            }",
          "        }",
          "    }",
          "",
          "    let valid_input = \"valid_token_example\";",
          "    let result = TestType::from_str_checked(valid_input);",
          "    assert_eq!(result, Ok(TestType));",
          "    assert!(TestType::valid(valid_input));",
          "    assert!(panic::catch_unwind(|| TestType::from_str(valid_input)).is_ok());",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(valid_input)), Ok(Ok(_))));",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(valid_input)), Ok(Err(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestType;",
          "",
          "    impl FromStr2 for TestType {",
          "        fn valid(src: &str) -> bool {",
          "            src.starts_with(\"valid_token\")",
          "        }",
          "",
          "        fn from_str(src: &str) -> Result<Self, proc_macro::LexError> {",
          "            if src == \"valid_token_with_error\" {",
          "                Err(proc_macro::LexError)",
          "            } else {",
          "                Ok(TestType)",
          "            }",
          "        }",
          "    }",
          "",
          "    let valid_input = \"valid_token_with_error\";",
          "    let result = TestType::from_str_checked(valid_input);",
          "}"
        ],
        "oracle": [
          "    TestType::valid(\"valid_token\");",
          "    TestType::from_str_checked(\"valid_token\");",
          "    TestType::valid(\"valid_token\");",
          "    TestType::from_str(\"valid_token\");",
          "    panic::catch_unwind(|| TestType::from_str(\"valid_token\"));",
          "    assert_eq!(TestType::from_str_checked(\"valid_token\").is_ok(), true);",
          "    assert_eq!(TestType::from_str_checked(\"valid_token\").unwrap(), TestType);",
          "    assert_eq!(TestType::from_str_checked(\"valid_token\").err().is_none(), true);"
        ],
        "code": [
          "{",
          "    struct TestType;",
          "",
          "    impl FromStr2 for TestType {",
          "        fn valid(src: &str) -> bool {",
          "            src.starts_with(\"valid_token\")",
          "        }",
          "",
          "        fn from_str(src: &str) -> Result<Self, proc_macro::LexError> {",
          "            if src == \"valid_token_with_error\" {",
          "                Err(proc_macro::LexError)",
          "            } else {",
          "                Ok(TestType)",
          "            }",
          "        }",
          "    }",
          "",
          "    let valid_input = \"valid_token_with_error\";",
          "    let result = TestType::from_str_checked(valid_input);",
          "    TestType::valid(\"valid_token\");",
          "    TestType::from_str_checked(\"valid_token\");",
          "    TestType::valid(\"valid_token\");",
          "    TestType::from_str(\"valid_token\");",
          "    panic::catch_unwind(|| TestType::from_str(\"valid_token\"));",
          "    assert_eq!(TestType::from_str_checked(\"valid_token\").is_ok(), true);",
          "    assert_eq!(TestType::from_str_checked(\"valid_token\").unwrap(), TestType);",
          "    assert_eq!(TestType::from_str_checked(\"valid_token\").err().is_none(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestType;",
          "",
          "    impl FromStr2 for TestType {",
          "        fn valid(src: &str) -> bool {",
          "            src.starts_with(\"valid\")",
          "        }",
          "",
          "        fn from_str(src: &str) -> Result<Self, proc_macro::LexError> {",
          "            if src == \"valid_token_2\" {",
          "                Ok(TestType)",
          "            } else {",
          "                Err(proc_macro::LexError)",
          "            }",
          "        }",
          "    }",
          "",
          "    let valid_input = \"valid_token_2\";",
          "    let result = TestType::from_str_checked(valid_input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(TestType::from_str_checked(\"valid_token_2\"), Ok(TestType));",
          "    assert!(TestType::valid(\"valid_token_2\"));",
          "    assert!(panic::catch_unwind(|| TestType::from_str(\"valid_token_2\")).is_ok());",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(\"valid_token_2\")), Ok(Ok(_))));",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(\"valid_token_2\")), Ok(Err(_))));"
        ],
        "code": [
          "{",
          "    struct TestType;",
          "",
          "    impl FromStr2 for TestType {",
          "        fn valid(src: &str) -> bool {",
          "            src.starts_with(\"valid\")",
          "        }",
          "",
          "        fn from_str(src: &str) -> Result<Self, proc_macro::LexError> {",
          "            if src == \"valid_token_2\" {",
          "                Ok(TestType)",
          "            } else {",
          "                Err(proc_macro::LexError)",
          "            }",
          "        }",
          "    }",
          "",
          "    let valid_input = \"valid_token_2\";",
          "    let result = TestType::from_str_checked(valid_input);",
          "    assert_eq!(TestType::from_str_checked(\"valid_token_2\"), Ok(TestType));",
          "    assert!(TestType::valid(\"valid_token_2\"));",
          "    assert!(panic::catch_unwind(|| TestType::from_str(\"valid_token_2\")).is_ok());",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(\"valid_token_2\")), Ok(Ok(_))));",
          "    assert!(matches!(panic::catch_unwind(|| TestType::from_str(\"valid_token_2\")), Ok(Err(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]