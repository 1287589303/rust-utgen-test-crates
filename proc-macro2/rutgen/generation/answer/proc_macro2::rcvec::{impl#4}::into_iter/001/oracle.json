[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: Vec::new() };",
          "    let _iter = builder.into_iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.inner.len(), 0);",
          "    assert!(mem::size_of_val(&_iter) > 0);",
          "    assert!(mem::size_of_val(&_iter.inner) > 0);",
          "    assert!(Rc::strong_count(&builder.inner) == 1);",
          "    assert!(Rc::strong_count(&_iter.inner) == 1);"
        ],
        "code": [
          "{",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: Vec::new() };",
          "    let _iter = builder.into_iter();",
          "    assert_eq!(_iter.inner.len(), 0);",
          "    assert!(mem::size_of_val(&_iter) > 0);",
          "    assert!(mem::size_of_val(&_iter.inner) > 0);",
          "    assert!(Rc::strong_count(&builder.inner) == 1);",
          "    assert!(Rc::strong_count(&_iter.inner) == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: vec![42] };",
          "    let _iter = builder.into_iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.inner.size_hint(), (1, Some(1)));",
          "    assert_eq!(_iter.inner.next(), Some(42));",
          "    assert_eq!(_iter.inner.next(), None);",
          "    assert!(mem::size_of_val(&_iter) > 0);",
          "    assert!(mem::size_of_val(&_iter.inner) > 0);",
          "    assert!(RefUnwindSafe::is_unwinding_safe(&_iter.inner));"
        ],
        "code": [
          "{",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: vec![42] };",
          "    let _iter = builder.into_iter();",
          "    assert_eq!(_iter.inner.size_hint(), (1, Some(1)));",
          "    assert_eq!(_iter.inner.next(), Some(42));",
          "    assert_eq!(_iter.inner.next(), None);",
          "    assert!(mem::size_of_val(&_iter) > 0);",
          "    assert!(mem::size_of_val(&_iter.inner) > 0);",
          "    assert!(RefUnwindSafe::is_unwinding_safe(&_iter.inner));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: vec![1, 2, 3, 4, 5] };",
          "    let _iter = builder.into_iter();",
          "}"
        ],
        "oracle": [
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: vec![1, 2, 3, 4, 5] };",
          "    assert!(matches!(_iter, RcVecIntoIter { inner: _ }));",
          "    assert_eq!(_iter.inner.len(), 5);",
          "    assert_eq!(_iter.inner.next(), Some(1));",
          "    assert_eq!(_iter.inner.next(), Some(2));",
          "    assert_eq!(_iter.inner.next(), Some(3));",
          "    assert_eq!(_iter.inner.next(), Some(4));",
          "    assert_eq!(_iter.inner.next(), Some(5));",
          "    assert_eq!(_iter.inner.next(), None);"
        ],
        "code": [
          "{",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: vec![1, 2, 3, 4, 5] };",
          "    let _iter = builder.into_iter();",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: vec![1, 2, 3, 4, 5] };",
          "    assert!(matches!(_iter, RcVecIntoIter { inner: _ }));",
          "    assert_eq!(_iter.inner.len(), 5);",
          "    assert_eq!(_iter.inner.next(), Some(1));",
          "    assert_eq!(_iter.inner.next(), Some(2));",
          "    assert_eq!(_iter.inner.next(), Some(3));",
          "    assert_eq!(_iter.inner.next(), Some(4));",
          "    assert_eq!(_iter.inner.next(), Some(5));",
          "    assert_eq!(_iter.inner.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let large_vec = (0..1000).collect::<Vec<i32>>();",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: large_vec };",
          "    let _iter = builder.into_iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.inner.len(), 1000);",
          "    assert_eq!(_iter.inner.next(), Some(0));",
          "    assert_eq!(_iter.inner.next(), Some(1));",
          "    assert_eq!(_iter.inner.next(), Some(2));",
          "    assert_eq!(_iter.inner.next_back(), Some(999));",
          "    assert_eq!(_iter.inner.next_back(), Some(998));",
          "    assert_eq!(_iter.inner.len(), 998);"
        ],
        "code": [
          "{",
          "    let large_vec = (0..1000).collect::<Vec<i32>>();",
          "    let builder: RcVecBuilder<i32> = RcVecBuilder { inner: large_vec };",
          "    let _iter = builder.into_iter();",
          "    assert_eq!(_iter.inner.len(), 1000);",
          "    assert_eq!(_iter.inner.next(), Some(0));",
          "    assert_eq!(_iter.inner.next(), Some(1));",
          "    assert_eq!(_iter.inner.next(), Some(2));",
          "    assert_eq!(_iter.inner.next_back(), Some(999));",
          "    assert_eq!(_iter.inner.next_back(), Some(998));",
          "    assert_eq!(_iter.inner.len(), 998);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]