[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\n'\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let Ok(cursor) = result;",
          "    assert_eq!(cursor.rest, \"''\");",
          "    assert!(input.parse(\"b'\").is_ok());",
          "    assert!(cursor.chars().as_str().is_char_boundary(2));",
          "    assert!(cursor.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(cursor.bytes().nth(1).map(|(_, b)| b) == Some(b'n'));",
          "    assert!(cursor.bytes().nth(2).map(|(_, b)| b) == Some(b\"'\"));",
          "    assert!(cursor.bytes().nth(3).is_none());",
          "    assert!(ok);"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\n'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    let Ok(cursor) = result;",
          "    assert_eq!(cursor.rest, \"''\");",
          "    assert!(input.parse(\"b'\").is_ok());",
          "    assert!(cursor.chars().as_str().is_char_boundary(2));",
          "    assert!(cursor.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(cursor.bytes().nth(1).map(|(_, b)| b) == Some(b'n'));",
          "    assert!(cursor.bytes().nth(2).map(|(_, b)| b) == Some(b\"'\"));",
          "    assert!(cursor.bytes().nth(3).is_none());",
          "    assert!(ok);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\r'\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    assert_eq!(result.unwrap().chars().as_str(), \"\");",
          "    let input = Cursor { rest: \"b'\\\\n'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\t'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\0'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\x01'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\r'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    assert_eq!(result.unwrap().chars().as_str(), \"\");",
          "    let input = Cursor { rest: \"b'\\\\n'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\t'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\0'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "    let input = Cursor { rest: \"b'\\\\x01'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().rest, \"'\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\t'\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let cursor_result = result.unwrap();",
          "    assert_eq!(cursor_result.rest, \"'\");",
          "    assert!(!cursor_result.is_empty());",
          "    assert!(cursor_result.starts_with(\"'\"));",
          "    assert!(cursor_result.chars().as_str().is_char_boundary(1));",
          "    assert_eq!(cursor_result.len(), 1);",
          "    assert_eq!(cursor_result.bytes().len(), 1);",
          "    assert!(cursor_result.starts_with_char('\\''));",
          "    assert!(cursor_result.starts_with_fn(|ch| ch == '\\''));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\t'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    let cursor_result = result.unwrap();",
          "    assert_eq!(cursor_result.rest, \"'\");",
          "    assert!(!cursor_result.is_empty());",
          "    assert!(cursor_result.starts_with(\"'\"));",
          "    assert!(cursor_result.chars().as_str().is_char_boundary(1));",
          "    assert_eq!(cursor_result.len(), 1);",
          "    assert_eq!(cursor_result.bytes().len(), 1);",
          "    assert!(cursor_result.starts_with_char('\\''));",
          "    assert!(cursor_result.starts_with_fn(|ch| ch == '\\''));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\\\\\'\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"b'\\\\\\\\'\" };",
          "    assert!(input.parse(\"b'\").is_ok());",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b).is_some());",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'n') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'r') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b't') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'\\\\') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'0') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'\\'') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'\"'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) != Some(b'x'));",
          "    assert!(ok);",
          "    assert!(bytes.next().ok_or(Reject).is_ok());",
          "    assert!(input.chars().as_str().is_char_boundary(offset));",
          "    assert!(input.advance(offset).parse(\"'\").is_ok());",
          "    assert!(result.is_ok() && result.unwrap() == literal_suffix(input));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\\\\\'\" };",
          "    let result = byte(input);",
          "    let input = Cursor { rest: \"b'\\\\\\\\'\" };",
          "    assert!(input.parse(\"b'\").is_ok());",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b).is_some());",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) == Some(b'n') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'r') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b't') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'\\\\') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'0') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'\\'') ||",
          "    input.bytes().next().map(|(_, b)| b) == Some(b'\"'));",
          "    assert!(input.bytes().next().map(|(_, b)| b) != Some(b'x'));",
          "    assert!(ok);",
          "    assert!(bytes.next().ok_or(Reject).is_ok());",
          "    assert!(input.chars().as_str().is_char_boundary(offset));",
          "    assert!(input.advance(offset).parse(\"'\").is_ok());",
          "    assert!(result.is_ok() && result.unwrap() == literal_suffix(input));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\0'\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let cursor = result.unwrap();",
          "    assert_eq!(cursor.rest, \"''\");",
          "    assert!(cursor.chars().as_str().is_char_boundary(0));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\0'\" };",
          "    let result = byte(input);",
          "    assert!(result.is_ok());",
          "    let cursor = result.unwrap();",
          "    assert_eq!(cursor.rest, \"''\");",
          "    assert!(cursor.chars().as_str().is_char_boundary(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\''\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"b'\\\\''\" };",
          "    let parse_result = input.parse(\"b'\").is_ok();",
          "    let first_byte = input.bytes().next().map(|(_, b)| b) == Some(b'\\\\');",
          "    let second_byte = input.bytes().next().map(|(_, b)| b) == Some(b'\\'');",
          "    let next_byte_is_valid = input.bytes().next().map(|(_, b)| b) == Some(b'\\\\');",
          "    let is_valid_char = input.bytes().next().map(|(_, b)| b) == Some(b'n');",
          "    let ok_condition = !(!first_byte || !next_byte_is_valid);",
          "    let offset = input.bytes().next().ok().unwrap().0;",
          "    let is_char_boundary = input.chars().as_str().is_char_boundary(offset);",
          "    let suffix_result = input.advance(offset).parse(\"'\").is_ok();",
          "    let expected_result = literal_suffix(input);",
          "    assert_eq!(result, Ok(expected_result));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\''\" };",
          "    let result = byte(input);",
          "    let input = Cursor { rest: \"b'\\\\''\" };",
          "    let parse_result = input.parse(\"b'\").is_ok();",
          "    let first_byte = input.bytes().next().map(|(_, b)| b) == Some(b'\\\\');",
          "    let second_byte = input.bytes().next().map(|(_, b)| b) == Some(b'\\'');",
          "    let next_byte_is_valid = input.bytes().next().map(|(_, b)| b) == Some(b'\\\\');",
          "    let is_valid_char = input.bytes().next().map(|(_, b)| b) == Some(b'n');",
          "    let ok_condition = !(!first_byte || !next_byte_is_valid);",
          "    let offset = input.bytes().next().ok().unwrap().0;",
          "    let is_char_boundary = input.chars().as_str().is_char_boundary(offset);",
          "    let suffix_result = input.advance(offset).parse(\"'\").is_ok();",
          "    let expected_result = literal_suffix(input);",
          "    assert_eq!(result, Ok(expected_result));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\"'\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"b'\\\\n'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\r'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\t'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\\\\\'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\0'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\''\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\"'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\xFF'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\x00'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\z'\" }; assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\"'\" };",
          "    let result = byte(input);",
          "    let input = Cursor { rest: \"b'\\\\n'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\r'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\t'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\\\\\'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\0'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\''\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\"'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\xFF'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\x00'\" }; assert!(result.is_ok());",
          "    let input = Cursor { rest: \"b'\\\\z'\" }; assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" };",
          "    let result = byte(input);",
          "}"
        ],
        "oracle": [
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; assert!(input.parse(\"b'\").is_ok());",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'x'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'n'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'r'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b't'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'0'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\\''));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\"'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'n'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let (offset, _) = bytes.next().ok_or(Reject).unwrap(); assert!(input.chars().as_str().is_char_boundary(offset));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let next_input = input.advance(offset).parse(\"'\").unwrap(); assert!(next_input.is_ok());",
          "    assert_eq!(byte(input), Ok(literal_suffix(input)));"
        ],
        "code": [
          "{",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" };",
          "    let result = byte(input);",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; assert!(input.parse(\"b'\").is_ok());",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'x'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'n'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'r'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b't'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\\\\'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'0'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\\''));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) != Some(b'\"'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let mut bytes = input.bytes().enumerate(); assert!(bytes.next().map(|(_, b)| b) == Some(b'n'));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let (offset, _) = bytes.next().ok_or(Reject).unwrap(); assert!(input.chars().as_str().is_char_boundary(offset));",
          "    let input = Cursor { rest: \"b'\\\\x0A'\" }; let next_input = input.advance(offset).parse(\"'\").unwrap(); assert!(next_input.is_ok());",
          "    assert_eq!(byte(input), Ok(literal_suffix(input)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]