[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Parenthesis,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Ident(Ident {",
          "                sym: Box::from(\"example\"),",
          "                span: Span::call_site(),",
          "                raw: false,",
          "            })]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let punct_joint = Punct::new('+', Spacing::Joint);",
          "    let punct_alone = Punct::new(',', Spacing::Alone);",
          "    let literal = Literal { repr: String::from(\"42\"), span: Span::call_site() };",
          "    ",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![",
          "            TokenTree::Group(group),",
          "            TokenTree::Punct(punct_joint),",
          "            TokenTree::Ident(Ident {",
          "                sym: Box::from(\"test\"),",
          "                span: Span::call_site(),",
          "                raw: true,",
          "            }),",
          "            TokenTree::Punct(punct_alone),",
          "            TokenTree::Literal(literal),",
          "        ]),",
          "    };",
          "",
          "    let _ = write!(&mut String::new(), \"{}\", token_stream);",
          "}"
        ],
        "oracle": [
          "    let group = Group { delimiter: Delimiter::Parenthesis, stream: TokenStream { inner: RcVec::new(vec![TokenTree::Ident(Ident { sym: Box::from(\"example\"), span: Span::call_site(), raw: false, })]), }, span: Span::call_site(), };",
          "    let punct_joint = Punct::new('+', Spacing::Joint);",
          "    let punct_alone = Punct::new(',', Spacing::Alone);",
          "    let literal = Literal { repr: String::from(\"42\"), span: Span::call_site() };",
          "    let token_stream = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group), TokenTree::Punct(punct_joint), TokenTree::Ident(Ident { sym: Box::from(\"test\"), span: Span::call_site(), raw: true, }), TokenTree::Punct(punct_alone), TokenTree::Literal(literal), ]), };",
          "    let _ = write!(&mut String::new(), \"{}\", token_stream);",
          "    assert!(token_stream.inner.len() > 0);",
          "    assert!(token_stream.inner.iter().next().is_some());",
          "    assert_eq!(token_stream.inner.iter().count(), 5);",
          "    assert!(std::panic::catch_unwind(|| { let _ = write!(&mut String::new(), \"{}\", token_stream); }).is_ok());",
          "    assert_eq!(token_stream.inner.iter().nth(1).unwrap(), &TokenTree::Punct(punct_joint));",
          "    assert_eq!(token_stream.inner.iter().nth(3).unwrap(), &TokenTree::Punct(punct_alone));",
          "    assert!(matches!(token_stream.inner.iter().nth(0).unwrap(), TokenTree::Group(_)));",
          "    assert!(matches!(token_stream.inner.iter().nth(2).unwrap(), TokenTree::Ident(_)));",
          "    assert!(matches!(token_stream.inner.iter().nth(4).unwrap(), TokenTree::Literal(_)));"
        ],
        "code": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Parenthesis,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Ident(Ident {",
          "                sym: Box::from(\"example\"),",
          "                span: Span::call_site(),",
          "                raw: false,",
          "            })]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let punct_joint = Punct::new('+', Spacing::Joint);",
          "    let punct_alone = Punct::new(',', Spacing::Alone);",
          "    let literal = Literal { repr: String::from(\"42\"), span: Span::call_site() };",
          "    ",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![",
          "            TokenTree::Group(group),",
          "            TokenTree::Punct(punct_joint),",
          "            TokenTree::Ident(Ident {",
          "                sym: Box::from(\"test\"),",
          "                span: Span::call_site(),",
          "                raw: true,",
          "            }),",
          "            TokenTree::Punct(punct_alone),",
          "            TokenTree::Literal(literal),",
          "        ]),",
          "    };",
          "",
          "    let _ = write!(&mut String::new(), \"{}\", token_stream);",
          "    let group = Group { delimiter: Delimiter::Parenthesis, stream: TokenStream { inner: RcVec::new(vec![TokenTree::Ident(Ident { sym: Box::from(\"example\"), span: Span::call_site(), raw: false, })]), }, span: Span::call_site(), };",
          "    let punct_joint = Punct::new('+', Spacing::Joint);",
          "    let punct_alone = Punct::new(',', Spacing::Alone);",
          "    let literal = Literal { repr: String::from(\"42\"), span: Span::call_site() };",
          "    let token_stream = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group), TokenTree::Punct(punct_joint), TokenTree::Ident(Ident { sym: Box::from(\"test\"), span: Span::call_site(), raw: true, }), TokenTree::Punct(punct_alone), TokenTree::Literal(literal), ]), };",
          "    let _ = write!(&mut String::new(), \"{}\", token_stream);",
          "    assert!(token_stream.inner.len() > 0);",
          "    assert!(token_stream.inner.iter().next().is_some());",
          "    assert_eq!(token_stream.inner.iter().count(), 5);",
          "    assert!(std::panic::catch_unwind(|| { let _ = write!(&mut String::new(), \"{}\", token_stream); }).is_ok());",
          "    assert_eq!(token_stream.inner.iter().nth(1).unwrap(), &TokenTree::Punct(punct_joint));",
          "    assert_eq!(token_stream.inner.iter().nth(3).unwrap(), &TokenTree::Punct(punct_alone));",
          "    assert!(matches!(token_stream.inner.iter().nth(0).unwrap(), TokenTree::Group(_)));",
          "    assert!(matches!(token_stream.inner.iter().nth(2).unwrap(), TokenTree::Ident(_)));",
          "    assert!(matches!(token_stream.inner.iter().nth(4).unwrap(), TokenTree::Literal(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Bracket,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Ident(Ident {",
          "                sym: Box::from(\"grouped\"),",
          "                span: Span::call_site(),",
          "                raw: false,",
          "            })]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let joint_punct = Punct::new('*', Spacing::Joint);",
          "    let lone_punct = Punct::new('%', Spacing::Alone);",
          "    ",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![",
          "            TokenTree::Group(group),",
          "            TokenTree::Punct(joint_punct),",
          "            TokenTree::Punct(lone_punct),",
          "        ]),",
          "    };",
          "",
          "    let _ = write!(&mut String::new(), \"{}\", token_stream);",
          "}"
        ],
        "oracle": [
          "    assert!(token_stream.inner.len() > 0);",
          "    assert!(token_stream.inner.iter().enumerate().count() > 0);",
          "    assert!(token_stream.inner.iter().enumerate().any(|(i, tt)| i != 0 && matches!(tt, TokenTree::Group(_)));",
          "    assert!(tt as TokenTree::Group(group));",
          "    assert!(write!(f, \" \").is_ok());",
          "    assert_eq!(joint_punct.spacing(), Spacing::Joint);",
          "    assert!(write!(&mut String::new(), \"{}\", token_stream).is_ok());",
          "    assert!(matches!(write!(f, \" \"), Ok(_)));",
          "    assert!(matches!(Display::fmt(token_stream.inner.get(0).unwrap(), f), Err(_)));"
        ],
        "code": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Bracket,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Ident(Ident {",
          "                sym: Box::from(\"grouped\"),",
          "                span: Span::call_site(),",
          "                raw: false,",
          "            })]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let joint_punct = Punct::new('*', Spacing::Joint);",
          "    let lone_punct = Punct::new('%', Spacing::Alone);",
          "    ",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![",
          "            TokenTree::Group(group),",
          "            TokenTree::Punct(joint_punct),",
          "            TokenTree::Punct(lone_punct),",
          "        ]),",
          "    };",
          "",
          "    let _ = write!(&mut String::new(), \"{}\", token_stream);",
          "    assert!(token_stream.inner.len() > 0);",
          "    assert!(token_stream.inner.iter().enumerate().count() > 0);",
          "    assert!(token_stream.inner.iter().enumerate().any(|(i, tt)| i != 0 && matches!(tt, TokenTree::Group(_)));",
          "    assert!(tt as TokenTree::Group(group));",
          "    assert!(write!(f, \" \").is_ok());",
          "    assert_eq!(joint_punct.spacing(), Spacing::Joint);",
          "    assert!(write!(&mut String::new(), \"{}\", token_stream).is_ok());",
          "    assert!(matches!(write!(f, \" \"), Ok(_)));",
          "    assert!(matches!(Display::fmt(token_stream.inner.get(0).unwrap(), f), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]