[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Parenthesis,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Ident(Ident {",
          "                sym: Box::from(\"test_ident\"),",
          "                span: Span::call_site(),",
          "                raw: false,",
          "            })]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![TokenTree::Group(group)]),",
          "    };",
          "",
          "    let _ = format!(\"{}\", token_stream);",
          "}"
        ],
        "oracle": [
          "    let group = Group { delimiter: Delimiter::Parenthesis, stream: TokenStream { inner: RcVec::new(vec![TokenTree::Ident(Ident { sym: Box::from(\"test_ident\"), span: Span::call_site(), raw: false, })]), }, span: Span::call_site(), };",
          "    let token_stream = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group)]), };",
          "    assert_eq!(format!(\"{}\", token_stream), \"\");",
          "    let token_stream_two = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group.clone()), TokenTree::Ident(Ident { sym: Box::from(\"another_ident\"), span: Span::call_site(), raw: false, })]), };",
          "    assert_eq!(format!(\"{}\", token_stream_two), \"test_ident another_ident\");",
          "    let token_stream_three = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group)]), };",
          "    assert!(token_stream_three.inner.len() > 0);"
        ],
        "code": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Parenthesis,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Ident(Ident {",
          "                sym: Box::from(\"test_ident\"),",
          "                span: Span::call_site(),",
          "                raw: false,",
          "            })]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![TokenTree::Group(group)]),",
          "    };",
          "",
          "    let _ = format!(\"{}\", token_stream);",
          "    let group = Group { delimiter: Delimiter::Parenthesis, stream: TokenStream { inner: RcVec::new(vec![TokenTree::Ident(Ident { sym: Box::from(\"test_ident\"), span: Span::call_site(), raw: false, })]), }, span: Span::call_site(), };",
          "    let token_stream = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group)]), };",
          "    assert_eq!(format!(\"{}\", token_stream), \"\");",
          "    let token_stream_two = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group.clone()), TokenTree::Ident(Ident { sym: Box::from(\"another_ident\"), span: Span::call_site(), raw: false, })]), };",
          "    assert_eq!(format!(\"{}\", token_stream_two), \"test_ident another_ident\");",
          "    let token_stream_three = TokenStream { inner: RcVec::new(vec![TokenTree::Group(group)]), };",
          "    assert!(token_stream_three.inner.len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Bracket,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Punct(Punct::new(',', Spacing::Joint))]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![TokenTree::Group(group)]),",
          "    };",
          "",
          "    let _ = format!(\"{}\", token_stream);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(token_stream.inner.len(), 1);",
          "    assert!(matches!(token_stream.inner.iter().next(), Some(TokenTree::Group(_))));",
          "    assert!(token_stream.inner.iter().enumerate().all(|(i, tt)| {",
          "    (i == 0 && matches!(tt, TokenTree::Group(_))) || (i != 0 && matches!(tt, TokenTree::Ident(_) | TokenTree::Punct(_) | TokenTree::Literal(_)))",
          "    }));",
          "    assert_eq!(format!(\"{}\", token_stream), \"\");",
          "    let punct = Punct::new(',', Spacing::Joint);",
          "    assert_eq!(punct.as_char(), ',');",
          "    assert_eq!(punct.spacing(), Spacing::Joint);"
        ],
        "code": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Bracket,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Punct(Punct::new(',', Spacing::Joint))]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![TokenTree::Group(group)]),",
          "    };",
          "",
          "    let _ = format!(\"{}\", token_stream);",
          "    assert_eq!(token_stream.inner.len(), 1);",
          "    assert!(matches!(token_stream.inner.iter().next(), Some(TokenTree::Group(_))));",
          "    assert!(token_stream.inner.iter().enumerate().all(|(i, tt)| {",
          "    (i == 0 && matches!(tt, TokenTree::Group(_))) || (i != 0 && matches!(tt, TokenTree::Ident(_) | TokenTree::Punct(_) | TokenTree::Literal(_)))",
          "    }));",
          "    assert_eq!(format!(\"{}\", token_stream), \"\");",
          "    let punct = Punct::new(',', Spacing::Joint);",
          "    assert_eq!(punct.as_char(), ',');",
          "    assert_eq!(punct.spacing(), Spacing::Joint);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Brace,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Punct(Punct::new('+', Spacing::Alone))]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![TokenTree::Group(group)]),",
          "    };",
          "",
          "    let _ = format!(\"{}\", token_stream);",
          "}"
        ],
        "oracle": [
          "    assert!(format!(\"{}\", token_stream).is_ok());",
          "    assert_eq!(format!(\"{}\", token_stream), \"{ + }\");",
          "    assert!(token_stream.inner.len() == 1);",
          "    assert!(matches!(token_stream.inner.iter().next().unwrap(), TokenTree::Group(_)));",
          "    assert!(matches!(token_stream.inner.iter().next().unwrap().as_ref(), TokenTree::Group(tt) if tt.delimiter == Delimiter::Brace));"
        ],
        "code": [
          "{",
          "    let group = Group {",
          "        delimiter: Delimiter::Brace,",
          "        stream: TokenStream {",
          "            inner: RcVec::new(vec![TokenTree::Punct(Punct::new('+', Spacing::Alone))]),",
          "        },",
          "        span: Span::call_site(),",
          "    };",
          "",
          "    let token_stream = TokenStream {",
          "        inner: RcVec::new(vec![TokenTree::Group(group)]),",
          "    };",
          "",
          "    let _ = format!(\"{}\", token_stream);",
          "    assert!(format!(\"{}\", token_stream).is_ok());",
          "    assert_eq!(format!(\"{}\", token_stream), \"{ + }\");",
          "    assert!(token_stream.inner.len() == 1);",
          "    assert!(matches!(token_stream.inner.iter().next().unwrap(), TokenTree::Group(_)));",
          "    assert!(matches!(token_stream.inner.iter().next().unwrap().as_ref(), TokenTree::Group(tt) if tt.delimiter == Delimiter::Brace));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]