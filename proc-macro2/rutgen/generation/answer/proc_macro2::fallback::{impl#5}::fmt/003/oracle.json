[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let punct1 = Punct::new('+', Spacing::Alone);",
          "    let punct2 = Punct::new(',', Spacing::Joint);",
          "    let token_tree1 = TokenTree::Punct(punct1);",
          "    let token_tree2 = TokenTree::Punct(punct2);",
          "    ",
          "    let inner_vec = RcVec {",
          "        inner: Rc::new(vec![token_tree1, token_tree2]),",
          "    };",
          "    ",
          "    let token_stream = TokenStream { inner: inner_vec };",
          "",
          "    let _ = token_stream.fmt(&mut fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(token_stream.inner.len(), 2);",
          "    assert!(token_stream.inner.iter().next().is_some());",
          "    assert!(token_stream.inner.iter().next().unwrap().matches(TokenTree::Punct(Punct::new('+', Spacing::Alone))));",
          "    assert!(token_stream.inner.iter().nth(1).unwrap().matches(TokenTree::Punct(Punct::new(',', Spacing::Joint))));",
          "    assert!(token_stream.inner.iter().enumerate().all(|(i, tt)| i == 0 || (tt.matches(TokenTree::Punct(_)) && i > 0)));",
          "    assert!(token_stream.fmt(&mut fmt::Formatter::new()).is_ok());",
          "    assert!(matches!(token_stream.fmt(&mut fmt::Formatter::new()), Ok(_)));"
        ],
        "code": [
          "{",
          "    let punct1 = Punct::new('+', Spacing::Alone);",
          "    let punct2 = Punct::new(',', Spacing::Joint);",
          "    let token_tree1 = TokenTree::Punct(punct1);",
          "    let token_tree2 = TokenTree::Punct(punct2);",
          "    ",
          "    let inner_vec = RcVec {",
          "        inner: Rc::new(vec![token_tree1, token_tree2]),",
          "    };",
          "    ",
          "    let token_stream = TokenStream { inner: inner_vec };",
          "",
          "    let _ = token_stream.fmt(&mut fmt::Formatter::new());",
          "    assert_eq!(token_stream.inner.len(), 2);",
          "    assert!(token_stream.inner.iter().next().is_some());",
          "    assert!(token_stream.inner.iter().next().unwrap().matches(TokenTree::Punct(Punct::new('+', Spacing::Alone))));",
          "    assert!(token_stream.inner.iter().nth(1).unwrap().matches(TokenTree::Punct(Punct::new(',', Spacing::Joint))));",
          "    assert!(token_stream.inner.iter().enumerate().all(|(i, tt)| i == 0 || (tt.matches(TokenTree::Punct(_)) && i > 0)));",
          "    assert!(token_stream.fmt(&mut fmt::Formatter::new()).is_ok());",
          "    assert!(matches!(token_stream.fmt(&mut fmt::Formatter::new()), Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]