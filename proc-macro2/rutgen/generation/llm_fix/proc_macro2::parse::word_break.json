{
  "name": "proc_macro2::parse::word_break",
  "mod_info": {
    "name": "parse",
    "loc": "src/lib.rs:142:1:142:11"
  },
  "visible": false,
  "loc": "src/parse.rs:157:1:162:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: input.chars().next() matches Some(ch) or Some(_) at line 158 is true\n",
        "precondition: input.chars().next() matches Some(ch) at line 158 is true\n",
        "precondition: is_ident_continue(ch) at line 159 is true\n",
        "expected return value/type: Err(Reject)\n"
      ],
      "input_infer": "Cursor with non-empty rest containing a character that is a valid identifier continuation according to `unicode_ident::is_xid_continue`.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor {",
                "        rest: \"abc\", // Non-empty rest containing valid identifier continuation",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    let _ = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(word_break(Cursor { rest: \"abc\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"d\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"1abc\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"_valid\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"valid_char$\", off: 0 }), Err(Reject));"
              ],
              "code": [
                "{",
                "    let cursor = Cursor {",
                "        rest: \"abc\", // Non-empty rest containing valid identifier continuation",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    let _ = word_break(cursor);",
                "    assert_eq!(word_break(Cursor { rest: \"abc\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"d\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"1abc\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"_valid\", off: 0 }), Err(Reject));",
                "    assert_eq!(word_break(Cursor { rest: \"valid_char$\", off: 0 }), Err(Reject));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor {",
                "        rest: \"d\", // Non-empty rest with a single valid identifier continuation character",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    let _ = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    let cursor = Cursor { rest: \"d\", ..Default::default() }; // Valid identifier continuation character 'd'",
                "    assert_eq!(word_break(cursor), Err(Reject));",
                "    ",
                "    let cursor = Cursor { rest: \"9\", ..Default::default() }; // Valid identifier continuation character '9'",
                "    assert_eq!(word_break(cursor), Err(Reject));",
                "    ",
                "    let cursor = Cursor { rest: \"__\", ..Default::default() }; // Valid identifier continuation character '_'",
                "    assert_eq!(word_break(cursor), Err(Reject));",
                "    ",
                "    let cursor = Cursor { rest: \"国\", ..Default::default() }; // Valid identifier continuation character in Unicode",
                "    assert_eq!(word_break(cursor), Err(Reject));"
              ],
              "code": [
                "{",
                "    let cursor = Cursor {",
                "        rest: \"d\", // Non-empty rest with a single valid identifier continuation character",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    let _ = word_break(cursor);",
                "    let cursor = Cursor { rest: \"d\", ..Default::default() }; // Valid identifier continuation character 'd'",
                "    assert_eq!(word_break(cursor), Err(Reject));",
                "    ",
                "    let cursor = Cursor { rest: \"9\", ..Default::default() }; // Valid identifier continuation character '9'",
                "    assert_eq!(word_break(cursor), Err(Reject));",
                "    ",
                "    let cursor = Cursor { rest: \"__\", ..Default::default() }; // Valid identifier continuation character '_'",
                "    assert_eq!(word_break(cursor), Err(Reject));",
                "    ",
                "    let cursor = Cursor { rest: \"国\", ..Default::default() }; // Valid identifier continuation character in Unicode",
                "    assert_eq!(word_break(cursor), Err(Reject));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor {",
                "        rest: \"_example\", // Non-empty rest with a valid identifier continuation starting with an underscore",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    let _ = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    let cursor = Cursor { rest: \"_example\", #[cfg(span_locations)] off: 0 }; assert_eq!(word_break(cursor), Err(Reject));"
              ],
              "code": [
                "{",
                "    let cursor = Cursor {",
                "        rest: \"_example\", // Non-empty rest with a valid identifier continuation starting with an underscore",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    let _ = word_break(cursor);",
                "    let cursor = Cursor { rest: \"_example\", #[cfg(span_locations)] off: 0 }; assert_eq!(word_break(cursor), Err(Reject));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: input.chars().next() matches Some(ch) or Some(_) at line 158 is true\n",
        "precondition: input.chars().next() matches Some(ch) at line 158 is true\n",
        "precondition: is_ident_continue(ch) at line 159 is false\n",
        "expected return value/type: Ok(input)\n"
      ],
      "input_infer": "Cursor input with non-identifier starting characters (e.g., numbers, symbols) or an empty rest string, ensuring is_ident_continue evaluates to false for the character at the start.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor { rest: \"\" };",
                "    let _result = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    let cursor = Cursor { rest: \"a\" }; // character 'a' is valid and should not trigger Err",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"1\" }; // character '1' is valid, not an identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"_\" }; // underscore is valid but treated as an identifier start, should not trigger Err",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"#\" }; // '#' is not a valid identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \" \" }; // space is not a valid identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"@\" }; // '@' is not a valid identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"abc\" }; // 'a' is valid, next characters 'bc' ignored for initial check",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)"
              ],
              "code": [
                "{",
                "    let cursor = Cursor { rest: \"\" };",
                "    let _result = word_break(cursor);",
                "    let cursor = Cursor { rest: \"a\" }; // character 'a' is valid and should not trigger Err",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"1\" }; // character '1' is valid, not an identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"_\" }; // underscore is valid but treated as an identifier start, should not trigger Err",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"#\" }; // '#' is not a valid identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \" \" }; // space is not a valid identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"@\" }; // '@' is not a valid identifier continuation",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "    ",
                "    let cursor = Cursor { rest: \"abc\" }; // 'a' is valid, next characters 'bc' ignored for initial check",
                "    let _result = word_break(cursor); // Expected: Ok(cursor)",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor { rest: \"123abc\" };",
                "    let _result = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    let cursor = Cursor { rest: \"123abc\" };",
                "    let result = word_break(cursor);",
                "    assert_eq!(result, Ok(cursor));"
              ],
              "code": [
                "{",
                "    let cursor = Cursor { rest: \"123abc\" };",
                "    let _result = word_break(cursor);",
                "    let cursor = Cursor { rest: \"123abc\" };",
                "    let result = word_break(cursor);",
                "    assert_eq!(result, Ok(cursor));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor { rest: \"@abc\" };",
                "    let _result = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(Cursor { rest: \"@abc\" }));"
              ],
              "code": [
                "{",
                "    let cursor = Cursor { rest: \"@abc\" };",
                "    let _result = word_break(cursor);",
                "    assert_eq!(_result, Ok(Cursor { rest: \"@abc\" }));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor { rest: \" abc\" };",
                "    let _result = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(Cursor { rest: \" abc\" }));",
                "    assert!(_result.is_ok());",
                "    assert!(matches!(_result, Ok(_)));",
                "    assert_eq!(_result.unwrap().rest, \" abc\");"
              ],
              "code": [
                "{",
                "    let cursor = Cursor { rest: \" abc\" };",
                "    let _result = word_break(cursor);",
                "    assert_eq!(_result, Ok(Cursor { rest: \" abc\" }));",
                "    assert!(_result.is_ok());",
                "    assert!(matches!(_result, Ok(_)));",
                "    assert_eq!(_result.unwrap().rest, \" abc\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor { rest: \"#$%\" };",
                "    let _result = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    let cursor = Cursor { rest: \"a\" };",
                "    let result = word_break(cursor);",
                "    assert_eq!(result, Ok(cursor));"
              ],
              "code": [
                "{",
                "    let cursor = Cursor { rest: \"#$%\" };",
                "    let _result = word_break(cursor);",
                "    let cursor = Cursor { rest: \"a\" };",
                "    let result = word_break(cursor);",
                "    assert_eq!(result, Ok(cursor));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: input.chars().next() matches None at line 158 is true\n",
        "expected return value/type: Ok(input)\n"
      ],
      "input_infer": "Cursor input with an empty string (rest: \"\") to ensure input.chars().next() evaluates to None\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cursor = Cursor { rest: \"\" };",
                "    let _ = word_break(cursor);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(word_break(Cursor { rest: \"\" }), Ok(Cursor { rest: \"\" }));"
              ],
              "code": [
                "{",
                "    let cursor = Cursor { rest: \"\" };",
                "    let _ = word_break(cursor);",
                "    assert_eq!(word_break(Cursor { rest: \"\" }), Ok(Cursor { rest: \"\" }));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}