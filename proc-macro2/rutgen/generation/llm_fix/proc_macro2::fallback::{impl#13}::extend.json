{
  "name": "proc_macro2::fallback::{impl#13}::extend",
  "mod_info": {
    "name": "fallback",
    "loc": "src/lib.rs:151:1:151:18"
  },
  "visible": true,
  "loc": "src/fallback.rs:298:5:300:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid `TokenStream` instances (including empty streams), various iterable types containing `TokenStream` elements, including edge cases like empty iterables or single element streams.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(Vec::new()),",
                "        },",
                "    };",
                "    let empty_streams: Vec<TokenStream> = Vec::new();",
                "    stream.extend(empty_streams);",
                "}"
              ],
              "oracle": [
                "    assert!(stream.inner.is_empty());",
                "    assert_eq!(stream.inner.len(), 0);",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(Vec::new()) } }]);",
                "    assert!(!stream.inner.is_empty());",
                "    assert_eq!(stream.inner.len(), 1);",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(Vec::new()) } }, TokenStream { inner: RcVec { inner: Rc::new(Vec::new()) } }]);",
                "    assert_eq!(stream.inner.len(), 3);",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"test\", Span::call_site())))]) } }]);",
                "    assert_eq!(stream.inner.len(), 4);"
              ],
              "code": [
                "{",
                "    let mut stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(Vec::new()),",
                "        },",
                "    };",
                "    let empty_streams: Vec<TokenStream> = Vec::new();",
                "    stream.extend(empty_streams);",
                "    assert!(stream.inner.is_empty());",
                "    assert_eq!(stream.inner.len(), 0);",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(Vec::new()) } }]);",
                "    assert!(!stream.inner.is_empty());",
                "    assert_eq!(stream.inner.len(), 1);",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(Vec::new()) } }, TokenStream { inner: RcVec { inner: Rc::new(Vec::new()) } }]);",
                "    assert_eq!(stream.inner.len(), 3);",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"test\", Span::call_site())))]) } }]);",
                "    assert_eq!(stream.inner.len(), 4);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(Vec::new()),",
                "        },",
                "    };",
                "    let single_stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"x\", Span::call_site()))]),",
                "        },",
                "    };",
                "    let single_element_streams = vec![single_stream];",
                "    stream.extend(single_element_streams);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(stream.inner.len(), 1);",
                "    assert!(!stream.inner.is_empty());",
                "    assert!(matches!(stream.inner.iter().next(), Some(TokenTree::Ident(_))));",
                "    assert_eq!(stream.inner.iter().count(), 1);",
                "    stream.extend(vec![TokenStream {",
                "    inner: RcVec {",
                "    inner: Rc::new(vec![TokenTree::Punct(Punct::new('+', Spacing::Alone))]),",
                "    },",
                "    }]);",
                "    assert_eq!(stream.inner.len(), 2);",
                "    assert!(!stream.inner.is_empty());",
                "    assert!(matches!(stream.inner.iter().skip(1).next(), Some(TokenTree::Punct(_))));",
                "    assert_eq!(stream.inner.iter().count(), 2);"
              ],
              "code": [
                "{",
                "    let mut stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(Vec::new()),",
                "        },",
                "    };",
                "    let single_stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"x\", Span::call_site()))]),",
                "        },",
                "    };",
                "    let single_element_streams = vec![single_stream];",
                "    stream.extend(single_element_streams);",
                "    assert_eq!(stream.inner.len(), 1);",
                "    assert!(!stream.inner.is_empty());",
                "    assert!(matches!(stream.inner.iter().next(), Some(TokenTree::Ident(_))));",
                "    assert_eq!(stream.inner.iter().count(), 1);",
                "    stream.extend(vec![TokenStream {",
                "    inner: RcVec {",
                "    inner: Rc::new(vec![TokenTree::Punct(Punct::new('+', Spacing::Alone))]),",
                "    },",
                "    }]);",
                "    assert_eq!(stream.inner.len(), 2);",
                "    assert!(!stream.inner.is_empty());",
                "    assert!(matches!(stream.inner.iter().skip(1).next(), Some(TokenTree::Punct(_))));",
                "    assert_eq!(stream.inner.iter().count(), 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(Vec::new()),",
                "        },",
                "    };",
                "    let multiple_streams = vec![",
                "        TokenStream {",
                "            inner: RcVec {",
                "                inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"a\", Span::call_site()))]),",
                "            },",
                "        },",
                "        TokenStream {",
                "            inner: RcVec {",
                "                inner: Rc::new(vec![TokenTree::Punct(Punct::new('+', Spacing::Alone))]),",
                "            },",
                "        },",
                "        TokenStream {",
                "            inner: RcVec {",
                "                inner: Rc::new(vec![TokenTree::Literal(Literal::new(\"42\", Span::call_site()))]),",
                "            },",
                "        },",
                "    ];",
                "    stream.extend(multiple_streams);",
                "}"
              ],
              "oracle": [
                "    assert!(stream.inner.len() > 0);",
                "    assert!(stream.inner.len() == 3);",
                "    assert!(stream.inner.is_empty() == false);",
                "    assert!(stream.inner.iter().count() == 3);",
                "    assert!(stream.inner.iter().any(|x| matches!(x, TokenTree::Ident(_)));",
                "    assert!(stream.inner.iter().any(|x| matches!(x, TokenTree::Punct(_)));",
                "    assert!(stream.inner.iter().any(|x| matches!(x, TokenTree::Literal(_)));"
              ],
              "code": [
                "{",
                "    let mut stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(Vec::new()),",
                "        },",
                "    };",
                "    let multiple_streams = vec![",
                "        TokenStream {",
                "            inner: RcVec {",
                "                inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"a\", Span::call_site()))]),",
                "            },",
                "        },",
                "        TokenStream {",
                "            inner: RcVec {",
                "                inner: Rc::new(vec![TokenTree::Punct(Punct::new('+', Spacing::Alone))]),",
                "            },",
                "        },",
                "        TokenStream {",
                "            inner: RcVec {",
                "                inner: Rc::new(vec![TokenTree::Literal(Literal::new(\"42\", Span::call_site()))]),",
                "            },",
                "        },",
                "    ];",
                "    stream.extend(multiple_streams);",
                "    assert!(stream.inner.len() > 0);",
                "    assert!(stream.inner.len() == 3);",
                "    assert!(stream.inner.is_empty() == false);",
                "    assert!(stream.inner.iter().count() == 3);",
                "    assert!(stream.inner.iter().any(|x| matches!(x, TokenTree::Ident(_)));",
                "    assert!(stream.inner.iter().any(|x| matches!(x, TokenTree::Punct(_)));",
                "    assert!(stream.inner.iter().any(|x| matches!(x, TokenTree::Literal(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(Vec::new()),",
                "        },",
                "    };",
                "    let empty_streams: Vec<TokenStream> = Vec::new();",
                "    let non_empty_stream = TokenStream {",
                "        inner: RcVec {",
                "            inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"y\", Span::call_site()))]),",
                "        },",
                "    };",
                "    let mixed_streams = vec![empty_streams, non_empty_stream];",
                "    stream.extend(mixed_streams.into_iter().flatten());",
                "}"
              ],
              "oracle": [
                "    assert!(stream.inner.is_empty());",
                "    assert_eq!(stream.inner.len(), 1);",
                "    assert!(matches!(stream.inner.iter().next(), Some(TokenTree::Ident(_))));",
                "    assert_eq!(stream.inner.iter().count(), 1);",
                "    assert!(stream.inner.make_mut().len() == 1);",
                "    assert!(stream.inner.get_mut().is_some());",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(vec![TokenTree::Punct(Punct::new('+', Spacing::Alone))]) }} ]);",
                "    assert_eq!(stream.inner.len(), 2);",
                "    assert!(matches!(stream.inner.iter().nth(1), Some(TokenTree::Punct(_))));",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(vec![TokenTree::Literal(Literal::new(\"42\", Span::call_site()))]) }} ]);",
                "    assert_eq!(stream.inner.len(), 3);",
                "    assert!(matches!(stream.inner.iter().nth(2), Some(TokenTree::Literal(_))));"
              ],
              "code": [
                "{",
                "  use proc_macro::Punct;  ",
                "  use std::rc::Rc;  ",
                "   ",
                "   let mut stream = TokenStream {",
                "       inner: RcVec {",
                "          inner: Rc::new(vec![]),  ",
                "       },",
                "   };",
                "   let empty_streams: Vec<TokenStream> = Vec::new();",
                "   let non_empty_stream = TokenStream {",
                "       inner: RcVec {",
                "           inner: Rc::new(vec![TokenTree::Ident(Ident::new(\"y\", Span::call_site()))]),",
                "       },",
                "   };",
                "  let mixed_streams = vec![empty_streams, vec![non_empty_stream]];",
                "   stream.extend(mixed_streams.into_iter().flatten());",
                "   assert!(stream.inner.is_empty());",
                "   assert_eq!(stream.inner.len(), 1);",
                "   assert!(matches!(stream.inner.iter().next(), Some(TokenTree::Ident(_))));",
                "   assert_eq!(stream.inner.iter().count(), 1);",
                "   assert!(stream.inner.make_mut().len() == 1);",
                "    assert_eq!(stream.inner.len(), 2);",
                "    assert!(matches!(stream.inner.iter().nth(1), Some(TokenTree::Punct(_))));",
                "    stream.extend(vec![TokenStream { inner: RcVec { inner: Rc::new(vec![TokenTree::Literal(Literal::new(\"42\", Span::call_site()))]) }} ]);",
                "    assert_eq!(stream.inner.len(), 3);",
                "    assert!(matches!(stream.inner.iter().nth(2), Some(TokenTree::Literal(_))));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}