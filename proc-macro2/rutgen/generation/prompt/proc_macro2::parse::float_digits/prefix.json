{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/parse.rs\n// crate name is proc_macro2\ntype PResult<'a, O> = Result<(Cursor<'a>, O), Reject>;\nuse crate::fallback::{\n    self, is_ident_continue, is_ident_start, Group, Ident, LexError, Literal, Span,\n    TokenStream, TokenStreamBuilder,\n};\nuse crate::{Delimiter, Punct, Spacing, TokenTree};\nuse core::char;\nuse core::str::{Bytes, CharIndices, Chars};\nconst ERROR: &str = \"(/*ERROR*/)\";\n#[derive(Copy, Clone, Eq, PartialEq)]\npub(crate) struct Cursor<'a> {\n    pub(crate) rest: &'a str,\n    #[cfg(span_locations)]\n    pub(crate) off: u32,\n}\npub(crate) struct Reject;\nimpl<'a> Cursor<'a> {\n    pub(crate) fn advance(&self, bytes: usize) -> Cursor<'a> {\n        let (_front, rest) = self.rest.split_at(bytes);\n        Cursor {\n            rest,\n            #[cfg(span_locations)]\n            off: self.off + _front.chars().count() as u32,\n        }\n    }\n    pub(crate) fn starts_with(&self, s: &str) -> bool {}\n    pub(crate) fn starts_with_char(&self, ch: char) -> bool {}\n    pub(crate) fn starts_with_fn<Pattern>(&self, f: Pattern) -> bool\n    where\n        Pattern: FnMut(char) -> bool,\n    {}\n    pub(crate) fn is_empty(&self) -> bool {}\n    fn len(&self) -> usize {}\n    fn as_bytes(&self) -> &'a [u8] {}\n    fn bytes(&self) -> Bytes<'a> {}\n    fn chars(&self) -> Chars<'a> {\n        self.rest.chars()\n    }\n    fn char_indices(&self) -> CharIndices<'a> {}\n    fn parse(&self, tag: &str) -> Result<Cursor<'a>, Reject> {}\n}\nfn float_digits(input: Cursor) -> Result<Cursor, Reject> {\n    let mut chars = input.chars().peekable();\n    match chars.next() {\n        Some(ch) if '0' <= ch && ch <= '9' => {}\n        _ => return Err(Reject),\n    }\n    let mut len = 1;\n    let mut has_dot = false;\n    let mut has_exp = false;\n    while let Some(&ch) = chars.peek() {\n        match ch {\n            '0'..='9' | '_' => {\n                chars.next();\n                len += 1;\n            }\n            '.' => {\n                if has_dot {\n                    break;\n                }\n                chars.next();\n                if chars.peek().map_or(false, |&ch| ch == '.' || is_ident_start(ch)) {\n                    return Err(Reject);\n                }\n                len += 1;\n                has_dot = true;\n            }\n            'e' | 'E' => {\n                chars.next();\n                len += 1;\n                has_exp = true;\n                break;\n            }\n            _ => break,\n        }\n    }\n    if !(has_dot || has_exp) {\n        return Err(Reject);\n    }\n    if has_exp {\n        let token_before_exp = if has_dot {\n            Ok(input.advance(len - 1))\n        } else {\n            Err(Reject)\n        };\n        let mut has_sign = false;\n        let mut has_exp_value = false;\n        while let Some(&ch) = chars.peek() {\n            match ch {\n                '+' | '-' => {\n                    if has_exp_value {\n                        break;\n                    }\n                    if has_sign {\n                        return token_before_exp;\n                    }\n                    chars.next();\n                    len += 1;\n                    has_sign = true;\n                }\n                '0'..='9' => {\n                    chars.next();\n                    len += 1;\n                    has_exp_value = true;\n                }\n                '_' => {\n                    chars.next();\n                    len += 1;\n                }\n                _ => break,\n            }\n        }\n        if !has_exp_value {\n            return token_before_exp;\n        }\n    }\n    Ok(input.advance(len))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n721 fn float_digits(input: Cursor) -> Result<Cursor, Reject> {\n722     let mut chars = input.chars().peekable();\n723     match chars.next() {\n724         Some(ch) if '0' <= ch && ch <= '9' => {}\n725         _ => return Err(Reject),\n726     }\n727 \n728     let mut len = 1;\n729     let mut has_dot = false;\n730     let mut has_exp = false;\n731     while let Some(&ch) = chars.peek() {\n732         match ch {\n733             '0'..='9' | '_' => {\n734                 chars.next();\n735                 len += 1;\n736             }\n737             '.' => {\n738                 if has_dot {\n739                     break;\n740                 }\n741                 chars.next();\n742                 if chars\n743                     .peek()\n744                     .map_or(false, |&ch| ch == '.' || is_ident_start(ch))\n745                 {\n746                     return Err(Reject);\n747                 }\n748                 len += 1;\n749                 has_dot = true;\n750             }\n751             'e' | 'E' => {\n752                 chars.next();\n753                 len += 1;\n754                 has_exp = true;\n755                 break;\n756             }\n757             _ => break,\n758         }\n759     }\n760 \n761     if !(has_dot || has_exp) {\n762         return Err(Reject);\n763     }\n764 \n765     if has_exp {\n766         let token_before_exp = if has_dot {\n767             Ok(input.advance(len - 1))\n768         } else {\n769             Err(Reject)\n770         };\n771         let mut has_sign = false;\n772         let mut has_exp_value = false;\n773         while let Some(&ch) = chars.peek() {\n774             match ch {\n775                 '+' | '-' => {\n776                     if has_exp_value {\n777                         break;\n778                     }\n779                     if has_sign {\n780                         return token_before_exp;\n781                     }\n782                     chars.next();\n783                     len += 1;\n784                     has_sign = true;\n785                 }\n786                 '0'..='9' => {\n787                     chars.next();\n788                     len += 1;\n789                     has_exp_value = true;\n790                 }\n791                 '_' => {\n792                     chars.next();\n793                     len += 1;\n794                 }\n795                 _ => break,\n796             }\n797         }\n798         if !has_exp_value {\n799             return token_before_exp;\n800         }\n801     }\n802 \n803     Ok(input.advance(len))\n804 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}