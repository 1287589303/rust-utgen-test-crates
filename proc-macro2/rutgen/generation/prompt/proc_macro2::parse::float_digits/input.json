{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/parse.rs\n// crate name is proc_macro2\ntype PResult<'a, O> = Result<(Cursor<'a>, O), Reject>;\nuse crate::fallback::{\n    self, is_ident_continue, is_ident_start, Group, Ident, LexError, Literal, Span,\n    TokenStream, TokenStreamBuilder,\n};\nuse crate::{Delimiter, Punct, Spacing, TokenTree};\nuse core::char;\nuse core::str::{Bytes, CharIndices, Chars};\nconst ERROR: &str = \"(/*ERROR*/)\";\n#[derive(Copy, Clone, Eq, PartialEq)]\npub(crate) struct Cursor<'a> {\n    pub(crate) rest: &'a str,\n    #[cfg(span_locations)]\n    pub(crate) off: u32,\n}\npub(crate) struct Reject;\nimpl<'a> Cursor<'a> {\n    pub(crate) fn advance(&self, bytes: usize) -> Cursor<'a> {\n        let (_front, rest) = self.rest.split_at(bytes);\n        Cursor {\n            rest,\n            #[cfg(span_locations)]\n            off: self.off + _front.chars().count() as u32,\n        }\n    }\n    pub(crate) fn starts_with(&self, s: &str) -> bool {}\n    pub(crate) fn starts_with_char(&self, ch: char) -> bool {}\n    pub(crate) fn starts_with_fn<Pattern>(&self, f: Pattern) -> bool\n    where\n        Pattern: FnMut(char) -> bool,\n    {}\n    pub(crate) fn is_empty(&self) -> bool {}\n    fn len(&self) -> usize {}\n    fn as_bytes(&self) -> &'a [u8] {}\n    fn bytes(&self) -> Bytes<'a> {}\n    fn chars(&self) -> Chars<'a> {\n        self.rest.chars()\n    }\n    fn char_indices(&self) -> CharIndices<'a> {}\n    fn parse(&self, tag: &str) -> Result<Cursor<'a>, Reject> {}\n}\nfn float_digits(input: Cursor) -> Result<Cursor, Reject> {\n    let mut chars = input.chars().peekable();\n    match chars.next() {\n        Some(ch) if '0' <= ch && ch <= '9' => {}\n        _ => return Err(Reject),\n    }\n    let mut len = 1;\n    let mut has_dot = false;\n    let mut has_exp = false;\n    while let Some(&ch) = chars.peek() {\n        match ch {\n            '0'..='9' | '_' => {\n                chars.next();\n                len += 1;\n            }\n            '.' => {\n                if has_dot {\n                    break;\n                }\n                chars.next();\n                if chars.peek().map_or(false, |&ch| ch == '.' || is_ident_start(ch)) {\n                    return Err(Reject);\n                }\n                len += 1;\n                has_dot = true;\n            }\n            'e' | 'E' => {\n                chars.next();\n                len += 1;\n                has_exp = true;\n                break;\n            }\n            _ => break,\n        }\n    }\n    if !(has_dot || has_exp) {\n        return Err(Reject);\n    }\n    if has_exp {\n        let token_before_exp = if has_dot {\n            Ok(input.advance(len - 1))\n        } else {\n            Err(Reject)\n        };\n        let mut has_sign = false;\n        let mut has_exp_value = false;\n        while let Some(&ch) = chars.peek() {\n            match ch {\n                '+' | '-' => {\n                    if has_exp_value {\n                        break;\n                    }\n                    if has_sign {\n                        return token_before_exp;\n                    }\n                    chars.next();\n                    len += 1;\n                    has_sign = true;\n                }\n                '0'..='9' => {\n                    chars.next();\n                    len += 1;\n                    has_exp_value = true;\n                }\n                '_' => {\n                    chars.next();\n                    len += 1;\n                }\n                _ => break,\n            }\n        }\n        if !has_exp_value {\n            return token_before_exp;\n        }\n    }\n    Ok(input.advance(len))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n721 fn float_digits(input: Cursor) -> Result<Cursor, Reject> {\n722     let mut chars = input.chars().peekable();\n723     match chars.next() {\n724         Some(ch) if '0' <= ch && ch <= '9' => {}\n725         _ => return Err(Reject),\n726     }\n727 \n728     let mut len = 1;\n729     let mut has_dot = false;\n730     let mut has_exp = false;\n731     while let Some(&ch) = chars.peek() {\n732         match ch {\n733             '0'..='9' | '_' => {\n734                 chars.next();\n735                 len += 1;\n736             }\n737             '.' => {\n738                 if has_dot {\n739                     break;\n740                 }\n741                 chars.next();\n742                 if chars\n743                     .peek()\n744                     .map_or(false, |&ch| ch == '.' || is_ident_start(ch))\n745                 {\n746                     return Err(Reject);\n747                 }\n748                 len += 1;\n749                 has_dot = true;\n750             }\n751             'e' | 'E' => {\n752                 chars.next();\n753                 len += 1;\n754                 has_exp = true;\n755                 break;\n756             }\n757             _ => break,\n758         }\n759     }\n760 \n761     if !(has_dot || has_exp) {\n762         return Err(Reject);\n763     }\n764 \n765     if has_exp {\n766         let token_before_exp = if has_dot {\n767             Ok(input.advance(len - 1))\n768         } else {\n769             Err(Reject)\n770         };\n771         let mut has_sign = false;\n772         let mut has_exp_value = false;\n773         while let Some(&ch) = chars.peek() {\n774             match ch {\n775                 '+' | '-' => {\n776                     if has_exp_value {\n777                         break;\n778                     }\n779                     if has_sign {\n780                         return token_before_exp;\n781                     }\n782                     chars.next();\n783                     len += 1;\n784                     has_sign = true;\n785                 }\n786                 '0'..='9' => {\n787                     chars.next();\n788                     len += 1;\n789                     has_exp_value = true;\n790                 }\n791                 '_' => {\n792                     chars.next();\n793                     len += 1;\n794                 }\n795                 _ => break,\n796             }\n797         }\n798         if !has_exp_value {\n799             return token_before_exp;\n800         }\n801     }\n802 \n803     Ok(input.advance(len))\n804 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}