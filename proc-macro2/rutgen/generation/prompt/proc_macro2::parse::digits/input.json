{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/parse.rs\n// crate name is proc_macro2\ntype PResult<'a, O> = Result<(Cursor<'a>, O), Reject>;\nuse crate::fallback::{\n    self, is_ident_continue, is_ident_start, Group, Ident, LexError, Literal, Span,\n    TokenStream, TokenStreamBuilder,\n};\nuse crate::{Delimiter, Punct, Spacing, TokenTree};\nuse core::char;\nuse core::str::{Bytes, CharIndices, Chars};\nconst ERROR: &str = \"(/*ERROR*/)\";\n#[derive(Copy, Clone, Eq, PartialEq)]\npub(crate) struct Cursor<'a> {\n    pub(crate) rest: &'a str,\n    #[cfg(span_locations)]\n    pub(crate) off: u32,\n}\npub(crate) struct Reject;\nimpl<'a> Cursor<'a> {\n    pub(crate) fn advance(&self, bytes: usize) -> Cursor<'a> {\n        let (_front, rest) = self.rest.split_at(bytes);\n        Cursor {\n            rest,\n            #[cfg(span_locations)]\n            off: self.off + _front.chars().count() as u32,\n        }\n    }\n    pub(crate) fn starts_with(&self, s: &str) -> bool {\n        self.rest.starts_with(s)\n    }\n    pub(crate) fn starts_with_char(&self, ch: char) -> bool {}\n    pub(crate) fn starts_with_fn<Pattern>(&self, f: Pattern) -> bool\n    where\n        Pattern: FnMut(char) -> bool,\n    {}\n    pub(crate) fn is_empty(&self) -> bool {}\n    fn len(&self) -> usize {}\n    fn as_bytes(&self) -> &'a [u8] {}\n    fn bytes(&self) -> Bytes<'a> {\n        self.rest.bytes()\n    }\n    fn chars(&self) -> Chars<'a> {}\n    fn char_indices(&self) -> CharIndices<'a> {}\n    fn parse(&self, tag: &str) -> Result<Cursor<'a>, Reject> {}\n}\nfn digits(mut input: Cursor) -> Result<Cursor, Reject> {\n    let base = if input.starts_with(\"0x\") {\n        input = input.advance(2);\n        16\n    } else if input.starts_with(\"0o\") {\n        input = input.advance(2);\n        8\n    } else if input.starts_with(\"0b\") {\n        input = input.advance(2);\n        2\n    } else {\n        10\n    };\n    let mut len = 0;\n    let mut empty = true;\n    for b in input.bytes() {\n        match b {\n            b'0'..=b'9' => {\n                let digit = (b - b'0') as u64;\n                if digit >= base {\n                    return Err(Reject);\n                }\n            }\n            b'a'..=b'f' => {\n                let digit = 10 + (b - b'a') as u64;\n                if digit >= base {\n                    break;\n                }\n            }\n            b'A'..=b'F' => {\n                let digit = 10 + (b - b'A') as u64;\n                if digit >= base {\n                    break;\n                }\n            }\n            b'_' => {\n                if empty && base == 10 {\n                    return Err(Reject);\n                }\n                len += 1;\n                continue;\n            }\n            _ => break,\n        }\n        len += 1;\n        empty = false;\n    }\n    if empty { Err(Reject) } else { Ok(input.advance(len)) }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n816 fn digits(mut input: Cursor) -> Result<Cursor, Reject> {\n817     let base = if input.starts_with(\"0x\") {\n818         input = input.advance(2);\n819         16\n820     } else if input.starts_with(\"0o\") {\n821         input = input.advance(2);\n822         8\n823     } else if input.starts_with(\"0b\") {\n824         input = input.advance(2);\n825         2\n826     } else {\n827         10\n828     };\n829 \n830     let mut len = 0;\n831     let mut empty = true;\n832     for b in input.bytes() {\n833         match b {\n834             b'0'..=b'9' => {\n835                 let digit = (b - b'0') as u64;\n836                 if digit >= base {\n837                     return Err(Reject);\n838                 }\n839             }\n840             b'a'..=b'f' => {\n841                 let digit = 10 + (b - b'a') as u64;\n842                 if digit >= base {\n843                     break;\n844                 }\n845             }\n846             b'A'..=b'F' => {\n847                 let digit = 10 + (b - b'A') as u64;\n848                 if digit >= base {\n849                     break;\n850                 }\n851             }\n852             b'_' => {\n853                 if empty && base == 10 {\n854                     return Err(Reject);\n855                 }\n856                 len += 1;\n857                 continue;\n858             }\n859             _ => break,\n860         }\n861         len += 1;\n862         empty = false;\n863     }\n864     if empty {\n865         Err(Reject)\n866     } else {\n867         Ok(input.advance(len))\n868     }\n869 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}