{
  "name": "proc_macro2::parse::literal_suffix",
  "mod_info": {
    "name": "parse",
    "loc": "src/lib.rs:142:1:142:11"
  },
  "visible": false,
  "loc": "src/parse.rs:363:1:368:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: ident_not_raw(input) matches Err(Reject) at line 364 is true\n",
        "expected return value/type: input\n"
      ],
      "input_infer": "Cursor containing a string that does not start with a valid identifier character and has valid length; test with input `Cursor { rest: \"123abc\", off: 0 }` and similar variations where the first character is not an identifier start.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor { rest: \"123abc\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \"123abc\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);"
              ],
              "code": [
                "{",
                "    let input = Cursor { rest: \"123abc\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "    let input = Cursor { rest: \"123abc\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor { rest: \"!@#abc\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \"!@#abc\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);"
              ],
              "code": [
                "{",
                "    let input = Cursor { rest: \"!@#abc\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "    let input = Cursor { rest: \"!@#abc\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor { rest: \" abc\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \" abc\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);"
              ],
              "code": [
                "{",
                "    let input = Cursor { rest: \" abc\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "    let input = Cursor { rest: \" abc\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor { rest: \"\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \"\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);"
              ],
              "code": [
                "{",
                "    let input = Cursor { rest: \"\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "    let input = Cursor { rest: \"\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor { rest: \"789\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \"789\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);"
              ],
              "code": [
                "{",
                "    let input = Cursor { rest: \"789\", off: 0 };",
                "    let _result = literal_suffix(input);",
                "    let input = Cursor { rest: \"789\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: ident_not_raw(input) matches Ok((input, _)) at line 364 is true\n",
        "precondition: ident_not_raw(input) matches Ok((input, _)) at line 364 is true\n",
        "expected return value/type: input\n"
      ],
      "input_infer": "Cursor with rest as a non-empty string starting with a valid identifier character (e.g., 'a', 'A', '$', '_') followed by valid identifier continuation characters (e.g., alphanumeric chars, '$', '_') and length greater than one.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor {",
                "        rest: \"abc123_def$ghi\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \"abc123_def$ghi\", #[cfg(span_locations)] off: 0 };",
                "    assert_eq!(literal_suffix(input), input);"
              ],
              "code": [
                "{",
                "    let input = Cursor {",
                "        rest: \"abc123_def$ghi\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "    let input = Cursor { rest: \"abc123_def$ghi\", #[cfg(span_locations)] off: 0 };",
                "    assert_eq!(literal_suffix(input), input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor {",
                "        rest: \"$validIdentifier123\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \"$validIdentifier123\", #[cfg(span_locations)] off: 0 }; assert_eq!(literal_suffix(input), input);"
              ],
              "code": [
                "{",
                "    let input = Cursor {",
                "        rest: \"$validIdentifier123\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "    let input = Cursor { rest: \"$validIdentifier123\", #[cfg(span_locations)] off: 0 }; assert_eq!(literal_suffix(input), input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor {",
                "        rest: \"_leadingUnderscore\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(literal_suffix(Cursor { rest: \"_leadingUnderscore\", ..Default::default() }), Cursor { rest: \"_leadingUnderscore\", ..Default::default() });"
              ],
              "code": [
                "{",
                "    let input = Cursor {",
                "        rest: \"_leadingUnderscore\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "    assert_eq!(literal_suffix(Cursor { rest: \"_leadingUnderscore\", ..Default::default() }), Cursor { rest: \"_leadingUnderscore\", ..Default::default() });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor {",
                "        rest: \"A1B2C3_$D4E5F6G7\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    let input = Cursor { rest: \"A1B2C3_$D4E5F6G7\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);"
              ],
              "code": [
                "{",
                "    let input = Cursor {",
                "        rest: \"A1B2C3_$D4E5F6G7\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "    let input = Cursor { rest: \"A1B2C3_$D4E5F6G7\", off: 0 };",
                "    let result = literal_suffix(input);",
                "    assert_eq!(result, input);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = Cursor {",
                "        rest: \"a\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(literal_suffix(Cursor { rest: \"a\", off: 0 }), Cursor { rest: \"a\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"identifier\", off: 0 }), Cursor { rest: \"identifier\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"x123\", off: 0 }), Cursor { rest: \"x123\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"valid_token\", off: 0 }), Cursor { rest: \"valid_token\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"anotherValidIdentifier\", off: 0 }), Cursor { rest: \"anotherValidIdentifier\", off: 0 });"
              ],
              "code": [
                "{",
                "    let input = Cursor {",
                "        rest: \"a\",",
                "        #[cfg(span_locations)]",
                "        off: 0,",
                "    };",
                "    literal_suffix(input);",
                "    assert_eq!(literal_suffix(Cursor { rest: \"a\", off: 0 }), Cursor { rest: \"a\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"identifier\", off: 0 }), Cursor { rest: \"identifier\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"x123\", off: 0 }), Cursor { rest: \"x123\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"valid_token\", off: 0 }), Cursor { rest: \"valid_token\", off: 0 });",
                "    assert_eq!(literal_suffix(Cursor { rest: \"anotherValidIdentifier\", off: 0 }), Cursor { rest: \"anotherValidIdentifier\", off: 0 });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}