[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let mut my_set = MyIndexSet::new();",
          "    my_set.set.insert(MyEquivalent(\"test_value1\".to_string()));",
          "    ",
          "    let query = MyEquivalent(\"test_value1\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"test_value1\".to_string())), Some((0, &MyEquivalent(\"test_value1\".to_string()))));",
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"non_existent\".to_string())), None);"
        ],
        "code": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let mut my_set = MyIndexSet::new();",
          "    my_set.set.insert(MyEquivalent(\"test_value1\".to_string()));",
          "    ",
          "    let query = MyEquivalent(\"test_value1\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"test_value1\".to_string())), Some((0, &MyEquivalent(\"test_value1\".to_string()))));",
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"non_existent\".to_string())), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let mut my_set = MyIndexSet::new();",
          "    my_set.set.insert(MyEquivalent(\"test_value2\".to_string()));",
          "    ",
          "    let query = MyEquivalent(\"non_existing_value\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, None);",
          "    ",
          "    let query_existing = MyEquivalent(\"test_value2\".to_string());",
          "    let result_existing = my_set.set.get_full(&query_existing);",
          "    assert!(result_existing.is_some());",
          "    assert_eq!(result_existing.unwrap().1.0, \"test_value2\");",
          "    ",
          "    my_set.set.insert(MyEquivalent(\"another_value\".to_string()));",
          "    let query_another = MyEquivalent(\"another_value\".to_string());",
          "    let result_another = my_set.set.get_full(&query_another);",
          "    assert!(result_another.is_some());",
          "    assert_eq!(result_another.unwrap().1.0, \"another_value\");"
        ],
        "code": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let mut my_set = MyIndexSet::new();",
          "    my_set.set.insert(MyEquivalent(\"test_value2\".to_string()));",
          "    ",
          "    let query = MyEquivalent(\"non_existing_value\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "    assert_eq!(_result, None);",
          "    ",
          "    let query_existing = MyEquivalent(\"test_value2\".to_string());",
          "    let result_existing = my_set.set.get_full(&query_existing);",
          "    assert!(result_existing.is_some());",
          "    assert_eq!(result_existing.unwrap().1.0, \"test_value2\");",
          "    ",
          "    my_set.set.insert(MyEquivalent(\"another_value\".to_string()));",
          "    let query_another = MyEquivalent(\"another_value\".to_string());",
          "    let result_another = my_set.set.get_full(&query_another);",
          "    assert!(result_another.is_some());",
          "    assert_eq!(result_another.unwrap().1.0, \"another_value\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let my_set = MyIndexSet::new();",
          "    ",
          "    let query = MyEquivalent(\"test_value1\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, None);",
          "    let value = MyEquivalent(\"test_value2\".to_string());",
          "    my_set.set.map.insert(value.clone(), ());",
          "    let result = my_set.set.get_full(&value);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().1, &value);",
          "    let (index, returned_value) = my_set.set.get_full(&value).unwrap();",
          "    assert_eq!(index, 0);",
          "    assert_eq!(returned_value, &value);"
        ],
        "code": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let my_set = MyIndexSet::new();",
          "    ",
          "    let query = MyEquivalent(\"test_value1\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "    assert_eq!(_result, None);",
          "    let value = MyEquivalent(\"test_value2\".to_string());",
          "    my_set.set.map.insert(value.clone(), ());",
          "    let result = my_set.set.get_full(&value);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().1, &value);",
          "    let (index, returned_value) = my_set.set.get_full(&value).unwrap();",
          "    assert_eq!(index, 0);",
          "    assert_eq!(returned_value, &value);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let mut my_set = MyIndexSet::new();",
          "    my_set.set.insert(MyEquivalent(\"boundary_value\".to_string()));",
          "    ",
          "    let query = MyEquivalent(\"boundary_value\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "}"
        ],
        "oracle": [
          "    assert!(my_set.set.get_full(&MyEquivalent(\"boundary_value\".to_string())).is_some());",
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"boundary_value\".to_string())).unwrap().0, 0);",
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"boundary_value\".to_string())).unwrap().1.0, \"boundary_value\");",
          "    assert!(my_set.set.get_full(&MyEquivalent(\"non_existent_value\".to_string())).is_none());",
          "    let empty_set = MyIndexSet::new();",
          "    assert!(empty_set.set.get_full(&MyEquivalent(\"any_value\".to_string())).is_none());"
        ],
        "code": [
          "{",
          "    struct MyEquivalent(String);",
          "    ",
          "    impl Hash for MyEquivalent {",
          "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {",
          "            state.write(self.0.as_bytes());",
          "        }",
          "    }",
          "    ",
          "    struct MyIndexSet {",
          "        set: crate::IndexSet<MyEquivalent, std::collections::hash_map::RandomState>,",
          "    }",
          "    ",
          "    impl MyIndexSet {",
          "        fn new() -> Self {",
          "            let set = crate::IndexSet {",
          "                map: crate::IndexMap::new(),",
          "            };",
          "            MyIndexSet { set }",
          "        }",
          "    }",
          "    ",
          "    let mut my_set = MyIndexSet::new();",
          "    my_set.set.insert(MyEquivalent(\"boundary_value\".to_string()));",
          "    ",
          "    let query = MyEquivalent(\"boundary_value\".to_string());",
          "    let _result = my_set.set.get_full(&query);",
          "    assert!(my_set.set.get_full(&MyEquivalent(\"boundary_value\".to_string())).is_some());",
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"boundary_value\".to_string())).unwrap().0, 0);",
          "    assert_eq!(my_set.set.get_full(&MyEquivalent(\"boundary_value\".to_string())).unwrap().1.0, \"boundary_value\");",
          "    assert!(my_set.set.get_full(&MyEquivalent(\"non_existent_value\".to_string())).is_none());",
          "    let empty_set = MyIndexSet::new();",
          "    assert!(empty_set.set.get_full(&MyEquivalent(\"any_value\".to_string())).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]