[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set.insert(3);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(2);",
          "        set.insert(4);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "}"
        ],
        "oracle": [
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = { let mut set = super::IndexSet::default(); set.insert(1); set.insert(2); set.insert(3); set };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = { let mut set = super::IndexSet::default(); set.insert(2); set.insert(4); set };",
          "    _result = &set1 - &set2;",
          "    assert_eq!(_result.len(), 2);",
          "    assert!(_result.contains(&1));",
          "    assert!(_result.contains(&3));",
          "    assert!(!_result.contains(&2));",
          "    assert!(!_result.contains(&4));"
        ],
        "code": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set.insert(3);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(2);",
          "        set.insert(4);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = { let mut set = super::IndexSet::default(); set.insert(1); set.insert(2); set.insert(3); set };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = { let mut set = super::IndexSet::default(); set.insert(2); set.insert(4); set };",
          "    _result = &set1 - &set2;",
          "    assert_eq!(_result.len(), 2);",
          "    assert!(_result.contains(&1));",
          "    assert!(_result.contains(&3));",
          "    assert!(!_result.contains(&2));",
          "    assert!(!_result.contains(&4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set.insert(3);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = super::IndexSet::default();",
          "    let _result = &set1 - &set2;",
          "}"
        ],
        "oracle": [
          "    let set1 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default().insert(1).insert(2).insert(3);",
          "    let set2 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    let result = &set1 - &set2;",
          "    assert_eq!(result, set1);",
          "    ",
          "    let set3: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set",
          "    };",
          "    let set4: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(1);",
          "    set.insert(3);",
          "    set",
          "    };",
          "    let result2 = &set3 - &set4;",
          "    assert_eq!(result2.len(), 1);",
          "    assert!(result2.contains(&2));",
          "    ",
          "    let set5: super::IndexSet<i32, std::collections::hash_map::RandomState> = super::IndexSet::default();",
          "    let result3 = &set5 - &set1;",
          "    assert!(result3.is_empty());",
          "    ",
          "    let set6: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(4);",
          "    set.insert(5);",
          "    set",
          "    };",
          "    let result4 = &set1 - &set6;",
          "    assert_eq!(result4.len(), 3);",
          "    assert!(result4.contains(&1));",
          "    assert!(result4.contains(&2));",
          "    assert!(result4.contains(&3));"
        ],
        "code": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set.insert(3);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = super::IndexSet::default();",
          "    let _result = &set1 - &set2;",
          "    let set1 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default().insert(1).insert(2).insert(3);",
          "    let set2 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    let result = &set1 - &set2;",
          "    assert_eq!(result, set1);",
          "    ",
          "    let set3: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set",
          "    };",
          "    let set4: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(1);",
          "    set.insert(3);",
          "    set",
          "    };",
          "    let result2 = &set3 - &set4;",
          "    assert_eq!(result2.len(), 1);",
          "    assert!(result2.contains(&2));",
          "    ",
          "    let set5: super::IndexSet<i32, std::collections::hash_map::RandomState> = super::IndexSet::default();",
          "    let result3 = &set5 - &set1;",
          "    assert!(result3.is_empty());",
          "    ",
          "    let set6: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(4);",
          "    set.insert(5);",
          "    set",
          "    };",
          "    let result4 = &set1 - &set6;",
          "    assert_eq!(result4.len(), 3);",
          "    assert!(result4.contains(&1));",
          "    assert!(result4.contains(&2));",
          "    assert!(result4.contains(&3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "}"
        ],
        "oracle": [
          "    let set1 = super::IndexSet::default();",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    let set2 = super::IndexSet::default();",
          "    set2.insert(1);",
          "    set2.insert(2);",
          "    let result = &set1 - &set2;",
          "    assert!(result.is_empty());",
          "    assert_eq!(result.len(), 0);",
          "    let set3: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(3);",
          "    set",
          "    };",
          "    let result2 = &set1 - &set3;",
          "    assert_eq!(result2.len(), 2);",
          "    assert!(result2.contains(&1));",
          "    assert!(result2.contains(&2));",
          "    let set4: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(0);",
          "    set",
          "    };",
          "    let result3 = &set4 - &set1;",
          "    assert_eq!(result3.len(), 1);",
          "    assert!(result3.contains(&0));",
          "    let set5: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(0);",
          "    set.insert(1);",
          "    set",
          "    };",
          "    let result4 = &set1 - &set5;",
          "    assert_eq!(result4.len(), 1);",
          "    assert!(result4.contains(&2));"
        ],
        "code": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(2);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "    let set1 = super::IndexSet::default();",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    let set2 = super::IndexSet::default();",
          "    set2.insert(1);",
          "    set2.insert(2);",
          "    let result = &set1 - &set2;",
          "    assert!(result.is_empty());",
          "    assert_eq!(result.len(), 0);",
          "    let set3: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(3);",
          "    set",
          "    };",
          "    let result2 = &set1 - &set3;",
          "    assert_eq!(result2.len(), 2);",
          "    assert!(result2.contains(&1));",
          "    assert!(result2.contains(&2));",
          "    let set4: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(0);",
          "    set",
          "    };",
          "    let result3 = &set4 - &set1;",
          "    assert_eq!(result3.len(), 1);",
          "    assert!(result3.contains(&0));",
          "    let set5: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(0);",
          "    set.insert(1);",
          "    set",
          "    };",
          "    let result4 = &set1 - &set5;",
          "    assert_eq!(result4.len(), 1);",
          "    assert!(result4.contains(&2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(3);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(0);",
          "        set.insert(2);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "}"
        ],
        "oracle": [
          "    let set1 = super::IndexSet::default();",
          "    set1.insert(1);",
          "    set1.insert(3);",
          "    let set2 = super::IndexSet::default();",
          "    set2.insert(0);",
          "    set2.insert(2);",
          "    let result = &set1 - &set2;",
          "    assert_eq!(result.len(), 2);",
          "    assert!(result.contains(&1));",
          "    assert!(result.contains(&3));",
          "    assert!(!result.contains(&0));",
          "    assert!(!result.contains(&2));",
          "    let set3: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    set",
          "    };",
          "    let result2 = &set3 - &set2;",
          "    assert_eq!(result2.len(), 2);",
          "    assert!(result2.contains(&1));",
          "    assert!(result2.contains(&3));",
          "    assert!(!result2.contains(&2));",
          "    let empty_set: super::IndexSet<i32, std::collections::hash_map::RandomState> = super::IndexSet::default();",
          "    let result3 = &empty_set - &set1;",
          "    assert_eq!(result3.len(), 0);",
          "    let result4 = &set1 - &empty_set;",
          "    assert_eq!(result4.len(), 2);",
          "    assert!(result4.contains(&1));",
          "    assert!(result4.contains(&3));"
        ],
        "code": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(3);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(0);",
          "        set.insert(2);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "    let set1 = super::IndexSet::default();",
          "    set1.insert(1);",
          "    set1.insert(3);",
          "    let set2 = super::IndexSet::default();",
          "    set2.insert(0);",
          "    set2.insert(2);",
          "    let result = &set1 - &set2;",
          "    assert_eq!(result.len(), 2);",
          "    assert!(result.contains(&1));",
          "    assert!(result.contains(&3));",
          "    assert!(!result.contains(&0));",
          "    assert!(!result.contains(&2));",
          "    let set3: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "    let mut set = super::IndexSet::default();",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    set",
          "    };",
          "    let result2 = &set3 - &set2;",
          "    assert_eq!(result2.len(), 2);",
          "    assert!(result2.contains(&1));",
          "    assert!(result2.contains(&3));",
          "    assert!(!result2.contains(&2));",
          "    let empty_set: super::IndexSet<i32, std::collections::hash_map::RandomState> = super::IndexSet::default();",
          "    let result3 = &empty_set - &set1;",
          "    assert_eq!(result3.len(), 0);",
          "    let result4 = &set1 - &empty_set;",
          "    assert_eq!(result4.len(), 2);",
          "    assert!(result4.contains(&1));",
          "    assert!(result4.contains(&3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(3);",
          "        set.insert(5);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(2);",
          "        set.insert(4);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "}"
        ],
        "oracle": [
          "    let set1 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set1.insert(1);",
          "    set1.insert(3);",
          "    set1.insert(5);",
          "    let set2 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set2.insert(2);",
          "    set2.insert(4);",
          "    let result = &set1 - &set2;",
          "    assert_eq!(result, super::IndexSet::<i32, std::collections::hash_map::RandomState>::from([1, 3, 5]));",
          "    let set3 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set3.insert(1);",
          "    set3.insert(3);",
          "    let result_empty = &set3 - &set3;",
          "    assert!(result_empty.is_empty());",
          "    let set4 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set4.insert(3);",
          "    set4.insert(5);",
          "    let result_subset = &set1 - &set4;",
          "    assert_eq!(result_subset, super::IndexSet::<i32, std::collections::hash_map::RandomState>::from([1]));",
          "    let result_empty_left = &set2 - &set1;",
          "    assert!(result_empty_left.is_empty());",
          "    let set5 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set5.insert(1);",
          "    set5.insert(2);",
          "    set5.insert(3);",
          "    set5.insert(4);",
          "    let set6 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set6.insert(1);",
          "    let result_single = &set5 - &set6;",
          "    assert_eq!(result_single, super::IndexSet::<i32, std::collections::hash_map::RandomState>::from([2, 3, 4]));"
        ],
        "code": [
          "{",
          "    let set1: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(1);",
          "        set.insert(3);",
          "        set.insert(5);",
          "        set",
          "    };",
          "    let set2: super::IndexSet<i32, std::collections::hash_map::RandomState> = {",
          "        let mut set = super::IndexSet::default();",
          "        set.insert(2);",
          "        set.insert(4);",
          "        set",
          "    };",
          "    let _result = &set1 - &set2;",
          "    let set1 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set1.insert(1);",
          "    set1.insert(3);",
          "    set1.insert(5);",
          "    let set2 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set2.insert(2);",
          "    set2.insert(4);",
          "    let result = &set1 - &set2;",
          "    assert_eq!(result, super::IndexSet::<i32, std::collections::hash_map::RandomState>::from([1, 3, 5]));",
          "    let set3 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set3.insert(1);",
          "    set3.insert(3);",
          "    let result_empty = &set3 - &set3;",
          "    assert!(result_empty.is_empty());",
          "    let set4 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set4.insert(3);",
          "    set4.insert(5);",
          "    let result_subset = &set1 - &set4;",
          "    assert_eq!(result_subset, super::IndexSet::<i32, std::collections::hash_map::RandomState>::from([1]));",
          "    let result_empty_left = &set2 - &set1;",
          "    assert!(result_empty_left.is_empty());",
          "    let set5 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set5.insert(1);",
          "    set5.insert(2);",
          "    set5.insert(3);",
          "    set5.insert(4);",
          "    let set6 = super::IndexSet::<i32, std::collections::hash_map::RandomState>::default();",
          "    set6.insert(1);",
          "    let result_single = &set5 - &set6;",
          "    assert_eq!(result_single, super::IndexSet::<i32, std::collections::hash_map::RandomState>::from([2, 3, 4]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]