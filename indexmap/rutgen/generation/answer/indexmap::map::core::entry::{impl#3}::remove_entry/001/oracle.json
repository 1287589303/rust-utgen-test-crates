[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestEntries {",
          "        entries: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        ",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.entries",
          "        }",
          "",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.entries",
          "        }",
          "",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.entries",
          "        }",
          "",
          "        fn with_entries<F>(&mut self, f: F) ",
          "        where ",
          "            F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.entries);",
          "        }",
          "    }",
          "",
          "    let mut map = TestEntries { entries: vec![(0, 10), (1, 20)] };",
          "    let index = hashbrown::hash_table::OccupiedEntry::new(&mut map.entries, 0);",
          "    let entry = OccupiedEntry::new(&mut map, index);",
          "    let (_key, _value) = entry.remove_entry();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entry.as_entries(), &[(0, 10), (1, 20)]);",
          "    assert_eq!(map.entries.len(), 2);",
          "    assert_eq!(entry.key(), &0);",
          "    assert_eq!(entry.get(), &10);",
          "    let (key, value) = entry.remove_entry();",
          "    assert_eq!(key, 0);",
          "    assert_eq!(value, 10);",
          "    assert_eq!(map.entries.len(), 1);",
          "    assert_eq!(map.entries[0], (1, 20));",
          "    assert!(map.entries.iter().all(|&(k, _)| k != 0));",
          "    assert!(!map.entries.contains(&(0, 10)));"
        ],
        "code": [
          "{",
          "    struct TestEntries {",
          "        entries: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        ",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.entries",
          "        }",
          "",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.entries",
          "        }",
          "",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.entries",
          "        }",
          "",
          "        fn with_entries<F>(&mut self, f: F) ",
          "        where ",
          "            F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.entries);",
          "        }",
          "    }",
          "",
          "    let mut map = TestEntries { entries: vec![(0, 10), (1, 20)] };",
          "    let index = hashbrown::hash_table::OccupiedEntry::new(&mut map.entries, 0);",
          "    let entry = OccupiedEntry::new(&mut map, index);",
          "    let (_key, _value) = entry.remove_entry();",
          "    assert_eq!(entry.as_entries(), &[(0, 10), (1, 20)]);",
          "    assert_eq!(map.entries.len(), 2);",
          "    assert_eq!(entry.key(), &0);",
          "    assert_eq!(entry.get(), &10);",
          "    let (key, value) = entry.remove_entry();",
          "    assert_eq!(key, 0);",
          "    assert_eq!(value, 10);",
          "    assert_eq!(map.entries.len(), 1);",
          "    assert_eq!(map.entries[0], (1, 20));",
          "    assert!(map.entries.iter().all(|&(k, _)| k != 0));",
          "    assert!(!map.entries.contains(&(0, 10)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestEntries {",
          "        entries: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        ",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.entries",
          "        }",
          "",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.entries",
          "        }",
          "",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.entries",
          "        }",
          "",
          "        fn with_entries<F>(&mut self, f: F) ",
          "        where ",
          "            F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.entries);",
          "        }",
          "    }",
          "",
          "    let mut map = TestEntries { entries: vec![(0, 10), (1, 20)] };",
          "    let index = hashbrown::hash_table::OccupiedEntry::new(&mut map.entries, 1);",
          "    let (_key, _value) = entry.remove_entry();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.as_entries(), &[(0, 10), (1, 20)]);",
          "    let entry = OccupiedEntry::new(&mut map, index);",
          "    let removed_entry = entry.remove_entry();",
          "    assert_eq!(removed_entry, (1, 20));",
          "    assert_eq!(map.as_entries(), &[(0, 10)]);"
        ],
        "code": [
          "{",
          "    struct TestEntries {",
          "        entries: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        ",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.entries",
          "        }",
          "",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.entries",
          "        }",
          "",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.entries",
          "        }",
          "",
          "        fn with_entries<F>(&mut self, f: F) ",
          "        where ",
          "            F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.entries);",
          "        }",
          "    }",
          "",
          "    let mut map = TestEntries { entries: vec![(0, 10), (1, 20)] };",
          "    let index = hashbrown::hash_table::OccupiedEntry::new(&mut map.entries, 1);",
          "    let (_key, _value) = entry.remove_entry();",
          "    assert_eq!(map.as_entries(), &[(0, 10), (1, 20)]);",
          "    let entry = OccupiedEntry::new(&mut map, index);",
          "    let removed_entry = entry.remove_entry();",
          "    assert_eq!(removed_entry, (1, 20));",
          "    assert_eq!(map.as_entries(), &[(0, 10)]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestEntries {",
          "        entries: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        ",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.entries",
          "        }",
          "",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.entries",
          "        }",
          "",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.entries",
          "        }",
          "",
          "        fn with_entries<F>(&mut self, f: F) ",
          "        where ",
          "            F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.entries);",
          "        }",
          "    }",
          "",
          "    let mut map = TestEntries { entries: vec![] };",
          "    let index = hashbrown::hash_table::OccupiedEntry::new(&mut map.entries, 0);",
          "    let entry = OccupiedEntry::new(&mut map, index);",
          "    entry.remove_entry();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entry.as_entries().len(), 0);",
          "    assert!(map.entries.is_empty());",
          "    let result = entry.key();",
          "    assert!(result.is_none());",
          "    let (key, value) = entry.remove_entry();",
          "    assert_eq!(key, expected_key);",
          "    assert_eq!(value, expected_value);",
          "    assert!(!map.entries.contains(&(expected_key, expected_value)));"
        ],
        "code": [
          "{",
          "    struct TestEntries {",
          "        entries: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        ",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.entries",
          "        }",
          "",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.entries",
          "        }",
          "",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.entries",
          "        }",
          "",
          "        fn with_entries<F>(&mut self, f: F) ",
          "        where ",
          "            F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.entries);",
          "        }",
          "    }",
          "",
          "    let mut map = TestEntries { entries: vec![] };",
          "    let index = hashbrown::hash_table::OccupiedEntry::new(&mut map.entries, 0);",
          "    let entry = OccupiedEntry::new(&mut map, index);",
          "    entry.remove_entry();",
          "    assert_eq!(entry.as_entries().len(), 0);",
          "    assert!(map.entries.is_empty());",
          "    let result = entry.key();",
          "    assert!(result.is_none());",
          "    let (key, value) = entry.remove_entry();",
          "    assert_eq!(key, expected_key);",
          "    assert_eq!(value, expected_value);",
          "    assert!(!map.entries.contains(&(expected_key, expected_value)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]