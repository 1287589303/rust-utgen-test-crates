[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input = vec![(1, 10)];",
          "    map.extend(input);",
          "}"
        ],
        "oracle": [
          "    map.len() == 1",
          "    map.is_empty() == false",
          "    map.keys().collect::<Vec<_>>() == vec![1]",
          "    map.values().collect::<Vec<_>>() == vec![10]"
        ],
        "code": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input = vec![(1, 10)];",
          "    map.extend(input);",
          "    map.len() == 1",
          "    map.is_empty() == false",
          "    map.keys().collect::<Vec<_>>() == vec![1]",
          "    map.values().collect::<Vec<_>>() == vec![10]",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input = vec![(1, 10), (2, 20), (3, 30)];",
          "    map.extend(input);",
          "}"
        ],
        "oracle": [
          "    assert!(map.len() == 3);",
          "    assert!(map.get(&1) == Some(&10));",
          "    assert!(map.get(&2) == Some(&20));",
          "    assert!(map.get(&3) == Some(&30));",
          "    assert!(map.is_empty() == false);",
          "    assert!(map.capacity() >= 3);"
        ],
        "code": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input = vec![(1, 10), (2, 20), (3, 30)];",
          "    map.extend(input);",
          "    assert!(map.len() == 3);",
          "    assert!(map.get(&1) == Some(&10));",
          "    assert!(map.get(&2) == Some(&20));",
          "    assert!(map.get(&3) == Some(&30));",
          "    assert!(map.is_empty() == false);",
          "    assert!(map.capacity() >= 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input = vec![(1, 10), (1, 15), (2, 20)];",
          "    map.extend(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.len(), 2);",
          "    assert_eq!(map.get(&1), Some(&15));",
          "    assert_eq!(map.get(&2), Some(&20));",
          "    assert!(map.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input = vec![(1, 10), (1, 15), (2, 20)];",
          "    map.extend(input);",
          "    assert_eq!(map.len(), 2);",
          "    assert_eq!(map.get(&1), Some(&15));",
          "    assert_eq!(map.get(&2), Some(&20));",
          "    assert!(map.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input: Vec<(i32, i32)> = vec![];",
          "    map.extend(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.len(), 0);",
          "    assert!(map.is_empty());",
          "    assert_eq!(map.capacity(), 0);",
          "    assert_eq!(map.iter().count(), 0);",
          "    assert_eq!(map.keys().count(), 0);",
          "    assert_eq!(map.values().count(), 0);"
        ],
        "code": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input: Vec<(i32, i32)> = vec![];",
          "    map.extend(input);",
          "    assert_eq!(map.len(), 0);",
          "    assert!(map.is_empty());",
          "    assert_eq!(map.capacity(), 0);",
          "    assert_eq!(map.iter().count(), 0);",
          "    assert_eq!(map.keys().count(), 0);",
          "    assert_eq!(map.values().count(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input: Vec<(i32, i32)> = (1..1000).map(|i| (i, i * 10)).collect();",
          "    map.extend(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.len(), 999);",
          "    assert_eq!(map.capacity(), 500);",
          "    assert_eq!(map.get(&1), Some(&10));",
          "    assert_eq!(map.get(&500), Some(&5000));",
          "    assert_eq!(map.get(&999), Some(&9990));",
          "    assert!(map.keys().eq(1..1000));",
          "    assert!(map.values().eq((10..9900).step_by(10)));",
          "    assert!(map.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(RandomState::new());",
          "    let input: Vec<(i32, i32)> = (1..1000).map(|i| (i, i * 10)).collect();",
          "    map.extend(input);",
          "    assert_eq!(map.len(), 999);",
          "    assert_eq!(map.capacity(), 500);",
          "    assert_eq!(map.get(&1), Some(&10));",
          "    assert_eq!(map.get(&500), Some(&5000));",
          "    assert_eq!(map.get(&999), Some(&9990));",
          "    assert!(map.keys().eq(1..1000));",
          "    assert!(map.values().eq((10..9900).step_by(10)));",
          "    assert!(map.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]