[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([42]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(&42));",
          "    assert!(!set.contains(&100));",
          "    assert_eq!(set, IndexSet::from([42]));"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([42]);",
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(&42));",
          "    assert!(!set.contains(&100));",
          "    assert_eq!(set, IndexSet::from([42]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([1, 2, 3, 4]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 4);",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(set.contains(&3));",
          "    assert!(set.contains(&4));",
          "    assert!(!set.contains(&5));",
          "    assert!(set.is_empty() == false);",
          "    let set2: IndexSet<_> = [1, 2, 3, 4].into();",
          "    assert_eq!(set, set2);",
          "    assert_eq!(set, IndexSet::from([1, 2, 3, 4]));",
          "    let set3: IndexSet<i32> = IndexSet::from([]);",
          "    assert_eq!(set3.len(), 0);",
          "    assert!(set3.is_empty());"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([1, 2, 3, 4]);",
          "    assert_eq!(set.len(), 4);",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(set.contains(&3));",
          "    assert!(set.contains(&4));",
          "    assert!(!set.contains(&5));",
          "    assert!(set.is_empty() == false);",
          "    let set2: IndexSet<_> = [1, 2, 3, 4].into();",
          "    assert_eq!(set, set2);",
          "    assert_eq!(set, IndexSet::from([1, 2, 3, 4]));",
          "    let set3: IndexSet<i32> = IndexSet::from([]);",
          "    assert_eq!(set3.len(), 0);",
          "    assert!(set3.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([1, 1, 2, 2]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 2);",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(!set.contains(&3));",
          "    assert_eq!(set.into_iter().collect::<Vec<_>>(), vec![1, 2]);"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([1, 1, 2, 2]);",
          "    assert_eq!(set.len(), 2);",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(!set.contains(&3));",
          "    assert_eq!(set.into_iter().collect::<Vec<_>>(), vec![1, 2]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.is_empty(), true);",
          "    assert_eq!(set.len(), 0);",
          "    assert_eq!(set.iter().count(), 0);",
          "    assert_eq!(set.contains(&1), false);",
          "    assert_eq!(set.contains(&2), false);",
          "    assert_eq!(set.into_iter().next(), None);",
          "    assert_eq!(set.clone().into_iter().next(), None);",
          "    assert_eq!(set.iter().collect::<Vec<_>>(), vec![]);"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([]);",
          "    assert_eq!(set.is_empty(), true);",
          "    assert_eq!(set.len(), 0);",
          "    assert_eq!(set.iter().count(), 0);",
          "    assert_eq!(set.contains(&1), false);",
          "    assert_eq!(set.contains(&2), false);",
          "    assert_eq!(set.into_iter().next(), None);",
          "    assert_eq!(set.clone().into_iter().next(), None);",
          "    assert_eq!(set.iter().collect::<Vec<_>>(), vec![]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([-1, -2, -3, -4]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 4);",
          "    assert!(set.contains(&-1));",
          "    assert!(set.contains(&-2));",
          "    assert!(set.contains(&-3));",
          "    assert!(set.contains(&-4));",
          "    assert!(!set.contains(&0));",
          "    assert!(!set.contains(&1));"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([-1, -2, -3, -4]);",
          "    assert_eq!(set.len(), 4);",
          "    assert!(set.contains(&-1));",
          "    assert!(set.contains(&-2));",
          "    assert!(set.contains(&-3));",
          "    assert!(set.contains(&-4));",
          "    assert!(!set.contains(&0));",
          "    assert!(!set.contains(&1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([-1, 0, 1, 2]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 4);",
          "    assert!(set.contains(&-1));",
          "    assert!(set.contains(&0));",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(!set.contains(&3));",
          "    assert_eq!(set.iter().count(), 4);",
          "    assert_eq!(set.into_iter().collect::<Vec<_>>(), vec![-1, 0, 1, 2]);",
          "    assert!(set.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([-1, 0, 1, 2]);",
          "    assert_eq!(set.len(), 4);",
          "    assert!(set.contains(&-1));",
          "    assert!(set.contains(&0));",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(!set.contains(&3));",
          "    assert_eq!(set.iter().count(), 4);",
          "    assert_eq!(set.into_iter().collect::<Vec<_>>(), vec![-1, 0, 1, 2]);",
          "    assert!(set.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([i32::MAX]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(&i32::MAX));",
          "    assert!(!set.contains(&(i32::MAX - 1)));",
          "    assert!(!set.contains(&(i32::MIN)));",
          "    assert_eq!(set.iter().count(), 1);",
          "    assert_eq!(set.iter().next(), Some(&i32::MAX));"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([i32::MAX]);",
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(&i32::MAX));",
          "    assert!(!set.contains(&(i32::MAX - 1)));",
          "    assert!(!set.contains(&(i32::MIN)));",
          "    assert_eq!(set.iter().count(), 1);",
          "    assert_eq!(set.iter().next(), Some(&i32::MAX));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([i32::MIN]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.is_empty(), false);",
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(&i32::MIN));",
          "    assert_eq!(set.iter().next(), Some(&i32::MIN));"
        ],
        "code": [
          "{",
          "    let set: IndexSet<i32> = IndexSet::from([i32::MIN]);",
          "    assert_eq!(set.is_empty(), false);",
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(&i32::MIN));",
          "    assert_eq!(set.iter().next(), Some(&i32::MIN));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]