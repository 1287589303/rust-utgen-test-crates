[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<i32>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<i32>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&i32> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![42]);",
          "    let _ = set.last();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.last(), Some(&42));",
          "    let empty_set = TestIndexSet::new(vec![]);",
          "    assert_eq!(empty_set.last(), None);",
          "    let multiple_set = TestIndexSet::new(vec![1, 2, 3, 4, 5]);",
          "    assert_eq!(multiple_set.last(), Some(&5));",
          "    let negative_set = TestIndexSet::new(vec![-1, -2, -3]);",
          "    assert_eq!(negative_set.last(), Some(&-3));",
          "    let single_element_set = TestIndexSet::new(vec![100]);",
          "    assert_eq!(single_element_set.last(), Some(&100));"
        ],
        "code": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<i32>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<i32>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&i32> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![42]);",
          "    let _ = set.last();",
          "    assert_eq!(set.last(), Some(&42));",
          "    let empty_set = TestIndexSet::new(vec![]);",
          "    assert_eq!(empty_set.last(), None);",
          "    let multiple_set = TestIndexSet::new(vec![1, 2, 3, 4, 5]);",
          "    assert_eq!(multiple_set.last(), Some(&5));",
          "    let negative_set = TestIndexSet::new(vec![-1, -2, -3]);",
          "    assert_eq!(negative_set.last(), Some(&-3));",
          "    let single_element_set = TestIndexSet::new(vec![100]);",
          "    assert_eq!(single_element_set.last(), Some(&100));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<i32>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<i32>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&i32> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![1, 2, 3, 4, 5]);",
          "    let _ = set.last();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.last(), Some(&5));",
          "    let empty_set = TestIndexSet::new(vec![]);",
          "    assert_eq!(empty_set.last(), None);",
          "    let single_element_set = TestIndexSet::new(vec![42]);",
          "    assert_eq!(single_element_set.last(), Some(&42));",
          "    let negative_numbers_set = TestIndexSet::new(vec![-1, -2, -3]);",
          "    assert_eq!(negative_numbers_set.last(), Some(&-3));",
          "    let duplicate_numbers_set = TestIndexSet::new(vec![1, 1, 1]);",
          "    assert_eq!(duplicate_numbers_set.last(), Some(&1));"
        ],
        "code": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<i32>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<i32>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&i32> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![1, 2, 3, 4, 5]);",
          "    let _ = set.last();",
          "    assert_eq!(set.last(), Some(&5));",
          "    let empty_set = TestIndexSet::new(vec![]);",
          "    assert_eq!(empty_set.last(), None);",
          "    let single_element_set = TestIndexSet::new(vec![42]);",
          "    assert_eq!(single_element_set.last(), Some(&42));",
          "    let negative_numbers_set = TestIndexSet::new(vec![-1, -2, -3]);",
          "    assert_eq!(negative_numbers_set.last(), Some(&-3));",
          "    let duplicate_numbers_set = TestIndexSet::new(vec![1, 1, 1]);",
          "    assert_eq!(duplicate_numbers_set.last(), Some(&1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<i32>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<i32>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&i32> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![]);",
          "    let _ = set.last();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.last(), None);",
          "    let set = TestIndexSet::new(vec![1]);",
          "    assert_eq!(set.last(), Some(&1));",
          "    let set = TestIndexSet::new(vec![1, 2, 3]);",
          "    assert_eq!(set.last(), Some(&3));",
          "    let set = TestIndexSet::new(vec![-1, 0, 1]);",
          "    assert_eq!(set.last(), Some(&1));",
          "    let set = TestIndexSet::new(vec![10, 20, 30, 40]);",
          "    assert_eq!(set.last(), Some(&40));"
        ],
        "code": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<i32>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<i32>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&i32> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![]);",
          "    let _ = set.last();",
          "    assert_eq!(set.last(), None);",
          "    let set = TestIndexSet::new(vec![1]);",
          "    assert_eq!(set.last(), Some(&1));",
          "    let set = TestIndexSet::new(vec![1, 2, 3]);",
          "    assert_eq!(set.last(), Some(&3));",
          "    let set = TestIndexSet::new(vec![-1, 0, 1]);",
          "    assert_eq!(set.last(), Some(&1));",
          "    let set = TestIndexSet::new(vec![10, 20, 30, 40]);",
          "    assert_eq!(set.last(), Some(&40));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<String>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<String>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&String> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![\"first\".to_string(), \"second\".to_string(), \"third\".to_string()]);",
          "    let _ = set.last();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.last(), Some(&\"third\".to_string()));",
          "    set = TestIndexSet::new(vec![]);",
          "    assert_eq!(set.last(), None);",
          "    set = TestIndexSet::new(vec![\"only\".to_string()]);",
          "    assert_eq!(set.last(), Some(&\"only\".to_string()));"
        ],
        "code": [
          "{",
          "    struct TestIndexSet {",
          "        items: Vec<String>,",
          "    }",
          "    ",
          "    impl TestIndexSet {",
          "        fn new(items: Vec<String>) -> Self {",
          "            TestIndexSet { items }",
          "        }",
          "",
          "        fn last(&self) -> Option<&String> {",
          "            self.items.last()",
          "        }",
          "    }",
          "",
          "    let set = TestIndexSet::new(vec![\"first\".to_string(), \"second\".to_string(), \"third\".to_string()]);",
          "    let _ = set.last();",
          "    assert_eq!(set.last(), Some(&\"third\".to_string()));",
          "    set = TestIndexSet::new(vec![]);",
          "    assert_eq!(set.last(), None);",
          "    set = TestIndexSet::new(vec![\"only\".to_string()]);",
          "    assert_eq!(set.last(), Some(&\"only\".to_string()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]