[
  {
    "uses": [
      "use std::collections::hash_map::RandomState;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    set1.insert(3);",
          "    ",
          "    set2.insert(4);",
          "    set2.insert(5);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter().count(), 5);",
          "    assert!(result.iter().any(|&x| x == 1);",
          "    assert!(result.iter().any(|&x| x == 2);",
          "    assert!(result.iter().any(|&x| x == 3);",
          "    assert!(result.iter().any(|&x| x == 4);",
          "    assert!(result.iter().any(|&x| x == 5);",
          "    assert!(!result.iter().any(|&x| x == 1 && set2.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 2 && set2.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 3 && set2.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 4 && set1.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 5 && set1.contains(&x)));"
        ],
        "code": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    set1.insert(3);",
          "    ",
          "    set2.insert(4);",
          "    set2.insert(5);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().count(), 5);",
          "    assert!(result.iter().any(|&x| x == 1);",
          "    assert!(result.iter().any(|&x| x == 2);",
          "    assert!(result.iter().any(|&x| x == 3);",
          "    assert!(result.iter().any(|&x| x == 4);",
          "    assert!(result.iter().any(|&x| x == 5);",
          "    assert!(!result.iter().any(|&x| x == 1 && set2.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 2 && set2.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 3 && set2.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 4 && set1.contains(&x)));",
          "    assert!(!result.iter().any(|&x| x == 5 && set1.contains(&x)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    ",
          "    set2.insert(2);",
          "    set2.insert(3);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.collect::<Vec<_>>(), vec![1, 3]);"
        ],
        "code": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    ",
          "    set2.insert(2);",
          "    set2.insert(3);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.collect::<Vec<_>>(), vec![1, 3]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    set1.insert(3);",
          "    ",
          "    set2.insert(1);",
          "    set2.insert(2);",
          "    set2.insert(3);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![]);",
          "    set2.insert(4);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![4]);",
          "    set1.insert(5);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![5]);",
          "    set1.insert(6);",
          "    set2.insert(7);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![5, 6, 7]);",
          "    set1.insert(2);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![5, 6, 7]);",
          "    set1.clear();",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![4, 7]);",
          "    set2.clear();",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![]);"
        ],
        "code": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    set1.insert(3);",
          "    ",
          "    set2.insert(1);",
          "    set2.insert(2);",
          "    set2.insert(3);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![]);",
          "    set2.insert(4);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![4]);",
          "    set1.insert(5);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![5]);",
          "    set1.insert(6);",
          "    set2.insert(7);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![5, 6, 7]);",
          "    set1.insert(2);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![5, 6, 7]);",
          "    set1.clear();",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![4, 7]);",
          "    set2.clear();",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().collect::<Vec<_>>(), vec![]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter().count(), 2);",
          "    assert!(result.iter().any(|&x| x == 1));",
          "    assert!(result.iter().any(|&x| x == 2));",
          "    assert!(!result.iter().any(|&x| x == 0));",
          "    let mut set3 = IndexSet::<i32, RandomState>::default();",
          "    set3.insert(2);",
          "    let result2 = set1.symmetric_difference(&set3);",
          "    assert_eq!(result2.iter().count(), 2);",
          "    assert!(result2.iter().any(|&x| x == 1));",
          "    assert!(result2.iter().any(|&x| x == 2));",
          "    let mut set4 = IndexSet::<i32, RandomState>::default();",
          "    set4.insert(3);",
          "    let result3 = set1.symmetric_difference(&set4);",
          "    assert_eq!(result3.iter().count(), 3);",
          "    assert!(result3.iter().any(|&x| x == 1));",
          "    assert!(result3.iter().any(|&x| x == 2));",
          "    assert!(result3.iter().any(|&x| x == 3));"
        ],
        "code": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    set1.insert(1);",
          "    set1.insert(2);",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter().count(), 2);",
          "    assert!(result.iter().any(|&x| x == 1));",
          "    assert!(result.iter().any(|&x| x == 2));",
          "    assert!(!result.iter().any(|&x| x == 0));",
          "    let mut set3 = IndexSet::<i32, RandomState>::default();",
          "    set3.insert(2);",
          "    let result2 = set1.symmetric_difference(&set3);",
          "    assert_eq!(result2.iter().count(), 2);",
          "    assert!(result2.iter().any(|&x| x == 1));",
          "    assert!(result2.iter().any(|&x| x == 2));",
          "    let mut set4 = IndexSet::<i32, RandomState>::default();",
          "    set4.insert(3);",
          "    let result3 = set1.symmetric_difference(&set4);",
          "    assert_eq!(result3.iter().count(), 3);",
          "    assert!(result3.iter().any(|&x| x == 1));",
          "    assert!(result3.iter().any(|&x| x == 2));",
          "    assert!(result3.iter().any(|&x| x == 3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::default();",
          "    let set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.iter.len(), 0);",
          "    assert!(result.iter().next().is_none());",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![1, 2, 3]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![3, 4, 5]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    let expected_values: Vec<i32> = vec![1, 2, 4, 5];",
          "    assert_eq!(result.iter.collect::<Vec<_>>(), expected_values);",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![1, 2, 3]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![1, 2, 3]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter.len(), 0);",
          "    assert!(result.iter().next().is_none());",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![4, 5]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter.collect::<Vec<_>>(), vec![4, 5]);",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![1, 2]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![2, 3]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter.collect::<Vec<_>>(), vec![1, 3]);"
        ],
        "code": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::default();",
          "    let set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter.len(), 0);",
          "    assert!(result.iter().next().is_none());",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![1, 2, 3]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![3, 4, 5]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    let expected_values: Vec<i32> = vec![1, 2, 4, 5];",
          "    assert_eq!(result.iter.collect::<Vec<_>>(), expected_values);",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![1, 2, 3]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![1, 2, 3]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter.len(), 0);",
          "    assert!(result.iter().next().is_none());",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![4, 5]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter.collect::<Vec<_>>(), vec![4, 5]);",
          "    ",
          "    let set1 = IndexSet::<i32, RandomState>::from(vec![1, 2]);",
          "    let set2 = IndexSet::<i32, RandomState>::from(vec![2, 3]);",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.iter.collect::<Vec<_>>(), vec![1, 3]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    for i in 0..1000 {",
          "        set1.insert(i);",
          "    }",
          "    ",
          "    for i in 500..1500 {",
          "        set2.insert(i);",
          "    }",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.into_iter().collect::<Vec<_>>(), vec![0, 1, 2, ..., 499, 1000, 1001, ..., 1499]);",
          "    assert!(result.into_iter().all(|x| set1.contains(&x) ^ set2.contains(&x)));",
          "    assert!(result.into_iter().count() == 1000);",
          "    assert!(result.into_iter().filter(|&x| x < 500).count() == 500);",
          "    assert!(result.into_iter().filter(|&x| x >= 1000).count() == 500);",
          "    assert!(set2.symmetric_difference(&set1).into_iter().collect::<Vec<_>>() == result.into_iter().collect::<Vec<_>>());",
          "    assert!(set1.symmetric_difference(&set1).into_iter().is_empty());",
          "    assert!(set2.symmetric_difference(&set2).into_iter().is_empty());",
          "    assert!(set1.symmetric_difference(&IndexSet::<i32, RandomState>::default()).into_iter().collect::<Vec<_>>() == set1.into_iter().collect::<Vec<_>>());",
          "    assert!(set2.symmetric_difference(&IndexSet::<i32, RandomState>::default()).into_iter().collect::<Vec<_>>() == set2.into_iter().collect::<Vec<_>>());"
        ],
        "code": [
          "{",
          "    use std::collections::hash_map::RandomState;",
          "    ",
          "    let mut set1 = IndexSet::<i32, RandomState>::default();",
          "    let mut set2 = IndexSet::<i32, RandomState>::default();",
          "    ",
          "    for i in 0..1000 {",
          "        set1.insert(i);",
          "    }",
          "    ",
          "    for i in 500..1500 {",
          "        set2.insert(i);",
          "    }",
          "    ",
          "    let result = set1.symmetric_difference(&set2);",
          "    assert_eq!(result.into_iter().collect::<Vec<_>>(), vec![0, 1, 2, ..., 499, 1000, 1001, ..., 1499]);",
          "    assert!(result.into_iter().all(|x| set1.contains(&x) ^ set2.contains(&x)));",
          "    assert!(result.into_iter().count() == 1000);",
          "    assert!(result.into_iter().filter(|&x| x < 500).count() == 500);",
          "    assert!(result.into_iter().filter(|&x| x >= 1000).count() == 500);",
          "    assert!(set2.symmetric_difference(&set1).into_iter().collect::<Vec<_>>() == result.into_iter().collect::<Vec<_>>());",
          "    assert!(set1.symmetric_difference(&set1).into_iter().is_empty());",
          "    assert!(set2.symmetric_difference(&set2).into_iter().is_empty());",
          "    assert!(set1.symmetric_difference(&IndexSet::<i32, RandomState>::default()).into_iter().collect::<Vec<_>>() == set1.into_iter().collect::<Vec<_>>());",
          "    assert!(set2.symmetric_difference(&IndexSet::<i32, RandomState>::default()).into_iter().collect::<Vec<_>>() == set2.into_iter().collect::<Vec<_>>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]