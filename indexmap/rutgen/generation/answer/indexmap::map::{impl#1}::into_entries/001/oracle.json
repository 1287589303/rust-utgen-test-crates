[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::new(),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entries.len(), 0);",
          "    assert!(entries.is_empty());",
          "    assert!(entries.capacity() >= 0);"
        ],
        "code": [
          "{",
          "    let map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::new(),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "    assert_eq!(entries.len(), 0);",
          "    assert!(entries.is_empty());",
          "    assert!(entries.capacity() >= 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::from(vec![super::Bucket {",
          "                hash: super::HashValue::new(1),",
          "                key: 1,",
          "                value: 100,",
          "            }]),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entries.len(), 1);",
          "    assert_eq!(entries[0].hash, super::HashValue::new(1));",
          "    assert_eq!(entries[0].key, 1);",
          "    assert_eq!(entries[0].value, 100);"
        ],
        "code": [
          "{",
          "    let mut map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::from(vec![super::Bucket {",
          "                hash: super::HashValue::new(1),",
          "                key: 1,",
          "                value: 100,",
          "            }]),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "    assert_eq!(entries.len(), 1);",
          "    assert_eq!(entries[0].hash, super::HashValue::new(1));",
          "    assert_eq!(entries[0].key, 1);",
          "    assert_eq!(entries[0].value, 100);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let entries_vec = vec![",
          "        super::Bucket {",
          "            hash: super::HashValue::new(1),",
          "            key: 1,",
          "            value: 100,",
          "        },",
          "        super::Bucket {",
          "            hash: super::HashValue::new(2),",
          "            key: 2,",
          "            value: 200,",
          "        },",
          "        super::Bucket {",
          "            hash: super::HashValue::new(3),",
          "            key: 3,",
          "            value: 300,",
          "        },",
          "    ];",
          "    ",
          "    let mut map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::from(entries_vec),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "}"
        ],
        "oracle": [
          "    let expected_entries = vec![",
          "    super::Bucket {",
          "    hash: super::HashValue::new(1),",
          "    key: 1,",
          "    value: 100,",
          "    },",
          "    super::Bucket {",
          "    hash: super::HashValue::new(2),",
          "    key: 2,",
          "    value: 200,",
          "    },",
          "    super::Bucket {",
          "    hash: super::HashValue::new(3),",
          "    key: 3,",
          "    value: 300,",
          "    },",
          "    ];",
          "    assert_eq!(entries, expected_entries);"
        ],
        "code": [
          "{",
          "    let entries_vec = vec![",
          "        super::Bucket {",
          "            hash: super::HashValue::new(1),",
          "            key: 1,",
          "            value: 100,",
          "        },",
          "        super::Bucket {",
          "            hash: super::HashValue::new(2),",
          "            key: 2,",
          "            value: 200,",
          "        },",
          "        super::Bucket {",
          "            hash: super::HashValue::new(3),",
          "            key: 3,",
          "            value: 300,",
          "        },",
          "    ];",
          "    ",
          "    let mut map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::from(entries_vec),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "    let expected_entries = vec![",
          "    super::Bucket {",
          "    hash: super::HashValue::new(1),",
          "    key: 1,",
          "    value: 100,",
          "    },",
          "    super::Bucket {",
          "    hash: super::HashValue::new(2),",
          "    key: 2,",
          "    value: 200,",
          "    },",
          "    super::Bucket {",
          "    hash: super::HashValue::new(3),",
          "    key: 3,",
          "    value: 300,",
          "    },",
          "    ];",
          "    assert_eq!(entries, expected_entries);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let entries_vec = vec![",
          "        super::Bucket {",
          "            hash: super::HashValue::new(1),",
          "            key: 1,",
          "            value: 100,",
          "        },",
          "        super::Bucket {",
          "            hash: super::HashValue::new(1),",
          "            key: 1,",
          "            value: 200,",
          "        },",
          "    ];",
          "",
          "    let mut map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::from(entries_vec),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entries.len(), 2);",
          "    assert_eq!(entries[0].key, 1);",
          "    assert_eq!(entries[0].value, 100);",
          "    assert_eq!(entries[1].key, 1);",
          "    assert_eq!(entries[1].value, 200);",
          "    assert_eq!(entries[0].hash, super::HashValue::new(1));",
          "    assert_eq!(entries[1].hash, super::HashValue::new(1));"
        ],
        "code": [
          "{",
          "    let entries_vec = vec![",
          "        super::Bucket {",
          "            hash: super::HashValue::new(1),",
          "            key: 1,",
          "            value: 100,",
          "        },",
          "        super::Bucket {",
          "            hash: super::HashValue::new(1),",
          "            key: 1,",
          "            value: 200,",
          "        },",
          "    ];",
          "",
          "    let mut map: super::IndexMap<i32, i32, std::collections::hash_map::RandomState> = super::IndexMap {",
          "        core: super::IndexMapCore {",
          "            indices: super::Indices::new(),",
          "            entries: super::Entries::from(entries_vec),",
          "        },",
          "        hash_builder: std::collections::hash_map::RandomState::new(),",
          "    };",
          "    let entries = map.into_entries();",
          "    assert_eq!(entries.len(), 2);",
          "    assert_eq!(entries[0].key, 1);",
          "    assert_eq!(entries[0].value, 100);",
          "    assert_eq!(entries[1].key, 1);",
          "    assert_eq!(entries[1].value, 200);",
          "    assert_eq!(entries[0].hash, super::HashValue::new(1));",
          "    assert_eq!(entries[1].hash, super::HashValue::new(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]