[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    struct TestEntries<K, V> {",
          "        data: Vec<(K, V)>,",
          "    }",
          "",
          "    impl<K, V> TestEntries<K, V> {",
          "        fn new() -> Self {",
          "            Self { data: Vec::new() }",
          "        }",
          "        fn push(&mut self, key: K, value: V) {",
          "            self.data.push((key, value));",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries::<TestKey, TestValue>::new();",
          "    entries.push(TestKey, TestValue);",
          "    ",
          "    let index_value = 0; ",
          "    let mut occupied_entry = OccupiedEntry::new(&mut entries, hash_table::OccupiedEntry::new(index_value));",
          "",
          "    let entry = Entry::Occupied(occupied_entry);",
          "    let key_mut_ref = entry.key_mut();",
          "}"
        ],
        "oracle": [
          "    key_mut_ref.assert_is_mutable();",
          "    entry.assert_is_occupied();",
          "    entry.assert_matches_entry_type(Entry::Occupied);",
          "    occupied_entry.assert_key_mut_return_type::<TestKey>();",
          "    occupied_entry.assert_key_mut_behaviour();",
          "    occupied_entry.assert_key_mut_is_same(&key_mut_ref);",
          "    occupied_entry.assert_key_mut_index(index_value);",
          "    entries.assert_contains_key_value(TestKey, TestValue);",
          "    entries.assert_mutable_state();"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    struct TestEntries<K, V> {",
          "        data: Vec<(K, V)>,",
          "    }",
          "",
          "    impl<K, V> TestEntries<K, V> {",
          "        fn new() -> Self {",
          "            Self { data: Vec::new() }",
          "        }",
          "        fn push(&mut self, key: K, value: V) {",
          "            self.data.push((key, value));",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries::<TestKey, TestValue>::new();",
          "    entries.push(TestKey, TestValue);",
          "    ",
          "    let index_value = 0; ",
          "    let mut occupied_entry = OccupiedEntry::new(&mut entries, hash_table::OccupiedEntry::new(index_value));",
          "",
          "    let entry = Entry::Occupied(occupied_entry);",
          "    let key_mut_ref = entry.key_mut();",
          "    key_mut_ref.assert_is_mutable();",
          "    entry.assert_is_occupied();",
          "    entry.assert_matches_entry_type(Entry::Occupied);",
          "    occupied_entry.assert_key_mut_return_type::<TestKey>();",
          "    occupied_entry.assert_key_mut_behaviour();",
          "    occupied_entry.assert_key_mut_is_same(&key_mut_ref);",
          "    occupied_entry.assert_key_mut_index(index_value);",
          "    entries.assert_contains_key_value(TestKey, TestValue);",
          "    entries.assert_mutable_state();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    struct TestEntries<K, V> {",
          "        data: Vec<(K, V)>,",
          "    }",
          "",
          "    impl<K, V> TestEntries<K, V> {",
          "        fn new() -> Self {",
          "            Self { data: Vec::new() }",
          "        }",
          "        fn push(&mut self, key: K, value: V) {",
          "            self.data.push((key, value));",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries::<TestKey, TestValue>::new();",
          "    let vacant_entry = VacantEntry::new(&mut entries, HashValue::default(), TestKey);",
          "    ",
          "    let entry = Entry::Vacant(vacant_entry);",
          "    let key_mut_ref = entry.key_mut();",
          "}"
        ],
        "oracle": [
          "    let mut occupied_entry = OccupiedEntry::new(&mut entries, hash_table::OccupiedEntry::default());",
          "    let entry = Entry::Occupied(occupied_entry);",
          "    let key_mut_ref = entry.key_mut();",
          "    assert!(key_mut_ref.is::<TestKey>());",
          "    assert!(key_mut_ref as *mut _ == occupied_entry.key_mut() as *mut _);"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    struct TestEntries<K, V> {",
          "        data: Vec<(K, V)>,",
          "    }",
          "",
          "    impl<K, V> TestEntries<K, V> {",
          "        fn new() -> Self {",
          "            Self { data: Vec::new() }",
          "        }",
          "        fn push(&mut self, key: K, value: V) {",
          "            self.data.push((key, value));",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries::<TestKey, TestValue>::new();",
          "    let vacant_entry = VacantEntry::new(&mut entries, HashValue::default(), TestKey);",
          "    ",
          "    let entry = Entry::Vacant(vacant_entry);",
          "    let key_mut_ref = entry.key_mut();",
          "    let mut occupied_entry = OccupiedEntry::new(&mut entries, hash_table::OccupiedEntry::default());",
          "    let entry = Entry::Occupied(occupied_entry);",
          "    let key_mut_ref = entry.key_mut();",
          "    assert!(key_mut_ref.is::<TestKey>());",
          "    assert!(key_mut_ref as *mut _ == occupied_entry.key_mut() as *mut _);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]