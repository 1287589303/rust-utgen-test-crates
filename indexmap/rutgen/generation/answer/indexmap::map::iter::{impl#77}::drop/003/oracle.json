[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHasher;",
          "",
          "    impl BuildHasher for TestHasher {",
          "        type Hasher = std::collections::hash_map::DefaultHasher;",
          "",
          "        fn build_hasher(&self) -> Self::Hasher {",
          "            std::collections::hash_map::DefaultHasher::new()",
          "        }",
          "    }",
          "",
          "    let mut map = IndexMap::<u32, String, TestHasher> {",
          "        core: IndexMapCore::new(),",
          "        hash_builder: TestHasher,",
          "    };",
          "",
          "    let tail = {",
          "        let mut core = IndexMapCore::with_capacity(2);",
          "        core.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value\".to_string() });",
          "        core.indices = Indices::new();",
          "        core",
          "    };",
          "",
          "    let replace_with_vec = vec![(1, \"new_value\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "",
          "    let mut splice = Splice {",
          "        map: &mut map,",
          "        tail,",
          "        drain: vec![].into_iter(),",
          "        replace_with,",
          "    };",
          "",
          "    splice.drop();",
          "}"
        ],
        "oracle": [
          "    let mut map = IndexMap::<u32, String, TestHasher> { core: IndexMapCore::new(), hash_builder: TestHasher };",
          "    let tail = IndexMapCore::with_capacity(2);",
          "    tail.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value\".to_string() });",
          "    let replace_with_vec = vec![(1, \"new_value\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "    let mut splice = Splice { map: &mut map, tail, drain: vec![].into_iter(), replace_with };",
          "    splice.drop();",
          "    assert_eq!(map.core.entries.len(), 1);",
          "    assert_eq!(map.core.entries[0].value, \"new_value\");",
          "    assert_eq!(tail.entries.len(), 0);"
        ],
        "code": [
          "{",
          "    struct TestHasher;",
          "",
          "    impl BuildHasher for TestHasher {",
          "        type Hasher = std::collections::hash_map::DefaultHasher;",
          "",
          "        fn build_hasher(&self) -> Self::Hasher {",
          "            std::collections::hash_map::DefaultHasher::new()",
          "        }",
          "    }",
          "",
          "    let mut map = IndexMap::<u32, String, TestHasher> {",
          "        core: IndexMapCore::new(),",
          "        hash_builder: TestHasher,",
          "    };",
          "",
          "    let tail = {",
          "        let mut core = IndexMapCore::with_capacity(2);",
          "        core.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value\".to_string() });",
          "        core.indices = Indices::new();",
          "        core",
          "    };",
          "",
          "    let replace_with_vec = vec![(1, \"new_value\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "",
          "    let mut splice = Splice {",
          "        map: &mut map,",
          "        tail,",
          "        drain: vec![].into_iter(),",
          "        replace_with,",
          "    };",
          "",
          "    splice.drop();",
          "    let mut map = IndexMap::<u32, String, TestHasher> { core: IndexMapCore::new(), hash_builder: TestHasher };",
          "    let tail = IndexMapCore::with_capacity(2);",
          "    tail.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value\".to_string() });",
          "    let replace_with_vec = vec![(1, \"new_value\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "    let mut splice = Splice { map: &mut map, tail, drain: vec![].into_iter(), replace_with };",
          "    splice.drop();",
          "    assert_eq!(map.core.entries.len(), 1);",
          "    assert_eq!(map.core.entries[0].value, \"new_value\");",
          "    assert_eq!(tail.entries.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHasher;",
          "",
          "    impl BuildHasher for TestHasher {",
          "        type Hasher = std::collections::hash_map::DefaultHasher;",
          "",
          "        fn build_hasher(&self) -> Self::Hasher {",
          "            std::collections::hash_map::DefaultHasher::new()",
          "        }",
          "    }",
          "",
          "    let mut map = IndexMap::<u32, String, TestHasher> {",
          "        core: IndexMapCore::new(),",
          "        hash_builder: TestHasher,",
          "    };",
          "",
          "    let tail = {",
          "        let mut core = IndexMapCore::with_capacity(2);",
          "        core.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value_1\".to_string() });",
          "        core.entries.push(Bucket { hash: HashValue(2), key: 2, value: \"old_value_2\".to_string() });",
          "        core.indices = Indices::new();",
          "        core",
          "    };",
          "",
          "    let replace_with_vec = vec![(1, \"new_value_1\".to_string()), (2, \"new_value_2\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "",
          "    let mut splice = Splice {",
          "        map: &mut map,",
          "        tail,",
          "        drain: vec![].into_iter(),",
          "        replace_with,",
          "    };",
          "",
          "    splice.drop();",
          "}"
        ],
        "oracle": [
          "    let mut map = IndexMap::<u32, String, TestHasher> { core: IndexMapCore::new(), hash_builder: TestHasher };",
          "    let tail = { let mut core = IndexMapCore::with_capacity(2); core.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value_1\".to_string() }); core.entries.push(Bucket { hash: HashValue(2), key: 2, value: \"old_value_2\".to_string() }); core.indices = Indices::new(); core };",
          "    let replace_with_vec = vec![(1, \"new_value_1\".to_string()), (2, \"new_value_2\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "    let mut splice = Splice { map: &mut map, tail, drain: vec![].into_iter(), replace_with };",
          "    splice.drop();",
          "    assert_eq!(map.core.entries.len(), 2);",
          "    assert_eq!(map.core.entries[0].value, \"new_value_1\");",
          "    assert_eq!(map.core.entries[1].value, \"new_value_2\");",
          "    assert_eq!(splice.tail.entries.len(), 0);"
        ],
        "code": [
          "{",
          "    struct TestHasher;",
          "",
          "    impl BuildHasher for TestHasher {",
          "        type Hasher = std::collections::hash_map::DefaultHasher;",
          "",
          "        fn build_hasher(&self) -> Self::Hasher {",
          "            std::collections::hash_map::DefaultHasher::new()",
          "        }",
          "    }",
          "",
          "    let mut map = IndexMap::<u32, String, TestHasher> {",
          "        core: IndexMapCore::new(),",
          "        hash_builder: TestHasher,",
          "    };",
          "",
          "    let tail = {",
          "        let mut core = IndexMapCore::with_capacity(2);",
          "        core.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value_1\".to_string() });",
          "        core.entries.push(Bucket { hash: HashValue(2), key: 2, value: \"old_value_2\".to_string() });",
          "        core.indices = Indices::new();",
          "        core",
          "    };",
          "",
          "    let replace_with_vec = vec![(1, \"new_value_1\".to_string()), (2, \"new_value_2\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "",
          "    let mut splice = Splice {",
          "        map: &mut map,",
          "        tail,",
          "        drain: vec![].into_iter(),",
          "        replace_with,",
          "    };",
          "",
          "    splice.drop();",
          "    let mut map = IndexMap::<u32, String, TestHasher> { core: IndexMapCore::new(), hash_builder: TestHasher };",
          "    let tail = { let mut core = IndexMapCore::with_capacity(2); core.entries.push(Bucket { hash: HashValue(1), key: 1, value: \"old_value_1\".to_string() }); core.entries.push(Bucket { hash: HashValue(2), key: 2, value: \"old_value_2\".to_string() }); core.indices = Indices::new(); core };",
          "    let replace_with_vec = vec![(1, \"new_value_1\".to_string()), (2, \"new_value_2\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "    let mut splice = Splice { map: &mut map, tail, drain: vec![].into_iter(), replace_with };",
          "    splice.drop();",
          "    assert_eq!(map.core.entries.len(), 2);",
          "    assert_eq!(map.core.entries[0].value, \"new_value_1\");",
          "    assert_eq!(map.core.entries[1].value, \"new_value_2\");",
          "    assert_eq!(splice.tail.entries.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHasher;",
          "",
          "    impl BuildHasher for TestHasher {",
          "        type Hasher = std::collections::hash_map::DefaultHasher;",
          "",
          "        fn build_hasher(&self) -> Self::Hasher {",
          "            std::collections::hash_map::DefaultHasher::new()",
          "        }",
          "    }",
          "",
          "    let mut map = IndexMap::<u32, String, TestHasher> {",
          "        core: IndexMapCore::new(),",
          "        hash_builder: TestHasher,",
          "    };",
          "",
          "    let tail = {",
          "        let mut core = IndexMapCore::with_capacity(1);",
          "        core.entries.push(Bucket { hash: HashValue(2), key: 2, value: \"old_value\".to_string() });",
          "        core.indices = Indices::new();",
          "        core",
          "    };",
          "",
          "    let replace_with_vec = vec![(1, \"new_value\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "",
          "    let mut splice = Splice {",
          "        map: &mut map,",
          "        tail,",
          "        drain: vec![].into_iter(),",
          "        replace_with,",
          "    };",
          "",
          "    splice.drop();",
          "}"
        ],
        "oracle": [
          "    let expected_value = \"new_value\".to_string();",
          "    let expected_key = 1;",
          "    ",
          "    // Validate that the splice inserts \"new_value\" for the key 1.",
          "    assert_eq!(map.core.entries.get(0).key, expected_key);",
          "    assert_eq!(map.core.entries.get(0).value, expected_value);",
          "    ",
          "    // Validate that the existing entry with key 2 retains its value.",
          "    let existing_key = 2;",
          "    let existing_value = \"old_value\".to_string();",
          "    assert_eq!(map.core.entries.get(1).key, existing_key);",
          "    assert_eq!(map.core.entries.get(1).value, existing_value);",
          "    ",
          "    // Validate that the length of the map's entries is correct after the drop.",
          "    assert_eq!(map.core.entries.len(), 2);",
          "    ",
          "    // Ensure that the drain iterator has been fully consumed.",
          "    assert!(splice.drain.count() == 0);"
        ],
        "code": [
          "{",
          "    struct TestHasher;",
          "",
          "    impl BuildHasher for TestHasher {",
          "        type Hasher = std::collections::hash_map::DefaultHasher;",
          "",
          "        fn build_hasher(&self) -> Self::Hasher {",
          "            std::collections::hash_map::DefaultHasher::new()",
          "        }",
          "    }",
          "",
          "    let mut map = IndexMap::<u32, String, TestHasher> {",
          "        core: IndexMapCore::new(),",
          "        hash_builder: TestHasher,",
          "    };",
          "",
          "    let tail = {",
          "        let mut core = IndexMapCore::with_capacity(1);",
          "        core.entries.push(Bucket { hash: HashValue(2), key: 2, value: \"old_value\".to_string() });",
          "        core.indices = Indices::new();",
          "        core",
          "    };",
          "",
          "    let replace_with_vec = vec![(1, \"new_value\".to_string())];",
          "    let replace_with = replace_with_vec.into_iter();",
          "",
          "    let mut splice = Splice {",
          "        map: &mut map,",
          "        tail,",
          "        drain: vec![].into_iter(),",
          "        replace_with,",
          "    };",
          "",
          "    splice.drop();",
          "    let expected_value = \"new_value\".to_string();",
          "    let expected_key = 1;",
          "    ",
          "    // Validate that the splice inserts \"new_value\" for the key 1.",
          "    assert_eq!(map.core.entries.get(0).key, expected_key);",
          "    assert_eq!(map.core.entries.get(0).value, expected_value);",
          "    ",
          "    // Validate that the existing entry with key 2 retains its value.",
          "    let existing_key = 2;",
          "    let existing_value = \"old_value\".to_string();",
          "    assert_eq!(map.core.entries.get(1).key, existing_key);",
          "    assert_eq!(map.core.entries.get(1).value, existing_value);",
          "    ",
          "    // Validate that the length of the map's entries is correct after the drop.",
          "    assert_eq!(map.core.entries.len(), 2);",
          "    ",
          "    // Ensure that the drain iterator has been fully consumed.",
          "    assert!(splice.drain.count() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]