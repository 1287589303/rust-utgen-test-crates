[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "            Bucket { hash: HashValue::default(), key: TestKey(2), value: TestValue(20) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(1), TestValue(10)),",
          "        (TestKey(2), TestValue(20)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(11))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(3), TestValue(20))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(10))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(3), TestValue(30))]), false);",
          "    assert_eq!(slice.eq(&[]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20)), (TestKey(3), TestValue(30))]), false);"
        ],
        "code": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "            Bucket { hash: HashValue::default(), key: TestKey(2), value: TestValue(20) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(1), TestValue(10)),",
          "        (TestKey(2), TestValue(20)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(11))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(3), TestValue(20))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(10))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(3), TestValue(30))]), false);",
          "    assert_eq!(slice.eq(&[]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20)), (TestKey(3), TestValue(30))]), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "            Bucket { hash: HashValue::default(), key: TestKey(2), value: TestValue(20) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(3), TestValue(30)),",
          "        (TestKey(4), TestValue(40)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(20))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(10))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(3), TestValue(30))]), false);",
          "    assert_eq!(slice.eq(&[]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(20)), (TestKey(1), TestValue(10))]), true);"
        ],
        "code": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "            Bucket { hash: HashValue::default(), key: TestKey(2), value: TestValue(20) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(3), TestValue(30)),",
          "        (TestKey(4), TestValue(40)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(20))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(10))]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(3), TestValue(30))]), false);",
          "    assert_eq!(slice.eq(&[]), false);",
          "    assert_eq!(slice.eq(&[(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))]), true);",
          "    assert_eq!(slice.eq(&[(TestKey(2), TestValue(20)), (TestKey(1), TestValue(10))]), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(1), TestValue(10)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice.eq(&other), true);",
          "    let other_different_key = [(TestKey(2), TestValue(10))];",
          "    assert_eq!(slice.eq(&other_different_key), false);",
          "    let other_different_value = [(TestKey(1), TestValue(20))];",
          "    assert_eq!(slice.eq(&other_different_value), false);",
          "    let other_empty: &[(TestKey, TestValue); 0] = &[];",
          "    assert_eq!(slice.eq(other_empty), false);",
          "    let slice_empty = Slice { entries: [] };",
          "    let other_empty_array: &[(TestKey, TestValue); 0] = &[];",
          "    assert_eq!(slice_empty.eq(other_empty_array), true);",
          "    let other_multiple_elements = [(TestKey(1), TestValue(10)), (TestKey(3), TestValue(30))];",
          "    assert_eq!(slice.eq(&other_multiple_elements), false);"
        ],
        "code": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(1), TestValue(10)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "    assert_eq!(slice.eq(&other), true);",
          "    let other_different_key = [(TestKey(2), TestValue(10))];",
          "    assert_eq!(slice.eq(&other_different_key), false);",
          "    let other_different_value = [(TestKey(1), TestValue(20))];",
          "    assert_eq!(slice.eq(&other_different_value), false);",
          "    let other_empty: &[(TestKey, TestValue); 0] = &[];",
          "    assert_eq!(slice.eq(other_empty), false);",
          "    let slice_empty = Slice { entries: [] };",
          "    let other_empty_array: &[(TestKey, TestValue); 0] = &[];",
          "    assert_eq!(slice_empty.eq(other_empty_array), true);",
          "    let other_multiple_elements = [(TestKey(1), TestValue(10)), (TestKey(3), TestValue(30))];",
          "    assert_eq!(slice.eq(&other_multiple_elements), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(1), TestValue(20)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "}"
        ],
        "oracle": [
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(1), TestValue(20))];",
          "    assert_eq!(slice.eq(&other), false);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(2), TestValue(10))];",
          "    assert_eq!(slice.eq(&other), false);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(1), TestValue(10))];",
          "    assert_eq!(slice.eq(&other), true);",
          "    ",
          "    let slice = Slice { entries: [] };",
          "    let other: [(TestKey, TestValue); 0] = [];",
          "    assert_eq!(slice.eq(&other), true);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }, Bucket { hash: HashValue::default(), key: TestKey(2), value: TestValue(20) }] };",
          "    let other = [(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))];",
          "    assert_eq!(slice.eq(&other), true);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))];",
          "    assert_eq!(slice.eq(&other), false);"
        ],
        "code": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "        ],",
          "    };",
          "    ",
          "    let other = [",
          "        (TestKey(1), TestValue(20)),",
          "    ];",
          "    ",
          "    let _result = slice.eq(&other);",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(1), TestValue(20))];",
          "    assert_eq!(slice.eq(&other), false);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(2), TestValue(10))];",
          "    assert_eq!(slice.eq(&other), false);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(1), TestValue(10))];",
          "    assert_eq!(slice.eq(&other), true);",
          "    ",
          "    let slice = Slice { entries: [] };",
          "    let other: [(TestKey, TestValue); 0] = [];",
          "    assert_eq!(slice.eq(&other), true);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }, Bucket { hash: HashValue::default(), key: TestKey(2), value: TestValue(20) }] };",
          "    let other = [(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))];",
          "    assert_eq!(slice.eq(&other), true);",
          "    ",
          "    let slice = Slice { entries: [Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) }] };",
          "    let other = [(TestKey(1), TestValue(10)), (TestKey(2), TestValue(20))];",
          "    assert_eq!(slice.eq(&other), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "        ],",
          "    };",
          "    ",
          "    let other: [(TestKey, TestValue); 0] = [];",
          "    ",
          "    let _result = slice.eq(&other);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice.eq(&other), true);"
        ],
        "code": [
          "{",
          "    struct TestKey(i32);",
          "    struct TestValue(i32);",
          "    ",
          "    let slice = Slice {",
          "        entries: [",
          "            Bucket { hash: HashValue::default(), key: TestKey(1), value: TestValue(10) },",
          "        ],",
          "    };",
          "    ",
          "    let other: [(TestKey, TestValue); 0] = [];",
          "    ",
          "    let _result = slice.eq(&other);",
          "    assert_eq!(slice.eq(&other), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]