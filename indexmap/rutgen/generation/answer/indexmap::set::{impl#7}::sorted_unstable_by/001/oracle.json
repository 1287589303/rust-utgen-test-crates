[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "}"
        ],
        "oracle": [
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).into_entries().len() == 0",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().is_empty()",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).iter().all(|entry| entry.key.is_empty())",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().first().is_none()",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().last().is_none()",
          "    let entries = set.sorted_unstable_by(|a, b| a.cmp(b)).into_entries();",
          "    entries.sort_unstable_by(|a, b| a.key.cmp(&b.key));",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).iter().zip(entries.iter()).all(|(iter_entry, bucket_entry)| iter_entry.key == bucket_entry.key)",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).len() == entries.len()",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().len() == entries.len()"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).into_entries().len() == 0",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().is_empty()",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).iter().all(|entry| entry.key.is_empty())",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().first().is_none()",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().last().is_none()",
          "    let entries = set.sorted_unstable_by(|a, b| a.cmp(b)).into_entries();",
          "    entries.sort_unstable_by(|a, b| a.key.cmp(&b.key));",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).iter().zip(entries.iter()).all(|(iter_entry, bucket_entry)| iter_entry.key == bucket_entry.key)",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).len() == entries.len()",
          "    set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().len() == entries.len()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(42);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "}"
        ],
        "oracle": [
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(42);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[42]);",
          "    set.insert(3);",
          "    set.insert(16);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[3, 16, 42]);",
          "    set.insert(-10);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-10, 3, 16, 42]);",
          "    set.insert(100);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-10, 3, 16, 42, 100]);",
          "    set.insert(0);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-10, 0, 3, 16, 42, 100]);",
          "    set.retain(|&x| x > 0);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[3, 16, 42, 100]);"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(42);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(42);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[42]);",
          "    set.insert(3);",
          "    set.insert(16);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[3, 16, 42]);",
          "    set.insert(-10);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-10, 3, 16, 42]);",
          "    set.insert(100);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-10, 3, 16, 42, 100]);",
          "    set.insert(0);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-10, 0, 3, 16, 42, 100]);",
          "    set.retain(|&x| x > 0);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[3, 16, 42, 100]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "}"
        ],
        "oracle": [
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[1, 2, 3]);",
          "    set.insert(5);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[1, 2, 3, 5]);",
          "    set.insert(4);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[1, 2, 3, 4, 5]);",
          "    set.insert(0);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[0, 1, 2, 3, 4, 5]);",
          "    set.insert(-1);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-1, 0, 1, 2, 3, 4, 5]);",
          "    set.insert(-2);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-2, -1, 0, 1, 2, 3, 4, 5]);",
          "    set.insert(3);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-2, -1, 0, 1, 2, 3, 4, 5]);"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[1, 2, 3]);",
          "    set.insert(5);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[1, 2, 3, 5]);",
          "    set.insert(4);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[1, 2, 3, 4, 5]);",
          "    set.insert(0);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[0, 1, 2, 3, 4, 5]);",
          "    set.insert(-1);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-1, 0, 1, 2, 3, 4, 5]);",
          "    set.insert(-2);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-2, -1, 0, 1, 2, 3, 4, 5]);",
          "    set.insert(3);",
          "    let iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(iter.as_slice(), &[-2, -1, 0, 1, 2, 3, 4, 5]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(3);",
          "    set.insert(2);",
          "    set.insert(1);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![1, 2, 3]);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| b.cmp(a)).as_slice(), vec![3, 2, 1]);",
          "    set.insert(4);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![1, 2, 3, 4]);",
          "    set.insert(-1);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![-1, 1, 2, 3, 4]);",
          "    set.insert(3);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![-1, 1, 2, 3, 4]);"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(3);",
          "    set.insert(2);",
          "    set.insert(1);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![1, 2, 3]);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| b.cmp(a)).as_slice(), vec![3, 2, 1]);",
          "    set.insert(4);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![1, 2, 3, 4]);",
          "    set.insert(-1);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![-1, 1, 2, 3, 4]);",
          "    set.insert(3);",
          "    assert_eq!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice(), vec![-1, 1, 2, 3, 4]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 3);",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(set.contains(&3));",
          "    assert!(!set.contains(&4));",
          "    let collected: Vec<_> = _iter.as_slice().iter().cloned().collect();",
          "    assert_eq!(collected, vec![1, 2, 3]);"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(1);",
          "    set.insert(2);",
          "    set.insert(3);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(set.len(), 3);",
          "    assert!(set.contains(&1));",
          "    assert!(set.contains(&2));",
          "    assert!(set.contains(&3));",
          "    assert!(!set.contains(&4));",
          "    let collected: Vec<_> = _iter.as_slice().iter().cloned().collect();",
          "    assert_eq!(collected, vec![1, 2, 3]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(3);",
          "    set.insert(2);",
          "    let _iter = set.sorted_unstable_by(|a, b| b.cmp(a));",
          "}"
        ],
        "oracle": [
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(3);",
          "    set.insert(2);",
          "    let mut iter = set.sorted_unstable_by(|a, b| b.cmp(a));",
          "    assert_eq!(iter.next(), Some(3));",
          "    assert_eq!(iter.next(), Some(2));",
          "    assert_eq!(iter.next(), Some(1));",
          "    assert_eq!(iter.next(), None);"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(3);",
          "    set.insert(2);",
          "    let _iter = set.sorted_unstable_by(|a, b| b.cmp(a));",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(1);",
          "    set.insert(3);",
          "    set.insert(2);",
          "    let mut iter = set.sorted_unstable_by(|a, b| b.cmp(a));",
          "    assert_eq!(iter.next(), Some(3));",
          "    assert_eq!(iter.next(), Some(2));",
          "    assert_eq!(iter.next(), Some(1));",
          "    assert_eq!(iter.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(i32::MAX);",
          "    set.insert(i32::MIN);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "}"
        ],
        "oracle": [
          "    set.insert(i32::MAX);",
          "    set.insert(i32::MIN);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(_iter.as_slice(), &[i32::MIN, i32::MAX]);",
          "    assert!(_iter.iter().next().is_some());",
          "    assert!(_iter.iter().last().is_some());",
          "    let iter = set.sorted_unstable_by(|a, b| b.cmp(a));",
          "    assert_eq!(iter.as_slice(), &[i32::MAX, i32::MIN]);",
          "    assert_eq!(iter.len(), 2);",
          "    assert!(set.first().is_some());",
          "    assert!(set.last().is_some());",
          "    assert!(set.get_index(0).is_some());",
          "    assert!(set.get_index(1).is_some());"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<i32, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(i32::MAX);",
          "    set.insert(i32::MIN);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    set.insert(i32::MAX);",
          "    set.insert(i32::MIN);",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(_iter.as_slice(), &[i32::MIN, i32::MAX]);",
          "    assert!(_iter.iter().next().is_some());",
          "    assert!(_iter.iter().last().is_some());",
          "    let iter = set.sorted_unstable_by(|a, b| b.cmp(a));",
          "    assert_eq!(iter.as_slice(), &[i32::MAX, i32::MIN]);",
          "    assert_eq!(iter.len(), 2);",
          "    assert!(set.first().is_some());",
          "    assert!(set.last().is_some());",
          "    assert!(set.get_index(0).is_some());",
          "    assert!(set.get_index(1).is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set: IndexSet<Option<i32>, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(None);",
          "    set.insert(Some(1));",
          "    set.insert(Some(2));",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.as_slice(), vec![Some(1), Some(2), None]);",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().is_sorted());",
          "    assert_eq!(_iter.len(), 3);",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().contains(&Some(1)));",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().contains(&Some(2)));",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().contains(&None));"
        ],
        "code": [
          "{",
          "    let mut set: IndexSet<Option<i32>, ()> = IndexSet { map: IndexMap { core: IndexMapCore::new(), hash_builder: RandomState::new() } };",
          "    set.insert(None);",
          "    set.insert(Some(1));",
          "    set.insert(Some(2));",
          "    let _iter = set.sorted_unstable_by(|a, b| a.cmp(b));",
          "    assert_eq!(_iter.as_slice(), vec![Some(1), Some(2), None]);",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().is_sorted());",
          "    assert_eq!(_iter.len(), 3);",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().contains(&Some(1)));",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().contains(&Some(2)));",
          "    assert!(set.sorted_unstable_by(|a, b| a.cmp(b)).as_slice().contains(&None));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]