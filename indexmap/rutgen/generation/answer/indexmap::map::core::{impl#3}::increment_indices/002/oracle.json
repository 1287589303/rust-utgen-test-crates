[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(0);",
          "    indices.insert(1);",
          "    let entries = vec![Bucket { hash: HashValue(0), key: 100, value: \"a\" }, ",
          "                       Bucket { hash: HashValue(1), key: 200, value: \"b\" },",
          "                       Bucket { hash: HashValue(2), key: 300, value: \"c\" }];",
          "",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(1, 3);",
          "}"
        ],
        "oracle": [
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(0);",
          "    indices.insert(1);",
          "    let entries = vec![Bucket { hash: HashValue(0), key: 100, value: \"a\" }, Bucket { hash: HashValue(1), key: 200, value: \"b\" }, Bucket { hash: HashValue(2), key: 300, value: \"c\" }];",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(1, 3);",
          "    assert_eq!(indices.find(HashValue(1).get()), Some(&2));",
          "    assert_eq!(indices.find(HashValue(2).get()), Some(&3));",
          "    assert_eq!(entries[1].hash, HashValue(1));",
          "    assert_eq!(entries[2].hash, HashValue(2));"
        ],
        "code": [
          "{",
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(0);",
          "    indices.insert(1);",
          "    let entries = vec![Bucket { hash: HashValue(0), key: 100, value: \"a\" }, ",
          "                       Bucket { hash: HashValue(1), key: 200, value: \"b\" },",
          "                       Bucket { hash: HashValue(2), key: 300, value: \"c\" }];",
          "",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(1, 3);",
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(0);",
          "    indices.insert(1);",
          "    let entries = vec![Bucket { hash: HashValue(0), key: 100, value: \"a\" }, Bucket { hash: HashValue(1), key: 200, value: \"b\" }, Bucket { hash: HashValue(2), key: 300, value: \"c\" }];",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(1, 3);",
          "    assert_eq!(indices.find(HashValue(1).get()), Some(&2));",
          "    assert_eq!(indices.find(HashValue(2).get()), Some(&3));",
          "    assert_eq!(entries[1].hash, HashValue(1));",
          "    assert_eq!(entries[2].hash, HashValue(2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(1);",
          "    indices.insert(2);",
          "    indices.insert(3);",
          "    ",
          "    let entries = vec![Bucket { hash: HashValue(3), key: 400, value: \"d\" }, ",
          "                       Bucket { hash: HashValue(4), key: 500, value: \"e\" },",
          "                       Bucket { hash: HashValue(5), key: 600, value: \"f\" },",
          "                       Bucket { hash: HashValue(6), key: 700, value: \"g\" }];",
          "",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(2, 4);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(indices.len(), 3);",
          "    assert!(indices.contains(&1));",
          "    assert!(indices.contains(&2));",
          "    assert!(indices.contains(&3));",
          "    assert!(!indices.contains(&4));",
          "    assert_eq!(entries[2].hash, HashValue(5));",
          "    assert_eq!(entries[3].hash, HashValue(6));",
          "    assert!(entries[2].key == 500);",
          "    assert!(entries[3].key == 600);",
          "    assert!(entries[2].value == \"e\");",
          "    assert!(entries[3].value == \"f\");",
          "    assert_eq!(indices.iter().copied().max(), Some(3));",
          "    assert_eq!(indices.iter().copied().min(), Some(1));",
          "    assert_eq!(indices.capacity(), 4);",
          "    assert!(indices.get(&5).is_none());",
          "    assert!(entries[2].key != entries[3].key);",
          "    assert!(entries.len() == 4);",
          "    assert!(entries[1].value != \"f\");",
          "    assert!(entries[0].value == \"d\");",
          "    assert!(indices.len() == 3);"
        ],
        "code": [
          "{",
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(1);",
          "    indices.insert(2);",
          "    indices.insert(3);",
          "    ",
          "    let entries = vec![Bucket { hash: HashValue(3), key: 400, value: \"d\" }, ",
          "                       Bucket { hash: HashValue(4), key: 500, value: \"e\" },",
          "                       Bucket { hash: HashValue(5), key: 600, value: \"f\" },",
          "                       Bucket { hash: HashValue(6), key: 700, value: \"g\" }];",
          "",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(2, 4);",
          "    assert_eq!(indices.len(), 3);",
          "    assert!(indices.contains(&1));",
          "    assert!(indices.contains(&2));",
          "    assert!(indices.contains(&3));",
          "    assert!(!indices.contains(&4));",
          "    assert_eq!(entries[2].hash, HashValue(5));",
          "    assert_eq!(entries[3].hash, HashValue(6));",
          "    assert!(entries[2].key == 500);",
          "    assert!(entries[3].key == 600);",
          "    assert!(entries[2].value == \"e\");",
          "    assert!(entries[3].value == \"f\");",
          "    assert_eq!(indices.iter().copied().max(), Some(3));",
          "    assert_eq!(indices.iter().copied().min(), Some(1));",
          "    assert_eq!(indices.capacity(), 4);",
          "    assert!(indices.get(&5).is_none());",
          "    assert!(entries[2].key != entries[3].key);",
          "    assert!(entries.len() == 4);",
          "    assert!(entries[1].value != \"f\");",
          "    assert!(entries[0].value == \"d\");",
          "    assert!(indices.len() == 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(2);",
          "    indices.insert(3);",
          "    indices.insert(4);",
          "    indices.insert(5);",
          "    ",
          "    let entries = vec![Bucket { hash: HashValue(7), key: 800, value: \"h\" },",
          "                       Bucket { hash: HashValue(8), key: 900, value: \"i\" },",
          "                       Bucket { hash: HashValue(9), key: 1000, value: \"j\" },",
          "                       Bucket { hash: HashValue(10), key: 1100, value: \"k\" },",
          "                       Bucket { hash: HashValue(11), key: 1200, value: \"l\" }];",
          "",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(3, 5);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(indices.get(&7), None);",
          "    assert_eq!(indices.get(&8), None);",
          "    assert_eq!(indices.get(&9), None);",
          "    assert_eq!(indices.get(&10), Some(&4));",
          "    assert_eq!(indices.get(&11), Some(&5));",
          "    assert_eq!(indices.len(), 4);",
          "    assert_eq!(entries[0].hash, HashValue(7));",
          "    assert_eq!(entries[1].hash, HashValue(8));",
          "    assert_eq!(entries[2].hash, HashValue(9));",
          "    assert_eq!(entries[3].hash, HashValue(10));",
          "    assert_eq!(entries[4].hash, HashValue(11));",
          "    assert_eq!(entries.len(), 5);",
          "    assert_eq!(indices.capacity(), 8);",
          "    assert!(indices.contains(&2));",
          "    assert!(indices.contains(&3));",
          "    assert!(indices.contains(&4));",
          "    assert!(indices.contains(&5));"
        ],
        "code": [
          "{",
          "    let mut indices = hash_table::HashTable::<usize>::new();",
          "    indices.insert(2);",
          "    indices.insert(3);",
          "    indices.insert(4);",
          "    indices.insert(5);",
          "    ",
          "    let entries = vec![Bucket { hash: HashValue(7), key: 800, value: \"h\" },",
          "                       Bucket { hash: HashValue(8), key: 900, value: \"i\" },",
          "                       Bucket { hash: HashValue(9), key: 1000, value: \"j\" },",
          "                       Bucket { hash: HashValue(10), key: 1100, value: \"k\" },",
          "                       Bucket { hash: HashValue(11), key: 1200, value: \"l\" }];",
          "",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.increment_indices(3, 5);",
          "    assert_eq!(indices.get(&7), None);",
          "    assert_eq!(indices.get(&8), None);",
          "    assert_eq!(indices.get(&9), None);",
          "    assert_eq!(indices.get(&10), Some(&4));",
          "    assert_eq!(indices.get(&11), Some(&5));",
          "    assert_eq!(indices.len(), 4);",
          "    assert_eq!(entries[0].hash, HashValue(7));",
          "    assert_eq!(entries[1].hash, HashValue(8));",
          "    assert_eq!(entries[2].hash, HashValue(9));",
          "    assert_eq!(entries[3].hash, HashValue(10));",
          "    assert_eq!(entries[4].hash, HashValue(11));",
          "    assert_eq!(entries.len(), 5);",
          "    assert_eq!(indices.capacity(), 8);",
          "    assert!(indices.contains(&2));",
          "    assert!(indices.contains(&3));",
          "    assert!(indices.contains(&4));",
          "    assert!(indices.contains(&5));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]