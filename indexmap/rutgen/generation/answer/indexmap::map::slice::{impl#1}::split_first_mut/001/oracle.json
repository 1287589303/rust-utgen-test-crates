[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Slice<i32, i32> = Slice {",
          "        entries: [Bucket {",
          "            hash: HashValue::default(),",
          "            key: 1,",
          "            value: 10,",
          "        }],",
          "    };",
          "    slice.split_first_mut();",
          "}"
        ],
        "oracle": [
          "    assert!(slice.split_first_mut().is_some());",
          "    let first_mut = slice.split_first_mut().unwrap();",
          "    assert_eq!(first_mut.0.0, &1);",
          "    assert_eq!(*first_mut.0.1, 10);",
          "    assert!(first_mut.1.is_empty());"
        ],
        "code": [
          "{",
          "    let mut slice: Slice<i32, i32> = Slice {",
          "        entries: [Bucket {",
          "            hash: HashValue::default(),",
          "            key: 1,",
          "            value: 10,",
          "        }],",
          "    };",
          "    slice.split_first_mut();",
          "    assert!(slice.split_first_mut().is_some());",
          "    let first_mut = slice.split_first_mut().unwrap();",
          "    assert_eq!(first_mut.0.0, &1);",
          "    assert_eq!(*first_mut.0.1, 10);",
          "    assert!(first_mut.1.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: Slice<i32, i32> = Slice {",
          "        entries: [",
          "            Bucket {",
          "                hash: HashValue::default(),",
          "                key: 1,",
          "                value: 10,",
          "            },",
          "            Bucket {",
          "                hash: HashValue::default(),",
          "                key: 2,",
          "                value: 20,",
          "            },",
          "        ],",
          "    };",
          "    slice.split_first_mut();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice.split_first_mut().is_some(), true);",
          "    assert_eq!(slice.entries.len(), 2);",
          "    assert_eq!(slice.split_first_mut().unwrap().0, (&1, &mut 10));",
          "    assert_eq!(slice.split_first_mut().unwrap().1.entries.len(), 1);",
          "    assert_eq!(slice.split_first_mut().unwrap().1.entries[0].key, 2);",
          "    assert_eq!(slice.split_first_mut().unwrap().1.entries[0].value, 20);"
        ],
        "code": [
          "{",
          "    let mut slice: Slice<i32, i32> = Slice {",
          "        entries: [",
          "            Bucket {",
          "                hash: HashValue::default(),",
          "                key: 1,",
          "                value: 10,",
          "            },",
          "            Bucket {",
          "                hash: HashValue::default(),",
          "                key: 2,",
          "                value: 20,",
          "            },",
          "        ],",
          "    };",
          "    slice.split_first_mut();",
          "    assert_eq!(slice.split_first_mut().is_some(), true);",
          "    assert_eq!(slice.entries.len(), 2);",
          "    assert_eq!(slice.split_first_mut().unwrap().0, (&1, &mut 10));",
          "    assert_eq!(slice.split_first_mut().unwrap().1.entries.len(), 1);",
          "    assert_eq!(slice.split_first_mut().unwrap().1.entries[0].key, 2);",
          "    assert_eq!(slice.split_first_mut().unwrap().1.entries[0].value, 20);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]