[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "    ];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "}"
        ],
        "oracle": [
          "    let entries = [Bucket { hash: 1, key: TestKey, value: TestValue }, Bucket { hash: 2, key: TestKey, value: TestValue }];",
          "    let slice = Slice { entries };",
          "    let iter = slice.iter();",
          "    assert_eq!(iter.as_slice().len(), 2);",
          "    assert!(slice.len() == 2);",
          "    assert!(!slice.is_empty());",
          "    let first = slice.first();",
          "    assert!(first.is_some());",
          "    let last = slice.last();",
          "    assert!(last.is_some());",
          "    let (first_half, second_half) = slice.split_at(1);",
          "    assert!(first_half.len() == 1);",
          "    assert!(second_half.len() == 1);"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "    ];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "    let entries = [Bucket { hash: 1, key: TestKey, value: TestValue }, Bucket { hash: 2, key: TestKey, value: TestValue }];",
          "    let slice = Slice { entries };",
          "    let iter = slice.iter();",
          "    assert_eq!(iter.as_slice().len(), 2);",
          "    assert!(slice.len() == 2);",
          "    assert!(!slice.is_empty());",
          "    let first = slice.first();",
          "    assert!(first.is_some());",
          "    let last = slice.last();",
          "    assert!(last.is_some());",
          "    let (first_half, second_half) = slice.split_at(1);",
          "    assert!(first_half.len() == 1);",
          "    assert!(second_half.len() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [Bucket { hash: 0, key: TestKey, value: TestValue }];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slice.entries.len(), 1);",
          "    assert_eq!(slice.iter().as_slice().len(), 1);",
          "    assert!(slice.iter().next().is_some());",
          "    assert_eq!(slice.iter().next().unwrap(), (&TestKey, &TestValue));",
          "    assert_eq!(slice.iter().as_slice().iter().count(), 1);",
          "    assert_eq!(slice.iter().as_slice().iter().position(|(k, _)| *k == TestKey), Some(0));"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [Bucket { hash: 0, key: TestKey, value: TestValue }];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "    assert_eq!(slice.entries.len(), 1);",
          "    assert_eq!(slice.iter().as_slice().len(), 1);",
          "    assert!(slice.iter().next().is_some());",
          "    assert_eq!(slice.iter().next().unwrap(), (&TestKey, &TestValue));",
          "    assert_eq!(slice.iter().as_slice().iter().count(), 1);",
          "    assert_eq!(slice.iter().as_slice().iter().position(|(k, _)| *k == TestKey), Some(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "    ];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "}"
        ],
        "oracle": [
          "    _iter.iter.len() == 3",
          "    _iter.as_slice().len() == 3",
          "    _iter.as_slice().get(0).unwrap() == (&TestKey, &TestValue)",
          "    _iter.as_slice().get(1).unwrap() == (&TestKey, &TestValue)",
          "    _iter.as_slice().get(2).unwrap() == (&TestKey, &TestValue)"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "        Bucket { hash: 0, key: TestKey, value: TestValue },",
          "    ];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "    _iter.iter.len() == 3",
          "    _iter.as_slice().len() == 3",
          "    _iter.as_slice().get(0).unwrap() == (&TestKey, &TestValue)",
          "    _iter.as_slice().get(1).unwrap() == (&TestKey, &TestValue)",
          "    _iter.as_slice().get(2).unwrap() == (&TestKey, &TestValue)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries: [Bucket<TestKey, TestValue>; 0] = [];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.as_slice(), &slice);",
          "    assert_eq!(slice.len(), 0);",
          "    assert!(slice.is_empty());",
          "    assert!(slice.first().is_none());",
          "    assert!(slice.last().is_none());",
          "    assert!(slice.split_at(0).0.is_empty());",
          "    assert!(slice.split_at(0).1.is_empty());",
          "    assert!(slice.split_first().is_none());",
          "    assert!(slice.split_last().is_none());",
          "    assert_eq!(slice.get_index(0), None);",
          "    assert_eq!(slice.get_range(0..1), None);",
          "    assert!(slice.get_range_mut(0..1).is_none());"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries: [Bucket<TestKey, TestValue>; 0] = [];",
          "    let slice = Slice { entries };",
          "",
          "    let _iter = slice.iter();",
          "    assert_eq!(_iter.as_slice(), &slice);",
          "    assert_eq!(slice.len(), 0);",
          "    assert!(slice.is_empty());",
          "    assert!(slice.first().is_none());",
          "    assert!(slice.last().is_none());",
          "    assert!(slice.split_at(0).0.is_empty());",
          "    assert!(slice.split_at(0).1.is_empty());",
          "    assert!(slice.split_first().is_none());",
          "    assert!(slice.split_last().is_none());",
          "    assert_eq!(slice.get_index(0), None);",
          "    assert_eq!(slice.get_range(0..1), None);",
          "    assert!(slice.get_range_mut(0..1).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]