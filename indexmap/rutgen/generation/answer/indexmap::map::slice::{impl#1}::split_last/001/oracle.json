[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bucket = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let entries = vec![bucket];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let result = slice.split_last();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    let ((last_key, last_value), rest_slice) = result.unwrap();",
          "    assert_eq!(last_key, &\"key1\");",
          "    assert_eq!(last_value, &\"value1\");",
          "    assert_eq!(rest_slice.len(), 0);"
        ],
        "code": [
          "{",
          "    let bucket = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let entries = vec![bucket];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let result = slice.split_last();",
          "    assert!(result.is_some());",
          "    let ((last_key, last_value), rest_slice) = result.unwrap();",
          "    assert_eq!(last_key, &\"key1\");",
          "    assert_eq!(last_value, &\"value1\");",
          "    assert_eq!(rest_slice.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let entries = vec![bucket1, bucket2];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let result = slice.split_last();",
          "}"
        ],
        "oracle": [
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let entries = vec![bucket1, bucket2];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let expected = Some((&\"key2\", &\"value2\"), Slice::from_slice(&[Bucket { hash: 0, key: \"key1\", value: \"value1\" }]));",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let entries = vec![bucket1, bucket2];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let result = slice.split_last();",
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let entries = vec![bucket1, bucket2];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let expected = Some((&\"key2\", &\"value2\"), Slice::from_slice(&[Bucket { hash: 0, key: \"key1\", value: \"value1\" }]));",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let bucket3 = Bucket { hash: 2, key: \"key3\", value: \"value3\" };",
          "    let entries = vec![bucket1, bucket2, bucket3];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let result = slice.split_last();",
          "}"
        ],
        "oracle": [
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let bucket3 = Bucket { hash: 2, key: \"key3\", value: \"value3\" };",
          "    let entries = vec![bucket1, bucket2, bucket3];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    let result = slice.split_last();",
          "    assert!(result.is_some());",
          "    let (last_refs, rest_slice) = result.unwrap();",
          "    assert_eq!(last_refs, (&\"key3\", &\"value3\"));",
          "    assert_eq!(rest_slice.len(), 2);",
          "    assert!(rest_slice.get_index(0).unwrap() == (&\"key1\", &\"value1\"));",
          "    assert!(rest_slice.get_index(1).unwrap() == (&\"key2\", &\"value2\"));"
        ],
        "code": [
          "{",
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let bucket3 = Bucket { hash: 2, key: \"key3\", value: \"value3\" };",
          "    let entries = vec![bucket1, bucket2, bucket3];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    ",
          "    let result = slice.split_last();",
          "    let bucket1 = Bucket { hash: 0, key: \"key1\", value: \"value1\" };",
          "    let bucket2 = Bucket { hash: 1, key: \"key2\", value: \"value2\" };",
          "    let bucket3 = Bucket { hash: 2, key: \"key3\", value: \"value3\" };",
          "    let entries = vec![bucket1, bucket2, bucket3];",
          "    let slice = Box::new(Slice { entries: entries.try_into().unwrap() });",
          "    let result = slice.split_last();",
          "    assert!(result.is_some());",
          "    let (last_refs, rest_slice) = result.unwrap();",
          "    assert_eq!(last_refs, (&\"key3\", &\"value3\"));",
          "    assert_eq!(rest_slice.len(), 2);",
          "    assert!(rest_slice.get_index(0).unwrap() == (&\"key1\", &\"value1\"));",
          "    assert!(rest_slice.get_index(1).unwrap() == (&\"key2\", &\"value2\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]