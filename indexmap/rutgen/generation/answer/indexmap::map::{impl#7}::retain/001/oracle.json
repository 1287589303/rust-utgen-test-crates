[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, String>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, \"One\".to_string());",
          "    map.data.insert(2, \"Two\".to_string());",
          "    ",
          "    map.data.retain(|_, _| true);",
          "    ",
          "    let _ = map.data.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.data.len(), 2);",
          "    map.data.retain(|_, v| v == \"One\");",
          "    assert_eq!(map.data.len(), 1);",
          "    assert_eq!(map.data.first(), Some((&1, &\"One\".to_string())));",
          "    map.data.retain(|k, _| *k != 1);",
          "    assert_eq!(map.data.len(), 0);",
          "    map.data.retain(|_, _| false);",
          "    assert_eq!(map.data.len(), 0);"
        ],
        "code": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, String>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, \"One\".to_string());",
          "    map.data.insert(2, \"Two\".to_string());",
          "    ",
          "    map.data.retain(|_, _| true);",
          "    ",
          "    let _ = map.data.len();",
          "    assert_eq!(map.data.len(), 2);",
          "    map.data.retain(|_, v| v == \"One\");",
          "    assert_eq!(map.data.len(), 1);",
          "    assert_eq!(map.data.first(), Some((&1, &\"One\".to_string())));",
          "    map.data.retain(|k, _| *k != 1);",
          "    assert_eq!(map.data.len(), 0);",
          "    map.data.retain(|_, _| false);",
          "    assert_eq!(map.data.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, String>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, \"One\".to_string());",
          "    map.data.insert(2, \"Two\".to_string());",
          "    ",
          "    map.data.retain(|_, _| false);",
          "    ",
          "    let _ = map.data.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.data.len(), 0);",
          "    map.data.insert(3, \"Three\".to_string());",
          "    map.data.retain(|_, _| true);",
          "    assert_eq!(map.data.len(), 1);",
          "    assert!(map.data.get_index(0).is_some());",
          "    assert_eq!(map.data.get_index(0), Some((&3, &\"Three\".to_string())));",
          "    map.data.retain(|k, _| *k != 3);",
          "    assert_eq!(map.data.len(), 0);"
        ],
        "code": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, String>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, \"One\".to_string());",
          "    map.data.insert(2, \"Two\".to_string());",
          "    ",
          "    map.data.retain(|_, _| false);",
          "    ",
          "    let _ = map.data.len();",
          "    assert_eq!(map.data.len(), 0);",
          "    map.data.insert(3, \"Three\".to_string());",
          "    map.data.retain(|_, _| true);",
          "    assert_eq!(map.data.len(), 1);",
          "    assert!(map.data.get_index(0).is_some());",
          "    assert_eq!(map.data.get_index(0), Some((&3, &\"Three\".to_string())));",
          "    map.data.retain(|k, _| *k != 3);",
          "    assert_eq!(map.data.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, String>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, \"One\".to_string());",
          "    map.data.insert(2, \"Two\".to_string());",
          "    ",
          "    map.data.retain(|k, _| *k == 1);",
          "    ",
          "    let _ = map.data.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.data.len(), 1);",
          "    assert!(map.data.get(&1).is_some());",
          "    assert!(map.data.get(&2).is_none());",
          "    assert_eq!(map.data.get(&1), Some(&\"One\".to_string()));",
          "    assert_eq!(map.data.get(&2), None);",
          "    map.data.retain(|k, _| *k == 2);",
          "    assert_eq!(map.data.len(), 0);",
          "    assert!(map.data.is_empty());"
        ],
        "code": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, String>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, \"One\".to_string());",
          "    map.data.insert(2, \"Two\".to_string());",
          "    ",
          "    map.data.retain(|k, _| *k == 1);",
          "    ",
          "    let _ = map.data.len();",
          "    assert_eq!(map.data.len(), 1);",
          "    assert!(map.data.get(&1).is_some());",
          "    assert!(map.data.get(&2).is_none());",
          "    assert_eq!(map.data.get(&1), Some(&\"One\".to_string()));",
          "    assert_eq!(map.data.get(&2), None);",
          "    map.data.retain(|k, _| *k == 2);",
          "    assert_eq!(map.data.len(), 0);",
          "    assert!(map.data.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, i32>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, 10);",
          "    map.data.insert(2, 20);",
          "    ",
          "    map.data.retain(|_, v| {",
          "        *v += 5;",
          "        *v > 12",
          "    });",
          "    ",
          "    let _ = map.data.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.data.len(), 1);",
          "    assert_eq!(map.data.get(&1), None);",
          "    assert_eq!(map.data.get(&2), Some(&25));"
        ],
        "code": [
          "{",
          "    struct TestMap {",
          "        data: indexmap::IndexMap<i32, i32>,",
          "    }",
          "    ",
          "    let mut map = TestMap {",
          "        data: indexmap::IndexMap::new(),",
          "    };",
          "    map.data.insert(1, 10);",
          "    map.data.insert(2, 20);",
          "    ",
          "    map.data.retain(|_, v| {",
          "        *v += 5;",
          "        *v > 12",
          "    });",
          "    ",
          "    let _ = map.data.len();",
          "    assert_eq!(map.data.len(), 1);",
          "    assert_eq!(map.data.get(&1), None);",
          "    assert_eq!(map.data.get(&2), Some(&25));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]