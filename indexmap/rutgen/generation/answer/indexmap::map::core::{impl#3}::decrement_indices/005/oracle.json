[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = indexmap::Indices::with_capacity(8);",
          "    indices.push(1);",
          "    indices.push(2);",
          "    indices.push(3);",
          "    indices.push(4);",
          "    ",
          "    let mut entries = vec![",
          "        Bucket { hash: HashValue(1), key: \"a\", value: 10 },",
          "        Bucket { hash: HashValue(2), key: \"b\", value: 20 },",
          "        Bucket { hash: HashValue(3), key: \"c\", value: 30 },",
          "        Bucket { hash: HashValue(4), key: \"d\", value: 40 },",
          "    ];",
          "    ",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 4);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(indices, vec![1, 2, 3, 4]);",
          "    assert_eq!(entries[0], Bucket { hash: HashValue(1), key: \"a\", value: 10 });",
          "    assert_eq!(entries[1], Bucket { hash: HashValue(2), key: \"b\", value: 20 });",
          "    assert_eq!(entries[2], Bucket { hash: HashValue(3), key: \"c\", value: 30 });",
          "    assert_eq!(entries[3], Bucket { hash: HashValue(4), key: \"d\", value: 40 });",
          "    assert!(indices.is_empty() || indices[0] != 0);",
          "    assert!(entries.len() == 4);",
          "    assert!(indices.len() == 4);",
          "    assert!(indices.iter().all(|&i| i >= 0));",
          "    assert!(indices.iter().all(|&i| i < entries.len()));"
        ],
        "code": [
          "{",
          "    let mut indices = indexmap::Indices::with_capacity(8);",
          "    indices.push(1);",
          "    indices.push(2);",
          "    indices.push(3);",
          "    indices.push(4);",
          "    ",
          "    let mut entries = vec![",
          "        Bucket { hash: HashValue(1), key: \"a\", value: 10 },",
          "        Bucket { hash: HashValue(2), key: \"b\", value: 20 },",
          "        Bucket { hash: HashValue(3), key: \"c\", value: 30 },",
          "        Bucket { hash: HashValue(4), key: \"d\", value: 40 },",
          "    ];",
          "    ",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 4);",
          "    assert_eq!(indices, vec![1, 2, 3, 4]);",
          "    assert_eq!(entries[0], Bucket { hash: HashValue(1), key: \"a\", value: 10 });",
          "    assert_eq!(entries[1], Bucket { hash: HashValue(2), key: \"b\", value: 20 });",
          "    assert_eq!(entries[2], Bucket { hash: HashValue(3), key: \"c\", value: 30 });",
          "    assert_eq!(entries[3], Bucket { hash: HashValue(4), key: \"d\", value: 40 });",
          "    assert!(indices.is_empty() || indices[0] != 0);",
          "    assert!(entries.len() == 4);",
          "    assert!(indices.len() == 4);",
          "    assert!(indices.iter().all(|&i| i >= 0));",
          "    assert!(indices.iter().all(|&i| i < entries.len()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = indexmap::Indices::with_capacity(4);",
          "    indices.push(1);",
          "    indices.push(2);",
          "    ",
          "    let mut entries = vec![",
          "        Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "        Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "        Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "        Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ];",
          "    ",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 4);",
          "}"
        ],
        "oracle": [
          "    let mut indices = indexmap::Indices::with_capacity(4);",
          "    indices.push(1);",
          "    indices.push(2);",
          "    let mut entries = vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ];",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    assert_eq!(indices, vec![1, 2]);",
          "    assert_eq!(entries[0..4], vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ]);",
          "    ref_mut.decrement_indices(0, 4);",
          "    assert_eq!(indices, vec![1, 2]);",
          "    assert_eq!(entries[0..4], vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ]);",
          "    let shifted_entries = &entries[0..4];",
          "    assert!(shifted_entries.len() <= indices.capacity() / 2);",
          "    ref_mut.decrement_indices(1, 3);",
          "    assert_eq!(indices, vec![0, 1]);",
          "    assert_eq!(entries[0..4], vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ]);",
          "    ref_mut.decrement_indices(0, 2);",
          "    assert_eq!(indices, vec![1, 2]);",
          "    assert!(shifted_entries.iter().all(|entry| entry.hash.0 == 1 || entry.hash.0 == 2));",
          "    assert!(shifted_entries.iter().all(|entry| entry.hash.0 != 3 && entry.hash.0 != 4));"
        ],
        "code": [
          "{",
          "    let mut indices = indexmap::Indices::with_capacity(4);",
          "    indices.push(1);",
          "    indices.push(2);",
          "    ",
          "    let mut entries = vec![",
          "        Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "        Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "        Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "        Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ];",
          "    ",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 4);",
          "    let mut indices = indexmap::Indices::with_capacity(4);",
          "    indices.push(1);",
          "    indices.push(2);",
          "    let mut entries = vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ];",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    assert_eq!(indices, vec![1, 2]);",
          "    assert_eq!(entries[0..4], vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ]);",
          "    ref_mut.decrement_indices(0, 4);",
          "    assert_eq!(indices, vec![1, 2]);",
          "    assert_eq!(entries[0..4], vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ]);",
          "    let shifted_entries = &entries[0..4];",
          "    assert!(shifted_entries.len() <= indices.capacity() / 2);",
          "    ref_mut.decrement_indices(1, 3);",
          "    assert_eq!(indices, vec![0, 1]);",
          "    assert_eq!(entries[0..4], vec![",
          "    Bucket { hash: HashValue(1), key: \"x\", value: 100 },",
          "    Bucket { hash: HashValue(2), key: \"y\", value: 200 },",
          "    Bucket { hash: HashValue(3), key: \"z\", value: 300 },",
          "    Bucket { hash: HashValue(4), key: \"w\", value: 400 },",
          "    ]);",
          "    ref_mut.decrement_indices(0, 2);",
          "    assert_eq!(indices, vec![1, 2]);",
          "    assert!(shifted_entries.iter().all(|entry| entry.hash.0 == 1 || entry.hash.0 == 2));",
          "    assert!(shifted_entries.iter().all(|entry| entry.hash.0 != 3 && entry.hash.0 != 4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = indexmap::Indices::with_capacity(8);",
          "    ",
          "    let mut entries: Vec<Bucket<_, _>> = Vec::new();",
          "    ",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 0);",
          "}"
        ],
        "oracle": [
          "    let mut indices = indexmap::Indices::with_capacity(8);",
          "    let mut entries: Vec<Bucket<_, _>> = Vec::new();",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 0);",
          "    assert_eq!(indices.len(), 0);",
          "    assert_eq!(entries.len(), 0);",
          "    assert!(indices.is_empty());",
          "    assert!(entries.is_empty());",
          "    ref_mut.decrement_indices(0, 1);",
          "    assert_eq!(indices.len(), 0);",
          "    assert_eq!(entries.len(), 0);",
          "    ref_mut.decrement_indices(1, 1);",
          "    assert_eq!(indices.len(), 0);",
          "    assert_eq!(entries.len(), 0);",
          "    let indices_capacity = 8;",
          "    indices.reserve(indices_capacity);",
          "    ref_mut.decrement_indices(0, 0);",
          "    assert_eq!(indices.len(), 0);",
          "    assert!(indices.capacity() > 0);"
        ],
        "code": [
          "{",
          "    let mut indices = indexmap::Indices::with_capacity(8);",
          "    ",
          "    let mut entries: Vec<Bucket<_, _>> = Vec::new();",
          "    ",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 0);",
          "    let mut indices = indexmap::Indices::with_capacity(8);",
          "    let mut entries: Vec<Bucket<_, _>> = Vec::new();",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    ref_mut.decrement_indices(0, 0);",
          "    assert_eq!(indices.len(), 0);",
          "    assert_eq!(entries.len(), 0);",
          "    assert!(indices.is_empty());",
          "    assert!(entries.is_empty());",
          "    ref_mut.decrement_indices(0, 1);",
          "    assert_eq!(indices.len(), 0);",
          "    assert_eq!(entries.len(), 0);",
          "    ref_mut.decrement_indices(1, 1);",
          "    assert_eq!(indices.len(), 0);",
          "    assert_eq!(entries.len(), 0);",
          "    let indices_capacity = 8;",
          "    indices.reserve(indices_capacity);",
          "    ref_mut.decrement_indices(0, 0);",
          "    assert_eq!(indices.len(), 0);",
          "    assert!(indices.capacity() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]