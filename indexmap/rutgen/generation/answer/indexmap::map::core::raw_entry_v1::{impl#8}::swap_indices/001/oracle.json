[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestEntries {",
          "        data: Vec<(usize, usize)>,",
          "    }",
          "    ",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.data",
          "        }",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.data",
          "        }",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.data",
          "        }",
          "        fn with_entries<F>(&mut self, f: F)",
          "            where F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.data);",
          "        }",
          "    }",
          "    ",
          "    let mut entries = TestEntries { data: vec![(0, 1), (2, 3), (4, 5)] };",
          "    let index_entry = RawOccupiedEntryMut {",
          "        entries: &mut entries,",
          "        index: hash_table::OccupiedEntry::new(1),",
          "        hash_builder: PhantomData,",
          "    };",
          "    index_entry.swap_indices(2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entries.as_entries(), &[(0, 1), (4, 5), (2, 3)]);",
          "    assert_eq!(index_entry.index(), 2);",
          "    assert!(std::panic::catch_unwind(|| { index_entry.swap_indices(3); }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { index_entry.swap_indices(5); }).is_err());",
          "    index_entry.swap_indices(1);",
          "    assert_eq!(entries.as_entries(), &[(2, 3), (0, 1), (4, 5)]);",
          "    assert_eq!(index_entry.index(), 1);"
        ],
        "code": [
          "{",
          "    struct TestEntries {",
          "        data: Vec<(usize, usize)>,",
          "    }",
          "    ",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.data",
          "        }",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.data",
          "        }",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.data",
          "        }",
          "        fn with_entries<F>(&mut self, f: F)",
          "            where F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.data);",
          "        }",
          "    }",
          "    ",
          "    let mut entries = TestEntries { data: vec![(0, 1), (2, 3), (4, 5)] };",
          "    let index_entry = RawOccupiedEntryMut {",
          "        entries: &mut entries,",
          "        index: hash_table::OccupiedEntry::new(1),",
          "        hash_builder: PhantomData,",
          "    };",
          "    index_entry.swap_indices(2);",
          "    assert_eq!(entries.as_entries(), &[(0, 1), (4, 5), (2, 3)]);",
          "    assert_eq!(index_entry.index(), 2);",
          "    assert!(std::panic::catch_unwind(|| { index_entry.swap_indices(3); }).is_err());",
          "    assert!(std::panic::catch_unwind(|| { index_entry.swap_indices(5); }).is_err());",
          "    index_entry.swap_indices(1);",
          "    assert_eq!(entries.as_entries(), &[(2, 3), (0, 1), (4, 5)]);",
          "    assert_eq!(index_entry.index(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestEntries {",
          "        data: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.data",
          "        }",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.data",
          "        }",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.data",
          "        }",
          "        fn with_entries<F>(&mut self, f: F)",
          "            where F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.data);",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries { data: vec![(0, 1), (2, 3), (4, 5)] };",
          "    let index_entry = RawOccupiedEntryMut {",
          "        entries: &mut entries,",
          "        index: hash_table::OccupiedEntry::new(1),",
          "        hash_builder: PhantomData,",
          "    };",
          "    index_entry.swap_indices(1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entries.as_entries(), &[(0, 1), (2, 3), (4, 5)]);",
          "    assert_eq!(index_entry.index(), 1);",
          "    index_entry.swap_indices(0);",
          "    assert_eq!(entries.as_entries(), &[(2, 3), (0, 1), (4, 5)]);",
          "    assert_eq!(index_entry.index(), 0);",
          "    index_entry.swap_indices(2);",
          "    assert_eq!(entries.as_entries(), &[(4, 5), (0, 1), (2, 3)]);",
          "    assert_eq!(index_entry.index(), 2);",
          "    assert!(std::panic::catch_unwind(|| { index_entry.swap_indices(3); }).is_err());"
        ],
        "code": [
          "{",
          "    struct TestEntries {",
          "        data: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.data",
          "        }",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.data",
          "        }",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.data",
          "        }",
          "        fn with_entries<F>(&mut self, f: F)",
          "            where F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.data);",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries { data: vec![(0, 1), (2, 3), (4, 5)] };",
          "    let index_entry = RawOccupiedEntryMut {",
          "        entries: &mut entries,",
          "        index: hash_table::OccupiedEntry::new(1),",
          "        hash_builder: PhantomData,",
          "    };",
          "    index_entry.swap_indices(1);",
          "    assert_eq!(entries.as_entries(), &[(0, 1), (2, 3), (4, 5)]);",
          "    assert_eq!(index_entry.index(), 1);",
          "    index_entry.swap_indices(0);",
          "    assert_eq!(entries.as_entries(), &[(2, 3), (0, 1), (4, 5)]);",
          "    assert_eq!(index_entry.index(), 0);",
          "    index_entry.swap_indices(2);",
          "    assert_eq!(entries.as_entries(), &[(4, 5), (0, 1), (2, 3)]);",
          "    assert_eq!(index_entry.index(), 2);",
          "    assert!(std::panic::catch_unwind(|| { index_entry.swap_indices(3); }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestEntries {",
          "        data: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.data",
          "        }",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.data",
          "        }",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.data",
          "        }",
          "        fn with_entries<F>(&mut self, f: F)",
          "            where F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.data);",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries { data: vec![(0, 1), (2, 3), (4, 5)] };",
          "    let index_entry = RawOccupiedEntryMut {",
          "        entries: &mut entries,",
          "        index: hash_table::OccupiedEntry::new(0),",
          "        hash_builder: PhantomData,",
          "    };",
          "    index_entry.swap_indices(3);",
          "}"
        ],
        "oracle": [
          "    swap_indices(index_entry, 3);",
          "    assert_eq!(entries.as_entries(), vec![(0, 1), (2, 3), (4, 5)]);",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(5)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(2)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(1)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(4)).is_err());"
        ],
        "code": [
          "{",
          "    struct TestEntries {",
          "        data: Vec<(usize, usize)>,",
          "    }",
          "",
          "    impl Entries for TestEntries {",
          "        type Entry = (usize, usize);",
          "        fn into_entries(self) -> Vec<Self::Entry> {",
          "            self.data",
          "        }",
          "        fn as_entries(&self) -> &[Self::Entry] {",
          "            &self.data",
          "        }",
          "        fn as_entries_mut(&mut self) -> &mut [Self::Entry] {",
          "            &mut self.data",
          "        }",
          "        fn with_entries<F>(&mut self, f: F)",
          "            where F: FnOnce(&mut [Self::Entry]) {",
          "            f(&mut self.data);",
          "        }",
          "    }",
          "",
          "    let mut entries = TestEntries { data: vec![(0, 1), (2, 3), (4, 5)] };",
          "    let index_entry = RawOccupiedEntryMut {",
          "        entries: &mut entries,",
          "        index: hash_table::OccupiedEntry::new(0),",
          "        hash_builder: PhantomData,",
          "    };",
          "    index_entry.swap_indices(3);",
          "    swap_indices(index_entry, 3);",
          "    assert_eq!(entries.as_entries(), vec![(0, 1), (2, 3), (4, 5)]);",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(5)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(0)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(2)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(1)).is_err());",
          "    assert!(std::panic::catch_unwind(|| index_entry.swap_indices(4)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]