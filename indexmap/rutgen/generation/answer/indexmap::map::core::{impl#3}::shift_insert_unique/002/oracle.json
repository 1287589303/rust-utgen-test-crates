[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = hash_table::HashTable::new();",
          "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = 0;",
          "    let hash = HashValue(42);",
          "    let key = 1;",
          "    let value = 10;",
          "    ref_mut.shift_insert_unique(index, hash, key, value);",
          "}"
        ],
        "oracle": [
          "    let indices = hash_table::HashTable::new();",
          "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
          "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = 0;",
          "    let hash = HashValue(42);",
          "    let key = 1;",
          "    let value = 10;",
          "    assert_eq!(entries.len(), 1);",
          "    assert_eq!(entries[0].key, key);",
          "    assert_eq!(entries[0].value, value);",
          "    assert_eq!(entries[0].hash.get(), hash.get());",
          "    assert_eq!(indices.len(), 1);",
          "    assert_eq!(indices.contains_key(&hash.get()), true);"
        ],
        "code": [
          "{",
          "    let mut indices = hash_table::HashTable::new();",
          "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = 0;",
          "    let hash = HashValue(42);",
          "    let key = 1;",
          "    let value = 10;",
          "    ref_mut.shift_insert_unique(index, hash, key, value);",
          "    let indices = hash_table::HashTable::new();",
          "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
          "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = 0;",
          "    let hash = HashValue(42);",
          "    let key = 1;",
          "    let value = 10;",
          "    assert_eq!(entries.len(), 1);",
          "    assert_eq!(entries[0].key, key);",
          "    assert_eq!(entries[0].value, value);",
          "    assert_eq!(entries[0].hash.get(), hash.get());",
          "    assert_eq!(indices.len(), 1);",
          "    assert_eq!(indices.contains_key(&hash.get()), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = hash_table::HashTable::new();",
          "    let mut entries: Vec<Bucket<usize, usize>> = vec![",
          "        Bucket { hash: HashValue(1), key: 2, value: 20 },",
          "        Bucket { hash: HashValue(2), key: 3, value: 30 },",
          "    ];",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = 2; // valid position equal to current length",
          "    let hash = HashValue(42);",
          "    let key = 4;",
          "    let value = 40;",
          "    ref_mut.shift_insert_unique(index, hash, key, value);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ref_mut.entries.len(), 3);",
          "    assert_eq!(ref_mut.entries[2].key, 4);",
          "    assert_eq!(ref_mut.entries[2].value, 40);",
          "    assert_eq!(ref_mut.entries[2].hash, HashValue(42));",
          "    assert_eq!(ref_mut.entries[0].key, 2);",
          "    assert_eq!(ref_mut.entries[1].key, 3);",
          "    assert_ne!(ref_mut.entries[0].hash, ref_mut.entries[1].hash);",
          "    assert_ne!(ref_mut.entries[0].hash, ref_mut.entries[2].hash);",
          "    assert_ne!(ref_mut.entries[1].hash, ref_mut.entries[2].hash);",
          "    assert!(ref_mut.indices.len() == 1);",
          "    assert!(ref_mut.indices.contains_key(&hash.get()));"
        ],
        "code": [
          "{",
          "    let mut indices = hash_table::HashTable::new();",
          "    let mut entries: Vec<Bucket<usize, usize>> = vec![",
          "        Bucket { hash: HashValue(1), key: 2, value: 20 },",
          "        Bucket { hash: HashValue(2), key: 3, value: 30 },",
          "    ];",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = 2; // valid position equal to current length",
          "    let hash = HashValue(42);",
          "    let key = 4;",
          "    let value = 40;",
          "    ref_mut.shift_insert_unique(index, hash, key, value);",
          "    assert_eq!(ref_mut.entries.len(), 3);",
          "    assert_eq!(ref_mut.entries[2].key, 4);",
          "    assert_eq!(ref_mut.entries[2].value, 40);",
          "    assert_eq!(ref_mut.entries[2].hash, HashValue(42));",
          "    assert_eq!(ref_mut.entries[0].key, 2);",
          "    assert_eq!(ref_mut.entries[1].key, 3);",
          "    assert_ne!(ref_mut.entries[0].hash, ref_mut.entries[1].hash);",
          "    assert_ne!(ref_mut.entries[0].hash, ref_mut.entries[2].hash);",
          "    assert_ne!(ref_mut.entries[1].hash, ref_mut.entries[2].hash);",
          "    assert!(ref_mut.indices.len() == 1);",
          "    assert!(ref_mut.indices.contains_key(&hash.get()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut indices = hash_table::HashTable::new();",
          "    let capacity = 5;",
          "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(capacity);",
          "    for i in 0..capacity {",
          "        entries.push(Bucket { hash: HashValue(i as usize), key: i, value: i * 10 });",
          "    }",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = entries.len(); // bound case where index == capacity",
          "    let hash = HashValue(99);",
          "    let key = 6;",
          "    let value = 60;",
          "    ref_mut.shift_insert_unique(index, hash, key, value);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(entries.len(), capacity);",
          "    assert_eq!(entries[index].key, key);",
          "    assert_eq!(entries[index].value, value);",
          "    assert_eq!(entries[index].hash.get(), hash.get());",
          "    assert_eq!(indices.len(), 0);",
          "    assert!(self.entries.len() <= self.entries.capacity());"
        ],
        "code": [
          "{",
          "    let mut indices = hash_table::HashTable::new();",
          "    let capacity = 5;",
          "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(capacity);",
          "    for i in 0..capacity {",
          "        entries.push(Bucket { hash: HashValue(i as usize), key: i, value: i * 10 });",
          "    }",
          "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
          "    let index = entries.len(); // bound case where index == capacity",
          "    let hash = HashValue(99);",
          "    let key = 6;",
          "    let value = 60;",
          "    ref_mut.shift_insert_unique(index, hash, key, value);",
          "    assert_eq!(entries.len(), capacity);",
          "    assert_eq!(entries[index].key, key);",
          "    assert_eq!(entries[index].value, value);",
          "    assert_eq!(entries[index].hash.get(), hash.get());",
          "    assert_eq!(indices.len(), 0);",
          "    assert!(self.entries.len() <= self.entries.capacity());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]