[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(1), Value(\"Value 1\".to_string()));",
          "    map.insert(Key(2), Value(\"Value 2\".to_string()));",
          "",
          "    let result = map.swap_remove_entry(&Key(1));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some((Key(1), Value(\"Value 1\".to_string()))));"
        ],
        "code": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(1), Value(\"Value 1\".to_string()));",
          "    map.insert(Key(2), Value(\"Value 2\".to_string()));",
          "",
          "    let result = map.swap_remove_entry(&Key(1));",
          "    assert_eq!(result, Some((Key(1), Value(\"Value 1\".to_string()))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(3), Value(\"Value 3\".to_string()));",
          "    map.insert(Key(4), Value(\"Value 4\".to_string()));",
          "",
          "    let result = map.swap_remove_entry(&Key(4));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some((Key(4), Value(\"Value 4\".to_string()))));",
          "    assert!(map.contains_key(&Key(3)));",
          "    assert!(!map.contains_key(&Key(4)));",
          "    assert_eq!(map.get(&Key(3)), Some(&Value(\"Value 3\".to_string())));",
          "    assert_eq!(map.swap_remove_entry(&Key(3)), Some((Key(3), Value(\"Value 3\".to_string()))));",
          "    assert!(map.is_empty());"
        ],
        "code": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(3), Value(\"Value 3\".to_string()));",
          "    map.insert(Key(4), Value(\"Value 4\".to_string()));",
          "",
          "    let result = map.swap_remove_entry(&Key(4));",
          "    assert_eq!(result, Some((Key(4), Value(\"Value 4\".to_string()))));",
          "    assert!(map.contains_key(&Key(3)));",
          "    assert!(!map.contains_key(&Key(4)));",
          "    assert_eq!(map.get(&Key(3)), Some(&Value(\"Value 3\".to_string())));",
          "    assert_eq!(map.swap_remove_entry(&Key(3)), Some((Key(3), Value(\"Value 3\".to_string()))));",
          "    assert!(map.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(5), Value(\"Value 5\".to_string()));",
          "    map.insert(Key(6), Value(\"Value 6\".to_string()));",
          "    map.insert(Key(7), Value(\"Value 7\".to_string()));",
          "",
          "    let result = map.swap_remove_entry(&Key(5));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some((Key(5), Value(\"Value 5\".to_string()))));"
        ],
        "code": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(5), Value(\"Value 5\".to_string()));",
          "    map.insert(Key(6), Value(\"Value 6\".to_string()));",
          "    map.insert(Key(7), Value(\"Value 7\".to_string()));",
          "",
          "    let result = map.swap_remove_entry(&Key(5));",
          "    assert_eq!(result, Some((Key(5), Value(\"Value 5\".to_string()))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(8), Value(\"Value 8\".to_string()));",
          "    map.insert(Key(8), Value(\"Value 8 Duplicate\".to_string())); ",
          "",
          "    let result = map.swap_remove_entry(&Key(8));",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    if let Some((key, value)) = result {",
          "    assert_eq!(key, Key(8));",
          "    assert_eq!(value, Value(\"Value 8 Duplicate\".to_string()));",
          "    }",
          "    assert!(!map.contains_key(&Key(8)));"
        ],
        "code": [
          "{",
          "    struct Key(usize);",
          "    struct Value(String);",
          "    ",
          "    let mut map = IndexMap::new();",
          "    map.insert(Key(8), Value(\"Value 8\".to_string()));",
          "    map.insert(Key(8), Value(\"Value 8 Duplicate\".to_string())); ",
          "",
          "    let result = map.swap_remove_entry(&Key(8));",
          "    assert!(result.is_some());",
          "    if let Some((key, value)) = result {",
          "    assert_eq!(key, Key(8));",
          "    assert_eq!(value, Value(\"Value 8 Duplicate\".to_string()));",
          "    }",
          "    assert!(!map.contains_key(&Key(8)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]