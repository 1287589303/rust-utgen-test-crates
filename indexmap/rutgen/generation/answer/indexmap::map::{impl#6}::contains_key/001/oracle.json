[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(\"existing_key\".to_string(), 42);",
          "    let result = my_map.map.contains_key(&\"existing_key\".to_string());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);"
        ],
        "code": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(\"existing_key\".to_string(), 42);",
          "    let result = my_map.map.contains_key(&\"existing_key\".to_string());",
          "    assert_eq!(result, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    let result = my_map.map.contains_key(&\"non_existing_key\".to_string());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    let result = my_map.map.contains_key(&\"non_existing_key\".to_string());",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<i32, String, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(1, \"value_1\".to_string());",
          "    let result = my_map.map.contains_key(&1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);"
        ],
        "code": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<i32, String, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(1, \"value_1\".to_string());",
          "    let result = my_map.map.contains_key(&1);",
          "    assert_eq!(result, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<i32, String, RandomState>,",
          "    }",
          "",
          "    let my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    let result = my_map.map.contains_key(&2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<i32, String, RandomState>,",
          "    }",
          "",
          "    let my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    let result = my_map.map.contains_key(&2);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(\"\".to_string(), 0);",
          "    let result = my_map.map.contains_key(&\"\".to_string());",
          "}"
        ],
        "oracle": [
          "    assert!(result);"
        ],
        "code": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(\"\".to_string(), 0);",
          "    let result = my_map.map.contains_key(&\"\".to_string());",
          "    assert!(result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    let large_key = \"a\".repeat(1000);",
          "    my_map.map.insert(large_key.clone(), 10);",
          "    let result = my_map.map.contains_key(&large_key);",
          "}"
        ],
        "oracle": [
          "    assert!(result == true);"
        ],
        "code": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    let large_key = \"a\".repeat(1000);",
          "    my_map.map.insert(large_key.clone(), 10);",
          "    let result = my_map.map.contains_key(&large_key);",
          "    assert!(result == true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(\"key1\".to_string(), 1);",
          "    my_map.map.insert(\"key2\".to_string(), 2); // Assume key1 and key2 potentially collide",
          "    let result = my_map.map.contains_key(&\"key1\".to_string());",
          "    let result2 = my_map.map.contains_key(&\"key2\".to_string());",
          "}"
        ],
        "oracle": [
          "    my_map.map.contains_key(&\"key1\".to_string()) == true",
          "    my_map.map.contains_key(&\"key2\".to_string()) == true",
          "    my_map.map.contains_key(&\"key3\".to_string()) == false"
        ],
        "code": [
          "{",
          "    struct MyMap {",
          "        map: IndexMap<String, i32, RandomState>,",
          "    }",
          "",
          "    let mut my_map = MyMap {",
          "        map: IndexMap::new(),",
          "    };",
          "    my_map.map.insert(\"key1\".to_string(), 1);",
          "    my_map.map.insert(\"key2\".to_string(), 2); // Assume key1 and key2 potentially collide",
          "    let result = my_map.map.contains_key(&\"key1\".to_string());",
          "    let result2 = my_map.map.contains_key(&\"key2\".to_string());",
          "    my_map.map.contains_key(&\"key1\".to_string()) == true",
          "    my_map.map.contains_key(&\"key2\".to_string()) == true",
          "    my_map.map.contains_key(&\"key3\".to_string()) == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]