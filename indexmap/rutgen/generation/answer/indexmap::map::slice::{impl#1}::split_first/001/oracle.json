[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "    ];",
          "",
          "    let slice = Slice { entries };",
          "    ",
          "    let result = slice.split_first();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    let (first_pair, rest_slice) = result.unwrap();",
          "    assert_eq!(first_pair.0, &slice.entries[0].key);",
          "    assert_eq!(first_pair.1, &slice.entries[0].value);",
          "    assert_eq!(rest_slice.len(), 1);",
          "    assert_eq!(rest_slice.get_index(0).unwrap(), (&slice.entries[1].key, &slice.entries[1].value));"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "    ];",
          "",
          "    let slice = Slice { entries };",
          "    ",
          "    let result = slice.split_first();",
          "    assert!(result.is_some());",
          "    let (first_pair, rest_slice) = result.unwrap();",
          "    assert_eq!(first_pair.0, &slice.entries[0].key);",
          "    assert_eq!(first_pair.1, &slice.entries[0].value);",
          "    assert_eq!(rest_slice.len(), 1);",
          "    assert_eq!(rest_slice.get_index(0).unwrap(), (&slice.entries[1].key, &slice.entries[1].value));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "    ];",
          "",
          "    let slice = Slice { entries };",
          "    ",
          "    let result = slice.split_first();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    let (first, rest) = result.unwrap();",
          "    assert_eq!(first, (&TestKey, &TestValue));",
          "    assert!(rest.is_empty());"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "    ];",
          "",
          "    let slice = Slice { entries };",
          "    ",
          "    let result = slice.split_first();",
          "    assert!(result.is_some());",
          "    let (first, rest) = result.unwrap();",
          "    assert_eq!(first, (&TestKey, &TestValue));",
          "    assert!(rest.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "    ];",
          "",
          "    let slice = Slice { entries };",
          "    ",
          "    let result = slice.split_first();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    let (first_pair, rest_slice) = result.unwrap();",
          "    assert_eq!(first_pair, (&TestKey, &TestValue));",
          "    assert_eq!(rest_slice.len(), 2);"
        ],
        "code": [
          "{",
          "    struct TestKey;",
          "    struct TestValue;",
          "",
          "    let entries = [",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "        Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
          "    ];",
          "",
          "    let slice = Slice { entries };",
          "    ",
          "    let result = slice.split_first();",
          "    assert!(result.is_some());",
          "    let (first_pair, rest_slice) = result.unwrap();",
          "    assert_eq!(first_pair, (&TestKey, &TestValue));",
          "    assert_eq!(rest_slice.len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]