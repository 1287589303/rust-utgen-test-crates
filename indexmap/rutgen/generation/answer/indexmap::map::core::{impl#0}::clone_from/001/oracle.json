[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_map: IndexMapCore<i32, i32> = IndexMapCore::new();",
          "    let other_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);",
          "",
          "    self_map.entries.reserve(5); // set capacity to 5",
          "    for i in 0..5 {",
          "        self_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 10,",
          "        });",
          "    }",
          "",
          "    // other_map has a length greater than self_map's capacity",
          "    for i in 0..10 {",
          "        other_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 20,",
          "        });",
          "    }",
          "",
          "    self_map.clone_from(&other_map);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_map.entries.len(), 10);",
          "    assert!(self_map.entries.capacity() >= other_map.entries.len());",
          "    assert_eq!(self_map.entries[0].key, 0);",
          "    assert_eq!(self_map.entries[0].value, 0);",
          "    assert_eq!(self_map.entries[1].key, 1);",
          "    assert_eq!(self_map.entries[1].value, 10);",
          "    assert_eq!(self_map.entries[5].key, 5);",
          "    assert_eq!(self_map.entries[5].value, 50);",
          "    assert_eq!(self_map.entries[9].key, 9);",
          "    assert_eq!(self_map.entries[9].value, 90);",
          "    assert_eq!(self_map.indices.len(), other_map.entries.len());"
        ],
        "code": [
          "{",
          "    let mut self_map: IndexMapCore<i32, i32> = IndexMapCore::new();",
          "    let other_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);",
          "",
          "    self_map.entries.reserve(5); // set capacity to 5",
          "    for i in 0..5 {",
          "        self_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 10,",
          "        });",
          "    }",
          "",
          "    // other_map has a length greater than self_map's capacity",
          "    for i in 0..10 {",
          "        other_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 20,",
          "        });",
          "    }",
          "",
          "    self_map.clone_from(&other_map);",
          "    assert_eq!(self_map.entries.len(), 10);",
          "    assert!(self_map.entries.capacity() >= other_map.entries.len());",
          "    assert_eq!(self_map.entries[0].key, 0);",
          "    assert_eq!(self_map.entries[0].value, 0);",
          "    assert_eq!(self_map.entries[1].key, 1);",
          "    assert_eq!(self_map.entries[1].value, 10);",
          "    assert_eq!(self_map.entries[5].key, 5);",
          "    assert_eq!(self_map.entries[5].value, 50);",
          "    assert_eq!(self_map.entries[9].key, 9);",
          "    assert_eq!(self_map.entries[9].value, 90);",
          "    assert_eq!(self_map.indices.len(), other_map.entries.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_map: IndexMapCore<i32, i32> = IndexMapCore::new();",
          "    let other_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(15);",
          "",
          "    self_map.entries.reserve(8); // set capacity to 8",
          "    for i in 0..8 {",
          "        self_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 30,",
          "        });",
          "    }",
          "",
          "    // other_map has a length greater than self_map's capacity",
          "    for i in 0..10 {",
          "        other_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 40,",
          "        });",
          "    }",
          "",
          "    self_map.clone_from(&other_map);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_map.entries.len(), 10);",
          "    assert!(self_map.entries.capacity() >= other_map.entries.len());",
          "    for i in 0..10 {",
          "    assert_eq!(self_map.entries[i].key, i);",
          "    assert_eq!(self_map.entries[i].value, i * 40);",
          "    }",
          "    assert_eq!(self_map.indices.capacity(), other_map.entries.len());",
          "    assert_eq!(self_map.entries.capacity(), 10);",
          "    assert!(self_map.indices.len() > 0);"
        ],
        "code": [
          "{",
          "    let mut self_map: IndexMapCore<i32, i32> = IndexMapCore::new();",
          "    let other_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(15);",
          "",
          "    self_map.entries.reserve(8); // set capacity to 8",
          "    for i in 0..8 {",
          "        self_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 30,",
          "        });",
          "    }",
          "",
          "    // other_map has a length greater than self_map's capacity",
          "    for i in 0..10 {",
          "        other_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 40,",
          "        });",
          "    }",
          "",
          "    self_map.clone_from(&other_map);",
          "    assert_eq!(self_map.entries.len(), 10);",
          "    assert!(self_map.entries.capacity() >= other_map.entries.len());",
          "    for i in 0..10 {",
          "    assert_eq!(self_map.entries[i].key, i);",
          "    assert_eq!(self_map.entries[i].value, i * 40);",
          "    }",
          "    assert_eq!(self_map.indices.capacity(), other_map.entries.len());",
          "    assert_eq!(self_map.entries.capacity(), 10);",
          "    assert!(self_map.indices.len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_map: IndexMapCore<i32, i32> = IndexMapCore::new();",
          "    let other_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(20);",
          "",
          "    self_map.entries.reserve(12); // set capacity to 12",
          "    for i in 0..12 {",
          "        self_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 50,",
          "        });",
          "    }",
          "",
          "    // other_map has a length greater than self_map's capacity",
          "    for i in 0..25 {",
          "        other_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 60,",
          "        });",
          "    }",
          "",
          "    self_map.clone_from(&other_map);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_map.entries.len(), 25);",
          "    assert_eq!(self_map.entries.capacity(), 25);",
          "    assert_eq!(self_map.entries[0].key, 0);",
          "    assert_eq!(self_map.entries[0].value, 0);",
          "    assert_eq!(self_map.entries[12].key, 12);",
          "    assert_eq!(self_map.entries[12].value, 720);",
          "    assert_eq!(self_map.entries[24].key, 24);",
          "    assert_eq!(self_map.entries[24].value, 1440);",
          "    assert_eq!(self_map.indices.len(), 25);",
          "    assert!(self_map.indices.capacity() >= other_map.entries.len());"
        ],
        "code": [
          "{",
          "    let mut self_map: IndexMapCore<i32, i32> = IndexMapCore::new();",
          "    let other_map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(20);",
          "",
          "    self_map.entries.reserve(12); // set capacity to 12",
          "    for i in 0..12 {",
          "        self_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 50,",
          "        });",
          "    }",
          "",
          "    // other_map has a length greater than self_map's capacity",
          "    for i in 0..25 {",
          "        other_map.entries.push(Bucket {",
          "            hash: HashValue::default(),",
          "            key: i,",
          "            value: i * 60,",
          "        });",
          "    }",
          "",
          "    self_map.clone_from(&other_map);",
          "    assert_eq!(self_map.entries.len(), 25);",
          "    assert_eq!(self_map.entries.capacity(), 25);",
          "    assert_eq!(self_map.entries[0].key, 0);",
          "    assert_eq!(self_map.entries[0].value, 0);",
          "    assert_eq!(self_map.entries[12].key, 12);",
          "    assert_eq!(self_map.entries[12].value, 720);",
          "    assert_eq!(self_map.entries[24].key, 24);",
          "    assert_eq!(self_map.entries[24].value, 1440);",
          "    assert_eq!(self_map.indices.len(), 25);",
          "    assert!(self_map.indices.capacity() >= other_map.entries.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]