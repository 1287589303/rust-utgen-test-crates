[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut index_map: IndexMap<i32, String, RandomState> = IndexMap::new();",
          "    index_map.insert(1, \"one\".to_string());",
          "    index_map.insert(2, \"two\".to_string());",
          "    ",
          "    let result = index_map.get(&1);",
          "}"
        ],
        "oracle": [
          "    let mut index_map: IndexMap<i32, String, RandomState> = IndexMap::new();",
          "    index_map.insert(1, \"one\".to_string());",
          "    index_map.insert(2, \"two\".to_string());",
          "    assert_eq!(index_map.get(&1), Some(&\"one\".to_string()));",
          "    assert_eq!(index_map.get(&2), Some(&\"two\".to_string()));",
          "    assert_eq!(index_map.get(&3), None);"
        ],
        "code": [
          "{",
          "    let mut index_map: IndexMap<i32, String, RandomState> = IndexMap::new();",
          "    index_map.insert(1, \"one\".to_string());",
          "    index_map.insert(2, \"two\".to_string());",
          "    ",
          "    let result = index_map.get(&1);",
          "    let mut index_map: IndexMap<i32, String, RandomState> = IndexMap::new();",
          "    index_map.insert(1, \"one\".to_string());",
          "    index_map.insert(2, \"two\".to_string());",
          "    assert_eq!(index_map.get(&1), Some(&\"one\".to_string()));",
          "    assert_eq!(index_map.get(&2), Some(&\"two\".to_string()));",
          "    assert_eq!(index_map.get(&3), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut index_map: IndexMap<String, i32, RandomState> = IndexMap::new();",
          "    index_map.insert(\"apple\".to_string(), 5);",
          "    index_map.insert(\"banana\".to_string(), 3);",
          "    ",
          "    let result = index_map.get(&\"banana\".to_string());",
          "}"
        ],
        "oracle": [
          "    let Some(value) = result;",
          "    assert_eq!(value, &3);"
        ],
        "code": [
          "{",
          "    let mut index_map: IndexMap<String, i32, RandomState> = IndexMap::new();",
          "    index_map.insert(\"apple\".to_string(), 5);",
          "    index_map.insert(\"banana\".to_string(), 3);",
          "    ",
          "    let result = index_map.get(&\"banana\".to_string());",
          "    let Some(value) = result;",
          "    assert_eq!(value, &3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Hash, Eq, PartialEq)]",
          "    struct Key {",
          "        id: i32,",
          "    }",
          "    ",
          "    let mut index_map: IndexMap<Key, String, RandomState> = IndexMap::new();",
          "    index_map.insert(Key { id: 1 }, \"value1\".to_string());",
          "    ",
          "    let result = index_map.get(&Key { id: 1 });",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(&\"value1\".to_string()));"
        ],
        "code": [
          "{",
          "    #[derive(Hash, Eq, PartialEq)]",
          "    struct Key {",
          "        id: i32,",
          "    }",
          "    ",
          "    let mut index_map: IndexMap<Key, String, RandomState> = IndexMap::new();",
          "    index_map.insert(Key { id: 1 }, \"value1\".to_string());",
          "    ",
          "    let result = index_map.get(&Key { id: 1 });",
          "    assert_eq!(result, Some(&\"value1\".to_string()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut index_map: IndexMap<u32, String, RandomState> = IndexMap::new();",
          "    index_map.insert(u32::MIN, \"min_value\".to_string());",
          "    index_map.insert(u32::MAX, \"max_value\".to_string());",
          "",
          "    let min_value_result = index_map.get(&u32::MIN);",
          "    let max_value_result = index_map.get(&u32::MAX);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(min_value_result, Some(&\"min_value\".to_string()));",
          "    assert_eq!(max_value_result, Some(&\"max_value\".to_string()));"
        ],
        "code": [
          "{",
          "    let mut index_map: IndexMap<u32, String, RandomState> = IndexMap::new();",
          "    index_map.insert(u32::MIN, \"min_value\".to_string());",
          "    index_map.insert(u32::MAX, \"max_value\".to_string());",
          "",
          "    let min_value_result = index_map.get(&u32::MIN);",
          "    let max_value_result = index_map.get(&u32::MAX);",
          "    assert_eq!(min_value_result, Some(&\"min_value\".to_string()));",
          "    assert_eq!(max_value_result, Some(&\"max_value\".to_string()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]