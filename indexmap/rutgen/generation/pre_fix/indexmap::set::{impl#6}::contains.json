{
  "name": "indexmap::set::{impl#6}::contains",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:124:1:124:13"
  },
  "visible": true,
  "loc": "src/set.rs:638:5:643:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "type of T being checked in IndexSet<T, S> can be any hashable type | Q can be any reference to a type that implements Hash and Equivalent<T> | Test with typical T values (like integers, strings) | Edge cases where T is empty or contains minimal entries | Test with Q being exactly identical, similar but different types, and edge cases with null or non-existent entries | Test for performance with large sets and varying sizes of T | Validate against custom hashers by varying S.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    set.insert(1);",
                "    set.insert(2);",
                "    assert!(set.contains(&1));",
                "    assert!(set.contains(&2));",
                "    assert!(!set.contains(&3));",
                "}"
              ],
              "oracle": [
                "    assert!(set.contains(&1) == true);",
                "    assert!(set.contains(&2) == true);",
                "    assert!(set.contains(&3) == false);"
              ],
              "code": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    set.insert(1);",
                "    set.insert(2);",
                "    assert!(set.contains(&1));",
                "    assert!(set.contains(&2));",
                "    assert!(!set.contains(&3));",
                "    assert!(set.contains(&1) == true);",
                "    assert!(set.contains(&2) == true);",
                "    assert!(set.contains(&3) == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<String, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    set.insert(\"hello\".to_string());",
                "    set.insert(\"world\".to_string());",
                "    assert!(set.contains(&\"hello\".to_string()));",
                "    assert!(set.contains(&\"world\".to_string()));",
                "    assert!(!set.contains(&\"rust\".to_string()));",
                "}"
              ],
              "oracle": [
                "    assert!(set.contains(&\"hello\".to_string()));",
                "    assert!(set.contains(&\"world\".to_string()));",
                "    assert!(!set.contains(&\"rust\".to_string()));"
              ],
              "code": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<String, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    set.insert(\"hello\".to_string());",
                "    set.insert(\"world\".to_string());",
                "    assert!(set.contains(&\"hello\".to_string()));",
                "    assert!(set.contains(&\"world\".to_string()));",
                "    assert!(!set.contains(&\"rust\".to_string()));",
                "    assert!(set.contains(&\"hello\".to_string()));",
                "    assert!(set.contains(&\"world\".to_string()));",
                "    assert!(!set.contains(&\"rust\".to_string()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    assert!(!set.contains(&1));    ",
                "}"
              ],
              "oracle": [
                "    assert!(set.contains(&1) == false);",
                "    assert!(set.contains(&0) == false);",
                "    assert!(set.contains(&2) == false);",
                "    assert!(set.contains(&-1) == false);",
                "    assert!(set.contains(&3) == false);"
              ],
              "code": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    assert!(!set.contains(&1));    ",
                "    assert!(set.contains(&1) == false);",
                "    assert!(set.contains(&0) == false);",
                "    assert!(set.contains(&2) == false);",
                "    assert!(set.contains(&-1) == false);",
                "    assert!(set.contains(&3) == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    set.insert(1);",
                "    assert!(set.contains(&1));",
                "    // This test assumes that different types will not match",
                "    assert!(!set.contains(&1.0));",
                "}"
              ],
              "oracle": [
                "    assert!(set.contains(&1));",
                "    assert!(!set.contains(&1.0));",
                "    assert!(!set.contains(&2));",
                "    set.insert(2);",
                "    assert!(set.contains(&2));",
                "    set.insert(3);",
                "    assert!(set.contains(&3));",
                "    assert!(!set.contains(&4));",
                "    set.remove(&1);",
                "    assert!(!set.contains(&1));",
                "    set.swap_remove(&2);",
                "    assert!(!set.contains(&2));",
                "    set.shift_remove(&3);",
                "    assert!(!set.contains(&3));",
                "    assert!(!set.contains(&4));"
              ],
              "code": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    set.insert(1);",
                "    assert!(set.contains(&1));",
                "    // This test assumes that different types will not match",
                "    assert!(!set.contains(&1.0));",
                "    assert!(set.contains(&1));",
                "    assert!(!set.contains(&1.0));",
                "    assert!(!set.contains(&2));",
                "    set.insert(2);",
                "    assert!(set.contains(&2));",
                "    set.insert(3);",
                "    assert!(set.contains(&3));",
                "    assert!(!set.contains(&4));",
                "    set.remove(&1);",
                "    assert!(!set.contains(&1));",
                "    set.swap_remove(&2);",
                "    assert!(!set.contains(&2));",
                "    set.shift_remove(&3);",
                "    assert!(!set.contains(&3));",
                "    assert!(!set.contains(&4));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    for i in 0..1000 {",
                "        set.insert(i);",
                "    }",
                "    ",
                "    for i in 0..1000 {",
                "        assert!(set.contains(&i));",
                "    }",
                "    assert!(!set.contains(&1001));",
                "}"
              ],
              "oracle": [
                "    assert!(set.contains(&0));",
                "    assert!(set.contains(&999));",
                "    assert!(!set.contains(&-1));",
                "    assert!(set.contains(&500));",
                "    assert!(!set.contains(&1002));"
              ],
              "code": [
                "{",
                "    struct MyHashBuilder;",
                "    ",
                "    let mut set: IndexSet<i32, MyHashBuilder> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyHashBuilder },",
                "    };",
                "",
                "    for i in 0..1000 {",
                "        set.insert(i);",
                "    }",
                "    ",
                "    for i in 0..1000 {",
                "        assert!(set.contains(&i));",
                "    }",
                "    assert!(!set.contains(&1001));",
                "    assert!(set.contains(&0));",
                "    assert!(set.contains(&999));",
                "    assert!(!set.contains(&-1));",
                "    assert!(set.contains(&500));",
                "    assert!(!set.contains(&1002));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MyCustomHasher;",
                "    ",
                "    let mut set: IndexSet<i32, MyCustomHasher> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyCustomHasher },",
                "    };",
                "",
                "    set.insert(10);",
                "    set.insert(20);",
                "    assert!(set.contains(&10));",
                "    assert!(set.contains(&20));",
                "    assert!(!set.contains(&30));",
                "}"
              ],
              "oracle": [
                "    assert!(set.contains(&10) == true);",
                "    assert!(set.contains(&20) == true);",
                "    assert!(set.contains(&30) == false);"
              ],
              "code": [
                "{",
                "    struct MyCustomHasher;",
                "    ",
                "    let mut set: IndexSet<i32, MyCustomHasher> = IndexSet {",
                "        map: IndexMap { core: IndexMapCore::new(), hash_builder: MyCustomHasher },",
                "    };",
                "",
                "    set.insert(10);",
                "    set.insert(20);",
                "    assert!(set.contains(&10));",
                "    assert!(set.contains(&20));",
                "    assert!(!set.contains(&30));",
                "    assert!(set.contains(&10) == true);",
                "    assert!(set.contains(&20) == true);",
                "    assert!(set.contains(&30) == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}