{
  "name": "indexmap::map::core::{impl#2}::retain_in_order",
  "mod_info": {
    "name": "map::core",
    "loc": "src/map.rs:4:1:4:10"
  },
  "visible": true,
  "loc": "src/map/core.rs:497:5:506:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.entries.len() < self.indices.len() at line 503 is true\n"
      ],
      "input_infer": "self.entries.len() = 1 to MAX_ENTRIES_CAPACITY, self.indices.len() > self.entries.len()\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                "    map.indices.push(0); // Simulating that indices length > entries length",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 10 });",
                "    ",
                "    map.retain_in_order(|_key, value| {",
                "        *value > 5",
                "    });",
                "}"
              ],
              "oracle": [
                "    let map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                "    map.indices.push(0);",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 10 });",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert!(map.indices.len() > map.entries.len());",
                "    map.retain_in_order(|_key, value| { *value > 5 });",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert_eq!(map.entries[0].value, 10);"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                "    map.indices.push(0); // Simulating that indices length > entries length",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 10 });",
                "    ",
                "    map.retain_in_order(|_key, value| {",
                "        *value > 5",
                "    });",
                "    let map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                "    map.indices.push(0);",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 10 });",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert!(map.indices.len() > map.entries.len());",
                "    map.retain_in_order(|_key, value| { *value > 5 });",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert_eq!(map.entries[0].value, 10);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::with_capacity(10);",
                "    map.indices.push(0); // Simulating that indices length > entries length",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 10 });",
                "    map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 5 });",
                "",
                "    map.retain_in_order(|_key, value| {",
                "        *value > 6",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.entries.len(), 1);",
                "    assert_eq!(map.entries[0].key, 1);",
                "    assert_eq!(map.entries[0].value, 10);",
                "    assert!(map.indices.len() > map.entries.len());",
                "    assert_eq!(map.indices.len(), 1);",
                "    assert_eq!(map.entries[0].hash, HashValue(1));"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::with_capacity(10);",
                "    map.indices.push(0); // Simulating that indices length > entries length",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 10 });",
                "    map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 5 });",
                "",
                "    map.retain_in_order(|_key, value| {",
                "        *value > 6",
                "    });",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert_eq!(map.entries[0].key, 1);",
                "    assert_eq!(map.entries[0].value, 10);",
                "    assert!(map.indices.len() > map.entries.len());",
                "    assert_eq!(map.indices.len(), 1);",
                "    assert_eq!(map.entries[0].hash, HashValue(1));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::with_capacity(10);",
                "    map.indices.push(0); // Simulating that indices length > entries length",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 2 });",
                "    map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 3 });",
                "",
                "    map.retain_in_order(|_key, _value| false);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.entries.len(), 2);",
                "    assert_eq!(map.indices.len(), 1);",
                "    assert_eq!(map.entries[0].key, 1);",
                "    assert_eq!(map.entries[0].value, 2);",
                "    assert_eq!(map.entries[1].key, 2);",
                "    assert_eq!(map.entries[1].value, 3);"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::with_capacity(10);",
                "    map.indices.push(0); // Simulating that indices length > entries length",
                "    map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 2 });",
                "    map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 3 });",
                "",
                "    map.retain_in_order(|_key, _value| false);",
                "    assert_eq!(map.entries.len(), 2);",
                "    assert_eq!(map.indices.len(), 1);",
                "    assert_eq!(map.entries[0].key, 1);",
                "    assert_eq!(map.entries[0].value, 2);",
                "    assert_eq!(map.entries[1].key, 2);",
                "    assert_eq!(map.entries[1].value, 3);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let max_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::with_capacity(max_capacity);",
                "    for i in 0..max_capacity {",
                "        map.indices.push(i); // Simulating that indices length > entries length",
                "        map.entries.push(Bucket { hash: HashValue(i as u64), key: i, value: i as usize });",
                "    }",
                "",
                "    map.retain_in_order(|_key, value| {",
                "        *value % 2 == 0",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.len(), max_capacity);",
                "    assert!(map.entries.iter().all(|entry| entry.value % 2 == 0));",
                "    assert!(map.entries.len() < map.indices.len());",
                "    assert!(map.indices.iter().all(|&index| index < max_capacity));",
                "    assert_eq!(map.entries.len(), map.indices.len() / 2);",
                "    assert_eq!(map.entries.iter().map(|entry| entry.value).count(), map.entries.len());",
                "    assert!(map.indices.iter().all(|index| {",
                "    let entry_value = map.entries.get(*index);",
                "    entry_value.is_some() && entry_value.unwrap().value % 2 == 0",
                "    }));"
              ],
              "code": [
                "{",
                "    let max_capacity = IndexMapCore::<usize, usize>::MAX_ENTRIES_CAPACITY;",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::with_capacity(max_capacity);",
                "    for i in 0..max_capacity {",
                "        map.indices.push(i); // Simulating that indices length > entries length",
                "        map.entries.push(Bucket { hash: HashValue(i as u64), key: i, value: i as usize });",
                "    }",
                "",
                "    map.retain_in_order(|_key, value| {",
                "        *value % 2 == 0",
                "    });",
                "    assert_eq!(map.len(), max_capacity);",
                "    assert!(map.entries.iter().all(|entry| entry.value % 2 == 0));",
                "    assert!(map.entries.len() < map.indices.len());",
                "    assert!(map.indices.iter().all(|&index| index < max_capacity));",
                "    assert_eq!(map.entries.len(), map.indices.len() / 2);",
                "    assert_eq!(map.entries.iter().map(|entry| entry.value).count(), map.entries.len());",
                "    assert!(map.indices.iter().all(|index| {",
                "    let entry_value = map.entries.get(*index);",
                "    entry_value.is_some() && entry_value.unwrap().value % 2 == 0",
                "    }));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.entries.len() < self.indices.len() at line 503 is false, with bound self.entries.len() == self.indices.len()\n"
      ],
      "input_infer": "self.entries.len() must be greater than 0 and equal to self.indices.len() for the retain_in_order function, with valid function F implementations to test varying key-value pairs including edge cases like entries with maximum size and handling of empty values.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();",
                "    map.push_entry(0, 1, \"value1\".to_string());",
                "    map.push_entry(0, 2, \"value2\".to_string());",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        *value = format!(\"updated_{}\", value);",
                "        *key % 2 == 0",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.entries.len(), 2);",
                "    assert_eq!(map.entries[0].value, \"updated_value1\");",
                "    assert_eq!(map.entries[1].value, \"updated_value2\");",
                "    assert_eq!(map.entries[0].key, 2);",
                "    assert_eq!(map.len(), 1);"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<usize, String> = IndexMapCore::new();",
                "    map.push_entry(0, 1, \"value1\".to_string());",
                "    map.push_entry(0, 2, \"value2\".to_string());",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        *value = format!(\"updated_{}\", value);",
                "        *key % 2 == 0",
                "    });",
                "    assert_eq!(map.entries.len(), 2);",
                "    assert_eq!(map.entries[0].value, \"updated_value1\");",
                "    assert_eq!(map.entries[1].value, \"updated_value2\");",
                "    assert_eq!(map.entries[0].key, 2);",
                "    assert_eq!(map.len(), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<String, usize> = IndexMapCore::with_capacity(2);",
                "    map.push_entry(0, \"key1\".to_string(), 1);",
                "    map.push_entry(0, \"key2\".to_string(), 2);",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        *value += 1;",
                "        key.len() > 3",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.entries.len(), map.indices.len());",
                "    assert_eq!(map.pop(), Some((\"key2\".to_string(), 3)));",
                "    assert_eq!(map.pop(), None);",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.capacity(), 2);",
                "    assert_eq!(map.indices.len(), 1);",
                "    assert_eq!(map.entries[0].key, \"key1\".to_string());"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<String, usize> = IndexMapCore::with_capacity(2);",
                "    map.push_entry(0, \"key1\".to_string(), 1);",
                "    map.push_entry(0, \"key2\".to_string(), 2);",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        *value += 1;",
                "        key.len() > 3",
                "    });",
                "    assert_eq!(map.entries.len(), map.indices.len());",
                "    assert_eq!(map.pop(), Some((\"key2\".to_string(), 3)));",
                "    assert_eq!(map.pop(), None);",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.capacity(), 2);",
                "    assert_eq!(map.indices.len(), 1);",
                "    assert_eq!(map.entries[0].key, \"key1\".to_string());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<(u32, char), Option<u32>> = IndexMapCore::new();",
                "    map.push_entry(0, (1, 'a'), None);",
                "    map.push_entry(0, (2, 'b'), Some(2));",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        if let Some(v) = value {",
                "            *v = *v + 10;",
                "        }",
                "        key.0 > 1",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert_eq!(map.entries[0].key, (2, 'b'));",
                "    assert_eq!(map.entries[0].value, Some(12));",
                "    assert!(map.indices.len() == map.entries.len());"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<(u32, char), Option<u32>> = IndexMapCore::new();",
                "    map.push_entry(0, (1, 'a'), None);",
                "    map.push_entry(0, (2, 'b'), Some(2));",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        if let Some(v) = value {",
                "            *v = *v + 10;",
                "        }",
                "        key.0 > 1",
                "    });",
                "    assert_eq!(map.len(), 1);",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert_eq!(map.entries[0].key, (2, 'b'));",
                "    assert_eq!(map.entries[0].value, Some(12));",
                "    assert!(map.indices.len() == map.entries.len());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<u64, Vec<u8>> = IndexMapCore::new();",
                "    map.push_entry(0, u64::MAX, vec![1, 2, 3]);",
                "    map.push_entry(0, u64::MAX - 1, vec![]);",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        value.push(4);",
                "        *key < u64::MAX",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.indices.len(), 2);",
                "    assert_eq!(map.entries.len(), 2);",
                "    assert_eq!(map.entries[0].value, vec![1, 2, 3, 4]);",
                "    assert_eq!(map.entries[1].value, vec![]);",
                "    assert_eq!(map.entries[0].key, u64::MAX - 1);"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<u64, Vec<u8>> = IndexMapCore::new();",
                "    map.push_entry(0, u64::MAX, vec![1, 2, 3]);",
                "    map.push_entry(0, u64::MAX - 1, vec![]);",
                "    assert_eq!(map.len(), 2);",
                "    map.retain_in_order(|key, value| {",
                "        value.push(4);",
                "        *key < u64::MAX",
                "    });",
                "    assert_eq!(map.indices.len(), 2);",
                "    assert_eq!(map.entries.len(), 2);",
                "    assert_eq!(map.entries[0].value, vec![1, 2, 3, 4]);",
                "    assert_eq!(map.entries[1].value, vec![]);",
                "    assert_eq!(map.entries[0].key, u64::MAX - 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                "    for i in 0..5 {",
                "        map.push_entry(0, i, i * 10);",
                "    }",
                "    assert_eq!(map.len(), 5);",
                "    map.retain_in_order(|key, value| {",
                "        if *key == 3 {",
                "            *value = 0; // Special case for key 3",
                "            true",
                "        } else {",
                "            *key != 0",
                "        }",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.len(), 5);",
                "    assert_eq!(map.entries.len(), 5);",
                "    assert_eq!(map.indices.len(), 5);",
                "    assert_eq!(map.entries[0].key, 1);",
                "    assert_eq!(map.entries[1].key, 2);",
                "    assert_eq!(map.entries[2].key, 3);",
                "    assert_eq!(map.entries[3].key, 4);",
                "    assert_eq!(map.entries[4].key, 0);",
                "    assert_eq!(map.entries[0].value, 10);",
                "    assert_eq!(map.entries[1].value, 20);",
                "    assert_eq!(map.entries[2].value, 0);",
                "    assert_eq!(map.entries[3].value, 40);",
                "    assert_eq!(map.entries[4].value, 0);"
              ],
              "code": [
                "{",
                "    let mut map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                "    for i in 0..5 {",
                "        map.push_entry(0, i, i * 10);",
                "    }",
                "    assert_eq!(map.len(), 5);",
                "    map.retain_in_order(|key, value| {",
                "        if *key == 3 {",
                "            *value = 0; // Special case for key 3",
                "            true",
                "        } else {",
                "            *key != 0",
                "        }",
                "    });",
                "    assert_eq!(map.len(), 5);",
                "    assert_eq!(map.entries.len(), 5);",
                "    assert_eq!(map.indices.len(), 5);",
                "    assert_eq!(map.entries[0].key, 1);",
                "    assert_eq!(map.entries[1].key, 2);",
                "    assert_eq!(map.entries[2].key, 3);",
                "    assert_eq!(map.entries[3].key, 4);",
                "    assert_eq!(map.entries[4].key, 0);",
                "    assert_eq!(map.entries[0].value, 10);",
                "    assert_eq!(map.entries[1].value, 20);",
                "    assert_eq!(map.entries[2].value, 0);",
                "    assert_eq!(map.entries[3].value, 40);",
                "    assert_eq!(map.entries[4].value, 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}