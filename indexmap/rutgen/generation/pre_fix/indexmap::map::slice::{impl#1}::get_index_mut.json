{
  "name": "indexmap::map::slice::{impl#1}::get_index_mut",
  "mod_info": {
    "name": "map::slice",
    "loc": "src/map.rs:7:1:7:11"
  },
  "visible": true,
  "loc": "src/map/slice.rs:84:5:86:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "0 <= index < self.len() where self.len() > 0; test with index = 0, index = self.len() - 1, index = self.len(), index = self.len() + 1 for boundary cases; test with self.len() = 0 for empty case.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestKey;",
                "    struct TestValue;",
                "    ",
                "    let mut slice = Slice {",
                "        entries: [",
                "            Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
                "            Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
                "        ],",
                "    };",
                "",
                "    let index_0 = slice.get_index_mut(0);",
                "    let index_last = slice.get_index_mut(slice.len() - 1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_0.is_some(), true);",
                "    assert_eq!(index_last.is_some(), true);",
                "    assert_eq!(index_0.unwrap().0, &slice.entries[0].key);",
                "    assert_eq!(index_last.unwrap().0, &slice.entries[slice.len() - 1].key);",
                "    assert!(slice.get_index_mut(slice.len()).is_none());",
                "    assert!(slice.get_index_mut(2).is_none());"
              ],
              "code": [
                "{",
                "    struct TestKey;",
                "    struct TestValue;",
                "    ",
                "    let mut slice = Slice {",
                "        entries: [",
                "            Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
                "            Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
                "        ],",
                "    };",
                "",
                "    let index_0 = slice.get_index_mut(0);",
                "    let index_last = slice.get_index_mut(slice.len() - 1);",
                "    assert_eq!(index_0.is_some(), true);",
                "    assert_eq!(index_last.is_some(), true);",
                "    assert_eq!(index_0.unwrap().0, &slice.entries[0].key);",
                "    assert_eq!(index_last.unwrap().0, &slice.entries[slice.len() - 1].key);",
                "    assert!(slice.get_index_mut(slice.len()).is_none());",
                "    assert!(slice.get_index_mut(2).is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestKey;",
                "    struct TestValue;",
                "",
                "    let mut slice = Slice {",
                "        entries: [",
                "            Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
                "        ],",
                "    };",
                "",
                "    let index_out_of_bounds = slice.get_index_mut(slice.len());",
                "    let index_out_of_bounds_plus_one = slice.get_index_mut(slice.len() + 1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(slice.get_index_mut(0).is_some(), true);",
                "    assert_eq!(slice.get_index_mut(slice.len()), None);",
                "    assert_eq!(slice.get_index_mut(slice.len() + 1), None);"
              ],
              "code": [
                "{",
                "    struct TestKey;",
                "    struct TestValue;",
                "",
                "    let mut slice = Slice {",
                "        entries: [",
                "            Bucket { hash: HashValue::default(), key: TestKey, value: TestValue },",
                "        ],",
                "    };",
                "",
                "    let index_out_of_bounds = slice.get_index_mut(slice.len());",
                "    let index_out_of_bounds_plus_one = slice.get_index_mut(slice.len() + 1);",
                "    assert_eq!(slice.get_index_mut(0).is_some(), true);",
                "    assert_eq!(slice.get_index_mut(slice.len()), None);",
                "    assert_eq!(slice.get_index_mut(slice.len() + 1), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestKey;",
                "    struct TestValue;",
                "",
                "    let mut slice = Slice::new_mut();",
                "",
                "    let index_empty = slice.get_index_mut(0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(slice.len(), 0);",
                "    assert!(index_empty.is_none());"
              ],
              "code": [
                "{",
                "    struct TestKey;",
                "    struct TestValue;",
                "",
                "    let mut slice = Slice::new_mut();",
                "",
                "    let index_empty = slice.get_index_mut(0);",
                "    assert_eq!(slice.len(), 0);",
                "    assert!(index_empty.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}