{
  "name": "indexmap::util::slice_eq",
  "mod_info": {
    "name": "util",
    "loc": "src/lib.rs:121:1:121:10"
  },
  "visible": true,
  "loc": "src/util.rs:62:1:78:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: left.len() != right.len() at line 63 is true\n",
        "expected return value/type: false\n"
      ],
      "input_infer": "left: any non-empty slice, right: any slice of different length than left\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[1, 2, 3];",
                "    let right = &[1, 2];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left = &[1, 2, 3];",
                "    let right = &[1, 2];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[\"a\", \"b\"];",
                "    let right = &[\"a\", \"b\", \"c\"];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left = &[\"a\", \"b\"];",
                "    let right = &[\"a\", \"b\", \"c\"];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[3.14, 2.71];",
                "    let right = &[3.14];",
                "    let result = slice_eq(left, right, |a, b| (a - b).abs() < f64::EPSILON);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left = &[3.14, 2.71];",
                "    let right = &[3.14];",
                "    let result = slice_eq(left, right, |a, b| (a - b).abs() < f64::EPSILON);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[true, false];",
                "    let right = &[false];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left = &[true, false];",
                "    let right = &[false];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left: &[i32] = &[];",
                "    let right: &[i32] = &[1];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left: &[i32] = &[];",
                "    let right: &[i32] = &[1];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: left.len() != right.len() at line 63 is false\n",
        "precondition: i in 0..left.len() at line 70 is true\n",
        "precondition: eq(&left[i], &right[i]) at line 72 is true\n",
        "precondition: i in 0..left.len() at line 70 is false\n",
        "expected return value/type: true\n"
      ],
      "input_infer": "left and right are non-empty slices of the same length with matching elements based on the eq function; examples include left = [1, 2, 3], right = [1, 2, 3] using eq as a reference equality check.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = [1, 2, 3];",
                "    let right = [1, 2, 3];",
                "    let eq = |a: &i32, b: &i32| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let left = [1, 2, 3];",
                "    let right = [1, 2, 3];",
                "    let eq = |a: &i32, b: &i32| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = [0, 1, 2];",
                "    let right = [0, 1, 2];",
                "    let eq = |a: &i32, b: &i32| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    assert!(result);",
                "    assert!(slice_eq(&[], &[], eq));",
                "    assert!(slice_eq(&[1], &[1], eq));",
                "    assert!(slice_eq(&[1, 2], &[1, 2], eq));",
                "    assert!(slice_eq(&[1, 2, 3], &[1, 2, 3], eq));",
                "    assert!(!slice_eq(&[1, 2, 3], &[1, 2], eq));",
                "    assert!(!slice_eq(&[1, 2, 3], &[3, 2, 1], eq));",
                "    assert!(!slice_eq(&[1, 2, 3], &[1, 2, 4], eq));"
              ],
              "code": [
                "{",
                "    let left = [0, 1, 2];",
                "    let right = [0, 1, 2];",
                "    let eq = |a: &i32, b: &i32| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "    assert_eq!(result, true);",
                "    assert!(result);",
                "    assert!(slice_eq(&[], &[], eq));",
                "    assert!(slice_eq(&[1], &[1], eq));",
                "    assert!(slice_eq(&[1, 2], &[1, 2], eq));",
                "    assert!(slice_eq(&[1, 2, 3], &[1, 2, 3], eq));",
                "    assert!(!slice_eq(&[1, 2, 3], &[1, 2], eq));",
                "    assert!(!slice_eq(&[1, 2, 3], &[3, 2, 1], eq));",
                "    assert!(!slice_eq(&[1, 2, 3], &[1, 2, 4], eq));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = [\"hello\", \"world\"];",
                "    let right = [\"hello\", \"world\"];",
                "    let eq = |a: &str, b: &str| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let left = [\"hello\", \"world\"];",
                "    let right = [\"hello\", \"world\"];",
                "    let eq = |a: &str, b: &str| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = [1.0, 2.0, 3.0];",
                "    let right = [1.0, 2.0, 3.0];",
                "    let eq = |a: &f64, b: &f64| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let left = [1.0, 2.0, 3.0];",
                "    let right = [1.0, 2.0, 3.0];",
                "    let eq = |a: &f64, b: &f64| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let a = 42;",
                "    let left = [&a, &a];",
                "    let right = [&a, &a];",
                "    let eq = |a: &&i32, b: &&i32| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let a = 42;",
                "    let left = [&a, &a];",
                "    let right = [&a, &a];",
                "    let eq = |a: &&i32, b: &&i32| a == b;",
                "    let result = slice_eq(&left, &right, eq);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: left.len() != right.len() at line 63 is false\n",
        "precondition: i in 0..left.len() at line 70 is true\n",
        "precondition: eq(&left[i], &right[i]) at line 72 is false\n",
        "expected return value/type: false\n"
      ],
      "input_infer": "left and right slices with equal lengths where eq function returns false for at least one pair of corresponding elements\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[1, 2, 3];",
                "    let right = &[1, 2, 4];",
                "    let eq = |a: &i32, b: &i32| *a == *b;",
                "",
                "    let result = slice_eq(left, right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left = &[1, 2, 3];",
                "    let right = &[1, 2, 4];",
                "    let eq = |a: &i32, b: &i32| *a == *b;",
                "",
                "    let result = slice_eq(left, right, eq);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[\"apple\", \"banana\", \"cherry\"];",
                "    let right = &[\"apple\", \"banana\", \"orange\"];",
                "    let eq = |a: &&str, b: &&str| *a == *b;",
                "",
                "    let result = slice_eq(left, right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left = &[\"apple\", \"banana\", \"cherry\"];",
                "    let right = &[\"apple\", \"banana\", \"orange\"];",
                "    let eq = |a: &&str, b: &&str| *a == *b;",
                "",
                "    let result = slice_eq(left, right, eq);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[5, 6, 7];",
                "    let right = &[5, 8, 7];",
                "    let eq = |a: &i32, b: &i32| *a == *b;",
                "",
                "    let result = slice_eq(left, right, eq);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, false);"
              ],
              "code": [
                "{",
                "    let left = &[5, 6, 7];",
                "    let right = &[5, 8, 7];",
                "    let eq = |a: &i32, b: &i32| *a == *b;",
                "",
                "    let result = slice_eq(left, right, eq);",
                "    assert_eq!(result, false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "precondition: left.len() != right.len() at line 63 is false\n",
        "precondition: i in 0..left.len() at line 70 is false\n",
        "expected return value/type: true\n"
      ],
      "input_infer": "left and right are non-empty slices of equal length, containing comparable elements T and U, with eq function returning true for all corresponding element pairs\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[1, 2, 3];",
                "    let right = &[1, 2, 3];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let left = &[1, 2, 3];",
                "    let right = &[1, 2, 3];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[\"hello\", \"world\"];",
                "    let right = &[\"hello\", \"world\"];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let left = &[\"hello\", \"world\"];",
                "    let right = &[\"hello\", \"world\"];",
                "    let result = slice_eq(left, right, |a, b| a == b);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let left = &[1.1, 2.2, 3.3];",
                "    let right = &[1.1, 2.2, 3.3];",
                "    let result = slice_eq(left, right, |a, b| (a - b).abs() < f64::EPSILON);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);",
                "    assert!(result);"
              ],
              "code": [
                "{",
                "    let left = &[1.1, 2.2, 3.3];",
                "    let right = &[1.1, 2.2, 3.3];",
                "    let result = slice_eq(left, right, |a, b| (a - b).abs() < f64::EPSILON);",
                "    assert_eq!(result, true);",
                "    assert!(result);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}