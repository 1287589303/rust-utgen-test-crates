{
  "name": "indexmap::map::iter::{impl#3}::as_slice",
  "mod_info": {
    "name": "map::iter",
    "loc": "src/map.rs:5:1:5:10"
  },
  "visible": true,
  "loc": "src/map/iter.rs:54:5:56:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Slice::from_slice(self.iter.as_slice())\n"
      ],
      "input_infer": "'entries' must be a non-empty slice of Bucket<K, V> where K and V types are defined and vary; entries length must be at least 1 and can go up to the maximum representable array size, containing valid Bucket instances with unique hashes.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bucket = Bucket { hash: 1, key: \"key1\", value: \"value1\" };",
                "    let entries = [bucket];",
                "    let iter = Iter::new(&entries);",
                "    let slice = iter.as_slice();",
                "}"
              ],
              "oracle": [
                "    let bucket = Bucket { hash: 1, key: \"key1\", value: \"value1\" };",
                "    let entries = [bucket];",
                "    let iter = Iter::new(&entries);",
                "    let slice = iter.as_slice();",
                "    assert_eq!(slice.entries.len(), 1);",
                "    assert_eq!(slice.entries[0].key, \"key1\");",
                "    assert_eq!(slice.entries[0].value, \"value1\");",
                "    assert_eq!(slice.entries[0].hash, 1);"
              ],
              "code": [
                "{",
                "    let bucket = Bucket { hash: 1, key: \"key1\", value: \"value1\" };",
                "    let entries = [bucket];",
                "    let iter = Iter::new(&entries);",
                "    let slice = iter.as_slice();",
                "    let bucket = Bucket { hash: 1, key: \"key1\", value: \"value1\" };",
                "    let entries = [bucket];",
                "    let iter = Iter::new(&entries);",
                "    let slice = iter.as_slice();",
                "    assert_eq!(slice.entries.len(), 1);",
                "    assert_eq!(slice.entries[0].key, \"key1\");",
                "    assert_eq!(slice.entries[0].value, \"value1\");",
                "    assert_eq!(slice.entries[0].hash, 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let buckets = [",
                "        Bucket { hash: 1, key: \"key1\", value: \"value1\" },",
                "        Bucket { hash: 2, key: \"key2\", value: \"value2\" },",
                "        Bucket { hash: 3, key: \"key3\", value: \"value3\" },",
                "    ];",
                "    let iter = Iter::new(&buckets);",
                "    let slice = iter.as_slice();",
                "}"
              ],
              "oracle": [
                "    let buckets = [",
                "    Bucket { hash: 1, key: \"key1\", value: \"value1\" },",
                "    Bucket { hash: 2, key: \"key2\", value: \"value2\" },",
                "    Bucket { hash: 3, key: \"key3\", value: \"value3\" },",
                "    ];",
                "    let iter = Iter::new(&buckets);",
                "    assert_eq!(slice.entries.len(), 3);",
                "    assert_eq!(slice.entries[0].key, \"key1\");",
                "    assert_eq!(slice.entries[1].key, \"key2\");",
                "    assert_eq!(slice.entries[2].key, \"key3\");",
                "    assert_eq!(slice.entries[0].value, \"value1\");",
                "    assert_eq!(slice.entries[1].value, \"value2\");",
                "    assert_eq!(slice.entries[2].value, \"value3\");"
              ],
              "code": [
                "{",
                "    let buckets = [",
                "        Bucket { hash: 1, key: \"key1\", value: \"value1\" },",
                "        Bucket { hash: 2, key: \"key2\", value: \"value2\" },",
                "        Bucket { hash: 3, key: \"key3\", value: \"value3\" },",
                "    ];",
                "    let iter = Iter::new(&buckets);",
                "    let slice = iter.as_slice();",
                "    let buckets = [",
                "    Bucket { hash: 1, key: \"key1\", value: \"value1\" },",
                "    Bucket { hash: 2, key: \"key2\", value: \"value2\" },",
                "    Bucket { hash: 3, key: \"key3\", value: \"value3\" },",
                "    ];",
                "    let iter = Iter::new(&buckets);",
                "    assert_eq!(slice.entries.len(), 3);",
                "    assert_eq!(slice.entries[0].key, \"key1\");",
                "    assert_eq!(slice.entries[1].key, \"key2\");",
                "    assert_eq!(slice.entries[2].key, \"key3\");",
                "    assert_eq!(slice.entries[0].value, \"value1\");",
                "    assert_eq!(slice.entries[1].value, \"value2\");",
                "    assert_eq!(slice.entries[2].value, \"value3\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut buckets = Vec::with_capacity(core::usize::MAX);",
                "    for i in 0..core::usize::MAX {",
                "        buckets.push(Bucket { hash: i as u64, key: i.to_string(), value: \"value\" });",
                "    }",
                "    let slice = Iter::new(&buckets).as_slice();",
                "}"
              ],
              "oracle": [
                "    let mut buckets = Vec::with_capacity(core::usize::MAX);",
                "    assert_eq!(buckets.len(), 0);",
                "    for i in 0..core::usize::MAX {",
                "    buckets.push(Bucket { hash: i as u64, key: i.to_string(), value: \"value\" });",
                "    }",
                "    let iter = Iter::new(&buckets);",
                "    let slice = iter.as_slice();",
                "    assert_eq!(slice.entries.len(), core::usize::MAX);",
                "    assert!(std::ptr::eq(slice.entries.as_ptr(), iter.iter.as_slice().as_ptr()));"
              ],
              "code": [
                "{",
                "    let mut buckets = Vec::with_capacity(core::usize::MAX);",
                "    for i in 0..core::usize::MAX {",
                "        buckets.push(Bucket { hash: i as u64, key: i.to_string(), value: \"value\" });",
                "    }",
                "    let slice = Iter::new(&buckets).as_slice();",
                "    let mut buckets = Vec::with_capacity(core::usize::MAX);",
                "    assert_eq!(buckets.len(), 0);",
                "    for i in 0..core::usize::MAX {",
                "    buckets.push(Bucket { hash: i as u64, key: i.to_string(), value: \"value\" });",
                "    }",
                "    let iter = Iter::new(&buckets);",
                "    let slice = iter.as_slice();",
                "    assert_eq!(slice.entries.len(), core::usize::MAX);",
                "    assert!(std::ptr::eq(slice.entries.as_ptr(), iter.iter.as_slice().as_ptr()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let buckets = [",
                "        Bucket { hash: 1, key: 1, value: \"one\" },",
                "        Bucket { hash: 2, key: 2.0, value: \"two point zero\" },",
                "        Bucket { hash: 3, key: true, value: \"true\" },",
                "    ];",
                "    let iter = Iter::new(&buckets);",
                "    let slice = iter.as_slice();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(slice.entries.len(), 3);",
                "    assert_eq!(slice.entries[0].hash, 1);",
                "    assert_eq!(slice.entries[0].key, 1);",
                "    assert_eq!(slice.entries[0].value, \"one\");",
                "    assert_eq!(slice.entries[1].hash, 2);",
                "    assert_eq!(slice.entries[1].key, 2.0);",
                "    assert_eq!(slice.entries[1].value, \"two point zero\");",
                "    assert_eq!(slice.entries[2].hash, 3);",
                "    assert_eq!(slice.entries[2].key, true);",
                "    assert_eq!(slice.entries[2].value, \"true\");"
              ],
              "code": [
                "{",
                "    let buckets = [",
                "        Bucket { hash: 1, key: 1, value: \"one\" },",
                "        Bucket { hash: 2, key: 2.0, value: \"two point zero\" },",
                "        Bucket { hash: 3, key: true, value: \"true\" },",
                "    ];",
                "    let iter = Iter::new(&buckets);",
                "    let slice = iter.as_slice();",
                "    assert_eq!(slice.entries.len(), 3);",
                "    assert_eq!(slice.entries[0].hash, 1);",
                "    assert_eq!(slice.entries[0].key, 1);",
                "    assert_eq!(slice.entries[0].value, \"one\");",
                "    assert_eq!(slice.entries[1].hash, 2);",
                "    assert_eq!(slice.entries[1].key, 2.0);",
                "    assert_eq!(slice.entries[1].value, \"two point zero\");",
                "    assert_eq!(slice.entries[2].hash, 3);",
                "    assert_eq!(slice.entries[2].key, true);",
                "    assert_eq!(slice.entries[2].value, \"true\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}