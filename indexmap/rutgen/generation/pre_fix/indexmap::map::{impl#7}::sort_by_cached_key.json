{
  "name": "indexmap::map::{impl#7}::sort_by_cached_key",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:123:1:123:13"
  },
  "visible": true,
  "loc": "src/map.rs:1074:5:1082:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Input conditions: A mutable IndexMap with at least one entry where keys implement Ord and the sort_key function should take a reference to a key and reference to a value, returning a value of type T that also implements Ord; edge cases including empty maps and maps with a single entry.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(3, \"three\".to_string());",
                "    test_map.data.insert(1, \"one\".to_string());",
                "    test_map.data.insert(2, \"two\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(test_map.data.get_index(0).map(|(k, v)| (*k, v.clone())), Some((1, \"one\".to_string())));",
                "    assert_eq!(test_map.data.get_index(1).map(|(k, v)| (*k, v.clone())), Some((2, \"two\".to_string())));",
                "    assert_eq!(test_map.data.get_index(2).map(|(k, v)| (*k, v.clone())), Some((3, \"three\".to_string())));",
                "    assert_eq!(test_map.data.len(), 3);",
                "    assert_eq!(test_map.data.first(), Some((&1, &\"one\".to_string())));",
                "    assert_eq!(test_map.data.last(), Some((&3, &\"three\".to_string())));"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(3, \"three\".to_string());",
                "    test_map.data.insert(1, \"one\".to_string());",
                "    test_map.data.insert(2, \"two\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert_eq!(test_map.data.get_index(0).map(|(k, v)| (*k, v.clone())), Some((1, \"one\".to_string())));",
                "    assert_eq!(test_map.data.get_index(1).map(|(k, v)| (*k, v.clone())), Some((2, \"two\".to_string())));",
                "    assert_eq!(test_map.data.get_index(2).map(|(k, v)| (*k, v.clone())), Some((3, \"three\".to_string())));",
                "    assert_eq!(test_map.data.len(), 3);",
                "    assert_eq!(test_map.data.first(), Some((&1, &\"one\".to_string())));",
                "    assert_eq!(test_map.data.last(), Some((&3, &\"three\".to_string())));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(5, \"five\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "}"
              ],
              "oracle": [
                "    assert!(test_map.data.first().is_some());",
                "    assert_eq!(test_map.data.first().unwrap(), (&5, &\"five\".to_string()));",
                "    assert_eq!(test_map.data.len(), 1);",
                "    assert!(test_map.data.last().is_some());",
                "    assert_eq!(test_map.data.last().unwrap(), (&5, &\"five\".to_string()));",
                "    assert!(test_map.data.get_index(0).is_some());",
                "    assert_eq!(test_map.data.get_index(0).unwrap(), (&5, &\"five\".to_string()));",
                "    assert_eq!(test_map.data.as_slice().len(), 1);",
                "    assert_eq!(test_map.data.into_boxed_slice().len(), 1);"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(5, \"five\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert!(test_map.data.first().is_some());",
                "    assert_eq!(test_map.data.first().unwrap(), (&5, &\"five\".to_string()));",
                "    assert_eq!(test_map.data.len(), 1);",
                "    assert!(test_map.data.last().is_some());",
                "    assert_eq!(test_map.data.last().unwrap(), (&5, &\"five\".to_string()));",
                "    assert!(test_map.data.get_index(0).is_some());",
                "    assert_eq!(test_map.data.get_index(0).unwrap(), (&5, &\"five\".to_string()));",
                "    assert_eq!(test_map.data.as_slice().len(), 1);",
                "    assert_eq!(test_map.data.into_boxed_slice().len(), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(test_map.data.len(), 0);",
                "    test_map.data.insert(1, \"apple\".to_string());",
                "    test_map.data.insert(2, \"banana\".to_string());",
                "    test_map.data.insert(3, \"kiwi\".to_string());",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert_eq!(test_map.data.first(), Some((&2, &\"banana\".to_string())));",
                "    assert_eq!(test_map.data.last(), Some((&3, &\"kiwi\".to_string())));",
                "    test_map.data.insert(4, \"fig\".to_string());",
                "    test_map.data.insert(5, \"grape\".to_string());",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert_eq!(test_map.data.as_slice(), vec![(&4, &\"fig\".to_string()), (&1, &\"apple\".to_string()), (&2, &\"banana\".to_string()), (&5, &\"grape\".to_string()), (&3, &\"kiwi\".to_string())].as_slice());"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert_eq!(test_map.data.len(), 0);",
                "    test_map.data.insert(1, \"apple\".to_string());",
                "    test_map.data.insert(2, \"banana\".to_string());",
                "    test_map.data.insert(3, \"kiwi\".to_string());",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert_eq!(test_map.data.first(), Some((&2, &\"banana\".to_string())));",
                "    assert_eq!(test_map.data.last(), Some((&3, &\"kiwi\".to_string())));",
                "    test_map.data.insert(4, \"fig\".to_string());",
                "    test_map.data.insert(5, \"grape\".to_string());",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert_eq!(test_map.data.as_slice(), vec![(&4, &\"fig\".to_string()), (&1, &\"apple\".to_string()), (&2, &\"banana\".to_string()), (&5, &\"grape\".to_string()), (&3, &\"kiwi\".to_string())].as_slice());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(1, \"one\".to_string());",
                "    test_map.data.insert(1, \"uno\".to_string());",
                "    test_map.data.insert(1, \"ein\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(test_map.data.len(), 3);",
                "    assert_eq!(test_map.data.get_index(0), Some((&1, &\"one\".to_string())));",
                "    assert_eq!(test_map.data.get_index(1), Some((&1, &\"uno\".to_string())));",
                "    assert_eq!(test_map.data.get_index(2), Some((&1, &\"ein\".to_string())));"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(1, \"one\".to_string());",
                "    test_map.data.insert(1, \"uno\".to_string());",
                "    test_map.data.insert(1, \"ein\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    assert_eq!(test_map.data.len(), 3);",
                "    assert_eq!(test_map.data.get_index(0), Some((&1, &\"one\".to_string())));",
                "    assert_eq!(test_map.data.get_index(1), Some((&1, &\"uno\".to_string())));",
                "    assert_eq!(test_map.data.get_index(2), Some((&1, &\"ein\".to_string())));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(5, \"five\".to_string());",
                "    test_map.data.insert(4, \"four\".to_string());",
                "    test_map.data.insert(3, \"three\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "}"
              ],
              "oracle": [
                "    test_map.data.as_slice().len() == 3",
                "    test_map.data.first() == Some((&3, &\"three\".to_string()))",
                "    test_map.data.last() == Some((&5, &\"five\".to_string()))",
                "    test_map.data.get_index(0) == Some((&3, &\"three\".to_string()))",
                "    test_map.data.get_index(1) == Some((&4, &\"four\".to_string()))",
                "    test_map.data.get_index(2) == Some((&5, &\"five\".to_string()))"
              ],
              "code": [
                "{",
                "    struct TestMap {",
                "        data: indexmap::IndexMap<i32, String>,",
                "    }",
                "",
                "    let mut test_map = TestMap {",
                "        data: indexmap::IndexMap::new(),",
                "    };",
                "",
                "    test_map.data.insert(5, \"five\".to_string());",
                "    test_map.data.insert(4, \"four\".to_string());",
                "    test_map.data.insert(3, \"three\".to_string());",
                "",
                "    test_map.data.sort_by_cached_key(|k, v| (v.len(), *k));",
                "    test_map.data.as_slice().len() == 3",
                "    test_map.data.first() == Some((&3, &\"three\".to_string()))",
                "    test_map.data.last() == Some((&5, &\"five\".to_string()))",
                "    test_map.data.get_index(0) == Some((&3, &\"three\".to_string()))",
                "    test_map.data.get_index(1) == Some((&4, &\"four\".to_string()))",
                "    test_map.data.get_index(2) == Some((&5, &\"five\".to_string()))",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}