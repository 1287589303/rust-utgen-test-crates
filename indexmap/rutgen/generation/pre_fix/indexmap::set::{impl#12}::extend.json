{
  "name": "indexmap::set::{impl#12}::extend",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:124:1:124:13"
  },
  "visible": true,
  "loc": "src/set.rs:1167:5:1170:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "I: IntoIterator<Item = &'a T> where T: Hash + Eq + Copy, with valid, invalid, empty, and large collections (e.g., 0, 1, 1000 elements) of unique and duplicate items.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let input: Vec<&i32> = Vec::new();",
                "    index_set.extend(input);",
                "}"
              ],
              "oracle": [
                "    assert!(index_set.is_empty());",
                "    let input: Vec<&i32> = vec![&1, &2, &3];",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.len(), 3);",
                "    assert!(index_set.contains(&1));",
                "    assert!(index_set.contains(&2));",
                "    assert!(index_set.contains(&3));",
                "    let input_empty: Vec<&i32> = vec![];",
                "    index_set.extend(input_empty);",
                "    assert_eq!(index_set.len(), 3);",
                "    let input_duplicates: Vec<&i32> = vec![&1, &1, &2];",
                "    index_set.extend(input_duplicates);",
                "    assert_eq!(index_set.len(), 3);"
              ],
              "code": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let input: Vec<&i32> = Vec::new();",
                "    index_set.extend(input);",
                "    assert!(index_set.is_empty());",
                "    let input: Vec<&i32> = vec![&1, &2, &3];",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.len(), 3);",
                "    assert!(index_set.contains(&1));",
                "    assert!(index_set.contains(&2));",
                "    assert!(index_set.contains(&3));",
                "    let input_empty: Vec<&i32> = vec![];",
                "    index_set.extend(input_empty);",
                "    assert_eq!(index_set.len(), 3);",
                "    let input_duplicates: Vec<&i32> = vec![&1, &1, &2];",
                "    index_set.extend(input_duplicates);",
                "    assert_eq!(index_set.len(), 3);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let value = 42;",
                "    let input: Vec<&i32> = vec![&value];",
                "    index_set.extend(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_set.len(), 1);",
                "    assert!(index_set.contains(&42));",
                "    assert!(!index_set.contains(&43));",
                "    assert!(index_set.map.core.entries().len() > 0);",
                "    assert_eq!(index_set.map.hash_builder, RandomState::new());"
              ],
              "code": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let value = 42;",
                "    let input: Vec<&i32> = vec![&value];",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.len(), 1);",
                "    assert!(index_set.contains(&42));",
                "    assert!(!index_set.contains(&43));",
                "    assert!(index_set.map.core.entries().len() > 0);",
                "    assert_eq!(index_set.map.hash_builder, RandomState::new());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let value1 = 10;",
                "    let value2 = 20;",
                "    let input: Vec<&i32> = vec![&value1, &value1, &value2, &value2];",
                "    index_set.extend(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_set.len(), 2);",
                "    assert!(index_set.contains(&10));",
                "    assert!(index_set.contains(&20));",
                "    assert!(!index_set.contains(&30));",
                "    assert_eq!(index_set.as_entries().len(), 2);",
                "    assert_eq!(index_set.as_entries()[0], &10);",
                "    assert_eq!(index_set.as_entries()[1], &20);"
              ],
              "code": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let value1 = 10;",
                "    let value2 = 20;",
                "    let input: Vec<&i32> = vec![&value1, &value1, &value2, &value2];",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.len(), 2);",
                "    assert!(index_set.contains(&10));",
                "    assert!(index_set.contains(&20));",
                "    assert!(!index_set.contains(&30));",
                "    assert_eq!(index_set.as_entries().len(), 2);",
                "    assert_eq!(index_set.as_entries()[0], &10);",
                "    assert_eq!(index_set.as_entries()[1], &20);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let input: Vec<&i32> = (0..1000).map(|x| &x).collect();",
                "    index_set.extend(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_set.map.core.len(), 1000);",
                "    assert!(index_set.map.core.contains_key(&0));",
                "    assert!(index_set.map.core.contains_key(&999));",
                "    assert!(!index_set.map.core.contains_key(&1001));",
                "    assert!(index_set.map.core.contains_key(&500));",
                "    let input_empty: Vec<&i32> = vec![];",
                "    index_set.extend(input_empty);",
                "    assert_eq!(index_set.map.core.len(), 1000);",
                "    let input_duplicates: Vec<&i32> = vec![&1, &1, &2];",
                "    index_set.extend(input_duplicates);",
                "    assert_eq!(index_set.map.core.len(), 1002);"
              ],
              "code": [
                "{",
                "    let mut index_set: IndexSet<i32, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let input: Vec<&i32> = (0..1000).map(|x| &x).collect();",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.map.core.len(), 1000);",
                "    assert!(index_set.map.core.contains_key(&0));",
                "    assert!(index_set.map.core.contains_key(&999));",
                "    assert!(!index_set.map.core.contains_key(&1001));",
                "    assert!(index_set.map.core.contains_key(&500));",
                "    let input_empty: Vec<&i32> = vec![];",
                "    index_set.extend(input_empty);",
                "    assert_eq!(index_set.map.core.len(), 1000);",
                "    let input_duplicates: Vec<&i32> = vec![&1, &1, &2];",
                "    index_set.extend(input_duplicates);",
                "    assert_eq!(index_set.map.core.len(), 1002);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut index_set: IndexSet<String, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let input: Vec<&String> = Vec::new();",
                "    index_set.extend(input);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_set.map.core.len(), 0);",
                "    assert!(index_set.map.core.is_empty());",
                "    let input: Vec<&String> = vec![\"hello\".to_string().as_ref(), \"world\".to_string().as_ref()];",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.map.core.len(), 2);",
                "    assert!(index_set.map.core.contains_key(&\"hello\".to_string()));",
                "    assert!(index_set.map.core.contains_key(&\"world\".to_string()));",
                "    let input_duplicates: Vec<&String> = vec![\"hello\".to_string().as_ref(), \"hello\".to_string().as_ref()];",
                "    index_set.extend(input_duplicates);",
                "    assert_eq!(index_set.map.core.len(), 2);",
                "    let input_empty: Vec<&String> = Vec::new();",
                "    index_set.extend(input_empty);",
                "    assert_eq!(index_set.map.core.len(), 2);",
                "    let input_with_none: Vec<&String> = vec![&\"hello\".to_string(), &\"not_exist\".to_string()];",
                "    index_set.extend(input_with_none);",
                "    assert_eq!(index_set.map.core.len(), 2);"
              ],
              "code": [
                "{",
                "    let mut index_set: IndexSet<String, RandomState> = IndexSet {",
                "        map: IndexMap {",
                "            core: IndexMapCore::new(),",
                "            hash_builder: RandomState::new(),",
                "        },",
                "    };",
                "    let input: Vec<&String> = Vec::new();",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.map.core.len(), 0);",
                "    assert!(index_set.map.core.is_empty());",
                "    let input: Vec<&String> = vec![\"hello\".to_string().as_ref(), \"world\".to_string().as_ref()];",
                "    index_set.extend(input);",
                "    assert_eq!(index_set.map.core.len(), 2);",
                "    assert!(index_set.map.core.contains_key(&\"hello\".to_string()));",
                "    assert!(index_set.map.core.contains_key(&\"world\".to_string()));",
                "    let input_duplicates: Vec<&String> = vec![\"hello\".to_string().as_ref(), \"hello\".to_string().as_ref()];",
                "    index_set.extend(input_duplicates);",
                "    assert_eq!(index_set.map.core.len(), 2);",
                "    let input_empty: Vec<&String> = Vec::new();",
                "    index_set.extend(input_empty);",
                "    assert_eq!(index_set.map.core.len(), 2);",
                "    let input_with_none: Vec<&String> = vec![&\"hello\".to_string(), &\"not_exist\".to_string()];",
                "    index_set.extend(input_with_none);",
                "    assert_eq!(index_set.map.core.len(), 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}