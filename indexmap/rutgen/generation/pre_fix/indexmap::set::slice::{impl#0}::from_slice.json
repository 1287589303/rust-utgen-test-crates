{
  "name": "indexmap::set::slice::{impl#0}::from_slice",
  "mod_info": {
    "name": "set::slice",
    "loc": "src/set.rs:5:1:5:11"
  },
  "visible": false,
  "loc": "src/set/slice.rs:27:5:29:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: &*(entries as *const [Bucket<T>] as *const Self)\n"
      ],
      "input_infer": "entries: non-empty slice of Bucket<T> with valid memory alignment, or empty slice of Bucket<T>, or slice length of 0 to N where N is the maximum capacity of Bucket<T> for the system architecture\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let buckets = [",
                "        Bucket { hash: 1, key: \"key1\", value: \"value1\" },",
                "        Bucket { hash: 2, key: \"key2\", value: \"value2\" },",
                "    ];",
                "    let slice = Slice::from_slice(&buckets);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(slice.entries.len(), 2);",
                "    assert_eq!(slice.entries[0].hash, 1);",
                "    assert_eq!(slice.entries[0].key, \"key1\");",
                "    assert_eq!(slice.entries[0].value, \"value1\");",
                "    assert_eq!(slice.entries[1].hash, 2);",
                "    assert_eq!(slice.entries[1].key, \"key2\");",
                "    assert_eq!(slice.entries[1].value, \"value2\");",
                "    assert_eq!(slice as *const Slice<Bucket<&str, &str>>, &buckets as *const [Bucket<&str, &str>] as *const Slice<Bucket<&str, &str>>);"
              ],
              "code": [
                "{",
                "    let buckets = [",
                "        Bucket { hash: 1, key: \"key1\", value: \"value1\" },",
                "        Bucket { hash: 2, key: \"key2\", value: \"value2\" },",
                "    ];",
                "    let slice = Slice::from_slice(&buckets);",
                "    assert_eq!(slice.entries.len(), 2);",
                "    assert_eq!(slice.entries[0].hash, 1);",
                "    assert_eq!(slice.entries[0].key, \"key1\");",
                "    assert_eq!(slice.entries[0].value, \"value1\");",
                "    assert_eq!(slice.entries[1].hash, 2);",
                "    assert_eq!(slice.entries[1].key, \"key2\");",
                "    assert_eq!(slice.entries[1].value, \"value2\");",
                "    assert_eq!(slice as *const Slice<Bucket<&str, &str>>, &buckets as *const [Bucket<&str, &str>] as *const Slice<Bucket<&str, &str>>);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let buckets: &[Bucket<&str>] = &[];",
                "    let slice = Slice::from_slice(buckets);",
                "}"
              ],
              "oracle": [
                "    let buckets: &[Bucket<&str>] = &[];",
                "    let slice = Slice::from_slice(buckets);",
                "    assert_eq!(slice.entries.as_ptr(), buckets.as_ptr());",
                "    assert!(std::mem::size_of::<Slice<&str>>() == std::mem::size_of_val(slice));",
                "    assert!(std::ptr::eq(slice.entries, buckets));"
              ],
              "code": [
                "{",
                "    let buckets: &[Bucket<&str>] = &[];",
                "    let slice = Slice::from_slice(buckets);",
                "    let buckets: &[Bucket<&str>] = &[];",
                "    let slice = Slice::from_slice(buckets);",
                "    assert_eq!(slice.entries.as_ptr(), buckets.as_ptr());",
                "    assert!(std::mem::size_of::<Slice<&str>>() == std::mem::size_of_val(slice));",
                "    assert!(std::ptr::eq(slice.entries, buckets));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let buckets = [Bucket { hash: 3, key: \"key3\", value: \"value3\" }];",
                "    let slice = Slice::from_slice(&buckets);",
                "}"
              ],
              "oracle": [
                "    let buckets: [Bucket<&str, &str>; 1] = [Bucket { hash: 3, key: \"key3\", value: \"value3\" }];",
                "    let slice = Slice::from_slice(&buckets);",
                "    assert_eq!(slice.entries[0].hash, 3);",
                "    assert_eq!(slice.entries[0].key, \"key3\");",
                "    assert_eq!(slice.entries[0].value, \"value3\");"
              ],
              "code": [
                "{",
                "    let buckets = [Bucket { hash: 3, key: \"key3\", value: \"value3\" }];",
                "    let slice = Slice::from_slice(&buckets);",
                "    let buckets: [Bucket<&str, &str>; 1] = [Bucket { hash: 3, key: \"key3\", value: \"value3\" }];",
                "    let slice = Slice::from_slice(&buckets);",
                "    assert_eq!(slice.entries[0].hash, 3);",
                "    assert_eq!(slice.entries[0].key, \"key3\");",
                "    assert_eq!(slice.entries[0].value, \"value3\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let buckets: &[Bucket<i32>] = &[",
                "        Bucket { hash: 4, key: 1, value: 100 },",
                "        Bucket { hash: 5, key: 2, value: 200 },",
                "        Bucket { hash: 6, key: 3, value: 300 },",
                "    ];",
                "    let slice = Slice::from_slice(buckets);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(slice.entries.len(), 3);",
                "    assert_eq!(slice.entries[0].key, 1);",
                "    assert_eq!(slice.entries[0].value, 100);",
                "    assert_eq!(slice.entries[1].key, 2);",
                "    assert_eq!(slice.entries[1].value, 200);",
                "    assert_eq!(slice.entries[2].key, 3);",
                "    assert_eq!(slice.entries[2].value, 300);"
              ],
              "code": [
                "{",
                "    let buckets: &[Bucket<i32>] = &[",
                "        Bucket { hash: 4, key: 1, value: 100 },",
                "        Bucket { hash: 5, key: 2, value: 200 },",
                "        Bucket { hash: 6, key: 3, value: 300 },",
                "    ];",
                "    let slice = Slice::from_slice(buckets);",
                "    assert_eq!(slice.entries.len(), 3);",
                "    assert_eq!(slice.entries[0].key, 1);",
                "    assert_eq!(slice.entries[0].value, 100);",
                "    assert_eq!(slice.entries[1].key, 2);",
                "    assert_eq!(slice.entries[1].value, 200);",
                "    assert_eq!(slice.entries[2].key, 3);",
                "    assert_eq!(slice.entries[2].value, 300);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}