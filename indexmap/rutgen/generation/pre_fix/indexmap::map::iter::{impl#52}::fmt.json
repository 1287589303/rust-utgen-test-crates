{
  "name": "indexmap::map::iter::{impl#52}::fmt",
  "mod_info": {
    "name": "map::iter",
    "loc": "src/map.rs:5:1:5:10"
  },
  "visible": true,
  "loc": "src/map/iter.rs:481:5:484:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "K must implement fmt::Debug, self.iter must have at least one element with a valid Bucket<K, V>, both K and V types should be non-primitive to ensure fmt::Debug works properly, and the fmt::Formatter must be a valid reference.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NonPrimitiveKey {",
                "        id: usize,",
                "    }",
                "",
                "    struct NonPrimitiveValue {",
                "        name: String,",
                "    }",
                "",
                "    let key = NonPrimitiveKey { id: 1 };",
                "    let value = NonPrimitiveValue { name: String::from(\"Value1\") };",
                "    let bucket = Bucket { hash: 0, key, value };",
                "    ",
                "    let iter = vec![bucket];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "",
                "    let _ = fmt::format(format_args!(\"{:?}\", into_keys));",
                "}"
              ],
              "oracle": [
                "    let key = NonPrimitiveKey { id: 1 };",
                "    let value = NonPrimitiveValue { name: String::from(\"Value1\") };",
                "    let bucket = Bucket { hash: 0, key, value };",
                "    let iter = vec![bucket];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "    let result = fmt::format(format_args!(\"{:?}\", into_keys));",
                "    assert_eq!(result.to_string(), \"[NonPrimitiveKey { id: 1 }]\");"
              ],
              "code": [
                "{",
                "    struct NonPrimitiveKey {",
                "        id: usize,",
                "    }",
                "",
                "    struct NonPrimitiveValue {",
                "        name: String,",
                "    }",
                "",
                "    let key = NonPrimitiveKey { id: 1 };",
                "    let value = NonPrimitiveValue { name: String::from(\"Value1\") };",
                "    let bucket = Bucket { hash: 0, key, value };",
                "    ",
                "    let iter = vec![bucket];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "",
                "    let _ = fmt::format(format_args!(\"{:?}\", into_keys));",
                "    let key = NonPrimitiveKey { id: 1 };",
                "    let value = NonPrimitiveValue { name: String::from(\"Value1\") };",
                "    let bucket = Bucket { hash: 0, key, value };",
                "    let iter = vec![bucket];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "    let result = fmt::format(format_args!(\"{:?}\", into_keys));",
                "    assert_eq!(result.to_string(), \"[NonPrimitiveKey { id: 1 }]\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NonPrimitiveKey {",
                "        id: usize,",
                "    }",
                "",
                "    struct NonPrimitiveValue {",
                "        name: String,",
                "    }",
                "",
                "    let key1 = NonPrimitiveKey { id: 1 };",
                "    let value1 = NonPrimitiveValue { name: String::from(\"Value1\") };",
                "    let bucket1 = Bucket { hash: 0, key: key1, value: value1 };",
                "",
                "    let key2 = NonPrimitiveKey { id: 2 };",
                "    let value2 = NonPrimitiveValue { name: String::from(\"Value2\") };",
                "    let bucket2 = Bucket { hash: 1, key: key2, value: value2 };",
                "",
                "    let iter = vec![bucket1, bucket2];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "",
                "    let _ = fmt::format(format_args!(\"{:?}\", into_keys));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(fmt::format(format_args!(\"{:?}\", into_keys)), \"[NonPrimitiveKey { id: 1 }, NonPrimitiveKey { id: 2 }]\");",
                "    assert_eq!(into_keys.iter.len(), 2);",
                "    assert!(matches!(into_keys.iter.next(), Some(Bucket { key, .. }) if key.id == 1));",
                "    assert!(matches!(into_keys.iter.next(), Some(Bucket { key, .. }) if key.id == 2));",
                "    assert!(into_keys.iter.next().is_none());"
              ],
              "code": [
                "{",
                "    struct NonPrimitiveKey {",
                "        id: usize,",
                "    }",
                "",
                "    struct NonPrimitiveValue {",
                "        name: String,",
                "    }",
                "",
                "    let key1 = NonPrimitiveKey { id: 1 };",
                "    let value1 = NonPrimitiveValue { name: String::from(\"Value1\") };",
                "    let bucket1 = Bucket { hash: 0, key: key1, value: value1 };",
                "",
                "    let key2 = NonPrimitiveKey { id: 2 };",
                "    let value2 = NonPrimitiveValue { name: String::from(\"Value2\") };",
                "    let bucket2 = Bucket { hash: 1, key: key2, value: value2 };",
                "",
                "    let iter = vec![bucket1, bucket2];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "",
                "    let _ = fmt::format(format_args!(\"{:?}\", into_keys));",
                "    assert_eq!(fmt::format(format_args!(\"{:?}\", into_keys)), \"[NonPrimitiveKey { id: 1 }, NonPrimitiveKey { id: 2 }]\");",
                "    assert_eq!(into_keys.iter.len(), 2);",
                "    assert!(matches!(into_keys.iter.next(), Some(Bucket { key, .. }) if key.id == 1));",
                "    assert!(matches!(into_keys.iter.next(), Some(Bucket { key, .. }) if key.id == 2));",
                "    assert!(into_keys.iter.next().is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NonPrimitiveKey {",
                "        id: usize,",
                "    }",
                "",
                "    struct NonPrimitiveValue {",
                "        name: String,",
                "    }",
                "",
                "    let key = NonPrimitiveKey { id: 1 };",
                "    let value = NonPrimitiveValue { name: String::from(\"SingleValue\") };",
                "    let bucket = Bucket { hash: 0, key, value };",
                "",
                "    let iter = vec![bucket];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "",
                "    let _ = fmt::format(format_args!(\"{:?}\", into_keys));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(fmt::format(format_args!(\"{:?}\", into_keys)), \"[NonPrimitiveKey { id: 1 }]\");"
              ],
              "code": [
                "{",
                "    struct NonPrimitiveKey {",
                "        id: usize,",
                "    }",
                "",
                "    struct NonPrimitiveValue {",
                "        name: String,",
                "    }",
                "",
                "    let key = NonPrimitiveKey { id: 1 };",
                "    let value = NonPrimitiveValue { name: String::from(\"SingleValue\") };",
                "    let bucket = Bucket { hash: 0, key, value };",
                "",
                "    let iter = vec![bucket];",
                "    let into_keys = IntoKeys { iter: iter.into_iter() };",
                "",
                "    let _ = fmt::format(format_args!(\"{:?}\", into_keys));",
                "    assert_eq!(fmt::format(format_args!(\"{:?}\", into_keys)), \"[NonPrimitiveKey { id: 1 }]\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}