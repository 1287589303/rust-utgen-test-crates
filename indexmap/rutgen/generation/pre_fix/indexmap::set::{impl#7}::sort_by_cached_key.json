{
  "name": "indexmap::set::{impl#7}::sort_by_cached_key",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:124:1:124:13"
  },
  "visible": true,
  "loc": "src/set.rs:901:5:909:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "MutableValues must contain at least one item of type T, and the function sort_key must be a callable function; T must support Ord and the caller must expect a sorted result based on the output of sort_key.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![5, 3, 8, 1, 2],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|&x| x);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 8]);",
                "    set.sort_by_cached_key(|&x| -x);",
                "    assert_eq!(set.values, vec![8, 5, 3, 2, 1]);",
                "    set.sort_by_cached_key(|x| x % 2);",
                "    assert_eq!(set.values, vec![2, 8, 3, 5, 1]);",
                "    set.sort_by_cached_key(|x| x / 2);",
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 8]);",
                "    set.sort_by_cached_key(|_| 0);",
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 8]);",
                "    set.values.push(6);",
                "    set.sort_by_cached_key(|&x| x);",
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 6, 8]);"
              ],
              "code": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![5, 3, 8, 1, 2],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|&x| x);",
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 8]);",
                "    set.sort_by_cached_key(|&x| -x);",
                "    assert_eq!(set.values, vec![8, 5, 3, 2, 1]);",
                "    set.sort_by_cached_key(|x| x % 2);",
                "    assert_eq!(set.values, vec![2, 8, 3, 5, 1]);",
                "    set.sort_by_cached_key(|x| x / 2);",
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 8]);",
                "    set.sort_by_cached_key(|_| 0);",
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 8]);",
                "    set.values.push(6);",
                "    set.sort_by_cached_key(|&x| x);",
                "    assert_eq!(set.values, vec![1, 2, 3, 5, 6, 8]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<(i32, i32)>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = (i32, i32);",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![(3, 1), (2, 4), (5, 2)],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x.0);",
                "}"
              ],
              "oracle": [
                "    let mut set = TestMutableValues { values: vec![(3, 1), (2, 4), (5, 2)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(2, 4), (3, 1), (5, 2)]);",
                "    let mut set = TestMutableValues { values: vec![] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![]);",
                "    let mut set = TestMutableValues { values: vec![(1, 0), (1, 2), (1, 1)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(1, 0), (1, 2), (1, 1)]);",
                "    let mut set = TestMutableValues { values: vec![(1, 2), (1, 0), (1, 1)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(1, 0), (1, 1), (1, 2)]);",
                "    let mut set = TestMutableValues { values: vec![(3, 1), (2, 4), (5, 2), (5, 0)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(2, 4), (3, 1), (5, 2), (5, 0)]);"
              ],
              "code": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<(i32, i32)>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = (i32, i32);",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![(3, 1), (2, 4), (5, 2)],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x.0);",
                "    let mut set = TestMutableValues { values: vec![(3, 1), (2, 4), (5, 2)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(2, 4), (3, 1), (5, 2)]);",
                "    let mut set = TestMutableValues { values: vec![] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![]);",
                "    let mut set = TestMutableValues { values: vec![(1, 0), (1, 2), (1, 1)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(1, 0), (1, 2), (1, 1)]);",
                "    let mut set = TestMutableValues { values: vec![(1, 2), (1, 0), (1, 1)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(1, 0), (1, 1), (1, 2)]);",
                "    let mut set = TestMutableValues { values: vec![(3, 1), (2, 4), (5, 2), (5, 0)] };",
                "    set.sort_by_cached_key(|x| x.0);",
                "    assert_eq!(set.values, vec![(2, 4), (3, 1), (5, 2), (5, 0)]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x);",
                "}"
              ],
              "oracle": [
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![]);",
                "    ",
                "    set.values.push(3);",
                "    set.values.push(1);",
                "    set.values.push(2);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 3]);",
                "    ",
                "    set.values.clear();",
                "    set.values.push(-1);",
                "    set.values.push(0);",
                "    set.values.push(2);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![-1, 0, 2]);",
                "    ",
                "    set.values.push(4);",
                "    set.values.push(3);",
                "    set.values.push(4);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![3, 4, 4]);",
                "    ",
                "    set.values.push(3);",
                "    set.values.push(4);",
                "    set.values.push(2);",
                "    set.sort_by_cached_key(|x| -x);",
                "    assert_eq!(set.values, vec![4, 3, 2]);",
                "    ",
                "    set.values.push(5);",
                "    set.values.push(1);",
                "    set.sort_by_cached_key(|x| x * x);",
                "    assert_eq!(set.values, vec![1, 1, 4, 9, 25]);"
              ],
              "code": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![]);",
                "    ",
                "    set.values.push(3);",
                "    set.values.push(1);",
                "    set.values.push(2);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 3]);",
                "    ",
                "    set.values.clear();",
                "    set.values.push(-1);",
                "    set.values.push(0);",
                "    set.values.push(2);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![-1, 0, 2]);",
                "    ",
                "    set.values.push(4);",
                "    set.values.push(3);",
                "    set.values.push(4);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![3, 4, 4]);",
                "    ",
                "    set.values.push(3);",
                "    set.values.push(4);",
                "    set.values.push(2);",
                "    set.sort_by_cached_key(|x| -x);",
                "    assert_eq!(set.values, vec![4, 3, 2]);",
                "    ",
                "    set.values.push(5);",
                "    set.values.push(1);",
                "    set.sort_by_cached_key(|x| x * x);",
                "    assert_eq!(set.values, vec![1, 1, 4, 9, 25]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![2, 2, 2],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.values, vec![2, 2, 2]);",
                "    set.values.push(1);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 2, 2]);",
                "    set.values.push(3);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 2, 2, 3]);",
                "    set.values = vec![5, 1, 3, 2, 4];",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 3, 4, 5]);",
                "    set.values = vec![-1, -5, -3, -2, -4];",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![-5, -4, -3, -2, -1]);",
                "    set.values = vec![];",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![]);"
              ],
              "code": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![2, 2, 2],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![2, 2, 2]);",
                "    set.values.push(1);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 2, 2]);",
                "    set.values.push(3);",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 2, 2, 3]);",
                "    set.values = vec![5, 1, 3, 2, 4];",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![1, 2, 3, 4, 5]);",
                "    set.values = vec![-1, -5, -3, -2, -4];",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![-5, -4, -3, -2, -1]);",
                "    set.values = vec![];",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![-1, -3, -2, 0],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.values, vec![-3, -2, -1, 0]);"
              ],
              "code": [
                "{",
                "    struct TestMutableValues {",
                "        values: Vec<i32>,",
                "    }",
                "",
                "    impl MutableValues for TestMutableValues {",
                "        type Value = i32;",
                "        ",
                "        fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>",
                "        where",
                "            Q: ?Sized + Hash + Equivalent<Self::Value>,",
                "        {",
                "            None",
                "        }",
                "        ",
                "        fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value> {",
                "            self.values.get_mut(index)",
                "        }",
                "",
                "        fn retain2<F>(&mut self, keep: F)",
                "        where",
                "            F: FnMut(&mut Self::Value) -> bool,",
                "        {",
                "            self.values.retain(keep);",
                "        }",
                "    }",
                "",
                "    let mut set = TestMutableValues {",
                "        values: vec![-1, -3, -2, 0],",
                "    };",
                "    ",
                "    set.sort_by_cached_key(|x| x);",
                "    assert_eq!(set.values, vec![-3, -2, -1, 0]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}