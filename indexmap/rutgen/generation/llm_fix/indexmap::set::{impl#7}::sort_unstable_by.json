{
  "name": "indexmap::set::{impl#7}::sort_unstable_by",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:124:1:124:13"
  },
  "visible": true,
  "loc": "src/set.rs:875:5:880:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid input where `self` is an `IndexSet` instance containing at least one element of type T, and `cmp` is a valid function that can compare pairs of elements of T to produce an `Ordering`, including edge cases where T has duplicate values or is ordered.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "    ",
                "    set.map.insert(3, ());",
                "    set.map.insert(1, ());",
                "    set.map.insert(2, ());",
                "",
                "    set.sort_unstable_by(|a, b| a.cmp(b));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.map.as_entries(), &[1, 2, 3]);",
                "    assert_eq!(set.map.len(), 3);",
                "    assert!(set.map.get_index(0).is_some());",
                "    assert!(set.map.get_index(1).is_some());",
                "    assert!(set.map.get_index(2).is_some());",
                "    assert!(set.map.first().unwrap() == &1);",
                "    assert!(set.map.last().unwrap() == &3);",
                "    assert_eq!(set.map.binary_search(&2), Ok(1));",
                "    assert_eq!(set.map.binary_search(&4), Err(3));",
                "    set.sort_unstable_by(|a, b| b.cmp(a));",
                "    assert_eq!(set.map.as_entries(), &[3, 2, 1]);",
                "    assert!(set.map.get_index(0).unwrap() == &3);",
                "    assert!(set.map.get_index(2).unwrap() == &1);"
              ],
              "code": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "    ",
                "   set.map.insert(3, ());",
                "   set.map.insert(1, ());",
                "   set.map.insert(2, ());",
                "",
                "   set.sort_unstable_by(|a, b| a.cmp(b));",
                "   assert_eq!(set.map.as_entries(), &[1, 2, 3]);",
                "   assert_eq!(set.map.len(), 3);",
                "   assert!(set.map.get_index(0).is_some());",
                "   assert!(set.map.get_index(1).is_some());",
                "   assert!(set.map.get_index(2).is_some());",
                "   assert!(set.map.first().unwrap() == (&1, &()));",
                "    assert!(set.map.last().unwrap() == &3);",
                "    assert_eq!(set.map.binary_search(&2), Ok(1));",
                "    assert_eq!(set.map.binary_search(&4), Err(3));",
                "    set.sort_unstable_by(|a, b| b.cmp(a));",
                "    assert_eq!(set.map.as_entries(), &[3, 2, 1]);",
                "   assert!(set.map.get_index(0).unwrap() == (&3, &()));  ",
                "   assert!(set.map.get_index(2).unwrap() == (&1, &()));  ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "    ",
                "    set.map.insert(3, ());",
                "    set.map.insert(1, ());",
                "    set.map.insert(2, ());",
                "",
                "    set.sort_unstable_by(|a, b| b.cmp(a));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.map.as_entries(), &[3, 2, 1]);"
              ],
              "code": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "    ",
                "    set.map.insert(3, ());",
                "    set.map.insert(1, ());",
                "    set.map.insert(2, ());",
                "",
                "    set.sort_unstable_by(|a, b| b.cmp(a));",
                "    assert_eq!(set.map.as_entries(), &[3, 2, 1]);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "    ",
                "    set.map.insert(2, ());",
                "    set.map.insert(1, ());",
                "    set.map.insert(2, ());",
                "",
                "    set.sort_unstable_by(|a, b| a.cmp(b));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.map.as_entries().len(), 2);",
                "    assert_eq!(set.map.as_entries()[0], &1);",
                "    assert_eq!(set.map.as_entries()[1], &2);"
              ],
              "code": [
                "{",
                "   struct TestSet {",
                "       map: IndexMap<i32, (), RandomState>,",
                "   }",
                "   ",
                "   let mut set = TestSet {",
                "       map: IndexMap::new(),",
                "   };",
                "   ",
                "   set.map.insert(2, ());",
                "   set.map.insert(1, ());",
                "   set.map.insert(2, ());",
                "",
                "   let mut keys: Vec<_> = set.map.keys().cloned().collect();",
                "   keys.sort_unstable();",
                "   assert_eq!(keys.len(), 2);",
                "   assert_eq!(keys[0], 1);",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "    ",
                "    set.map.insert(5, ());",
                "",
                "    set.sort_unstable_by(|a, b| a.cmp(b));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.map.as_entries(), &[5]);",
                "    set.map.insert(3, ());",
                "    set.map.sort_unstable_by(|a, b| a.cmp(b));",
                "    assert_eq!(set.map.as_entries(), &[3, 5]);",
                "    set.map.insert(4, ());",
                "    set.map.sort_unstable_by(|a, b| a.cmp(b));",
                "    assert_eq!(set.map.as_entries(), &[3, 4, 5]);",
                "    set.map.insert(2, ());",
                "    set.map.sort_unstable_by(|a, b| a.cmp(b));",
                "    assert_eq!(set.map.as_entries(), &[2, 3, 4, 5]);",
                "    set.map.insert(1, ());",
                "    set.map.sort_unstable_by(|a, b| a.cmp(b));",
                "    assert_eq!(set.map.as_entries(), &[1, 2, 3, 4, 5]);",
                "    set.map.insert(6, ());",
                "    set.map.sort_unstable_by(|a, b| a.cmp(b));",
                "    assert_eq!(set.map.as_entries(), &[1, 2, 3, 4, 5, 6]);",
                "    set.map.clear();",
                "    set.map.sort_unstable_by(|a, b| a.cmp(b));",
                "    assert!(set.map.as_entries().is_empty());"
              ],
              "code": [
                "{",
                "   struct TestSet {  ",
                "       map: IndexMap<i32, (), RandomState>,  ",
                "   }  ",
                "   ",
                "   let mut set = TestSet {  ",
                "       map: IndexMap::new(),  ",
                "   };  ",
                "   ",
                "   set.map.insert(5, ());  ",
                " ",
                "   set.map.sort_unstable_by(|_, a, _, b| a.cmp(b));  ",
                "   assert_eq!(set.map.as_entries(), &[5]);  ",
                "   set.map.insert(3, ());  ",
                "   set.map.sort_unstable_by(|_, a, _, b| a.cmp(b));  ",
                "   assert_eq!(set.map.as_entries(), &[3, 5]);  ",
                "   set.map.insert(4, ());  ",
                "   set.map.sort_unstable_by(|_, a, _, b| a.cmp(b));  ",
                "   assert_eq!(set.map.as_entries(), &[3, 4, 5]);  ",
                "   set.map.insert(2, ());  ",
                "   set.map.sort_unstable_by(|_, a, _, b| a.cmp(b));  ",
                "   assert_eq!(set.map.as_entries(), &[2, 3, 4, 5]);  ",
                "   set.map.insert(1, ());  ",
                "   set.map.sort_unstable_by(|_, a, _, b| a.cmp(b));  ",
                "   assert_eq!(set.map.as_entries(), &[1, 2, 3, 4, 5]);  ",
                "   set.map.insert(6, ());  ",
                "   set.map.sort_unstable_by(|_, a, _, b| a.cmp(b));  ",
                "   assert_eq!(set.map.as_entries(), &[1, 2, 3, 4, 5, 6]);  ",
                "   set.map.clear();  ",
                "   set.map.sort_unstable_by(|_, a, _, b| a.cmp(b));  ",
                "   assert!(set.map.as_entries().is_empty());  ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "",
                "    set.sort_unstable_by(|a, b| a.cmp(b));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(set.map.len(), 0);",
                "    let values: Vec<i32> = vec![5, 1, 3, 2, 4];",
                "    set.map.extend(values.into_iter().map(|v| (v, ())));",
                "    set.sort_unstable_by(|a, b| a.cmp(b));",
                "    let sorted_values: Vec<i32> = set.map.keys().cloned().collect();",
                "    assert_eq!(sorted_values, vec![1, 2, 3, 4, 5]);",
                "    assert_eq!(set.map.len(), 5);",
                "    set.sort_unstable_by(|a, b| b.cmp(a));",
                "    let reverse_sorted_values: Vec<i32> = set.map.keys().cloned().collect();",
                "    assert_eq!(reverse_sorted_values, vec![5, 4, 3, 2, 1]);"
              ],
              "code": [
                "{",
                "    struct TestSet {",
                "        map: IndexMap<i32, (), RandomState>,",
                "    }",
                "    ",
                "    let mut set = TestSet {",
                "        map: IndexMap::new(),",
                "    };",
                "",
                "   let mut keys: Vec<_> = set.map.keys().cloned().collect();",
                "   keys.sort_unstable_by(|a, b| a.cmp(b));",
                "   assert_eq!(set.map.len(), 0);",
                "   let values: Vec<i32> = vec![5, 1, 3, 2, 4];",
                "   set.map.extend(values.into_iter().map(|v| (v, ())));",
                "    let sorted_values: Vec<i32> = set.map.keys().cloned().collect();",
                "    assert_eq!(sorted_values, vec![1, 2, 3, 4, 5]);",
                "   assert_eq!(set.map.len(), 5);",
                "   let mut keys: Vec<_> = set.map.keys().cloned().collect();",
                "   keys.sort_unstable_by(|a, b| b.cmp(a));",
                "   assert_eq!(keys, vec![5, 4, 3, 2, 1]);",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}