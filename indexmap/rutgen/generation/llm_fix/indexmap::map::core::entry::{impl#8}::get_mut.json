{
  "name": "indexmap::map::core::entry::{impl#8}::get_mut",
  "mod_info": {
    "name": "map::core::entry",
    "loc": "src/map/core.rs:10:1:10:11"
  },
  "visible": true,
  "loc": "src/map/core/entry.rs:465:5:467:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: &mut self.map.entries[self.index].value\n"
      ],
      "input_infer": "Valid input conditions: self must be a mutable reference to IndexedEntry with non-empty entries, index must be within the range [0, entries.len() - 1], and map must not be borrowed elsewhere concurrently.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut entries: Vec<Bucket<i32, i32>> = vec![",
                "        Bucket { hash: HashValue(1), key: 1, value: 10 },",
                "        Bucket { hash: HashValue(2), key: 2, value: 20 },",
                "    ];",
                "    let mut ref_mut = RefMut {",
                "        indices: &mut Indices::new(),",
                "        entries: &mut Entries { data: entries },",
                "    };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 1;",
                "",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "}"
              ],
              "oracle": [
                "    let mut entries: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(1), key: 1, value: 10 }, Bucket { hash: HashValue(2), key: 2, value: 20 }];",
                "    let mut ref_mut = RefMut { indices: &mut Indices::new(), entries: &mut Entries { data: entries } };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 1;",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "    assert_eq!(*value_mut, 20);",
                "    *value_mut = 30;",
                "    assert_eq!(map.entries.entries[index].value, 30);"
              ],
              "code": [
                "{",
                "  let mut entries: Vec<crate::Bucket<i32, i32>> = vec![  ",
                "      crate::Bucket { hash: HashValue(1), key: 1, value: 10 },  ",
                "      crate::Bucket { hash: HashValue(2), key: 2, value: 20 },  ",
                "  ];",
                "  let mut ref_mut = RefMut {",
                "      indices: &mut crate::map::core::Indices::new(),",
                "      entries: &mut Entries { data: entries },",
                "  };",
                "  let mut map = IndexMapCore { entries: ref_mut, indices: crate::map::core::Indices::new() };",
                "   let index = 1;",
                "",
                "   let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "   let value_mut = indexed_entry.get_mut();",
                "   let mut entries: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(1), key: 1, value: 10 }, Bucket { hash: HashValue(2), key: 2, value: 20 }];",
                "   let mut ref_mut = RefMut { indices: &mut crate::map::core::Indices::new(), entries: &mut Entries { data: entries } };",
                "  let mut map = IndexMapCore { entries: ref_mut, indices: crate::map::core::Indices::new() };",
                "  let index = 1;",
                "  let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "  let value_mut = indexed_entry.get_mut();",
                "  assert_eq!(*value_mut, 20);",
                "  *value_mut = 30;",
                "  assert_eq!(map.entries[index].value, 30);  ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut entries: Vec<Bucket<i32, i32>> = vec![",
                "        Bucket { hash: HashValue(1), key: 1, value: 30 },",
                "    ];",
                "    let mut ref_mut = RefMut {",
                "        indices: &mut Indices::new(),",
                "        entries: &mut Entries { data: entries },",
                "    };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 0;",
                "",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(*value_mut, 30);",
                "    assert_eq!(value_mut as *mut _, &mut map.entries.data[index].value as *mut _);",
                "    *value_mut = 42;",
                "    assert_eq!(map.entries.data[index].value, 42);",
                "    assert!(indexed_entry.map.entries.data.len() == 1);",
                "    assert!(!std::ptr::eq(value_mut, &mut map.entries.data[index].value));"
              ],
              "code": [
                "{",
                "  use crate::Bucket;",
                "  let mut entries = vec![",
                "      Bucket { hash: HashValue(1), key: 1, value: 30 },",
                "  ];",
                "   let mut ref_mut = RefMut {",
                "      indices: &mut crate::map::core::Indices::new(),",
                "      entries: &mut Entries { entries },",
                "  };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 0;",
                "",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "    assert_eq!(*value_mut, 30);",
                "    assert_eq!(value_mut as *mut _, &mut map.entries.data[index].value as *mut _);",
                "    *value_mut = 42;",
                "    assert_eq!(map.entries.data[index].value, 42);",
                "  assert!(indexed_entry.map.entries.len() == 1);  ",
                "   assert!(!std::ptr::eq(value_mut, &mut map.entries.entries[index].value));  ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut entries: Vec<Bucket<i32, i32>> = vec![];",
                "    let mut ref_mut = RefMut {",
                "        indices: &mut Indices::new(),",
                "        entries: &mut Entries { data: entries },",
                "    };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 0;",
                "",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(value_mut, &mut map.entries.entries.data[index].value);",
                "    assert_eq!(value_mut as *mut _, &mut indexed_entry.map.entries[index].value as *mut _);",
                "    assert!(std::ptr::eq(value_mut, &mut map.entries.entries.data[index].value));",
                "    assert!(std::ptr::eq(value_mut, indexed_entry.key_mut()));",
                "    assert!(value_mut.is_mut());",
                "    assert!(value_mut == &mut map.entries.entries.data[index].value);"
              ],
              "code": [
                "{",
                "   let mut entries: std::vec::Vec<crate::Bucket<i32, i32>> = vec![];  ",
                "   let mut indices = Indices::new();",
                "   let mut ref_mut = RefMut {",
                "       indices: &mut indices,",
                "       entries: &mut Entries { data: entries },",
                "   };",
                "   let mut map = IndexMapCore { entries: ref_mut, indices };",
                "    let index = 0;",
                "",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "    assert_eq!(value_mut, &mut map.entries.entries.data[index].value);",
                "    assert_eq!(value_mut as *mut _, &mut indexed_entry.map.entries[index].value as *mut _);",
                "    assert!(std::ptr::eq(value_mut, &mut map.entries.entries.data[index].value));",
                "    assert!(std::ptr::eq(value_mut, indexed_entry.key_mut()));",
                "    assert!(value_mut.is_mut());",
                "    assert!(value_mut == &mut map.entries.entries.data[index].value);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut entries: Vec<Bucket<i32, i32>> = vec![",
                "        Bucket { hash: HashValue(1), key: 3, value: 40 },",
                "    ];",
                "    let mut ref_mut = RefMut {",
                "        indices: &mut Indices::new(),",
                "        entries: &mut Entries { data: entries },",
                "    };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 1; // Out of bounds",
                "",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "}"
              ],
              "oracle": [
                "    let mut entries: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(1), key: 3, value: 40 }];",
                "    let mut ref_mut = RefMut { indices: &mut Indices::new(), entries: &mut Entries { data: entries } };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 0; // Valid index",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "    assert_eq!(*value_mut, 40); // Check mutable reference to value",
                "    *value_mut = 50; // Modify the value through the mutable reference",
                "    assert_eq!(indexed_entry.get(), &50); // Check if the modification is reflected in the value",
                "    assert_eq!(map.entries.entries.data[index].value, 50); // Ensure the value in the map is updated"
              ],
              "code": [
                "{",
                "  let mut entries: Vec<crate::Bucket<i32, i32>> = vec![  ",
                "      crate::Bucket { hash: HashValue(1), key: 3, value: 40 },  ",
                "    ];",
                "    let mut ref_mut = RefMut {",
                "        indices: &mut Indices::new(),",
                "        entries: &mut Entries { data: entries },",
                "    };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 1; // Out of bounds",
                "",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "    let mut entries: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(1), key: 3, value: 40 }];",
                "    let mut ref_mut = RefMut { indices: &mut Indices::new(), entries: &mut Entries { data: entries } };",
                "    let mut map = IndexMapCore { entries: ref_mut };",
                "    let index = 0; // Valid index",
                "    let mut indexed_entry = IndexedEntry::new(&mut map, index);",
                "    let value_mut = indexed_entry.get_mut();",
                "    assert_eq!(*value_mut, 40); // Check mutable reference to value",
                "    *value_mut = 50; // Modify the value through the mutable reference",
                "    assert_eq!(indexed_entry.get(), &50); // Check if the modification is reflected in the value",
                "    assert_eq!(map.entries.entries.data[index].value, 50); // Ensure the value in the map is updated",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}