{
  "name": "indexmap::map::{impl#7}::last_entry",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:123:1:123:13"
  },
  "visible": true,
  "loc": "src/map.rs:1261:5:1263:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.len().checked_sub(1)? at line 1262 is Err/None\n"
      ],
      "input_infer": "self must be an empty IndexMap or contain one entry only; test cases: empty map (len() = 0) and map with one entry (len() = 1).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::hash::DummyHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::hash::DummyHasher",
                "        }",
                "    }",
                "",
                "    let mut map: IndexMap<i32, i32, TestHasher> = IndexMap::with_hasher(TestHasher);",
                "    let entry = map.last_entry();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry, None);"
              ],
              "code": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::hash::DummyHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::hash::DummyHasher",
                "        }",
                "    }",
                "",
                "    let mut map: IndexMap<i32, i32, TestHasher> = IndexMap::with_hasher(TestHasher);",
                "    let entry = map.last_entry();",
                "    assert_eq!(entry, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::hash::DummyHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::hash::DummyHasher",
                "        }",
                "    }",
                "",
                "    let mut map: IndexMap<i32, i32, TestHasher> = IndexMap::with_hasher(TestHasher);",
                "    map.insert(1, 10);",
                "    let entry = map.last_entry();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry, None);"
              ],
              "code": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::hash::DummyHasher;",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::hash::DummyHasher",
                "        }",
                "    }",
                "",
                "    let mut map: IndexMap<i32, i32, TestHasher> = IndexMap::with_hasher(TestHasher);",
                "    map.insert(1, 10);",
                "    let entry = map.last_entry();",
                "    assert_eq!(entry, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.len().checked_sub(1)? at line 1262 is Ok/Some\n"
      ],
      "input_infer": "self.len() > 0 with various sizes of IndexMap including 1, 10, and maximum capacity settings for K and V types to ensure edge cases are covered.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                "    map.insert(1, 10);",
                "    let entry = map.last_entry();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(entry.is_some(), true);",
                "    assert_eq!(entry.unwrap().index, 0);",
                "    assert_eq!(entry.unwrap().map.get(&1), Some(&10));",
                "    assert_eq!(map.len(), 1);"
              ],
              "code": [
                "{",
                "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                "    map.insert(1, 10);",
                "    let entry = map.last_entry();",
                "    assert_eq!(entry.is_some(), true);",
                "    assert_eq!(entry.unwrap().index, 0);",
                "    assert_eq!(entry.unwrap().map.get(&1), Some(&10));",
                "    assert_eq!(map.len(), 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                "    for i in 0..10 {",
                "        map.insert(i, i * 10);",
                "    }",
                "    let entry = map.last_entry();",
                "}"
              ],
              "oracle": [
                "    assert!(entry.is_some());",
                "    let (key, value) = entry.unwrap();",
                "    assert_eq!(key, 9);",
                "    assert_eq!(value, 90);"
              ],
              "code": [
                "{",
                "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                "    for i in 0..10 {",
                "        map.insert(i, i * 10);",
                "    }",
                "    let entry = map.last_entry();",
                "    assert!(entry.is_some());",
                "    let (key, value) = entry.unwrap();",
                "    assert_eq!(key, 9);",
                "    assert_eq!(value, 90);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
                "    for i in 0..u32::MAX {",
                "        map.insert(i, i * 2);",
                "        if map.len() == 10 { // Using a small number for practicality",
                "            break;",
                "        }",
                "    }",
                "    let entry = map.last_entry();",
                "}"
              ],
              "oracle": [
                "    assert!(entry.is_some());",
                "    assert_eq!(entry.unwrap().index, 9);",
                "    assert_eq!(entry.unwrap().map.get_index(9).unwrap(), (&9, &18));"
              ],
              "code": [
                "{",
                "    let mut map: IndexMap<u32, u32> = IndexMap::new();",
                "    for i in 0..u32::MAX {",
                "        map.insert(i, i * 2);",
                "        if map.len() == 10 { // Using a small number for practicality",
                "            break;",
                "        }",
                "    }",
                "    let entry = map.last_entry();",
                "    assert!(entry.is_some());",
                "    assert_eq!(entry.unwrap().index, 9);",
                "    assert_eq!(entry.unwrap().map.get_index(9).unwrap(), (&9, &18));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}