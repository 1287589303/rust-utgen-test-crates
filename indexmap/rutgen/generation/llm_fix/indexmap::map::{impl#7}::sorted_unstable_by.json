{
  "name": "indexmap::map::{impl#7}::sorted_unstable_by",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:123:1:123:13"
  },
  "visible": true,
  "loc": "src/map.rs:1057:5:1064:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid key-value pairs with various types for K and V, including edge cases like empty map, single entry, duplicate keys (if allowed), and complex key types; comparator function F must handle all presented key-value types without panic and be consistent in returned Ordering; map should accommodate high capacity to test performance under load.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let map: IndexMap<i32, i32> = IndexMap::new();",
                "    let _result = map.sorted_unstable_by(|_k1, _v1, _k2, _v2| Ordering::Equal);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result.as_slice().len(), 0);",
                "    assert_eq!(_result.iter.clone().collect::<Vec<_>>(), vec![]);",
                "    assert_eq!(_result.as_mut_slice().len(), 0);",
                "    assert_eq!(_result.iter().next(), None);",
                "    assert!(_result.iter().count() == 0);"
              ],
              "code": [
                "{",
                "    let map: IndexMap<i32, i32> = IndexMap::new();",
                "    let _result = map.sorted_unstable_by(|_k1, _v1, _k2, _v2| Ordering::Equal);",
                "    assert_eq!(_result.as_slice().len(), 0);",
                "    assert_eq!(_result.iter.clone().collect::<Vec<_>>(), vec![]);",
                "    assert_eq!(_result.as_mut_slice().len(), 0);",
                "    assert_eq!(_result.iter().next(), None);",
                "    assert!(_result.iter().count() == 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    map.insert(1, 100);",
                "    let _result = map.sorted_unstable_by(|_k1, _v1, _k2, _v2| Ordering::Equal);",
                "}"
              ],
              "oracle": [
                "    let map = IndexMap::new();",
                "    map.insert(1, 100);",
                "    let result = map.sorted_unstable_by(|_k1, _v1, _k2, _v2| Ordering::Equal);",
                "    assert_eq!(result.as_slice(), vec![(1, 100)].as_slice());",
                "    assert!(result.iter.len() == 1);",
                "    assert!(result.iter().next().is_some());"
              ],
              "code": [
                "{",
                "   let mut map = IndexMap::new();",
                "   map.insert(1, 100);",
                "   let _result = map.sorted_unstable_by(|_k1, _v1, _k2, _v2| Ordering::Equal);",
                "   let mut map = IndexMap::new();",
                "   map.insert(1, 100);",
                "    let result = map.sorted_unstable_by(|_k1, _v1, _k2, _v2| Ordering::Equal);",
                "    assert_eq!(result.as_slice(), vec![(1, 100)].as_slice());",
                "   assert!(result.len() == 1);",
                "   assert!(result.into_iter().next().is_some());",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    map.insert(3, 300);",
                "    map.insert(1, 100);",
                "    map.insert(2, 200);",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2)));",
                "}"
              ],
              "oracle": [
                "    let mut map = IndexMap::new();",
                "    map.insert(3, 300);",
                "    map.insert(1, 100);",
                "    map.insert(2, 200);",
                "    assert_eq!(map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2))).as_slice(), vec![(1, 100), (2, 200), (3, 300)]);",
                "    assert_eq!(map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2)).as_slice(), vec![(1, 100), (2, 200), (3, 300)]);"
              ],
              "code": [
                "{",
                "    let mut map = IndexMap::new();",
                "    map.insert(3, 300);",
                "    map.insert(1, 100);",
                "    map.insert(2, 200);",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2)));",
                "    let mut map = IndexMap::new();",
                "    map.insert(3, 300);",
                "    map.insert(1, 100);",
                "    map.insert(2, 200);",
                "    assert_eq!(map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2))).as_slice(), vec![(1, 100), (2, 200), (3, 300)]);",
                "    assert_eq!(map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2)).as_slice(), vec![(1, 100), (2, 200), (3, 300)]);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    map.insert(1, 100);",
                "    map.insert(1, 200);",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2)));",
                "}"
              ],
              "oracle": [
                "    let mut map = IndexMap::new();",
                "    assert_eq!(map.len(), 0);",
                "    map.insert(1, 100);",
                "    assert_eq!(map.len(), 1);",
                "    map.insert(1, 200);",
                "    assert_eq!(map.len(), 1);",
                "    let result: Vec<(i32, i32)> = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2))).collect();",
                "    assert_eq!(result.len(), 1);",
                "    assert_eq!(result[0], (1, 200));"
              ],
              "code": [
                "{",
                "    let mut map = IndexMap::new();",
                "    map.insert(1, 100);",
                "    map.insert(1, 200);",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2)));",
                "    let mut map = IndexMap::new();",
                "    assert_eq!(map.len(), 0);",
                "    map.insert(1, 100);",
                "    assert_eq!(map.len(), 1);",
                "    map.insert(1, 200);",
                "    assert_eq!(map.len(), 1);",
                "    let result: Vec<(i32, i32)> = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2))).collect();",
                "    assert_eq!(result.len(), 1);",
                "    assert_eq!(result[0], (1, 200));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Eq, PartialEq, Ord, PartialOrd)]",
                "    struct ComplexKey {",
                "        id: i32,",
                "        name: String,",
                "    }",
                "    ",
                "    let mut map = IndexMap::new();",
                "    map.insert(ComplexKey { id: 2, name: \"B\".to_string() }, 200);",
                "    map.insert(ComplexKey { id: 1, name: \"A\".to_string() }, 100);",
                "    ",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| {",
                "        k1.id.cmp(&k2.id).then(k1.name.cmp(&k2.name)).then(v1.cmp(v2))",
                "    });",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.len(), 2);",
                "    assert_eq!(map.get_index(0), Some((&ComplexKey { id: 1, name: \"A\".to_string() }, &100)));",
                "    assert_eq!(map.get_index(1), Some((&ComplexKey { id: 2, name: \"B\".to_string() }, &200)));",
                "    let sorted_entries: Vec<_> = map.sorted_unstable_by(|k1, v1, k2, v2| {",
                "    k1.id.cmp(&k2.id).then(k1.name.cmp(&k2.name)).then(v1.cmp(v2))",
                "    }).into_iter().collect();",
                "    assert_eq!(sorted_entries.len(), 2);",
                "    assert_eq!(sorted_entries[0], Bucket { hash: HashValue::from(0), key: ComplexKey { id: 1, name: \"A\".to_string() }, value: 100 });",
                "    assert_eq!(sorted_entries[1], Bucket { hash: HashValue::from(1), key: ComplexKey { id: 2, name: \"B\".to_string() }, value: 200 });"
              ],
              "code": [
                "{",
                "    #[derive(Eq, PartialEq, Ord, PartialOrd)]",
                "    struct ComplexKey {",
                "        id: i32,",
                "        name: String,",
                "    }",
                "    ",
                "    let mut map = IndexMap::new();",
                "    map.insert(ComplexKey { id: 2, name: \"B\".to_string() }, 200);",
                "    map.insert(ComplexKey { id: 1, name: \"A\".to_string() }, 100);",
                "    ",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| {",
                "        k1.id.cmp(&k2.id).then(k1.name.cmp(&k2.name)).then(v1.cmp(v2))",
                "    });",
                "    assert_eq!(map.len(), 2);",
                "    assert_eq!(map.get_index(0), Some((&ComplexKey { id: 1, name: \"A\".to_string() }, &100)));",
                "    assert_eq!(map.get_index(1), Some((&ComplexKey { id: 2, name: \"B\".to_string() }, &200)));",
                "    let sorted_entries: Vec<_> = map.sorted_unstable_by(|k1, v1, k2, v2| {",
                "    k1.id.cmp(&k2.id).then(k1.name.cmp(&k2.name)).then(v1.cmp(v2))",
                "    }).into_iter().collect();",
                "    assert_eq!(sorted_entries.len(), 2);",
                "    assert_eq!(sorted_entries[0], Bucket { hash: HashValue::from(0), key: ComplexKey { id: 1, name: \"A\".to_string() }, value: 100 });",
                "    assert_eq!(sorted_entries[1], Bucket { hash: HashValue::from(1), key: ComplexKey { id: 2, name: \"B\".to_string() }, value: 200 });",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    for i in (0..1000).rev() {",
                "        map.insert(i, i * 10);",
                "    }",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2)));",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.first(), Some((&0, &0)));",
                "    assert_eq!(map.last(), Some((&999, &9990)));",
                "    assert_eq!(map.get_index(0), Some((&0, &0)));",
                "    assert_eq!(map.get_index(999), Some((&999, &9990)));",
                "    assert_eq!(map.len(), 1000);",
                "    assert!(map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2))).as_slice().iter().all(|bucket| bucket.key < bucket.value));",
                "    assert!(map.get_range(0..100).unwrap().iter().all(|(_, value)| *value < 1000));",
                "    assert_eq!(map.partition_point(|k, v| *k < 500), 500);",
                "    map.reverse();",
                "    assert_eq!(map.first(), Some((&999, &9990)));",
                "    assert_eq!(map.last(), Some((&0, &0)));"
              ],
              "code": [
                "{",
                "    let mut map = IndexMap::new();",
                "    for i in (0..1000).rev() {",
                "        map.insert(i, i * 10);",
                "    }",
                "    let _result = map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2)));",
                "    assert_eq!(map.first(), Some((&0, &0)));",
                "    assert_eq!(map.last(), Some((&999, &9990)));",
                "    assert_eq!(map.get_index(0), Some((&0, &0)));",
                "    assert_eq!(map.get_index(999), Some((&999, &9990)));",
                "    assert_eq!(map.len(), 1000);",
                "   assert!(map.sorted_unstable_by(|k1, v1, k2, v2| k1.cmp(k2).then(v1.cmp(v2))).as_slice().iter().all(|&(_, value)| value < &value));",
                "   assert!(map.get_range(0..100).unwrap().iter().all(|(_, value)| *value < 1000));",
                "    assert_eq!(map.partition_point(|k, v| *k < 500), 500);",
                "    map.reverse();",
                "    assert_eq!(map.first(), Some((&999, &9990)));",
                "    assert_eq!(map.last(), Some((&0, &0)));",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}