{
  "name": "indexmap::set::{impl#11}::extend",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:124:1:124:13"
  },
  "visible": true,
  "loc": "src/set.rs:1156:5:1159:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "iterable must be an instance of IntoIterator where the Item type T is Hash, Eq, and Copy; additionally, test with an empty iterator, a single-item iterator, and an iterator with multiple items including boundary cases such as maximum and minimum values for type T.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::collections::hash_map::RandomState;",
                "",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::RandomState::new()",
                "        }",
                "    }",
                "",
                "    let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };",
                "    let empty_iter: Vec<i32> = vec![];",
                "    index_set.extend(empty_iter.iter());",
                "}"
              ],
              "oracle": [
                "    index_set.map.core.len() == 0;",
                "    index_set.map.core.is_empty() == true;",
                "    index_set.map.core.capacity() >= 0;",
                "    index_set.extend(vec![1, 2, 3].iter());",
                "    index_set.map.core.len() == 3;",
                "    index_set.map.core.contains_key(&1) == true;",
                "    index_set.map.core.contains_key(&2) == true;",
                "    index_set.map.core.contains_key(&3) == true;",
                "    index_set.extend(vec![4, 5].iter());",
                "    index_set.map.core.len() == 5;",
                "    index_set.map.core.contains_key(&4) == true;",
                "    index_set.map.core.contains_key(&5) == true;",
                "    index_set.extend(vec![1, 2].iter());",
                "    index_set.map.core.len() == 5;  // No duplicates added",
                "    index_set.extend(vec![-1, -2].iter());",
                "    index_set.map.core.len() == 7;  // New distinct values added",
                "    index_set.map.core.contains_key(&-1) == true;",
                "    index_set.map.core.contains_key(&-2) == true;"
              ],
              "code": [
                "{",
                "   struct TestHasher;",
                "",
                "   impl BuildHasher for TestHasher {",
                "       type Hasher = std::collections::hash_map::DefaultHasher;",
                "",
                "       fn build_hasher(&self) -> Self::Hasher {",
                "           std::collections::hash_map::DefaultHasher::new()",
                "       }",
                "   }",
                "",
                "    let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };",
                "    let empty_iter: Vec<i32> = vec![];",
                "    index_set.extend(empty_iter.iter());",
                "    index_set.map.core.len() == 0;",
                "   index_set.map.core.len() == 0;",
                "   index_set.map.core.capacity() >= 0;",
                "    index_set.extend(vec![1, 2, 3].iter());",
                "    index_set.map.core.len() == 3;",
                "   index_set.map.contains_key(&1) == true;",
                "   index_set.map.contains_key(&2) == true;",
                "   index_set.map.contains_key(&3) == true;",
                "   index_set.extend(vec![4, 5].iter());",
                "   index_set.map.len() == 5;",
                "   index_set.map.contains_key(&4) == true;",
                "   index_set.map.contains_key(&5) == true;",
                "   index_set.extend(vec![1, 2].iter());",
                "   index_set.map.len() == 5;  // No duplicates added",
                "    index_set.extend(vec![-1, -2].iter());",
                "    index_set.map.core.len() == 7;  // New distinct values added",
                "   index_set.map.contains_key(&-1) == true;",
                "   index_set.map.contains_key(&-2) == true;",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::collections::hash_map::RandomState;",
                "",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::RandomState::new()",
                "        }",
                "    }",
                "",
                "    let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };",
                "    let single_item_iter = vec![42];",
                "    index_set.extend(single_item_iter.iter());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_set.map.core.len(), 1);",
                "    assert!(index_set.map.core.contains_key(&42));",
                "    assert_eq!(index_set.map.hash_builder.build_hasher().finish(), index_set.map.hash_builder.build_hasher().finish());",
                "    assert_eq!(index_set.map.core.entries().next().unwrap().0, 42);",
                "    assert!(index_set.map.extend(single_item_iter.iter()).is_ok());"
              ],
              "code": [
                "{",
                "   struct TestHasher;",
                "",
                "   impl BuildHasher for TestHasher {",
                "       type Hasher = std::collections::hash_map::DefaultHasher;",
                "",
                "       fn build_hasher(&self) -> Self::Hasher {",
                "           std::collections::hash_map::DefaultHasher::new()",
                "       }",
                "   }",
                "",
                "    let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };",
                "    let single_item_iter = vec![42];",
                "    index_set.extend(single_item_iter.iter());",
                "    assert_eq!(index_set.map.core.len(), 1);",
                "   assert!(index_set.map.contains_key(&42));",
                "   assert!(index_set.map.is_empty() == index_set.map.is_empty());  ",
                "    assert_eq!(index_set.map.core.entries().next().unwrap().0, 42);",
                "   index_set.extend(single_item_iter.iter().cloned());",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::collections::hash_map::RandomState;",
                "",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::RandomState::new()",
                "        }",
                "    }",
                "",
                "    let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };",
                "    let multiple_items_iter = vec![1, 2, 3, 4, 5];",
                "    index_set.extend(multiple_items_iter.iter());",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_set.map.core.len(), 5);",
                "    assert!(index_set.map.core.contains_key(&1));",
                "    assert!(index_set.map.core.contains_key(&2));",
                "    assert!(index_set.map.core.contains_key(&3));",
                "    assert!(index_set.map.core.contains_key(&4));",
                "    assert!(index_set.map.core.contains_key(&5));",
                "    assert!(!index_set.map.core.contains_key(&0));",
                "    index_set.extend(vec![6, 7, 8].iter());",
                "    assert_eq!(index_set.map.core.len(), 8);",
                "    assert!(index_set.map.core.contains_key(&6));",
                "    assert!(index_set.map.core.contains_key(&7));",
                "    assert!(index_set.map.core.contains_key(&8));"
              ],
              "code": [
                "{",
                "   struct TestHasher;",
                "   ",
                "   impl BuildHasher for TestHasher {",
                "       type Hasher = std::collections::hash_map::DefaultHasher;",
                "   ",
                "       fn build_hasher(&self) -> Self::Hasher {",
                "           std::collections::hash_map::DefaultHasher::new()",
                "       }",
                "   }",
                "",
                "   let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };  ",
                "   let multiple_items_iter = vec![1, 2, 3, 4, 5];  ",
                "   index_set.extend(multiple_items_iter.iter());  ",
                "   assert_eq!(index_set.map.core.len(), 5);  ",
                "   assert!(index_set.map.contains_key(&1));  ",
                "   assert!(index_set.map.contains_key(&2));  ",
                "   assert!(index_set.map.contains_key(&3));  ",
                "   assert!(index_set.map.contains_key(&4));  ",
                "   assert!(index_set.map.contains_key(&5));  ",
                "   assert!(!index_set.map.contains_key(&0));  ",
                "   index_set.extend(vec![6, 7, 8].iter());  ",
                "   assert_eq!(index_set.map.core.len(), 8);  ",
                "   assert!(index_set.map.contains_key(&6));  ",
                "   assert!(index_set.map.contains_key(&7));  ",
                "   assert!(index_set.map.contains_key(&8));  ",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestHasher;",
                "",
                "    impl BuildHasher for TestHasher {",
                "        type Hasher = std::collections::hash_map::RandomState;",
                "",
                "        fn build_hasher(&self) -> Self::Hasher {",
                "            std::collections::hash_map::RandomState::new()",
                "        }",
                "    }",
                "",
                "    let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };",
                "    let boundary_values_iter = vec![i32::MIN, -1, 0, 1, i32::MAX];",
                "    index_set.extend(boundary_values_iter.iter());",
                "}"
              ],
              "oracle": [
                "    index_set.extend(vec![i32::MIN, -1, 0, 1, i32::MAX].iter());",
                "    assert_eq!(index_set.map.core.len(), 5);",
                "    assert!(index_set.map.core.contains_key(&i32::MIN));",
                "    assert!(index_set.map.core.contains_key(&-1));",
                "    assert!(index_set.map.core.contains_key(&0));",
                "    assert!(index_set.map.core.contains_key(&1));",
                "    assert!(index_set.map.core.contains_key(&i32::MAX));",
                "    index_set.extend(vec![1, 2, 3].iter());",
                "    assert_eq!(index_set.map.core.len(), 8);",
                "    assert!(index_set.map.core.contains_key(&2));",
                "    assert!(index_set.map.core.contains_key(&3));",
                "    index_set.extend(vec![0, 0, -1].iter());",
                "    assert_eq!(index_set.map.core.len(), 8);",
                "    index_set.extend(vec![].iter());",
                "    assert_eq!(index_set.map.core.len(), 8);"
              ],
              "code": [
                "{",
                "   struct TestHasher;",
                " ",
                "   impl BuildHasher for TestHasher {",
                "       type Hasher = std::collections::hash_map::DefaultHasher;",
                " ",
                "       fn build_hasher(&self) -> Self::Hasher {",
                "           std::collections::hash_map::DefaultHasher::new()",
                "        }",
                "    }",
                "",
                "    let mut index_set: IndexSet<i32, TestHasher> = IndexSet { map: IndexMap { core: IndexMapCore { /* initialize as needed */ }, hash_builder: TestHasher } };",
                "    let boundary_values_iter = vec![i32::MIN, -1, 0, 1, i32::MAX];",
                "    index_set.extend(boundary_values_iter.iter());",
                "    index_set.extend(vec![i32::MIN, -1, 0, 1, i32::MAX].iter());",
                "    assert_eq!(index_set.map.core.len(), 5);",
                "   assert!(index_set.map.contains_key(&i32::MIN));",
                "   assert!(index_set.map.contains_key(&-1));",
                "   assert!(index_set.map.contains_key(&0));",
                "   assert!(index_set.map.contains_key(&1));",
                "   assert!(index_set.map.contains_key(&i32::MAX));",
                "   index_set.extend(vec![1, 2, 3].iter());",
                "   assert_eq!(index_set.map.len(), 8);",
                "   assert!(index_set.map.contains_key(&2));",
                "   assert!(index_set.map.contains_key(&3));",
                "    index_set.extend(vec![0, 0, -1].iter());",
                "    assert_eq!(index_set.map.core.len(), 8);",
                "    index_set.extend(vec![].iter());",
                "    assert_eq!(index_set.map.core.len(), 8);",
                "}"
              ],
              "can_compile": false,
              "repaired": true
            }
          ]
        }
      ]
    }
  ]
}