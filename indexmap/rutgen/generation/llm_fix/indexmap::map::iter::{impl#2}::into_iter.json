{
  "name": "indexmap::map::iter::{impl#2}::into_iter",
  "mod_info": {
    "name": "map::iter",
    "loc": "src/map.rs:5:1:5:10"
  },
  "visible": true,
  "loc": "src/map/iter.rs:33:5:35:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Test with an IndexMap containing no entries, an IndexMap with a single entry, and an IndexMap with multiple entries (including edge cases with maximum size or capacity) while ensuring different key and value types as well as varying hash builders.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let index_map: super::IndexMap<i32, i32, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    let iter = index_map.into_iter();",
                "}"
              ],
              "oracle": [
                "    let index_map: super::IndexMap<i32, i32, DummyHasher> = super::IndexMap { core: super::IndexMapCore { indices: super::Indices::new(), entries: super::Entries::new(), }, hash_builder: DummyHasher, };",
                "    let iter = index_map.into_iter();",
                "    assert!(iter.as_slice().is_empty());",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    let iter = index_map.into_iter();",
                "    assert_eq!(iter.as_slice(), &[(1, 10), (2, 20)]);",
                "    assert_eq!(iter.as_mut_slice(), &mut [(1, 10), (2, 20)]);",
                "    let iter = index_map.into_iter();",
                "    let (key, value) = iter.next().unwrap();",
                "    assert_eq!(key, 1);",
                "    assert_eq!(value, 10);",
                "    assert_eq!(iter.next(), Some((2, 20)));",
                "    assert_eq!(iter.next(), None);",
                "    assert!(iter.is_fused());"
              ],
              "code": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let index_map: super::IndexMap<i32, i32, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    let iter = index_map.into_iter();",
                "    let index_map: super::IndexMap<i32, i32, DummyHasher> = super::IndexMap { core: super::IndexMapCore { indices: super::Indices::new(), entries: super::Entries::new(), }, hash_builder: DummyHasher, };",
                "    let iter = index_map.into_iter();",
                "    assert!(iter.as_slice().is_empty());",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    let iter = index_map.into_iter();",
                "    assert_eq!(iter.as_slice(), &[(1, 10), (2, 20)]);",
                "    assert_eq!(iter.as_mut_slice(), &mut [(1, 10), (2, 20)]);",
                "    let iter = index_map.into_iter();",
                "    let (key, value) = iter.next().unwrap();",
                "    assert_eq!(key, 1);",
                "    assert_eq!(value, 10);",
                "    assert_eq!(iter.next(), Some((2, 20)));",
                "    assert_eq!(iter.next(), None);",
                "    assert!(iter.is_fused());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let mut index_map: super::IndexMap<i32, String, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    index_map.core.entries.push(super::Bucket { hash: 1, key: 1, value: String::from(\"one\") });",
                "",
                "    let iter = index_map.into_iter();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(iter.as_slice().len(), 1);",
                "    assert_eq!(iter.as_slice()[0].0, 1);",
                "    assert_eq!(iter.as_slice()[0].1, \"one\");",
                "    assert!(iter.as_mut_slice().len() == 1);",
                "    iter.as_mut_slice()[0].1 = String::from(\"updated\");",
                "    assert_eq!(iter.as_slice()[0].1, \"updated\");"
              ],
              "code": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let mut index_map: super::IndexMap<i32, String, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    index_map.core.entries.push(super::Bucket { hash: 1, key: 1, value: String::from(\"one\") });",
                "",
                "    let iter = index_map.into_iter();",
                "    assert_eq!(iter.as_slice().len(), 1);",
                "    assert_eq!(iter.as_slice()[0].0, 1);",
                "    assert_eq!(iter.as_slice()[0].1, \"one\");",
                "    assert!(iter.as_mut_slice().len() == 1);",
                "    iter.as_mut_slice()[0].1 = String::from(\"updated\");",
                "    assert_eq!(iter.as_slice()[0].1, \"updated\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let mut index_map: super::IndexMap<String, Vec<i32>, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    index_map.core.entries.push(super::Bucket { hash: 1, key: String::from(\"one\"), value: vec![1, 2, 3] });",
                "    index_map.core.entries.push(super::Bucket { hash: 2, key: String::from(\"two\"), value: vec![4, 5, 6] });",
                "",
                "    let iter = index_map.into_iter();",
                "}"
              ],
              "oracle": [
                "    let iter = index_map.into_iter();",
                "    assert_eq!(iter.as_slice().len(), 2);",
                "    assert_eq!(iter.as_slice()[0].key, String::from(\"one\"));",
                "    assert_eq!(iter.as_slice()[0].value, vec![1, 2, 3]);",
                "    assert_eq!(iter.as_slice()[1].key, String::from(\"two\"));",
                "    assert_eq!(iter.as_slice()[1].value, vec![4, 5, 6]);",
                "    assert!(iter.as_mut_slice().len() == 2);",
                "    iter.as_mut_slice()[0].value.push(7);",
                "    assert_eq!(iter.as_mut_slice()[0].value, vec![1, 2, 3, 7]);"
              ],
              "code": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let mut index_map: super::IndexMap<String, Vec<i32>, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    index_map.core.entries.push(super::Bucket { hash: 1, key: String::from(\"one\"), value: vec![1, 2, 3] });",
                "    index_map.core.entries.push(super::Bucket { hash: 2, key: String::from(\"two\"), value: vec![4, 5, 6] });",
                "",
                "    let iter = index_map.into_iter();",
                "    let iter = index_map.into_iter();",
                "    assert_eq!(iter.as_slice().len(), 2);",
                "    assert_eq!(iter.as_slice()[0].key, String::from(\"one\"));",
                "    assert_eq!(iter.as_slice()[0].value, vec![1, 2, 3]);",
                "    assert_eq!(iter.as_slice()[1].key, String::from(\"two\"));",
                "    assert_eq!(iter.as_slice()[1].value, vec![4, 5, 6]);",
                "    assert!(iter.as_mut_slice().len() == 2);",
                "    iter.as_mut_slice()[0].value.push(7);",
                "    assert_eq!(iter.as_mut_slice()[0].value, vec![1, 2, 3, 7]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let mut index_map: super::IndexMap<u64, u64, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    for i in 0..1000 {",
                "        index_map.core.entries.push(super::Bucket { hash: i as u64, key: i, value: i });",
                "    }",
                "",
                "    let iter = index_map.into_iter();",
                "}"
              ],
              "oracle": [
                "    let expected_length = 1000;",
                "    assert_eq!(iter.iter.len(), expected_length);",
                "    for i in 0..expected_length {",
                "    let (key, value) = iter.iter.next().unwrap();",
                "    assert_eq!(key, i);",
                "    assert_eq!(value, i);",
                "    }",
                "    assert!(iter.iter.next().is_none());"
              ],
              "code": [
                "{",
                "    struct DummyHasher;",
                "",
                "    let mut index_map: super::IndexMap<u64, u64, DummyHasher> = super::IndexMap {",
                "        core: super::IndexMapCore {",
                "            indices: super::Indices::new(),",
                "            entries: super::Entries::new(),",
                "        },",
                "        hash_builder: DummyHasher,",
                "    };",
                "",
                "    for i in 0..1000 {",
                "        index_map.core.entries.push(super::Bucket { hash: i as u64, key: i, value: i });",
                "    }",
                "",
                "    let iter = index_map.into_iter();",
                "    let expected_length = 1000;",
                "    assert_eq!(iter.iter.len(), expected_length);",
                "    for i in 0..expected_length {",
                "    let (key, value) = iter.iter.next().unwrap();",
                "    assert_eq!(key, i);",
                "    assert_eq!(value, i);",
                "    }",
                "    assert!(iter.iter.next().is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}