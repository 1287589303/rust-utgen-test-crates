{
  "name": "indexmap::map::mutable::{impl#0}::retain2",
  "mod_info": {
    "name": "map::mutable",
    "loc": "src/map.rs:6:1:6:13"
  },
  "visible": true,
  "loc": "src/map/mutable.rs:85:5:90:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "&mut self: mutable reference to IndexMap, keep: callable that modifies K and V, and returns a bool; K and V types should be present in IndexMap, ensure the callable can handle edge cases of empty, single-entry, and multiple entries scenarios for retain function behavior.\n",
      "answers": [
        {
          "uses": [
            "use std::collections::hash_map::RandomState;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    ",
                "    index_map.retain2(|_key, _value| true);",
                "}"
              ],
              "oracle": [
                "    index_map.retain2(|key, value| { assert_eq!(key, /* expected key */); assert_eq!(value, /* expected value */); true });",
                "    index_map.retain2(|key, value| { assert!(key > 0); assert!(value > 0); true });",
                "    index_map.retain2(|key, value| { assert!(key % 2 == 0); assert!(value % 2 == 0); true });",
                "    index_map.retain2(|key, value| { assert!(key != /* a specific value */); assert!(value != /* a specific value */); false });",
                "    index_map.retain2(|key, value| { assert!(key + value < /* threshold */); true });"
              ],
              "code": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    ",
                "    index_map.retain2(|_key, _value| true);",
                "   index_map.retain2(|key, value| { assert_eq!(*key, 0); assert_eq!(*value, 0); true });",
                "  index_map.retain2(|key, value| { assert!(*key > 0); assert!(*value > 0); true });  ",
                "  index_map.retain2(|key, value| { assert!(*key % 2 == 0); assert!(*value % 2 == 0); true });",
                "  index_map.retain2(|key, value| { assert!(*key != 5); assert!(*value != 5); false });  ",
                "  index_map.retain2(|key, value| { assert!(*key + *value < 10); true });  ",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    ",
                "    index_map.retain2(|key, value| *key % 2 == 0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_map.len(), 1);",
                "    assert_eq!(index_map.get_full_mut2(&1), Some((0, &mut 1, &mut 10)));",
                "    index_map.insert(2, 20);",
                "    index_map.retain2(|key, value| *value > 15);",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    assert_eq!(index_map.len(), 1);",
                "    index_map.retain2(|_, _| false);",
                "    assert_eq!(index_map.len(), 0);",
                "    index_map.insert(3, 30);",
                "    index_map.insert(4, 40);",
                "    index_map.iter_mut2().for_each(|(key, value)| assert!(*key % 2 == 0));",
                "    index_map.retain2(|key, value| *key > 2);",
                "    assert_eq!(index_map.len(), 1);",
                "    assert_eq!(index_map.get_index_mut2(0), Some((&mut 4, &mut 40)));",
                "    index_map.retain2(|key, _| *key == 3);",
                "    assert!(index_map.get_index_mut2(0).is_none());"
              ],
              "code": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    ",
                "    index_map.retain2(|key, value| *key % 2 == 0);",
                "    assert_eq!(index_map.len(), 1);",
                "    assert_eq!(index_map.get_full_mut2(&1), Some((0, &mut 1, &mut 10)));",
                "    index_map.insert(2, 20);",
                "    index_map.retain2(|key, value| *value > 15);",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    assert_eq!(index_map.len(), 1);",
                "    index_map.retain2(|_, _| false);",
                "    assert_eq!(index_map.len(), 0);",
                "    index_map.insert(3, 30);",
                "    index_map.insert(4, 40);",
                "    index_map.iter_mut2().for_each(|(key, value)| assert!(*key % 2 == 0));",
                "    index_map.retain2(|key, value| *key > 2);",
                "    assert_eq!(index_map.len(), 1);",
                "    assert_eq!(index_map.get_index_mut2(0), Some((&mut 4, &mut 40)));",
                "    index_map.retain2(|key, _| *key == 3);",
                "    assert!(index_map.get_index_mut2(0).is_none());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    index_map.insert(3, 30);",
                "    ",
                "    index_map.retain2(|key, value| *value > 15);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_map.entries.len(), 2);",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    assert!(index_map.get_full_mut2(&1).is_none());",
                "    assert!(index_map.get_full_mut2(&3).is_some());",
                "    assert_eq!(index_map.get_index_mut2(0), Some((&mut 2, &mut 20)));",
                "    assert_eq!(index_map.get_index_mut2(1), Some((&mut 3, &mut 30)));",
                "    assert!(index_map.get_index_mut2(2).is_none());",
                "    assert_eq!(index_map.iter_mut2().count(), 2);",
                "    assert_eq!(index_map.iter_mut2().next().map(|(k, v)| (*k, *v)), Some((2, 20)));",
                "    assert_eq!(index_map.iter_mut2().nth(1).map(|(k, v)| (*k, *v)), Some((3, 30)));"
              ],
              "code": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    index_map.insert(3, 30);",
                "    ",
                "    index_map.retain2(|key, value| *value > 15);",
                "   assert_eq!(index_map.len(), 2);  ",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    assert!(index_map.get_full_mut2(&1).is_none());",
                "    assert!(index_map.get_full_mut2(&3).is_some());",
                "    assert_eq!(index_map.get_index_mut2(0), Some((&mut 2, &mut 20)));",
                "    assert_eq!(index_map.get_index_mut2(1), Some((&mut 3, &mut 30)));",
                "    assert!(index_map.get_index_mut2(2).is_none());",
                "    assert_eq!(index_map.iter_mut2().count(), 2);",
                "    assert_eq!(index_map.iter_mut2().next().map(|(k, v)| (*k, *v)), Some((2, 20)));",
                "    assert_eq!(index_map.iter_mut2().nth(1).map(|(k, v)| (*k, *v)), Some((3, 30)));",
                "}"
              ],
              "can_compile": true,
              "repaired": true
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    ",
                "    index_map.retain2(|_key, _value| false);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_map.len(), 2);",
                "    assert_eq!(index_map.get_full_mut2(&1), Some((0, &mut 1, &mut 10)));",
                "    assert_eq!(index_map.get_full_mut2(&2), Some((1, &mut 2, &mut 20)));",
                "    index_map.retain2(|_key, _value| true);",
                "    assert_eq!(index_map.len(), 2);"
              ],
              "code": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    ",
                "    index_map.retain2(|_key, _value| false);",
                "    assert_eq!(index_map.len(), 2);",
                "    assert_eq!(index_map.get_full_mut2(&1), Some((0, &mut 1, &mut 10)));",
                "    assert_eq!(index_map.get_full_mut2(&2), Some((1, &mut 2, &mut 20)));",
                "    index_map.retain2(|_key, _value| true);",
                "    assert_eq!(index_map.len(), 2);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    ",
                "    index_map.retain2(|_key, _value| true);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(index_map.len(), 2);",
                "    assert!(index_map.get_full_mut2(&1).is_some());",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    index_map.retain2(|key, value| *key > 1);",
                "    assert_eq!(index_map.len(), 1);",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    assert!(index_map.get_full_mut2(&1).is_none());",
                "    index_map.retain2(|_, value| *value > 15);",
                "    assert_eq!(index_map.len(), 1);",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    index_map.retain2(|_, _| false);",
                "    assert_eq!(index_map.len(), 0);"
              ],
              "code": [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "",
                "    let mut index_map: super::IndexMap<i32, i32, RandomState> = super::IndexMap::new();",
                "    index_map.insert(1, 10);",
                "    index_map.insert(2, 20);",
                "    ",
                "    index_map.retain2(|_key, _value| true);",
                "    assert_eq!(index_map.len(), 2);",
                "    assert!(index_map.get_full_mut2(&1).is_some());",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    index_map.retain2(|key, value| *key > 1);",
                "    assert_eq!(index_map.len(), 1);",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    assert!(index_map.get_full_mut2(&1).is_none());",
                "    index_map.retain2(|_, value| *value > 15);",
                "    assert_eq!(index_map.len(), 1);",
                "    assert!(index_map.get_full_mut2(&2).is_some());",
                "    index_map.retain2(|_, _| false);",
                "    assert_eq!(index_map.len(), 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}