{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map.rs\n// crate name is indexmap\npub use self::core::raw_entry_v1::{self, RawEntryApiV1};\npub use self::core::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\npub use self::iter::{\n    Drain, IntoIter, IntoKeys, IntoValues, Iter, IterMut, IterMut2, Keys, Splice, Values,\n    ValuesMut,\n};\npub use self::mutable::MutableEntryKey;\npub use self::mutable::MutableKeys;\npub use self::slice::Slice;\n#[cfg(feature = \"rayon\")]\npub use crate::rayon::map as rayon;\nuse ::core::cmp::Ordering;\nuse ::core::fmt;\nuse ::core::hash::{BuildHasher, Hash, Hasher};\nuse ::core::mem;\nuse ::core::ops::{Index, IndexMut, RangeBounds};\nuse alloc::boxed::Box;\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\nuse std::collections::hash_map::RandomState;\nuse self::core::IndexMapCore;\nuse crate::util::{third, try_simplify_range};\nuse crate::{Bucket, Entries, Equivalent, HashValue, TryReserveError};\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\npub trait RawEntryApiV1<K, V, S>: private::Sealed {\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;\n}\npub trait MutableKeys: private::Sealed {\n    type Key;\n    type Value;\n    fn get_full_mut2<Q>(\n        &mut self,\n        key: &Q,\n    ) -> Option<(usize, &mut Self::Key, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Key>;\n    fn get_index_mut2(\n        &mut self,\n        index: usize,\n    ) -> Option<(&mut Self::Key, &mut Self::Value)>;\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Key, &mut Self::Value) -> bool;\n}\n#[cfg(not(feature = \"std\"))]\npub struct IndexMap<K, V, S> {\n    pub(crate) core: IndexMapCore<K, V>,\n    hash_builder: S,\n}\npub struct Drain<'a, K, V> {\n    iter: vec::Drain<'a, Bucket<K, V>>,\n}\n#[derive(Debug)]\npub(crate) struct IndexMapCore<K, V> {\n    /// indices mapping from the entry hash to its index.\n    indices: Indices,\n    /// entries is a dense vec maintaining entry order.\n    entries: Entries<K, V>,\n}\nimpl<K, V, S> IndexMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {}\n    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {}\n    pub fn insert_sorted(&mut self, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Ord,\n    {}\n    #[track_caller]\n    pub fn insert_before(\n        &mut self,\n        mut index: usize,\n        key: K,\n        value: V,\n    ) -> (usize, Option<V>) {}\n    #[track_caller]\n    pub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V> {}\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {}\n    #[track_caller]\n    pub fn splice<R, I>(\n        &mut self,\n        range: R,\n        replace_with: I,\n    ) -> Splice<'_, I::IntoIter, K, V, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = (K, V)>,\n    {}\n    pub fn append<S2>(&mut self, other: &mut IndexMap<K, V, S2>) {\n        self.extend(other.drain(..));\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Moves all key-value pairs from `other` into `self`, leaving `other` empty.\n///\n/// This is equivalent to calling [`insert`][Self::insert] for each\n/// key-value pair from `other` in order, which means that for keys that\n/// already exist in `self`, their value is updated in the current position.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n///\n/// // Note: Key (3) is present in both maps.\n/// let mut a = IndexMap::from([(3, \"c\"), (2, \"b\"), (1, \"a\")]);\n/// let mut b = IndexMap::from([(3, \"d\"), (4, \"e\"), (5, \"f\")]);\n/// let old_capacity = b.capacity();\n///\n/// a.append(&mut b);\n///\n/// assert_eq!(a.len(), 5);\n/// assert_eq!(b.len(), 0);\n/// assert_eq!(b.capacity(), old_capacity);\n///\n/// assert!(a.keys().eq(&[3, 2, 1, 4, 5]));\n/// assert_eq!(a[&3], \"d\"); // \"c\" was overwritten.\n/// ```\n682 pub fn append<S2>(&mut self, other: &mut IndexMap<K, V, S2>) {\n683     self.extend(other.drain(..));\n684 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}