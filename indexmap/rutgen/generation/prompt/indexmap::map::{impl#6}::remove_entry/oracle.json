{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map.rs\n// crate name is indexmap\npub use self::core::raw_entry_v1::{self, RawEntryApiV1};\npub use self::core::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\npub use self::iter::{\n    Drain, IntoIter, IntoKeys, IntoValues, Iter, IterMut, IterMut2, Keys, Splice, Values,\n    ValuesMut,\n};\npub use self::mutable::MutableEntryKey;\npub use self::mutable::MutableKeys;\npub use self::slice::Slice;\n#[cfg(feature = \"rayon\")]\npub use crate::rayon::map as rayon;\nuse ::core::cmp::Ordering;\nuse ::core::fmt;\nuse ::core::hash::{BuildHasher, Hash, Hasher};\nuse ::core::mem;\nuse ::core::ops::{Index, IndexMut, RangeBounds};\nuse alloc::boxed::Box;\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\nuse std::collections::hash_map::RandomState;\nuse self::core::IndexMapCore;\nuse crate::util::{third, try_simplify_range};\nuse crate::{Bucket, Entries, Equivalent, HashValue, TryReserveError};\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\npub trait RawEntryApiV1<K, V, S>: private::Sealed {\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;\n}\npub trait MutableKeys: private::Sealed {\n    type Key;\n    type Value;\n    fn get_full_mut2<Q>(\n        &mut self,\n        key: &Q,\n    ) -> Option<(usize, &mut Self::Key, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Key>;\n    fn get_index_mut2(\n        &mut self,\n        index: usize,\n    ) -> Option<(&mut Self::Key, &mut Self::Value)>;\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Key, &mut Self::Value) -> bool;\n}\n#[cfg(not(feature = \"std\"))]\npub struct IndexMap<K, V, S> {\n    pub(crate) core: IndexMapCore<K, V>,\n    hash_builder: S,\n}\n#[derive(Debug)]\npub(crate) struct IndexMapCore<K, V> {\n    /// indices mapping from the entry hash to its index.\n    indices: Indices,\n    /// entries is a dense vec maintaining entry order.\n    entries: Entries<K, V>,\n}\nimpl<K, V, S> IndexMap<K, V, S>\nwhere\n    S: BuildHasher,\n{\n    pub(crate) fn hash<Q: ?Sized + Hash>(&self, key: &Q) -> HashValue {}\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get<Q>(&self, key: &Q) -> Option<&V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_full<Q>(&self, key: &Q) -> Option<(usize, &K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_index_of<Q>(&self, key: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_full_mut<Q>(&mut self, key: &Q) -> Option<(usize, &K, &mut V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    #[deprecated(\n        note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\"\n    )]\n    pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    #[deprecated(\n        note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\"\n    )]\n    pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        self.swap_remove_entry(key)\n    }\n    pub fn swap_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn swap_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn swap_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn shift_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn shift_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn shift_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Remove and return the key-value pair equivalent to `key`.\n///\n/// **NOTE:** This is equivalent to [`.swap_remove_entry(key)`][Self::swap_remove_entry],\n/// replacing this entry's position with the last element, and it is deprecated in favor of\n/// calling that explicitly. If you need to preserve the relative order of the keys in the map,\n/// use [`.shift_remove_entry(key)`][Self::shift_remove_entry] instead.\n817 pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n818 where\n819     Q: ?Sized + Hash + Equivalent<K>,\n820 {\n821     self.swap_remove_entry(key)\n822 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}