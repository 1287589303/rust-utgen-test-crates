{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map/core.rs\n// crate name is indexmap\ntype Indices = hash_table::HashTable<usize>;\ntype Entries<K, V> = Vec<Bucket<K, V>>;\nuse hashbrown::hash_table;\nuse crate::vec::{self, Vec};\nuse crate::TryReserveError;\nuse core::mem;\nuse core::ops::RangeBounds;\nuse crate::util::simplify_range;\nuse crate::{Bucket, Equivalent, HashValue};\npub use entry::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\nstruct RefMut<'a, K, V> {\n    indices: &'a mut Indices,\n    entries: &'a mut Entries<K, V>,\n}\n#[derive(Clone, Copy, Debug, PartialEq)]\nstruct HashValue(usize);\n#[derive(Copy, Debug)]\nstruct Bucket<K, V> {\n    hash: HashValue,\n    key: K,\n    value: V,\n}\nimpl<'a, K, V> RefMut<'a, K, V> {\n    #[inline]\n    fn new(indices: &'a mut Indices, entries: &'a mut Entries<K, V>) -> Self {\n        Self { indices, entries }\n    }\n    #[inline]\n    fn reserve_entries(&mut self, additional: usize) {\n        reserve_entries(self.entries, additional, self.indices.capacity());\n    }\n    fn insert_unique(\n        self,\n        hash: HashValue,\n        key: K,\n        value: V,\n    ) -> OccupiedEntry<'a, K, V> {}\n    fn shift_insert_unique(&mut self, index: usize, hash: HashValue, key: K, value: V) {\n        let end = self.indices.len();\n        assert!(index <= end);\n        self.increment_indices(index, end);\n        let entries = &*self.entries;\n        self.indices\n            .insert_unique(\n                hash.get(),\n                index,\n                move |&i| {\n                    debug_assert_ne!(i, index);\n                    let i = if i < index { i } else { i - 1 };\n                    entries[i].hash.get()\n                },\n            );\n        if self.entries.len() == self.entries.capacity() {\n            self.reserve_entries(1);\n        }\n        self.entries.insert(index, Bucket { hash, key, value });\n    }\n    fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {}\n    fn shift_remove_finish(&mut self, index: usize) -> (K, V) {}\n    fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)> {}\n    fn swap_remove_finish(&mut self, index: usize) -> (K, V) {}\n    fn decrement_indices(&mut self, start: usize, end: usize) {}\n    fn increment_indices(&mut self, start: usize, end: usize) {\n        let shifted_entries = &self.entries[start..end];\n        if shifted_entries.len() > self.indices.capacity() / 2 {\n            for i in &mut *self.indices {\n                if start <= *i && *i < end {\n                    *i += 1;\n                }\n            }\n        } else {\n            for (i, entry) in (start..end).zip(shifted_entries).rev() {\n                update_index(self.indices, entry.hash, i, i + 1);\n            }\n        }\n    }\n    #[track_caller]\n    fn move_index(&mut self, from: usize, to: usize) {}\n    #[track_caller]\n    fn swap_indices(&mut self, a: usize, b: usize) {}\n}\nimpl HashValue {\n    #[inline(always)]\n    fn get(self) -> u64 {\n        self.0 as u64\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Insert a key-value pair in `entries` at a particular index,\n/// *without* checking whether it already exists.\n569 fn shift_insert_unique(&mut self, index: usize, hash: HashValue, key: K, value: V) {\n570     let end = self.indices.len();\n571     assert!(index <= end);\n572     // Increment others first so we don't have duplicate indices.\n573     self.increment_indices(index, end);\n574     let entries = &*self.entries;\n575     self.indices.insert_unique(hash.get(), index, move |&i| {\n576         // Adjust for the incremented indices to find hashes.\n577         debug_assert_ne!(i, index);\n578         let i = if i < index { i } else { i - 1 };\n579         entries[i].hash.get()\n580     });\n581     if self.entries.len() == self.entries.capacity() {\n582         // Reserve our own capacity synced to the indices,\n583         // rather than letting `Vec::insert` just double it.\n584         self.reserve_entries(1);\n585     }\n586     self.entries.insert(index, Bucket { hash, key, value });\n587 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}