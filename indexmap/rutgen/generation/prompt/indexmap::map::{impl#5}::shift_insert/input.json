{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map.rs\n// crate name is indexmap\npub use self::core::raw_entry_v1::{self, RawEntryApiV1};\npub use self::core::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\npub use self::iter::{\n    Drain, IntoIter, IntoKeys, IntoValues, Iter, IterMut, IterMut2, Keys, Splice, Values,\n    ValuesMut,\n};\npub use self::mutable::MutableEntryKey;\npub use self::mutable::MutableKeys;\npub use self::slice::Slice;\n#[cfg(feature = \"rayon\")]\npub use crate::rayon::map as rayon;\nuse ::core::cmp::Ordering;\nuse ::core::fmt;\nuse ::core::hash::{BuildHasher, Hash, Hasher};\nuse ::core::mem;\nuse ::core::ops::{Index, IndexMut, RangeBounds};\nuse alloc::boxed::Box;\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\nuse std::collections::hash_map::RandomState;\nuse self::core::IndexMapCore;\nuse crate::util::{third, try_simplify_range};\nuse crate::{Bucket, Entries, Equivalent, HashValue, TryReserveError};\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\npub trait RawEntryApiV1<K, V, S>: private::Sealed {\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;\n}\npub trait MutableKeys: private::Sealed {\n    type Key;\n    type Value;\n    fn get_full_mut2<Q>(\n        &mut self,\n        key: &Q,\n    ) -> Option<(usize, &mut Self::Key, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Key>;\n    fn get_index_mut2(\n        &mut self,\n        index: usize,\n    ) -> Option<(&mut Self::Key, &mut Self::Value)>;\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Key, &mut Self::Value) -> bool;\n}\n#[cfg(not(feature = \"std\"))]\npub struct IndexMap<K, V, S> {\n    pub(crate) core: IndexMapCore<K, V>,\n    hash_builder: S,\n}\npub struct VacantEntry<'a, K, V> {\n    map: RefMut<'a, K, V>,\n    hash: HashValue,\n    key: K,\n}\npub struct OccupiedEntry<'a, K, V> {\n    entries: &'a mut Entries<K, V>,\n    index: hash_table::OccupiedEntry<'a, usize>,\n}\n#[derive(Debug)]\npub(crate) struct IndexMapCore<K, V> {\n    /// indices mapping from the entry hash to its index.\n    indices: Indices,\n    /// entries is a dense vec maintaining entry order.\n    entries: Entries<K, V>,\n}\npub enum Entry<'a, K, V> {\n    /// Existing slot with equivalent key.\n    Occupied(OccupiedEntry<'a, K, V>),\n    /// Vacant slot (no equivalent key in the map).\n    Vacant(VacantEntry<'a, K, V>),\n}\nimpl<K, V, S> IndexMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {}\n    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {}\n    pub fn insert_sorted(&mut self, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Ord,\n    {}\n    #[track_caller]\n    pub fn insert_before(\n        &mut self,\n        mut index: usize,\n        key: K,\n        value: V,\n    ) -> (usize, Option<V>) {}\n    #[track_caller]\n    pub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V> {\n        let len = self.len();\n        match self.entry(key) {\n            Entry::Occupied(mut entry) => {\n                assert!(\n                    index < len,\n                    \"index out of bounds: the len is {len} but the index is {index}\"\n                );\n                let old = mem::replace(entry.get_mut(), value);\n                entry.move_index(index);\n                Some(old)\n            }\n            Entry::Vacant(entry) => {\n                assert!(\n                    index <= len,\n                    \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n                );\n                entry.shift_insert(index, value);\n                None\n            }\n        }\n    }\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n        let hash = self.hash(&key);\n        self.core.entry(hash, key)\n    }\n    #[track_caller]\n    pub fn splice<R, I>(\n        &mut self,\n        range: R,\n        replace_with: I,\n    ) -> Splice<'_, I::IntoIter, K, V, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = (K, V)>,\n    {}\n    pub fn append<S2>(&mut self, other: &mut IndexMap<K, V, S2>) {}\n}\nimpl<'a, K, V> VacantEntry<'a, K, V> {\n    pub fn index(&self) -> usize {}\n    pub fn key(&self) -> &K {}\n    pub(crate) fn key_mut(&mut self) -> &mut K {}\n    pub fn into_key(self) -> K {}\n    pub fn insert(self, value: V) -> &'a mut V {}\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {}\n    pub fn insert_sorted(self, value: V) -> (usize, &'a mut V)\n    where\n        K: Ord,\n    {}\n    pub fn shift_insert(mut self, index: usize, value: V) -> &'a mut V {\n        self.map.shift_insert_unique(index, self.hash, self.key, value);\n        &mut self.map.entries[index].value\n    }\n}\nimpl<'a, K, V> OccupiedEntry<'a, K, V> {\n    pub(crate) fn new(\n        entries: &'a mut Entries<K, V>,\n        index: hash_table::OccupiedEntry<'a, usize>,\n    ) -> Self {\n        Self { entries, index }\n    }\n    #[inline]\n    pub fn index(&self) -> usize {}\n    #[inline]\n    fn into_ref_mut(self) -> RefMut<'a, K, V> {}\n    pub fn key(&self) -> &K {}\n    pub(crate) fn key_mut(&mut self) -> &mut K {}\n    pub fn get(&self) -> &V {}\n    pub fn get_mut(&mut self) -> &mut V {\n        let index = self.index();\n        &mut self.entries[index].value\n    }\n    pub fn into_mut(self) -> &'a mut V {}\n    pub(super) fn into_muts(self) -> (&'a mut K, &'a mut V) {}\n    pub fn insert(&mut self, value: V) -> V {}\n    #[deprecated(\n        note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\"\n    )]\n    pub fn remove(self) -> V {}\n    pub fn swap_remove(self) -> V {}\n    pub fn shift_remove(self) -> V {}\n    #[deprecated(\n        note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\"\n    )]\n    pub fn remove_entry(self) -> (K, V) {}\n    pub fn swap_remove_entry(self) -> (K, V) {}\n    pub fn shift_remove_entry(self) -> (K, V) {}\n    #[track_caller]\n    pub fn move_index(self, to: usize) {\n        let index = self.index();\n        self.into_ref_mut().move_index(index, to);\n    }\n    pub fn swap_indices(self, other: usize) {}\n}\nimpl<K, V, S> IndexMap<K, V, S> {\n    #[inline]\n    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {\n        if n == 0 {\n            Self::with_hasher(hash_builder)\n        } else {\n            IndexMap {\n                core: IndexMapCore::with_capacity(n),\n                hash_builder,\n            }\n        }\n    }\n    pub const fn with_hasher(hash_builder: S) -> Self {\n        IndexMap {\n            core: IndexMapCore::new(),\n            hash_builder,\n        }\n    }\n    pub fn capacity(&self) -> usize {}\n    pub fn hasher(&self) -> &S {}\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.core.len()\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    pub fn iter(&self) -> Iter<'_, K, V> {}\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {}\n    pub fn keys(&self) -> Keys<'_, K, V> {}\n    pub fn into_keys(self) -> IntoKeys<K, V> {}\n    pub fn values(&self) -> Values<'_, K, V> {}\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {}\n    pub fn into_values(self) -> IntoValues<K, V> {}\n    pub fn clear(&mut self) {}\n    pub fn truncate(&mut self, len: usize) {}\n    #[track_caller]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, K, V>\n    where\n        R: RangeBounds<usize>,\n    {}\n    #[track_caller]\n    pub fn split_off(&mut self, at: usize) -> Self\n    where\n        S: Clone,\n    {\n        Self {\n            core: self.core.split_off(at),\n            hash_builder: self.hash_builder.clone(),\n        }\n    }\n    pub fn reserve(&mut self, additional: usize) {}\n    pub fn reserve_exact(&mut self, additional: usize) {}\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {}\n    pub fn try_reserve_exact(\n        &mut self,\n        additional: usize,\n    ) -> Result<(), TryReserveError> {}\n    pub fn shrink_to_fit(&mut self) {}\n    pub fn shrink_to(&mut self, min_capacity: usize) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Insert a key-value pair in the map at the given index.\n///\n/// If an equivalent key already exists in the map: the key remains and\n/// is moved to the given index in the map, its corresponding value is updated\n/// with `value`, and the older value is returned inside `Some(_)`.\n/// Note that existing entries **cannot** be moved to `index == map.len()`!\n/// (See [`insert_before`](Self::insert_before) for different behavior here.)\n///\n/// If no equivalent key existed in the map: the new key-value pair is\n/// inserted at the given index, and `None` is returned.\n///\n/// ***Panics*** if `index` is out of bounds.\n/// Valid indices are `0..map.len()` (exclusive) when moving an existing entry, or\n/// `0..=map.len()` (inclusive) when inserting a new key.\n///\n/// Computes in **O(n)** time (average).\n///\n/// See also [`entry`][Self::entry] if you want to insert *or* modify,\n/// perhaps only using the index for new entries with [`VacantEntry::shift_insert`].\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n/// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n///\n/// // The new key '*' goes exactly at the given index.\n/// assert_eq!(map.get_index_of(&'*'), None);\n/// assert_eq!(map.shift_insert(10, '*', ()), None);\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Moving the key 'a' up to 10 will shift others down, including the '*' that was at 10.\n/// assert_eq!(map.shift_insert(10, 'a', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'a'), Some(10));\n/// assert_eq!(map.get_index_of(&'*'), Some(9));\n///\n/// // Moving the key 'z' down to 9 will shift others up, including the '*' that was at 9.\n/// assert_eq!(map.shift_insert(9, 'z', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'z'), Some(9));\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Existing keys can move to len-1 at most, but new keys can insert at the endpoint.\n/// assert_eq!(map.len(), 27);\n/// assert_eq!(map.shift_insert(map.len() - 1, '*', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'*'), Some(26));\n/// assert_eq!(map.shift_insert(map.len(), '+', ()), None);\n/// assert_eq!(map.get_index_of(&'+'), Some(27));\n/// assert_eq!(map.len(), 28);\n/// ```\n///\n/// ```should_panic\n/// use indexmap::IndexMap;\n/// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n///\n/// // This is an invalid index for moving an existing key!\n/// map.shift_insert(map.len(), 'a', ());\n/// ```\n584 pub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V> {\n585     let len = self.len();\n586     match self.entry(key) {\n587         Entry::Occupied(mut entry) => {\n588             assert!(\n589                 index < len,\n590                 \"index out of bounds: the len is {len} but the index is {index}\"\n591             );\n592 \n593             let old = mem::replace(entry.get_mut(), value);\n594             entry.move_index(index);\n595             Some(old)\n596         }\n597         Entry::Vacant(entry) => {\n598             assert!(\n599                 index <= len,\n600                 \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n601             );\n602 \n603             entry.shift_insert(index, value);\n604             None\n605         }\n606     }\n607 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}