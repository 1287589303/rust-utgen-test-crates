{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map.rs\n// crate name is indexmap\npub use self::core::raw_entry_v1::{self, RawEntryApiV1};\npub use self::core::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\npub use self::iter::{\n    Drain, IntoIter, IntoKeys, IntoValues, Iter, IterMut, IterMut2, Keys, Splice, Values,\n    ValuesMut,\n};\npub use self::mutable::MutableEntryKey;\npub use self::mutable::MutableKeys;\npub use self::slice::Slice;\n#[cfg(feature = \"rayon\")]\npub use crate::rayon::map as rayon;\nuse ::core::cmp::Ordering;\nuse ::core::fmt;\nuse ::core::hash::{BuildHasher, Hash, Hasher};\nuse ::core::mem;\nuse ::core::ops::{Index, IndexMut, RangeBounds};\nuse alloc::boxed::Box;\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\nuse std::collections::hash_map::RandomState;\nuse self::core::IndexMapCore;\nuse crate::util::{third, try_simplify_range};\nuse crate::{Bucket, Entries, Equivalent, HashValue, TryReserveError};\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\npub trait RawEntryApiV1<K, V, S>: private::Sealed {\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;\n}\npub trait MutableKeys: private::Sealed {\n    type Key;\n    type Value;\n    fn get_full_mut2<Q>(\n        &mut self,\n        key: &Q,\n    ) -> Option<(usize, &mut Self::Key, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Key>;\n    fn get_index_mut2(\n        &mut self,\n        index: usize,\n    ) -> Option<(&mut Self::Key, &mut Self::Value)>;\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Key, &mut Self::Value) -> bool;\n}\n#[cfg(not(feature = \"std\"))]\npub struct IndexMap<K, V, S> {\n    pub(crate) core: IndexMapCore<K, V>,\n    hash_builder: S,\n}\n#[derive(Copy, Debug)]\nstruct Bucket<K, V> {\n    hash: HashValue,\n    key: K,\n    value: V,\n}\n#[derive(Debug)]\npub(crate) struct IndexMapCore<K, V> {\n    /// indices mapping from the entry hash to its index.\n    indices: Indices,\n    /// entries is a dense vec maintaining entry order.\n    entries: Entries<K, V>,\n}\nimpl<K, V, S> IndexMap<K, V, S>\nwhere\n    S: BuildHasher,\n{\n    pub(crate) fn hash<Q: ?Sized + Hash>(&self, key: &Q) -> HashValue {}\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get<Q>(&self, key: &Q) -> Option<&V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_full<Q>(&self, key: &Q) -> Option<(usize, &K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &self.as_entries()[i];\n            Some((i, &entry.key, &entry.value))\n        } else {\n            None\n        }\n    }\n    pub fn get_index_of<Q>(&self, key: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn get_full_mut<Q>(&mut self, key: &Q) -> Option<(usize, &K, &mut V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    #[deprecated(\n        note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\"\n    )]\n    pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    #[deprecated(\n        note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\"\n    )]\n    pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn swap_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn swap_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn swap_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn shift_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn shift_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n    pub fn shift_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Return item index, key and value\n740 pub fn get_full<Q>(&self, key: &Q) -> Option<(usize, &K, &V)>\n741 where\n742     Q: ?Sized + Hash + Equivalent<K>,\n743 {\n744     if let Some(i) = self.get_index_of(key) {\n745         let entry = &self.as_entries()[i];\n746         Some((i, &entry.key, &entry.value))\n747     } else {\n748         None\n749     }\n750 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}