{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map.rs\n// crate name is indexmap\npub use self::core::raw_entry_v1::{self, RawEntryApiV1};\npub use self::core::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\npub use self::iter::{\n    Drain, IntoIter, IntoKeys, IntoValues, Iter, IterMut, IterMut2, Keys, Splice, Values,\n    ValuesMut,\n};\npub use self::mutable::MutableEntryKey;\npub use self::mutable::MutableKeys;\npub use self::slice::Slice;\n#[cfg(feature = \"rayon\")]\npub use crate::rayon::map as rayon;\nuse ::core::cmp::Ordering;\nuse ::core::fmt;\nuse ::core::hash::{BuildHasher, Hash, Hasher};\nuse ::core::mem;\nuse ::core::ops::{Index, IndexMut, RangeBounds};\nuse alloc::boxed::Box;\nuse alloc::vec::Vec;\n#[cfg(feature = \"std\")]\nuse std::collections::hash_map::RandomState;\nuse self::core::IndexMapCore;\nuse crate::util::{third, try_simplify_range};\nuse crate::{Bucket, Entries, Equivalent, HashValue, TryReserveError};\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\npub trait RawEntryApiV1<K, V, S>: private::Sealed {\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;\n}\npub trait MutableKeys: private::Sealed {\n    type Key;\n    type Value;\n    fn get_full_mut2<Q>(\n        &mut self,\n        key: &Q,\n    ) -> Option<(usize, &mut Self::Key, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Key>;\n    fn get_index_mut2(\n        &mut self,\n        index: usize,\n    ) -> Option<(&mut Self::Key, &mut Self::Value)>;\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Key, &mut Self::Value) -> bool;\n}\n#[cfg(not(feature = \"std\"))]\npub struct IndexMap<K, V, S> {\n    pub(crate) core: IndexMapCore<K, V>,\n    hash_builder: S,\n}\n#[derive(Debug)]\npub(crate) struct IndexMapCore<K, V> {\n    /// indices mapping from the entry hash to its index.\n    indices: Indices,\n    /// entries is a dense vec maintaining entry order.\n    entries: Entries<K, V>,\n}\nimpl<K, V, S> IndexMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {}\n    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {}\n    pub fn insert_sorted(&mut self, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Ord,\n    {}\n    #[track_caller]\n    pub fn insert_before(\n        &mut self,\n        mut index: usize,\n        key: K,\n        value: V,\n    ) -> (usize, Option<V>) {}\n    #[track_caller]\n    pub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V> {}\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {}\n    #[track_caller]\n    pub fn splice<R, I>(\n        &mut self,\n        range: R,\n        replace_with: I,\n    ) -> Splice<'_, I::IntoIter, K, V, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = (K, V)>,\n    {\n        Splice::new(self, range, replace_with.into_iter())\n    }\n    pub fn append<S2>(&mut self, other: &mut IndexMap<K, V, S2>) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Creates a splicing iterator that replaces the specified range in the map\n/// with the given `replace_with` key-value iterator and yields the removed\n/// items. `replace_with` does not need to be the same length as `range`.\n///\n/// The `range` is removed even if the iterator is not consumed until the\n/// end. It is unspecified how many elements are removed from the map if the\n/// `Splice` value is leaked.\n///\n/// The input iterator `replace_with` is only consumed when the `Splice`\n/// value is dropped. If a key from the iterator matches an existing entry\n/// in the map (outside of `range`), then the value will be updated in that\n/// position. Otherwise, the new key-value pair will be inserted in the\n/// replaced `range`.\n///\n/// ***Panics*** if the starting point is greater than the end point or if\n/// the end point is greater than the length of the map.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n///\n/// let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);\n/// let new = [(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];\n/// let removed: Vec<_> = map.splice(2..4, new).collect();\n///\n/// // 1 and 4 got new values, while 5, 3, and 2 were newly inserted.\n/// assert!(map.into_iter().eq([(0, '_'), (1, 'A'), (5, 'E'), (3, 'C'), (2, 'B'), (4, 'D')]));\n/// assert_eq!(removed, &[(2, 'b'), (3, 'c')]);\n/// ```\n649 pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, K, V, S>\n650 where\n651     R: RangeBounds<usize>,\n652     I: IntoIterator<Item = (K, V)>,\n653 {\n654     Splice::new(self, range, replace_with.into_iter())\n655 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}