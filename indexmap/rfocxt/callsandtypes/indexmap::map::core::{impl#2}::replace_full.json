{"mod_name":"map::core","calls":["map::core::equivalent::<K, V, K>","<alloc::vec::Vec<Bucket<K, V>> as core::ops::Deref>::deref","alloc::vec::Vec::<Bucket<K, V>>::len","hashbrown::HashTable::<usize>::entry::<impl for<'a> Fn","map::core::get_hash::<K, V>","HashValue::get","hashbrown::hash_table::OccupiedEntry::<'_, usize>::get","<alloc::vec::Vec<Bucket<K, V>> as core::ops::IndexMut<usize>>::index_mut","core::mem::replace::<K>","core::mem::replace::<V>","hashbrown::HashTable::<usize>::len","core::panicking::assert_failed::<usize, usize>","map::core::IndexMapCore::<K, V>::push_entry","hashbrown::hash_table::VacantEntry::<'_, usize>::insert"],"types":["u64","Bucket<K, V>","alloc::alloc::Global","bool","core::option::Option<core::fmt::Arguments<'_>>","(usize, core::option::Option<(K, V)>)","alloc::vec::Vec<Bucket<K, V>>","HashValue","usize","impl for<'a> Fn(&'a usize) -> u64 + '_","(K, V)","isize","(&usize, &usize)","!","hashbrown::hash_table::Entry<'_, usize>","impl for<'a> Fn(&'a usize) -> bool + '_","core::fmt::Arguments<'_>","core::panicking::AssertKind","K","()","V","hashbrown::hash_table::OccupiedEntry<'_, usize>","core::option::Option<(K, V)>","hashbrown::HashTable<usize>","hashbrown::hash_table::VacantEntry<'_, usize>","hashbrown::raw::alloc::inner::Global","[Bucket<K, V>]","map::core::IndexMapCore<K, V>"]}