{
  "name": "regex_automata::meta::regex::{impl#20}::dfa_size_limit",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:2875:5:2877:6",
  "doc": "/// Sets the size limit, in bytes, for heap memory used for a fully\n/// compiled DFA.\n///\n/// **NOTE:** If you increase this, you'll likely also need to increase\n/// [`Config::dfa_state_limit`].\n///\n/// In contrast to the lazy DFA, building a full DFA requires computing\n/// all of its state transitions up front. This can be a very expensive\n/// process, and runs in worst case `2^n` time and space (where `n` is\n/// proportional to the size of the regex). However, a full DFA unlocks\n/// some additional optimization opportunities.\n///\n/// Because full DFAs can be so expensive, the default limits for them are\n/// incredibly small. Generally speaking, if your regex is moderately big\n/// or if you're using Unicode features (`\\w` is Unicode-aware by default\n/// for example), then you can expect that the meta regex engine won't even\n/// attempt to build a DFA for it.\n///\n/// If this and [`Config::dfa_state_limit`] are set to `None`, then the\n/// meta regex will not use any sort of limits when deciding whether to\n/// build a DFA. This in turn makes construction of a `Regex` take\n/// worst case exponential time and space. Even short patterns can result\n/// in huge space blow ups. So it is strongly recommended to keep some kind\n/// of limit set!\n///\n/// The default is set to a small number that permits some simple regexes\n/// to get compiled into DFAs in reasonable time.\n///\n/// # Example\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::meta::Regex;\n///\n/// let result = Regex::builder()\n///     // 100MB is much bigger than the default.\n///     .configure(Regex::config()\n///         .dfa_size_limit(Some(100 * (1<<20)))\n///         // We don't care about size too much here, so just\n///         // remove the NFA state limit altogether.\n///         .dfa_state_limit(None))\n///     .build(r\"\\pL{5}\");\n/// assert!(result.is_ok());\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn dfa_size_limit(self, limit: Option<usize>) -> Config {",
    "    Config { dfa_size_limit: Some(limit), ..self }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "Config { dfa_size_limit: Some(limit), ..self }",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}