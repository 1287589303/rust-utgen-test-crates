{
  "name": "regex_automata::hybrid::dfa::{impl#8}::skip_cache_capacity_check",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:3561:5:3564:6",
  "doc": "/// Configures construction of a lazy DFA to use the minimum cache capacity\n/// if the configured capacity is otherwise too small for the provided NFA.\n///\n/// This is useful if you never want lazy DFA construction to fail because\n/// of a capacity that is too small.\n///\n/// In general, this option is typically not a good idea. In particular,\n/// while a minimum cache capacity does permit the lazy DFA to function\n/// where it otherwise couldn't, it's plausible that it may not function\n/// well if it's constantly running out of room. In that case, the speed\n/// advantages of the lazy DFA may be negated. On the other hand, the\n/// \"minimum\" cache capacity computed may not be completely accurate and\n/// could actually be bigger than what is really necessary. Therefore, it\n/// is plausible that using the minimum cache capacity could still result\n/// in very good performance.\n///\n/// This is disabled by default.\n///\n/// # Example\n///\n/// This example shows what happens if the configured cache capacity is\n/// too small. In such cases, one could override the capacity explicitly.\n/// An alternative, demonstrated here, let's us force construction to use\n/// the minimum cache capacity if the configured capacity is otherwise\n/// too small.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{hybrid::dfa::DFA, HalfMatch, Input};\n///\n/// let pattern = r\"\\p{L}{1000}\";\n///\n/// // The default cache capacity is likely too small to deal with regexes\n/// // that are very large. Large repetitions of large Unicode character\n/// // classes are a common way to make very large regexes.\n/// let _ = DFA::new(pattern).unwrap_err();\n/// // Configure construction such it automatically selects the minimum\n/// // cache capacity if it would otherwise be too small.\n/// let dfa = DFA::builder()\n///     .configure(DFA::config().skip_cache_capacity_check(true))\n///     .build(pattern)?;\n/// let mut cache = dfa.create_cache();\n///\n/// let haystack = \"ͰͲͶͿΆΈΉΊΌΎΏΑΒΓΔΕΖΗΘΙ\".repeat(50);\n/// let expected = Some(HalfMatch::must(0, 2000));\n/// let got = dfa.try_search_fwd(&mut cache, &Input::new(&haystack))?;\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn skip_cache_capacity_check(mut self, yes: bool) -> Config {",
    "    self.skip_cache_capacity_check = Some(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}