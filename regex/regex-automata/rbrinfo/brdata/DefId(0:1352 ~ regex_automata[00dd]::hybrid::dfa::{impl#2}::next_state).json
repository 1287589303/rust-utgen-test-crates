{
  "name": "regex_automata::hybrid::dfa::{impl#2}::next_state",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:1215:5:1229:6",
  "doc": "/// Transitions from the current state to the next state, given the next\n/// byte of input.\n///\n/// The given cache is used to either reuse pre-computed state\n/// transitions, or to store this newly computed transition for future\n/// reuse. Thus, this routine guarantees that it will never return a state\n/// ID that has an \"unknown\" tag.\n///\n/// # State identifier validity\n///\n/// The only valid value for `current` is the lazy state ID returned\n/// by the most recent call to `next_state`, `next_state_untagged`,\n/// `next_state_untagged_unchecked`, `start_state_forward` or\n/// `state_state_reverse` for the given `cache`. Any state ID returned from\n/// prior calls to these routines (with the same `cache`) is considered\n/// invalid (even if it gives an appearance of working). State IDs returned\n/// from _any_ prior call for different `cache` values are also always\n/// invalid.\n///\n/// The returned ID is always a valid ID when `current` refers to a valid\n/// ID. Moreover, this routine is defined for all possible values of\n/// `input`.\n///\n/// These validity rules are not checked, even in debug mode. Callers are\n/// required to uphold these rules themselves.\n///\n/// Violating these state ID validity rules will not sacrifice memory\n/// safety, but _may_ produce an incorrect result or a panic.\n///\n/// # Panics\n///\n/// If the given ID does not refer to a valid state, then this routine\n/// may panic but it also may not panic and instead return an invalid or\n/// incorrect ID.\n///\n/// # Example\n///\n/// This shows a simplistic example for walking a lazy DFA for a given\n/// haystack by using the `next_state` method.\n///\n/// ```\n/// use regex_automata::{hybrid::dfa::DFA, Input};\n///\n/// let dfa = DFA::new(r\"[a-z]+r\")?;\n/// let mut cache = dfa.create_cache();\n/// let haystack = \"bar\".as_bytes();\n///\n/// // The start state is determined by inspecting the position and the\n/// // initial bytes of the haystack.\n/// let mut sid = dfa.start_state_forward(\n///     &mut cache, &Input::new(haystack),\n/// )?;\n/// // Walk all the bytes in the haystack.\n/// for &b in haystack {\n///     sid = dfa.next_state(&mut cache, sid, b)?;\n/// }\n/// // Matches are always delayed by 1 byte, so we must explicitly walk the\n/// // special \"EOI\" transition at the end of the search.\n/// sid = dfa.next_eoi_state(&mut cache, sid)?;\n/// assert!(sid.is_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn next_state(",
    "    &self,",
    "    cache: &mut Cache,",
    "    current: LazyStateID,",
    "    input: u8,",
    ") -> Result<LazyStateID, CacheError> {",
    "    let class = usize::from(self.classes.get(input));",
    "    let offset = current.as_usize_untagged() + class;",
    "    let sid = cache.trans[offset];",
    "    if !sid.is_unknown() {",
    "        return Ok(sid);",
    "    }",
    "    let unit = alphabet::Unit::u8(input);",
    "    Lazy::new(self, cache).cache_next_state(current, unit)",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "sid.is_unknown()",
          "norm": null,
          "value": "true",
          "line": 1224,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        9,
        10,
        11,
        12
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "sid.is_unknown()",
          "norm": null,
          "value": "false",
          "line": 1224,
          "bound": null
        }
      ],
      "ret": "Ok(sid)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        8,
        12
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}