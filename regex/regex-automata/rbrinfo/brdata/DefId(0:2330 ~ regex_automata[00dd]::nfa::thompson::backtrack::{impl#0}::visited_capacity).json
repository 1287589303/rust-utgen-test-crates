{
  "name": "regex_automata::nfa::thompson::backtrack::{impl#0}::visited_capacity",
  "mod_info": {
    "name": "nfa::thompson::backtrack",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:57:1:57:19"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/backtrack.rs:171:5:174:6",
  "doc": "/// Set the visited capacity used to bound backtracking.\n///\n/// The visited capacity represents the amount of heap memory (in bytes) to\n/// allocate toward tracking which parts of the backtracking search have\n/// been done before. The heap memory needed for any particular search is\n/// proportional to `haystack.len() * nfa.states().len()`, which an be\n/// quite large. Therefore, the bounded backtracker is typically only able\n/// to run on shorter haystacks.\n///\n/// For a given regex, increasing the visited capacity means that the\n/// maximum haystack length that can be searched is increased. The\n/// [`BoundedBacktracker::max_haystack_len`] method returns that maximum.\n///\n/// The default capacity is a reasonable but empirically chosen size.\n///\n/// # Example\n///\n/// As with other regex engines, Unicode is what tends to make the bounded\n/// backtracker less useful by making the maximum haystack length quite\n/// small. If necessary, increasing the visited capacity using this routine\n/// will increase the maximum haystack length at the cost of using more\n/// memory.\n///\n/// Note though that the specific maximum values here are not an API\n/// guarantee. The default visited capacity is subject to change and not\n/// covered by semver.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::nfa::thompson::backtrack::BoundedBacktracker;\n///\n/// // Unicode inflates the size of the underlying NFA quite a bit, and\n/// // thus means that the backtracker can only handle smaller haystacks,\n/// // assuming that the visited capacity remains unchanged.\n/// let re = BoundedBacktracker::new(r\"\\w+\")?;\n/// assert!(re.max_haystack_len() <= 7_000);\n/// // But we can increase the visited capacity to handle bigger haystacks!\n/// let re = BoundedBacktracker::builder()\n///     .configure(BoundedBacktracker::config().visited_capacity(1<<20))\n///     .build(r\"\\w+\")?;\n/// assert!(re.max_haystack_len() >= 25_000);\n/// assert!(re.max_haystack_len() <= 28_000);\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn visited_capacity(mut self, capacity: usize) -> Config {",
    "    self.visited_capacity = Some(capacity);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}