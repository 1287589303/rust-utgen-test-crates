{
  "name": "regex_automata::hybrid::dfa::minimum_cache_capacity",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": false,
  "loc": "regex-automata/src/hybrid/dfa.rs:4319:1:4376:2",
  "doc": "/// Based on the minimum number of states required for a useful lazy DFA cache,\n/// this returns a heuristic minimum number of bytes of heap space required.\n///\n/// This is a \"heuristic\" because the minimum it returns is likely bigger than\n/// the true minimum. Namely, it assumes that each powerset NFA/DFA state uses\n/// the maximum number of NFA states (all of them). This is likely bigger\n/// than what is required in practice. Computing the true minimum effectively\n/// requires determinization, which is probably too much work to do for a\n/// simple check like this.\n///\n/// One of the issues with this approach IMO is that it requires that this\n/// be in sync with the calculation above for computing how much heap memory\n/// the DFA cache uses. If we get it wrong, it's possible for example for the\n/// minimum to be smaller than the computed heap memory, and thus, it may be\n/// the case that we can't add the required minimum number of states. That in\n/// turn will make lazy DFA panic because we assume that we can add at least a\n/// minimum number of states.\n///\n/// Another approach would be to always allow the minimum number of states to\n/// be added to the lazy DFA cache, even if it exceeds the configured cache\n/// limit. This does mean that the limit isn't really a limit in all cases,\n/// which is unfortunate. But it does at least guarantee that the lazy DFA can\n/// always make progress, even if it is slow. (This approach is very similar to\n/// enabling the 'skip_cache_capacity_check' config knob, except it wouldn't\n/// rely on cache size calculation. Instead, it would just always permit a\n/// minimum number of states to be added.)\n",
  "code": [
    "fn minimum_cache_capacity(",
    "    nfa: &thompson::NFA,",
    "    classes: &ByteClasses,",
    "    starts_for_each_pattern: bool,",
    ") -> usize {",
    "    const ID_SIZE: usize = size_of::<LazyStateID>();",
    "    const STATE_SIZE: usize = size_of::<State>();",
    "",
    "    let stride = 1 << classes.stride2();",
    "    let states_len = nfa.states().len();",
    "    let sparses = 2 * states_len * NFAStateID::SIZE;",
    "    let trans = MIN_STATES * stride * ID_SIZE;",
    "",
    "    let mut starts = Start::len() * ID_SIZE;",
    "    if starts_for_each_pattern {",
    "        starts += (Start::len() * nfa.pattern_len()) * ID_SIZE;",
    "    }",
    "",
    "    // The min number of states HAS to be at least 4: we have 3 sentinel states",
    "    // and then we need space for one more when we save a state after clearing",
    "    // the cache. We also need space for one more, otherwise we get stuck in a",
    "    // loop where we try to add a 5th state, which gets rejected, which clears",
    "    // the cache, which adds back a saved state (4th total state) which then",
    "    // tries to add the 5th state again.",
    "    assert!(MIN_STATES >= 5, \"minimum number of states has to be at least 5\");",
    "    // The minimum number of non-sentinel states. We consider this separately",
    "    // because sentinel states are much smaller in that they contain no NFA",
    "    // states. Given our aggressive calculation here, it's worth being more",
    "    // precise with the number of states we need.",
    "    let non_sentinel = MIN_STATES.checked_sub(SENTINEL_STATES).unwrap();",
    "",
    "    // Every `State` has 5 bytes for flags, 4 bytes (max) for the number of",
    "    // patterns, followed by 32-bit encodings of patterns and then delta",
    "    // varint encodings of NFA state IDs. We use the worst case (which isn't",
    "    // technically possible) of 5 bytes for each NFA state ID.",
    "    //",
    "    // HOWEVER, three of the states needed by a lazy DFA are just the sentinel",
    "    // unknown, dead and quit states. Those states have a known size and it is",
    "    // small.",
    "    let dead_state_size = State::dead().memory_usage();",
    "    let max_state_size = 5 + 4 + (nfa.pattern_len() * 4) + (states_len * 5);",
    "    let states = (SENTINEL_STATES * (STATE_SIZE + dead_state_size))",
    "        + (non_sentinel * (STATE_SIZE + max_state_size));",
    "    // NOTE: We don't double count heap memory used by State for this map since",
    "    // we use reference counting to avoid doubling memory usage. (This tends to",
    "    // be where most memory is allocated in the cache.)",
    "    let states_to_sid = (MIN_STATES * STATE_SIZE) + (MIN_STATES * ID_SIZE);",
    "    let stack = states_len * NFAStateID::SIZE;",
    "    let scratch_state_builder = max_state_size;",
    "",
    "    trans",
    "        + starts",
    "        + states",
    "        + states_to_sid",
    "        + sparses",
    "        + stack",
    "        + scratch_state_builder",
    "}"
  ],
  "size": {
    "chain": 4,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "starts_for_each_pattern",
          "norm": null,
          "value": "true",
          "line": 4333,
          "bound": null
        },
        {
          "cond": "MIN_STATES >= 5",
          "norm": "5 <= MIN_STATES",
          "value": "true",
          "line": 4343,
          "bound": "MIN_STATES == 5"
        }
      ],
      "ret": "trans\n        + starts\n        + states\n        + states_to_sid\n        + sparses\n        + stack\n        + scratch_state_builder",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        18,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "starts_for_each_pattern",
          "norm": null,
          "value": "true",
          "line": 4333,
          "bound": null
        },
        {
          "cond": "MIN_STATES >= 5",
          "norm": "5 <= MIN_STATES",
          "value": "false",
          "line": 4343,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        18,
        19,
        20,
        49
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "starts_for_each_pattern",
          "norm": null,
          "value": "false",
          "line": 4333,
          "bound": null
        },
        {
          "cond": "MIN_STATES >= 5",
          "norm": "5 <= MIN_STATES",
          "value": "true",
          "line": 4343,
          "bound": "MIN_STATES == 5"
        }
      ],
      "ret": "trans\n        + starts\n        + states\n        + states_to_sid\n        + sparses\n        + stack\n        + scratch_state_builder",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        17,
        18,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "starts_for_each_pattern",
          "norm": null,
          "value": "false",
          "line": 4333,
          "bound": null
        },
        {
          "cond": "MIN_STATES >= 5",
          "norm": "5 <= MIN_STATES",
          "value": "false",
          "line": 4343,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        17,
        18,
        19,
        20,
        49
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}