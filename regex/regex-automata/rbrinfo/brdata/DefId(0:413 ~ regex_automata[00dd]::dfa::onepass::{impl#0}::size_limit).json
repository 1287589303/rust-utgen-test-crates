{
  "name": "regex_automata::dfa::onepass::{impl#0}::size_limit",
  "mod_info": {
    "name": "dfa::onepass",
    "loc": "regex-automata/src/dfa/mod.rs:339:1:339:17"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/onepass.rs:235:5:238:6",
  "doc": "/// Set a size limit on the total heap used by a one-pass DFA.\n///\n/// This size limit is expressed in bytes and is applied during\n/// construction of a one-pass DFA. If the DFA's heap usage exceeds\n/// this configured limit, then construction is stopped and an error is\n/// returned.\n///\n/// The default is no limit.\n///\n/// # Example\n///\n/// This example shows a one-pass DFA that fails to build because of\n/// a configured size limit. This particular example also serves as a\n/// cautionary tale demonstrating just how big DFAs with large Unicode\n/// character classes can get.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{dfa::onepass::DFA, Match};\n///\n/// // 6MB isn't enough!\n/// DFA::builder()\n///     .configure(DFA::config().size_limit(Some(6_000_000)))\n///     .build(r\"\\w{20}\")\n///     .unwrap_err();\n///\n/// // ... but 7MB probably is!\n/// // (Note that DFA sizes aren't necessarily stable between releases.)\n/// let re = DFA::builder()\n///     .configure(DFA::config().size_limit(Some(7_000_000)))\n///     .build(r\"\\w{20}\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let haystack = \"A\".repeat(20);\n/// re.captures(&mut cache, &haystack, &mut caps);\n/// assert_eq!(Some(Match::must(0, 0..20)), caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// While one needs a little more than 3MB to represent `\\w{20}`, it\n/// turns out that you only need a little more than 4KB to represent\n/// `(?-u:\\w{20})`. So only use Unicode if you need it!\n",
  "code": [
    "pub fn size_limit(mut self, limit: Option<usize>) -> Config {",
    "    self.size_limit = Some(limit);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}