{
  "name": "regex_automata::nfa::thompson::compiler::{impl#0}::which_captures",
  "mod_info": {
    "name": "nfa::thompson::compiler",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:60:1:60:14"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/compiler.rs:410:5:413:6",
  "doc": "/// Configures what kinds of capture groups are compiled into\n/// [`State::Capture`](crate::nfa::thompson::State::Capture) states in a\n/// Thompson NFA.\n///\n/// Currently, using any option except for [`WhichCaptures::None`] requires\n/// disabling the [`reverse`](Config::reverse) setting. If both are\n/// enabled, then the compiler will return an error. It is expected that\n/// this limitation will be lifted in the future.\n///\n/// This is set to [`WhichCaptures::All`] by default. Callers may wish to\n/// use [`WhichCaptures::Implicit`] in cases where one wants avoid the\n/// overhead of capture states for explicit groups. Usually this occurs\n/// when one wants to use the `PikeVM` only for determining the overall\n/// match. Otherwise, the `PikeVM` could use much more memory than is\n/// necessary.\n///\n/// # Example\n///\n/// This example demonstrates that some regex engines, like the Pike VM,\n/// require capturing states to be present in the NFA to report match\n/// offsets.\n///\n/// ```\n/// use regex_automata::nfa::thompson::{\n///     pikevm::PikeVM,\n///     NFA,\n///     WhichCaptures,\n/// };\n///\n/// let re = PikeVM::builder()\n///     .thompson(NFA::config().which_captures(WhichCaptures::None))\n///     .build(r\"[a-z]+\")?;\n/// let mut cache = re.create_cache();\n///\n/// assert!(re.is_match(&mut cache, \"abc\"));\n/// assert_eq!(None, re.find(&mut cache, \"abc\"));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// The same applies to the bounded backtracker:\n///\n/// ```\n/// use regex_automata::nfa::thompson::{\n///     backtrack::BoundedBacktracker,\n///     NFA,\n///     WhichCaptures,\n/// };\n///\n/// let re = BoundedBacktracker::builder()\n///     .thompson(NFA::config().which_captures(WhichCaptures::None))\n///     .build(r\"[a-z]+\")?;\n/// let mut cache = re.create_cache();\n///\n/// assert!(re.try_is_match(&mut cache, \"abc\")?);\n/// assert_eq!(None, re.try_find(&mut cache, \"abc\")?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {",
    "    self.which_captures = Some(which_captures);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}