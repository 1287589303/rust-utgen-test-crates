{
  "name": "regex_automata::dfa::onepass::{impl#5}::find_match",
  "mod_info": {
    "name": "dfa::onepass",
    "loc": "regex-automata/src/dfa/mod.rs:339:1:339:17"
  },
  "visible": false,
  "loc": "regex-automata/src/dfa/onepass.rs:2181:5:2225:6",
  "doc": "/// Assumes 'sid' is a match state and looks for whether a match can\n/// be reported. If so, appropriate offsets are written to 'slots' and\n/// 'matched_pid' is set to the matching pattern ID.\n///\n/// Even when 'sid' is a match state, it's possible that a match won't\n/// be reported. For example, when the conditional epsilon transitions\n/// leading to the match state aren't satisfied at the given position in\n/// the haystack.\n",
  "code": [
    "fn find_match(",
    "    &self,",
    "    cache: &mut Cache,",
    "    input: &Input<'_>,",
    "    at: usize,",
    "    sid: StateID,",
    "    slots: &mut [Option<NonMaxUsize>],",
    "    matched_pid: &mut Option<PatternID>,",
    ") -> bool {",
    "    debug_assert!(sid >= self.min_match_id);",
    "    let pateps = self.pattern_epsilons(sid);",
    "    let epsilons = pateps.epsilons();",
    "    if !epsilons.looks().is_empty()",
    "        && !self.nfa.look_matcher().matches_set_inline(",
    "            epsilons.looks(),",
    "            input.haystack(),",
    "            at,",
    "        )",
    "    {",
    "        return false;",
    "    }",
    "    let pid = pateps.pattern_id_unchecked();",
    "    // This calculation is always correct because we know our 'pid' is",
    "    // valid and thus we know that the slot indices for it are valid.",
    "    let slot_end = pid.as_usize().wrapping_mul(2).wrapping_add(1);",
    "    // Set the implicit 'end' slot for the matching pattern. (The 'start'",
    "    // slot was set at the beginning of the search.)",
    "    if slot_end < slots.len() {",
    "        slots[slot_end] = NonMaxUsize::new(at);",
    "    }",
    "    // If the caller provided enough room, copy the previously recorded",
    "    // explicit slots from our scratch space to the caller provided slots.",
    "    // We *also* need to set any explicit slots that are active as part of",
    "    // the path to the match state.",
    "    if self.explicit_slot_start < slots.len() {",
    "        // NOTE: The 'cache.explicit_slots()' slice is setup at the",
    "        // beginning of every search such that it is guaranteed to return a",
    "        // slice of length equivalent to 'slots[explicit_slot_start..]'.",
    "        slots[self.explicit_slot_start..]",
    "            .copy_from_slice(cache.explicit_slots());",
    "        epsilons.slots().apply(at, &mut slots[self.explicit_slot_start..]);",
    "    }",
    "    *matched_pid = Some(pid);",
    "    true",
    "}"
  ],
  "size": {
    "chain": 10,
    "contra": 0,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "true",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2208,
          "bound": null
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2215,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        11,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        39,
        40
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "true",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2208,
          "bound": null
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2215,
          "bound": "self.explicit_slot_start == slots.len()"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        11,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        29,
        30,
        38,
        39,
        40
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "true",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2208,
          "bound": "slot_end == slots.len()"
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2215,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        11,
        19,
        20,
        21,
        22,
        23,
        24,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        39,
        40
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "true",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2208,
          "bound": "slot_end == slots.len()"
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2215,
          "bound": "self.explicit_slot_start == slots.len()"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        11,
        19,
        20,
        21,
        22,
        23,
        24,
        28,
        29,
        30,
        38,
        39,
        40
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "false",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "self.nfa.look_matcher().matches_set_inline(\n                epsilons.looks(),\n                input.haystack(),\n                at,\n            )",
          "norm": null,
          "value": "true",
          "line": 2194,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2208,
          "bound": null
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2215,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        12,
        13,
        14,
        15,
        16,
        17,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        39,
        40
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "false",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "self.nfa.look_matcher().matches_set_inline(\n                epsilons.looks(),\n                input.haystack(),\n                at,\n            )",
          "norm": null,
          "value": "true",
          "line": 2194,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2208,
          "bound": null
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2215,
          "bound": "self.explicit_slot_start == slots.len()"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        12,
        13,
        14,
        15,
        16,
        17,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        29,
        30,
        38,
        39,
        40
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "false",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "self.nfa.look_matcher().matches_set_inline(\n                epsilons.looks(),\n                input.haystack(),\n                at,\n            )",
          "norm": null,
          "value": "true",
          "line": 2194,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2208,
          "bound": "slot_end == slots.len()"
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "true",
          "line": 2215,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        12,
        13,
        14,
        15,
        16,
        17,
        19,
        20,
        21,
        22,
        23,
        24,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        39,
        40
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "false",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "self.nfa.look_matcher().matches_set_inline(\n                epsilons.looks(),\n                input.haystack(),\n                at,\n            )",
          "norm": null,
          "value": "true",
          "line": 2194,
          "bound": null
        },
        {
          "cond": "slot_end < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2208,
          "bound": "slot_end == slots.len()"
        },
        {
          "cond": "self.explicit_slot_start < slots.len()",
          "norm": null,
          "value": "false",
          "line": 2215,
          "bound": "self.explicit_slot_start == slots.len()"
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        12,
        13,
        14,
        15,
        16,
        17,
        19,
        20,
        21,
        22,
        23,
        24,
        28,
        29,
        30,
        38,
        39,
        40
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "true",
          "line": 2190,
          "bound": "sid == self.min_match_id"
        },
        {
          "cond": "epsilons.looks().is_empty()",
          "norm": null,
          "value": "false",
          "line": 2193,
          "bound": null
        },
        {
          "cond": "self.nfa.look_matcher().matches_set_inline(\n                epsilons.looks(),\n                input.haystack(),\n                at,\n            )",
          "norm": null,
          "value": "false",
          "line": 2194,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        12,
        13,
        14,
        15,
        16,
        18,
        40
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "sid >= self.min_match_id",
          "norm": "self.min_match_id <= sid",
          "value": "false",
          "line": 2190,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        41
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}