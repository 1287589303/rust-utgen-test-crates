{
  "name": "regex_automata::util::captures::{impl#0}::interpolate_string_into",
  "mod_info": {
    "name": "util::captures",
    "loc": "regex-automata/src/util/mod.rs:32:1:32:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/captures.rs:766:5:784:6",
  "doc": "/// Interpolates the capture references in `replacement` with the\n/// corresponding substrings in `haystack` matched by each reference. The\n/// interpolated string is written to `dst`.\n///\n/// See the [`interpolate` module](interpolate) for documentation on the\n/// format of the replacement string.\n///\n/// # Example\n///\n/// This example shows how to use interpolation, and also shows how it\n/// can work with multi-pattern regexes.\n///\n/// ```\n/// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};\n///\n/// let re = PikeVM::new_many(&[\n///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n///     r\"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})\",\n/// ])?;\n/// let mut cache = re.create_cache();\n/// let mut caps = re.create_captures();\n///\n/// let replacement = \"year=$year, month=$month, day=$day\";\n///\n/// // This matches the first pattern.\n/// let hay = \"On 14-03-2010, I became a Tenneessee lamb.\";\n/// re.captures(&mut cache, hay, &mut caps);\n/// let mut dst = String::new();\n/// caps.interpolate_string_into(hay, replacement, &mut dst);\n/// assert_eq!(\"year=2010, month=03, day=14\", dst);\n///\n/// // And this matches the second pattern.\n/// let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";\n/// re.captures(&mut cache, hay, &mut caps);\n/// let mut dst = String::new();\n/// caps.interpolate_string_into(hay, replacement, &mut dst);\n/// assert_eq!(\"year=2010, month=03, day=14\", dst);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn interpolate_string_into(",
    "    &self,",
    "    haystack: &str,",
    "    replacement: &str,",
    "    dst: &mut String,",
    ") {",
    "    interpolate::string(",
    "        replacement,",
    "        |index, dst| {",
    "            let span = match self.get_group(index) {",
    "                None => return,",
    "                Some(span) => span,",
    "            };",
    "            dst.push_str(&haystack[span]);",
    "        },",
    "        |name| self.group_info().to_index(self.pattern()?, name),",
    "        dst,",
    "    );",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}