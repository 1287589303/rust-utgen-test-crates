{
  "name": "regex_automata::dfa::dense::{impl#22}::from_bytes_unchecked",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": false,
  "loc": "regex-automata/src/dfa/dense.rs:4356:5:4421:6",
  "doc": "",
  "code": [
    "unsafe fn from_bytes_unchecked(",
    "    mut slice: &'a [u8],",
    ") -> Result<(MatchStates<&'a [u32]>, usize), DeserializeError> {",
    "    let slice_start = slice.as_ptr().as_usize();",
    "",
    "    // Read the total number of match states.",
    "    let (state_len, nr) =",
    "        wire::try_read_u32_as_usize(slice, \"match state length\")?;",
    "    slice = &slice[nr..];",
    "",
    "    // Read the slice start/length pairs.",
    "    let pair_len = wire::mul(2, state_len, \"match state offset pairs\")?;",
    "    let slices_bytes_len = wire::mul(",
    "        pair_len,",
    "        PatternID::SIZE,",
    "        \"match state slice offset byte length\",",
    "    )?;",
    "    wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?;",
    "    wire::check_alignment::<PatternID>(slice)?;",
    "    let slices_bytes = &slice[..slices_bytes_len];",
    "    slice = &slice[slices_bytes_len..];",
    "    // SAFETY: Since PatternID is always representable as a u32, all we",
    "    // need to do is ensure that we have the proper length and alignment.",
    "    // We've checked both above, so the cast below is safe.",
    "    //",
    "    // N.B. This is one of the few not-safe snippets in this function,",
    "    // so we mark it explicitly to call it out.",
    "    let slices = core::slice::from_raw_parts(",
    "        slices_bytes.as_ptr().cast::<u32>(),",
    "        pair_len,",
    "    );",
    "",
    "    // Read the total number of unique pattern IDs (which is always 1 more",
    "    // than the maximum pattern ID in this automaton, since pattern IDs are",
    "    // handed out contiguously starting at 0).",
    "    let (pattern_len, nr) =",
    "        wire::try_read_u32_as_usize(slice, \"pattern length\")?;",
    "    slice = &slice[nr..];",
    "",
    "    // Now read the pattern ID length. We don't need to store this",
    "    // explicitly, but we need it to know how many pattern IDs to read.",
    "    let (idlen, nr) =",
    "        wire::try_read_u32_as_usize(slice, \"pattern ID length\")?;",
    "    slice = &slice[nr..];",
    "",
    "    // Read the actual pattern IDs.",
    "    let pattern_ids_len =",
    "        wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?;",
    "    wire::check_slice_len(slice, pattern_ids_len, \"match pattern IDs\")?;",
    "    wire::check_alignment::<PatternID>(slice)?;",
    "    let pattern_ids_bytes = &slice[..pattern_ids_len];",
    "    slice = &slice[pattern_ids_len..];",
    "    // SAFETY: Since PatternID is always representable as a u32, all we",
    "    // need to do is ensure that we have the proper length and alignment.",
    "    // We've checked both above, so the cast below is safe.",
    "    //",
    "    // N.B. This is one of the few not-safe snippets in this function,",
    "    // so we mark it explicitly to call it out.",
    "    let pattern_ids = core::slice::from_raw_parts(",
    "        pattern_ids_bytes.as_ptr().cast::<u32>(),",
    "        idlen,",
    "    );",
    "",
    "    let ms = MatchStates { slices, pattern_ids, pattern_len };",
    "    Ok((ms, slice.as_ptr().as_usize() - slice_start))",
    "}"
  ],
  "size": {
    "chain": 11,
    "contra": 0,
    "min_set": 11
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Err/None",
          "line": 4363,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Err/None",
          "line": 4367,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        14,
        16,
        17,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Err/None",
          "line": 4368,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        21,
        23,
        24,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Err/None",
          "line": 4373,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        28,
        30,
        31,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4373,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Err/None",
          "line": 4374,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        35,
        37,
        38,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4373,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4374,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern length\")?",
          "norm": null,
          "value": "Err/None",
          "line": 4392,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        47,
        49,
        50,
        91,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4373,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4374,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4392,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern ID length\")?",
          "norm": null,
          "value": "Err/None",
          "line": 4398,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        51,
        52,
        53,
        55,
        57,
        58,
        90,
        91,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4373,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4374,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4392,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern ID length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4398,
          "bound": null
        },
        {
          "cond": "wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?",
          "norm": null,
          "value": "Err/None",
          "line": 4403,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        51,
        52,
        53,
        56,
        59,
        60,
        61,
        63,
        65,
        66,
        89,
        90,
        91,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4373,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4374,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4392,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern ID length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4398,
          "bound": null
        },
        {
          "cond": "wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4403,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, pattern_ids_len, \"match pattern IDs\")?",
          "norm": null,
          "value": "Err/None",
          "line": 4404,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        51,
        52,
        53,
        56,
        59,
        60,
        61,
        64,
        67,
        68,
        70,
        72,
        73,
        89,
        90,
        91,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4373,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4374,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4392,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern ID length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4398,
          "bound": null
        },
        {
          "cond": "wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4403,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, pattern_ids_len, \"match pattern IDs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4404,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Err/None",
          "line": 4405,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        51,
        52,
        53,
        56,
        59,
        60,
        61,
        64,
        67,
        68,
        71,
        74,
        75,
        77,
        79,
        80,
        89,
        90,
        91,
        92,
        93,
        94,
        95
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"match state length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4363,
          "bound": null
        },
        {
          "cond": "wire::mul(2, state_len, \"match state offset pairs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4367,
          "bound": null
        },
        {
          "cond": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4368,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4373,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4374,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4392,
          "bound": null
        },
        {
          "cond": "wire::try_read_u32_as_usize(slice, \"pattern ID length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4398,
          "bound": null
        },
        {
          "cond": "wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4403,
          "bound": null
        },
        {
          "cond": "wire::check_slice_len(slice, pattern_ids_len, \"match pattern IDs\")?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4404,
          "bound": null
        },
        {
          "cond": "wire::check_alignment::<PatternID>(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 4405,
          "bound": null
        }
      ],
      "ret": "Ok((ms, slice.as_ptr().as_usize() - slice_start))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        51,
        52,
        53,
        56,
        59,
        60,
        61,
        64,
        67,
        68,
        71,
        74,
        75,
        78,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        95
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}