{
  "name": "regex_automata::nfa::thompson::nfa::{impl#0}::is_always_start_anchored",
  "mod_info": {
    "name": "nfa::thompson::nfa",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:66:1:66:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/nfa.rs:964:5:966:6",
  "doc": "/// Returns true if and only if all starting states for this NFA correspond\n/// to the beginning of an anchored search.\n///\n/// Typically, an NFA will have both an anchored and an unanchored starting\n/// state. Namely, because it tends to be useful to have both and the cost\n/// of having an unanchored starting state is almost zero (for an NFA).\n/// However, if all patterns in the NFA are themselves anchored, then even\n/// the unanchored starting state will correspond to an anchored search\n/// since the pattern doesn't permit anything else.\n///\n/// # Example\n///\n/// This example shows a few different scenarios where this method's\n/// return value varies.\n///\n/// ```\n/// use regex_automata::nfa::thompson::NFA;\n///\n/// // The unanchored starting state permits matching this pattern anywhere\n/// // in a haystack, instead of just at the beginning.\n/// let nfa = NFA::new(\"a\")?;\n/// assert!(!nfa.is_always_start_anchored());\n///\n/// // In this case, the pattern is itself anchored, so there is no way\n/// // to run an unanchored search.\n/// let nfa = NFA::new(\"^a\")?;\n/// assert!(nfa.is_always_start_anchored());\n///\n/// // When multiline mode is enabled, '^' can match at the start of a line\n/// // in addition to the start of a haystack, so an unanchored search is\n/// // actually possible.\n/// let nfa = NFA::new(\"(?m)^a\")?;\n/// assert!(!nfa.is_always_start_anchored());\n///\n/// // Weird cases also work. A pattern is only considered anchored if all\n/// // matches may only occur at the start of a haystack.\n/// let nfa = NFA::new(\"(^a)|a\")?;\n/// assert!(!nfa.is_always_start_anchored());\n///\n/// // When multiple patterns are present, if they are all anchored, then\n/// // the NFA is always anchored too.\n/// let nfa = NFA::new_many(&[\"^a\", \"^b\", \"^c\"])?;\n/// assert!(nfa.is_always_start_anchored());\n///\n/// // But if one pattern is unanchored, then the NFA must permit an\n/// // unanchored search.\n/// let nfa = NFA::new_many(&[\"^a\", \"b\", \"^c\"])?;\n/// assert!(!nfa.is_always_start_anchored());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn is_always_start_anchored(&self) -> bool {",
    "    self.start_anchored() == self.start_unanchored()",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}