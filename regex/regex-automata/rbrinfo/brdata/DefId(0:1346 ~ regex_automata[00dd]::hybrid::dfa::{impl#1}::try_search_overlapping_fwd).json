{
  "name": "regex_automata::hybrid::dfa::{impl#1}::try_search_overlapping_fwd",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:896:5:915:6",
  "doc": "/// Executes an overlapping forward search and returns the end position of\n/// matches as they are found. If no match exists, then `None` is returned.\n///\n/// This routine is principally only useful when searching for multiple\n/// patterns on inputs where multiple patterns may match the same regions\n/// of text. In particular, callers must preserve the automaton's search\n/// state from prior calls so that the implementation knows where the last\n/// match occurred.\n///\n/// When using this routine to implement an iterator of overlapping\n/// matches, the `start` of the search should remain invariant throughout\n/// iteration. The `OverlappingState` given to the search will keep track\n/// of the current position of the search. (This is because multiple\n/// matches may be reported at the same position, so only the search\n/// implementation itself knows when to advance the position.)\n///\n/// If for some reason you want the search to forget about its previous\n/// state and restart the search at a particular position, then setting the\n/// state to [`OverlappingState::start`] will accomplish that.\n///\n/// # Errors\n///\n/// This routine errors if the search could not complete. This can occur\n/// in a number of circumstances:\n///\n/// * The configuration of the lazy DFA may permit it to \"quit\" the search.\n/// For example, setting quit bytes or enabling heuristic support for\n/// Unicode word boundaries. The default configuration does not enable any\n/// option that could result in the lazy DFA quitting.\n/// * The configuration of the lazy DFA may also permit it to \"give up\"\n/// on a search if it makes ineffective use of its transition table\n/// cache. The default configuration does not enable this by default,\n/// although it is typically a good idea to.\n/// * When the provided `Input` configuration is not supported. For\n/// example, by providing an unsupported anchor mode.\n///\n/// When a search returns an error, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example\n///\n/// This example shows how to run a basic overlapping search. Notice\n/// that we build the automaton with a `MatchKind::All` configuration.\n/// Overlapping searches are unlikely to work as one would expect when\n/// using the default `MatchKind::LeftmostFirst` match semantics, since\n/// leftmost-first matching is fundamentally incompatible with overlapping\n/// searches. Namely, overlapping searches need to report matches as they\n/// are seen, where as leftmost-first searches will continue searching even\n/// after a match has been observed in order to find the conventional end\n/// position of the match. More concretely, leftmost-first searches use\n/// dead states to terminate a search after a specific match can no longer\n/// be extended. Overlapping searches instead do the opposite by continuing\n/// the search to find totally new matches (potentially of other patterns).\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     hybrid::dfa::{DFA, OverlappingState},\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .configure(DFA::config().match_kind(MatchKind::All))\n///     .build_many(&[r\"\\w+$\", r\"\\S+$\"])?;\n/// let mut cache = dfa.create_cache();\n///\n/// let haystack = \"@foo\";\n/// let mut state = OverlappingState::start();\n///\n/// let expected = Some(HalfMatch::must(1, 4));\n/// dfa.try_search_overlapping_fwd(\n///     &mut cache, &Input::new(haystack), &mut state,\n/// )?;\n/// assert_eq!(expected, state.get_match());\n///\n/// // The first pattern also matches at the same position, so re-running\n/// // the search will yield another match. Notice also that the first\n/// // pattern is returned after the second. This is because the second\n/// // pattern begins its match before the first, is therefore an earlier\n/// // match and is thus reported first.\n/// let expected = Some(HalfMatch::must(0, 4));\n/// dfa.try_search_overlapping_fwd(\n///     &mut cache, &Input::new(haystack), &mut state,\n/// )?;\n/// assert_eq!(expected, state.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn try_search_overlapping_fwd(",
    "    &self,",
    "    cache: &mut Cache,",
    "    input: &Input<'_>,",
    "    state: &mut OverlappingState,",
    ") -> Result<(), MatchError> {",
    "    let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();",
    "    search::find_overlapping_fwd(self, cache, input, state)?;",
    "    match state.get_match() {",
    "        None => Ok(()),",
    "        Some(_) if !utf8empty => Ok(()),",
    "        Some(_) => skip_empty_utf8_splits_overlapping(",
    "            input,",
    "            state,",
    "            |input, state| {",
    "                search::find_overlapping_fwd(self, cache, input, state)",
    "            },",
    "        ),",
    "    }",
    "}"
  ],
  "size": {
    "chain": 8,
    "contra": 0,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "true",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Err/None",
          "line": 903,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        5,
        6,
        7,
        8,
        9,
        11,
        13,
        14,
        27,
        28,
        29
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "true",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 903,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_) or Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "true",
          "line": 906,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        5,
        6,
        7,
        8,
        9,
        12,
        15,
        16,
        19,
        22,
        23,
        20,
        25,
        26,
        29
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "true",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 903,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_) or Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "false",
          "line": 906,
          "bound": null
        }
      ],
      "ret": "Ok(())",
      "path": [
        0,
        1,
        2,
        3,
        5,
        6,
        7,
        8,
        9,
        12,
        15,
        16,
        19,
        22,
        24,
        26,
        29
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "true",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 903,
          "bound": null
        },
        {
          "cond": "state.get_match() matches None",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "state.get_match() matches None",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        }
      ],
      "ret": "Ok(())",
      "path": [
        0,
        1,
        2,
        3,
        5,
        6,
        7,
        8,
        9,
        12,
        15,
        16,
        18,
        21,
        26,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "false",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Err/None",
          "line": 903,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        7,
        8,
        9,
        11,
        13,
        14,
        27,
        28,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "false",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 903,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_) or Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "true",
          "line": 906,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        7,
        8,
        9,
        12,
        15,
        16,
        19,
        22,
        23,
        20,
        25,
        26,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "false",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 903,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_) or Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "state.get_match() matches Some(_)",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "false",
          "line": 906,
          "bound": null
        }
      ],
      "ret": "Ok(())",
      "path": [
        0,
        1,
        2,
        4,
        7,
        8,
        9,
        12,
        15,
        16,
        19,
        22,
        24,
        26,
        29
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "self.get_nfa().has_empty()",
          "norm": null,
          "value": "false",
          "line": 902,
          "bound": null
        },
        {
          "cond": "search::find_overlapping_fwd(self, cache, input, state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 903,
          "bound": null
        },
        {
          "cond": "state.get_match() matches None",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        },
        {
          "cond": "state.get_match() matches None",
          "norm": null,
          "value": "true",
          "line": 904,
          "bound": null
        }
      ],
      "ret": "Ok(())",
      "path": [
        0,
        1,
        2,
        4,
        7,
        8,
        9,
        12,
        15,
        16,
        18,
        21,
        26,
        29
      ],
      "may_contra": false,
      "min_set": false
    }
  ]
}