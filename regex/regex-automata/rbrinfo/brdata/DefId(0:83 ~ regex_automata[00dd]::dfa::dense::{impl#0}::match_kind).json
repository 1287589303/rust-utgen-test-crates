{
  "name": "regex_automata::dfa::dense::{impl#0}::match_kind",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:358:5:361:6",
  "doc": "/// Set the desired match semantics.\n///\n/// The default is [`MatchKind::LeftmostFirst`], which corresponds to the\n/// match semantics of Perl-like regex engines. That is, when multiple\n/// patterns would match at the same leftmost position, the pattern that\n/// appears first in the concrete syntax is chosen.\n///\n/// Currently, the only other kind of match semantics supported is\n/// [`MatchKind::All`]. This corresponds to classical DFA construction\n/// where all possible matches are added to the DFA.\n///\n/// Typically, `All` is used when one wants to execute an overlapping\n/// search and `LeftmostFirst` otherwise. In particular, it rarely makes\n/// sense to use `All` with the various \"leftmost\" find routines, since the\n/// leftmost routines depend on the `LeftmostFirst` automata construction\n/// strategy. Specifically, `LeftmostFirst` adds dead states to the DFA\n/// as a way to terminate the search and report a match. `LeftmostFirst`\n/// also supports non-greedy matches using this strategy where as `All`\n/// does not.\n///\n/// # Example: overlapping search\n///\n/// This example shows the typical use of `MatchKind::All`, which is to\n/// report overlapping matches.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     dfa::{Automaton, OverlappingState, dense},\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = dense::Builder::new()\n///     .configure(dense::Config::new().match_kind(MatchKind::All))\n///     .build_many(&[r\"\\w+$\", r\"\\S+$\"])?;\n/// let input = Input::new(\"@foo\");\n/// let mut state = OverlappingState::start();\n///\n/// let expected = Some(HalfMatch::must(1, 4));\n/// dfa.try_search_overlapping_fwd(&input, &mut state)?;\n/// assert_eq!(expected, state.get_match());\n///\n/// // The first pattern also matches at the same position, so re-running\n/// // the search will yield another match. Notice also that the first\n/// // pattern is returned after the second. This is because the second\n/// // pattern begins its match before the first, is therefore an earlier\n/// // match and is thus reported first.\n/// let expected = Some(HalfMatch::must(0, 4));\n/// dfa.try_search_overlapping_fwd(&input, &mut state)?;\n/// assert_eq!(expected, state.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: reverse automaton to find start of match\n///\n/// Another example for using `MatchKind::All` is for constructing a\n/// reverse automaton to find the start of a match. `All` semantics are\n/// used for this in order to find the longest possible match, which\n/// corresponds to the leftmost starting position.\n///\n/// Note that if you need the starting position then\n/// [`dfa::regex::Regex`](crate::dfa::regex::Regex) will handle this for\n/// you, so it's usually not necessary to do this yourself.\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense, Automaton, StartKind},\n///     nfa::thompson::NFA,\n///     Anchored, HalfMatch, Input, MatchKind,\n/// };\n///\n/// let haystack = \"123foobar456\".as_bytes();\n/// let pattern = r\"[a-z]+r\";\n///\n/// let dfa_fwd = dense::DFA::new(pattern)?;\n/// let dfa_rev = dense::Builder::new()\n///     .thompson(NFA::config().reverse(true))\n///     .configure(dense::Config::new()\n///         // This isn't strictly necessary since both anchored and\n///         // unanchored searches are supported by default. But since\n///         // finding the start-of-match only requires anchored searches,\n///         // we can get rid of the unanchored configuration and possibly\n///         // slim down our DFA considerably.\n///         .start_kind(StartKind::Anchored)\n///         .match_kind(MatchKind::All)\n///     )\n///     .build(pattern)?;\n/// let expected_fwd = HalfMatch::must(0, 9);\n/// let expected_rev = HalfMatch::must(0, 3);\n/// let got_fwd = dfa_fwd.try_search_fwd(&Input::new(haystack))?.unwrap();\n/// // Here we don't specify the pattern to search for since there's only\n/// // one pattern and we're doing a leftmost search. But if this were an\n/// // overlapping search, you'd need to specify the pattern that matched\n/// // in the forward direction. (Otherwise, you might wind up finding the\n/// // starting position of a match of some other pattern.) That in turn\n/// // requires building the reverse automaton with starts_for_each_pattern\n/// // enabled. Indeed, this is what Regex does internally.\n/// let input = Input::new(haystack)\n///     .range(..got_fwd.offset())\n///     .anchored(Anchored::Yes);\n/// let got_rev = dfa_rev.try_search_rev(&input)?.unwrap();\n/// assert_eq!(expected_fwd, got_fwd);\n/// assert_eq!(expected_rev, got_rev);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn match_kind(mut self, kind: MatchKind) -> Config {",
    "    self.match_kind = Some(kind);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}