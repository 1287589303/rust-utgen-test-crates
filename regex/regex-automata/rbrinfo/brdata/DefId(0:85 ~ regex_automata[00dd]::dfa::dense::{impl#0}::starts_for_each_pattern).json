{
  "name": "regex_automata::dfa::dense::{impl#0}::starts_for_each_pattern",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:475:5:478:6",
  "doc": "/// Whether to compile a separate start state for each pattern in the\n/// automaton.\n///\n/// When enabled, a separate **anchored** start state is added for each\n/// pattern in the DFA. When this start state is used, then the DFA will\n/// only search for matches for the pattern specified, even if there are\n/// other patterns in the DFA.\n///\n/// The main downside of this option is that it can potentially increase\n/// the size of the DFA and/or increase the time it takes to build the DFA.\n///\n/// There are a few reasons one might want to enable this (it's disabled\n/// by default):\n///\n/// 1. When looking for the start of an overlapping match (using a\n/// reverse DFA), doing it correctly requires starting the reverse search\n/// using the starting state of the pattern that matched in the forward\n/// direction. Indeed, when building a [`Regex`](crate::dfa::regex::Regex),\n/// it will automatically enable this option when building the reverse DFA\n/// internally.\n/// 2. When you want to use a DFA with multiple patterns to both search\n/// for matches of any pattern or to search for anchored matches of one\n/// particular pattern while using the same DFA. (Otherwise, you would need\n/// to compile a new DFA for each pattern.)\n/// 3. Since the start states added for each pattern are anchored, if you\n/// compile an unanchored DFA with one pattern while also enabling this\n/// option, then you can use the same DFA to perform anchored or unanchored\n/// searches. The latter you get with the standard search APIs. The former\n/// you get from the various `_at` search methods that allow you specify a\n/// pattern ID to search for.\n///\n/// By default this is disabled.\n///\n/// # Example\n///\n/// This example shows how to use this option to permit the same DFA to\n/// run both anchored and unanchored searches for a single pattern.\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense, Automaton},\n///     Anchored, HalfMatch, PatternID, Input,\n/// };\n///\n/// let dfa = dense::Builder::new()\n///     .configure(dense::Config::new().starts_for_each_pattern(true))\n///     .build(r\"foo[0-9]+\")?;\n/// let haystack = \"quux foo123\";\n///\n/// // Here's a normal unanchored search. Notice that we use 'None' for the\n/// // pattern ID. Since the DFA was built as an unanchored machine, it\n/// // use its default unanchored starting state.\n/// let expected = HalfMatch::must(0, 11);\n/// let input = Input::new(haystack);\n/// assert_eq!(Some(expected), dfa.try_search_fwd(&input)?);\n/// // But now if we explicitly specify the pattern to search ('0' being\n/// // the only pattern in the DFA), then it will use the starting state\n/// // for that specific pattern which is always anchored. Since the\n/// // pattern doesn't have a match at the beginning of the haystack, we\n/// // find nothing.\n/// let input = Input::new(haystack)\n///     .anchored(Anchored::Pattern(PatternID::must(0)));\n/// assert_eq!(None, dfa.try_search_fwd(&input)?);\n/// // And finally, an anchored search is not the same as putting a '^' at\n/// // beginning of the pattern. An anchored search can only match at the\n/// // beginning of the *search*, which we can change:\n/// let input = Input::new(haystack)\n///     .anchored(Anchored::Pattern(PatternID::must(0)))\n///     .range(5..);\n/// assert_eq!(Some(expected), dfa.try_search_fwd(&input)?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {",
    "    self.starts_for_each_pattern = Some(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}