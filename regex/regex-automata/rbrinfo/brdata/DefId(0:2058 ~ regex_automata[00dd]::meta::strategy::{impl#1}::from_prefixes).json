{
  "name": "regex_automata::meta::strategy::{impl#1}::from_prefixes",
  "mod_info": {
    "name": "meta::strategy",
    "loc": "regex-automata/src/meta/mod.rs:61:1:61:14"
  },
  "visible": false,
  "loc": "regex-automata/src/meta/strategy.rs:224:5:305:6",
  "doc": "/// Given a sequence of prefixes, attempt to return a full `Strategy` using\n/// just the prefixes.\n///\n/// Basically, this occurs when the prefixes given not just prefixes,\n/// but an enumeration of the entire language matched by the regular\n/// expression.\n///\n/// A number of other conditions need to be true too. For example, there\n/// can be only one pattern, the number of explicit capture groups is 0, no\n/// look-around assertions and so on.\n///\n/// Note that this ignores `Config::get_auto_prefilter` because if this\n/// returns something, then it isn't a prefilter but a matcher itself.\n/// Therefore, it shouldn't suffer from the problems typical to prefilters\n/// (such as a high false positive rate).\n",
  "code": [
    "fn from_prefixes(",
    "    info: &RegexInfo,",
    "    prefixes: &literal::Seq,",
    ") -> Option<Arc<dyn Strategy>> {",
    "    let kind = info.config().get_match_kind();",
    "    // Check to see if our prefixes are exact, which means we might be",
    "    // able to bypass the regex engine entirely and just rely on literal",
    "    // searches.",
    "    if !prefixes.is_exact() {",
    "        return None;",
    "    }",
    "    // We also require that we have a single regex pattern. Namely,",
    "    // we reuse the prefilter infrastructure to implement search and",
    "    // prefilters only report spans. Prefilters don't know about pattern",
    "    // IDs. The multi-regex case isn't a lost cause, we might still use",
    "    // Aho-Corasick and we might still just use a regular prefilter, but",
    "    // that's done below.",
    "    if info.pattern_len() != 1 {",
    "        return None;",
    "    }",
    "    // We can't have any capture groups either. The literal engines don't",
    "    // know how to deal with things like '(foo)(bar)'. In that case, a",
    "    // prefilter will just be used and then the regex engine will resolve",
    "    // the capture groups.",
    "    if info.props()[0].explicit_captures_len() != 0 {",
    "        return None;",
    "    }",
    "    // We also require that it has zero look-around assertions. Namely,",
    "    // literal extraction treats look-around assertions as if they match",
    "    // *every* empty string. But of course, that isn't true. So for",
    "    // example, 'foo\\bquux' never matches anything, but 'fooquux' is",
    "    // extracted from that as an exact literal. Such cases should just run",
    "    // the regex engine. 'fooquux' will be used as a normal prefilter, and",
    "    // then the regex engine will try to look for an actual match.",
    "    if !info.props()[0].look_set().is_empty() {",
    "        return None;",
    "    }",
    "    // Finally, currently, our prefilters are all oriented around",
    "    // leftmost-first match semantics, so don't try to use them if the",
    "    // caller asked for anything else.",
    "    if kind != MatchKind::LeftmostFirst {",
    "        return None;",
    "    }",
    "    // The above seems like a lot of requirements to meet, but it applies",
    "    // to a lot of cases. 'foo', '[abc][123]' and 'foo|bar|quux' all meet",
    "    // the above criteria, for example.",
    "    //",
    "    // Note that this is effectively a latency optimization. If we didn't",
    "    // do this, then the extracted literals would still get bundled into",
    "    // a prefilter, and every regex engine capable of running unanchored",
    "    // searches supports prefilters. So this optimization merely sidesteps",
    "    // having to run the regex engine at all to confirm the match. Thus, it",
    "    // decreases the latency of a match.",
    "",
    "    // OK because we know the set is exact and thus finite.",
    "    let prefixes = prefixes.literals().unwrap();",
    "    debug!(",
    "        \"trying to bypass regex engine by creating \\",
    "         prefilter from {} literals: {:?}\",",
    "        prefixes.len(),",
    "        prefixes,",
    "    );",
    "    let choice = match prefilter::Choice::new(kind, prefixes) {",
    "        Some(choice) => choice,",
    "        None => {",
    "            debug!(",
    "                \"regex bypass failed because no prefilter could be built\"",
    "            );",
    "            return None;",
    "        }",
    "    };",
    "    let strat: Arc<dyn Strategy> = match choice {",
    "        prefilter::Choice::Memchr(pre) => Pre::new(pre),",
    "        prefilter::Choice::Memchr2(pre) => Pre::new(pre),",
    "        prefilter::Choice::Memchr3(pre) => Pre::new(pre),",
    "        prefilter::Choice::Memmem(pre) => Pre::new(pre),",
    "        prefilter::Choice::Teddy(pre) => Pre::new(pre),",
    "        prefilter::Choice::ByteSet(pre) => Pre::new(pre),",
    "        prefilter::Choice::AhoCorasick(pre) => Pre::new(pre),",
    "    };",
    "    Some(strat)",
    "}"
  ],
  "size": {
    "chain": 13,
    "contra": 0,
    "min_set": 13
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "true",
          "line": 241,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        7,
        64,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "true",
          "line": 248,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        12,
        64,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "true",
          "line": 264,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        21,
        64,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::AhoCorasick(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        }
      ],
      "ret": "Some(strat)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        27,
        29,
        30,
        31,
        39,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::ByteSet(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::ByteSet(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        }
      ],
      "ret": "Some(strat)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        27,
        29,
        30,
        31,
        38,
        53,
        54,
        57,
        58,
        59,
        60,
        61,
        62,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Teddy(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Teddy(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        }
      ],
      "ret": "Some(strat)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        27,
        29,
        30,
        31,
        37,
        50,
        51,
        52,
        57,
        58,
        59,
        60,
        61,
        62,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memmem(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memmem(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        }
      ],
      "ret": "Some(strat)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        27,
        29,
        30,
        31,
        36,
        47,
        48,
        49,
        57,
        58,
        59,
        60,
        61,
        62,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memchr3(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memchr3(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        }
      ],
      "ret": "Some(strat)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        27,
        29,
        30,
        31,
        35,
        45,
        46,
        57,
        58,
        59,
        60,
        61,
        62,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memchr2(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memchr2(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        }
      ],
      "ret": "Some(strat)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        27,
        29,
        30,
        31,
        34,
        43,
        44,
        57,
        58,
        59,
        60,
        61,
        62,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches Some(choice)",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memchr(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        },
        {
          "cond": "choice matches prefilter::Choice::Memchr(pre)",
          "norm": null,
          "value": "true",
          "line": 295,
          "bound": null
        }
      ],
      "ret": "Some(strat)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        27,
        29,
        30,
        31,
        33,
        40,
        41,
        42,
        57,
        58,
        59,
        60,
        61,
        62,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "true",
          "line": 258,
          "bound": null
        },
        {
          "cond": "kind != MatchKind::LeftmostFirst",
          "norm": "MatchKind::LeftmostFirst != kind",
          "value": "false",
          "line": 264,
          "bound": null
        },
        {
          "cond": "prefilter::Choice::new(kind, prefixes) matches None",
          "norm": null,
          "value": "true",
          "line": 286,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        23,
        24,
        25,
        28,
        63,
        64,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "true",
          "line": 232,
          "bound": null
        },
        {
          "cond": "info.pattern_len() != 1",
          "norm": "1 != info.pattern_len()",
          "value": "false",
          "line": 241,
          "bound": null
        },
        {
          "cond": "info.props()[0].explicit_captures_len() != 0",
          "norm": "0 != info.props()[0].explicit_captures_len()",
          "value": "false",
          "line": 248,
          "bound": null
        },
        {
          "cond": "info.props()[0].look_set().is_empty()",
          "norm": null,
          "value": "false",
          "line": 258,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        14,
        15,
        16,
        17,
        19,
        64,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "prefixes.is_exact()",
          "norm": null,
          "value": "false",
          "line": 232,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        5,
        64,
        65
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}