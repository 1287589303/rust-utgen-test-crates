{
  "name": "regex_automata::nfa::thompson::pikevm::{impl#0}::match_kind",
  "mod_info": {
    "name": "nfa::thompson::pikevm",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:68:1:68:16"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/pikevm.rs:96:5:99:6",
  "doc": "/// Set the desired match semantics.\n///\n/// The default is [`MatchKind::LeftmostFirst`], which corresponds to the\n/// match semantics of Perl-like regex engines. That is, when multiple\n/// patterns would match at the same leftmost position, the pattern that\n/// appears first in the concrete syntax is chosen.\n///\n/// Currently, the only other kind of match semantics supported is\n/// [`MatchKind::All`]. This corresponds to \"classical DFA\" construction\n/// where all possible matches are visited in the NFA by the `PikeVM`.\n///\n/// Typically, `All` is used when one wants to execute an overlapping\n/// search and `LeftmostFirst` otherwise. In particular, it rarely makes\n/// sense to use `All` with the various \"leftmost\" find routines, since the\n/// leftmost routines depend on the `LeftmostFirst` automata construction\n/// strategy. Specifically, `LeftmostFirst` results in the `PikeVM`\n/// simulating dead states as a way to terminate the search and report a\n/// match. `LeftmostFirst` also supports non-greedy matches using this\n/// strategy where as `All` does not.\n",
  "code": [
    "pub fn match_kind(mut self, kind: MatchKind) -> Config {",
    "    self.match_kind = Some(kind);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}