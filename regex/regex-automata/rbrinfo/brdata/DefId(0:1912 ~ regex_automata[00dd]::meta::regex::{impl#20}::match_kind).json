{
  "name": "regex_automata::meta::regex::{impl#20}::match_kind",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:2490:5:2492:6",
  "doc": "/// Set the match semantics for a `Regex`.\n///\n/// The default value is [`MatchKind::LeftmostFirst`].\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{meta::Regex, Match, MatchKind};\n///\n/// // By default, leftmost-first semantics are used, which\n/// // disambiguates matches at the same position by selecting\n/// // the one that corresponds earlier in the pattern.\n/// let re = Regex::new(\"sam|samwise\")?;\n/// assert_eq!(Some(Match::must(0, 0..3)), re.find(\"samwise\"));\n///\n/// // But with 'all' semantics, match priority is ignored\n/// // and all match states are included. When coupled with\n/// // a leftmost search, the search will report the last\n/// // possible match.\n/// let re = Regex::builder()\n///     .configure(Regex::config().match_kind(MatchKind::All))\n///     .build(\"sam|samwise\")?;\n/// assert_eq!(Some(Match::must(0, 0..7)), re.find(\"samwise\"));\n/// // Beware that this can lead to skipping matches!\n/// // Usually 'all' is used for anchored reverse searches\n/// // only, or for overlapping searches.\n/// assert_eq!(Some(Match::must(0, 4..11)), re.find(\"sam samwise\"));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn match_kind(self, kind: MatchKind) -> Config {",
    "    Config { match_kind: Some(kind), ..self }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "Config { match_kind: Some(kind), ..self }",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}