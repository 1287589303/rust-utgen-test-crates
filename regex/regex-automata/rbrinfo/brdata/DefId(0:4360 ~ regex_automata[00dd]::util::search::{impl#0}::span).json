{
  "name": "regex_automata::util::search::{impl#0}::span",
  "mod_info": {
    "name": "util::search",
    "loc": "regex-automata/src/util/mod.rs:53:1:53:23"
  },
  "visible": true,
  "loc": "regex-automata/src/util/search.rs:206:5:209:6",
  "doc": "/// Set the span for this search.\n///\n/// This routine does not panic if the span given is not a valid range for\n/// this search's haystack. If this search is run with an invalid range,\n/// then the most likely outcome is that the actual search execution will\n/// panic.\n///\n/// This routine is generic over how a span is provided. While\n/// a [`Span`] may be given directly, one may also provide a\n/// `std::ops::Range<usize>`. To provide anything supported by range\n/// syntax, use the [`Input::range`] method.\n///\n/// The default span is the entire haystack.\n///\n/// Note that [`Input::range`] overrides this method and vice versa.\n///\n/// # Panics\n///\n/// This panics if the given span does not correspond to valid bounds in\n/// the haystack or the termination of a search.\n///\n/// # Example\n///\n/// This example shows how the span of the search can impact whether a\n/// match is reported or not. This is particularly relevant for look-around\n/// operators, which might take things outside of the span into account\n/// when determining whether they match.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     nfa::thompson::pikevm::PikeVM,\n///     Match, Input,\n/// };\n///\n/// // Look for 'at', but as a distinct word.\n/// let re = PikeVM::new(r\"\\bat\\b\")?;\n/// let mut cache = re.create_cache();\n/// let mut caps = re.create_captures();\n///\n/// // Our haystack contains 'at', but not as a distinct word.\n/// let haystack = \"batter\";\n///\n/// // A standard search finds nothing, as expected.\n/// let input = Input::new(haystack);\n/// re.search(&mut cache, &input, &mut caps);\n/// assert_eq!(None, caps.get_match());\n///\n/// // But if we wanted to search starting at position '1', we might\n/// // slice the haystack. If we do this, it's impossible for the \\b\n/// // anchors to take the surrounding context into account! And thus,\n/// // a match is produced.\n/// let input = Input::new(&haystack[1..3]);\n/// re.search(&mut cache, &input, &mut caps);\n/// assert_eq!(Some(Match::must(0, 0..2)), caps.get_match());\n///\n/// // But if we specify the span of the search instead of slicing the\n/// // haystack, then the regex engine can \"see\" outside of the span\n/// // and resolve the anchors correctly.\n/// let input = Input::new(haystack).span(1..3);\n/// re.search(&mut cache, &input, &mut caps);\n/// assert_eq!(None, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// This may seem a little ham-fisted, but this scenario tends to come up\n/// if some other regex engine found the match span and now you need to\n/// re-process that span to look for capturing groups. (e.g., Run a faster\n/// DFA first, find a match, then run the PikeVM on just the match span to\n/// resolve capturing groups.) In order to implement that sort of logic\n/// correctly, you need to set the span on the search instead of slicing\n/// the haystack directly.\n///\n/// The other advantage of using this routine to specify the bounds of the\n/// search is that the match offsets are still reported in terms of the\n/// original haystack. For example, the second search in the example above\n/// reported a match at position `0`, even though `at` starts at offset\n/// `1` because we sliced the haystack.\n",
  "code": [
    "pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {",
    "    self.set_span(span);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}