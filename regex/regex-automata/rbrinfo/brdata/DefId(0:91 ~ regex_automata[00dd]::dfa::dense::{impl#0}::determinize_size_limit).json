{
  "name": "regex_automata::dfa::dense::{impl#0}::determinize_size_limit",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:946:5:949:6",
  "doc": "/// Set a size limit on the total heap used by determinization.\n///\n/// This size limit is expressed in bytes and is applied during\n/// determinization of an NFA into a DFA. If the heap used for auxiliary\n/// storage during determinization (memory that is not in the DFA but\n/// necessary for building the DFA) exceeds this configured limit, then\n/// determinization is stopped and an error is returned.\n///\n/// This limit does not apply to heap used by the DFA itself.\n///\n/// The total limit on heap used during determinization is the sum of the\n/// DFA and determinization size limits.\n///\n/// The default is no limit.\n///\n/// # Example\n///\n/// This example shows a DFA that fails to build because of a\n/// configured size limit on the amount of heap space used by\n/// determinization. This particular example complements the example for\n/// [`Config::dfa_size_limit`] by demonstrating that not only does Unicode\n/// potentially make DFAs themselves big, but it also results in more\n/// auxiliary storage during determinization. (Although, auxiliary storage\n/// is still not as much as the DFA itself.)\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// # if !cfg!(target_pointer_width = \"64\") { return Ok(()); } // see #1039\n/// use regex_automata::{dfa::{dense, Automaton}, Input};\n///\n/// // 700KB isn't enough!\n/// dense::Builder::new()\n///     .configure(dense::Config::new()\n///         .determinize_size_limit(Some(700_000))\n///     )\n///     .build(r\"\\w{20}\")\n///     .unwrap_err();\n///\n/// // ... but 800KB probably is!\n/// // (Note that auxiliary storage sizes aren't necessarily stable between\n/// // releases.)\n/// let dfa = dense::Builder::new()\n///     .configure(dense::Config::new()\n///         .determinize_size_limit(Some(800_000))\n///     )\n///     .build(r\"\\w{20}\")?;\n/// let haystack = \"A\".repeat(20).into_bytes();\n/// assert!(dfa.try_search_fwd(&Input::new(&haystack))?.is_some());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// Note that some parts of the configuration on a DFA can have a\n/// big impact on how big the DFA is, and thus, how much memory is\n/// used. For example, the default setting for [`Config::start_kind`] is\n/// [`StartKind::Both`]. But if you only need an anchored search, for\n/// example, then it can be much cheaper to build a DFA that only supports\n/// anchored searches. (Running an unanchored search with it would panic.)\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// # if !cfg!(target_pointer_width = \"64\") { return Ok(()); } // see #1039\n/// use regex_automata::{\n///     dfa::{dense, Automaton, StartKind},\n///     Anchored, Input,\n/// };\n///\n/// // 200KB isn't enough!\n/// dense::Builder::new()\n///     .configure(dense::Config::new()\n///         .determinize_size_limit(Some(200_000))\n///         .start_kind(StartKind::Anchored)\n///     )\n///     .build(r\"\\w{20}\")\n///     .unwrap_err();\n///\n/// // ... but 300KB probably is!\n/// // (Note that auxiliary storage sizes aren't necessarily stable between\n/// // releases.)\n/// let dfa = dense::Builder::new()\n///     .configure(dense::Config::new()\n///         .determinize_size_limit(Some(300_000))\n///         .start_kind(StartKind::Anchored)\n///     )\n///     .build(r\"\\w{20}\")?;\n/// let haystack = \"A\".repeat(20).into_bytes();\n/// let input = Input::new(&haystack).anchored(Anchored::Yes);\n/// assert!(dfa.try_search_fwd(&input)?.is_some());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn determinize_size_limit(mut self, bytes: Option<usize>) -> Config {",
    "    self.determinize_size_limit = Some(bytes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}