{
  "name": "regex_automata::nfa::thompson::nfa::{impl#6}::matches_byte",
  "mod_info": {
    "name": "nfa::thompson::nfa",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:66:1:66:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/nfa.rs:1830:5:1866:6",
  "doc": "/// This follows the matching transition for a particular byte.\n///\n/// The matching transition is found by looking for a matching byte range\n/// (there is at most one) corresponding to the byte given.\n",
  "code": [
    "pub fn matches_byte(&self, byte: u8) -> Option<StateID> {",
    "    for t in self.transitions.iter() {",
    "        if t.start > byte {",
    "            break;",
    "        } else if t.matches_byte(byte) {",
    "            return Some(t.next);",
    "        }",
    "    }",
    "    None",
    "",
    "    /*",
    "    // This is an alternative implementation that uses binary search. In",
    "    // some ad hoc experiments, like",
    "    //",
    "    //   regex-cli find match pikevm -b -p '\\b\\w+\\b' non-ascii-file",
    "    //",
    "    // I could not observe any improvement, and in fact, things seemed to",
    "    // be a bit slower. I can see an improvement in at least one benchmark:",
    "    //",
    "    //   regex-cli find match pikevm -b -p '\\pL{100}' all-codepoints-utf8",
    "    //",
    "    // Where total search time goes from 3.2s to 2.4s when using binary",
    "    // search.",
    "    self.transitions",
    "        .binary_search_by(|t| {",
    "            if t.end < byte {",
    "                core::cmp::Ordering::Less",
    "            } else if t.start > byte {",
    "                core::cmp::Ordering::Greater",
    "            } else {",
    "                core::cmp::Ordering::Equal",
    "            }",
    "        })",
    "        .ok()",
    "        .map(|i| self.transitions[i].next)",
    "    */",
    "}"
  ],
  "size": {
    "chain": 4,
    "contra": 1,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "t in self.transitions.iter()",
          "norm": null,
          "value": "true",
          "line": 1831,
          "bound": null
        },
        {
          "cond": "t.start > byte",
          "norm": "byte < t.start",
          "value": "true",
          "line": 1832,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "t in self.transitions.iter()",
          "norm": null,
          "value": "true",
          "line": 1831,
          "bound": null
        },
        {
          "cond": "t.start > byte",
          "norm": "byte < t.start",
          "value": "false",
          "line": 1832,
          "bound": "t.start == byte"
        },
        {
          "cond": "t.matches_byte(byte)",
          "norm": null,
          "value": "true",
          "line": 1834,
          "bound": null
        }
      ],
      "ret": "Some(t.next)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        11,
        12,
        13,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "t in self.transitions.iter()",
          "norm": null,
          "value": "true",
          "line": 1831,
          "bound": null
        },
        {
          "cond": "t.start > byte",
          "norm": "byte < t.start",
          "value": "false",
          "line": 1832,
          "bound": "t.start == byte"
        },
        {
          "cond": "t.matches_byte(byte)",
          "norm": null,
          "value": "false",
          "line": 1834,
          "bound": null
        },
        {
          "cond": "t in self.transitions.iter()",
          "norm": null,
          "value": "false",
          "line": 1831,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        11,
        12,
        14,
        3,
        4,
        5,
        7,
        9,
        15,
        16
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "t in self.transitions.iter()",
          "norm": null,
          "value": "false",
          "line": 1831,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}