{
  "name": "regex_automata::util::captures::{impl#0}::extract",
  "mod_info": {
    "name": "util::captures",
    "loc": "regex-automata/src/util/mod.rs:32:1:32:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/captures.rs:937:5:948:6",
  "doc": "/// This is a convenience routine for extracting the substrings\n/// corresponding to matching capture groups in the given `haystack`. The\n/// `haystack` should be the same substring used to find the match spans in\n/// this `Captures` value.\n///\n/// This is identical to [`Captures::extract_bytes`], except it works with\n/// `&str` instead of `&[u8]`.\n///\n/// # Panics\n///\n/// This panics if the number of explicit matching groups in this\n/// `Captures` value is less than `N`. This also panics if this `Captures`\n/// value does not correspond to a match.\n///\n/// Note that this does *not* panic if the number of explicit matching\n/// groups is bigger than `N`. In that case, only the first `N` matching\n/// groups are extracted.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::nfa::thompson::pikevm::PikeVM;\n///\n/// let re = PikeVM::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\")?;\n/// let mut cache = re.create_cache();\n/// let mut caps = re.create_captures();\n///\n/// let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";\n/// re.captures(&mut cache, hay, &mut caps);\n/// assert!(caps.is_match());\n/// let (full, [year, month, day]) = caps.extract(hay);\n/// assert_eq!(\"2010-03-14\", full);\n/// assert_eq!(\"2010\", year);\n/// assert_eq!(\"03\", month);\n/// assert_eq!(\"14\", day);\n///\n/// // We can also ask for fewer than all capture groups.\n/// let (full, [year]) = caps.extract(hay);\n/// assert_eq!(\"2010-03-14\", full);\n/// assert_eq!(\"2010\", year);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn extract<'h, const N: usize>(",
    "    &self,",
    "    haystack: &'h str,",
    ") -> (&'h str, [&'h str; N]) {",
    "    let mut matched = self.iter().flatten();",
    "    let whole_match = &haystack[matched.next().expect(\"a match\")];",
    "    let group_matches = [0; N].map(|_| {",
    "        let sp = matched.next().expect(\"too few matching groups\");",
    "        &haystack[sp]",
    "    });",
    "    (whole_match, group_matches)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "(whole_match, group_matches)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}