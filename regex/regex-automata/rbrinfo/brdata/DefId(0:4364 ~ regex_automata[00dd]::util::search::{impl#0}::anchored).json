{
  "name": "regex_automata::util::search::{impl#0}::anchored",
  "mod_info": {
    "name": "util::search",
    "loc": "regex-automata/src/util/mod.rs:53:1:53:23"
  },
  "visible": true,
  "loc": "regex-automata/src/util/search.rs:342:5:345:6",
  "doc": "/// Sets the anchor mode of a search.\n///\n/// When a search is anchored (so that's [`Anchored::Yes`] or\n/// [`Anchored::Pattern`]), a match must begin at the start of a search.\n/// When a search is not anchored (that's [`Anchored::No`]), regex engines\n/// will behave as if the pattern started with a `(?s-u:.)*?`. This prefix\n/// permits a match to appear anywhere.\n///\n/// By default, the anchored mode is [`Anchored::No`].\n///\n/// **WARNING:** this is subtly different than using a `^` at the start of\n/// your regex. A `^` forces a regex to match exclusively at the start of\n/// a haystack, regardless of where you begin your search. In contrast,\n/// anchoring a search will allow your regex to match anywhere in your\n/// haystack, but the match must start at the beginning of a search.\n///\n/// For example, consider the haystack `aba` and the following searches:\n///\n/// 1. The regex `^a` is compiled with `Anchored::No` and searches `aba`\n///    starting at position `2`. Since `^` requires the match to start at\n///    the beginning of the haystack and `2 > 0`, no match is found.\n/// 2. The regex `a` is compiled with `Anchored::Yes` and searches `aba`\n///    starting at position `2`. This reports a match at `[2, 3]` since\n///    the match starts where the search started. Since there is no `^`,\n///    there is no requirement for the match to start at the beginning of\n///    the haystack.\n/// 3. The regex `a` is compiled with `Anchored::Yes` and searches `aba`\n///    starting at position `1`. Since `b` corresponds to position `1` and\n///    since the search is anchored, it finds no match. While the regex\n///    matches at other positions, configuring the search to be anchored\n///    requires that it only report a match that begins at the same offset\n///    as the beginning of the search.\n/// 4. The regex `a` is compiled with `Anchored::No` and searches `aba`\n///    starting at position `1`. Since the search is not anchored and\n///    the regex does not start with `^`, the search executes as if there\n///    is a `(?s:.)*?` prefix that permits it to match anywhere. Thus, it\n///    reports a match at `[2, 3]`.\n///\n/// Note that the [`Anchored::Pattern`] mode is like `Anchored::Yes`,\n/// except it only reports matches for a particular pattern.\n///\n/// # Example\n///\n/// This demonstrates the differences between an anchored search and\n/// a pattern that begins with `^` (as described in the above warning\n/// message).\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson::pikevm::PikeVM,\n///     Anchored, Match, Input,\n/// };\n///\n/// let haystack = \"aba\";\n///\n/// let re = PikeVM::new(r\"^a\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let input = Input::new(haystack).span(2..3).anchored(Anchored::No);\n/// re.search(&mut cache, &input, &mut caps);\n/// // No match is found because 2 is not the beginning of the haystack,\n/// // which is what ^ requires.\n/// assert_eq!(None, caps.get_match());\n///\n/// let re = PikeVM::new(r\"a\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let input = Input::new(haystack).span(2..3).anchored(Anchored::Yes);\n/// re.search(&mut cache, &input, &mut caps);\n/// // An anchored search can still match anywhere in the haystack, it just\n/// // must begin at the start of the search which is '2' in this case.\n/// assert_eq!(Some(Match::must(0, 2..3)), caps.get_match());\n///\n/// let re = PikeVM::new(r\"a\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let input = Input::new(haystack).span(1..3).anchored(Anchored::Yes);\n/// re.search(&mut cache, &input, &mut caps);\n/// // No match is found since we start searching at offset 1 which\n/// // corresponds to 'b'. Since there is no '(?s:.)*?' prefix, no match\n/// // is found.\n/// assert_eq!(None, caps.get_match());\n///\n/// let re = PikeVM::new(r\"a\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let input = Input::new(haystack).span(1..3).anchored(Anchored::No);\n/// re.search(&mut cache, &input, &mut caps);\n/// // Since anchored=no, an implicit '(?s:.)*?' prefix was added to the\n/// // pattern. Even though the search starts at 'b', the 'match anything'\n/// // prefix allows the search to match 'a'.\n/// let expected = Some(Match::must(0, 2..3));\n/// assert_eq!(expected, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn anchored(mut self, mode: Anchored) -> Input<'h> {",
    "    self.set_anchored(mode);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}