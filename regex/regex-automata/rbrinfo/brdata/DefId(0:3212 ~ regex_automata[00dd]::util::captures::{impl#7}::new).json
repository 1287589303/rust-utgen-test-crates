{
  "name": "regex_automata::util::captures::{impl#7}::new",
  "mod_info": {
    "name": "util::captures",
    "loc": "regex-automata/src/util/mod.rs:32:1:32:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/captures.rs:1569:5:1610:6",
  "doc": "/// Creates a new group info from a sequence of patterns, where each\n/// sequence of patterns yields a sequence of possible group names. The\n/// index of each pattern in the sequence corresponds to its `PatternID`,\n/// and the index of each group in each pattern's sequence corresponds to\n/// its corresponding group index.\n///\n/// While this constructor is very generic and therefore perhaps hard to\n/// chew on, an example of a valid concrete type that can be passed to\n/// this constructor is `Vec<Vec<Option<String>>>`. The outer `Vec`\n/// corresponds to the patterns, i.e., one `Vec<Option<String>>` per\n/// pattern. The inner `Vec` corresponds to the capturing groups for\n/// each pattern. The `Option<String>` corresponds to the name of the\n/// capturing group, if present.\n///\n/// It is legal to pass an empty iterator to this constructor. It will\n/// return an empty group info with zero slots. An empty group info is\n/// useful for cases where you have no patterns or for cases where slots\n/// aren't being used at all (e.g., for most DFAs in this crate).\n///\n/// # Errors\n///\n/// This constructor returns an error if the given capturing groups are\n/// invalid in some way. Those reasons include, but are not necessarily\n/// limited to:\n///\n/// * Too many patterns (i.e., `PatternID` would overflow).\n/// * Too many capturing groups (e.g., `u32` would overflow).\n/// * A pattern is given that has no capturing groups. (All patterns must\n/// have at least an implicit capturing group at index `0`.)\n/// * The capturing group at index `0` has a name. It must be unnamed.\n/// * There are duplicate capturing group names within the same pattern.\n/// (Multiple capturing groups with the same name may exist, but they\n/// must be in different patterns.)\n///\n/// An example below shows how to trigger some of the above error\n/// conditions.\n///\n/// # Example\n///\n/// This example shows how to build a new `GroupInfo` and query it for\n/// information.\n///\n/// ```\n/// use regex_automata::util::captures::GroupInfo;\n///\n/// let info = GroupInfo::new(vec![\n///     vec![None, Some(\"foo\")],\n///     vec![None],\n///     vec![None, None, None, Some(\"bar\"), None],\n///     vec![None, None, Some(\"foo\")],\n/// ])?;\n/// // The number of patterns being tracked.\n/// assert_eq!(4, info.pattern_len());\n/// // 2 slots per group\n/// assert_eq!(22, info.slot_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: empty `GroupInfo`\n///\n/// This example shows how to build a new `GroupInfo` and query it for\n/// information.\n///\n/// ```\n/// use regex_automata::util::captures::GroupInfo;\n///\n/// let info = GroupInfo::empty();\n/// // Everything is zero.\n/// assert_eq!(0, info.pattern_len());\n/// assert_eq!(0, info.slot_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: error conditions\n///\n/// This example shows how to provoke some of the ways in which building\n/// a `GroupInfo` can fail.\n///\n/// ```\n/// use regex_automata::util::captures::GroupInfo;\n///\n/// // Either the group info is empty, or all patterns must have at least\n/// // one capturing group.\n/// assert!(GroupInfo::new(vec![\n///     vec![None, Some(\"a\")], // ok\n///     vec![None], // ok\n///     vec![], // not ok\n/// ]).is_err());\n/// // Note that building an empty group info is OK.\n/// assert!(GroupInfo::new(Vec::<Vec<Option<String>>>::new()).is_ok());\n///\n/// // The first group in each pattern must correspond to an implicit\n/// // anonymous group. i.e., One that is not named. By convention, this\n/// // group corresponds to the overall match of a regex. Every other group\n/// // in a pattern is explicit and optional.\n/// assert!(GroupInfo::new(vec![vec![Some(\"foo\")]]).is_err());\n///\n/// // There must not be duplicate group names within the same pattern.\n/// assert!(GroupInfo::new(vec![\n///     vec![None, Some(\"foo\"), Some(\"foo\")],\n/// ]).is_err());\n/// // But duplicate names across distinct patterns is OK.\n/// assert!(GroupInfo::new(vec![\n///     vec![None, Some(\"foo\")],\n///     vec![None, Some(\"foo\")],\n/// ]).is_ok());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// There are other ways for building a `GroupInfo` to fail but are\n/// difficult to show. For example, if the number of patterns given would\n/// overflow `PatternID`.\n",
  "code": [
    "pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>",
    "where",
    "    P: IntoIterator<Item = G>,",
    "    G: IntoIterator<Item = Option<N>>,",
    "    N: AsRef<str>,",
    "{",
    "    let mut group_info = GroupInfoInner {",
    "        slot_ranges: vec![],",
    "        name_to_index: vec![],",
    "        index_to_name: vec![],",
    "        memory_extra: 0,",
    "    };",
    "    for (pattern_index, groups) in pattern_groups.into_iter().enumerate() {",
    "        // If we can't convert the pattern index to an ID, then the caller",
    "        // tried to build capture info for too many patterns.",
    "        let pid = PatternID::new(pattern_index)",
    "            .map_err(GroupInfoError::too_many_patterns)?;",
    "",
    "        let mut groups_iter = groups.into_iter().enumerate();",
    "        match groups_iter.next() {",
    "            None => return Err(GroupInfoError::missing_groups(pid)),",
    "            Some((_, Some(_))) => {",
    "                return Err(GroupInfoError::first_must_be_unnamed(pid))",
    "            }",
    "            Some((_, None)) => {}",
    "        }",
    "        group_info.add_first_group(pid);",
    "        // Now iterate over the rest, which correspond to all of the",
    "        // (conventionally) explicit capture groups in a regex pattern.",
    "        for (group_index, maybe_name) in groups_iter {",
    "            // Just like for patterns, if the group index can't be",
    "            // converted to a \"small\" index, then the caller has given too",
    "            // many groups for a particular pattern.",
    "            let group = SmallIndex::new(group_index).map_err(|_| {",
    "                GroupInfoError::too_many_groups(pid, group_index)",
    "            })?;",
    "            group_info.add_explicit_group(pid, group, maybe_name)?;",
    "        }",
    "    }",
    "    group_info.fixup_slot_ranges()?;",
    "    Ok(GroupInfo(Arc::new(group_info)))",
    "}"
  ],
  "size": {
    "chain": 11,
    "contra": 4,
    "min_set": 7
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Err/None",
          "line": 1584,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        21,
        23,
        24,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_)))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        }
      ],
      "ret": "Err(GroupInfoError::first_must_be_unnamed(pid))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        31,
        32,
        37,
        38,
        39,
        101,
        102,
        103,
        104,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "true",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "SmallIndex::new(group_index).map_err(|_| {\n                    GroupInfoError::too_many_groups(pid, group_index)\n                })?",
          "norm": null,
          "value": "Err/None",
          "line": 1602,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        31,
        33,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        50,
        51,
        52,
        54,
        56,
        57,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        103,
        104,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "true",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "SmallIndex::new(group_index).map_err(|_| {\n                    GroupInfoError::too_many_groups(pid, group_index)\n                })?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1602,
          "bound": null
        },
        {
          "cond": "group_info.add_explicit_group(pid, group, maybe_name)?",
          "norm": null,
          "value": "Err/None",
          "line": 1605,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        31,
        33,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        50,
        51,
        52,
        55,
        58,
        59,
        60,
        62,
        64,
        65,
        92,
        93,
        96,
        97,
        98,
        99,
        100,
        103,
        104,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "true",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "SmallIndex::new(group_index).map_err(|_| {\n                    GroupInfoError::too_many_groups(pid, group_index)\n                })?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1602,
          "bound": null
        },
        {
          "cond": "group_info.add_explicit_group(pid, group, maybe_name)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1605,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "false",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "false",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "group_info.fixup_slot_ranges()?",
          "norm": null,
          "value": "Err/None",
          "line": 1608,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        31,
        33,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        50,
        51,
        52,
        55,
        58,
        59,
        60,
        63,
        66,
        67,
        68,
        43,
        44,
        45,
        47,
        49,
        69,
        70,
        71,
        72,
        73,
        74,
        10,
        11,
        12,
        14,
        16,
        75,
        76,
        77,
        78,
        79,
        81,
        83,
        84,
        90,
        91,
        112,
        113,
        114
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "true",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "SmallIndex::new(group_index).map_err(|_| {\n                    GroupInfoError::too_many_groups(pid, group_index)\n                })?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1602,
          "bound": null
        },
        {
          "cond": "group_info.add_explicit_group(pid, group, maybe_name)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1605,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "false",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "false",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "group_info.fixup_slot_ranges()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1608,
          "bound": null
        }
      ],
      "ret": "Ok(GroupInfo(Arc::new(group_info)))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        31,
        33,
        40,
        41,
        42,
        43,
        44,
        45,
        48,
        50,
        51,
        52,
        55,
        58,
        59,
        60,
        63,
        66,
        67,
        68,
        43,
        44,
        45,
        47,
        49,
        69,
        70,
        71,
        72,
        73,
        74,
        10,
        11,
        12,
        14,
        16,
        75,
        76,
        77,
        78,
        79,
        82,
        85,
        86,
        87,
        88,
        89,
        114
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "false",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "false",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "group_info.fixup_slot_ranges()?",
          "norm": null,
          "value": "Err/None",
          "line": 1608,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        31,
        33,
        40,
        41,
        42,
        43,
        44,
        45,
        47,
        49,
        69,
        70,
        71,
        72,
        73,
        74,
        10,
        11,
        12,
        14,
        16,
        75,
        76,
        77,
        78,
        79,
        81,
        83,
        84,
        90,
        91,
        112,
        113,
        114
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches Some((_, Some(_))) or Some((_, None))",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "(group_index, maybe_name) in groups_iter",
          "norm": null,
          "value": "false",
          "line": 1598,
          "bound": null
        },
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "false",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "group_info.fixup_slot_ranges()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1608,
          "bound": null
        }
      ],
      "ret": "Ok(GroupInfo(Arc::new(group_info)))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        31,
        33,
        40,
        41,
        42,
        43,
        44,
        45,
        47,
        49,
        69,
        70,
        71,
        72,
        73,
        74,
        10,
        11,
        12,
        14,
        16,
        75,
        76,
        77,
        78,
        79,
        82,
        85,
        86,
        87,
        88,
        89,
        114
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "true",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1584,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        },
        {
          "cond": "groups_iter.next() matches None",
          "norm": null,
          "value": "true",
          "line": 1588,
          "bound": null
        }
      ],
      "ret": "Err(GroupInfoError::missing_groups(pid))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15,
        17,
        18,
        19,
        22,
        25,
        26,
        27,
        28,
        30,
        34,
        35,
        36,
        101,
        102,
        103,
        104,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "false",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "group_info.fixup_slot_ranges()?",
          "norm": null,
          "value": "Err/None",
          "line": 1608,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        14,
        16,
        75,
        76,
        77,
        78,
        79,
        81,
        83,
        84,
        90,
        91,
        112,
        113,
        114
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "(pattern_index, groups) in pattern_groups.into_iter().enumerate()",
          "norm": null,
          "value": "false",
          "line": 1581,
          "bound": null
        },
        {
          "cond": "group_info.fixup_slot_ranges()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1608,
          "bound": null
        }
      ],
      "ret": "Ok(GroupInfo(Arc::new(group_info)))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        14,
        16,
        75,
        76,
        77,
        78,
        79,
        82,
        85,
        86,
        87,
        88,
        89,
        114
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}