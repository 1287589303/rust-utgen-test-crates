{
  "name": "regex_automata::dfa::dense::{impl#7}::to_sparse",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:1758:5:1760:6",
  "doc": "/// Convert this dense DFA to a sparse DFA.\n///\n/// If a `StateID` is too small to represent all states in the sparse\n/// DFA, then this returns an error. In most cases, if a dense DFA is\n/// constructable with `StateID` then a sparse DFA will be as well.\n/// However, it is not guaranteed.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{dfa::{Automaton, dense}, HalfMatch, Input};\n///\n/// let dense = dense::DFA::new(\"foo[0-9]+\")?;\n/// let sparse = dense.to_sparse()?;\n///\n/// let expected = Some(HalfMatch::must(0, 8));\n/// assert_eq!(expected, sparse.try_search_fwd(&Input::new(\"foo12345\"))?);\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn to_sparse(&self) -> Result<sparse::DFA<Vec<u8>>, BuildError> {",
    "    sparse::DFA::from_dense(self)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}