{
  "name": "regex_automata::meta::regex::{impl#20}::nfa_size_limit",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:2752:5:2754:6",
  "doc": "/// Sets the size limit, in bytes, to enforce on the construction of every\n/// NFA build by the meta regex engine.\n///\n/// Setting it to `None` disables the limit. This is not recommended if\n/// you're compiling untrusted patterns.\n///\n/// Note that this limit is applied to _each_ NFA built, and if any of\n/// them exceed the limit, then construction will fail. This limit does\n/// _not_ correspond to the total memory used by all NFAs in the meta regex\n/// engine.\n///\n/// This defaults to some reasonable number that permits most reasonable\n/// patterns.\n///\n/// # Example\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::meta::Regex;\n///\n/// let result = Regex::builder()\n///     .configure(Regex::config().nfa_size_limit(Some(20 * (1<<10))))\n///     // Not even 20KB is enough to build a single large Unicode class!\n///     .build(r\"\\pL\");\n/// assert!(result.is_err());\n///\n/// // But notice that building such a regex with the exact same limit\n/// // can succeed depending on other aspects of the configuration. For\n/// // example, a single *forward* NFA will (at time of writing) fit into\n/// // the 20KB limit, but a *reverse* NFA of the same pattern will not.\n/// // So if one configures a meta regex such that a reverse NFA is never\n/// // needed and thus never built, then the 20KB limit will be enough for\n/// // a pattern like \\pL!\n/// let result = Regex::builder()\n///     .configure(Regex::config()\n///         .nfa_size_limit(Some(20 * (1<<10)))\n///         // The DFAs are the only thing that (currently) need a reverse\n///         // NFA. So if both are disabled, the meta regex engine will\n///         // skip building the reverse NFA. Note that this isn't an API\n///         // guarantee. A future semver compatible version may introduce\n///         // new use cases for a reverse NFA.\n///         .hybrid(false)\n///         .dfa(false)\n///     )\n///     // Not even 20KB is enough to build a single large Unicode class!\n///     .build(r\"\\pL\");\n/// assert!(result.is_ok());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn nfa_size_limit(self, limit: Option<usize>) -> Config {",
    "    Config { nfa_size_limit: Some(limit), ..self }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "Config { nfa_size_limit: Some(limit), ..self }",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}