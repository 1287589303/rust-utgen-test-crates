{
  "name": "regex_automata::meta::regex::{impl#20}::dfa_state_limit",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:2907:5:2909:6",
  "doc": "/// Sets a limit on the total number of NFA states, beyond which, a full\n/// DFA is not attempted to be compiled.\n///\n/// This limit works in concert with [`Config::dfa_size_limit`]. Namely,\n/// where as `Config::dfa_size_limit` is applied by attempting to construct\n/// a DFA, this limit is used to avoid the attempt in the first place. This\n/// is useful to avoid hefty initialization costs associated with building\n/// a DFA for cases where it is obvious the DFA will ultimately be too big.\n///\n/// By default, this is set to a very small number.\n///\n/// # Example\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::meta::Regex;\n///\n/// let result = Regex::builder()\n///     .configure(Regex::config()\n///         // Sometimes the default state limit rejects DFAs even\n///         // if they would fit in the size limit. Here, we disable\n///         // the check on the number of NFA states and just rely on\n///         // the size limit.\n///         .dfa_state_limit(None))\n///     .build(r\"(?-u)\\w{30}\");\n/// assert!(result.is_ok());\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn dfa_state_limit(self, limit: Option<usize>) -> Config {",
    "    Config { dfa_state_limit: Some(limit), ..self }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "Config { dfa_state_limit: Some(limit), ..self }",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}