{
  "name": "regex_automata::dfa::onepass::{impl#0}::starts_for_each_pattern",
  "mod_info": {
    "name": "dfa::onepass",
    "loc": "regex-automata/src/dfa/mod.rs:339:1:339:17"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/onepass.rs:154:5:157:6",
  "doc": "/// Whether to compile a separate start state for each pattern in the\n/// one-pass DFA.\n///\n/// When enabled, a separate **anchored** start state is added for each\n/// pattern in the DFA. When this start state is used, then the DFA will\n/// only search for matches for the pattern specified, even if there are\n/// other patterns in the DFA.\n///\n/// The main downside of this option is that it can potentially increase\n/// the size of the DFA and/or increase the time it takes to build the DFA.\n///\n/// You might want to enable this option when you want to both search for\n/// anchored matches of any pattern or to search for anchored matches of\n/// one particular pattern while using the same DFA. (Otherwise, you would\n/// need to compile a new DFA for each pattern.)\n///\n/// By default this is disabled.\n///\n/// # Example\n///\n/// This example shows how to build a multi-regex and then search for\n/// matches for a any of the patterns or matches for a specific pattern.\n///\n/// ```\n/// use regex_automata::{\n///     dfa::onepass::DFA, Anchored, Input, Match, PatternID,\n/// };\n///\n/// let re = DFA::builder()\n///     .configure(DFA::config().starts_for_each_pattern(true))\n///     .build_many(&[\"[a-z]+\", \"[0-9]+\"])?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let haystack = \"123abc\";\n/// let input = Input::new(haystack).anchored(Anchored::Yes);\n///\n/// // A normal multi-pattern search will show pattern 1 matches.\n/// re.try_search(&mut cache, &input, &mut caps)?;\n/// assert_eq!(Some(Match::must(1, 0..3)), caps.get_match());\n///\n/// // If we only want to report pattern 0 matches, then we'll get no\n/// // match here.\n/// let input = input.anchored(Anchored::Pattern(PatternID::must(0)));\n/// re.try_search(&mut cache, &input, &mut caps)?;\n/// assert_eq!(None, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {",
    "    self.starts_for_each_pattern = Some(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}