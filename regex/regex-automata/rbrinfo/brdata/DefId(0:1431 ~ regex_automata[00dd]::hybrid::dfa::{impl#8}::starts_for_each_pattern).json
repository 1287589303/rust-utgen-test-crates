{
  "name": "regex_automata::hybrid::dfa::{impl#8}::starts_for_each_pattern",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:3153:5:3156:6",
  "doc": "/// Whether to compile a separate start state for each pattern in the\n/// lazy DFA.\n///\n/// When enabled, a separate **anchored** start state is added for each\n/// pattern in the lazy DFA. When this start state is used, then the DFA\n/// will only search for matches for the pattern specified, even if there\n/// are other patterns in the DFA.\n///\n/// The main downside of this option is that it can potentially increase\n/// the size of the DFA and/or increase the time it takes to build the\n/// DFA at search time. However, since this is configuration for a lazy\n/// DFA, these states aren't actually built unless they're used. Enabling\n/// this isn't necessarily free, however, as it may result in higher cache\n/// usage.\n///\n/// There are a few reasons one might want to enable this (it's disabled\n/// by default):\n///\n/// 1. When looking for the start of an overlapping match (using a reverse\n/// DFA), doing it correctly requires starting the reverse search using the\n/// starting state of the pattern that matched in the forward direction.\n/// Indeed, when building a [`Regex`](crate::hybrid::regex::Regex), it\n/// will automatically enable this option when building the reverse DFA\n/// internally.\n/// 2. When you want to use a DFA with multiple patterns to both search\n/// for matches of any pattern or to search for anchored matches of one\n/// particular pattern while using the same DFA. (Otherwise, you would need\n/// to compile a new DFA for each pattern.)\n///\n/// By default this is disabled.\n///\n/// # Example\n///\n/// This example shows how to use this option to permit the same lazy DFA\n/// to run both general searches for any pattern and anchored searches for\n/// a specific pattern.\n///\n/// ```\n/// use regex_automata::{\n///     hybrid::dfa::DFA,\n///     Anchored, HalfMatch, Input, PatternID,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .configure(DFA::config().starts_for_each_pattern(true))\n///     .build_many(&[r\"[a-z0-9]{6}\", r\"[a-z][a-z0-9]{5}\"])?;\n/// let mut cache = dfa.create_cache();\n/// let haystack = \"bar foo123\";\n///\n/// // Here's a normal unanchored search that looks for any pattern.\n/// let expected = HalfMatch::must(0, 10);\n/// let input = Input::new(haystack);\n/// assert_eq!(Some(expected), dfa.try_search_fwd(&mut cache, &input)?);\n/// // We can also do a normal anchored search for any pattern. Since it's\n/// // an anchored search, we position the start of the search where we\n/// // know the match will begin.\n/// let expected = HalfMatch::must(0, 10);\n/// let input = Input::new(haystack).range(4..);\n/// assert_eq!(Some(expected), dfa.try_search_fwd(&mut cache, &input)?);\n/// // Since we compiled anchored start states for each pattern, we can\n/// // also look for matches of other patterns explicitly, even if a\n/// // different pattern would have normally matched.\n/// let expected = HalfMatch::must(1, 10);\n/// let input = Input::new(haystack)\n///     .range(4..)\n///     .anchored(Anchored::Pattern(PatternID::must(1)));\n/// assert_eq!(Some(expected), dfa.try_search_fwd(&mut cache, &input)?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {",
    "    self.starts_for_each_pattern = Some(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}