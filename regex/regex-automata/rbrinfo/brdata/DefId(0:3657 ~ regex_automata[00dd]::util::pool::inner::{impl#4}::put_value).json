{
  "name": "regex_automata::util::pool::inner::{impl#4}::put_value",
  "mod_info": {
    "name": "util::pool::inner",
    "loc": "regex-automata/src/util/pool.rs:235:1:793:2"
  },
  "visible": false,
  "loc": "regex-automata/src/util/pool.rs:604:9:626:10",
  "doc": "/// Puts a value back into the pool. Callers don't need to call this.\n/// Once the guard that's returned by 'get' is dropped, it is put back\n/// into the pool automatically.\n",
  "code": [
    "fn put_value(&self, value: Box<T>) {",
    "    let caller = THREAD_ID.with(|id| *id);",
    "    let stack_id = caller % self.stacks.len();",
    "    // As with trying to pop a value from this thread's stack, we",
    "    // merely attempt to get access to push this value back on the",
    "    // stack. If there's too much contention, we just give up and throw",
    "    // the value away.",
    "    //",
    "    // Interestingly, in ad hoc benchmarking, it is beneficial to",
    "    // attempt to push the value back more than once, unlike when",
    "    // popping the value. I don't have a good theory for why this is.",
    "    // I guess if we drop too many values then that winds up forcing",
    "    // the pop operation to create new fresh values and thus leads to",
    "    // less reuse. There's definitely a balancing act here.",
    "    for _ in 0..10 {",
    "        let mut stack = match self.stacks[stack_id].0.try_lock() {",
    "            Err(_) => continue,",
    "            Ok(stack) => stack,",
    "        };",
    "        stack.push(value);",
    "        return;",
    "    }",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 1,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "_ in 0..10",
          "norm": null,
          "value": "true",
          "line": 618,
          "bound": null
        },
        {
          "cond": "self.stacks[stack_id].0.try_lock() matches Err(_)",
          "norm": null,
          "value": "true",
          "line": 619,
          "bound": null
        },
        {
          "cond": "self.stacks[stack_id].0.try_lock() matches Err(_)",
          "norm": null,
          "value": "true",
          "line": 619,
          "bound": null
        },
        {
          "cond": "_ in 0..10",
          "norm": null,
          "value": "false",
          "line": 618,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        10,
        12,
        13,
        15,
        21,
        22,
        5,
        6,
        7,
        9,
        11,
        24
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "_ in 0..10",
          "norm": null,
          "value": "true",
          "line": 618,
          "bound": null
        },
        {
          "cond": "self.stacks[stack_id].0.try_lock() matches Ok(stack)",
          "norm": null,
          "value": "true",
          "line": 619,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        10,
        12,
        13,
        16,
        17,
        18,
        19,
        20,
        23,
        24
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "_ in 0..10",
          "norm": null,
          "value": "false",
          "line": 618,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        9,
        11,
        24
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}