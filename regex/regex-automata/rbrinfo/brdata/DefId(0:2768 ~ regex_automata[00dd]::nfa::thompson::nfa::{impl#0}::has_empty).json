{
  "name": "regex_automata::nfa::thompson::nfa::{impl#0}::has_empty",
  "mod_info": {
    "name": "nfa::thompson::nfa",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:66:1:66:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/nfa.rs:818:5:820:6",
  "doc": "/// Returns true if and only if this NFA can match the empty string.\n/// When it returns false, all possible matches are guaranteed to have a\n/// non-zero length.\n///\n/// This is useful as cheap way to know whether code needs to handle the\n/// case of a zero length match. This is particularly important when UTF-8\n/// modes are enabled, as when UTF-8 mode is enabled, empty matches that\n/// split a codepoint must never be reported. This extra handling can\n/// sometimes be costly, and since regexes matching an empty string are\n/// somewhat rare, it can be beneficial to treat such regexes specially.\n///\n/// # Example\n///\n/// This example shows a few different NFAs and whether they match the\n/// empty string or not. Notice the empty string isn't merely a matter\n/// of a string of length literally `0`, but rather, whether a match can\n/// occur between specific pairs of bytes.\n///\n/// ```\n/// use regex_automata::{nfa::thompson::NFA, util::syntax};\n///\n/// // The empty regex matches the empty string.\n/// let nfa = NFA::new(\"\")?;\n/// assert!(nfa.has_empty(), \"empty matches empty\");\n/// // The '+' repetition operator requires at least one match, and so\n/// // does not match the empty string.\n/// let nfa = NFA::new(\"a+\")?;\n/// assert!(!nfa.has_empty(), \"+ does not match empty\");\n/// // But the '*' repetition operator does.\n/// let nfa = NFA::new(\"a*\")?;\n/// assert!(nfa.has_empty(), \"* does match empty\");\n/// // And wrapping '+' in an operator that can match an empty string also\n/// // causes it to match the empty string too.\n/// let nfa = NFA::new(\"(a+)*\")?;\n/// assert!(nfa.has_empty(), \"+ inside of * matches empty\");\n///\n/// // If a regex is just made of a look-around assertion, even if the\n/// // assertion requires some kind of non-empty string around it (such as\n/// // \\b), then it is still treated as if it matches the empty string.\n/// // Namely, if a match occurs of just a look-around assertion, then the\n/// // match returned is empty.\n/// let nfa = NFA::compiler()\n///     .syntax(syntax::Config::new().utf8(false))\n///     .build(r\"^$\\A\\z\\b\\B(?-u:\\b\\B)\")?;\n/// assert!(nfa.has_empty(), \"assertions match empty\");\n/// // Even when an assertion is wrapped in a '+', it still matches the\n/// // empty string.\n/// let nfa = NFA::new(r\"\\b+\")?;\n/// assert!(nfa.has_empty(), \"+ of an assertion matches empty\");\n///\n/// // An alternation with even one branch that can match the empty string\n/// // is also said to match the empty string overall.\n/// let nfa = NFA::new(\"foo|(bar)?|quux\")?;\n/// assert!(nfa.has_empty(), \"alternations can match empty\");\n///\n/// // An NFA that matches nothing does not match the empty string.\n/// let nfa = NFA::new(\"[a&&b]\")?;\n/// assert!(!nfa.has_empty(), \"never matching means not matching empty\");\n/// // But if it's wrapped in something that doesn't require a match at\n/// // all, then it can match the empty string!\n/// let nfa = NFA::new(\"[a&&b]*\")?;\n/// assert!(nfa.has_empty(), \"* on never-match still matches empty\");\n/// // Since a '+' requires a match, using it on something that can never\n/// // match will itself produce a regex that can never match anything,\n/// // and thus does not match the empty string.\n/// let nfa = NFA::new(\"[a&&b]+\")?;\n/// assert!(!nfa.has_empty(), \"+ on never-match still matches nothing\");\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn has_empty(&self) -> bool {",
    "    self.0.has_empty",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self.0.has_empty",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}