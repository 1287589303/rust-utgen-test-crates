{
  "name": "regex_automata::nfa::thompson::backtrack::{impl#4}::try_search",
  "mod_info": {
    "name": "nfa::thompson::backtrack",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:57:1:57:19"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/backtrack.rs:1209:5:1219:6",
  "doc": "/// Executes a leftmost forward search and writes the spans of capturing\n/// groups that participated in a match into the provided [`Captures`]\n/// value. If no match was found, then [`Captures::is_match`] is guaranteed\n/// to return `false`.\n///\n/// This is like [`BoundedBacktracker::try_captures`], but it accepts a\n/// concrete `&Input` instead of an `Into<Input>`.\n///\n/// # Errors\n///\n/// This routine only errors if the search could not complete. For this\n/// backtracking regex engine, this only occurs when the haystack length\n/// exceeds [`BoundedBacktracker::max_haystack_len`].\n///\n/// When a search cannot complete, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example: specific pattern search\n///\n/// This example shows how to build a multi bounded backtracker that\n/// permits searching for specific patterns.\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson::backtrack::BoundedBacktracker,\n///     Anchored, Input, Match, PatternID,\n/// };\n///\n/// let re = BoundedBacktracker::new_many(&[\n///     \"[a-z0-9]{6}\",\n///     \"[a-z][a-z0-9]{5}\",\n/// ])?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let haystack = \"foo123\";\n///\n/// // Since we are using the default leftmost-first match and both\n/// // patterns match at the same starting position, only the first pattern\n/// // will be returned in this case when doing a search for any of the\n/// // patterns.\n/// let expected = Some(Match::must(0, 0..6));\n/// re.try_search(&mut cache, &Input::new(haystack), &mut caps)?;\n/// assert_eq!(expected, caps.get_match());\n///\n/// // But if we want to check whether some other pattern matches, then we\n/// // can provide its pattern ID.\n/// let expected = Some(Match::must(1, 0..6));\n/// let input = Input::new(haystack)\n///     .anchored(Anchored::Pattern(PatternID::must(1)));\n/// re.try_search(&mut cache, &input, &mut caps)?;\n/// assert_eq!(expected, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: specifying the bounds of a search\n///\n/// This example shows how providing the bounds of a search can produce\n/// different results than simply sub-slicing the haystack.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     nfa::thompson::backtrack::BoundedBacktracker,\n///     Match, Input,\n/// };\n///\n/// let re = BoundedBacktracker::new(r\"\\b[0-9]{3}\\b\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let haystack = \"foo123bar\";\n///\n/// // Since we sub-slice the haystack, the search doesn't know about\n/// // the larger context and assumes that `123` is surrounded by word\n/// // boundaries. And of course, the match position is reported relative\n/// // to the sub-slice as well, which means we get `0..3` instead of\n/// // `3..6`.\n/// let expected = Some(Match::must(0, 0..3));\n/// re.try_search(&mut cache, &Input::new(&haystack[3..6]), &mut caps)?;\n/// assert_eq!(expected, caps.get_match());\n///\n/// // But if we provide the bounds of the search within the context of the\n/// // entire haystack, then the search can take the surrounding context\n/// // into account. (And if we did find a match, it would be reported\n/// // as a valid offset into `haystack` instead of its sub-slice.)\n/// let expected = None;\n/// re.try_search(\n///     &mut cache, &Input::new(haystack).range(3..6), &mut caps,\n/// )?;\n/// assert_eq!(expected, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn try_search(",
    "    &self,",
    "    cache: &mut Cache,",
    "    input: &Input<'_>,",
    "    caps: &mut Captures,",
    ") -> Result<(), MatchError> {",
    "    caps.set_pattern(None);",
    "    let pid = self.try_search_slots(cache, input, caps.slots_mut())?;",
    "    caps.set_pattern(pid);",
    "    Ok(())",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.try_search_slots(cache, input, caps.slots_mut())?",
          "norm": null,
          "value": "Err/None",
          "line": 1216,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        12,
        13,
        14
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.try_search_slots(cache, input, caps.slots_mut())?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1216,
          "bound": null
        }
      ],
      "ret": "Ok(())",
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        14
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}