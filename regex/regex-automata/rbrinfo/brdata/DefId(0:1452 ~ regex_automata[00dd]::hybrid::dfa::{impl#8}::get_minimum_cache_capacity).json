{
  "name": "regex_automata::hybrid::dfa::{impl#8}::get_minimum_cache_capacity",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:3801:5:3809:6",
  "doc": "/// Returns the minimum lazy DFA cache capacity required for the given NFA.\n///\n/// The cache capacity required for a particular NFA may change without\n/// notice. Callers should not rely on it being stable.\n///\n/// This is useful for informational purposes, but can also be useful for\n/// other reasons. For example, if one wants to check the minimum cache\n/// capacity themselves or if one wants to set the capacity based on the\n/// minimum.\n///\n/// This may return an error if this configuration does not support all of\n/// the instructions used in the given NFA. For example, if the NFA has a\n/// Unicode word boundary but this configuration does not enable heuristic\n/// support for Unicode word boundaries.\n",
  "code": [
    "pub fn get_minimum_cache_capacity(",
    "    &self,",
    "    nfa: &thompson::NFA,",
    ") -> Result<usize, BuildError> {",
    "    let quitset = self.quit_set_from_nfa(nfa)?;",
    "    let classes = self.byte_classes_from_nfa(nfa, &quitset);",
    "    let starts = self.get_starts_for_each_pattern();",
    "    Ok(minimum_cache_capacity(nfa, &classes, starts))",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.quit_set_from_nfa(nfa)?",
          "norm": null,
          "value": "Err/None",
          "line": 3805,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        6,
        7,
        12,
        13,
        14
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.quit_set_from_nfa(nfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 3805,
          "bound": null
        }
      ],
      "ret": "Ok(minimum_cache_capacity(nfa, &classes, starts))",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        14
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}