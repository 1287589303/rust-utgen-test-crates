{
  "name": "regex_automata::hybrid::dfa::{impl#8}::prefilter",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:3074:5:3081:6",
  "doc": "/// Set a prefilter to be used whenever a start state is entered.\n///\n/// A [`Prefilter`] in this context is meant to accelerate searches by\n/// looking for literal prefixes that every match for the corresponding\n/// pattern (or patterns) must start with. Once a prefilter produces a\n/// match, the underlying search routine continues on to try and confirm\n/// the match.\n///\n/// Be warned that setting a prefilter does not guarantee that the search\n/// will be faster. While it's usually a good bet, if the prefilter\n/// produces a lot of false positive candidates (i.e., positions matched\n/// by the prefilter but not by the regex), then the overall result can\n/// be slower than if you had just executed the regex engine without any\n/// prefilters.\n///\n/// Note that unless [`Config::specialize_start_states`] has been\n/// explicitly set, then setting this will also enable (when `pre` is\n/// `Some`) or disable (when `pre` is `None`) start state specialization.\n/// This occurs because without start state specialization, a prefilter\n/// is likely to be less effective. And without a prefilter, start state\n/// specialization is usually pointless.\n///\n/// By default no prefilter is set.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{\n///     hybrid::dfa::DFA,\n///     util::prefilter::Prefilter,\n///     Input, HalfMatch, MatchKind,\n/// };\n///\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"foo\", \"bar\"]);\n/// let re = DFA::builder()\n///     .configure(DFA::config().prefilter(pre))\n///     .build(r\"(foo|bar)[a-z]+\")?;\n/// let mut cache = re.create_cache();\n/// let input = Input::new(\"foo1 barfox bar\");\n/// assert_eq!(\n///     Some(HalfMatch::must(0, 11)),\n///     re.try_search_fwd(&mut cache, &input)?,\n/// );\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// Be warned though that an incorrect prefilter can lead to incorrect\n/// results!\n///\n/// ```\n/// use regex_automata::{\n///     hybrid::dfa::DFA,\n///     util::prefilter::Prefilter,\n///     Input, HalfMatch, MatchKind,\n/// };\n///\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"foo\", \"car\"]);\n/// let re = DFA::builder()\n///     .configure(DFA::config().prefilter(pre))\n///     .build(r\"(foo|bar)[a-z]+\")?;\n/// let mut cache = re.create_cache();\n/// let input = Input::new(\"foo1 barfox bar\");\n/// assert_eq!(\n///     // No match reported even though there clearly is one!\n///     None,\n///     re.try_search_fwd(&mut cache, &input)?,\n/// );\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {",
    "    self.pre = Some(pre);",
    "    if self.specialize_start_states.is_none() {",
    "        self.specialize_start_states =",
    "            Some(self.get_prefilter().is_some());",
    "    }",
    "    self",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.specialize_start_states.is_none()",
          "norm": null,
          "value": "true",
          "line": 3076,
          "bound": null
        }
      ],
      "ret": "self",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        10,
        11,
        12
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.specialize_start_states.is_none()",
          "norm": null,
          "value": "false",
          "line": 3076,
          "bound": null
        }
      ],
      "ret": "self",
      "path": [
        0,
        1,
        2,
        4,
        5,
        9,
        10,
        11,
        12
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}