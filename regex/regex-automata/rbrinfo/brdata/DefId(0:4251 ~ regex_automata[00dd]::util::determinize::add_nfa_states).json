{
  "name": "regex_automata::util::determinize::add_nfa_states",
  "mod_info": {
    "name": "util::determinize",
    "loc": "regex-automata/src/util/mod.rs:49:1:49:28"
  },
  "visible": true,
  "loc": "regex-automata/src/util/determinize/mod.rs:448:1:579:2",
  "doc": "/// Add the NFA state IDs in the given `set` to the given DFA builder state.\n/// The order in which states are added corresponds to the order in which they\n/// were added to `set`.\n///\n/// The DFA builder state given should already have its complete set of match\n/// pattern IDs added (if any) and any look-behind assertions (StartLF, Start\n/// and whether this state is being generated for a transition over a word byte\n/// when applicable) that are true immediately prior to transitioning into this\n/// state (via `builder.look_have()`). The match pattern IDs should correspond\n/// to matches that occurred on the previous transition, since all matches are\n/// delayed by one byte. The things that should _not_ be set are look-ahead\n/// assertions (EndLF, End and whether the next byte is a word byte or not).\n/// The builder state should also not have anything in `look_need` set, as this\n/// routine will compute that for you.\n///\n/// The given NFA should be able to resolve all identifiers in `set` to a\n/// particular NFA state. Additionally, `set` must have capacity equivalent\n/// to `nfa.len()`.\n",
  "code": [
    "pub(crate) fn add_nfa_states(",
    "    nfa: &thompson::NFA,",
    "    set: &SparseSet,",
    "    builder: &mut StateBuilderNFA,",
    ") {",
    "    for nfa_id in set.iter() {",
    "        match *nfa.state(nfa_id) {",
    "            thompson::State::ByteRange { .. } => {",
    "                builder.add_nfa_state_id(nfa_id);",
    "            }",
    "            thompson::State::Sparse { .. } => {",
    "                builder.add_nfa_state_id(nfa_id);",
    "            }",
    "            thompson::State::Dense { .. } => {",
    "                builder.add_nfa_state_id(nfa_id);",
    "            }",
    "            thompson::State::Look { look, .. } => {",
    "                builder.add_nfa_state_id(nfa_id);",
    "                builder.set_look_need(|need| need.insert(look));",
    "            }",
    "            thompson::State::Union { .. }",
    "            | thompson::State::BinaryUnion { .. } => {",
    "                // Pure epsilon transitions don't need to be tracked as part",
    "                // of the DFA state. Tracking them is actually superfluous;",
    "                // they won't cause any harm other than making determinization",
    "                // slower.",
    "                //",
    "                // Why aren't these needed? Well, in an NFA, epsilon",
    "                // transitions are really just jumping points to other states.",
    "                // So once you hit an epsilon transition, the same set of",
    "                // resulting states always appears. Therefore, putting them in",
    "                // a DFA's set of ordered NFA states is strictly redundant.",
    "                //",
    "                // Look-around states are also epsilon transitions, but",
    "                // they are *conditional*. So their presence could be",
    "                // discriminatory, and thus, they are tracked above.",
    "                //",
    "                // But wait... why are epsilon states in our `set` in the first",
    "                // place? Why not just leave them out? They're in our `set`",
    "                // because it was generated by computing an epsilon closure,",
    "                // and we want to keep track of all states we visited to avoid",
    "                // re-visiting them. In exchange, we have to do this second",
    "                // iteration over our collected states to finalize our DFA",
    "                // state. In theory, we could avoid this second iteration if",
    "                // we maintained two sets during epsilon closure: the set of",
    "                // visited states (to avoid cycles) and the set of states that",
    "                // will actually be used to construct the next DFA state.",
    "                //",
    "                // Note that this optimization requires that we re-compute the",
    "                // epsilon closure to account for look-ahead in 'next' *only",
    "                // when necessary*. Namely, only when the set of look-around",
    "                // assertions changes and only when those changes are within",
    "                // the set of assertions that are needed in order to step",
    "                // through the closure correctly. Otherwise, if we re-do the",
    "                // epsilon closure needlessly, it could change based on the",
    "                // fact that we are omitting epsilon states here.",
    "                //",
    "                // -----",
    "                //",
    "                // Welp, scratch the above. It turns out that recording these",
    "                // is in fact necessary to seemingly handle one particularly",
    "                // annoying case: when a conditional epsilon transition is",
    "                // put inside of a repetition operator. One specific case I",
    "                // ran into was the regex `(?:\\b|%)+` on the haystack `z%`.",
    "                // The correct leftmost first matches are: [0, 0] and [1, 1].",
    "                // But the DFA was reporting [0, 0] and [1, 2]. To understand",
    "                // why this happens, consider the NFA for the aforementioned",
    "                // regex:",
    "                //",
    "                //     >000000: binary-union(4, 1)",
    "                //      000001: \\x00-\\xFF => 0",
    "                //      000002: WordAscii => 5",
    "                //      000003: % => 5",
    "                //     ^000004: binary-union(2, 3)",
    "                //      000005: binary-union(4, 6)",
    "                //      000006: MATCH(0)",
    "                //",
    "                // The problem here is that one of the DFA start states is",
    "                // going to consist of the NFA states [2, 3] by computing the",
    "                // epsilon closure of state 4. State 4 isn't included because",
    "                // we previously were not keeping track of union states. But",
    "                // only a subset of transitions out of this state will be able",
    "                // to follow WordAscii, and in those cases, the epsilon closure",
    "                // is redone. The only problem is that computing the epsilon",
    "                // closure from [2, 3] is different than computing the epsilon",
    "                // closure from [4]. In the former case, assuming the WordAscii",
    "                // assertion is satisfied, you get: [2, 3, 6]. In the latter",
    "                // case, you get: [2, 6, 3]. Notice that '6' is the match state",
    "                // and appears AFTER '3' in the former case. This leads to a",
    "                // preferential but incorrect match of '%' before returning",
    "                // a match. In the latter case, the match is preferred over",
    "                // continuing to accept the '%'.",
    "                //",
    "                // It almost feels like we might be able to fix the NFA states",
    "                // to avoid this, or to at least only keep track of union",
    "                // states where this actually matters, since in the vast",
    "                // majority of cases, this doesn't matter.",
    "                //",
    "                // Another alternative would be to define a new HIR property",
    "                // called \"assertion is repeated anywhere\" and compute it",
    "                // inductively over the entire pattern. If it happens anywhere,",
    "                // which is probably pretty rare, then we record union states.",
    "                // Otherwise we don't.",
    "                builder.add_nfa_state_id(nfa_id);",
    "            }",
    "            // Capture states we definitely do not need to record, since they",
    "            // are unconditional epsilon transitions with no branching.",
    "            thompson::State::Capture { .. } => {}",
    "            // It's not totally clear whether we need to record fail states or",
    "            // not, but we do so out of an abundance of caution. Since they are",
    "            // quite rare in practice, there isn't much cost to recording them.",
    "            thompson::State::Fail => {",
    "                builder.add_nfa_state_id(nfa_id);",
    "            }",
    "            thompson::State::Match { .. } => {",
    "                // Normally, the NFA match state doesn't actually need to",
    "                // be inside the DFA state. But since we delay matches by",
    "                // one byte, the matching DFA state corresponds to states",
    "                // that transition from the one we're building here. And",
    "                // the way we detect those cases is by looking for an NFA",
    "                // match state. See 'next' for how this is handled.",
    "                builder.add_nfa_state_id(nfa_id);",
    "            }",
    "        }",
    "    }",
    "    // If we know this state contains no look-around assertions, then",
    "    // there's no reason to track which look-around assertions were",
    "    // satisfied when this state was created.",
    "    if builder.look_need().is_empty() {",
    "        builder.set_look_have(|_| LookSet::empty());",
    "    }",
    "}"
  ],
  "size": {
    "chain": 20,
    "contra": 18,
    "min_set": 11
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Match { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        18,
        34,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Match { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        18,
        34,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Fail",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Fail",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        17,
        32,
        33,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Fail",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Fail",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        17,
        32,
        33,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        16,
        31,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Capture { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        16,
        31,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::BinaryUnion { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::BinaryUnion { .. } or thompson::State::Union { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        19,
        29,
        30,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::BinaryUnion { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::BinaryUnion { .. } or thompson::State::Union { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        19,
        29,
        30,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Union { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::BinaryUnion { .. } or thompson::State::Union { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        19,
        29,
        30,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Union { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::BinaryUnion { .. } or thompson::State::Union { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        19,
        29,
        30,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Look { look, .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Look { look, .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        15,
        26,
        27,
        28,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Look { look, .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Look { look, .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        15,
        26,
        27,
        28,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Dense { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Dense { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        14,
        24,
        25,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 14,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Dense { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Dense { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        14,
        24,
        25,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 15,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Sparse { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Sparse { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        13,
        22,
        23,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 16,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Sparse { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::Sparse { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        13,
        22,
        23,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 17,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::ByteRange { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::ByteRange { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        12,
        20,
        21,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 18,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "true",
          "line": 453,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::ByteRange { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "*nfa.state(nfa_id) matches thompson::State::ByteRange { .. }",
          "norm": null,
          "value": "true",
          "line": 454,
          "bound": null
        },
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        12,
        20,
        21,
        35,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 19,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "true",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        38,
        39,
        41
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 20,
      "conds": [
        {
          "cond": "nfa_id in set.iter()",
          "norm": null,
          "value": "false",
          "line": 453,
          "bound": null
        },
        {
          "cond": "builder.look_need().is_empty()",
          "norm": null,
          "value": "false",
          "line": 576,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        36,
        37,
        40,
        41
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}