{
  "name": "regex_automata::nfa::thompson::compiler::{impl#4}::c_unicode_class",
  "mod_info": {
    "name": "nfa::thompson::compiler",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:60:1:60:14"
  },
  "visible": false,
  "loc": "regex-automata/src/nfa/thompson/compiler.rs:1373:5:1492:6",
  "doc": "/// Compile the given Unicode character class.\n///\n/// This routine specifically tries to use various types of compression,\n/// since UTF-8 automata of large classes can get quite large. The specific\n/// type of compression used depends on forward vs reverse compilation, and\n/// whether NFA shrinking is enabled or not.\n///\n/// Aside from repetitions causing lots of repeat group, this is like the\n/// single most expensive part of regex compilation. Therefore, a large part\n/// of the expense of compilation may be reduce by disabling Unicode in the\n/// pattern.\n///\n/// This routine compiles an empty character class into a \"fail\" state.\n",
  "code": [
    "fn c_unicode_class(",
    "    &self,",
    "    cls: &hir::ClassUnicode,",
    ") -> Result<ThompsonRef, BuildError> {",
    "    // If all we have are ASCII ranges wrapped in a Unicode package, then",
    "    // there is zero reason to bring out the big guns. We can fit all ASCII",
    "    // ranges within a single sparse state.",
    "    if cls.is_ascii() {",
    "        let end = self.add_empty()?;",
    "        let mut trans = Vec::with_capacity(cls.ranges().len());",
    "        for r in cls.iter() {",
    "            // The unwraps below are OK because we've verified that this",
    "            // class only contains ASCII codepoints.",
    "            trans.push(Transition {",
    "                // FIXME(1.59): use the 'TryFrom<char> for u8' impl.",
    "                start: u8::try_from(u32::from(r.start())).unwrap(),",
    "                end: u8::try_from(u32::from(r.end())).unwrap(),",
    "                next: end,",
    "            });",
    "        }",
    "        Ok(ThompsonRef { start: self.add_sparse(trans)?, end })",
    "    } else if self.is_reverse() {",
    "        if !self.config.get_shrink() {",
    "            // When we don't want to spend the extra time shrinking, we",
    "            // compile the UTF-8 automaton in reverse using something like",
    "            // the \"naive\" approach, but will attempt to re-use common",
    "            // suffixes.",
    "            self.c_unicode_class_reverse_with_suffix(cls)",
    "        } else {",
    "            // When we want to shrink our NFA for reverse UTF-8 automata,",
    "            // we cannot feed UTF-8 sequences directly to the UTF-8",
    "            // compiler, since the UTF-8 compiler requires all sequences",
    "            // to be lexicographically sorted. Instead, we organize our",
    "            // sequences into a range trie, which can then output our",
    "            // sequences in the correct order. Unfortunately, building the",
    "            // range trie is fairly expensive (but not nearly as expensive",
    "            // as building a DFA). Hence the reason why the 'shrink' option",
    "            // exists, so that this path can be toggled off. For example,",
    "            // we might want to turn this off if we know we won't be",
    "            // compiling a DFA.",
    "            let mut trie = self.trie_state.borrow_mut();",
    "            trie.clear();",
    "",
    "            for rng in cls.iter() {",
    "                for mut seq in Utf8Sequences::new(rng.start(), rng.end()) {",
    "                    seq.reverse();",
    "                    trie.insert(seq.as_slice());",
    "                }",
    "            }",
    "            let mut builder = self.builder.borrow_mut();",
    "            let mut utf8_state = self.utf8_state.borrow_mut();",
    "            let mut utf8c =",
    "                Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;",
    "            trie.iter(|seq| {",
    "                utf8c.add(&seq)?;",
    "                Ok(())",
    "            })?;",
    "            utf8c.finish()",
    "        }",
    "    } else {",
    "        // In the forward direction, we always shrink our UTF-8 automata",
    "        // because we can stream it right into the UTF-8 compiler. There",
    "        // is almost no downside (in either memory or time) to using this",
    "        // approach.",
    "        let mut builder = self.builder.borrow_mut();",
    "        let mut utf8_state = self.utf8_state.borrow_mut();",
    "        let mut utf8c =",
    "            Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;",
    "        for rng in cls.iter() {",
    "            for seq in Utf8Sequences::new(rng.start(), rng.end()) {",
    "                utf8c.add(seq.as_slice())?;",
    "            }",
    "        }",
    "        utf8c.finish()",
    "    }",
    "",
    "    // For reference, the code below is the \"naive\" version of compiling a",
    "    // UTF-8 automaton. It is deliciously simple (and works for both the",
    "    // forward and reverse cases), but will unfortunately produce very",
    "    // large NFAs. When compiling a forward automaton, the size difference",
    "    // can sometimes be an order of magnitude. For example, the '\\w' regex",
    "    // will generate about ~3000 NFA states using the naive approach below,",
    "    // but only 283 states when using the approach above. This is because",
    "    // the approach above actually compiles a *minimal* (or near minimal,",
    "    // because of the bounded hashmap for reusing equivalent states) UTF-8",
    "    // automaton.",
    "    //",
    "    // The code below is kept as a reference point in order to make it",
    "    // easier to understand the higher level goal here. Although, it will",
    "    // almost certainly bit-rot, so keep that in mind. Also, if you try to",
    "    // use it, some of the tests in this module will fail because they look",
    "    // for terser byte code produce by the more optimized handling above.",
    "    // But the integration test suite should still pass.",
    "    //",
    "    // One good example of the substantial difference this can make is to",
    "    // compare and contrast performance of the Pike VM when the code below",
    "    // is active vs the code above. Here's an example to try:",
    "    //",
    "    //   regex-cli find match pikevm -b -p '(?m)^\\w{20}' non-ascii-file",
    "    //",
    "    // With Unicode classes generated below, this search takes about 45s on",
    "    // my machine. But with the compressed version above, the search takes",
    "    // only around 1.4s. The NFA is also 20% smaller. This is in part due",
    "    // to the compression, but also because of the utilization of 'sparse'",
    "    // NFA states. They lead to much less state shuffling during the NFA",
    "    // search.",
    "    /*",
    "    let it = cls",
    "        .iter()",
    "        .flat_map(|rng| Utf8Sequences::new(rng.start(), rng.end()))",
    "        .map(|seq| {",
    "            let it = seq",
    "                .as_slice()",
    "                .iter()",
    "                .map(|rng| self.c_range(rng.start, rng.end));",
    "            self.c_concat(it)",
    "        });",
    "    self.c_alt_iter(it)",
    "    */",
    "}"
  ],
  "size": {
    "chain": 20,
    "contra": 10,
    "min_set": 13
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "true",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.add_empty()?",
          "norm": null,
          "value": "Err/None",
          "line": 1381,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        173,
        174,
        175,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "true",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.add_empty()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1381,
          "bound": null
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1383,
          "bound": null
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1383,
          "bound": null
        },
        {
          "cond": "self.add_sparse(trans)?",
          "norm": null,
          "value": "Err/None",
          "line": 1393,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        16,
        17,
        18,
        20,
        22,
        32,
        33,
        35,
        37,
        38,
        170,
        171,
        172,
        175,
        176
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "true",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.add_empty()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1381,
          "bound": null
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1383,
          "bound": null
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1383,
          "bound": null
        },
        {
          "cond": "self.add_sparse(trans)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1393,
          "bound": null
        }
      ],
      "ret": "Ok(ThompsonRef { start: self.add_sparse(trans)?, end })",
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        16,
        17,
        18,
        20,
        22,
        32,
        33,
        36,
        39,
        40,
        151,
        176
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "true",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.add_empty()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1381,
          "bound": null
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1383,
          "bound": null
        },
        {
          "cond": "self.add_sparse(trans)?",
          "norm": null,
          "value": "Err/None",
          "line": 1393,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        32,
        33,
        35,
        37,
        38,
        170,
        171,
        172,
        175,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "true",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.add_empty()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1381,
          "bound": null
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1383,
          "bound": null
        },
        {
          "cond": "self.add_sparse(trans)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1393,
          "bound": null
        }
      ],
      "ret": "Ok(ThompsonRef { start: self.add_sparse(trans)?, end })",
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        20,
        22,
        32,
        33,
        36,
        39,
        40,
        151,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "true",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Err/None",
          "line": 1425,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        58,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        69,
        71,
        72,
        73,
        74,
        64,
        65,
        66,
        68,
        70,
        75,
        76,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        86,
        87,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        175,
        176
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "true",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1425,
          "bound": null
        },
        {
          "cond": "trie.iter(|seq| {\n                    utf8c.add(&seq)?;\n                    Ok(())\n                })?",
          "norm": null,
          "value": "Err/None",
          "line": 1426,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        58,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        69,
        71,
        72,
        73,
        74,
        64,
        65,
        66,
        68,
        70,
        75,
        76,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        85,
        88,
        89,
        90,
        91,
        93,
        95,
        96,
        161,
        162,
        165,
        166,
        167,
        168,
        169,
        175,
        176
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "true",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1425,
          "bound": null
        },
        {
          "cond": "trie.iter(|seq| {\n                    utf8c.add(&seq)?;\n                    Ok(())\n                })?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1426,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        58,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        69,
        71,
        72,
        73,
        74,
        64,
        65,
        66,
        68,
        70,
        75,
        76,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        85,
        88,
        89,
        90,
        91,
        94,
        97,
        98,
        99,
        100,
        101,
        102,
        150,
        151,
        176
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Err/None",
          "line": 1425,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        58,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        70,
        75,
        76,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        86,
        87,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        175,
        176
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1425,
          "bound": null
        },
        {
          "cond": "trie.iter(|seq| {\n                    utf8c.add(&seq)?;\n                    Ok(())\n                })?",
          "norm": null,
          "value": "Err/None",
          "line": 1426,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        58,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        70,
        75,
        76,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        85,
        88,
        89,
        90,
        91,
        93,
        95,
        96,
        161,
        162,
        165,
        166,
        167,
        168,
        169,
        175,
        176
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "mut seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1417,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1425,
          "bound": null
        },
        {
          "cond": "trie.iter(|seq| {\n                    utf8c.add(&seq)?;\n                    Ok(())\n                })?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1426,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        58,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        70,
        75,
        76,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        85,
        88,
        89,
        90,
        91,
        94,
        97,
        98,
        99,
        100,
        101,
        102,
        150,
        151,
        176
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Err/None",
          "line": 1425,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        86,
        87,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        175,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1425,
          "bound": null
        },
        {
          "cond": "trie.iter(|seq| {\n                    utf8c.add(&seq)?;\n                    Ok(())\n                })?",
          "norm": null,
          "value": "Err/None",
          "line": 1426,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        85,
        88,
        89,
        90,
        91,
        93,
        95,
        96,
        161,
        162,
        165,
        166,
        167,
        168,
        169,
        175,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 14,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "true",
          "line": 1395,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1416,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1425,
          "bound": null
        },
        {
          "cond": "trie.iter(|seq| {\n                    utf8c.add(&seq)?;\n                    Ok(())\n                })?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1426,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        57,
        59,
        77,
        78,
        79,
        80,
        81,
        82,
        85,
        88,
        89,
        90,
        91,
        94,
        97,
        98,
        99,
        100,
        101,
        102,
        150,
        151,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 15,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "true",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "self.config.get_shrink()",
          "norm": null,
          "value": "false",
          "line": 1395,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        43,
        44,
        46,
        47,
        102,
        150,
        151,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 16,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "false",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Err/None",
          "line": 1440,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        111,
        113,
        114,
        156,
        157,
        158,
        159,
        160,
        169,
        175,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 17,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "false",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1440,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1441,
          "bound": null
        },
        {
          "cond": "seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "true",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "utf8c.add(seq.as_slice())?",
          "norm": null,
          "value": "Err/None",
          "line": 1443,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        112,
        115,
        116,
        117,
        118,
        119,
        120,
        123,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        134,
        136,
        137,
        138,
        140,
        142,
        143,
        152,
        153,
        154,
        155,
        158,
        159,
        160,
        169,
        175,
        176
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 18,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "false",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1440,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1441,
          "bound": null
        },
        {
          "cond": "seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "true",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "utf8c.add(seq.as_slice())?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1443,
          "bound": null
        },
        {
          "cond": "seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1441,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        112,
        115,
        116,
        117,
        118,
        119,
        120,
        123,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        134,
        136,
        137,
        138,
        141,
        144,
        129,
        130,
        131,
        133,
        135,
        145,
        146,
        118,
        119,
        120,
        122,
        124,
        147,
        148,
        149,
        150,
        151,
        176
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 19,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "false",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1440,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 1441,
          "bound": null
        },
        {
          "cond": "seq in Utf8Sequences::new(rng.start(), rng.end())",
          "norm": null,
          "value": "false",
          "line": 1442,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1441,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        112,
        115,
        116,
        117,
        118,
        119,
        120,
        123,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        133,
        135,
        145,
        146,
        118,
        119,
        120,
        122,
        124,
        147,
        148,
        149,
        150,
        151,
        176
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 20,
      "conds": [
        {
          "cond": "cls.is_ascii()",
          "norm": null,
          "value": "false",
          "line": 1380,
          "bound": null
        },
        {
          "cond": "self.is_reverse()",
          "norm": null,
          "value": "false",
          "line": 1394,
          "bound": null
        },
        {
          "cond": "Utf8Compiler::new(&mut *builder, &mut *utf8_state)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1440,
          "bound": null
        },
        {
          "cond": "rng in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 1441,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        41,
        42,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        112,
        115,
        116,
        117,
        118,
        119,
        120,
        122,
        124,
        147,
        148,
        149,
        150,
        151,
        176
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}