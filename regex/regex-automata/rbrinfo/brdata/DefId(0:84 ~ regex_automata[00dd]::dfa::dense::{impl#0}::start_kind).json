{
  "name": "regex_automata::dfa::dense::{impl#0}::start_kind",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:397:5:400:6",
  "doc": "/// The type of starting state configuration to use for a DFA.\n///\n/// By default, the starting state configuration is [`StartKind::Both`].\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense::DFA, Automaton, StartKind},\n///     Anchored, HalfMatch, Input,\n/// };\n///\n/// let haystack = \"quux foo123\";\n/// let expected = HalfMatch::must(0, 11);\n///\n/// // By default, DFAs support both anchored and unanchored searches.\n/// let dfa = DFA::new(r\"[0-9]+\")?;\n/// let input = Input::new(haystack);\n/// assert_eq!(Some(expected), dfa.try_search_fwd(&input)?);\n///\n/// // But if we only need anchored searches, then we can build a DFA\n/// // that only supports anchored searches. This leads to a smaller DFA\n/// // (potentially significantly smaller in some cases), but a DFA that\n/// // will panic if you try to use it with an unanchored search.\n/// let dfa = DFA::builder()\n///     .configure(DFA::config().start_kind(StartKind::Anchored))\n///     .build(r\"[0-9]+\")?;\n/// let input = Input::new(haystack)\n///     .range(8..)\n///     .anchored(Anchored::Yes);\n/// assert_eq!(Some(expected), dfa.try_search_fwd(&input)?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn start_kind(mut self, kind: StartKind) -> Config {",
    "    self.start_kind = Some(kind);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}