{
  "name": "regex_automata::util::alphabet::{impl#2}::elements",
  "mod_info": {
    "name": "util::alphabet",
    "loc": "regex-automata/src/util/mod.rs:30:1:30:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/alphabet.rs:472:5:474:6",
  "doc": "/// Returns an iterator of the bytes in the given equivalence class.\n///\n/// This is useful when one needs to know the actual bytes that belong to\n/// an equivalence class. For example, conceptually speaking, accelerating\n/// a DFA state occurs when a state only has a few outgoing transitions.\n/// But in reality, what is required is that there are only a small\n/// number of distinct bytes that can lead to an outgoing transition. The\n/// difference is that any one transition can correspond to an equivalence\n/// class which may contains many bytes. Therefore, DFA state acceleration\n/// considers the actual elements in each equivalence class of each\n/// outgoing transition.\n///\n/// # Example\n///\n/// This shows an example of how to get all of the elements in an\n/// equivalence class.\n///\n/// ```\n/// use regex_automata::{nfa::thompson::NFA, util::alphabet::Unit};\n///\n/// let nfa = NFA::new(\"[a-z]+\")?;\n/// let classes = nfa.byte_classes();\n/// let elements: Vec<Unit> = classes.elements(Unit::u8(1)).collect();\n/// let expected: Vec<Unit> = (b'a'..=b'z').map(Unit::u8).collect();\n/// assert_eq!(expected, elements);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn elements(&self, class: Unit) -> ByteClassElements {",
    "    ByteClassElements { classes: self, class, byte: 0 }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "ByteClassElements { classes: self, class, byte: 0 }",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}