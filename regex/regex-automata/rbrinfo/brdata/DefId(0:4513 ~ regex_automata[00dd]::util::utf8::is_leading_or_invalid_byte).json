{
  "name": "regex_automata::util::utf8::is_leading_or_invalid_byte",
  "mod_info": {
    "name": "util::utf8",
    "loc": "regex-automata/src/util/mod.rs:57:1:57:21"
  },
  "visible": false,
  "loc": "regex-automata/src/util/utf8.rs:143:1:164:2",
  "doc": "/// Returns true if and only if the given byte is either a valid leading UTF-8\n/// byte, or is otherwise an invalid byte that can never appear anywhere in a\n/// valid UTF-8 sequence.\n",
  "code": [
    "fn is_leading_or_invalid_byte(b: u8) -> bool {",
    "    // In the ASCII case, the most significant bit is never set. The leading",
    "    // byte of a 2/3/4-byte sequence always has the top two most significant",
    "    // bits set. For bytes that can never appear anywhere in valid UTF-8, this",
    "    // also returns true, since every such byte has its two most significant",
    "    // bits set:",
    "    //",
    "    //     \\xC0 :: 11000000",
    "    //     \\xC1 :: 11000001",
    "    //     \\xF5 :: 11110101",
    "    //     \\xF6 :: 11110110",
    "    //     \\xF7 :: 11110111",
    "    //     \\xF8 :: 11111000",
    "    //     \\xF9 :: 11111001",
    "    //     \\xFA :: 11111010",
    "    //     \\xFB :: 11111011",
    "    //     \\xFC :: 11111100",
    "    //     \\xFD :: 11111101",
    "    //     \\xFE :: 11111110",
    "    //     \\xFF :: 11111111",
    "    (b & 0b1100_0000) != 0b1000_0000",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "(b & 0b1100_0000) != 0b1000_0000",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}