{
  "name": "regex_automata::dfa::automaton::Automaton::universal_start_state",
  "mod_info": {
    "name": "dfa::automaton",
    "loc": "regex-automata/src/dfa/mod.rs:348:1:348:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/automaton.rs:386:5:388:6",
  "doc": "/// If this DFA has a universal starting state for the given anchor mode\n/// and the DFA supports universal starting states, then this returns that\n/// state's identifier.\n///\n/// A DFA is said to have a universal starting state when the starting\n/// state is invariant with respect to the haystack. Usually, the starting\n/// state is chosen depending on the bytes immediately surrounding the\n/// starting position of a search. However, the starting state only differs\n/// when one or more of the patterns in the DFA have look-around assertions\n/// in its prefix.\n///\n/// Stated differently, if none of the patterns in a DFA have look-around\n/// assertions in their prefix, then the DFA has a universal starting state\n/// and _may_ be returned by this method.\n///\n/// It is always correct for implementations to return `None`, and indeed,\n/// this is what the default implementation does. When this returns `None`,\n/// callers must use either `start_state_forward` or `start_state_reverse`\n/// to get the starting state.\n///\n/// # Use case\n///\n/// There are a few reasons why one might want to use this:\n///\n/// * If you know your regex patterns have no look-around assertions in\n/// their prefix, then calling this routine is likely cheaper and perhaps\n/// more semantically meaningful.\n/// * When implementing prefilter support in a DFA regex implementation,\n/// it is necessary to re-compute the start state after a candidate\n/// is returned from the prefilter. However, this is only needed when\n/// there isn't a universal start state. When one exists, one can avoid\n/// re-computing the start state.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{Automaton, dense::DFA},\n///     Anchored,\n/// };\n///\n/// // There are no look-around assertions in the prefixes of any of the\n/// // patterns, so we get a universal start state.\n/// let dfa = DFA::new_many(&[\"[0-9]+\", \"[a-z]+$\", \"[A-Z]+\"])?;\n/// assert!(dfa.universal_start_state(Anchored::No).is_some());\n/// assert!(dfa.universal_start_state(Anchored::Yes).is_some());\n///\n/// // One of the patterns has a look-around assertion in its prefix,\n/// // so this means there is no longer a universal start state.\n/// let dfa = DFA::new_many(&[\"[0-9]+\", \"^[a-z]+$\", \"[A-Z]+\"])?;\n/// assert!(!dfa.universal_start_state(Anchored::No).is_some());\n/// assert!(!dfa.universal_start_state(Anchored::Yes).is_some());\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "fn universal_start_state(&self, _mode: Anchored) -> Option<StateID> {",
    "    None",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "None",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}