{
  "name": "regex_automata::meta::regex::{impl#3}::search_captures_with",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:1375:5:1384:6",
  "doc": "/// This is like [`Regex::search_captures`], but requires the caller to\n/// explicitly pass a [`Cache`].\n///\n/// # Why pass a `Cache` explicitly?\n///\n/// Passing a `Cache` explicitly will bypass the use of an internal memory\n/// pool used by `Regex` to get a `Cache` for a search. The use of this\n/// pool can be slower in some cases when a `Regex` is used from multiple\n/// threads simultaneously. Typically, performance only becomes an issue\n/// when there is heavy contention, which in turn usually only occurs\n/// when each thread's primary unit of work is a regex search on a small\n/// haystack.\n///\n/// # Example: specific pattern search\n///\n/// This example shows how to build a multi-pattern `Regex` that permits\n/// searching for specific patterns.\n///\n/// ```\n/// use regex_automata::{\n///     meta::Regex,\n///     Anchored, Match, PatternID, Input,\n/// };\n///\n/// let re = Regex::new_many(&[\"[a-z0-9]{6}\", \"[a-z][a-z0-9]{5}\"])?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let haystack = \"foo123\";\n///\n/// // Since we are using the default leftmost-first match and both\n/// // patterns match at the same starting position, only the first pattern\n/// // will be returned in this case when doing a search for any of the\n/// // patterns.\n/// let expected = Some(Match::must(0, 0..6));\n/// re.search_captures_with(&mut cache, &Input::new(haystack), &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// // But if we want to check whether some other pattern matches, then we\n/// // can provide its pattern ID.\n/// let expected = Some(Match::must(1, 0..6));\n/// let input = Input::new(haystack)\n///     .anchored(Anchored::Pattern(PatternID::must(1)));\n/// re.search_captures_with(&mut cache, &input, &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: specifying the bounds of a search\n///\n/// This example shows how providing the bounds of a search can produce\n/// different results than simply sub-slicing the haystack.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{meta::Regex, Match, Input};\n///\n/// let re = Regex::new(r\"\\b[0-9]{3}\\b\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n/// let haystack = \"foo123bar\";\n///\n/// // Since we sub-slice the haystack, the search doesn't know about\n/// // the larger context and assumes that `123` is surrounded by word\n/// // boundaries. And of course, the match position is reported relative\n/// // to the sub-slice as well, which means we get `0..3` instead of\n/// // `3..6`.\n/// let expected = Some(Match::must(0, 0..3));\n/// let input = Input::new(&haystack[3..6]);\n/// re.search_captures_with(&mut cache, &input, &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// // But if we provide the bounds of the search within the context of the\n/// // entire haystack, then the search can take the surrounding context\n/// // into account. (And if we did find a match, it would be reported\n/// // as a valid offset into `haystack` instead of its sub-slice.)\n/// let expected = None;\n/// let input = Input::new(haystack).range(3..6);\n/// re.search_captures_with(&mut cache, &input, &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn search_captures_with(",
    "    &self,",
    "    cache: &mut Cache,",
    "    input: &Input<'_>,",
    "    caps: &mut Captures,",
    ") {",
    "    caps.set_pattern(None);",
    "    let pid = self.search_slots_with(cache, input, caps.slots_mut());",
    "    caps.set_pattern(pid);",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}