{
  "name": "regex_automata::hybrid::dfa::{impl#8}::minimum_bytes_per_state",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:3709:5:3712:6",
  "doc": "/// Configure a lazy DFA search to quit only when its efficiency drops\n/// below the given minimum.\n///\n/// The efficiency of the cache is determined by the number of DFA states\n/// compiled per byte of haystack searched. For example, if the efficiency\n/// is 2, then it means the lazy DFA is creating a new DFA state after\n/// searching approximately 2 bytes in a haystack. Generally speaking, 2\n/// is quite bad and it's likely that even a slower regex engine like the\n/// [`PikeVM`](crate::nfa::thompson::pikevm::PikeVM) would be faster.\n///\n/// This has no effect if [`Config::minimum_cache_clear_count`] is not set.\n/// Namely, this option only kicks in when the cache has been cleared more\n/// than the minimum number. If no minimum is set, then the cache is simply\n/// cleared whenever it fills up and it is impossible for the lazy DFA to\n/// quit due to ineffective use of the cache.\n///\n/// In general, if one is setting [`Config::minimum_cache_clear_count`],\n/// then one should probably also set this knob as well. The reason is\n/// that the absolute number of times the cache is cleared is generally\n/// not a great predictor of efficiency. For example, if a new DFA state\n/// is created for every 1,000 bytes searched, then it wouldn't be hard\n/// for the cache to get cleared more than `N` times and then cause the\n/// lazy DFA to quit. But a new DFA state every 1,000 bytes is likely quite\n/// good from a performance perspective, and it's likely that the lazy\n/// DFA should continue searching, even if it requires clearing the cache\n/// occasionally.\n///\n/// Finally, note that if you're implementing your own lazy DFA search\n/// routine and also want this efficiency check to work correctly, then\n/// you'll need to use the following routines to record search progress:\n///\n/// * Call [`Cache::search_start`] at the beginning of every search.\n/// * Call [`Cache::search_update`] whenever [`DFA::next_state`] is\n/// called.\n/// * Call [`Cache::search_finish`] before completing a search. (It is\n/// not strictly necessary to call this when an error is returned, as\n/// `Cache::search_start` will automatically finish the previous search\n/// for you. But calling it where possible before returning helps improve\n/// the accuracy of how many bytes have actually been searched.)\n",
  "code": [
    "pub fn minimum_bytes_per_state(mut self, min: Option<usize>) -> Config {",
    "    self.minimum_bytes_per_state = Some(min);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}