{
  "name": "regex_automata::meta::regex::{impl#2}::search_captures",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:1063:5:1067:6",
  "doc": "/// Executes a leftmost forward search and writes the spans of capturing\n/// groups that participated in a match into the provided [`Captures`]\n/// value. If no match was found, then [`Captures::is_match`] is guaranteed\n/// to return `false`.\n///\n/// This is like [`Regex::captures`], but it accepts a concrete `&Input`\n/// instead of an `Into<Input>`.\n///\n/// # Example: specific pattern search\n///\n/// This example shows how to build a multi-pattern `Regex` that permits\n/// searching for specific patterns.\n///\n/// ```\n/// use regex_automata::{\n///     meta::Regex,\n///     Anchored, Match, PatternID, Input,\n/// };\n///\n/// let re = Regex::new_many(&[\"[a-z0-9]{6}\", \"[a-z][a-z0-9]{5}\"])?;\n/// let mut caps = re.create_captures();\n/// let haystack = \"foo123\";\n///\n/// // Since we are using the default leftmost-first match and both\n/// // patterns match at the same starting position, only the first pattern\n/// // will be returned in this case when doing a search for any of the\n/// // patterns.\n/// let expected = Some(Match::must(0, 0..6));\n/// re.search_captures(&Input::new(haystack), &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// // But if we want to check whether some other pattern matches, then we\n/// // can provide its pattern ID.\n/// let expected = Some(Match::must(1, 0..6));\n/// let input = Input::new(haystack)\n///     .anchored(Anchored::Pattern(PatternID::must(1)));\n/// re.search_captures(&input, &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: specifying the bounds of a search\n///\n/// This example shows how providing the bounds of a search can produce\n/// different results than simply sub-slicing the haystack.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{meta::Regex, Match, Input};\n///\n/// let re = Regex::new(r\"\\b[0-9]{3}\\b\")?;\n/// let mut caps = re.create_captures();\n/// let haystack = \"foo123bar\";\n///\n/// // Since we sub-slice the haystack, the search doesn't know about\n/// // the larger context and assumes that `123` is surrounded by word\n/// // boundaries. And of course, the match position is reported relative\n/// // to the sub-slice as well, which means we get `0..3` instead of\n/// // `3..6`.\n/// let expected = Some(Match::must(0, 0..3));\n/// let input = Input::new(&haystack[3..6]);\n/// re.search_captures(&input, &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// // But if we provide the bounds of the search within the context of the\n/// // entire haystack, then the search can take the surrounding context\n/// // into account. (And if we did find a match, it would be reported\n/// // as a valid offset into `haystack` instead of its sub-slice.)\n/// let expected = None;\n/// let input = Input::new(haystack).range(3..6);\n/// re.search_captures(&input, &mut caps);\n/// assert_eq!(expected, caps.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn search_captures(&self, input: &Input<'_>, caps: &mut Captures) {",
    "    caps.set_pattern(None);",
    "    let pid = self.search_slots(input, caps.slots_mut());",
    "    caps.set_pattern(pid);",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}