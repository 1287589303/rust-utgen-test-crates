{
  "name": "regex_automata::dfa::dense::{impl#8}::from_bytes",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:2336:5:2368:6",
  "doc": "/// Safely deserialize a DFA with a specific state identifier\n/// representation. Upon success, this returns both the deserialized DFA\n/// and the number of bytes read from the given slice. Namely, the contents\n/// of the slice beyond the DFA are not read.\n///\n/// Deserializing a DFA using this routine will never allocate heap memory.\n/// For safety purposes, the DFA's transition table will be verified such\n/// that every transition points to a valid state. If this verification is\n/// too costly, then a [`DFA::from_bytes_unchecked`] API is provided, which\n/// will always execute in constant time.\n///\n/// The bytes given must be generated by one of the serialization APIs\n/// of a `DFA` using a semver compatible release of this crate. Those\n/// include:\n///\n/// * [`DFA::to_bytes_little_endian`]\n/// * [`DFA::to_bytes_big_endian`]\n/// * [`DFA::to_bytes_native_endian`]\n/// * [`DFA::write_to_little_endian`]\n/// * [`DFA::write_to_big_endian`]\n/// * [`DFA::write_to_native_endian`]\n///\n/// The `to_bytes` methods allocate and return a `Vec<u8>` for you, along\n/// with handling alignment correctly. The `write_to` methods do not\n/// allocate and write to an existing slice (which may be on the stack).\n/// Since deserialization always uses the native endianness of the target\n/// platform, the serialization API you use should match the endianness of\n/// the target platform. (It's often a good idea to generate serialized\n/// DFAs for both forms of endianness and then load the correct one based\n/// on endianness.)\n///\n/// # Errors\n///\n/// Generally speaking, it's easier to state the conditions in which an\n/// error is _not_ returned. All of the following must be true:\n///\n/// * The bytes given must be produced by one of the serialization APIs\n///   on this DFA, as mentioned above.\n/// * The endianness of the target platform matches the endianness used to\n///   serialized the provided DFA.\n/// * The slice given must have the same alignment as `u32`.\n///\n/// If any of the above are not true, then an error will be returned.\n///\n/// # Panics\n///\n/// This routine will never panic for any input.\n///\n/// # Example\n///\n/// This example shows how to serialize a DFA to raw bytes, deserialize it\n/// and then use it for searching.\n///\n/// ```\n/// use regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch, Input};\n///\n/// let initial = DFA::new(\"foo[0-9]+\")?;\n/// let (bytes, _) = initial.to_bytes_native_endian();\n/// let dfa: DFA<&[u32]> = DFA::from_bytes(&bytes)?.0;\n///\n/// let expected = Some(HalfMatch::must(0, 8));\n/// assert_eq!(expected, dfa.try_search_fwd(&Input::new(\"foo12345\"))?);\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: dealing with alignment and padding\n///\n/// In the above example, we used the `to_bytes_native_endian` method to\n/// serialize a DFA, but we ignored part of its return value corresponding\n/// to padding added to the beginning of the serialized DFA. This is OK\n/// because deserialization will skip this initial padding. What matters\n/// is that the address immediately following the padding has an alignment\n/// that matches `u32`. That is, the following is an equivalent but\n/// alternative way to write the above example:\n///\n/// ```\n/// use regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch, Input};\n///\n/// let initial = DFA::new(\"foo[0-9]+\")?;\n/// // Serialization returns the number of leading padding bytes added to\n/// // the returned Vec<u8>.\n/// let (bytes, pad) = initial.to_bytes_native_endian();\n/// let dfa: DFA<&[u32]> = DFA::from_bytes(&bytes[pad..])?.0;\n///\n/// let expected = Some(HalfMatch::must(0, 8));\n/// assert_eq!(expected, dfa.try_search_fwd(&Input::new(\"foo12345\"))?);\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// This padding is necessary because Rust's standard library does\n/// not expose any safe and robust way of creating a `Vec<u8>` with a\n/// guaranteed alignment other than 1. Now, in practice, the underlying\n/// allocator is likely to provide a `Vec<u8>` that meets our alignment\n/// requirements, which means `pad` is zero in practice most of the time.\n///\n/// The purpose of exposing the padding like this is flexibility for the\n/// caller. For example, if one wants to embed a serialized DFA into a\n/// compiled program, then it's important to guarantee that it starts at a\n/// `u32`-aligned address. The simplest way to do this is to discard the\n/// padding bytes and set it up so that the serialized DFA itself begins at\n/// a properly aligned address. We can show this in two parts. The first\n/// part is serializing the DFA to a file:\n///\n/// ```no_run\n/// use regex_automata::dfa::dense::DFA;\n///\n/// let dfa = DFA::new(\"foo[0-9]+\")?;\n///\n/// let (bytes, pad) = dfa.to_bytes_big_endian();\n/// // Write the contents of the DFA *without* the initial padding.\n/// std::fs::write(\"foo.bigendian.dfa\", &bytes[pad..])?;\n///\n/// // Do it again, but this time for little endian.\n/// let (bytes, pad) = dfa.to_bytes_little_endian();\n/// std::fs::write(\"foo.littleendian.dfa\", &bytes[pad..])?;\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// And now the second part is embedding the DFA into the compiled program\n/// and deserializing it at runtime on first use. We use conditional\n/// compilation to choose the correct endianness.\n///\n/// ```no_run\n/// use regex_automata::{\n///     dfa::{Automaton, dense::DFA},\n///     util::{lazy::Lazy, wire::AlignAs},\n///     HalfMatch, Input,\n/// };\n///\n/// // This crate provides its own \"lazy\" type, kind of like\n/// // lazy_static! or once_cell::sync::Lazy. But it works in no-alloc\n/// // no-std environments and let's us write this using completely\n/// // safe code.\n/// static RE: Lazy<DFA<&'static [u32]>> = Lazy::new(|| {\n///     # const _: &str = stringify! {\n///     // This assignment is made possible (implicitly) via the\n///     // CoerceUnsized trait. This is what guarantees that our\n///     // bytes are stored in memory on a 4 byte boundary. You\n///     // *must* do this or something equivalent for correct\n///     // deserialization.\n///     static ALIGNED: &AlignAs<[u8], u32> = &AlignAs {\n///         _align: [],\n///         #[cfg(target_endian = \"big\")]\n///         bytes: *include_bytes!(\"foo.bigendian.dfa\"),\n///         #[cfg(target_endian = \"little\")]\n///         bytes: *include_bytes!(\"foo.littleendian.dfa\"),\n///     };\n///     # };\n///     # static ALIGNED: &AlignAs<[u8], u32> = &AlignAs {\n///     #     _align: [],\n///     #     bytes: [],\n///     # };\n///\n///     let (dfa, _) = DFA::from_bytes(&ALIGNED.bytes)\n///         .expect(\"serialized DFA should be valid\");\n///     dfa\n/// });\n///\n/// let expected = Ok(Some(HalfMatch::must(0, 8)));\n/// assert_eq!(expected, RE.try_search_fwd(&Input::new(\"foo12345\")));\n/// ```\n///\n/// An alternative to [`util::lazy::Lazy`](crate::util::lazy::Lazy)\n/// is [`lazy_static`](https://crates.io/crates/lazy_static) or\n/// [`once_cell`](https://crates.io/crates/once_cell), which provide\n/// stronger guarantees (like the initialization function only being\n/// executed once). And `once_cell` in particular provides a more\n/// expressive API. But a `Lazy` value from this crate is likely just fine\n/// in most circumstances.\n///\n/// Note that regardless of which initialization method you use, you\n/// will still need to use the [`AlignAs`](crate::util::wire::AlignAs)\n/// trick above to force correct alignment, but this is safe to do and\n/// `from_bytes` will return an error if you get it wrong.\n",
  "code": [
    "pub fn from_bytes(",
    "    slice: &'a [u8],",
    ") -> Result<(DFA<&'a [u32]>, usize), DeserializeError> {",
    "    // SAFETY: This is safe because we validate the transition table, start",
    "    // table, match states and accelerators below. If any validation fails,",
    "    // then we return an error.",
    "    let (dfa, nread) = unsafe { DFA::from_bytes_unchecked(slice)? };",
    "    dfa.tt.validate(&dfa)?;",
    "    dfa.st.validate(&dfa)?;",
    "    dfa.ms.validate(&dfa)?;",
    "    dfa.accels.validate()?;",
    "    // N.B. dfa.special doesn't have a way to do unchecked deserialization,",
    "    // so it has already been validated.",
    "    for state in dfa.states() {",
    "        // If the state is an accel state, then it must have a non-empty",
    "        // accelerator.",
    "        if dfa.is_accel_state(state.id()) {",
    "            let index = dfa.accelerator_index(state.id());",
    "            if index >= dfa.accels.len() {",
    "                return Err(DeserializeError::generic(",
    "                    \"found DFA state with invalid accelerator index\",",
    "                ));",
    "            }",
    "            let needles = dfa.accels.needles(index);",
    "            if !(1 <= needles.len() && needles.len() <= 3) {",
    "                return Err(DeserializeError::generic(",
    "                    \"accelerator needles has invalid length\",",
    "                ));",
    "            }",
    "        }",
    "    }",
    "    Ok((dfa, nread))",
    "}"
  ],
  "size": {
    "chain": 11,
    "contra": 2,
    "min_set": 11
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Err/None",
          "line": 2342,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        6,
        7,
        74,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Err/None",
          "line": 2343,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        14,
        16,
        17,
        72,
        73,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Err/None",
          "line": 2344,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        21,
        23,
        24,
        72,
        73,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Err/None",
          "line": 2345,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        28,
        30,
        31,
        72,
        73,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2345,
          "bound": null
        },
        {
          "cond": "dfa.accels.validate()?",
          "norm": null,
          "value": "Err/None",
          "line": 2346,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        35,
        37,
        38,
        72,
        73,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2345,
          "bound": null
        },
        {
          "cond": "dfa.accels.validate()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2346,
          "bound": null
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "true",
          "line": 2349,
          "bound": null
        },
        {
          "cond": "dfa.is_accel_state(state.id())",
          "norm": null,
          "value": "true",
          "line": 2352,
          "bound": null
        },
        {
          "cond": "index >= dfa.accels.len()",
          "norm": "dfa.accels.len() <= index",
          "value": "true",
          "line": 2354,
          "bound": "index == dfa.accels.len()"
        }
      ],
      "ret": "Err(DeserializeError::generic(\n                        \"found DFA state with invalid accelerator index\",\n                    ))",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        46,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        71,
        72,
        73,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2345,
          "bound": null
        },
        {
          "cond": "dfa.accels.validate()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2346,
          "bound": null
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "true",
          "line": 2349,
          "bound": null
        },
        {
          "cond": "dfa.is_accel_state(state.id())",
          "norm": null,
          "value": "true",
          "line": 2352,
          "bound": null
        },
        {
          "cond": "index >= dfa.accels.len()",
          "norm": "dfa.accels.len() <= index",
          "value": "false",
          "line": 2354,
          "bound": null
        },
        {
          "cond": "1 <= needles.len()",
          "norm": null,
          "value": "true",
          "line": 2360,
          "bound": "1 == needles.len()"
        },
        {
          "cond": "needles.len() <= 3",
          "norm": "3 >= needles.len()",
          "value": "true",
          "line": 2360,
          "bound": "needles.len() == 3"
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "false",
          "line": 2349,
          "bound": null
        }
      ],
      "ret": "Ok((dfa, nread))",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        46,
        48,
        49,
        50,
        51,
        52,
        53,
        56,
        57,
        58,
        59,
        60,
        61,
        67,
        41,
        42,
        43,
        45,
        47,
        68,
        69,
        70,
        75
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2345,
          "bound": null
        },
        {
          "cond": "dfa.accels.validate()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2346,
          "bound": null
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "true",
          "line": 2349,
          "bound": null
        },
        {
          "cond": "dfa.is_accel_state(state.id())",
          "norm": null,
          "value": "true",
          "line": 2352,
          "bound": null
        },
        {
          "cond": "index >= dfa.accels.len()",
          "norm": "dfa.accels.len() <= index",
          "value": "false",
          "line": 2354,
          "bound": null
        },
        {
          "cond": "1 <= needles.len()",
          "norm": null,
          "value": "true",
          "line": 2360,
          "bound": "1 == needles.len()"
        },
        {
          "cond": "needles.len() <= 3",
          "norm": "3 >= needles.len()",
          "value": "false",
          "line": 2360,
          "bound": null
        }
      ],
      "ret": "Err(DeserializeError::generic(\n                        \"accelerator needles has invalid length\",\n                    ))",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        46,
        48,
        49,
        50,
        51,
        52,
        53,
        56,
        57,
        58,
        59,
        60,
        62,
        64,
        65,
        71,
        72,
        73,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2345,
          "bound": null
        },
        {
          "cond": "dfa.accels.validate()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2346,
          "bound": null
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "true",
          "line": 2349,
          "bound": null
        },
        {
          "cond": "dfa.is_accel_state(state.id())",
          "norm": null,
          "value": "true",
          "line": 2352,
          "bound": null
        },
        {
          "cond": "index >= dfa.accels.len()",
          "norm": "dfa.accels.len() <= index",
          "value": "false",
          "line": 2354,
          "bound": null
        },
        {
          "cond": "1 <= needles.len()",
          "norm": null,
          "value": "false",
          "line": 2360,
          "bound": null
        }
      ],
      "ret": "Err(DeserializeError::generic(\n                        \"accelerator needles has invalid length\",\n                    ))",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        46,
        48,
        49,
        50,
        51,
        52,
        53,
        56,
        57,
        58,
        63,
        64,
        65,
        71,
        72,
        73,
        75
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2345,
          "bound": null
        },
        {
          "cond": "dfa.accels.validate()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2346,
          "bound": null
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "true",
          "line": 2349,
          "bound": null
        },
        {
          "cond": "dfa.is_accel_state(state.id())",
          "norm": null,
          "value": "false",
          "line": 2352,
          "bound": null
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "false",
          "line": 2349,
          "bound": null
        }
      ],
      "ret": "Ok((dfa, nread))",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        46,
        48,
        49,
        66,
        67,
        41,
        42,
        43,
        45,
        47,
        68,
        69,
        70,
        75
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "DFA::from_bytes_unchecked(slice)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2342,
          "bound": null
        },
        {
          "cond": "dfa.tt.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2343,
          "bound": null
        },
        {
          "cond": "dfa.st.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2344,
          "bound": null
        },
        {
          "cond": "dfa.ms.validate(&dfa)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2345,
          "bound": null
        },
        {
          "cond": "dfa.accels.validate()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2346,
          "bound": null
        },
        {
          "cond": "state in dfa.states()",
          "norm": null,
          "value": "false",
          "line": 2349,
          "bound": null
        }
      ],
      "ret": "Ok((dfa, nread))",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        15,
        18,
        19,
        22,
        25,
        26,
        29,
        32,
        33,
        36,
        39,
        40,
        41,
        42,
        43,
        45,
        47,
        68,
        69,
        70,
        75
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}