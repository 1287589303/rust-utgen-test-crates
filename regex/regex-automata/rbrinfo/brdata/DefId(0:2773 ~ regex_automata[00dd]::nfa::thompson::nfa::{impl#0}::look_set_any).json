{
  "name": "regex_automata::nfa::thompson::nfa::{impl#0}::look_set_any",
  "mod_info": {
    "name": "nfa::thompson::nfa",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:66:1:66:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/nfa.rs:1059:5:1061:6",
  "doc": "/// Returns the union of all look-around assertions used throughout this\n/// NFA. When the returned set is empty, it implies that the NFA has no\n/// look-around assertions and thus zero conditional epsilon transitions.\n///\n/// This is useful in some cases enabling optimizations. It is not\n/// unusual, for example, for optimizations to be of the form, \"for any\n/// regex with zero conditional epsilon transitions, do ...\" where \"...\"\n/// is some kind of optimization.\n///\n/// This isn't only helpful for optimizations either. Sometimes look-around\n/// assertions are difficult to support. For example, many of the DFAs in\n/// this crate don't support Unicode word boundaries or handle them using\n/// heuristics. Handling that correctly typically requires some kind of\n/// cheap check of whether the NFA has a Unicode word boundary in the first\n/// place.\n///\n/// # Example\n///\n/// This example shows how this routine varies based on the regex pattern:\n///\n/// ```\n/// use regex_automata::{nfa::thompson::NFA, util::look::Look};\n///\n/// // No look-around at all.\n/// let nfa = NFA::new(\"a\")?;\n/// assert!(nfa.look_set_any().is_empty());\n///\n/// // When multiple patterns are present, since this returns the union,\n/// // it will include look-around assertions that only appear in one\n/// // pattern.\n/// let nfa = NFA::new_many(&[\"a\", \"b\", \"a^b\", \"c\"])?;\n/// assert!(nfa.look_set_any().contains(Look::Start));\n///\n/// // Some groups of assertions have various shortcuts. For example:\n/// let nfa = NFA::new(r\"(?-u:\\b)\")?;\n/// assert!(nfa.look_set_any().contains_word());\n/// assert!(!nfa.look_set_any().contains_word_unicode());\n/// assert!(nfa.look_set_any().contains_word_ascii());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn look_set_any(&self) -> LookSet {",
    "    self.0.look_set_any",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self.0.look_set_any",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}