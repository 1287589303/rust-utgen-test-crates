{
  "name": "regex_automata::meta::regex::{impl#20}::hybrid_cache_capacity",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:2826:5:2828:6",
  "doc": "/// Set the cache capacity, in bytes, for the lazy DFA.\n///\n/// The cache capacity of the lazy DFA determines approximately how much\n/// heap memory it is allowed to use to store its state transitions. The\n/// state transitions are computed at search time, and if the cache fills\n/// up it, it is cleared. At this point, any previously generated state\n/// transitions are lost and are re-generated if they're needed again.\n///\n/// This sort of cache filling and clearing works quite well _so long as\n/// cache clearing happens infrequently_. If it happens too often, then the\n/// meta regex engine will stop using the lazy DFA and switch over to a\n/// different regex engine.\n///\n/// In cases where the cache is cleared too often, it may be possible to\n/// give the cache more space and reduce (or eliminate) how often it is\n/// cleared. Similarly, sometimes a regex is so big that the lazy DFA isn't\n/// used at all if its cache capacity isn't big enough.\n///\n/// The capacity set here is a _limit_ on how much memory is used. The\n/// actual memory used is only allocated as it's needed.\n///\n/// Determining the right value for this is a little tricky and will likely\n/// required some profiling. Enabling the `logging` feature and setting the\n/// log level to `trace` will also tell you how often the cache is being\n/// cleared.\n///\n/// # Example\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::meta::Regex;\n///\n/// let result = Regex::builder()\n///     .configure(Regex::config().hybrid_cache_capacity(20 * (1<<20)))\n///     .build(r\"\\pL{5}\");\n/// assert!(result.is_ok());\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn hybrid_cache_capacity(self, limit: usize) -> Config {",
    "    Config { hybrid_cache_capacity: Some(limit), ..self }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "Config { hybrid_cache_capacity: Some(limit), ..self }",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}