{
  "name": "regex_automata::nfa::thompson::backtrack::{impl#0}::prefilter",
  "mod_info": {
    "name": "nfa::thompson::backtrack",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:57:1:57:19"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/backtrack.rs:122:5:125:6",
  "doc": "/// Set a prefilter to be used whenever a start state is entered.\n///\n/// A [`Prefilter`] in this context is meant to accelerate searches by\n/// looking for literal prefixes that every match for the corresponding\n/// pattern (or patterns) must start with. Once a prefilter produces a\n/// match, the underlying search routine continues on to try and confirm\n/// the match.\n///\n/// Be warned that setting a prefilter does not guarantee that the search\n/// will be faster. While it's usually a good bet, if the prefilter\n/// produces a lot of false positive candidates (i.e., positions matched\n/// by the prefilter but not by the regex), then the overall result can\n/// be slower than if you had just executed the regex engine without any\n/// prefilters.\n///\n/// By default no prefilter is set.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson::backtrack::BoundedBacktracker,\n///     util::prefilter::Prefilter,\n///     Input, Match, MatchKind,\n/// };\n///\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"foo\", \"bar\"]);\n/// let re = BoundedBacktracker::builder()\n///     .configure(BoundedBacktracker::config().prefilter(pre))\n///     .build(r\"(foo|bar)[a-z]+\")?;\n/// let mut cache = re.create_cache();\n/// let input = Input::new(\"foo1 barfox bar\");\n/// assert_eq!(\n///     Some(Match::must(0, 5..11)),\n///     re.try_find(&mut cache, input)?,\n/// );\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// Be warned though that an incorrect prefilter can lead to incorrect\n/// results!\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson::backtrack::BoundedBacktracker,\n///     util::prefilter::Prefilter,\n///     Input, HalfMatch, MatchKind,\n/// };\n///\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"foo\", \"car\"]);\n/// let re = BoundedBacktracker::builder()\n///     .configure(BoundedBacktracker::config().prefilter(pre))\n///     .build(r\"(foo|bar)[a-z]+\")?;\n/// let mut cache = re.create_cache();\n/// let input = Input::new(\"foo1 barfox bar\");\n/// // No match reported even though there clearly is one!\n/// assert_eq!(None, re.try_find(&mut cache, input)?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {",
    "    self.pre = Some(pre);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}