{
  "name": "regex_automata::dfa::automaton::Automaton::try_search_rev",
  "mod_info": {
    "name": "dfa::automaton",
    "loc": "regex-automata/src/dfa/mod.rs:348:1:348:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/automaton.rs:1486:5:1500:6",
  "doc": "/// Executes a reverse search and returns the start of the position of the\n/// leftmost match that is found. If no match exists, then `None` is\n/// returned.\n///\n/// # Errors\n///\n/// This routine errors if the search could not complete. This can occur\n/// in a number of circumstances:\n///\n/// * The configuration of the DFA may permit it to \"quit\" the search.\n/// For example, setting quit bytes or enabling heuristic support for\n/// Unicode word boundaries. The default configuration does not enable any\n/// option that could result in the DFA quitting.\n/// * When the provided `Input` configuration is not supported. For\n/// example, by providing an unsupported anchor mode.\n///\n/// When a search returns an error, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example\n///\n/// This example shows how to use this method with a\n/// [`dense::DFA`](crate::dfa::dense::DFA). In particular, this\n/// routine is principally useful when used in conjunction with the\n/// [`nfa::thompson::Config::reverse`](crate::nfa::thompson::Config::reverse)\n/// configuration. In general, it's unlikely to be correct to use\n/// both `try_search_fwd` and `try_search_rev` with the same DFA since\n/// any particular DFA will only support searching in one direction with\n/// respect to the pattern.\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson,\n///     dfa::{Automaton, dense},\n///     HalfMatch, Input,\n/// };\n///\n/// let dfa = dense::Builder::new()\n///     .thompson(thompson::Config::new().reverse(true))\n///     .build(\"foo[0-9]+\")?;\n/// let expected = Some(HalfMatch::must(0, 0));\n/// assert_eq!(expected, dfa.try_search_rev(&Input::new(b\"foo12345\"))?);\n///\n/// // Even though a match is found after reading the last byte (`c`),\n/// // the leftmost first match semantics demand that we find the earliest\n/// // match that prefers earlier parts of the pattern over latter parts.\n/// let dfa = dense::Builder::new()\n///     .thompson(thompson::Config::new().reverse(true))\n///     .build(\"abc|c\")?;\n/// let expected = Some(HalfMatch::must(0, 0));\n/// assert_eq!(expected, dfa.try_search_rev(&Input::new(b\"abc\"))?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: UTF-8 mode\n///\n/// This examples demonstrates that UTF-8 mode applies to reverse\n/// DFAs. When UTF-8 mode is enabled in the underlying NFA, then all\n/// matches reported must correspond to valid UTF-8 spans. This includes\n/// prohibiting zero-width matches that split a codepoint.\n///\n/// UTF-8 mode is enabled by default. Notice below how the only zero-width\n/// matches reported are those at UTF-8 boundaries:\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense::DFA, Automaton},\n///     nfa::thompson,\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .thompson(thompson::Config::new().reverse(true))\n///     .build(r\"\")?;\n///\n/// // Run the reverse DFA to collect all matches.\n/// let mut input = Input::new(\"☃\");\n/// let mut matches = vec![];\n/// loop {\n///     match dfa.try_search_rev(&input)? {\n///         None => break,\n///         Some(hm) => {\n///             matches.push(hm);\n///             if hm.offset() == 0 || input.end() == 0 {\n///                 break;\n///             } else if hm.offset() < input.end() {\n///                 input.set_end(hm.offset());\n///             } else {\n///                 // This is only necessary to handle zero-width\n///                 // matches, which of course occur in this example.\n///                 // Without this, the search would never advance\n///                 // backwards beyond the initial match.\n///                 input.set_end(input.end() - 1);\n///             }\n///         }\n///     }\n/// }\n///\n/// // No matches split a codepoint.\n/// let expected = vec![\n///     HalfMatch::must(0, 3),\n///     HalfMatch::must(0, 0),\n/// ];\n/// assert_eq!(expected, matches);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// Now let's look at the same example, but with UTF-8 mode on the\n/// original NFA disabled (which results in disabling UTF-8 mode on the\n/// DFA):\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense::DFA, Automaton},\n///     nfa::thompson,\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .thompson(thompson::Config::new().reverse(true).utf8(false))\n///     .build(r\"\")?;\n///\n/// // Run the reverse DFA to collect all matches.\n/// let mut input = Input::new(\"☃\");\n/// let mut matches = vec![];\n/// loop {\n///     match dfa.try_search_rev(&input)? {\n///         None => break,\n///         Some(hm) => {\n///             matches.push(hm);\n///             if hm.offset() == 0 || input.end() == 0 {\n///                 break;\n///             } else if hm.offset() < input.end() {\n///                 input.set_end(hm.offset());\n///             } else {\n///                 // This is only necessary to handle zero-width\n///                 // matches, which of course occur in this example.\n///                 // Without this, the search would never advance\n///                 // backwards beyond the initial match.\n///                 input.set_end(input.end() - 1);\n///             }\n///         }\n///     }\n/// }\n///\n/// // No matches split a codepoint.\n/// let expected = vec![\n///     HalfMatch::must(0, 3),\n///     HalfMatch::must(0, 2),\n///     HalfMatch::must(0, 1),\n///     HalfMatch::must(0, 0),\n/// ];\n/// assert_eq!(expected, matches);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "fn try_search_rev(",
    "    &self,",
    "    input: &Input<'_>,",
    ") -> Result<Option<HalfMatch>, MatchError> {",
    "    let utf8empty = self.has_empty() && self.is_utf8();",
    "    let hm = match search::find_rev(self, input)? {",
    "        None => return Ok(None),",
    "        Some(hm) if !utf8empty => return Ok(Some(hm)),",
    "        Some(hm) => hm,",
    "    };",
    "    empty::skip_splits_rev(input, hm, hm.offset(), |input| {",
    "        let got = search::find_rev(self, input)?;",
    "        Ok(got.map(|hm| (hm, hm.offset())))",
    "    })",
    "}"
  ],
  "size": {
    "chain": 8,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "true",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm) or Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        9,
        11,
        12,
        24,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "true",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm) or Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "true",
          "line": 1493,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        10,
        15,
        18,
        19,
        16,
        21,
        22,
        23,
        27
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "true",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm) or Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "false",
          "line": 1493,
          "bound": null
        }
      ],
      "ret": "Ok(Some(hm))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        10,
        15,
        18,
        20,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "true",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        }
      ],
      "ret": "Ok(None)",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        10,
        14,
        17,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "false",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm) or Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        3,
        5,
        6,
        7,
        9,
        11,
        12,
        24,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "false",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm) or Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "true",
          "line": 1493,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        3,
        5,
        6,
        7,
        10,
        15,
        18,
        19,
        16,
        21,
        22,
        23,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "false",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm) or Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches Some(hm)",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "utf8empty",
          "norm": null,
          "value": "false",
          "line": 1493,
          "bound": null
        }
      ],
      "ret": "Ok(Some(hm))",
      "path": [
        0,
        1,
        3,
        5,
        6,
        7,
        10,
        15,
        18,
        20,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "self.has_empty()",
          "norm": null,
          "value": "false",
          "line": 1490,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        },
        {
          "cond": "search::find_rev(self, input)? matches None",
          "norm": null,
          "value": "true",
          "line": 1491,
          "bound": null
        }
      ],
      "ret": "Ok(None)",
      "path": [
        0,
        1,
        3,
        5,
        6,
        7,
        10,
        14,
        17,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    }
  ]
}