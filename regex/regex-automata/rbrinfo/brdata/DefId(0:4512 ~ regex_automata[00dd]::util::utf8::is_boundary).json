{
  "name": "regex_automata::util::utf8::is_boundary",
  "mod_info": {
    "name": "util::utf8",
    "loc": "regex-automata/src/util/mod.rs:57:1:57:21"
  },
  "visible": true,
  "loc": "regex-automata/src/util/utf8.rs:123:1:137:2",
  "doc": "/// Returns true if and only if the given offset in the given bytes falls on a\n/// valid UTF-8 encoded codepoint boundary.\n///\n/// If `bytes` is not valid UTF-8, then the behavior of this routine is\n/// unspecified.\n",
  "code": [
    "pub(crate) fn is_boundary(bytes: &[u8], i: usize) -> bool {",
    "    match bytes.get(i) {",
    "        // The position at the end of the bytes always represents an empty",
    "        // string, which is a valid boundary. But anything after that doesn't",
    "        // make much sense to call valid a boundary.",
    "        None => i == bytes.len(),",
    "        // Other than ASCII (where the most significant bit is never set),",
    "        // valid starting bytes always have their most significant two bits",
    "        // set, where as continuation bytes never have their second most",
    "        // significant bit set. Therefore, this only returns true when bytes[i]",
    "        // corresponds to a byte that begins a valid UTF-8 encoding of a",
    "        // Unicode scalar value.",
    "        Some(&b) => b <= 0b0111_1111 || b >= 0b1100_0000,",
    "    }",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 0,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "bytes.get(i) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 124,
          "bound": null
        },
        {
          "cond": "b <= 0b0111_1111",
          "norm": "0b0111_1111 >= b",
          "value": "true",
          "line": 135,
          "bound": "b == 0b0111_1111"
        }
      ],
      "ret": "b <= 0b0111_1111 || b >= 0b1100_0000",
      "path": [
        0,
        1,
        4,
        7,
        9,
        10
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "bytes.get(i) matches Some(&b)",
          "norm": null,
          "value": "true",
          "line": 124,
          "bound": null
        },
        {
          "cond": "b <= 0b0111_1111",
          "norm": "0b0111_1111 >= b",
          "value": "false",
          "line": 135,
          "bound": null
        }
      ],
      "ret": "b >= 0b1100_0000",
      "path": [
        0,
        1,
        4,
        8,
        9,
        10
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "bytes.get(i) matches None",
          "norm": null,
          "value": "true",
          "line": 124,
          "bound": null
        },
        {
          "cond": "bytes.get(i) matches None",
          "norm": null,
          "value": "true",
          "line": 124,
          "bound": null
        }
      ],
      "ret": "i == bytes.len()",
      "path": [
        0,
        1,
        3,
        5,
        6,
        10
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}