{
  "name": "regex_automata::util::captures::{impl#0}::interpolate_string",
  "mod_info": {
    "name": "util::captures",
    "loc": "regex-automata/src/util/mod.rs:32:1:32:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/captures.rs:716:5:724:6",
  "doc": "/// Interpolates the capture references in `replacement` with the\n/// corresponding substrings in `haystack` matched by each reference. The\n/// interpolated string is returned.\n///\n/// See the [`interpolate` module](interpolate) for documentation on the\n/// format of the replacement string.\n///\n/// # Example\n///\n/// This example shows how to use interpolation, and also shows how it\n/// can work with multi-pattern regexes.\n///\n/// ```\n/// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID};\n///\n/// let re = PikeVM::new_many(&[\n///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n///     r\"(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})\",\n/// ])?;\n/// let mut cache = re.create_cache();\n/// let mut caps = re.create_captures();\n///\n/// let replacement = \"year=$year, month=$month, day=$day\";\n///\n/// // This matches the first pattern.\n/// let hay = \"On 14-03-2010, I became a Tenneessee lamb.\";\n/// re.captures(&mut cache, hay, &mut caps);\n/// let result = caps.interpolate_string(hay, replacement);\n/// assert_eq!(\"year=2010, month=03, day=14\", result);\n///\n/// // And this matches the second pattern.\n/// let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";\n/// re.captures(&mut cache, hay, &mut caps);\n/// let result = caps.interpolate_string(hay, replacement);\n/// assert_eq!(\"year=2010, month=03, day=14\", result);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn interpolate_string(",
    "    &self,",
    "    haystack: &str,",
    "    replacement: &str,",
    ") -> String {",
    "    let mut dst = String::new();",
    "    self.interpolate_string_into(haystack, replacement, &mut dst);",
    "    dst",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "dst",
      "path": [
        0,
        1,
        2,
        3
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}