{
  "name": "regex_automata::util::captures::{impl#0}::iter",
  "mod_info": {
    "name": "util::captures",
    "loc": "regex-automata/src/util/mod.rs:32:1:32:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/captures.rs:576:5:583:6",
  "doc": "/// Returns an iterator of possible spans for every capturing group in the\n/// matching pattern.\n///\n/// If this `Captures` value does not correspond to a match, then the\n/// iterator returned yields no elements.\n///\n/// Note that the iterator returned yields elements of type `Option<Span>`.\n/// A span is present if and only if it corresponds to a capturing group\n/// that participated in a match.\n///\n/// # Example\n///\n/// This example shows how to collect all capturing groups:\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{nfa::thompson::pikevm::PikeVM, Span};\n///\n/// let re = PikeVM::new(\n///     // Matches first/last names, with an optional middle name.\n///     r\"^(?P<first>\\pL+)\\s+(?:(?P<middle>\\pL+)\\s+)?(?P<last>\\pL+)$\",\n/// )?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n///\n/// re.captures(&mut cache, \"Harry James Potter\", &mut caps);\n/// assert!(caps.is_match());\n/// let groups: Vec<Option<Span>> = caps.iter().collect();\n/// assert_eq!(groups, vec![\n///     Some(Span::from(0..18)),\n///     Some(Span::from(0..5)),\n///     Some(Span::from(6..11)),\n///     Some(Span::from(12..18)),\n/// ]);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// This example uses the same regex as the previous example, but with a\n/// haystack that omits the middle name. This results in a capturing group\n/// that is present in the elements yielded by the iterator but without a\n/// match:\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{nfa::thompson::pikevm::PikeVM, Span};\n///\n/// let re = PikeVM::new(\n///     // Matches first/last names, with an optional middle name.\n///     r\"^(?P<first>\\pL+)\\s+(?:(?P<middle>\\pL+)\\s+)?(?P<last>\\pL+)$\",\n/// )?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n///\n/// re.captures(&mut cache, \"Harry Potter\", &mut caps);\n/// assert!(caps.is_match());\n/// let groups: Vec<Option<Span>> = caps.iter().collect();\n/// assert_eq!(groups, vec![\n///     Some(Span::from(0..12)),\n///     Some(Span::from(0..5)),\n///     None,\n///     Some(Span::from(6..12)),\n/// ]);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn iter(&self) -> CapturesPatternIter<'_> {",
    "    let names = self",
    "        .pattern()",
    "        .map_or(GroupInfoPatternNames::empty().enumerate(), |pid| {",
    "            self.group_info().pattern_names(pid).enumerate()",
    "        });",
    "    CapturesPatternIter { caps: self, names }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "CapturesPatternIter { caps: self, names }",
      "path": [
        0,
        1,
        2,
        3,
        4
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}