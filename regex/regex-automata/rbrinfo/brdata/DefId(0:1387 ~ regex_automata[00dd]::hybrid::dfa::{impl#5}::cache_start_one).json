{
  "name": "regex_automata::hybrid::dfa::{impl#5}::cache_start_one",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": false,
  "loc": "regex-automata/src/hybrid/dfa.rs:2199:5:2232:6",
  "doc": "/// Compute and cache the starting state for the given NFA state ID and the\n/// starting configuration. The NFA state ID might be one of the following:\n///\n/// 1) An unanchored start state to match any pattern.\n/// 2) An anchored start state to match any pattern.\n/// 3) An anchored start state for a particular pattern.\n///\n/// This will never return an unknown lazy state ID.\n///\n/// If caching this state would otherwise result in a cache that has been\n/// cleared too many times, then an error is returned.\n",
  "code": [
    "fn cache_start_one(",
    "    &mut self,",
    "    nfa_start_id: NFAStateID,",
    "    start: Start,",
    ") -> Result<LazyStateID, CacheError> {",
    "    let mut builder_matches = self.get_state_builder().into_matches();",
    "    determinize::set_lookbehind_from_start(",
    "        self.dfa.get_nfa(),",
    "        &start,",
    "        &mut builder_matches,",
    "    );",
    "    self.cache.sparses.set1.clear();",
    "    determinize::epsilon_closure(",
    "        self.dfa.get_nfa(),",
    "        nfa_start_id,",
    "        builder_matches.look_have(),",
    "        &mut self.cache.stack,",
    "        &mut self.cache.sparses.set1,",
    "    );",
    "    let mut builder = builder_matches.into_nfa();",
    "    determinize::add_nfa_states(",
    "        &self.dfa.get_nfa(),",
    "        &self.cache.sparses.set1,",
    "        &mut builder,",
    "    );",
    "    let tag_starts = self.dfa.get_config().get_specialize_start_states();",
    "    self.add_builder_state(builder, |id| {",
    "        if tag_starts {",
    "            id.to_start()",
    "        } else {",
    "            id",
    "        }",
    "    })",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}