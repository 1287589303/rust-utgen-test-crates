{
  "name": "regex_automata::util::captures::{impl#1}::clear",
  "mod_info": {
    "name": "util::captures",
    "loc": "regex-automata/src/util/mod.rs:32:1:32:18"
  },
  "visible": true,
  "loc": "regex-automata/src/util/captures.rs:1071:5:1076:6",
  "doc": "/// Clear this `Captures` value.\n///\n/// After clearing, all slots inside this `Captures` value will be set to\n/// `None`. Similarly, any pattern ID that it was previously associated\n/// with (for a match) is erased.\n///\n/// It is not usually necessary to call this routine. Namely, a `Captures`\n/// value only provides high level access to the capturing groups of the\n/// pattern that matched, and only low level access to individual slots.\n/// Thus, even if slots corresponding to groups that aren't associated\n/// with the matching pattern are set, then it won't impact the higher\n/// level APIs. Namely, higher level APIs like [`Captures::get_group`] will\n/// return `None` if no pattern ID is present, even if there are spans set\n/// in the underlying slots.\n///\n/// Thus, to \"clear\" a `Captures` value of a match, it is usually only\n/// necessary to call [`Captures::set_pattern`] with `None`.\n///\n/// # Example\n///\n/// This example shows what happens when a `Captures` value is cleared.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::nfa::thompson::pikevm::PikeVM;\n///\n/// let re = PikeVM::new(r\"^(?P<first>\\pL+)\\s+(?P<last>\\pL+)$\")?;\n/// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());\n///\n/// re.captures(&mut cache, \"Bruce Springsteen\", &mut caps);\n/// assert!(caps.is_match());\n/// let slots: Vec<Option<usize>> =\n///     caps.slots().iter().map(|s| s.map(|x| x.get())).collect();\n/// // Note that the following ordering is considered an API guarantee.\n/// assert_eq!(slots, vec![\n///     Some(0),\n///     Some(17),\n///     Some(0),\n///     Some(5),\n///     Some(6),\n///     Some(17),\n/// ]);\n///\n/// // Now clear the slots. Everything is gone and it is no longer a match.\n/// caps.clear();\n/// assert!(!caps.is_match());\n/// let slots: Vec<Option<usize>> =\n///     caps.slots().iter().map(|s| s.map(|x| x.get())).collect();\n/// assert_eq!(slots, vec![\n///     None,\n///     None,\n///     None,\n///     None,\n///     None,\n///     None,\n/// ]);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn clear(&mut self) {",
    "    self.pid = None;",
    "    for slot in self.slots.iter_mut() {",
    "        *slot = None;",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 1,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "slot in self.slots.iter_mut()",
          "norm": null,
          "value": "true",
          "line": 1073,
          "bound": null
        },
        {
          "cond": "slot in self.slots.iter_mut()",
          "norm": null,
          "value": "false",
          "line": 1073,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        9,
        4,
        5,
        6,
        8,
        10
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "slot in self.slots.iter_mut()",
          "norm": null,
          "value": "false",
          "line": 1073,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        8,
        10
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}