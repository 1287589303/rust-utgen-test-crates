{
  "name": "regex_automata::util::utf8::is_word_byte",
  "mod_info": {
    "name": "util::utf8",
    "loc": "regex-automata/src/util/mod.rs:57:1:57:21"
  },
  "visible": true,
  "loc": "regex-automata/src/util/utf8.rs:16:1:41:2",
  "doc": "/// Returns true if and only if the given byte is considered a word character.\n/// This only applies to ASCII.\n///\n/// This was copied from regex-syntax so that we can use it to determine the\n/// starting DFA state while searching without depending on regex-syntax. The\n/// definition is never going to change, so there's no maintenance/bit-rot\n/// hazard here.\n",
  "code": [
    "pub(crate) fn is_word_byte(b: u8) -> bool {",
    "    const fn mkwordset() -> [bool; 256] {",
    "        // FIXME: Use as_usize() once const functions in traits are stable.",
    "        let mut set = [false; 256];",
    "        set[b'_' as usize] = true;",
    "",
    "        let mut byte = b'0';",
    "        while byte <= b'9' {",
    "            set[byte as usize] = true;",
    "            byte += 1;",
    "        }",
    "        byte = b'A';",
    "        while byte <= b'Z' {",
    "            set[byte as usize] = true;",
    "            byte += 1;",
    "        }",
    "        byte = b'a';",
    "        while byte <= b'z' {",
    "            set[byte as usize] = true;",
    "            byte += 1;",
    "        }",
    "        set",
    "    }",
    "    const WORD: [bool; 256] = mkwordset();",
    "    WORD[b as usize]",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "WORD[b as usize]",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}