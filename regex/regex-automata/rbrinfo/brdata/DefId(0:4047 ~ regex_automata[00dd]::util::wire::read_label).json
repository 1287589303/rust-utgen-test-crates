{
  "name": "regex_automata::util::wire::read_label",
  "mod_info": {
    "name": "util::wire",
    "loc": "regex-automata/src/util/mod.rs:46:1:46:14"
  },
  "visible": true,
  "loc": "regex-automata/src/util/wire.rs:421:1:449:2",
  "doc": "/// Reads a NUL terminated label starting at the beginning of the given slice.\n///\n/// If a NUL terminated label could not be found, then an error is returned.\n/// Similarly, if a label is found but doesn't match the expected label, then\n/// an error is returned.\n///\n/// Upon success, the total number of bytes read (including padding bytes) is\n/// returned.\n",
  "code": [
    "pub(crate) fn read_label(",
    "    slice: &[u8],",
    "    expected_label: &'static str,",
    ") -> Result<usize, DeserializeError> {",
    "    // Set an upper bound on how many bytes we scan for a NUL. Since no label",
    "    // in this crate is longer than 256 bytes, if we can't find one within that",
    "    // range, then we have corrupted data.",
    "    let first_nul =",
    "        slice[..cmp::min(slice.len(), 256)].iter().position(|&b| b == 0);",
    "    let first_nul = match first_nul {",
    "        Some(first_nul) => first_nul,",
    "        None => {",
    "            return Err(DeserializeError::generic(",
    "                \"could not find NUL terminated label \\",
    "                 at start of serialized object\",",
    "            ));",
    "        }",
    "    };",
    "    let len = first_nul + padding_len(first_nul);",
    "    if slice.len() < len {",
    "        return Err(DeserializeError::generic(",
    "            \"could not find properly sized label at start of serialized object\"",
    "        ));",
    "    }",
    "    if expected_label.as_bytes() != &slice[..first_nul] {",
    "        return Err(DeserializeError::label_mismatch(expected_label));",
    "    }",
    "    Ok(len)",
    "}"
  ],
  "size": {
    "chain": 4,
    "contra": 0,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "first_nul matches Some(first_nul)",
          "norm": null,
          "value": "true",
          "line": 430,
          "bound": null
        },
        {
          "cond": "first_nul matches Some(first_nul)",
          "norm": null,
          "value": "true",
          "line": 430,
          "bound": null
        },
        {
          "cond": "slice.len() < len",
          "norm": "len > slice.len()",
          "value": "true",
          "line": 440,
          "bound": null
        }
      ],
      "ret": "Err(DeserializeError::generic(\n            \"could not find properly sized label at start of serialized object\"\n        ))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        11,
        12,
        13,
        14,
        15,
        23,
        24,
        25
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "first_nul matches Some(first_nul)",
          "norm": null,
          "value": "true",
          "line": 430,
          "bound": null
        },
        {
          "cond": "first_nul matches Some(first_nul)",
          "norm": null,
          "value": "true",
          "line": 430,
          "bound": null
        },
        {
          "cond": "slice.len() < len",
          "norm": "len > slice.len()",
          "value": "false",
          "line": 440,
          "bound": "slice.len() == len"
        },
        {
          "cond": "expected_label.as_bytes() != &slice[..first_nul]",
          "norm": "&slice[..first_nul] != expected_label.as_bytes()",
          "value": "true",
          "line": 445,
          "bound": null
        }
      ],
      "ret": "Err(DeserializeError::label_mismatch(expected_label))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        11,
        12,
        13,
        16,
        17,
        18,
        19,
        20,
        21,
        23,
        24,
        25
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "first_nul matches Some(first_nul)",
          "norm": null,
          "value": "true",
          "line": 430,
          "bound": null
        },
        {
          "cond": "first_nul matches Some(first_nul)",
          "norm": null,
          "value": "true",
          "line": 430,
          "bound": null
        },
        {
          "cond": "slice.len() < len",
          "norm": "len > slice.len()",
          "value": "false",
          "line": 440,
          "bound": "slice.len() == len"
        },
        {
          "cond": "expected_label.as_bytes() != &slice[..first_nul]",
          "norm": "&slice[..first_nul] != expected_label.as_bytes()",
          "value": "false",
          "line": 445,
          "bound": null
        }
      ],
      "ret": "Ok(len)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        11,
        12,
        13,
        16,
        17,
        18,
        19,
        22,
        25
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "first_nul matches None",
          "norm": null,
          "value": "true",
          "line": 430,
          "bound": null
        }
      ],
      "ret": "Err(DeserializeError::generic(\n                \"could not find NUL terminated label \\\n                 at start of serialized object\",\n            ))",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        24,
        25
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}