{
  "name": "regex_automata::meta::regex::{impl#0}::new_many",
  "mod_info": {
    "name": "meta::regex",
    "loc": "regex-automata/src/meta/mod.rs:57:1:57:11"
  },
  "visible": true,
  "loc": "regex-automata/src/meta/regex.rs:393:5:397:6",
  "doc": "/// Builds a `Regex` from many pattern strings using the default\n/// configuration.\n///\n/// If there was a problem parsing any of the patterns or a problem turning\n/// them into a regex matcher, then an error is returned.\n///\n/// If you want to change the configuration of a `Regex`, use a [`Builder`]\n/// with a [`Config`].\n///\n/// # Example: simple lexer\n///\n/// This simplistic example leverages the multi-pattern support to build a\n/// simple little lexer. The pattern ID in the match tells you which regex\n/// matched, which in turn might be used to map back to the \"type\" of the\n/// token returned by the lexer.\n///\n/// ```\n/// use regex_automata::{meta::Regex, Match};\n///\n/// let re = Regex::new_many(&[\n///     r\"[[:space:]]\",\n///     r\"[A-Za-z0-9][A-Za-z0-9_]+\",\n///     r\"->\",\n///     r\".\",\n/// ])?;\n/// let haystack = \"fn is_boss(bruce: i32, springsteen: String) -> bool;\";\n/// let matches: Vec<Match> = re.find_iter(haystack).collect();\n/// assert_eq!(matches, vec![\n///     Match::must(1, 0..2),   // 'fn'\n///     Match::must(0, 2..3),   // ' '\n///     Match::must(1, 3..10),  // 'is_boss'\n///     Match::must(3, 10..11), // '('\n///     Match::must(1, 11..16), // 'bruce'\n///     Match::must(3, 16..17), // ':'\n///     Match::must(0, 17..18), // ' '\n///     Match::must(1, 18..21), // 'i32'\n///     Match::must(3, 21..22), // ','\n///     Match::must(0, 22..23), // ' '\n///     Match::must(1, 23..34), // 'springsteen'\n///     Match::must(3, 34..35), // ':'\n///     Match::must(0, 35..36), // ' '\n///     Match::must(1, 36..42), // 'String'\n///     Match::must(3, 42..43), // ')'\n///     Match::must(0, 43..44), // ' '\n///     Match::must(2, 44..46), // '->'\n///     Match::must(0, 46..47), // ' '\n///     Match::must(1, 47..51), // 'bool'\n///     Match::must(3, 51..52), // ';'\n/// ]);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// One can write a lexer like the above using a regex like\n/// `(?P<space>[[:space:]])|(?P<ident>[A-Za-z0-9][A-Za-z0-9_]+)|...`,\n/// but then you need to ask whether capture group matched to determine\n/// which branch in the regex matched, and thus, which token the match\n/// corresponds to. In contrast, the above example includes the pattern ID\n/// in the match. There's no need to use capture groups at all.\n///\n/// # Example: finding the pattern that caused an error\n///\n/// When a syntax error occurs, it is possible to ask which pattern\n/// caused the syntax error.\n///\n/// ```\n/// use regex_automata::{meta::Regex, PatternID};\n///\n/// let err = Regex::new_many(&[\"a\", \"b\", r\"\\p{Foo}\", \"c\"]).unwrap_err();\n/// assert_eq!(Some(PatternID::must(2)), err.pattern());\n/// ```\n///\n/// # Example: zero patterns is valid\n///\n/// Building a regex with zero patterns results in a regex that never\n/// matches anything. Because this routine is generic, passing an empty\n/// slice usually requires a turbo-fish (or something else to help type\n/// inference).\n///\n/// ```\n/// use regex_automata::{meta::Regex, util::syntax, Match};\n///\n/// let re = Regex::new_many::<&str>(&[])?;\n/// assert_eq!(None, re.find(\"\"));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn new_many<P: AsRef<str>>(",
    "    patterns: &[P],",
    ") -> Result<Regex, BuildError> {",
    "    Regex::builder().build_many(patterns)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}