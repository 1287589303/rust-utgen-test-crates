{
  "name": "regex_automata::meta::reverse_inner::prefilter",
  "mod_info": {
    "name": "meta::reverse_inner",
    "loc": "regex-automata/src/meta/mod.rs:58:1:58:19"
  },
  "visible": false,
  "loc": "regex-automata/src/meta/reverse_inner.rs:127:1:154:2",
  "doc": "/// Attempt to extract a prefilter from an HIR expression.\n///\n/// We do a little massaging here to do our best that the prefilter we get out\n/// of this is *probably* fast. Basically, the false positive rate has a much\n/// higher impact for things like the reverse inner optimization because more\n/// work needs to potentially be done for each candidate match.\n///\n/// Note that this assumes leftmost-first match semantics, so callers must\n/// not call this otherwise.\n",
  "code": [
    "fn prefilter(hir: &Hir) -> Option<Prefilter> {",
    "    let mut extractor = literal::Extractor::new();",
    "    extractor.kind(literal::ExtractKind::Prefix);",
    "    let mut prefixes = extractor.extract(hir);",
    "    debug!(",
    "        \"inner prefixes (len={:?}) extracted before optimization: {:?}\",",
    "        prefixes.len(),",
    "        prefixes",
    "    );",
    "    // Since these are inner literals, we know they cannot be exact. But the",
    "    // extractor doesn't know this. We mark them as inexact because this might",
    "    // impact literal optimization. Namely, optimization weights \"all literals",
    "    // are exact\" as very high, because it presumes that any match results in",
    "    // an overall match. But of course, that is not the case here.",
    "    //",
    "    // In practice, this avoids plucking out a ASCII-only \\s as an alternation",
    "    // of single-byte whitespace characters.",
    "    prefixes.make_inexact();",
    "    prefixes.optimize_for_prefix_by_preference();",
    "    debug!(",
    "        \"inner prefixes (len={:?}) extracted after optimization: {:?}\",",
    "        prefixes.len(),",
    "        prefixes",
    "    );",
    "    prefixes",
    "        .literals()",
    "        .and_then(|lits| Prefilter::new(MatchKind::LeftmostFirst, lits))",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}