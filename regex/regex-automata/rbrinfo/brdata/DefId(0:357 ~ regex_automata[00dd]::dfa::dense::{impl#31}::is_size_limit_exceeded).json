{
  "name": "regex_automata::dfa::dense::{impl#31}::is_size_limit_exceeded",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:5015:5:5026:6",
  "doc": "/// Returns true if and only if this error corresponds to an error with DFA\n/// construction that occurred because of exceeding a size limit.\n///\n/// While this can occur when size limits like [`Config::dfa_size_limit`]\n/// or [`Config::determinize_size_limit`] are exceeded, this can also occur\n/// when the number of states or patterns exceeds a hard-coded maximum.\n/// (Where these maximums are derived based on the values representable by\n/// [`StateID`] and [`PatternID`].)\n///\n/// This predicate is useful in contexts where you want to distinguish\n/// between errors related to something provided by an end user (for\n/// example, an invalid regex pattern) and errors related to configured\n/// heuristics. For example, building a DFA might be an optimization that\n/// you want to skip if construction fails because of an exceeded size\n/// limit, but where you want to bubble up an error if it fails for some\n/// other reason.\n///\n/// # Example\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// # if !cfg!(target_pointer_width = \"64\") { return Ok(()); } // see #1039\n/// use regex_automata::{dfa::{dense, Automaton}, Input};\n///\n/// let err = dense::Builder::new()\n///     .configure(dense::Config::new()\n///         .determinize_size_limit(Some(100_000))\n///     )\n///     .build(r\"\\w{20}\")\n///     .unwrap_err();\n/// // This error occurs because a size limit was exceeded.\n/// // But things are otherwise valid.\n/// assert!(err.is_size_limit_exceeded());\n///\n/// let err = dense::Builder::new()\n///     .build(r\"\\bxyz\\b\")\n///     .unwrap_err();\n/// // This error occurs because a Unicode word boundary\n/// // was used without enabling heuristic support for it.\n/// // So... not related to size limits.\n/// assert!(!err.is_size_limit_exceeded());\n///\n/// let err = dense::Builder::new()\n///     .build(r\"(xyz\")\n///     .unwrap_err();\n/// // This error occurs because the pattern is invalid.\n/// // So... not related to size limits.\n/// assert!(!err.is_size_limit_exceeded());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn is_size_limit_exceeded(&self) -> bool {",
    "    use self::BuildErrorKind::*;",
    "",
    "    match self.kind {",
    "        NFA(_) | Unsupported(_) => false,",
    "        TooManyStates",
    "        | TooManyStartStates",
    "        | TooManyMatchPatternIDs",
    "        | DFAExceededSizeLimit { .. }",
    "        | DeterminizeExceededSizeLimit { .. } => true,",
    "    }",
    "}"
  ],
  "size": {
    "chain": 7,
    "contra": 0,
    "min_set": 7
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.kind matches DeterminizeExceededSizeLimit { .. }",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        3,
        5
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.kind matches DFAExceededSizeLimit { .. }",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        3,
        5
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "self.kind matches TooManyMatchPatternIDs",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        3,
        5
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "self.kind matches TooManyStartStates",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        3,
        5
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "self.kind matches TooManyStates",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        }
      ],
      "ret": "true",
      "path": [
        0,
        3,
        5
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "self.kind matches Unsupported(_)",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        },
        {
          "cond": "self.kind matches NFA(_) or Unsupported(_)",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        2,
        4,
        5
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "self.kind matches NFA(_)",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        },
        {
          "cond": "self.kind matches NFA(_) or Unsupported(_)",
          "norm": null,
          "value": "true",
          "line": 5018,
          "bound": null
        }
      ],
      "ret": "false",
      "path": [
        0,
        2,
        4,
        5
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}