{
  "name": "regex_automata::nfa::thompson::nfa::{impl#0}::is_reverse",
  "mod_info": {
    "name": "nfa::thompson::nfa",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:66:1:66:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/nfa.rs:908:5:910:6",
  "doc": "/// Returns true when this NFA is meant to be matched in reverse.\n///\n/// Generally speaking, when this is true, it means the NFA is supposed to\n/// be used in conjunction with moving backwards through the haystack. That\n/// is, from a higher memory address to a lower memory address.\n///\n/// It is often the case that lower level routines dealing with an NFA\n/// don't need to care about whether it is \"meant\" to be matched in reverse\n/// or not. However, there are some specific cases where it matters. For\n/// example, the implementation of CRLF-aware `^` and `$` line anchors\n/// needs to know whether the search is in the forward or reverse\n/// direction. In the forward direction, neither `^` nor `$` should match\n/// when a `\\r` has been seen previously and a `\\n` is next. However, in\n/// the reverse direction, neither `^` nor `$` should match when a `\\n`\n/// has been seen previously and a `\\r` is next. This fundamentally changes\n/// how the state machine is constructed, and thus needs to be altered\n/// based on the direction of the search.\n///\n/// This is automatically set when using a [`Compiler`] with a configuration\n/// where [`Config::reverse`] is enabled. If you're building your own NFA\n/// by hand via a [`Builder`]\n",
  "code": [
    "pub fn is_reverse(&self) -> bool {",
    "    self.0.reverse",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self.0.reverse",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}