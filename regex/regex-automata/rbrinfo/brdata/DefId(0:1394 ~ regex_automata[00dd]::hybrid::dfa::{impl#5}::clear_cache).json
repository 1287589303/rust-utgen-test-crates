{
  "name": "regex_automata::hybrid::dfa::{impl#5}::clear_cache",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": false,
  "loc": "regex-automata/src/hybrid/dfa.rs:2445:5:2495:6",
  "doc": "/// Clear the cache used by this lazy DFA.\n///\n/// If 'self.state_saver' is set to save a state, then this state is\n/// persisted through cache clearing. Otherwise, the cache is returned to\n/// its state after initialization with two exceptions: its clear count\n/// is incremented and some of its memory likely has additional capacity.\n/// That is, clearing a cache does _not_ release memory.\n///\n/// Otherwise, any lazy state ID generated by the cache prior to resetting\n/// it is invalid after the reset.\n",
  "code": [
    "fn clear_cache(&mut self) {",
    "    self.cache.trans.clear();",
    "    self.cache.starts.clear();",
    "    self.cache.states.clear();",
    "    self.cache.states_to_id.clear();",
    "    self.cache.memory_usage_state = 0;",
    "    self.cache.clear_count += 1;",
    "    self.cache.bytes_searched = 0;",
    "    if let Some(ref mut progress) = self.cache.progress {",
    "        progress.start = progress.at;",
    "    }",
    "    trace!(",
    "        \"lazy DFA cache has been cleared (count: {})\",",
    "        self.cache.clear_count",
    "    );",
    "    self.init_cache();",
    "    // If the state we want to save is one of the sentinel",
    "    // (unknown/dead/quit) states, then 'init_cache' adds those back, and",
    "    // their identifier values remains invariant. So there's no need to add",
    "    // it again. (And indeed, doing so would be incorrect!)",
    "    if let Some((old_id, state)) = self.cache.state_saver.take_to_save() {",
    "        // If the state is one of the special sentinel states, then it is",
    "        // automatically added by cache initialization and its ID always",
    "        // remains the same. With that said, this should never occur since",
    "        // the sentinel states are all loop states back to themselves. So",
    "        // we should never be in a position where we're attempting to save",
    "        // a sentinel state since we never compute transitions out of a",
    "        // sentinel state.",
    "        assert!(",
    "            !self.as_ref().is_sentinel(old_id),",
    "            \"cannot save sentinel state\"",
    "        );",
    "        let new_id = self",
    "            .add_state(state, |id| {",
    "                if old_id.is_start() {",
    "                    // We don't need to consult the",
    "                    // 'specialize_start_states' config knob here, because",
    "                    // if it's disabled, old_id.is_start() will never",
    "                    // return true.",
    "                    id.to_start()",
    "                } else {",
    "                    id",
    "                }",
    "            })",
    "            // The unwrap here is OK because lazy DFA creation ensures that",
    "            // we have room in the cache to add MIN_STATES states. Since",
    "            // 'init_cache' above adds 3, this adds a 4th.",
    "            .expect(\"adding one state after cache clear must work\");",
    "        self.cache.state_saver = StateSaver::Saved(new_id);",
    "    }",
    "}"
  ],
  "size": {
    "chain": 6,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let Some(ref mut progress) = self.cache.progress",
          "norm": null,
          "value": "true",
          "line": 2453,
          "bound": null
        },
        {
          "cond": "let Some((old_id, state)) = self.cache.state_saver.take_to_save()",
          "norm": null,
          "value": "true",
          "line": 2465,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        9,
        10,
        11,
        24,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let Some(ref mut progress) = self.cache.progress",
          "norm": null,
          "value": "true",
          "line": 2453,
          "bound": null
        },
        {
          "cond": "let Some((old_id, state)) = self.cache.state_saver.take_to_save()",
          "norm": null,
          "value": "true",
          "line": 2465,
          "bound": null
        },
        {
          "cond": "self.as_ref().is_sentinel(old_id)",
          "norm": null,
          "value": "true",
          "line": 2474,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        18,
        29,
        30,
        31
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "let Some(ref mut progress) = self.cache.progress",
          "norm": null,
          "value": "true",
          "line": 2453,
          "bound": null
        },
        {
          "cond": "let Some((old_id, state)) = self.cache.state_saver.take_to_save()",
          "norm": null,
          "value": "true",
          "line": 2465,
          "bound": null
        },
        {
          "cond": "self.as_ref().is_sentinel(old_id)",
          "norm": null,
          "value": "false",
          "line": 2474,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        17,
        19,
        20,
        21,
        23,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "let Some(ref mut progress) = self.cache.progress",
          "norm": null,
          "value": "true",
          "line": 2453,
          "bound": null
        },
        {
          "cond": "let Some((old_id, state)) = self.cache.state_saver.take_to_save()",
          "norm": null,
          "value": "true",
          "line": 2465,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        9,
        10,
        11,
        24,
        26,
        27
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "let Some(ref mut progress) = self.cache.progress",
          "norm": null,
          "value": "true",
          "line": 2453,
          "bound": null
        },
        {
          "cond": "let Some((old_id, state)) = self.cache.state_saver.take_to_save()",
          "norm": null,
          "value": "true",
          "line": 2465,
          "bound": null
        },
        {
          "cond": "self.as_ref().is_sentinel(old_id)",
          "norm": null,
          "value": "true",
          "line": 2474,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        18,
        29,
        30,
        31
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "let Some(ref mut progress) = self.cache.progress",
          "norm": null,
          "value": "true",
          "line": 2453,
          "bound": null
        },
        {
          "cond": "let Some((old_id, state)) = self.cache.state_saver.take_to_save()",
          "norm": null,
          "value": "true",
          "line": 2465,
          "bound": null
        },
        {
          "cond": "self.as_ref().is_sentinel(old_id)",
          "norm": null,
          "value": "false",
          "line": 2474,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        17,
        19,
        20,
        21,
        23,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}