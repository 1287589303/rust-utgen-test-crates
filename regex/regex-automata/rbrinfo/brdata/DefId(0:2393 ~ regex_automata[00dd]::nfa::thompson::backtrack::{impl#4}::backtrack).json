{
  "name": "regex_automata::nfa::thompson::backtrack::{impl#4}::backtrack",
  "mod_info": {
    "name": "nfa::thompson::backtrack",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:57:1:57:19"
  },
  "visible": false,
  "loc": "regex-automata/src/nfa/thompson/backtrack.rs:1425:5:1447:6",
  "doc": "/// Look for a match starting at `at` in `input` and write the matching\n/// pattern ID and group spans to `caps`. The search uses `start_id` as its\n/// starting state in the underlying NFA.\n///\n/// If no match was found, then the caller should increment `at` and try\n/// at the next position.\n",
  "code": [
    "fn backtrack(",
    "    &self,",
    "    cache: &mut Cache,",
    "    input: &Input<'_>,",
    "    at: usize,",
    "    start_id: StateID,",
    "    slots: &mut [Option<NonMaxUsize>],",
    ") -> Option<HalfMatch> {",
    "    cache.stack.push(Frame::Step { sid: start_id, at });",
    "    while let Some(frame) = cache.stack.pop() {",
    "        match frame {",
    "            Frame::Step { sid, at } => {",
    "                if let Some(hm) = self.step(cache, input, sid, at, slots) {",
    "                    return Some(hm);",
    "                }",
    "            }",
    "            Frame::RestoreCapture { slot, offset } => {",
    "                slots[slot] = offset;",
    "            }",
    "        }",
    "    }",
    "    None",
    "}"
  ],
  "size": {
    "chain": 4,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let Some(frame) = cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1434,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        17,
        18
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let Some(frame) = cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1434,
          "bound": null
        },
        {
          "cond": "frame matches Frame::RestoreCapture { slot, offset }",
          "norm": null,
          "value": "true",
          "line": 1435,
          "bound": null
        },
        {
          "cond": "let Some(frame) = cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1434,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        9,
        15,
        16,
        2,
        3,
        4,
        17,
        18
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "let Some(frame) = cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1434,
          "bound": null
        },
        {
          "cond": "frame matches Frame::Step { sid, at }",
          "norm": null,
          "value": "true",
          "line": 1435,
          "bound": null
        },
        {
          "cond": "frame matches Frame::Step { sid, at }",
          "norm": null,
          "value": "true",
          "line": 1435,
          "bound": null
        },
        {
          "cond": "let Some(hm) = self.step(cache, input, sid, at, slots)",
          "norm": null,
          "value": "true",
          "line": 1437,
          "bound": null
        },
        {
          "cond": "let Some(frame) = cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1434,
          "bound": null
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        8,
        10,
        11,
        14,
        16,
        2,
        3,
        4,
        17,
        18
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "let Some(frame) = cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1434,
          "bound": null
        },
        {
          "cond": "frame matches Frame::Step { sid, at }",
          "norm": null,
          "value": "true",
          "line": 1435,
          "bound": null
        },
        {
          "cond": "frame matches Frame::Step { sid, at }",
          "norm": null,
          "value": "true",
          "line": 1435,
          "bound": null
        },
        {
          "cond": "let Some(hm) = self.step(cache, input, sid, at, slots)",
          "norm": null,
          "value": "true",
          "line": 1437,
          "bound": null
        }
      ],
      "ret": "Some(hm)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        8,
        10,
        11,
        12,
        13,
        18
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}