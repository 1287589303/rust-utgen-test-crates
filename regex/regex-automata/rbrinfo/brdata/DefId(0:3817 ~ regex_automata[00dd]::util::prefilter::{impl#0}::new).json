{
  "name": "regex_automata::util::prefilter::{impl#0}::new",
  "mod_info": {
    "name": "util::prefilter",
    "loc": "regex-automata/src/util/mod.rs:41:1:41:19"
  },
  "visible": true,
  "loc": "regex-automata/src/util/prefilter/mod.rs:203:5:212:6",
  "doc": "/// Create a new prefilter from a sequence of needles and a corresponding\n/// match semantics.\n///\n/// This may return `None` for a variety of reasons, for example, if\n/// a suitable prefilter could not be constructed. That might occur\n/// if they are unavailable (e.g., the `perf-literal-substring` and\n/// `perf-literal-multisubstring` features aren't enabled), or it might\n/// occur because of heuristics or other artifacts of how the prefilter\n/// works.\n///\n/// Note that if you have an [`Hir`] expression, it may be more convenient\n/// to use [`Prefilter::from_hir_prefix`]. It will automatically handle the\n/// task of extracting prefix literals for you.\n///\n/// # Example\n///\n/// This example shows how match semantics can impact the matching\n/// algorithm used by the prefilter. For this reason, it is important to\n/// ensure that the match semantics given here are consistent with the\n/// match semantics intended for the regular expression that the literals\n/// were extracted from.\n///\n/// ```\n/// use regex_automata::{\n///     util::{prefilter::Prefilter, syntax},\n///     MatchKind, Span,\n/// };\n///\n/// let hay = \"Hello samwise\";\n///\n/// // With leftmost-first, we find 'samwise' here because it comes\n/// // before 'sam' in the sequence we give it..\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"samwise\", \"sam\"])\n///     .expect(\"a prefilter\");\n/// assert_eq!(\n///     Some(Span::from(6..13)),\n///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),\n/// );\n/// // Still with leftmost-first but with the literals reverse, now 'sam'\n/// // will match instead!\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"sam\", \"samwise\"])\n///     .expect(\"a prefilter\");\n/// assert_eq!(\n///     Some(Span::from(6..9)),\n///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),\n/// );\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn new<B: AsRef<[u8]>>(",
    "    kind: MatchKind,",
    "    needles: &[B],",
    ") -> Option<Prefilter> {",
    "    Choice::new(kind, needles).and_then(|choice| {",
    "        let max_needle_len =",
    "            needles.iter().map(|b| b.as_ref().len()).max().unwrap_or(0);",
    "        Prefilter::from_choice(choice, max_needle_len)",
    "    })",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}