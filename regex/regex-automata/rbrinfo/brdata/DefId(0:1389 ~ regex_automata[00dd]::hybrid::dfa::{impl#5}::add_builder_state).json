{
  "name": "regex_automata::hybrid::dfa::{impl#5}::add_builder_state",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": false,
  "loc": "regex-automata/src/hybrid/dfa.rs:2245:5:2261:6",
  "doc": "/// Either add the given builder state to this cache, or return an ID to an\n/// equivalent state already in this cache.\n///\n/// In the case where no equivalent state exists, the idmap function given\n/// may be used to transform the identifier allocated. This is useful if\n/// the caller needs to tag the ID with additional information.\n///\n/// This will never return an unknown lazy state ID.\n///\n/// If caching this state would otherwise result in a cache that has been\n/// cleared too many times, then an error is returned.\n",
  "code": [
    "fn add_builder_state(",
    "    &mut self,",
    "    builder: StateBuilderNFA,",
    "    idmap: impl Fn(LazyStateID) -> LazyStateID,",
    ") -> Result<LazyStateID, CacheError> {",
    "    if let Some(&cached_id) =",
    "        self.cache.states_to_id.get(builder.as_bytes())",
    "    {",
    "        // Since we have a cached state, put the constructed state's",
    "        // memory back into our scratch space, so that it can be reused.",
    "        self.put_state_builder(builder);",
    "        return Ok(cached_id);",
    "    }",
    "    let result = self.add_state(builder.to_state(), idmap);",
    "    self.put_state_builder(builder);",
    "    result",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let Some(&cached_id) =\n            self.cache.states_to_id.get(builder.as_bytes())",
          "norm": null,
          "value": "true",
          "line": 2250,
          "bound": null
        }
      ],
      "ret": "result",
      "path": [
        0,
        1,
        2,
        6,
        7,
        8,
        9,
        10,
        12
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let Some(&cached_id) =\n            self.cache.states_to_id.get(builder.as_bytes())",
          "norm": null,
          "value": "true",
          "line": 2250,
          "bound": null
        }
      ],
      "ret": "Ok(cached_id)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        11,
        12
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}