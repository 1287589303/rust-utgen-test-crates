{
  "name": "regex_automata::nfa::thompson::nfa::{impl#0}::look_set_prefix_any",
  "mod_info": {
    "name": "nfa::thompson::nfa",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:66:1:66:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/nfa.rs:1099:5:1101:6",
  "doc": "/// Returns the union of all prefix look-around assertions for every\n/// pattern in this NFA. When the returned set is empty, it implies none of\n/// the patterns require moving through a conditional epsilon transition\n/// before inspecting the first byte in the haystack.\n///\n/// This can be useful for determining what kinds of assertions need to be\n/// satisfied at the beginning of a search. For example, typically DFAs\n/// in this crate will build a distinct starting state for each possible\n/// starting configuration that might result in look-around assertions\n/// being satisfied differently. However, if the set returned here is\n/// empty, then you know that the start state is invariant because there\n/// are no conditional epsilon transitions to consider.\n///\n/// # Example\n///\n/// This example shows how this routine varies based on the regex pattern:\n///\n/// ```\n/// use regex_automata::{nfa::thompson::NFA, util::look::Look};\n///\n/// // No look-around at all.\n/// let nfa = NFA::new(\"a\")?;\n/// assert!(nfa.look_set_prefix_any().is_empty());\n///\n/// // When multiple patterns are present, since this returns the union,\n/// // it will include look-around assertions that only appear in one\n/// // pattern. But it will only include assertions that are in the prefix\n/// // of a pattern. For example, this includes '^' but not '$' even though\n/// // '$' does appear.\n/// let nfa = NFA::new_many(&[\"a\", \"b\", \"^ab$\", \"c\"])?;\n/// assert!(nfa.look_set_prefix_any().contains(Look::Start));\n/// assert!(!nfa.look_set_prefix_any().contains(Look::End));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn look_set_prefix_any(&self) -> LookSet {",
    "    self.0.look_set_prefix_any",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self.0.look_set_prefix_any",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}