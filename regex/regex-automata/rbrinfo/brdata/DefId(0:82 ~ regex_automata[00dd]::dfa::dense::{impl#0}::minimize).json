{
  "name": "regex_automata::dfa::dense::{impl#0}::minimize",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:246:5:249:6",
  "doc": "/// Minimize the DFA.\n///\n/// When enabled, the DFA built will be minimized such that it is as small\n/// as possible.\n///\n/// Whether one enables minimization or not depends on the types of costs\n/// you're willing to pay and how much you care about its benefits. In\n/// particular, minimization has worst case `O(n*k*logn)` time and `O(k*n)`\n/// space, where `n` is the number of DFA states and `k` is the alphabet\n/// size. In practice, minimization can be quite costly in terms of both\n/// space and time, so it should only be done if you're willing to wait\n/// longer to produce a DFA. In general, you might want a minimal DFA in\n/// the following circumstances:\n///\n/// 1. You would like to optimize for the size of the automaton. This can\n///    manifest in one of two ways. Firstly, if you're converting the\n///    DFA into Rust code (or a table embedded in the code), then a minimal\n///    DFA will translate into a corresponding reduction in code  size, and\n///    thus, also the final compiled binary size. Secondly, if you are\n///    building many DFAs and putting them on the heap, you'll be able to\n///    fit more if they are smaller. Note though that building a minimal\n///    DFA itself requires additional space; you only realize the space\n///    savings once the minimal DFA is constructed (at which point, the\n///    space used for minimization is freed).\n/// 2. You've observed that a smaller DFA results in faster match\n///    performance. Naively, this isn't guaranteed since there is no\n///    inherent difference between matching with a bigger-than-minimal\n///    DFA and a minimal DFA. However, a smaller DFA may make use of your\n///    CPU's cache more efficiently.\n/// 3. You are trying to establish an equivalence between regular\n///    languages. The standard method for this is to build a minimal DFA\n///    for each language and then compare them. If the DFAs are equivalent\n///    (up to state renaming), then the languages are equivalent.\n///\n/// Typically, minimization only makes sense as an offline process. That\n/// is, one might minimize a DFA before serializing it to persistent\n/// storage. In practical terms, minimization can take around an order of\n/// magnitude more time than compiling the initial DFA via determinization.\n///\n/// This option is disabled by default.\n",
  "code": [
    "pub fn minimize(mut self, yes: bool) -> Config {",
    "    self.minimize = Some(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}