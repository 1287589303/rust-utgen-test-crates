{
  "name": "regex_automata::util::look::{impl#4}::is_word_unicode_negate",
  "mod_info": {
    "name": "util::look",
    "loc": "regex-automata/src/util/mod.rs:38:1:38:14"
  },
  "visible": true,
  "loc": "regex-automata/src/util/look.rs:1042:5:1089:6",
  "doc": "/// Returns true when [`Look::WordUnicodeNegate`] is satisfied `at` the\n/// given position in `haystack`.\n///\n/// # Panics\n///\n/// This may panic when `at > haystack.len()`. Note that `at ==\n/// haystack.len()` is legal and guaranteed not to panic.\n///\n/// # Errors\n///\n/// This returns an error when Unicode word boundary tables\n/// are not available. Specifically, this only occurs when the\n/// `unicode-word-boundary` feature is not enabled.\n",
  "code": [
    "pub fn is_word_unicode_negate(",
    "    &self,",
    "    haystack: &[u8],",
    "    at: usize,",
    ") -> Result<bool, UnicodeWordBoundaryError> {",
    "    // This is pretty subtle. Why do we need to do UTF-8 decoding here?",
    "    // Well... at time of writing, the is_word_char_{fwd,rev} routines will",
    "    // only return true if there is a valid UTF-8 encoding of a \"word\"",
    "    // codepoint, and false in every other case (including invalid UTF-8).",
    "    // This means that in regions of invalid UTF-8 (which might be a",
    "    // subset of valid UTF-8!), it would result in \\B matching. While this",
    "    // would be questionable in the context of truly invalid UTF-8, it is",
    "    // *certainly* wrong to report match boundaries that split the encoding",
    "    // of a codepoint. So to work around this, we ensure that we can decode",
    "    // a codepoint on either side of `at`. If either direction fails, then",
    "    // we don't permit \\B to match at all.",
    "    //",
    "    // Now, this isn't exactly optimal from a perf perspective. We could",
    "    // try and detect this in is_word_char::{fwd,rev}, but it's not clear",
    "    // if it's worth it. \\B is, after all, rarely used. Even worse,",
    "    // is_word_char::{fwd,rev} could do its own UTF-8 decoding, and so this",
    "    // will wind up doing UTF-8 decoding twice. Owch. We could fix this",
    "    // with more code complexity, but it just doesn't feel worth it for \\B.",
    "    //",
    "    // And in particular, we do *not* have to do this with \\b, because \\b",
    "    // *requires* that at least one side of `at` be a \"word\" codepoint,",
    "    // which in turn implies one side of `at` must be valid UTF-8. This in",
    "    // turn implies that \\b can never split a valid UTF-8 encoding of a",
    "    // codepoint. In the case where one side of `at` is truly invalid UTF-8",
    "    // and the other side IS a word codepoint, then we want \\b to match",
    "    // since it represents a valid UTF-8 boundary. It also makes sense. For",
    "    // example, you'd want \\b\\w+\\b to match 'abc' in '\\xFFabc\\xFF'.",
    "    //",
    "    // Note also that this is not just '!is_word_unicode(..)' like it is",
    "    // for the ASCII case. For example, neither \\b nor \\B is satisfied",
    "    // within invalid UTF-8 sequences.",
    "    let word_before = at > 0",
    "        && match utf8::decode_last(&haystack[..at]) {",
    "            None | Some(Err(_)) => return Ok(false),",
    "            Some(Ok(_)) => is_word_char::rev(haystack, at)?,",
    "        };",
    "    let word_after = at < haystack.len()",
    "        && match utf8::decode(&haystack[at..]) {",
    "            None | Some(Err(_)) => return Ok(false),",
    "            Some(Ok(_)) => is_word_char::fwd(haystack, at)?,",
    "        };",
    "    Ok(word_before == word_after)",
    "}"
  ],
  "size": {
    "chain": 13,
    "contra": 0,
    "min_set": 6
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        }
      ],
      "ret": "Ok(false)",
      "path": [
        0,
        1,
        3,
        4,
        6,
        8,
        9,
        37,
        38,
        39
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "is_word_char::rev(haystack, at)?",
          "norm": null,
          "value": "Err/None",
          "line": 1081,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        3,
        4,
        6,
        7,
        10,
        11,
        13,
        15,
        16,
        37,
        38,
        39
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "is_word_char::rev(haystack, at)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1081,
          "bound": null
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        }
      ],
      "ret": "Ok(false)",
      "path": [
        0,
        1,
        3,
        4,
        6,
        7,
        10,
        11,
        14,
        17,
        18,
        19,
        21,
        22,
        24,
        26,
        27,
        36,
        38,
        39
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "is_word_char::rev(haystack, at)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1081,
          "bound": null
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "is_word_char::fwd(haystack, at)?",
          "norm": null,
          "value": "Err/None",
          "line": 1086,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        3,
        4,
        6,
        7,
        10,
        11,
        14,
        17,
        18,
        19,
        21,
        22,
        24,
        25,
        28,
        29,
        31,
        33,
        34,
        36,
        38,
        39
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "is_word_char::rev(haystack, at)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1081,
          "bound": null
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "is_word_char::fwd(haystack, at)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1086,
          "bound": null
        }
      ],
      "ret": "Ok(word_before == word_after)",
      "path": [
        0,
        1,
        3,
        4,
        6,
        7,
        10,
        11,
        14,
        17,
        18,
        19,
        21,
        22,
        24,
        25,
        28,
        29,
        32,
        35,
        39
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "is_word_char::rev(haystack, at)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1081,
          "bound": null
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        }
      ],
      "ret": "Ok(false)",
      "path": [
        0,
        1,
        3,
        4,
        6,
        7,
        10,
        11,
        14,
        17,
        18,
        19,
        21,
        22,
        26,
        27,
        36,
        38,
        39
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches Some(Ok(_)) or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "is_word_char::rev(haystack, at)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1081,
          "bound": null
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "false",
          "line": 1083,
          "bound": "at == haystack.len()"
        }
      ],
      "ret": "Ok(word_before == word_after)",
      "path": [
        0,
        1,
        3,
        4,
        6,
        7,
        10,
        11,
        14,
        17,
        18,
        20,
        35,
        39
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "true",
          "line": 1078,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        },
        {
          "cond": "utf8::decode_last(&haystack[..at]) matches None or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1079,
          "bound": null
        }
      ],
      "ret": "Ok(false)",
      "path": [
        0,
        1,
        3,
        4,
        8,
        9,
        37,
        38,
        39
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "false",
          "line": 1078,
          "bound": "at == 0"
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        }
      ],
      "ret": "Ok(false)",
      "path": [
        0,
        2,
        17,
        18,
        19,
        21,
        22,
        24,
        26,
        27,
        36,
        38,
        39
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "false",
          "line": 1078,
          "bound": "at == 0"
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "is_word_char::fwd(haystack, at)?",
          "norm": null,
          "value": "Err/None",
          "line": 1086,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        2,
        17,
        18,
        19,
        21,
        22,
        24,
        25,
        28,
        29,
        31,
        33,
        34,
        36,
        38,
        39
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "false",
          "line": 1078,
          "bound": "at == 0"
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches Some(Err(_)) or Some(Ok(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "is_word_char::fwd(haystack, at)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 1086,
          "bound": null
        }
      ],
      "ret": "Ok(word_before == word_after)",
      "path": [
        0,
        2,
        17,
        18,
        19,
        21,
        22,
        24,
        25,
        28,
        29,
        32,
        35,
        39
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "false",
          "line": 1078,
          "bound": "at == 0"
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "true",
          "line": 1083,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        },
        {
          "cond": "utf8::decode(&haystack[at..]) matches None or Some(Err(_))",
          "norm": null,
          "value": "true",
          "line": 1084,
          "bound": null
        }
      ],
      "ret": "Ok(false)",
      "path": [
        0,
        2,
        17,
        18,
        19,
        21,
        22,
        26,
        27,
        36,
        38,
        39
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "at > 0",
          "norm": "0 < at",
          "value": "false",
          "line": 1078,
          "bound": "at == 0"
        },
        {
          "cond": "at < haystack.len()",
          "norm": null,
          "value": "false",
          "line": 1083,
          "bound": "at == haystack.len()"
        }
      ],
      "ret": "Ok(word_before == word_after)",
      "path": [
        0,
        2,
        17,
        18,
        20,
        35,
        39
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}