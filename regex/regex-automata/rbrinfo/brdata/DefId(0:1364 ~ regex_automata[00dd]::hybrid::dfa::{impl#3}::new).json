{
  "name": "regex_automata::hybrid::dfa::{impl#3}::new",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:1875:5:1894:6",
  "doc": "/// Create a new cache for the given lazy DFA.\n///\n/// The cache returned should only be used for searches for the given DFA.\n/// If you want to reuse the cache for another DFA, then you must call\n/// [`Cache::reset`] with that DFA.\n",
  "code": [
    "pub fn new(dfa: &DFA) -> Cache {",
    "    let mut cache = Cache {",
    "        trans: alloc::vec![],",
    "        starts: alloc::vec![],",
    "        states: alloc::vec![],",
    "        states_to_id: StateMap::new(),",
    "        sparses: SparseSets::new(dfa.get_nfa().states().len()),",
    "        stack: alloc::vec![],",
    "        scratch_state_builder: StateBuilderEmpty::new(),",
    "        state_saver: StateSaver::none(),",
    "        memory_usage_state: 0,",
    "        clear_count: 0,",
    "        bytes_searched: 0,",
    "        progress: None,",
    "    };",
    "    debug!(\"pre-init lazy DFA cache size: {}\", cache.memory_usage());",
    "    Lazy { dfa, cache: &mut cache }.init_cache();",
    "    debug!(\"post-init lazy DFA cache size: {}\", cache.memory_usage());",
    "    cache",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "cache",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}