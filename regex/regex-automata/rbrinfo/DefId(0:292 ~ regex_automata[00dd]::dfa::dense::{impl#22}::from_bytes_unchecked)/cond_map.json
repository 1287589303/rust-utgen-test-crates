{
  "regex-automata/src/dfa/dense.rs:4405:9:4405:51": [
    {
      "Try": "wire::check_alignment::<PatternID>(slice)?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4368:32:4372:11": [
    {
      "Try": "wire::mul(\n            pair_len,\n            PatternID::SIZE,\n            \"match state slice offset byte length\",\n        )?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4392:13:4392:66": [
    {
      "Try": "wire::try_read_u32_as_usize(slice, \"pattern length\")?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4363:13:4363:70": [
    {
      "Try": "wire::try_read_u32_as_usize(slice, \"match state length\")?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4398:13:4398:69": [
    {
      "Try": "wire::try_read_u32_as_usize(slice, \"pattern ID length\")?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4373:9:4373:78": [
    {
      "Try": "wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4420:17:4420:56": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "slice.as_ptr().as_usize() - slice_start",
          "lhs": "slice.as_ptr().as_usize()",
          "rhs": "slice_start",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/dense.rs:4367:24:4367:76": [
    {
      "Try": "wire::mul(2, state_len, \"match state offset pairs\")?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4404:9:4404:76": [
    {
      "Try": "wire::check_slice_len(slice, pattern_ids_len, \"match pattern IDs\")?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4374:9:4374:51": [
    {
      "Try": "wire::check_alignment::<PatternID>(slice)?"
    }
  ],
  "regex-automata/src/dfa/dense.rs:4403:13:4403:73": [
    {
      "Try": "wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?"
    }
  ]
}