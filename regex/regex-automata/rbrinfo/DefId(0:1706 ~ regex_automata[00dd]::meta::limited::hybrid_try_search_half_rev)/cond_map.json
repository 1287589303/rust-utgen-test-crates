{
  "regex-automata/src/meta/limited.rs:144:12:144:27": [
    {
      "Bool": {
        "Other": "sid.is_tagged()"
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:154:23:154:36": [
    {
      "Bool": {
        "Other": "sid.is_quit()"
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:176:13:176:21": [
    {
      "Bool": {
        "Other": "was_dead"
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:175:12:175:61": [
    {
      "Bool": {
        "Other": "mat.map_or(false, |m| m.offset() > input.start())"
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:134:19:134:57": [
    {
      "Try": "dfa.start_state_reverse(cache, input)?"
    }
  ],
  "regex-automata/src/meta/limited.rs:151:52:151:58": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "at + 1",
          "lhs": "at",
          "rhs": "1",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:145:16:145:30": [
    {
      "Bool": {
        "Other": "sid.is_match()"
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:174:8:174:27": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "at == input.start()",
          "lhs": "at",
          "rhs": "input.start()",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:135:8:135:36": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "input.start() == input.end()",
          "lhs": "input.start()",
          "rhs": "input.end()",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:139:18:139:33": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "input.end() - 1",
          "lhs": "input.end()",
          "rhs": "1",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:152:23:152:36": [
    {
      "Bool": {
        "Other": "sid.is_dead()"
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:141:15:143:51": [
    {
      "Try": "dfa\n            .next_state(cache, sid, input.haystack()[at])\n            .map_err(|_| MatchError::gave_up(at))?"
    }
  ],
  "regex-automata/src/meta/limited.rs:136:9:136:63": [
    {
      "Try": "hybrid_eoi_rev(dfa, cache, input, &mut sid, &mut mat)?"
    }
  ],
  "regex-automata/src/meta/limited.rs:158:12:158:31": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "at == input.start()",
          "lhs": "at",
          "rhs": "input.start()",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/meta/limited.rs:172:5:172:59": [
    {
      "Try": "hybrid_eoi_rev(dfa, cache, input, &mut sid, &mut mat)?"
    }
  ],
  "regex-automata/src/meta/limited.rs:162:12:162:26": [
    {
      "Bool": {
        "Binary": {
          "kind": "Lt",
          "expr": "at < min_start",
          "lhs": "at",
          "rhs": "min_start",
          "cmp_with_int": false
        }
      }
    }
  ]
}