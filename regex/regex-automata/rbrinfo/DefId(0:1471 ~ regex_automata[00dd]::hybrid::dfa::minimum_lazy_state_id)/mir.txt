bb0
  0: StorageLive(_2)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:9-4288:15)
  1: StorageLive(_3)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:23-4288:40)
  2: StorageLive(_4)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:23-4288:30)
  3: _4 = &(*_1)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:23-4288:30)
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:23-4288:40)
      kind: _3 = util::alphabet::ByteClasses::stride2(move _4) -> [return: bb1, unwind: bb7]
  }
  preds []
  succs [bb1, bb7]

bb1
  0: StorageDead(_4)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:39-4288:40)
  1: _5 = Lt(_3, const 64_usize)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:18-4288:40)
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:18-4288:40)
      kind: assert(move _5, "attempt to shift left by `{}`, which would overflow", _3) -> [success: bb2, unwind: bb7]
  }
  preds [bb0]
  succs [bb2, bb7]

bb2
  0: _2 = Shl(const 1_usize, move _3)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:18-4288:40)
  1: StorageDead(_3)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:39-4288:40)
  2: FakeRead(ForLet(None), _2)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4288:9-4288:15)
  3: StorageLive(_6)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4289:9-4289:24)
  4: StorageLive(_7)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4289:27-4289:52)
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4289:27-4289:52)
      kind: _7 = core::num::<impl usize>::checked_sub(const hybrid::dfa::MIN_STATES, const 1_usize) -> [return: bb3, unwind: bb7]
  }
  preds [bb1]
  succs [bb3, bb7]

bb3
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4289:27-4289:61)
      kind: _6 = core::option::Option::<usize>::unwrap(move _7) -> [return: bb4, unwind: bb7]
  }
  preds [bb2]
  succs [bb4, bb7]

bb4
  0: StorageDead(_7)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4289:60-4289:61)
  1: FakeRead(ForLet(None), _6)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4289:9-4289:24)
  2: StorageLive(_8)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:22-4290:46)
  3: StorageLive(_9)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:22-4290:37)
  4: _9 = _6
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:22-4290:37)
  5: StorageLive(_10)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:40-4290:46)
  6: _10 = _2
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:40-4290:46)
  7: _11 = MulWithOverflow(_9, _10)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:22-4290:46)
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:22-4290:46)
      kind: assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", move _9, move _10) -> [success: bb5, unwind: bb7]
  }
  preds [bb3]
  succs [bb5, bb7]

bb5
  0: _8 = move (_11.0: usize)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:22-4290:46)
  1: StorageDead(_10)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:45-4290:46)
  2: StorageDead(_9)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:45-4290:46)
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:5-4290:47)
      kind: _0 = hybrid::id::LazyStateID::new(move _8) -> [return: bb6, unwind: bb7]
  }
  preds [bb4]
  succs [bb6, bb7]

bb6
  0: StorageDead(_8)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4290:46-4290:47)
  1: StorageDead(_6)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4291:1-4291:2)
  2: StorageDead(_2)
    SourceInfo(regex-automata/src/hybrid/dfa.rs:4291:1-4291:2)
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4291:2-4291:2)
      kind: return
  }
  preds [bb5]
  succs []

bb7
  Terminator {
      source_info: SourceInfo(regex-automata/src/hybrid/dfa.rs:4285:1-4291:2)
      kind: resume
  }
  preds [bb0, bb1, bb2, bb3, bb4, bb5]
  succs []

