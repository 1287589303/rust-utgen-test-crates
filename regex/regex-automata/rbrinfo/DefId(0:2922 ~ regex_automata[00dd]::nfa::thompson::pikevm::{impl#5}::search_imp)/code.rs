fn search_imp(
        &self,
        cache: &mut Cache,
        input: &Input<'_>,
        slots: &mut [Option<NonMaxUsize>],
    ) -> Option<HalfMatch> {
        cache.setup_search(slots.len());
        if input.is_done() {
            return None;
        }
        // Why do we even care about this? Well, in our 'Captures'
        // representation, we use usize::MAX as a sentinel to indicate "no
        // match." This isn't problematic so long as our haystack doesn't have
        // a maximal length. Byte slices are guaranteed by Rust to have a
        // length that fits into isize, and so this assert should always pass.
        // But we put it here to make our assumption explicit.
        assert!(
            input.haystack().len() < core::usize::MAX,
            "byte slice lengths must be less than usize MAX",
        );
        instrument!(|c| c.reset(&self.nfa));

        // Whether we want to visit all match states instead of emulating the
        // 'leftmost' semantics of typical backtracking regex engines.
        let allmatches =
            self.config.get_match_kind().continue_past_first_match();
        let (anchored, start_id) = match self.start_config(input) {
            None => return None,
            Some(config) => config,
        };

        let pre =
            if anchored { None } else { self.get_config().get_prefilter() };
        let Cache { ref mut stack, ref mut curr, ref mut next } = cache;
        let mut hm = None;
        // Yes, our search doesn't end at input.end(), but includes it. This
        // is necessary because matches are delayed by one byte, just like
        // how the DFA engines work. The delay is used to handle look-behind
        // assertions. In the case of the PikeVM, the delay is implemented
        // by not considering a match to exist until it is visited in
        // 'steps'. Technically, we know a match exists in the previous
        // iteration via 'epsilon_closure'. (It's the same thing in NFA-to-DFA
        // determinization. We don't mark a DFA state as a match state if it
        // contains an NFA match state, but rather, whether the DFA state was
        // generated by a transition from a DFA state that contains an NFA
        // match state.)
        let mut at = input.start();
        while at <= input.end() {
            // If we have no states left to visit, then there are some cases
            // where we know we can quit early or even skip ahead.
            if curr.set.is_empty() {
                // We have a match and we haven't been instructed to continue
                // on even after finding a match, so we can quit.
                if hm.is_some() && !allmatches {
                    break;
                }
                // If we're running an anchored search and we've advanced
                // beyond the start position with no other states to try, then
                // we will never observe a match and thus can stop.
                if anchored && at > input.start() {
                    break;
                }
                // If there no states left to explore at this position and we
                // know we can't terminate early, then we are effectively at
                // the starting state of the NFA. If we fell through here,
                // we'd end up adding our '(?s-u:.)*?' prefix and it would be
                // the only thing in 'curr'. So we might as well just skip
                // ahead until we find something that we know might advance us
                // forward.
                if let Some(ref pre) = pre {
                    let span = Span::from(at..input.end());
                    match pre.find(input.haystack(), span) {
                        None => break,
                        Some(ref span) => at = span.start,
                    }
                }
            }
            // Instead of using the NFA's unanchored start state, we actually
            // always use its anchored starting state. As a result, when doing
            // an unanchored search, we need to simulate our own '(?s-u:.)*?'
            // prefix, to permit a match to appear anywhere.
            //
            // Now, we don't *have* to do things this way. We could use the
            // NFA's unanchored starting state and do one 'epsilon_closure'
            // call from that starting state before the main loop here. And
            // that is just as correct. However, it turns out to be slower
            // than our approach here because it slightly increases the cost
            // of processing each byte by requiring us to visit more NFA
            // states to deal with the additional NFA states in the unanchored
            // prefix. By simulating it explicitly here, we lower those costs
            // substantially. The cost is itself small, but it adds up for
            // large haystacks.
            //
            // In order to simulate the '(?s-u:.)*?' prefix---which is not
            // greedy---we are careful not to perform an epsilon closure on
            // the start state if we already have a match. Namely, if we
            // did otherwise, we would never reach a terminating condition
            // because there would always be additional states to process.
            // In effect, the exclusion of running 'epsilon_closure' when
            // we have a match corresponds to the "dead" states we have in
            // our DFA regex engines. Namely, in a DFA, match states merely
            // instruct the search execution to record the current offset as
            // the most recently seen match. It is the dead state that actually
            // indicates when to stop the search (other than EOF or quit
            // states).
            //
            // However, when 'allmatches' is true, the caller has asked us to
            // leave in every possible match state. This tends not to make a
            // whole lot of sense in unanchored searches, because it means the
            // search really cannot terminate until EOF. And often, in that
            // case, you wind up skipping over a bunch of matches and are left
            // with the "last" match. Arguably, it just doesn't make a lot of
            // sense to run a 'leftmost' search (which is what this routine is)
            // with 'allmatches' set to true. But the DFAs support it and this
            // matches their behavior. (Generally, 'allmatches' is useful for
            // overlapping searches or leftmost anchored searches to find the
            // longest possible match by ignoring match priority.)
            //
            // Additionally, when we're running an anchored search, this
            // epsilon closure should only be computed at the beginning of the
            // search. If we re-computed it at every position, we would be
            // simulating an unanchored search when we were tasked to perform
            // an anchored search.
            if (!hm.is_some() || allmatches)
                && (!anchored || at == input.start())
            {
                // Since we are adding to the 'curr' active states and since
                // this is for the start ID, we use a slots slice that is
                // guaranteed to have the right length but where every element
                // is absent. This is exactly what we want, because this
                // epsilon closure is responsible for simulating an unanchored
                // '(?s:.)*?' prefix. It is specifically outside of any
                // capturing groups, and thus, using slots that are always
                // absent is correct.
                //
                // Note though that we can't just use '&mut []' here, since
                // this epsilon closure may traverse through 'Captures' epsilon
                // transitions, and thus must be able to write offsets to the
                // slots given which are later copied to slot values in 'curr'.
                let slots = next.slot_table.all_absent();
                self.epsilon_closure(stack, slots, curr, input, at, start_id);
            }
            if let Some(pid) = self.nexts(stack, curr, next, input, at, slots)
            {
                hm = Some(HalfMatch::new(pid, at));
            }
            // Unless the caller asked us to return early, we need to mush on
            // to see if we can extend our match. (But note that 'nexts' will
            // quit right after seeing a match when match_kind==LeftmostFirst,
            // as is consistent with leftmost-first match priority.)
            if input.get_earliest() && hm.is_some() {
                break;
            }
            core::mem::swap(curr, next);
            next.set.clear();
            at += 1;
        }
        instrument!(|c| c.eprint(&self.nfa));
        hm
    }