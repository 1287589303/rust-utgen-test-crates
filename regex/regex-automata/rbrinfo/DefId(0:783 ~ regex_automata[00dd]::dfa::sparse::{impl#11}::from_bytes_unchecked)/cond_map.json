{
  "regex-automata/src/dfa/sparse.rs:1894:18:1899:16": [
    {
      "Try": "StateID::try_from(universal_unanchored).map_err(|e| {\n                DeserializeError::state_id_error(\n                    e,\n                    \"universal unanchored start\",\n                )\n            })?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1866:13:1866:77": [
    {
      "Try": "wire::try_read_u32_as_usize(slice, \"sparse start table stride\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1913:34:1917:11": [
    {
      "Try": "wire::mul(\n            stride,\n            pattern_len.unwrap_or(0),\n            \"sparse invalid pattern length\",\n        )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1862:31:1862:63": [
    {
      "Try": "StartByteMap::from_bytes(slice)?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1859:26:1859:55": [
    {
      "Try": "StartKind::from_bytes(slice)?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1877:30:1877:68": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "maybe_pattern_len.as_u32() == u32::MAX",
          "lhs": "maybe_pattern_len.as_u32()",
          "rhs": "u32::MAX",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1868:12:1868:34": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ne",
          "expr": "stride != Start::len()",
          "lhs": "stride",
          "rhs": "Start::len()",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1926:31:1930:11": [
    {
      "Try": "wire::mul(\n            start_state_len,\n            StateID::SIZE,\n            \"sparse pattern table bytes length\",\n        )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1891:45:1891:77": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "universal_unanchored == u32::MAX",
          "lhs": "universal_unanchored",
          "rhs": "u32::MAX",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1882:12:1882:67": [
    {
      "Bool": {
        "Other": "pattern_len.map_or(false, |len| len > PatternID::LIMIT)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1922:13:1922:64": [
    {
      "Try": "wire::mul(2, stride, \"start state stride too big\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1948:17:1948:56": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "slice.as_ptr().as_usize() - slice_start",
          "lhs": "slice.as_ptr().as_usize()",
          "rhs": "slice_start",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1875:13:1875:79": [
    {
      "Try": "wire::try_read_u32_as_usize(slice, \"sparse start table patterns\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1905:43:1905:73": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "universal_anchored == u32::MAX",
          "lhs": "universal_anchored",
          "rhs": "u32::MAX",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1889:13:1889:69": [
    {
      "Try": "wire::try_read_u32(slice, \"universal unanchored start\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1908:18:1910:16": [
    {
      "Try": "StateID::try_from(universal_anchored).map_err(|e| {\n                DeserializeError::state_id_error(e, \"universal anchored start\")\n            })?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1903:13:1903:67": [
    {
      "Try": "wire::try_read_u32(slice, \"universal anchored start\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1931:9:1935:11": [
    {
      "Try": "wire::check_slice_len(\n            slice,\n            table_bytes_len,\n            \"sparse start ID table\",\n        )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1921:31:1925:11": [
    {
      "Try": "wire::add(\n            wire::mul(2, stride, \"start state stride too big\")?,\n            pattern_table_size,\n            \"sparse invalid 'any' pattern starts size\",\n        )?"
    }
  ]
}