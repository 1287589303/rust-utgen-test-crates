{
  "regex-automata/src/dfa/sparse.rs:1406:21:1406:40": [
    {
      "Bool": {
        "Other": "is_actually_special"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1396:15:1396:50": [
    {
      "Bool": {
        "Binary": {
          "kind": "Lt",
          "expr": "id.as_usize() < self.sparse().len()",
          "lhs": "id.as_usize()",
          "rhs": "self.sparse().len()",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1451:25:1451:47": [
    {
      "Bool": {
        "Other": "verified.contains(&to)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1460:12:1460:33": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ne",
          "expr": "len != self.state_len",
          "lhs": "len",
          "rhs": "self.state_len",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1438:22:1438:37": [
    {
      "For": {
        "iter_var": "i",
        "iter_range": "0..state.ntrans"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1414:25:1414:48": [
    {
      "Try": "self.try_state(sp, id)?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1401:43:1401:63": [
    {
      "Bool": {
        "Other": "sp.is_dead_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1400:16:1400:39": [
    {
      "Bool": {
        "Other": "sp.is_special_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1403:24:1403:45": [
    {
      "Bool": {
        "Other": "sp.is_match_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1405:24:1405:45": [
    {
      "Bool": {
        "Other": "sp.is_accel_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1404:24:1404:45": [
    {
      "Bool": {
        "Other": "sp.is_start_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1417:31:1421:15": [
    {
      "Try": "wire::add(\n                id.as_usize(),\n                state.write_to_len(),\n                \"next state ID offset\",\n            )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1417:18:1424:16": [
    {
      "Try": "StateID::new(wire::add(\n                id.as_usize(),\n                state.write_to_len(),\n                \"next state ID offset\",\n            )?)\n            .map_err(|err| {\n                DeserializeError::state_id_error(err, \"next state ID offset\")\n            })?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1436:22:1436:35": [
    {
      "For": {
        "iter_var": "state",
        "iter_range": "self.states()"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1402:24:1402:44": [
    {
      "Bool": {
        "Other": "sp.is_quit_state(id)"
      }
    }
  ]
}