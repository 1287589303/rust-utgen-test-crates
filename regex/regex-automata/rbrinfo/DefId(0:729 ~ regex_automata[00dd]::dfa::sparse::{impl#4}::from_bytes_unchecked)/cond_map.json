{
  "regex-automata/src/dfa/sparse.rs:1051:27:1051:75": [
    {
      "Try": "Transitions::from_bytes_unchecked(&slice[nr..])?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1054:27:1054:74": [
    {
      "Try": "StartTable::from_bytes_unchecked(&slice[nr..])?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1042:15:1042:57": [
    {
      "Try": "wire::read_endianness_check(&slice[nr..])?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1041:15:1041:53": [
    {
      "Try": "wire::read_label(&slice[nr..], LABEL)?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1048:30:1048:62": [
    {
      "Try": "Flags::from_bytes(&slice[nr..])?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1065:32:1065:66": [
    {
      "Try": "ByteSet::from_bytes(&slice[nr..])?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1043:15:1043:57": [
    {
      "Try": "wire::read_version(&slice[nr..], VERSION)?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1059:12:1059:55": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ge",
          "expr": "special.max.as_usize() >= tt.sparse().len()",
          "lhs": "special.max.as_usize()",
          "rhs": "tt.sparse().len()",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1057:32:1057:66": [
    {
      "Try": "Special::from_bytes(&slice[nr..])?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1045:23:1045:72": [
    {
      "Try": "wire::try_read_u32(&slice[nr..], \"unused space\")?"
    }
  ]
}