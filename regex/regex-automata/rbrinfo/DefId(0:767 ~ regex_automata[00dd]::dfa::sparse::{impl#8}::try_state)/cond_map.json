{
  "regex-automata/src/dfa/sparse.rs:1608:17:1608:70": [
    {
      "Try": "wire::mul(npats, 4, \"sparse pattern ID byte length\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1543:25:1543:34": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "(1 << 15)",
          "lhs": "1",
          "rhs": "15",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1551:12:1551:20": [
    {
      "Bool": {
        "Other": "is_match"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1616:17:1619:19": [
    {
      "Try": "wire::read_pattern_id(\n                    patbytes,\n                    \"sparse pattern ID in try_state\",\n                )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1635:12:1635:45": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ne",
          "expr": "sp.is_match_state(id) != is_match",
          "lhs": "sp.is_match_state(id)",
          "rhs": "is_match",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1630:12:1630:33": [
    {
      "Bool": {
        "Other": "sp.is_match_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1555:32:1555:53": [
    {
      "Bool": {
        "Other": "sp.is_match_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1546:28:1546:39": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "ntrans == 0",
          "lhs": "ntrans",
          "rhs": "0",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1544:20:1544:29": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "(1 << 15)",
          "lhs": "1",
          "rhs": "15",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1655:19:1655:33": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "accel_len == 0",
          "lhs": "accel_len",
          "rhs": "0",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1565:9:1565:77": [
    {
      "Try": "wire::check_slice_len(state, input_ranges_len, \"sparse byte pairs\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1601:16:1601:26": [
    {
      "Bool": {
        "Binary": {
          "kind": "Eq",
          "expr": "npats == 0",
          "lhs": "npats",
          "rhs": "0",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1681:43:1681:59": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "state.ntrans - 1",
          "lhs": "state.ntrans",
          "rhs": "1",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1651:12:1651:25": [
    {
      "Bool": {
        "Binary": {
          "kind": "Gt",
          "expr": "accel_len > 3",
          "lhs": "accel_len",
          "rhs": "3",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1581:9:1581:74": [
    {
      "Try": "wire::check_slice_len(state, next_len, \"sparse trans state IDs\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1665:9:1669:11": [
    {
      "Try": "wire::check_slice_len(\n            state,\n            accel_len,\n            \"sparse corrupt accelerator length\",\n        )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1681:12:1681:61": [
    {
      "Bool": {
        "Other": "sp.is_quit_state(state.next_at(state.ntrans - 1))"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1570:16:1570:27": [
    {
      "Bool": {
        "Binary": {
          "kind": "Gt",
          "expr": "start > end",
          "lhs": "start",
          "rhs": "end",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1597:39:1597:47": [
    {
      "Bool": {
        "Other": "is_match"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1615:29:1615:64": [
    {
      "For": {
        "iter_var": "patbytes",
        "iter_range": "pattern_ids.chunks(PatternID::SIZE)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1542:13:1542:75": [
    {
      "Try": "wire::try_read_u16_as_usize(state, \"state transition length\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1533:12:1533:47": [
    {
      "Bool": {
        "Binary": {
          "kind": "Gt",
          "expr": "id.as_usize() > self.sparse().len()",
          "lhs": "id.as_usize()",
          "rhs": "self.sparse().len()",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1584:24:1584:50": [
    {
      "For": {
        "iter_var": "idbytes",
        "iter_range": "next.chunks(self.id_len())"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1599:17:1599:73": [
    {
      "Try": "wire::try_read_u32_as_usize(state, \"pattern ID length\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1543:24:1543:49": [
    {
      "Bool": {
        "Binary": {
          "kind": "Ne",
          "expr": "((1 << 15) & ntrans) != 0",
          "lhs": "((1 << 15) & ntrans)",
          "rhs": "0",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1646:12:1646:28": [
    {
      "Bool": {
        "Other": "state.is_empty()"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1655:37:1655:58": [
    {
      "Bool": {
        "Other": "sp.is_accel_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1551:25:1551:46": [
    {
      "Bool": {
        "Other": "sp.is_match_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1555:20:1555:28": [
    {
      "Bool": {
        "Other": "is_match"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1586:17:1586:78": [
    {
      "Try": "wire::read_state_id(idbytes, \"sparse state ID in try_state\")?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1625:12:1625:20": [
    {
      "Bool": {
        "Other": "is_match"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1625:24:1625:46": [
    {
      "Bool": {
        "Other": "pattern_ids.is_empty()"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1659:19:1659:32": [
    {
      "Bool": {
        "Binary": {
          "kind": "Gt",
          "expr": "accel_len > 0",
          "lhs": "accel_len",
          "rhs": "0",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1587:13:1591:15": [
    {
      "Try": "wire::check_slice_len(\n                self.sparse(),\n                id.as_usize(),\n                \"invalid sparse state ID\",\n            )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1543:24:1543:44": [
    {
      "Bool": {
        "Binary": {
          "kind": "Other",
          "expr": "((1 << 15) & ntrans)",
          "lhs": "(1 << 15)",
          "rhs": "ntrans",
          "cmp_with_int": false
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1609:13:1613:15": [
    {
      "Try": "wire::check_slice_len(\n                state,\n                pattern_ids_len,\n                \"sparse pattern IDs\",\n            )?"
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1568:21:1568:43": [
    {
      "For": {
        "iter_var": "pair",
        "iter_range": "input_ranges.chunks(2)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1659:37:1659:58": [
    {
      "Bool": {
        "Other": "sp.is_accel_state(id)"
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1546:12:1546:24": [
    {
      "Bool": {
        "Binary": {
          "kind": "Gt",
          "expr": "ntrans > 257",
          "lhs": "ntrans",
          "rhs": "257",
          "cmp_with_int": true
        }
      }
    }
  ],
  "regex-automata/src/dfa/sparse.rs:1630:37:1630:59": [
    {
      "Bool": {
        "Other": "pattern_ids.is_empty()"
      }
    }
  ]
}