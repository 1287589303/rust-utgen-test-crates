use core::cmp::Ordering;
use alloc::{boxed::Box, string::String, vec, vec::Vec};
pub use crate::ast::visitor::{visit, Visitor};
#[derive(Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct Alternation {
    /// The span of this alternation.
    pub span: Span,
    /// The alternate regular expressions.
    pub asts: Vec<Ast>,
}
#[derive(Clone, Copy, Eq, PartialEq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub struct Span {
    /// The start byte offset.
    pub start: Position,
    /// The end byte offset.
    pub end: Position,
}
#[derive(Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
pub enum Ast {
    /// An empty regex that matches everything.
    Empty(Box<Span>),
    /// A set of flags, e.g., `(?is)`.
    Flags(Box<SetFlags>),
    /// A single character literal, which includes escape sequences.
    Literal(Box<Literal>),
    /// The "any character" class.
    Dot(Box<Span>),
    /// A single zero-width assertion.
    Assertion(Box<Assertion>),
    /// A single Unicode character class, e.g., `\pL` or `\p{Greek}`.
    ClassUnicode(Box<ClassUnicode>),
    /// A single perl character class, e.g., `\d` or `\W`.
    ClassPerl(Box<ClassPerl>),
    /// A single bracketed character class set, which may contain zero or more
    /// character ranges and/or zero or more nested classes. e.g.,
    /// `[a-zA-Z\pL]`.
    ClassBracketed(Box<ClassBracketed>),
    /// A repetition operator applied to an arbitrary regular expression.
    Repetition(Box<Repetition>),
    /// A grouped regular expression.
    Group(Box<Group>),
    /// An alternation of regular expressions.
    Alternation(Box<Alternation>),
    /// A concatenation of regular expressions.
    Concat(Box<Concat>),
}
impl Alternation {
    pub fn into_ast(mut self) -> Ast {
        match self.asts.len() {
            0 => Ast::empty(self.span),
            1 => self.asts.pop().unwrap(),
            _ => Ast::alternation(self),
        }
    }
}
impl Ast {
    pub fn empty(span: Span) -> Ast {
        Ast::Empty(Box::new(span))
    }
    pub fn flags(e: SetFlags) -> Ast {}
    pub fn literal(e: Literal) -> Ast {}
    pub fn dot(span: Span) -> Ast {}
    pub fn assertion(e: Assertion) -> Ast {}
    pub fn class_unicode(e: ClassUnicode) -> Ast {}
    pub fn class_perl(e: ClassPerl) -> Ast {}
    pub fn class_bracketed(e: ClassBracketed) -> Ast {}
    pub fn repetition(e: Repetition) -> Ast {}
    pub fn group(e: Group) -> Ast {}
    pub fn alternation(e: Alternation) -> Ast {
        Ast::Alternation(Box::new(e))
    }
    pub fn concat(e: Concat) -> Ast {}
    pub fn span(&self) -> &Span {}
    pub fn is_empty(&self) -> bool {}
    fn has_subexprs(&self) -> bool {}
}
