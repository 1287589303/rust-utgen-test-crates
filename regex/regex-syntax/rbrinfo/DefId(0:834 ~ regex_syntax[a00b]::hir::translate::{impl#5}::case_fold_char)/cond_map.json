{
  "regex-syntax/src/hir/translate.rs:856:17:856:20": [
    {
      "Bool": {
        "Other": "map"
      }
    }
  ],
  "regex-syntax/src/hir/translate.rs:846:13:846:44": [
    {
      "Bool": {
        "Other": "self.flags().case_insensitive()"
      }
    }
  ],
  "regex-syntax/src/hir/translate.rs:849:12:849:34": [
    {
      "Bool": {
        "Other": "self.flags().unicode()"
      }
    }
  ],
  "regex-syntax/src/hir/translate.rs:868:17:868:29": [
    {
      "Bool": {
        "Other": "c.is_ascii()"
      }
    }
  ],
  "regex-syntax/src/hir/translate.rs:863:13:865:16": [
    {
      "Try": "cls.try_case_fold_simple().map_err(|_| {\n                self.error(span, ErrorKind::UnicodeCaseUnavailable)\n            })?"
    }
  ],
  "regex-syntax/src/hir/translate.rs:872:19:872:20": [
    {
      "Match": {
        "match_source": "regex-syntax/src/hir/translate.rs:872:19:872:20",
        "match_str": "c",
        "match_kind": "Other",
        "arms": {
          "regex-syntax/src/hir/translate.rs:873:29:873:38": {
            "pat": {
              "pat_str": "'a'..='z'",
              "kind": {
                "Other": null
              }
            },
            "guard": null,
            "body_source": "regex-syntax/src/hir/translate.rs:873:42:873:44"
          },
          "regex-syntax/src/hir/translate.rs:873:17:873:26": {
            "pat": {
              "pat_str": "'A'..='Z'",
              "kind": {
                "Other": null
              }
            },
            "guard": null,
            "body_source": "regex-syntax/src/hir/translate.rs:873:42:873:44"
          },
          "regex-syntax/src/hir/translate.rs:874:17:874:18": {
            "pat": {
              "pat_str": "_",
              "kind": "Wild"
            },
            "guard": null,
            "body_source": "regex-syntax/src/hir/translate.rs:874:22:874:37"
          }
        }
      }
    }
  ],
  "regex-syntax/src/hir/translate.rs:851:23:855:20": [
    {
      "Try": "unicode::SimpleCaseFolder::new()\n                .map(|f| f.overlaps(c, c))\n                .map_err(|_| {\n                    self.error(span, ErrorKind::UnicodeCaseUnavailable)\n                })?"
    }
  ]
}