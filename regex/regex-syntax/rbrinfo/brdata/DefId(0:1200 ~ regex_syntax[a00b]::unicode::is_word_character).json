{
  "name": "regex_syntax::unicode::is_word_character",
  "mod_info": {
    "name": "unicode",
    "loc": "regex-syntax/src/lib.rs:193:1:193:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/unicode.rs:463:1:492:2",
  "doc": "/// Returns true only if the given codepoint is in the `\\w` character class.\n///\n/// If the `unicode-perl` feature is not enabled, then this returns an error.\n",
  "code": [
    "pub fn is_word_character(c: char) -> Result<bool, UnicodeWordError> {",
    "    #[cfg(not(feature = \"unicode-perl\"))]",
    "    fn imp(_: char) -> Result<bool, UnicodeWordError> {",
    "        Err(UnicodeWordError(()))",
    "    }",
    "",
    "    #[cfg(feature = \"unicode-perl\")]",
    "    fn imp(c: char) -> Result<bool, UnicodeWordError> {",
    "        use crate::{is_word_byte, unicode_tables::perl_word::PERL_WORD};",
    "",
    "        if u8::try_from(c).map_or(false, is_word_byte) {",
    "            return Ok(true);",
    "        }",
    "        Ok(PERL_WORD",
    "            .binary_search_by(|&(start, end)| {",
    "                use core::cmp::Ordering;",
    "",
    "                if start <= c && c <= end {",
    "                    Ordering::Equal",
    "                } else if start > c {",
    "                    Ordering::Greater",
    "                } else {",
    "                    Ordering::Less",
    "                }",
    "            })",
    "            .is_ok())",
    "    }",
    "",
    "    imp(c)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}