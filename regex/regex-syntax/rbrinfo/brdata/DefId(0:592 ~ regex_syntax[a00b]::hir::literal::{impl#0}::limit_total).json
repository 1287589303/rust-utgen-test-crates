{
  "name": "regex_syntax::hir::literal::{impl#0}::limit_total",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:42:1:42:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal.rs:385:5:388:6",
  "doc": "/// Configure a limit on the total number of literals that will be\n/// returned.\n///\n/// This is useful as a practical measure for avoiding the creation of\n/// large sequences of literals. While the extractor will automatically\n/// handle local creations of large sequences (for example, `[A-Z]` yields\n/// an infinite sequence by default), large sequences can be created\n/// through non-local means as well.\n///\n/// For example, `[ab]{3}{3}` would yield a sequence of length `512 = 2^9`\n/// despite each of the repetitions being small on their own. This limit\n/// thus represents a \"catch all\" for avoiding locally small sequences from\n/// combining into large sequences.\n///\n/// # Example\n///\n/// This example shows how reducing the limit will change the literal\n/// sequence returned.\n///\n/// ```\n/// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n///\n/// let hir = parse(r\"[ab]{2}{2}\")?;\n///\n/// let got = Extractor::new().extract(&hir);\n/// let expected = Seq::new([\n///     \"aaaa\", \"aaab\", \"aaba\", \"aabb\",\n///     \"abaa\", \"abab\", \"abba\", \"abbb\",\n///     \"baaa\", \"baab\", \"baba\", \"babb\",\n///     \"bbaa\", \"bbab\", \"bbba\", \"bbbb\",\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// // The default limit is not too big, but big enough to extract all\n/// // literals from '[ab]{2}{2}'. If we shrink the limit to less than 16,\n/// // then we'll get a truncated set. Notice that it returns a sequence of\n/// // length 4 even though our limit was 10. This is because the sequence\n/// // is difficult to increase without blowing the limit. Notice also\n/// // that every literal in the sequence is now inexact because they were\n/// // stripped of some suffix.\n/// let got = Extractor::new().limit_total(10).extract(&hir);\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"aa\"),\n///     Literal::inexact(\"ab\"),\n///     Literal::inexact(\"ba\"),\n///     Literal::inexact(\"bb\"),\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n",
  "code": [
    "pub fn limit_total(&mut self, limit: usize) -> &mut Extractor {",
    "    self.limit_total = limit;",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}