{
  "name": "regex_syntax::hir::{impl#5}::literal",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:342:5:351:6",
  "doc": "/// Creates a literal HIR expression.\n///\n/// This accepts anything that can be converted into a `Box<[u8]>`.\n///\n/// Note that there is no mechanism for storing a `char` or a `Box<str>`\n/// in an HIR. Everything is \"just bytes.\" Whether a `Literal` (or\n/// any HIR node) matches valid UTF-8 exclusively can be queried via\n/// [`Properties::is_utf8`].\n///\n/// # Example\n///\n/// This example shows that concatenations of `Literal` HIR values will\n/// automatically get flattened and combined together. So for example, even\n/// if you concat multiple `Literal` values that are themselves not valid\n/// UTF-8, they might add up to valid UTF-8. This also demonstrates just\n/// how \"smart\" Hir's smart constructors are.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, HirKind, Literal};\n///\n/// let literals = vec![\n///     Hir::literal([0xE2]),\n///     Hir::literal([0x98]),\n///     Hir::literal([0x83]),\n/// ];\n/// // Each literal, on its own, is invalid UTF-8.\n/// assert!(literals.iter().all(|hir| !hir.properties().is_utf8()));\n///\n/// let concat = Hir::concat(literals);\n/// // But the concatenation is valid UTF-8!\n/// assert!(concat.properties().is_utf8());\n///\n/// // And also notice that the literals have been concatenated into a\n/// // single `Literal`, to the point where there is no explicit `Concat`!\n/// let expected = HirKind::Literal(Literal(Box::from(\"☃\".as_bytes())));\n/// assert_eq!(&expected, concat.kind());\n/// ```\n///\n/// # Example: building a literal from a `char`\n///\n/// This example shows how to build a single `Hir` literal from a `char`\n/// value. Since a [`Literal`] is just bytes, we just need to UTF-8\n/// encode a `char` value:\n///\n/// ```\n/// use regex_syntax::hir::{Hir, HirKind, Literal};\n///\n/// let ch = '☃';\n/// let got = Hir::literal(ch.encode_utf8(&mut [0; 4]).as_bytes());\n///\n/// let expected = HirKind::Literal(Literal(Box::from(\"☃\".as_bytes())));\n/// assert_eq!(&expected, got.kind());\n/// ```\n",
  "code": [
    "pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir {",
    "    let bytes = lit.into();",
    "    if bytes.is_empty() {",
    "        return Hir::empty();",
    "    }",
    "",
    "    let lit = Literal(bytes);",
    "    let props = Properties::literal(&lit);",
    "    Hir { kind: HirKind::Literal(lit), props }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "bytes.is_empty()",
          "norm": null,
          "value": "true",
          "line": 344,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        13,
        14,
        15
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "bytes.is_empty()",
          "norm": null,
          "value": "false",
          "line": 344,
          "bound": null
        }
      ],
      "ret": "Hir { kind: HirKind::Literal(lit), props }",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        15
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}