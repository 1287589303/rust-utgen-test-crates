{
  "name": "regex_syntax::hir::literal::{impl#4}::minimize_by_preference",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:42:1:42:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal.rs:1463:5:1467:6",
  "doc": "/// Shrinks this seq to its minimal size while respecting the preference\n/// order of its literals.\n///\n/// While this routine will remove duplicate literals from this seq, it\n/// will also remove literals that can never match in a leftmost-first or\n/// \"preference order\" search. Similar to [`Seq::dedup`], if a literal is\n/// deduped, then the one that remains is made inexact.\n///\n/// This is a no-op on seqs that are empty or not finite.\n///\n/// # Example\n///\n/// This example shows the difference between `{sam, samwise}` and\n/// `{samwise, sam}`.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// // If 'sam' comes before 'samwise' and a preference order search is\n/// // executed, then 'samwise' can never match.\n/// let mut seq = Seq::new(&[\"sam\", \"samwise\"]);\n/// seq.minimize_by_preference();\n/// assert_eq!(Seq::from_iter([Literal::inexact(\"sam\")]), seq);\n///\n/// // But if they are reversed, then it's possible for 'samwise' to match\n/// // since it is given higher preference.\n/// let mut seq = Seq::new(&[\"samwise\", \"sam\"]);\n/// seq.minimize_by_preference();\n/// assert_eq!(Seq::new(&[\"samwise\", \"sam\"]), seq);\n/// ```\n///\n/// This example shows that if an empty string is in this seq, then\n/// anything that comes after it can never match.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// // An empty string is a prefix of all strings, so it automatically\n/// // inhibits any subsequent strings from matching.\n/// let mut seq = Seq::new(&[\"foo\", \"bar\", \"\", \"quux\", \"fox\"]);\n/// seq.minimize_by_preference();\n/// let expected = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::exact(\"bar\"),\n///     Literal::inexact(\"\"),\n/// ]);\n/// assert_eq!(expected, seq);\n///\n/// // And of course, if it's at the beginning, then it makes it impossible\n/// // for anything else to match.\n/// let mut seq = Seq::new(&[\"\", \"foo\", \"quux\", \"fox\"]);\n/// seq.minimize_by_preference();\n/// assert_eq!(Seq::from_iter([Literal::inexact(\"\")]), seq);\n/// ```\n",
  "code": [
    "pub fn minimize_by_preference(&mut self) {",
    "    if let Some(ref mut lits) = self.literals {",
    "        PreferenceTrie::minimize(lits, false);",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let Some(ref mut lits) = self.literals",
          "norm": null,
          "value": "true",
          "line": 1464,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        4,
        5
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let Some(ref mut lits) = self.literals",
          "norm": null,
          "value": "true",
          "line": 1464,
          "bound": null
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        5
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}