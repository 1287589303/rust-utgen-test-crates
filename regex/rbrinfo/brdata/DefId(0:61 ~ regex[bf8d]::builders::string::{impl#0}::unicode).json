{
  "name": "regex::builders::string::{impl#0}::unicode",
  "mod_info": {
    "name": "builders::string",
    "loc": "src/builders.rs:200:1:1355:2"
  },
  "visible": true,
  "loc": "src/builders.rs:293:9:296:10",
  "doc": "/// This configures Unicode mode for the entire pattern.\n///\n/// Enabling Unicode mode does a number of things:\n///\n/// * Most fundamentally, it causes the fundamental atom of matching\n/// to be a single codepoint. When Unicode mode is disabled, it's a\n/// single byte. For example, when Unicode mode is enabled, `.` will\n/// match `ğŸ’©` once, where as it will match 4 times when Unicode mode\n/// is disabled. (Since the UTF-8 encoding of `ğŸ’©` is 4 bytes long.)\n/// * Case insensitive matching uses Unicode simple case folding rules.\n/// * Unicode character classes like `\\p{Letter}` and `\\p{Greek}` are\n/// available.\n/// * Perl character classes are Unicode aware. That is, `\\w`, `\\s` and\n/// `\\d`.\n/// * The word boundary assertions, `\\b` and `\\B`, use the Unicode\n/// definition of a word character.\n///\n/// Note that if Unicode mode is disabled, then the regex will fail to\n/// compile if it could match invalid UTF-8. For example, when Unicode\n/// mode is disabled, then since `.` matches any byte (except for\n/// `\\n`), then it can match invalid UTF-8 and thus building a regex\n/// from it will fail. Another example is `\\w` and `\\W`. Since `\\w` can\n/// only match ASCII bytes when Unicode mode is disabled, it's allowed.\n/// But `\\W` can match more than ASCII bytes, including invalid UTF-8,\n/// and so it is not allowed. This restriction can be lifted only by\n/// using a [`bytes::Regex`](crate::bytes::Regex).\n///\n/// For more details on the Unicode support in this crate, see the\n/// [Unicode section](crate#unicode) in this crate's top-level\n/// documentation.\n///\n/// The default for this is `true`.\n///\n/// # Example\n///\n/// ```\n/// use regex::RegexBuilder;\n///\n/// let re = RegexBuilder::new(r\"\\w\")\n///     .unicode(false)\n///     .build()\n///     .unwrap();\n/// // Normally greek letters would be included in \\w, but since\n/// // Unicode mode is disabled, it only matches ASCII letters.\n/// assert!(!re.is_match(\"Î´\"));\n///\n/// let re = RegexBuilder::new(r\"s\")\n///     .case_insensitive(true)\n///     .unicode(false)\n///     .build()\n///     .unwrap();\n/// // Normally 'Å¿' is included when searching for 's' case\n/// // insensitively due to Unicode's simple case folding rules. But\n/// // when Unicode mode is disabled, only ASCII case insensitive rules\n/// // are used.\n/// assert!(!re.is_match(\"Å¿\"));\n/// ```\n",
  "code": [
    "pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder {",
    "    self.builder.unicode(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}