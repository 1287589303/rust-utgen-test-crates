{
  "name": "regex::builders::string::{impl#1}::ignore_whitespace",
  "mod_info": {
    "name": "builders::string",
    "loc": "src/builders.rs:200:1:1355:2"
  },
  "visible": true,
  "loc": "src/builders.rs:1181:9:1187:10",
  "doc": "/// This configures verbose mode for all of the patterns.\n///\n/// When enabled, whitespace will treated as insignifcant in the\n/// pattern and `#` can be used to start a comment until the next new\n/// line.\n///\n/// Normally, in most places in a pattern, whitespace is treated\n/// literally. For example ` +` will match one or more ASCII whitespace\n/// characters.\n///\n/// When verbose mode is enabled, `\\#` can be used to match a literal\n/// `#` and `\\ ` can be used to match a literal ASCII whitespace\n/// character.\n///\n/// Verbose mode is useful for permitting regexes to be formatted and\n/// broken up more nicely. This may make them more easily readable.\n///\n/// This setting can also be configured using the inline flag `x` in\n/// the pattern.\n///\n/// The default for this is `false`.\n///\n/// # Example\n///\n/// ```\n/// use regex::RegexSetBuilder;\n///\n/// let pat = r\"\n///     \\b\n///     (?<first>\\p{Uppercase}\\w*)  # always start with uppercase letter\n///     [\\s--\\n]+                   # whitespace should separate names\n///     (?: # middle name can be an initial!\n///         (?:(?<initial>\\p{Uppercase})\\.|(?<middle>\\p{Uppercase}\\w*))\n///         [\\s--\\n]+\n///     )?\n///     (?<last>\\p{Uppercase}\\w*)\n///     \\b\n/// \";\n/// let re = RegexSetBuilder::new([pat])\n///     .ignore_whitespace(true)\n///     .build()\n///     .unwrap();\n/// assert!(re.is_match(\"Harry Potter\"));\n/// assert!(re.is_match(\"Harry J. Potter\"));\n/// assert!(re.is_match(\"Harry James Potter\"));\n/// assert!(!re.is_match(\"harry J. Potter\"));\n/// ```\n",
  "code": [
    "pub fn ignore_whitespace(",
    "    &mut self,",
    "    yes: bool,",
    ") -> &mut RegexSetBuilder {",
    "    self.builder.ignore_whitespace(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}