{
  "name": "regex::builders::string::{impl#0}::ignore_whitespace",
  "mod_info": {
    "name": "builders::string",
    "loc": "src/builders.rs:200:1:1355:2"
  },
  "visible": true,
  "loc": "src/builders.rs:616:9:619:10",
  "doc": "/// This configures verbose mode for the entire pattern.\n///\n/// When enabled, whitespace will treated as insignifcant in the\n/// pattern and `#` can be used to start a comment until the next new\n/// line.\n///\n/// Normally, in most places in a pattern, whitespace is treated\n/// literally. For example ` +` will match one or more ASCII whitespace\n/// characters.\n///\n/// When verbose mode is enabled, `\\#` can be used to match a literal\n/// `#` and `\\ ` can be used to match a literal ASCII whitespace\n/// character.\n///\n/// Verbose mode is useful for permitting regexes to be formatted and\n/// broken up more nicely. This may make them more easily readable.\n///\n/// This setting can also be configured using the inline flag `x` in\n/// the pattern.\n///\n/// The default for this is `false`.\n///\n/// # Example\n///\n/// ```\n/// use regex::RegexBuilder;\n///\n/// let pat = r\"\n///     \\b\n///     (?<first>\\p{Uppercase}\\w*)  # always start with uppercase letter\n///     [\\s--\\n]+                   # whitespace should separate names\n///     (?: # middle name can be an initial!\n///         (?:(?<initial>\\p{Uppercase})\\.|(?<middle>\\p{Uppercase}\\w*))\n///         [\\s--\\n]+\n///     )?\n///     (?<last>\\p{Uppercase}\\w*)\n///     \\b\n/// \";\n/// let re = RegexBuilder::new(pat)\n///     .ignore_whitespace(true)\n///     .build()\n///     .unwrap();\n///\n/// let caps = re.captures(\"Harry Potter\").unwrap();\n/// assert_eq!(\"Harry\", &caps[\"first\"]);\n/// assert_eq!(\"Potter\", &caps[\"last\"]);\n///\n/// let caps = re.captures(\"Harry J. Potter\").unwrap();\n/// assert_eq!(\"Harry\", &caps[\"first\"]);\n/// // Since a middle name/initial isn't required for an overall match,\n/// // we can't assume that 'initial' or 'middle' will be populated!\n/// assert_eq!(Some(\"J\"), caps.name(\"initial\").map(|m| m.as_str()));\n/// assert_eq!(None, caps.name(\"middle\").map(|m| m.as_str()));\n/// assert_eq!(\"Potter\", &caps[\"last\"]);\n///\n/// let caps = re.captures(\"Harry James Potter\").unwrap();\n/// assert_eq!(\"Harry\", &caps[\"first\"]);\n/// // Since a middle name/initial isn't required for an overall match,\n/// // we can't assume that 'initial' or 'middle' will be populated!\n/// assert_eq!(None, caps.name(\"initial\").map(|m| m.as_str()));\n/// assert_eq!(Some(\"James\"), caps.name(\"middle\").map(|m| m.as_str()));\n/// assert_eq!(\"Potter\", &caps[\"last\"]);\n/// ```\n",
  "code": [
    "pub fn ignore_whitespace(&mut self, yes: bool) -> &mut RegexBuilder {",
    "    self.builder.ignore_whitespace(yes);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}