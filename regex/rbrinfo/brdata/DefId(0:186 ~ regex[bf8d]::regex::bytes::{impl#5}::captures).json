{
  "name": "regex::regex::bytes::{impl#5}::captures",
  "mod_info": {
    "name": "regex::bytes",
    "loc": "src/regex/mod.rs:1:1:1:22"
  },
  "visible": true,
  "loc": "src/regex/bytes.rs:353:5:355:6",
  "doc": "/// This routine searches for the first match of this regex in the haystack\n/// given, and if found, returns not only the overall match but also the\n/// matches of each capture group in the regex. If no match is found, then\n/// `None` is returned.\n///\n/// Capture group `0` always corresponds to an implicit unnamed group that\n/// includes the entire match. If a match is found, this group is always\n/// present. Subsequent groups may be named and are numbered, starting\n/// at 1, by the order in which the opening parenthesis appears in the\n/// pattern. For example, in the pattern `(?<a>.(?<b>.))(?<c>.)`, `a`,\n/// `b` and `c` correspond to capture group indices `1`, `2` and `3`,\n/// respectively.\n///\n/// You should only use `captures` if you need access to the capture group\n/// matches. Otherwise, [`Regex::find`] is generally faster for discovering\n/// just the overall match.\n///\n/// # Example\n///\n/// Say you have some haystack with movie names and their release years,\n/// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for\n/// strings looking like that, while also extracting the movie name and its\n/// release year separately. The example below shows how to do that.\n///\n/// ```\n/// use regex::bytes::Regex;\n///\n/// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n/// let hay = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(hay).unwrap();\n/// assert_eq!(caps.get(0).unwrap().as_bytes(), b\"'Citizen Kane' (1941)\");\n/// assert_eq!(caps.get(1).unwrap().as_bytes(), b\"Citizen Kane\");\n/// assert_eq!(caps.get(2).unwrap().as_bytes(), b\"1941\");\n/// // You can also access the groups by index using the Index notation.\n/// // Note that this will panic on an invalid index. In this case, these\n/// // accesses are always correct because the overall regex will only\n/// // match when these capture groups match.\n/// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n/// assert_eq!(&caps[1], b\"Citizen Kane\");\n/// assert_eq!(&caps[2], b\"1941\");\n/// ```\n///\n/// Note that the full match is at capture group `0`. Each subsequent\n/// capture group is indexed by the order of its opening `(`.\n///\n/// We can make this example a bit clearer by using *named* capture groups:\n///\n/// ```\n/// use regex::bytes::Regex;\n///\n/// let re = Regex::new(r\"'(?<title>[^']+)'\\s+\\((?<year>\\d{4})\\)\").unwrap();\n/// let hay = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(hay).unwrap();\n/// assert_eq!(caps.get(0).unwrap().as_bytes(), b\"'Citizen Kane' (1941)\");\n/// assert_eq!(caps.name(\"title\").unwrap().as_bytes(), b\"Citizen Kane\");\n/// assert_eq!(caps.name(\"year\").unwrap().as_bytes(), b\"1941\");\n/// // You can also access the groups by name using the Index notation.\n/// // Note that this will panic on an invalid group name. In this case,\n/// // these accesses are always correct because the overall regex will\n/// // only match when these capture groups match.\n/// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n/// assert_eq!(&caps[\"title\"], b\"Citizen Kane\");\n/// assert_eq!(&caps[\"year\"], b\"1941\");\n/// ```\n///\n/// Here we name the capture groups, which we can access with the `name`\n/// method or the `Index` notation with a `&str`. Note that the named\n/// capture groups are still accessible with `get` or the `Index` notation\n/// with a `usize`.\n///\n/// The `0`th capture group is always unnamed, so it must always be\n/// accessed with `get(0)` or `[0]`.\n///\n/// Finally, one other way to to get the matched substrings is with the\n/// [`Captures::extract`] API:\n///\n/// ```\n/// use regex::bytes::Regex;\n///\n/// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n/// let hay = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let (full, [title, year]) = re.captures(hay).unwrap().extract();\n/// assert_eq!(full, b\"'Citizen Kane' (1941)\");\n/// assert_eq!(title, b\"Citizen Kane\");\n/// assert_eq!(year, b\"1941\");\n/// ```\n",
  "code": [
    "pub fn captures<'h>(&self, haystack: &'h [u8]) -> Option<Captures<'h>> {",
    "    self.captures_at(haystack, 0)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}