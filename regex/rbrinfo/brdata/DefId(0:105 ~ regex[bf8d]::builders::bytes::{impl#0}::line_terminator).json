{
  "name": "regex::builders::bytes::{impl#0}::line_terminator",
  "mod_info": {
    "name": "builders::bytes",
    "loc": "src/builders.rs:1357:1:2539:2"
  },
  "visible": true,
  "loc": "src/builders.rs:1694:9:1697:10",
  "doc": "/// Configures the line terminator to be used by the regex.\n///\n/// The line terminator is relevant in two ways for a particular regex:\n///\n/// * When dot-matches-new-line mode is *not* enabled (the default),\n/// then `.` will match any character except for the configured line\n/// terminator.\n/// * When multi-line mode is enabled (not the default), then `^` and\n/// `$` will match immediately after and before, respectively, a line\n/// terminator.\n///\n/// In both cases, if CRLF mode is enabled in a particular context,\n/// then it takes precedence over any configured line terminator.\n///\n/// This option cannot be configured from within the pattern.\n///\n/// The default line terminator is `\\n`.\n///\n/// # Example\n///\n/// This shows how to treat the NUL byte as a line terminator. This can\n/// be a useful heuristic when searching binary data.\n///\n/// ```\n/// use regex::bytes::RegexBuilder;\n///\n/// let re = RegexBuilder::new(r\"^foo$\")\n///     .multi_line(true)\n///     .line_terminator(b'\\x00')\n///     .build()\n///     .unwrap();\n/// let hay = b\"\\x00foo\\x00\";\n/// assert_eq!(Some(1..4), re.find(hay).map(|m| m.range()));\n/// ```\n///\n/// This example shows that the behavior of `.` is impacted by this\n/// setting as well:\n///\n/// ```\n/// use regex::bytes::RegexBuilder;\n///\n/// let re = RegexBuilder::new(r\".\")\n///     .line_terminator(b'\\x00')\n///     .build()\n///     .unwrap();\n/// assert!(re.is_match(b\"\\n\"));\n/// assert!(!re.is_match(b\"\\x00\"));\n/// ```\n///\n/// This shows that building a regex will work even when the byte\n/// given is not ASCII. This is unlike the top-level `Regex` API where\n/// matching invalid UTF-8 is not allowed.\n///\n/// Note though that you must disable Unicode mode. This is required\n/// because Unicode mode requires matching one codepoint at a time,\n/// and there is no way to match a non-ASCII byte as if it were a\n/// codepoint.\n///\n/// ```\n/// use regex::bytes::RegexBuilder;\n///\n/// assert!(\n///     RegexBuilder::new(r\".\")\n///         .unicode(false)\n///         .line_terminator(0x80)\n///         .build()\n///         .is_ok(),\n/// );\n/// ```\n",
  "code": [
    "pub fn line_terminator(&mut self, byte: u8) -> &mut RegexBuilder {",
    "    self.builder.line_terminator(byte);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}