{
  "name": "regex::regex::bytes::{impl#12}::expand",
  "mod_info": {
    "name": "regex::bytes",
    "loc": "src/regex/mod.rs:1:1:1:22"
  },
  "visible": true,
  "loc": "src/regex/bytes.rs:1853:5:1855:6",
  "doc": "/// Expands all instances of `$ref` in `replacement` to the corresponding\n/// capture group, and writes them to the `dst` buffer given. A `ref` can\n/// be a capture group index or a name. If `ref` doesn't refer to a capture\n/// group that participated in the match, then it is replaced with the\n/// empty string.\n///\n/// # Format\n///\n/// The format of the replacement string supports two different kinds of\n/// capture references: unbraced and braced.\n///\n/// For the unbraced format, the format supported is `$ref` where `name`\n/// can be any character in the class `[0-9A-Za-z_]`. `ref` is always\n/// the longest possible parse. So for example, `$1a` corresponds to the\n/// capture group named `1a` and not the capture group at index `1`. If\n/// `ref` matches `^[0-9]+$`, then it is treated as a capture group index\n/// itself and not a name.\n///\n/// For the braced format, the format supported is `${ref}` where `ref` can\n/// be any sequence of bytes except for `}`. If no closing brace occurs,\n/// then it is not considered a capture reference. As with the unbraced\n/// format, if `ref` matches `^[0-9]+$`, then it is treated as a capture\n/// group index and not a name.\n///\n/// The braced format is useful for exerting precise control over the name\n/// of the capture reference. For example, `${1}a` corresponds to the\n/// capture group reference `1` followed by the letter `a`, where as `$1a`\n/// (as mentioned above) corresponds to the capture group reference `1a`.\n/// The braced format is also useful for expressing capture group names\n/// that use characters not supported by the unbraced format. For example,\n/// `${foo[bar].baz}` refers to the capture group named `foo[bar].baz`.\n///\n/// If a capture group reference is found and it does not refer to a valid\n/// capture group, then it will be replaced with the empty string.\n///\n/// To write a literal `$`, use `$$`.\n///\n/// # Example\n///\n/// ```\n/// use regex::bytes::Regex;\n///\n/// let re = Regex::new(\n///     r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\",\n/// ).unwrap();\n/// let hay = b\"On 14-03-2010, I became a Tenneessee lamb.\";\n/// let caps = re.captures(hay).unwrap();\n///\n/// let mut dst = vec![];\n/// caps.expand(b\"year=$year, month=$month, day=$day\", &mut dst);\n/// assert_eq!(dst, b\"year=2010, month=03, day=14\");\n/// ```\n",
  "code": [
    "pub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>) {",
    "    self.caps.interpolate_bytes_into(self.haystack, replacement, dst);",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}