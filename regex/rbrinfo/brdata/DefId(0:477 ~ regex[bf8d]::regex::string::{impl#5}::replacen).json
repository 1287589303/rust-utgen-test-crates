{
  "name": "regex::regex::string::{impl#5}::replacen",
  "mod_info": {
    "name": "regex::string",
    "loc": "src/regex/mod.rs:2:1:2:23"
  },
  "visible": true,
  "loc": "src/regex/string.rs:907:5:961:6",
  "doc": "/// Replaces at most `limit` non-overlapping matches in the haystack with\n/// the replacement provided. If `limit` is `0`, then all non-overlapping\n/// matches are replaced. That is, `Regex::replace_all(hay, rep)` is\n/// equivalent to `Regex::replacen(hay, 0, rep)`.\n///\n/// If no match is found, then the haystack is returned unchanged. In that\n/// case, this implementation will likely return a `Cow::Borrowed` value\n/// such that no allocation is performed.\n///\n/// When a `Cow::Borrowed` is returned, the value returned is guaranteed\n/// to be equivalent to the `haystack` given.\n///\n/// The documentation for [`Regex::replace`] goes into more detail about\n/// what kinds of replacement strings are supported.\n///\n/// # Time complexity\n///\n/// Since iterators over all matches requires running potentially many\n/// searches on the haystack, and since each search has worst case\n/// `O(m * n)` time complexity, the overall worst case time complexity for\n/// this routine is `O(m * n^2)`.\n///\n/// Although note that the worst case time here has an upper bound given\n/// by the `limit` parameter.\n///\n/// # Fallibility\n///\n/// See the corresponding section in the docs for [`Regex::replace_all`]\n/// for tips on how to deal with a replacement routine that can fail.\n///\n/// # Example\n///\n/// This example shows how to flip the order of whitespace (excluding line\n/// terminators) delimited fields, and normalizes the whitespace that\n/// delimits the fields. But we only do it for the first two matches.\n///\n/// ```\n/// use regex::Regex;\n///\n/// let re = Regex::new(r\"(?m)^(\\S+)[\\s--\\r\\n]+(\\S+)$\").unwrap();\n/// let hay = \"\n/// Greetings  1973\n/// Wild\\t1973\n/// BornToRun\\t\\t\\t\\t1975\n/// Darkness                    1978\n/// TheRiver 1980\n/// \";\n/// let new = re.replacen(hay, 2, \"$2 $1\");\n/// assert_eq!(new, \"\n/// 1973 Greetings\n/// 1973 Wild\n/// BornToRun\\t\\t\\t\\t1975\n/// Darkness                    1978\n/// TheRiver 1980\n/// \");\n/// ```\n",
  "code": [
    "pub fn replacen<'h, R: Replacer>(",
    "    &self,",
    "    haystack: &'h str,",
    "    limit: usize,",
    "    mut rep: R,",
    ") -> Cow<'h, str> {",
    "    // If we know that the replacement doesn't have any capture expansions,",
    "    // then we can use the fast path. The fast path can make a tremendous",
    "    // difference:",
    "    //",
    "    //   1) We use `find_iter` instead of `captures_iter`. Not asking for",
    "    //      captures generally makes the regex engines faster.",
    "    //   2) We don't need to look up all of the capture groups and do",
    "    //      replacements inside the replacement string. We just push it",
    "    //      at each match and be done with it.",
    "    if let Some(rep) = rep.no_expansion() {",
    "        let mut it = self.find_iter(haystack).enumerate().peekable();",
    "        if it.peek().is_none() {",
    "            return Cow::Borrowed(haystack);",
    "        }",
    "        let mut new = String::with_capacity(haystack.len());",
    "        let mut last_match = 0;",
    "        for (i, m) in it {",
    "            new.push_str(&haystack[last_match..m.start()]);",
    "            new.push_str(&rep);",
    "            last_match = m.end();",
    "            if limit > 0 && i >= limit - 1 {",
    "                break;",
    "            }",
    "        }",
    "        new.push_str(&haystack[last_match..]);",
    "        return Cow::Owned(new);",
    "    }",
    "",
    "    // The slower path, which we use if the replacement may need access to",
    "    // capture groups.",
    "    let mut it = self.captures_iter(haystack).enumerate().peekable();",
    "    if it.peek().is_none() {",
    "        return Cow::Borrowed(haystack);",
    "    }",
    "    let mut new = String::with_capacity(haystack.len());",
    "    let mut last_match = 0;",
    "    for (i, cap) in it {",
    "        // unwrap on 0 is OK because captures only reports matches",
    "        let m = cap.get(0).unwrap();",
    "        new.push_str(&haystack[last_match..m.start()]);",
    "        rep.replace_append(&cap, &mut new);",
    "        last_match = m.end();",
    "        if limit > 0 && i >= limit - 1 {",
    "            break;",
    "        }",
    "    }",
    "    new.push_str(&haystack[last_match..]);",
    "    Cow::Owned(new)",
    "}"
  ],
  "size": {
    "chain": 10,
    "contra": 4,
    "min_set": 10
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "true",
          "line": 944,
          "bound": null
        }
      ],
      "ret": "Cow::Borrowed(haystack)",
      "path": [
        0,
        1,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        83,
        89,
        90
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 944,
          "bound": null
        },
        {
          "cond": "(i, cap) in it",
          "norm": null,
          "value": "true",
          "line": 949,
          "bound": null
        },
        {
          "cond": "limit > 0",
          "norm": "0 < limit",
          "value": "true",
          "line": 955,
          "bound": null
        },
        {
          "cond": "i >= limit - 1",
          "norm": null,
          "value": "true",
          "line": 955,
          "bound": "i == limit - 1"
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        56,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        90
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 944,
          "bound": null
        },
        {
          "cond": "(i, cap) in it",
          "norm": null,
          "value": "true",
          "line": 949,
          "bound": null
        },
        {
          "cond": "limit > 0",
          "norm": "0 < limit",
          "value": "true",
          "line": 955,
          "bound": null
        },
        {
          "cond": "i >= limit - 1",
          "norm": null,
          "value": "false",
          "line": 955,
          "bound": null
        },
        {
          "cond": "(i, cap) in it",
          "norm": null,
          "value": "false",
          "line": 949,
          "bound": null
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        56,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        68,
        70,
        71,
        72,
        51,
        52,
        53,
        55,
        57,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        90
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 944,
          "bound": null
        },
        {
          "cond": "(i, cap) in it",
          "norm": null,
          "value": "true",
          "line": 949,
          "bound": null
        },
        {
          "cond": "limit > 0",
          "norm": "0 < limit",
          "value": "false",
          "line": 955,
          "bound": "limit == 0"
        },
        {
          "cond": "(i, cap) in it",
          "norm": null,
          "value": "false",
          "line": 949,
          "bound": null
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        56,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        69,
        70,
        71,
        72,
        51,
        52,
        53,
        55,
        57,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        90
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 944,
          "bound": null
        },
        {
          "cond": "(i, cap) in it",
          "norm": null,
          "value": "false",
          "line": 949,
          "bound": null
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        55,
        57,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        90
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "true",
          "line": 924,
          "bound": null
        }
      ],
      "ret": "Cow::Borrowed(haystack)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        85,
        86,
        87,
        88,
        89,
        90
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 924,
          "bound": null
        },
        {
          "cond": "(i, m) in it",
          "norm": null,
          "value": "true",
          "line": 929,
          "bound": null
        },
        {
          "cond": "limit > 0",
          "norm": "0 < limit",
          "value": "true",
          "line": 933,
          "bound": null
        },
        {
          "cond": "i >= limit - 1",
          "norm": null,
          "value": "true",
          "line": 933,
          "bound": "i == limit - 1"
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        19,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        33,
        34,
        35,
        36,
        37,
        38,
        84,
        85,
        86,
        87,
        88,
        89,
        90
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 924,
          "bound": null
        },
        {
          "cond": "(i, m) in it",
          "norm": null,
          "value": "true",
          "line": 929,
          "bound": null
        },
        {
          "cond": "limit > 0",
          "norm": "0 < limit",
          "value": "true",
          "line": 933,
          "bound": null
        },
        {
          "cond": "i >= limit - 1",
          "norm": null,
          "value": "false",
          "line": 933,
          "bound": null
        },
        {
          "cond": "(i, m) in it",
          "norm": null,
          "value": "false",
          "line": 929,
          "bound": null
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        19,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        30,
        32,
        14,
        15,
        16,
        18,
        20,
        33,
        34,
        35,
        36,
        37,
        38,
        84,
        85,
        86,
        87,
        88,
        89,
        90
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 924,
          "bound": null
        },
        {
          "cond": "(i, m) in it",
          "norm": null,
          "value": "true",
          "line": 929,
          "bound": null
        },
        {
          "cond": "limit > 0",
          "norm": "0 < limit",
          "value": "false",
          "line": 933,
          "bound": "limit == 0"
        },
        {
          "cond": "(i, m) in it",
          "norm": null,
          "value": "false",
          "line": 929,
          "bound": null
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        19,
        21,
        22,
        23,
        24,
        25,
        26,
        31,
        32,
        14,
        15,
        16,
        18,
        20,
        33,
        34,
        35,
        36,
        37,
        38,
        84,
        85,
        86,
        87,
        88,
        89,
        90
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "let Some(rep) = rep.no_expansion()",
          "norm": null,
          "value": "true",
          "line": 922,
          "bound": null
        },
        {
          "cond": "it.peek().is_none()",
          "norm": null,
          "value": "false",
          "line": 924,
          "bound": null
        },
        {
          "cond": "(i, m) in it",
          "norm": null,
          "value": "false",
          "line": 929,
          "bound": null
        }
      ],
      "ret": "Cow::Owned(new)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        18,
        20,
        33,
        34,
        35,
        36,
        37,
        38,
        84,
        85,
        86,
        87,
        88,
        89,
        90
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}