{
  "name": "regex::builders::string::{impl#1}::line_terminator",
  "mod_info": {
    "name": "builders::string",
    "loc": "src/builders.rs:200:1:1355:2"
  },
  "visible": true,
  "loc": "src/builders.rs:1108:9:1111:10",
  "doc": "/// Configures the line terminator to be used by the regex.\n///\n/// The line terminator is relevant in two ways for a particular regex:\n///\n/// * When dot-matches-new-line mode is *not* enabled (the default),\n/// then `.` will match any character except for the configured line\n/// terminator.\n/// * When multi-line mode is enabled (not the default), then `^` and\n/// `$` will match immediately after and before, respectively, a line\n/// terminator.\n///\n/// In both cases, if CRLF mode is enabled in a particular context,\n/// then it takes precedence over any configured line terminator.\n///\n/// This option cannot be configured from within the pattern.\n///\n/// The default line terminator is `\\n`.\n///\n/// # Example\n///\n/// This shows how to treat the NUL byte as a line terminator. This can\n/// be a useful heuristic when searching binary data.\n///\n/// ```\n/// use regex::RegexSetBuilder;\n///\n/// let re = RegexSetBuilder::new([r\"^foo$\"])\n///     .multi_line(true)\n///     .line_terminator(b'\\x00')\n///     .build()\n///     .unwrap();\n/// let hay = \"\\x00foo\\x00\";\n/// assert!(re.is_match(hay));\n/// ```\n///\n/// This example shows that the behavior of `.` is impacted by this\n/// setting as well:\n///\n/// ```\n/// use regex::RegexSetBuilder;\n///\n/// let re = RegexSetBuilder::new([r\".\"])\n///     .line_terminator(b'\\x00')\n///     .build()\n///     .unwrap();\n/// assert!(re.is_match(\"\\n\"));\n/// assert!(!re.is_match(\"\\x00\"));\n/// ```\n///\n/// This shows that building a regex will fail if the byte given\n/// is not ASCII and the pattern could result in matching invalid\n/// UTF-8. This is because any singular non-ASCII byte is not valid\n/// UTF-8, and it is not permitted for a [`RegexSet`] to match invalid\n/// UTF-8. (It is permissible to use a non-ASCII byte when building a\n/// [`bytes::RegexSet`](crate::bytes::RegexSet).)\n///\n/// ```\n/// use regex::RegexSetBuilder;\n///\n/// assert!(\n///     RegexSetBuilder::new([r\".\"])\n///         .line_terminator(0x80)\n///         .build()\n///         .is_err()\n/// );\n/// // Note that using a non-ASCII byte isn't enough on its own to\n/// // cause regex compilation to fail. You actually have to make use\n/// // of it in the regex in a way that leads to matching invalid\n/// // UTF-8. If you don't, then regex compilation will succeed!\n/// assert!(\n///     RegexSetBuilder::new([r\"a\"])\n///         .line_terminator(0x80)\n///         .build()\n///         .is_ok()\n/// );\n/// ```\n",
  "code": [
    "pub fn line_terminator(&mut self, byte: u8) -> &mut RegexSetBuilder {",
    "    self.builder.line_terminator(byte);",
    "    self",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self",
      "path": [
        0,
        1
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}