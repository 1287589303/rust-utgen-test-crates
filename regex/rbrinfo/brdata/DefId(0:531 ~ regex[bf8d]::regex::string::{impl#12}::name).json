{
  "name": "regex::regex::string::{impl#12}::name",
  "mod_info": {
    "name": "regex::string",
    "loc": "src/regex/mod.rs:2:1:2:23"
  },
  "visible": true,
  "loc": "src/regex/string.rs:1708:5:1712:6",
  "doc": "/// Returns the `Match` associated with the capture group named `name`. If\n/// `name` isn't a valid capture group or it refers to a group that didn't\n/// match, then `None` is returned.\n///\n/// Note that unlike `caps[\"name\"]`, this returns a `Match` whose lifetime\n/// matches the lifetime of the haystack in this `Captures` value.\n/// Conversely, the substring returned by `caps[\"name\"]` has a lifetime\n/// of the `Captures` value, which is likely shorter than the lifetime of\n/// the haystack. In some cases, it may be necessary to use this method to\n/// access the matching substring instead of the `caps[\"name\"]` notation.\n///\n/// # Examples\n///\n/// Get the substring that matched with a default of an empty string if the\n/// group didn't participate in the match:\n///\n/// ```\n/// use regex::Regex;\n///\n/// let re = Regex::new(\n///     r\"[a-z]+(?:(?<numbers>[0-9]+)|(?<letters>[A-Z]+))\",\n/// ).unwrap();\n/// let caps = re.captures(\"abc123\").unwrap();\n///\n/// let numbers = caps.name(\"numbers\").map_or(\"\", |m| m.as_str());\n/// let letters = caps.name(\"letters\").map_or(\"\", |m| m.as_str());\n/// assert_eq!(numbers, \"123\");\n/// assert_eq!(letters, \"\");\n/// ```\n",
  "code": [
    "pub fn name(&self, name: &str) -> Option<Match<'h>> {",
    "    self.caps",
    "        .get_group_by_name(name)",
    "        .map(|sp| Match::new(self.haystack, sp.start, sp.end))",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}