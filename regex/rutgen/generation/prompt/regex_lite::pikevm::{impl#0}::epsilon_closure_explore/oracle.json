{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/pikevm.rs\n// crate name is regex_lite\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    int::{NonMaxUsize, U32},\n    nfa::{State, StateID, NFA},\n    pool::CachePoolGuard, utf8,\n};\npub(crate) trait U32 {\n    fn as_usize(self) -> usize;\n}\n#[derive(Clone, Debug)]\npub(crate) struct PikeVM {\n    nfa: NFA,\n}\n#[derive(Clone, Debug)]\nstruct SlotTable {\n    /// The actual table of offsets.\n    table: Vec<Option<NonMaxUsize>>,\n    /// The number of slots per state, i.e., the table's stride or the length\n    /// of each row.\n    slots_per_state: usize,\n    /// The number of slots in the caller-provided `Captures` value for the\n    /// current search. Setting this to `slots_per_state` is always correct,\n    /// but may be wasteful.\n    slots_for_captures: usize,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub(crate) struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone)]\npub(crate) struct NFA {\n    /// The pattern string this NFA was generated from.\n    ///\n    /// We put it here for lack of a better place to put it. ¯\\_(ツ)_/¯\n    pattern: String,\n    /// The states that make up this NFA.\n    states: Vec<State>,\n    /// The ID of the start state.\n    start: StateID,\n    /// Whether this NFA can only match at the beginning of a haystack.\n    is_start_anchored: bool,\n    /// Whether this NFA can match the empty string.\n    is_match_empty: bool,\n    /// If every match has the same number of matching capture groups, then\n    /// this corresponds to the number of groups.\n    static_explicit_captures_len: Option<usize>,\n    /// A map from capture group name to its corresponding index.\n    cap_name_to_index: CaptureNameMap,\n    /// A map from capture group index to the corresponding name, if one\n    /// exists.\n    cap_index_to_name: Vec<Option<Arc<str>>>,\n    /// Heap memory used indirectly by NFA states and other things (like the\n    /// various capturing group representations above). Since each state\n    /// might use a different amount of heap, we need to keep track of this\n    /// incrementally.\n    memory_extra: usize,\n}\n#[derive(Clone)]\nstruct SparseSet {\n    /// The number of elements currently in this set.\n    len: usize,\n    /// Dense contains the ids in the order in which they were inserted.\n    dense: Vec<StateID>,\n    /// Sparse maps ids to their location in dense.\n    ///\n    /// A state ID is in the set if and only if\n    /// sparse[id] < len && id == dense[sparse[id]].\n    ///\n    /// Note that these are indices into 'dense'. It's a little weird to use\n    /// StateID here, but we know our length can never exceed the bounds of\n    /// StateID (enforced by 'resize') and StateID will be at most 4 bytes\n    /// where as a usize is likely double that in most cases.\n    sparse: Vec<StateID>,\n}\n#[derive(Clone, Debug)]\nstruct ActiveStates {\n    /// The set of active NFA states. This set preserves insertion order, which\n    /// is critical for simulating the match semantics of backtracking regex\n    /// engines.\n    set: SparseSet,\n    /// The slots for every NFA state, where each slot stores a (possibly\n    /// absent) offset. Every capturing group has two slots. One for a start\n    /// offset and one for an end offset.\n    slot_table: SlotTable,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Look {\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    Start = 1 << 0,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    End = 1 << 1,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLF = 1 << 2,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\n` character.\n    EndLF = 1 << 3,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following either a `\\r` or `\\n` character, but never after\n    /// a `\\r` when a `\\n` follows.\n    StartCRLF = 1 << 4,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\r` or `\\n` character, but never before a `\\n` when a `\\r`\n    /// precedes it.\n    EndCRLF = 1 << 5,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    Word = 1 << 6,\n    /// Match an ASCII-only negation of a word boundary.\n    WordNegate = 1 << 7,\n    /// Match the start of an ASCII-only word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStart = 1 << 8,\n    /// Match the end of an ASCII-only word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEnd = 1 << 9,\n    /// Match the start half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalf = 1 << 10,\n    /// Match the end half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the end of the haystack or where the\n    /// following character is not a word character.\n    WordEndHalf = 1 << 11,\n}\n#[derive(Clone, Eq, PartialEq)]\npub(crate) enum State {\n    Char { target: StateID, ch: char },\n    Ranges { target: StateID, ranges: Vec<(char, char)> },\n    Splits { targets: Vec<StateID>, reverse: bool },\n    Goto { target: StateID, look: Option<hir::Look> },\n    Capture { target: StateID, slot: u32 },\n    Fail,\n    Match,\n}\n#[derive(Clone, Debug)]\nenum FollowEpsilon {\n    /// Explore the epsilon transitions from a state ID.\n    Explore(StateID),\n    /// Reset the given `slot` to the given `offset` (which might be `None`).\n    RestoreCapture { slot: u32, offset: Option<NonMaxUsize> },\n}\nimpl PikeVM {\n    pub(crate) fn new(nfa: NFA) -> PikeVM {}\n    pub(crate) fn nfa(&self) -> &NFA {}\n    pub(crate) fn find_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> FindMatches<'r, 'h> {}\n    pub(crate) fn captures_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> CapturesMatches<'r, 'h> {}\n    pub(crate) fn search(\n        &self,\n        cache: &mut Cache,\n        haystack: &[u8],\n        start: usize,\n        end: usize,\n        earliest: bool,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {}\n    fn nexts(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {}\n    fn next(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slot_table: &mut SlotTable,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        sid: StateID,\n    ) -> bool {}\n    fn epsilon_closure(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        sid: StateID,\n    ) {}\n    fn epsilon_closure_explore(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        mut sid: StateID,\n    ) {\n        loop {\n            if !next.set.insert(sid) {\n                return;\n            }\n            match *self.nfa.state(sid) {\n                State::Fail\n                | State::Match { .. }\n                | State::Char { .. }\n                | State::Ranges { .. } => {\n                    next.slot_table.for_state(sid).copy_from_slice(curr_slots);\n                    return;\n                }\n                State::Goto { target, look: None } => {\n                    sid = target;\n                }\n                State::Goto { target, look: Some(look) } => {\n                    if !look.is_match(haystack, at) {\n                        return;\n                    }\n                    sid = target;\n                }\n                State::Splits { ref targets, reverse: false } => {\n                    sid = match targets.get(0) {\n                        None => return,\n                        Some(&sid) => sid,\n                    };\n                    stack\n                        .extend(\n                            targets[1..]\n                                .iter()\n                                .copied()\n                                .rev()\n                                .map(FollowEpsilon::Explore),\n                        );\n                }\n                State::Splits { ref targets, reverse: true } => {\n                    sid = match targets.last() {\n                        None => return,\n                        Some(&sid) => sid,\n                    };\n                    stack\n                        .extend(\n                            targets[..targets.len() - 1]\n                                .iter()\n                                .copied()\n                                .map(FollowEpsilon::Explore),\n                        );\n                }\n                State::Capture { target, slot } => {\n                    if slot.as_usize() < curr_slots.len() {\n                        stack\n                            .push(FollowEpsilon::RestoreCapture {\n                                slot,\n                                offset: curr_slots[slot.as_usize()],\n                            });\n                        curr_slots[slot.as_usize()] = Some(\n                            NonMaxUsize::new(at).unwrap(),\n                        );\n                    }\n                    sid = target;\n                }\n            }\n        }\n    }\n}\nimpl Look {\n    pub(crate) fn is_match(&self, haystack: &[u8], at: usize) -> bool {\n        use self::Look::*;\n        match *self {\n            Start => at == 0,\n            End => at == haystack.len(),\n            StartLF => at == 0 || haystack[at - 1] == b'\\n',\n            EndLF => at == haystack.len() || haystack[at] == b'\\n',\n            StartCRLF => {\n                at == 0 || haystack[at - 1] == b'\\n'\n                    || (haystack[at - 1] == b'\\r'\n                        && (at >= haystack.len() || haystack[at] != b'\\n'))\n            }\n            EndCRLF => {\n                at == haystack.len() || haystack[at] == b'\\r'\n                    || (haystack[at] == b'\\n' && (at == 0 || haystack[at - 1] != b'\\r'))\n            }\n            Word => {\n                let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);\n                let word_after = at < haystack.len() && utf8::is_word_byte(haystack[at]);\n                word_before != word_after\n            }\n            WordNegate => {\n                let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);\n                let word_after = at < haystack.len() && utf8::is_word_byte(haystack[at]);\n                word_before == word_after\n            }\n            WordStart => {\n                let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);\n                let word_after = at < haystack.len() && utf8::is_word_byte(haystack[at]);\n                !word_before && word_after\n            }\n            WordEnd => {\n                let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);\n                let word_after = at < haystack.len() && utf8::is_word_byte(haystack[at]);\n                word_before && !word_after\n            }\n            WordStartHalf => {\n                let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);\n                !word_before\n            }\n            WordEndHalf => {\n                let word_after = at < haystack.len() && utf8::is_word_byte(haystack[at]);\n                !word_after\n            }\n        }\n    }\n}\nimpl SlotTable {\n    fn new() -> SlotTable {}\n    fn reset(&mut self, re: &PikeVM) {}\n    fn setup_search(&mut self, captures_slot_len: usize) {}\n    fn for_state(&mut self, sid: StateID) -> &mut [Option<NonMaxUsize>] {\n        let i = sid.as_usize() * self.slots_per_state;\n        &mut self.table[i..i + self.slots_for_captures]\n    }\n    fn all_absent(&mut self) -> &mut [Option<NonMaxUsize>] {}\n}\nimpl NonMaxUsize {\n    pub(crate) fn new(value: usize) -> Option<NonMaxUsize> {\n        NonZeroUsize::new(value.wrapping_add(1)).map(NonMaxUsize)\n    }\n    pub(crate) fn get(self) -> usize {}\n}\nimpl NFA {\n    pub(crate) fn new(config: Config, pattern: String, hir: &Hir) -> Result<NFA, Error> {}\n    pub(crate) fn pattern(&self) -> &str {}\n    pub(crate) fn state(&self, id: StateID) -> &State {\n        &self.states[id.as_usize()]\n    }\n    pub(crate) fn len(&self) -> usize {}\n    pub(crate) fn start(&self) -> StateID {}\n    pub(crate) fn to_index(&self, name: &str) -> Option<usize> {}\n    pub(crate) fn capture_names(&self) -> CaptureNames<'_> {}\n    pub(crate) fn group_len(&self) -> usize {}\n    pub(crate) fn is_start_anchored(&self) -> bool {}\n    pub(crate) fn static_explicit_captures_len(&self) -> Option<usize> {}\n    fn memory_usage(&self) -> usize {}\n}\nimpl SparseSet {\n    fn new(capacity: usize) -> SparseSet {}\n    fn resize(&mut self, new_capacity: usize) {}\n    fn capacity(&self) -> usize {}\n    fn len(&self) -> usize {}\n    fn is_empty(&self) -> bool {}\n    fn insert(&mut self, id: StateID) -> bool {\n        if self.contains(id) {\n            return false;\n        }\n        let index = self.len();\n        assert!(\n            index < self.capacity(), \"{:?} exceeds capacity of {:?} when inserting {:?}\",\n            index, self.capacity(), id,\n        );\n        self.dense[index] = id;\n        self.sparse[id.as_usize()] = u32::try_from(index).unwrap();\n        self.len += 1;\n        true\n    }\n    fn contains(&self, id: StateID) -> bool {}\n    fn clear(&mut self) {}\n    fn iter(&self) -> SparseSetIter<'_> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Explore all of the epsilon transitions out of `sid`. This is mostly\n/// split out from `epsilon_closure` in order to clearly delineate\n/// the actual work of computing an epsilon closure from the stack\n/// book-keeping.\n///\n/// This will push any additional explorations needed on to `stack`.\n///\n/// `curr_slots` should refer to the slots for the currently active NFA\n/// state. That is, the current state we are stepping through. These\n/// slots are mutated in place as new `Captures` states are traversed\n/// during epsilon closure, but the slots are restored to their original\n/// values once the full epsilon closure is completed. The ultimate use of\n/// `curr_slots` is to copy them to the corresponding `next_slots`, so that\n/// the capturing group spans are forwarded from the currently active state\n/// to the next.\n///\n/// `next` refers to the next set of active states. Computing an epsilon\n/// closure may increase the next set of active states.\n///\n/// `haystack` refers to the what we're searching and `at` refers to the\n/// current position in the haystack. These are used to check whether\n/// conditional epsilon transitions (like look-around) are satisfied at\n/// the current position. If they aren't, then the epsilon closure won't\n/// include them.\n355 fn epsilon_closure_explore(\n356     &self,\n357     stack: &mut Vec<FollowEpsilon>,\n358     curr_slots: &mut [Option<NonMaxUsize>],\n359     next: &mut ActiveStates,\n360     haystack: &[u8],\n361     at: usize,\n362     mut sid: StateID,\n363 ) {\n364     // We can avoid pushing some state IDs on to our stack in precisely\n365     // the cases where a 'push(x)' would be immediately followed by a 'x\n366     // = pop()'. This is achieved by this outer-loop. We simply set 'sid'\n367     // to be the next state ID we want to explore once we're done with\n368     // our initial exploration. In practice, this avoids a lot of stack\n369     // thrashing.\n370     loop {\n371         // Record this state as part of our next set of active states. If\n372         // we've already explored it, then no need to do it again.\n373         if !next.set.insert(sid) {\n374             return;\n375         }\n376         match *self.nfa.state(sid) {\n377             State::Fail\n378             | State::Match { .. }\n379             | State::Char { .. }\n380             | State::Ranges { .. } => {\n381                 next.slot_table.for_state(sid).copy_from_slice(curr_slots);\n382                 return;\n383             }\n384             State::Goto { target, look: None } => {\n385                 sid = target;\n386             }\n387             State::Goto { target, look: Some(look) } => {\n388                 if !look.is_match(haystack, at) {\n389                     return;\n390                 }\n391                 sid = target;\n392             }\n393             State::Splits { ref targets, reverse: false } => {\n394                 sid = match targets.get(0) {\n395                     None => return,\n396                     Some(&sid) => sid,\n397                 };\n398                 stack.extend(\n399                     targets[1..]\n400                         .iter()\n401                         .copied()\n402                         .rev()\n403                         .map(FollowEpsilon::Explore),\n404                 );\n405             }\n406             State::Splits { ref targets, reverse: true } => {\n407                 sid = match targets.last() {\n408                     None => return,\n409                     Some(&sid) => sid,\n410                 };\n411                 stack.extend(\n412                     targets[..targets.len() - 1]\n413                         .iter()\n414                         .copied()\n415                         .map(FollowEpsilon::Explore),\n416                 );\n417             }\n418             State::Capture { target, slot } => {\n419                 // There's no need to do anything with slots that\n420                 // ultimately won't be copied into the caller-provided\n421                 // 'Captures' value. So we just skip dealing with them at\n422                 // all.\n423                 if slot.as_usize() < curr_slots.len() {\n424                     stack.push(FollowEpsilon::RestoreCapture {\n425                         slot,\n426                         offset: curr_slots[slot.as_usize()],\n427                     });\n428                     // OK because length of a slice must fit into an isize.\n429                     curr_slots[slot.as_usize()] =\n430                         Some(NonMaxUsize::new(at).unwrap());\n431                 }\n432                 sid = target;\n433             }\n434         }\n435     }\n436 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}