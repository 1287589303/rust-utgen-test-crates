{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/visitor.rs\n// crate name is regex_syntax\nuse alloc::{vec, vec::Vec};\nuse crate::ast::{self, Ast};\nstruct HeapVisitor<'a> {\n    /// A stack of `Ast` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Ast, Frame<'a>)>,\n    /// Similar to the `Ast` stack above, but is used only for character\n    /// classes. In particular, character classes embed their own mini\n    /// recursive syntax.\n    stack_class: Vec<(ClassInduct<'a>, ClassFrame<'a>)>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum Ast {\n    /// An empty regex that matches everything.\n    Empty(Box<Span>),\n    /// A set of flags, e.g., `(?is)`.\n    Flags(Box<SetFlags>),\n    /// A single character literal, which includes escape sequences.\n    Literal(Box<Literal>),\n    /// The \"any character\" class.\n    Dot(Box<Span>),\n    /// A single zero-width assertion.\n    Assertion(Box<Assertion>),\n    /// A single Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    ClassUnicode(Box<ClassUnicode>),\n    /// A single perl character class, e.g., `\\d` or `\\W`.\n    ClassPerl(Box<ClassPerl>),\n    /// A single bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    ClassBracketed(Box<ClassBracketed>),\n    /// A repetition operator applied to an arbitrary regular expression.\n    Repetition(Box<Repetition>),\n    /// A grouped regular expression.\n    Group(Box<Group>),\n    /// An alternation of regular expressions.\n    Alternation(Box<Alternation>),\n    /// A concatenation of regular expressions.\n    Concat(Box<Concat>),\n}\nimpl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {\n        HeapVisitor {\n            stack: vec![],\n            stack_class: vec![],\n        }\n    }\n    fn visit<V: Visitor>(\n        &mut self,\n        mut ast: &'a Ast,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {}\n    fn induct<V: Visitor>(\n        &mut self,\n        ast: &'a Ast,\n        visitor: &mut V,\n    ) -> Result<Option<Frame<'a>>, V::Err> {}\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {}\n    fn visit_class<V: Visitor>(\n        &mut self,\n        ast: &'a ast::ClassBracketed,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {}\n    fn visit_class_pre<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {}\n    fn visit_class_post<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {}\n    fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {}\n    fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {}\n}\npub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err> {\n    HeapVisitor::new().visit(ast, visitor)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes an implementation of `Visitor` in constant stack space.\n///\n/// This function will visit every node in the given `Ast` while calling the\n/// appropriate methods provided by the [`Visitor`] trait.\n///\n/// The primary use case for this method is when one wants to perform case\n/// analysis over an `Ast` without using a stack size proportional to the depth\n/// of the `Ast`. Namely, this method will instead use constant stack size, but\n/// will use heap space proportional to the size of the `Ast`. This may be\n/// desirable in cases where the size of `Ast` is proportional to end user\n/// input.\n///\n/// If the visitor returns an error at any point, then visiting is stopped and\n/// the error is returned.\n118 pub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err> {\n119     HeapVisitor::new().visit(ast, visitor)\n120 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}