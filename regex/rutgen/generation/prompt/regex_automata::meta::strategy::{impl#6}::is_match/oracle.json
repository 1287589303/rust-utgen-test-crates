{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseAnchored {\n    core: Core,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Debug)]\npub(crate) struct RetryFailError {\n    offset: usize,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\nimpl Strategy for ReverseAnchored {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn group_info(&self) -> &GroupInfo {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn create_cache(&self) -> Cache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn reset_cache(&self, cache: &mut Cache) {}\n    fn is_accelerated(&self) -> bool {}\n    fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {\n        if input.get_anchored().is_anchored() {\n            return self.core.is_match(cache, input);\n        }\n        match self.try_search_half_anchored_rev(cache, input) {\n            Err(_err) => {\n                trace!(\"fast reverse anchored search failed: {}\", _err);\n                self.core.is_match_nofail(cache, input)\n            }\n            Ok(None) => false,\n            Ok(Some(_)) => true,\n        }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) {}\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {}\n    #[inline]\n    pub fn start(&self) -> usize {}\n    #[inline]\n    pub fn end(&self) -> usize {}\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {\n        self.anchored\n    }\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl ReverseAnchored {\n    fn new(core: Core) -> Result<ReverseAnchored, Core> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_anchored_rev(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {\n        let input = input.clone().anchored(Anchored::Yes);\n        if let Some(e) = self.core.dfa.get(&input) {\n            trace!(\n                \"using full DFA for reverse anchored search at {:?}\", input.get_span()\n            );\n            e.try_search_half_rev(&input)\n        } else if let Some(e) = self.core.hybrid.get(&input) {\n            trace!(\n                \"using lazy DFA for reverse anchored search at {:?}\", input.get_span()\n            );\n            e.try_search_half_rev(&mut cache.hybrid, &input)\n        } else {\n            unreachable!(\"ReverseAnchored always has a DFA\")\n        }\n    }\n}\nimpl Core {\n    fn new(\n        info: RegexInfo,\n        pre: Option<Prefilter>,\n        hirs: &[&Hir],\n    ) -> Result<Core, BuildError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_mayfail(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Option<Result<Option<Match>, RetryFailError>> {}\n    fn search_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {}\n    fn search_half_nofail(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Option<HalfMatch> {}\n    fn search_slots_nofail(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    fn is_match_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> bool {\n        if let Some(ref e) = self.onepass.get(input) {\n            trace!(\"using OnePass for is-match search at {:?}\", input.get_span());\n            e.search_slots(&mut cache.onepass, input, &mut []).is_some()\n        } else if let Some(ref e) = self.backtrack.get(input) {\n            trace!(\n                \"using BoundedBacktracker for is-match search at {:?}\", input.get_span()\n            );\n            e.is_match(&mut cache.backtrack, input)\n        } else {\n            trace!(\"using PikeVM for is-match search at {:?}\", input.get_span());\n            let e = self.pikevm.get();\n            e.is_match(&mut cache.pikevm, input)\n        }\n    }\n    fn is_capture_search_needed(&self, slots_len: usize) -> bool {}\n}\nimpl Anchored {\n    #[inline]\n    pub fn is_anchored(&self) -> bool {\n        matches!(* self, Anchored::Yes | Anchored::Pattern(_))\n    }\n    #[inline]\n    pub fn pattern(&self) -> Option<PatternID> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1053 fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {\n1054     if input.get_anchored().is_anchored() {\n1055         return self.core.is_match(cache, input);\n1056     }\n1057     match self.try_search_half_anchored_rev(cache, input) {\n1058         Err(_err) => {\n1059             trace!(\"fast reverse anchored search failed: {}\", _err);\n1060             self.core.is_match_nofail(cache, input)\n1061         }\n1062         Ok(None) => false,\n1063         Ok(Some(_)) => true,\n1064     }\n1065 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}