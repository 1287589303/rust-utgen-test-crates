{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/parse.rs\n// crate name is regex_syntax\ntype Result<T> = core::result::Result<T, ast::Error>;\nuse core::{\n    borrow::Borrow, cell::{Cell, RefCell},\n    mem,\n};\nuse alloc::{\n    boxed::Box, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::{self, Ast, Position, Span},\n    either::Either, is_escapeable_character, is_meta_character,\n};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Eq, PartialEq)]\npub struct Literal(pub Box<[u8]>);\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassPerl {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of Perl class.\n    pub kind: ClassPerlKind,\n    /// Whether the class is negated or not. e.g., `\\d` is not negated but\n    /// `\\D` is.\n    pub negated: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Assertion {\n    /// The span of this assertion.\n    pub span: Span,\n    /// The assertion kind, e.g., `\\b` or `^`.\n    pub kind: AssertionKind,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassUnicode {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not.\n    ///\n    /// Note: be careful when using this attribute. This specifically refers\n    /// to whether the class is written as `\\p` or `\\P`, where the latter\n    /// is `negated = true`. However, it also possible to write something like\n    /// `\\P{scx!=Katakana}` which is actually equivalent to\n    /// `\\p{scx=Katakana}` and is therefore not actually negated even though\n    /// `negated = true` here. To test whether this class is truly negated\n    /// or not, use the `is_negated` method.\n    pub negated: bool,\n    /// The kind of Unicode class.\n    pub kind: ClassUnicodeKind,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Eq, PartialEq, PartialOrd, Ord)]\npub struct Literal {\n    bytes: Vec<u8>,\n    exact: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum Primitive {\n    Literal(ast::Literal),\n    Assertion(ast::Assertion),\n    Dot(Span),\n    Perl(ast::ClassPerl),\n    Unicode(ast::ClassUnicode),\n}\nimpl Primitive {\n    fn span(&self) -> &Span {\n        match *self {\n            Primitive::Literal(ref x) => &x.span,\n            Primitive::Assertion(ref x) => &x.span,\n            Primitive::Dot(ref span) => span,\n            Primitive::Perl(ref x) => &x.span,\n            Primitive::Unicode(ref x) => &x.span,\n        }\n    }\n    fn into_ast(self) -> Ast {}\n    fn into_class_set_item<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<'_, P>,\n    ) -> Result<ast::ClassSetItem> {}\n    fn into_class_literal<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<'_, P>,\n    ) -> Result<ast::Literal> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Return the span of this primitive.\n43 fn span(&self) -> &Span {\n44     match *self {\n45         Primitive::Literal(ref x) => &x.span,\n46         Primitive::Assertion(ref x) => &x.span,\n47         Primitive::Dot(ref span) => span,\n48         Primitive::Perl(ref x) => &x.span,\n49         Primitive::Unicode(ref x) => &x.span,\n50     }\n51 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}