{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\nstruct StartTable<T> {\n    /// The initial start state IDs as a contiguous table of native endian\n    /// encoded integers, represented by `S`.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8] and has no alignment\n    /// requirements.\n    ///\n    /// The first `2 * stride` (currently always 8) entries always correspond\n    /// to the starts states for the entire DFA, with the first 4 entries being\n    /// for unanchored searches and the second 4 entries being for anchored\n    /// searches. To keep things simple, we always use 8 entries even if the\n    /// `StartKind` is not both.\n    ///\n    /// After that, there are `stride * patterns` state IDs, where `patterns`\n    /// may be zero in the case of a DFA with no patterns or in the case where\n    /// the DFA was built without enabling starting states for each pattern.\n    table: T,\n    /// The starting state configuration supported. When 'both', both\n    /// unanchored and anchored searches work. When 'unanchored', anchored\n    /// searches panic. When 'anchored', unanchored searches panic.\n    kind: StartKind,\n    /// The start state configuration for every possible byte.\n    start_map: StartByteMap,\n    /// The number of starting state IDs per pattern.\n    stride: usize,\n    /// The total number of patterns for which starting states are encoded.\n    /// This is `None` for DFAs that were built without start states for each\n    /// pattern. Thus, one cannot use this field to say how many patterns\n    /// are in the DFA in all cases. It is specific to how many patterns are\n    /// represented in this start table.\n    pattern_len: Option<usize>,\n    /// The universal starting state for unanchored searches. This is only\n    /// present when the DFA supports unanchored searches and when all starting\n    /// state IDs for an unanchored search are equivalent.\n    universal_start_unanchored: Option<StateID>,\n    /// The universal starting state for anchored searches. This is only\n    /// present when the DFA supports anchored searches and when all starting\n    /// state IDs for an anchored search are equivalent.\n    universal_start_anchored: Option<StateID>,\n}\n#[derive(Clone)]\npub(crate) struct StartByteMap {\n    map: [Start; 256],\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum StartKind {\n    /// Support both anchored and unanchored searches.\n    Both,\n    /// Support only unanchored searches. Requesting an anchored search will\n    /// panic.\n    ///\n    /// Note that even if an unanchored search is requested, the pattern itself\n    /// may still be anchored. For example, `^abc` will only match `abc` at the\n    /// start of a haystack. This will remain true, even if the regex engine\n    /// only supported unanchored searches.\n    Unanchored,\n    /// Support only anchored searches. Requesting an unanchored search will\n    /// panic.\n    Anchored,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Start {\n    /// This occurs when the starting position is not any of the ones below.\n    NonWordByte = 0,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is an ASCII word byte.\n    WordByte = 1,\n    /// This occurs when the starting position of the search corresponds to the\n    /// beginning of the haystack.\n    Text = 2,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\n`.\n    LineLF = 3,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\r`.\n    LineCR = 4,\n    /// This occurs when a custom line terminator has been set via a\n    /// `LookMatcher`, and when that line terminator is neither a `\\r` or a\n    /// `\\n`.\n    ///\n    /// If the custom line terminator is a word byte, then this start\n    /// configuration is still selected. DFAs that implement word boundary\n    /// assertions will likely need to check whether the custom line terminator\n    /// is a word byte, in which case, it should behave as if the byte\n    /// satisfies `\\b` in addition to multi-line anchors.\n    CustomLineTerminator = 5,\n}\n#[non_exhaustive]\n#[derive(Clone, Debug)]\npub enum StartError {\n    /// An error that occurs when a starting configuration's look-behind byte\n    /// is in this DFA's quit set.\n    Quit {\n        /// The quit byte that was found.\n        byte: u8,\n    },\n    /// An error that occurs when the caller requests an anchored mode that\n    /// isn't supported by the DFA.\n    UnsupportedAnchored {\n        /// The anchored mode given that is unsupported.\n        mode: Anchored,\n    },\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\nimpl<T: AsRef<[u8]>> StartTable<T> {\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n    fn validate(&self, sp: &Special, seen: &Seen) -> Result<(), DeserializeError> {}\n    fn as_ref(&self) -> StartTable<&'_ [u8]> {}\n    #[cfg(feature = \"alloc\")]\n    fn to_owned(&self) -> StartTable<alloc::vec::Vec<u8>> {}\n    fn start(&self, anchored: Anchored, start: Start) -> Result<StateID, StartError> {\n        let start_index = start.as_usize();\n        let index = match anchored {\n            Anchored::No => {\n                if !self.kind.has_unanchored() {\n                    return Err(StartError::unsupported_anchored(anchored));\n                }\n                start_index\n            }\n            Anchored::Yes => {\n                if !self.kind.has_anchored() {\n                    return Err(StartError::unsupported_anchored(anchored));\n                }\n                self.stride + start_index\n            }\n            Anchored::Pattern(pid) => {\n                let len = match self.pattern_len {\n                    None => return Err(StartError::unsupported_anchored(anchored)),\n                    Some(len) => len,\n                };\n                if pid.as_usize() >= len {\n                    return Ok(DEAD);\n                }\n                (2 * self.stride) + (self.stride * pid.as_usize()) + start_index\n            }\n        };\n        let start = index * StateID::SIZE;\n        Ok(wire::read_state_id_unchecked(&self.table()[start..]).0)\n    }\n    fn iter(&self) -> StartStateIter<'_, T> {}\n    fn len(&self) -> usize {}\n    fn table(&self) -> &[u8] {\n        self.table.as_ref()\n    }\n    fn memory_usage(&self) -> usize {}\n}\nimpl StartKind {\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(StartKind, usize), DeserializeError> {}\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn has_unanchored(&self) -> bool {\n        matches!(* self, StartKind::Both | StartKind::Unanchored)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn has_anchored(&self) -> bool {\n        matches!(* self, StartKind::Both | StartKind::Anchored)\n    }\n}\nimpl Start {\n    pub(crate) fn from_usize(n: usize) -> Option<Start> {}\n    pub(crate) fn len() -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn as_u8(&self) -> u8 {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn as_usize(&self) -> usize {\n        usize::from(self.as_u8())\n    }\n}\nimpl StartError {\n    pub(crate) fn quit(byte: u8) -> StartError {}\n    pub(crate) fn unsupported_anchored(mode: Anchored) -> StartError {\n        StartError::UnsupportedAnchored {\n            mode,\n        }\n    }\n}\npub(crate) fn read_state_id_unchecked(slice: &[u8]) -> (StateID, usize) {\n    let sid = StateID::from_ne_bytes_unchecked(\n        slice[..StateID::SIZE].try_into().unwrap(),\n    );\n    (sid, StateID::SIZE)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Return the start state for the given index and pattern ID. If the\n/// pattern ID is None, then the corresponding start state for the entire\n/// DFA is returned. If the pattern ID is not None, then the corresponding\n/// starting state for the given pattern is returned. If this start table\n/// does not have individual starting states for each pattern, then this\n/// panics.\n2070 fn start(\n2071     &self,\n2072     anchored: Anchored,\n2073     start: Start,\n2074 ) -> Result<StateID, StartError> {\n2075     let start_index = start.as_usize();\n2076     let index = match anchored {\n2077         Anchored::No => {\n2078             if !self.kind.has_unanchored() {\n2079                 return Err(StartError::unsupported_anchored(anchored));\n2080             }\n2081             start_index\n2082         }\n2083         Anchored::Yes => {\n2084             if !self.kind.has_anchored() {\n2085                 return Err(StartError::unsupported_anchored(anchored));\n2086             }\n2087             self.stride + start_index\n2088         }\n2089         Anchored::Pattern(pid) => {\n2090             let len = match self.pattern_len {\n2091                 None => {\n2092                     return Err(StartError::unsupported_anchored(anchored))\n2093                 }\n2094                 Some(len) => len,\n2095             };\n2096             if pid.as_usize() >= len {\n2097                 return Ok(DEAD);\n2098             }\n2099             (2 * self.stride)\n2100                 + (self.stride * pid.as_usize())\n2101                 + start_index\n2102         }\n2103     };\n2104     let start = index * StateID::SIZE;\n2105     // This OK since we're allowed to assume that the start table contains\n2106     // valid StateIDs.\n2107     Ok(wire::read_state_id_unchecked(&self.table()[start..]).0)\n2108 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}