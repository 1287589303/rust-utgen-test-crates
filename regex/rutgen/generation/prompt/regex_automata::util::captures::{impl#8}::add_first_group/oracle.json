{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/captures.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype CaptureNameMap = std::collections::HashMap<Arc<str>, SmallIndex>;\n#[cfg(not(feature = \"std\"))]\ntype CaptureNameMap = alloc::collections::BTreeMap<Arc<str>, SmallIndex>;\nuse alloc::{string::String, sync::Arc, vec, vec::Vec};\nuse crate::util::{\n    interpolate,\n    primitives::{NonMaxUsize, PatternID, PatternIDError, PatternIDIter, SmallIndex},\n    search::{Match, Span},\n};\n#[derive(Debug, Default)]\nstruct GroupInfoInner {\n    slot_ranges: Vec<(SmallIndex, SmallIndex)>,\n    name_to_index: Vec<CaptureNameMap>,\n    index_to_name: Vec<Vec<Option<Arc<str>>>>,\n    memory_extra: usize,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\nimpl GroupInfoInner {\n    fn add_first_group(&mut self, pid: PatternID) {\n        assert_eq!(pid.as_usize(), self.slot_ranges.len());\n        assert_eq!(pid.as_usize(), self.name_to_index.len());\n        assert_eq!(pid.as_usize(), self.index_to_name.len());\n        let slot_start = self.small_slot_len();\n        self.slot_ranges.push((slot_start, slot_start));\n        self.name_to_index.push(CaptureNameMap::new());\n        self.index_to_name.push(vec![None]);\n        self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();\n    }\n    fn add_explicit_group<N: AsRef<str>>(\n        &mut self,\n        pid: PatternID,\n        group: SmallIndex,\n        maybe_name: Option<N>,\n    ) -> Result<(), GroupInfoError> {}\n    fn fixup_slot_ranges(&mut self) -> Result<(), GroupInfoError> {}\n    fn pattern_len(&self) -> usize {}\n    fn group_len(&self, pid: PatternID) -> usize {}\n    fn small_slot_len(&self) -> SmallIndex {\n        self.slot_ranges.last().map_or(SmallIndex::ZERO, |&(_, end)| end)\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// This adds the first unnamed group for the given pattern ID. The given\n/// pattern ID must be zero if this is the first time this method is\n/// called, or must be exactly one more than the pattern ID supplied to the\n/// previous call to this method. (This method panics if this rule is\n/// violated.)\n///\n/// This can be thought of as initializing the GroupInfo state for the\n/// given pattern and closing off the state for any previous pattern.\n2192 fn add_first_group(&mut self, pid: PatternID) {\n2193     assert_eq!(pid.as_usize(), self.slot_ranges.len());\n2194     assert_eq!(pid.as_usize(), self.name_to_index.len());\n2195     assert_eq!(pid.as_usize(), self.index_to_name.len());\n2196     // This is the start of our slots for the explicit capturing groups.\n2197     // Note that since the slots for the 0th group for every pattern appear\n2198     // before any slots for the nth group (where n > 0) in any pattern, we\n2199     // will have to fix up the slot ranges once we know how many patterns\n2200     // we've added capture groups for.\n2201     let slot_start = self.small_slot_len();\n2202     self.slot_ranges.push((slot_start, slot_start));\n2203     self.name_to_index.push(CaptureNameMap::new());\n2204     self.index_to_name.push(vec![None]);\n2205     self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();\n2206 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}