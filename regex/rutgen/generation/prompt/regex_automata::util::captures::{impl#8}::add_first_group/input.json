{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/captures.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype CaptureNameMap = std::collections::HashMap<Arc<str>, SmallIndex>;\n#[cfg(not(feature = \"std\"))]\ntype CaptureNameMap = alloc::collections::BTreeMap<Arc<str>, SmallIndex>;\nuse alloc::{string::String, sync::Arc, vec, vec::Vec};\nuse crate::util::{\n    interpolate,\n    primitives::{NonMaxUsize, PatternID, PatternIDError, PatternIDIter, SmallIndex},\n    search::{Match, Span},\n};\n#[derive(Debug, Default)]\nstruct GroupInfoInner {\n    slot_ranges: Vec<(SmallIndex, SmallIndex)>,\n    name_to_index: Vec<CaptureNameMap>,\n    index_to_name: Vec<Vec<Option<Arc<str>>>>,\n    memory_extra: usize,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\nimpl GroupInfoInner {\n    fn add_first_group(&mut self, pid: PatternID) {\n        assert_eq!(pid.as_usize(), self.slot_ranges.len());\n        assert_eq!(pid.as_usize(), self.name_to_index.len());\n        assert_eq!(pid.as_usize(), self.index_to_name.len());\n        let slot_start = self.small_slot_len();\n        self.slot_ranges.push((slot_start, slot_start));\n        self.name_to_index.push(CaptureNameMap::new());\n        self.index_to_name.push(vec![None]);\n        self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();\n    }\n    fn add_explicit_group<N: AsRef<str>>(\n        &mut self,\n        pid: PatternID,\n        group: SmallIndex,\n        maybe_name: Option<N>,\n    ) -> Result<(), GroupInfoError> {}\n    fn fixup_slot_ranges(&mut self) -> Result<(), GroupInfoError> {}\n    fn pattern_len(&self) -> usize {}\n    fn group_len(&self, pid: PatternID) -> usize {}\n    fn small_slot_len(&self) -> SmallIndex {\n        self.slot_ranges.last().map_or(SmallIndex::ZERO, |&(_, end)| end)\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// This adds the first unnamed group for the given pattern ID. The given\n/// pattern ID must be zero if this is the first time this method is\n/// called, or must be exactly one more than the pattern ID supplied to the\n/// previous call to this method. (This method panics if this rule is\n/// violated.)\n///\n/// This can be thought of as initializing the GroupInfo state for the\n/// given pattern and closing off the state for any previous pattern.\n2192 fn add_first_group(&mut self, pid: PatternID) {\n2193     assert_eq!(pid.as_usize(), self.slot_ranges.len());\n2194     assert_eq!(pid.as_usize(), self.name_to_index.len());\n2195     assert_eq!(pid.as_usize(), self.index_to_name.len());\n2196     // This is the start of our slots for the explicit capturing groups.\n2197     // Note that since the slots for the 0th group for every pattern appear\n2198     // before any slots for the nth group (where n > 0) in any pattern, we\n2199     // will have to fix up the slot ranges once we know how many patterns\n2200     // we've added capture groups for.\n2201     let slot_start = self.small_slot_len();\n2202     self.slot_ranges.push((slot_start, slot_start));\n2203     self.name_to_index.push(CaptureNameMap::new());\n2204     self.index_to_name.push(vec![None]);\n2205     self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();\n2206 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}