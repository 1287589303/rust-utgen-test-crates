{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/stopat.rs\n// crate name is regex_automata\nuse crate::{meta::error::RetryFailError, HalfMatch, Input, MatchError};\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Debug)]\npub(crate) struct RetryFailError {\n    offset: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {\n        HalfMatch { pattern, offset }\n    }\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {\n        MatchError::new(MatchErrorKind::Quit {\n            byte,\n            offset,\n        })\n    }\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {}\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {\n        self.earliest\n    }\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\n#[cfg(feature = \"dfa-build\")]\npub(crate) fn dfa_try_search_half_fwd(\n    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,\n    input: &Input<'_>,\n) -> Result<Result<HalfMatch, usize>, RetryFailError> {\n    use crate::dfa::{accel, Automaton};\n    let mut mat = None;\n    let mut sid = dfa.start_state_forward(input)?;\n    let mut at = input.start();\n    while at < input.end() {\n        sid = dfa.next_state(sid, input.haystack()[at]);\n        if dfa.is_special_state(sid) {\n            if dfa.is_match_state(sid) {\n                let pattern = dfa.match_pattern(sid, 0);\n                mat = Some(HalfMatch::new(pattern, at));\n                if input.get_earliest() {\n                    return Ok(mat.ok_or(at));\n                }\n                if dfa.is_accel_state(sid) {\n                    let needs = dfa.accelerator(sid);\n                    at = accel::find_fwd(needs, input.haystack(), at)\n                        .unwrap_or(input.end());\n                    continue;\n                }\n            } else if dfa.is_accel_state(sid) {\n                let needs = dfa.accelerator(sid);\n                at = accel::find_fwd(needs, input.haystack(), at).unwrap_or(input.end());\n                continue;\n            } else if dfa.is_dead_state(sid) {\n                return Ok(mat.ok_or(at));\n            } else if dfa.is_quit_state(sid) {\n                return Err(MatchError::quit(input.haystack()[at], at).into());\n            } else {\n                debug_assert!(dfa.is_start_state(sid));\n            }\n        }\n        at += 1;\n    }\n    dfa_eoi_fwd(dfa, input, &mut sid, &mut mat)?;\n    Ok(mat.ok_or(at))\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\npub(crate) fn find_fwd(needles: &[u8], haystack: &[u8], at: usize) -> Option<usize> {\n    let bs = needles;\n    let i = match needles.len() {\n        1 => memchr::memchr(bs[0], &haystack[at..])?,\n        2 => memchr::memchr2(bs[0], bs[1], &haystack[at..])?,\n        3 => memchr::memchr3(bs[0], bs[1], bs[2], &haystack[at..])?,\n        0 => panic!(\"cannot find with empty needles\"),\n        n => panic!(\"invalid needles length: {}\", n),\n    };\n    Some(at + i)\n}\n#[cfg(feature = \"dfa-build\")]\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn dfa_eoi_fwd(\n    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,\n    input: &Input<'_>,\n    sid: &mut crate::util::primitives::StateID,\n    mat: &mut Option<HalfMatch>,\n) -> Result<(), MatchError> {\n    use crate::dfa::Automaton;\n    let sp = input.get_span();\n    match input.haystack().get(sp.end) {\n        Some(&b) => {\n            *sid = dfa.next_state(*sid, b);\n            if dfa.is_match_state(*sid) {\n                let pattern = dfa.match_pattern(*sid, 0);\n                *mat = Some(HalfMatch::new(pattern, sp.end));\n            } else if dfa.is_quit_state(*sid) {\n                return Err(MatchError::quit(b, sp.end));\n            }\n        }\n        None => {\n            *sid = dfa.next_eoi_state(*sid);\n            if dfa.is_match_state(*sid) {\n                let pattern = dfa.match_pattern(*sid, 0);\n                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));\n            }\n            debug_assert!(! dfa.is_quit_state(* sid));\n        }\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n52 pub(crate) fn dfa_try_search_half_fwd(\n53     dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,\n54     input: &Input<'_>,\n55 ) -> Result<Result<HalfMatch, usize>, RetryFailError> {\n56     use crate::dfa::{accel, Automaton};\n57 \n58     let mut mat = None;\n59     let mut sid = dfa.start_state_forward(input)?;\n60     let mut at = input.start();\n61     while at < input.end() {\n62         sid = dfa.next_state(sid, input.haystack()[at]);\n63         if dfa.is_special_state(sid) {\n64             if dfa.is_match_state(sid) {\n65                 let pattern = dfa.match_pattern(sid, 0);\n66                 mat = Some(HalfMatch::new(pattern, at));\n67                 if input.get_earliest() {\n68                     return Ok(mat.ok_or(at));\n69                 }\n70                 if dfa.is_accel_state(sid) {\n71                     let needs = dfa.accelerator(sid);\n72                     at = accel::find_fwd(needs, input.haystack(), at)\n73                         .unwrap_or(input.end());\n74                     continue;\n75                 }\n76             } else if dfa.is_accel_state(sid) {\n77                 let needs = dfa.accelerator(sid);\n78                 at = accel::find_fwd(needs, input.haystack(), at)\n79                     .unwrap_or(input.end());\n80                 continue;\n81             } else if dfa.is_dead_state(sid) {\n82                 return Ok(mat.ok_or(at));\n83             } else if dfa.is_quit_state(sid) {\n84                 return Err(MatchError::quit(input.haystack()[at], at).into());\n85             } else {\n86                 // Ideally we wouldn't use a DFA that specialized start states\n87                 // and thus 'is_start_state()' could never be true here, but in\n88                 // practice we reuse the DFA created for the full regex which\n89                 // will specialize start states whenever there is a prefilter.\n90                 debug_assert!(dfa.is_start_state(sid));\n91             }\n92         }\n93         at += 1;\n94     }\n95     dfa_eoi_fwd(dfa, input, &mut sid, &mut mat)?;\n96     Ok(mat.ok_or(at))\n97 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}