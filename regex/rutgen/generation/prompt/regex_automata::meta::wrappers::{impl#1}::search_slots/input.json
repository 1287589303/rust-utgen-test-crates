{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/wrappers.rs\n// crate name is regex_automata\nuse alloc::vec::Vec;\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError},\n        regex::RegexInfo,\n    },\n    nfa::thompson::{pikevm, NFA},\n    util::{prefilter::Prefilter, primitives::NonMaxUsize},\n    HalfMatch, Input, Match, MatchKind, PatternID, PatternSet,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa;\n#[cfg(feature = \"dfa-onepass\")]\nuse crate::dfa::onepass;\n#[cfg(feature = \"hybrid\")]\nuse crate::hybrid;\n#[cfg(feature = \"nfa-backtrack\")]\nuse crate::nfa::thompson::backtrack;\n#[derive(Debug)]\npub(crate) struct PikeVMEngine(pikevm::PikeVM);\n#[derive(Clone, Debug)]\npub struct PikeVM {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Debug)]\npub(crate) struct PikeVM(PikeVMEngine);\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug)]\npub(crate) struct PikeVMCache(Option<pikevm::Cache>);\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used while computing epsilon closure. This effectively lets us\n    /// move what is more naturally expressed through recursion to a stack\n    /// on the heap.\n    stack: Vec<FollowEpsilon>,\n    /// The current active states being explored for the current byte in the\n    /// haystack.\n    curr: ActiveStates,\n    /// The next set of states we're building that will be explored for the\n    /// next byte in the haystack.\n    next: ActiveStates,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\nimpl PikeVMEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n    ) -> Result<PikeVMEngine, BuildError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_match(&self, cache: &mut PikeVMCache, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn search_slots(\n        &self,\n        cache: &mut PikeVMCache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {\n        self.0.search_slots(cache.0.as_mut().unwrap(), input, slots)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn which_overlapping_matches(\n        &self,\n        cache: &mut PikeVMCache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) {}\n}\nimpl PikeVM {\n    #[inline]\n    pub fn search(&self, cache: &mut Cache, input: &Input<'_>, caps: &mut Captures) {}\n    #[inline]\n    pub fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {\n        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n        if !utf8empty {\n            let hm = self.search_slots_imp(cache, input, slots)?;\n            return Some(hm.pattern());\n        }\n        let min = self.get_nfa().group_info().implicit_slot_len();\n        if slots.len() >= min {\n            let hm = self.search_slots_imp(cache, input, slots)?;\n            return Some(hm.pattern());\n        }\n        if self.get_nfa().pattern_len() == 1 {\n            let mut enough = [None, None];\n            let got = self.search_slots_imp(cache, input, &mut enough);\n            slots.copy_from_slice(&enough[..slots.len()]);\n            return got.map(|hm| hm.pattern());\n        }\n        let mut enough = vec![None; min];\n        let got = self.search_slots_imp(cache, input, &mut enough);\n        slots.copy_from_slice(&enough[..slots.len()]);\n        got.map(|hm| hm.pattern())\n    }\n    #[inline(never)]\n    fn search_slots_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {}\n    #[inline]\n    pub fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n100 pub(crate) fn search_slots(\n101     &self,\n102     cache: &mut PikeVMCache,\n103     input: &Input<'_>,\n104     slots: &mut [Option<NonMaxUsize>],\n105 ) -> Option<PatternID> {\n106     self.0.search_slots(cache.0.as_mut().unwrap(), input, slots)\n107 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}