{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/interval.rs\n// crate name is regex_syntax\nuse core::{char, cmp, fmt::Debug, slice};\nuse alloc::vec::Vec;\nuse crate::unicode;\npub trait Interval: Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord {\n    type Bound: Bound;\n    fn lower(&self) -> Self::Bound;\n    fn upper(&self) -> Self::Bound;\n    fn set_lower(&mut self, bound: Self::Bound);\n    fn set_upper(&mut self, bound: Self::Bound);\n    fn case_fold_simple(\n        &self,\n        intervals: &mut Vec<Self>,\n    ) -> Result<(), unicode::CaseFoldError>;\n    fn create(lower: Self::Bound, upper: Self::Bound) -> Self {\n        let mut int = Self::default();\n        if lower <= upper {\n            int.set_lower(lower);\n            int.set_upper(upper);\n        } else {\n            int.set_lower(upper);\n            int.set_upper(lower);\n        }\n        int\n    }\n    fn union(&self, other: &Self) -> Option<Self> {\n        if !self.is_contiguous(other) {\n            return None;\n        }\n        let lower = cmp::min(self.lower(), other.lower());\n        let upper = cmp::max(self.upper(), other.upper());\n        Some(Self::create(lower, upper))\n    }\n    fn intersect(&self, other: &Self) -> Option<Self> {\n        let lower = cmp::max(self.lower(), other.lower());\n        let upper = cmp::min(self.upper(), other.upper());\n        if lower <= upper { Some(Self::create(lower, upper)) } else { None }\n    }\n    fn difference(&self, other: &Self) -> (Option<Self>, Option<Self>) {\n        if self.is_subset(other) {\n            return (None, None);\n        }\n        if self.is_intersection_empty(other) {\n            return (Some(self.clone()), None);\n        }\n        let add_lower = other.lower() > self.lower();\n        let add_upper = other.upper() < self.upper();\n        assert!(add_lower || add_upper);\n        let mut ret = (None, None);\n        if add_lower {\n            let upper = other.lower().decrement();\n            ret.0 = Some(Self::create(self.lower(), upper));\n        }\n        if add_upper {\n            let lower = other.upper().increment();\n            let range = Self::create(lower, self.upper());\n            if ret.0.is_none() {\n                ret.0 = Some(range);\n            } else {\n                ret.1 = Some(range);\n            }\n        }\n        ret\n    }\n    fn is_contiguous(&self, other: &Self) -> bool;\n    fn is_intersection_empty(&self, other: &Self) -> bool;\n    fn is_subset(&self, other: &Self) -> bool;\n}\n#[derive(Clone, Debug)]\npub struct IntervalSet<I> {\n    /// A sorted set of non-overlapping ranges.\n    ranges: Vec<I>,\n    /// While not required at all for correctness, we keep track of whether an\n    /// interval set has been case folded or not. This helps us avoid doing\n    /// redundant work if, for example, a set has already been cased folded.\n    /// And note that whether a set is folded or not is preserved through\n    /// all of the pairwise set operations. That is, if both interval sets\n    /// have been case folded, then any of difference, union, intersection or\n    /// symmetric difference all produce a case folded set.\n    ///\n    /// Note that when this is true, it *must* be the case that the set is case\n    /// folded. But when it's false, the set *may* be case folded. In other\n    /// words, we only set this to true when we know it to be case, but we're\n    /// okay with it being false if it would otherwise be costly to determine\n    /// whether it should be true. This means code cannot assume that a false\n    /// value necessarily indicates that the set is not case folded.\n    ///\n    /// Bottom line: this is a performance optimization.\n    folded: bool,\n}\nimpl<I: Interval> IntervalSet<I> {\n    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {}\n    pub fn push(&mut self, interval: I) {}\n    pub fn iter(&self) -> IntervalSetIter<'_, I> {}\n    pub fn intervals(&self) -> &[I] {}\n    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {}\n    pub fn union(&mut self, other: &IntervalSet<I>) {}\n    pub fn intersect(&mut self, other: &IntervalSet<I>) {}\n    pub fn difference(&mut self, other: &IntervalSet<I>) {\n        if self.ranges.is_empty() || other.ranges.is_empty() {\n            return;\n        }\n        let drain_end = self.ranges.len();\n        let (mut a, mut b) = (0, 0);\n        'LOOP: while a < drain_end && b < other.ranges.len() {\n            if other.ranges[b].upper() < self.ranges[a].lower() {\n                b += 1;\n                continue;\n            }\n            if self.ranges[a].upper() < other.ranges[b].lower() {\n                let range = self.ranges[a];\n                self.ranges.push(range);\n                a += 1;\n                continue;\n            }\n            assert!(! self.ranges[a].is_intersection_empty(& other.ranges[b]));\n            let mut range = self.ranges[a];\n            while b < other.ranges.len()\n                && !range.is_intersection_empty(&other.ranges[b])\n            {\n                let old_range = range;\n                range = match range.difference(&other.ranges[b]) {\n                    (None, None) => {\n                        a += 1;\n                        continue 'LOOP;\n                    }\n                    (Some(range1), None) | (None, Some(range1)) => range1,\n                    (Some(range1), Some(range2)) => {\n                        self.ranges.push(range1);\n                        range2\n                    }\n                };\n                if other.ranges[b].upper() > old_range.upper() {\n                    break;\n                }\n                b += 1;\n            }\n            self.ranges.push(range);\n            a += 1;\n        }\n        while a < drain_end {\n            let range = self.ranges[a];\n            self.ranges.push(range);\n            a += 1;\n        }\n        self.ranges.drain(..drain_end);\n        self.folded = self.folded && other.folded;\n    }\n    pub fn symmetric_difference(&mut self, other: &IntervalSet<I>) {}\n    pub fn negate(&mut self) {}\n    fn canonicalize(&mut self) {}\n    fn is_canonical(&self) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Subtract the given set from this set, in place.\n185 pub fn difference(&mut self, other: &IntervalSet<I>) {\n186     if self.ranges.is_empty() || other.ranges.is_empty() {\n187         return;\n188     }\n189 \n190     // This algorithm is (to me) surprisingly complex. A search of the\n191     // interwebs indicate that this is a potentially interesting problem.\n192     // Folks seem to suggest interval or segment trees, but I'd like to\n193     // avoid the overhead (both runtime and conceptual) of that.\n194     //\n195     // The following is basically my Shitty First Draft. Therefore, in\n196     // order to grok it, you probably need to read each line carefully.\n197     // Simplifications are most welcome!\n198     //\n199     // Remember, we can assume the canonical format invariant here, which\n200     // says that all ranges are sorted, not overlapping and not adjacent in\n201     // each class.\n202     let drain_end = self.ranges.len();\n203     let (mut a, mut b) = (0, 0);\n204     'LOOP: while a < drain_end && b < other.ranges.len() {\n205         // Basically, the easy cases are when neither range overlaps with\n206         // each other. If the `b` range is less than our current `a`\n207         // range, then we can skip it and move on.\n208         if other.ranges[b].upper() < self.ranges[a].lower() {\n209             b += 1;\n210             continue;\n211         }\n212         // ... similarly for the `a` range. If it's less than the smallest\n213         // `b` range, then we can add it as-is.\n214         if self.ranges[a].upper() < other.ranges[b].lower() {\n215             let range = self.ranges[a];\n216             self.ranges.push(range);\n217             a += 1;\n218             continue;\n219         }\n220         // Otherwise, we have overlapping ranges.\n221         assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));\n222 \n223         // This part is tricky and was non-obvious to me without looking\n224         // at explicit examples (see the tests). The trickiness stems from\n225         // two things: 1) subtracting a range from another range could\n226         // yield two ranges and 2) after subtracting a range, it's possible\n227         // that future ranges can have an impact. The loop below advances\n228         // the `b` ranges until they can't possible impact the current\n229         // range.\n230         //\n231         // For example, if our `a` range is `a-t` and our next three `b`\n232         // ranges are `a-c`, `g-i`, `r-t` and `x-z`, then we need to apply\n233         // subtraction three times before moving on to the next `a` range.\n234         let mut range = self.ranges[a];\n235         while b < other.ranges.len()\n236             && !range.is_intersection_empty(&other.ranges[b])\n237         {\n238             let old_range = range;\n239             range = match range.difference(&other.ranges[b]) {\n240                 (None, None) => {\n241                     // We lost the entire range, so move on to the next\n242                     // without adding this one.\n243                     a += 1;\n244                     continue 'LOOP;\n245                 }\n246                 (Some(range1), None) | (None, Some(range1)) => range1,\n247                 (Some(range1), Some(range2)) => {\n248                     self.ranges.push(range1);\n249                     range2\n250                 }\n251             };\n252             // It's possible that the `b` range has more to contribute\n253             // here. In particular, if it is greater than the original\n254             // range, then it might impact the next `a` range *and* it\n255             // has impacted the current `a` range as much as possible,\n256             // so we can quit. We don't bump `b` so that the next `a`\n257             // range can apply it.\n258             if other.ranges[b].upper() > old_range.upper() {\n259                 break;\n260             }\n261             // Otherwise, the next `b` range might apply to the current\n262             // `a` range.\n263             b += 1;\n264         }\n265         self.ranges.push(range);\n266         a += 1;\n267     }\n268     while a < drain_end {\n269         let range = self.ranges[a];\n270         self.ranges.push(range);\n271         a += 1;\n272     }\n273     self.ranges.drain(..drain_end);\n274     self.folded = self.folded && other.folded;\n275 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}