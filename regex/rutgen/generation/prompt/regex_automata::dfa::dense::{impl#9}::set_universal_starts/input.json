{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/dense.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\npub(crate) type OwnedDFA = DFA<alloc::vec::Vec<u32>>;\n#[cfg(feature = \"dfa-build\")]\nuse core::cmp;\nuse core::{fmt, iter, mem::size_of, slice};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{\n    collections::{BTreeMap, BTreeSet},\n    vec, vec::Vec,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::{\n    dfa::{accel::Accel, determinize, minimize::Minimizer, remapper::Remapper, sparse},\n    nfa::thompson, util::{look::LookMatcher, search::MatchKind},\n};\nuse crate::{\n    dfa::{\n        accel::Accels, automaton::{fmt_state_indicator, Automaton, StartError},\n        special::Special, start::StartKind, DEAD,\n    },\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        int::{Pointer, Usize},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-dense\";\nconst VERSION: u32 = 2;\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\npub(crate) trait U16 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn high_u8(self) -> u8;\n}\npub(crate) trait U32 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn high_u16(self) -> u16;\n}\npub(crate) trait Usize {\n    fn as_u8(self) -> u8;\n    fn as_u16(self) -> u16;\n    fn as_u32(self) -> u32;\n    fn as_u64(self) -> u64;\n}\npub(crate) trait U8 {\n    fn as_usize(self) -> usize;\n}\npub(crate) trait U64 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn low_u32(self) -> u32;\n    fn high_u32(self) -> u32;\n}\npub(crate) trait I32 {\n    fn as_usize(self) -> usize;\n    fn to_bits(self) -> u32;\n    fn from_bits(n: u32) -> i32;\n}\npub(crate) trait Pointer {\n    fn as_usize(self) -> usize;\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Start {\n    /// This occurs when the starting position is not any of the ones below.\n    NonWordByte = 0,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is an ASCII word byte.\n    WordByte = 1,\n    /// This occurs when the starting position of the search corresponds to the\n    /// beginning of the haystack.\n    Text = 2,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\n`.\n    LineLF = 3,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\r`.\n    LineCR = 4,\n    /// This occurs when a custom line terminator has been set via a\n    /// `LookMatcher`, and when that line terminator is neither a `\\r` or a\n    /// `\\n`.\n    ///\n    /// If the custom line terminator is a word byte, then this start\n    /// configuration is still selected. DFAs that implement word boundary\n    /// assertions will likely need to check whether the custom line terminator\n    /// is a word byte, in which case, it should behave as if the byte\n    /// satisfies `\\b` in addition to multi-line anchors.\n    CustomLineTerminator = 5,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum StartKind {\n    /// Support both anchored and unanchored searches.\n    Both,\n    /// Support only unanchored searches. Requesting an anchored search will\n    /// panic.\n    ///\n    /// Note that even if an unanchored search is requested, the pattern itself\n    /// may still be anchored. For example, `^abc` will only match `abc` at the\n    /// start of a haystack. This will remain true, even if the regex engine\n    /// only supported unanchored searches.\n    Unanchored,\n    /// Support only anchored searches. Requesting an unanchored search will\n    /// panic.\n    Anchored,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\n#[cfg(feature = \"dfa-build\")]\nimpl OwnedDFA {\n    pub(crate) fn set_start_state(\n        &mut self,\n        anchored: Anchored,\n        start: Start,\n        id: StateID,\n    ) {}\n    pub(crate) fn set_transition(\n        &mut self,\n        from: StateID,\n        byte: alphabet::Unit,\n        to: StateID,\n    ) {}\n    pub(crate) fn add_empty_state(&mut self) -> Result<StateID, BuildError> {}\n    pub(crate) fn swap_states(&mut self, id1: StateID, id2: StateID) {}\n    pub(crate) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {}\n    pub(crate) fn remap_state(&mut self, id: StateID, map: impl Fn(StateID) -> StateID) {}\n    pub(crate) fn truncate_states(&mut self, len: usize) {}\n    pub(crate) fn minimize(&mut self) {}\n    pub(crate) fn set_pattern_map(\n        &mut self,\n        map: &BTreeMap<StateID, Vec<PatternID>>,\n    ) -> Result<(), BuildError> {}\n    pub(crate) fn accelerate(&mut self) {}\n    pub(crate) fn shuffle(\n        &mut self,\n        mut matches: BTreeMap<StateID, Vec<PatternID>>,\n    ) -> Result<(), BuildError> {}\n    fn set_universal_starts(&mut self) {\n        assert_eq!(6, Start::len(), \"expected 6 start configurations\");\n        let start_id = |dfa: &mut OwnedDFA, anchored: Anchored, start: Start| {\n            dfa.st.start(anchored, start).expect(\"valid Input configuration\")\n        };\n        if self.start_kind().has_unanchored() {\n            let anchor = Anchored::No;\n            let sid = start_id(self, anchor, Start::NonWordByte);\n            if sid == start_id(self, anchor, Start::WordByte)\n                && sid == start_id(self, anchor, Start::Text)\n                && sid == start_id(self, anchor, Start::LineLF)\n                && sid == start_id(self, anchor, Start::LineCR)\n                && sid == start_id(self, anchor, Start::CustomLineTerminator)\n            {\n                self.st.universal_start_unanchored = Some(sid);\n            }\n        }\n        if self.start_kind().has_anchored() {\n            let anchor = Anchored::Yes;\n            let sid = start_id(self, anchor, Start::NonWordByte);\n            if sid == start_id(self, anchor, Start::WordByte)\n                && sid == start_id(self, anchor, Start::Text)\n                && sid == start_id(self, anchor, Start::LineLF)\n                && sid == start_id(self, anchor, Start::LineCR)\n                && sid == start_id(self, anchor, Start::CustomLineTerminator)\n            {\n                self.st.universal_start_anchored = Some(sid);\n            }\n        }\n    }\n}\nimpl Start {\n    pub(crate) fn from_usize(n: usize) -> Option<Start> {}\n    pub(crate) fn len() -> usize {\n        6\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn as_u8(&self) -> u8 {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn as_usize(&self) -> usize {}\n}\nimpl StartKind {\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(StartKind, usize), DeserializeError> {}\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn has_unanchored(&self) -> bool {\n        matches!(* self, StartKind::Both | StartKind::Unanchored)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn has_anchored(&self) -> bool {\n        matches!(* self, StartKind::Both | StartKind::Anchored)\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Checks whether there are universal start states (both anchored and\n/// unanchored), and if so, sets the relevant fields to the start state\n/// IDs.\n///\n/// Universal start states occur precisely when the all patterns in the\n/// DFA have no look-around assertions in their prefix.\n2904 fn set_universal_starts(&mut self) {\n2905     assert_eq!(6, Start::len(), \"expected 6 start configurations\");\n2906 \n2907     let start_id = |dfa: &mut OwnedDFA,\n2908                     anchored: Anchored,\n2909                     start: Start| {\n2910         // This OK because we only call 'start' under conditions\n2911         // in which we know it will succeed.\n2912         dfa.st.start(anchored, start).expect(\"valid Input configuration\")\n2913     };\n2914     if self.start_kind().has_unanchored() {\n2915         let anchor = Anchored::No;\n2916         let sid = start_id(self, anchor, Start::NonWordByte);\n2917         if sid == start_id(self, anchor, Start::WordByte)\n2918             && sid == start_id(self, anchor, Start::Text)\n2919             && sid == start_id(self, anchor, Start::LineLF)\n2920             && sid == start_id(self, anchor, Start::LineCR)\n2921             && sid == start_id(self, anchor, Start::CustomLineTerminator)\n2922         {\n2923             self.st.universal_start_unanchored = Some(sid);\n2924         }\n2925     }\n2926     if self.start_kind().has_anchored() {\n2927         let anchor = Anchored::Yes;\n2928         let sid = start_id(self, anchor, Start::NonWordByte);\n2929         if sid == start_id(self, anchor, Start::WordByte)\n2930             && sid == start_id(self, anchor, Start::Text)\n2931             && sid == start_id(self, anchor, Start::LineLF)\n2932             && sid == start_id(self, anchor, Start::LineCR)\n2933             && sid == start_id(self, anchor, Start::CustomLineTerminator)\n2934         {\n2935             self.st.universal_start_anchored = Some(sid);\n2936         }\n2937     }\n2938 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}