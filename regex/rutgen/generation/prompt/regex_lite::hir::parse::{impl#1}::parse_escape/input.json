{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/hir/parse.rs\n// crate name is regex_lite\nuse core::cell::{Cell, RefCell};\nuse alloc::{\n    boxed::Box, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{error::Error, hir::{self, Config, Flags, Hir, HirKind}};\nconst ERR_TOO_MUCH_NESTING: &str = \"pattern has too much nesting\";\nconst ERR_TOO_MANY_CAPTURES: &str = \"too many capture groups\";\nconst ERR_DUPLICATE_CAPTURE_NAME: &str = \"duplicate capture group name\";\nconst ERR_UNCLOSED_GROUP: &str = \"found open group without closing ')'\";\nconst ERR_UNCLOSED_GROUP_QUESTION: &str = \"expected closing ')', but got end of pattern\";\nconst ERR_UNOPENED_GROUP: &str = \"found closing ')' without matching '('\";\nconst ERR_LOOK_UNSUPPORTED: &str = \"look-around is not supported\";\nconst ERR_EMPTY_FLAGS: &str = \"empty flag directive '(?)' is not allowed\";\nconst ERR_MISSING_GROUP_NAME: &str = \"expected capture group name, but got end of pattern\";\nconst ERR_INVALID_GROUP_NAME: &str = \"invalid group name\";\nconst ERR_UNCLOSED_GROUP_NAME: &str = \"expected end of capture group name, but got end of pattern\";\nconst ERR_EMPTY_GROUP_NAME: &str = \"empty capture group names are not allowed\";\nconst ERR_FLAG_UNRECOGNIZED: &str = \"unrecognized inline flag\";\nconst ERR_FLAG_REPEATED_NEGATION: &str = \"inline flag negation cannot be repeated\";\nconst ERR_FLAG_DUPLICATE: &str = \"duplicate inline flag is not allowed\";\nconst ERR_FLAG_UNEXPECTED_EOF: &str = \"expected ':' or ')' to end inline flags, but got end of pattern\";\nconst ERR_FLAG_DANGLING_NEGATION: &str = \"inline flags cannot end with negation directive\";\nconst ERR_DECIMAL_NO_DIGITS: &str = \"expected decimal number, but found no digits\";\nconst ERR_DECIMAL_INVALID: &str = \"got invalid decimal number\";\nconst ERR_HEX_BRACE_INVALID_DIGIT: &str = \"expected hexadecimal number in braces, but got non-hex digit\";\nconst ERR_HEX_BRACE_UNEXPECTED_EOF: &str = \"expected hexadecimal number, but saw end of pattern before closing brace\";\nconst ERR_HEX_BRACE_EMPTY: &str = \"expected hexadecimal number in braces, but got no digits\";\nconst ERR_HEX_BRACE_INVALID: &str = \"got invalid hexadecimal number in braces\";\nconst ERR_HEX_FIXED_UNEXPECTED_EOF: &str = \"expected fixed length hexadecimal number, but saw end of pattern first\";\nconst ERR_HEX_FIXED_INVALID_DIGIT: &str = \"expected fixed length hexadecimal number, but got non-hex digit\";\nconst ERR_HEX_FIXED_INVALID: &str = \"got invalid fixed length hexadecimal number\";\nconst ERR_HEX_UNEXPECTED_EOF: &str = \"expected hexadecimal number, but saw end of pattern first\";\nconst ERR_ESCAPE_UNEXPECTED_EOF: &str = \"saw start of escape sequence, but saw end of pattern before it finished\";\nconst ERR_BACKREF_UNSUPPORTED: &str = \"backreferences are not supported\";\nconst ERR_UNICODE_CLASS_UNSUPPORTED: &str = \"Unicode character classes are not supported\";\nconst ERR_ESCAPE_UNRECOGNIZED: &str = \"unrecognized escape sequence\";\nconst ERR_POSIX_CLASS_UNRECOGNIZED: &str = \"unrecognized POSIX character class\";\nconst ERR_UNCOUNTED_REP_SUB_MISSING: &str = \"uncounted repetition operator must be applied to a sub-expression\";\nconst ERR_COUNTED_REP_SUB_MISSING: &str = \"counted repetition operator must be applied to a sub-expression\";\nconst ERR_COUNTED_REP_UNCLOSED: &str = \"found unclosed counted repetition operator\";\nconst ERR_COUNTED_REP_MIN_UNCLOSED: &str = \"found incomplete and unclosed counted repetition operator\";\nconst ERR_COUNTED_REP_COMMA_UNCLOSED: &str = \"found counted repetition operator with a comma that is unclosed\";\nconst ERR_COUNTED_REP_MIN_MAX_UNCLOSED: &str = \"found counted repetition with min and max that is unclosed\";\nconst ERR_COUNTED_REP_INVALID: &str = \"expected closing brace for counted repetition, but got something else\";\nconst ERR_COUNTED_REP_INVALID_RANGE: &str = \"found counted repetition with a min bigger than its max\";\nconst ERR_CLASS_UNCLOSED_AFTER_ITEM: &str = \"non-empty character class has no closing bracket\";\nconst ERR_CLASS_INVALID_RANGE_ITEM: &str = \"character class ranges must start and end with a single character\";\nconst ERR_CLASS_INVALID_ITEM: &str = \"invalid escape sequence in character class\";\nconst ERR_CLASS_UNCLOSED_AFTER_DASH: &str = \"non-empty character class has no closing bracket after dash\";\nconst ERR_CLASS_UNCLOSED_AFTER_NEGATION: &str = \"negated character class has no closing bracket\";\nconst ERR_CLASS_UNCLOSED_AFTER_CLOSING: &str = \"character class begins with literal ']' but has no closing bracket\";\nconst ERR_CLASS_INVALID_RANGE: &str = \"invalid range in character class\";\nconst ERR_CLASS_UNCLOSED: &str = \"found unclosed character class\";\nconst ERR_CLASS_NEST_UNSUPPORTED: &str = \"nested character classes are not supported\";\nconst ERR_CLASS_INTERSECTION_UNSUPPORTED: &str = \"character class intersection is not supported\";\nconst ERR_CLASS_DIFFERENCE_UNSUPPORTED: &str = \"character class difference is not supported\";\nconst ERR_CLASS_SYMDIFFERENCE_UNSUPPORTED: &str = \"character class symmetric difference is not supported\";\nconst ERR_SPECIAL_WORD_BOUNDARY_UNCLOSED: &str = \"special word boundary assertion is unclosed or has an invalid character\";\nconst ERR_SPECIAL_WORD_BOUNDARY_UNRECOGNIZED: &str = \"special word boundary assertion is unrecognized\";\nconst ERR_SPECIAL_WORD_OR_REP_UNEXPECTED_EOF: &str = \"found start of special word boundary or repetition without an end\";\n#[derive(Clone, Debug)]\npub(super) struct Parser<'a> {\n    /// The configuration of the parser as given by the caller.\n    config: Config,\n    /// The pattern we're parsing as given by the caller.\n    pattern: &'a str,\n    /// The call depth of the parser. This is incremented for each\n    /// sub-expression parsed. Its peak value is the maximum nesting of the\n    /// pattern.\n    depth: Cell<u32>,\n    /// The current position of the parser.\n    pos: Cell<usize>,\n    /// The current codepoint of the parser. The codepoint corresponds to the\n    /// codepoint encoded in `pattern` beginning at `pos`.\n    ///\n    /// This is `None` if and only if `pos == pattern.len()`.\n    char: Cell<Option<char>>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The flags that are currently set.\n    flags: RefCell<Flags>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<String>>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    msg: &'static str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) struct Hir {\n    kind: HirKind,\n    is_start_anchored: bool,\n    is_match_empty: bool,\n    static_explicit_captures_len: Option<usize>,\n}\n#[derive(Clone, Copy, Debug, Default)]\npub(crate) struct Flags {\n    /// Whether to match case insensitively.\n    ///\n    /// This is the `i` flag.\n    pub(crate) case_insensitive: bool,\n    /// Whether `^` and `$` should be treated as line anchors or not.\n    ///\n    /// This is the `m` flag.\n    pub(crate) multi_line: bool,\n    /// Whether `.` should match line terminators or not.\n    ///\n    /// This is the `s` flag.\n    pub(crate) dot_matches_new_line: bool,\n    /// Whether to swap the meaning of greedy and non-greedy operators.\n    ///\n    /// This is the `U` flag.\n    pub(crate) swap_greed: bool,\n    /// Whether to enable CRLF mode.\n    ///\n    /// This is the `R` flag.\n    pub(crate) crlf: bool,\n    /// Whether to ignore whitespace. i.e., verbose mode.\n    ///\n    /// This is the `x` flag.\n    pub(crate) ignore_whitespace: bool,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Config {\n    /// The maximum number of times we're allowed to recurse.\n    ///\n    /// Note that unlike the regex-syntax parser, we actually use recursion in\n    /// this parser for simplicity. My hope is that by setting a conservative\n    /// default call limit and providing a way to configure it, that we can\n    /// keep this simplification. But if we must, we can re-work the parser to\n    /// put the call stack on the heap like regex-syntax does.\n    pub(crate) nest_limit: u32,\n    /// Various flags that control how a pattern is interpreted.\n    pub(crate) flags: Flags,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Config {\n    pub(crate) size_limit: Option<usize>,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Look {\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    Start = 1 << 0,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    End = 1 << 1,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLF = 1 << 2,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\n` character.\n    EndLF = 1 << 3,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following either a `\\r` or `\\n` character, but never after\n    /// a `\\r` when a `\\n` follows.\n    StartCRLF = 1 << 4,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\r` or `\\n` character, but never before a `\\n` when a `\\r`\n    /// precedes it.\n    EndCRLF = 1 << 5,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    Word = 1 << 6,\n    /// Match an ASCII-only negation of a word boundary.\n    WordNegate = 1 << 7,\n    /// Match the start of an ASCII-only word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStart = 1 << 8,\n    /// Match the end of an ASCII-only word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEnd = 1 << 9,\n    /// Match the start half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalf = 1 << 10,\n    /// Match the end half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the end of the haystack or where the\n    /// following character is not a word character.\n    WordEndHalf = 1 << 11,\n}\nimpl<'a> Parser<'a> {\n    pub(super) fn parse(&self) -> Result<Hir, Error> {}\n    fn parse_inner(&self) -> Result<Hir, Error> {}\n    fn parse_primitive(&self) -> Result<Hir, Error> {}\n    fn parse_escape(&self) -> Result<Hir, Error> {\n        if self.is_done() {\n            return Err(Error::new(ERR_ESCAPE_UNEXPECTED_EOF));\n        }\n        let ch = self.char();\n        match ch {\n            '0'..='9' => return Err(Error::new(ERR_BACKREF_UNSUPPORTED)),\n            'p' | 'P' => return Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)),\n            'x' | 'u' | 'U' => return self.parse_hex(),\n            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n                return Ok(self.parse_perl_class());\n            }\n            _ => {}\n        }\n        self.bump();\n        if hir::is_meta_character(ch) || hir::is_escapeable_character(ch) {\n            return Ok(self.hir_char(ch));\n        }\n        let special = |ch| Ok(self.hir_char(ch));\n        match ch {\n            'a' => special('\\x07'),\n            'f' => special('\\x0C'),\n            't' => special('\\t'),\n            'n' => special('\\n'),\n            'r' => special('\\r'),\n            'v' => special('\\x0B'),\n            'A' => Ok(Hir::look(hir::Look::Start)),\n            'z' => Ok(Hir::look(hir::Look::End)),\n            'b' => {\n                let mut hir = Hir::look(hir::Look::Word);\n                if !self.is_done() && self.char() == '{' {\n                    if let Some(special) = self.maybe_parse_special_word_boundary()? {\n                        hir = special;\n                    }\n                }\n                Ok(hir)\n            }\n            'B' => Ok(Hir::look(hir::Look::WordNegate)),\n            '<' => Ok(Hir::look(hir::Look::WordStart)),\n            '>' => Ok(Hir::look(hir::Look::WordEnd)),\n            _ => Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)),\n        }\n    }\n    fn maybe_parse_special_word_boundary(&self) -> Result<Option<Hir>, Error> {\n        assert_eq!(self.char(), '{');\n        let is_valid_char = |c| match c {\n            'A'..='Z' | 'a'..='z' | '-' => true,\n            _ => false,\n        };\n        let start = self.pos();\n        if !self.bump_and_bump_space() {\n            return Err(Error::new(ERR_SPECIAL_WORD_OR_REP_UNEXPECTED_EOF));\n        }\n        if !is_valid_char(self.char()) {\n            self.pos.set(start);\n            self.char.set(Some('{'));\n            return Ok(None);\n        }\n        let mut scratch = String::new();\n        while !self.is_done() && is_valid_char(self.char()) {\n            scratch.push(self.char());\n            self.bump_and_bump_space();\n        }\n        if self.is_done() || self.char() != '}' {\n            return Err(Error::new(ERR_SPECIAL_WORD_BOUNDARY_UNCLOSED));\n        }\n        self.bump();\n        let kind = match scratch.as_str() {\n            \"start\" => hir::Look::WordStart,\n            \"end\" => hir::Look::WordEnd,\n            \"start-half\" => hir::Look::WordStartHalf,\n            \"end-half\" => hir::Look::WordEndHalf,\n            _ => return Err(Error::new(ERR_SPECIAL_WORD_BOUNDARY_UNRECOGNIZED)),\n        };\n        Ok(Some(Hir::look(kind)))\n    }\n    fn parse_hex(&self) -> Result<Hir, Error> {\n        let digit_len = match self.char() {\n            'x' => 2,\n            'u' => 4,\n            'U' => 8,\n            unk => {\n                unreachable!(\"invalid start of fixed length hexadecimal number {}\", unk)\n            }\n        };\n        if !self.bump_and_bump_space() {\n            return Err(Error::new(ERR_HEX_UNEXPECTED_EOF));\n        }\n        if self.char() == '{' {\n            self.parse_hex_brace()\n        } else {\n            self.parse_hex_digits(digit_len)\n        }\n    }\n    fn parse_hex_digits(&self, digit_len: usize) -> Result<Hir, Error> {}\n    fn parse_hex_brace(&self) -> Result<Hir, Error> {}\n    fn parse_decimal(&self) -> Result<u32, Error> {}\n    fn parse_uncounted_repetition(\n        &self,\n        mut concat: Vec<Hir>,\n    ) -> Result<Vec<Hir>, Error> {}\n    fn parse_counted_repetition(&self, mut concat: Vec<Hir>) -> Result<Vec<Hir>, Error> {}\n    fn parse_group(&self) -> Result<Option<Hir>, Error> {}\n    fn parse_capture_name(&self) -> Result<&str, Error> {}\n    fn parse_flags(&self) -> Result<Flags, Error> {}\n    fn parse_flag(&self, flags: &mut Flags, negate: bool) -> Result<(), Error> {}\n    fn parse_class(&self) -> Result<Hir, Error> {}\n    fn parse_class_range(&self, union: &mut Vec<hir::ClassRange>) -> Result<(), Error> {}\n    fn parse_class_item(&self) -> Result<Hir, Error> {}\n    fn maybe_parse_posix_class(&self) -> Option<hir::Class> {}\n    fn parse_perl_class(&self) -> Hir {\n        let ch = self.char();\n        self.bump();\n        let mut class = hir::Class::new(\n            match ch {\n                'd' | 'D' => posix_class(\"digit\").unwrap(),\n                's' | 'S' => posix_class(\"space\").unwrap(),\n                'w' | 'W' => posix_class(\"word\").unwrap(),\n                unk => unreachable!(\"invalid Perl class \\\\{}\", unk),\n            },\n        );\n        if ch.is_ascii_uppercase() {\n            class.negate();\n        }\n        Hir::class(class)\n    }\n    fn hir_dot(&self) -> Hir {}\n    fn hir_anchor_start(&self) -> Hir {}\n    fn hir_anchor_end(&self) -> Hir {}\n    fn hir_char(&self, ch: char) -> Hir {\n        if self.flags().case_insensitive {\n            let this = hir::ClassRange {\n                start: ch,\n                end: ch,\n            };\n            if let Some(folded) = this.ascii_case_fold() {\n                return Hir::class(hir::Class::new([this, folded]));\n            }\n        }\n        Hir::char(ch)\n    }\n}\nimpl Error {\n    pub(crate) fn new(msg: &'static str) -> Error {\n        Error { msg }\n    }\n}\nimpl Hir {\n    pub(crate) fn parse(config: Config, pattern: &str) -> Result<Hir, Error> {}\n    pub(crate) fn kind(&self) -> &HirKind {}\n    pub(crate) fn is_start_anchored(&self) -> bool {}\n    pub(crate) fn is_match_empty(&self) -> bool {}\n    pub(crate) fn static_explicit_captures_len(&self) -> Option<usize> {}\n    fn fail() -> Hir {}\n    fn empty() -> Hir {}\n    fn char(ch: char) -> Hir {}\n    fn class(class: Class) -> Hir {}\n    fn look(look: Look) -> Hir {\n        let kind = HirKind::Look(look);\n        Hir {\n            kind,\n            is_start_anchored: matches!(look, Look::Start),\n            is_match_empty: true,\n            static_explicit_captures_len: Some(0),\n        }\n    }\n    fn repetition(rep: Repetition) -> Hir {}\n    fn capture(cap: Capture) -> Hir {}\n    fn concat(mut subs: Vec<Hir>) -> Hir {}\n    fn alternation(mut subs: Vec<Hir>) -> Hir {}\n}\nfn is_meta_character(c: char) -> bool {\n    match c {\n        '\\\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{' | '}' | '^'\n        | '$' | '#' | '&' | '-' | '~' => true,\n        _ => false,\n    }\n}\nfn is_escapeable_character(c: char) -> bool {\n    if is_meta_character(c) {\n        return true;\n    }\n    if !c.is_ascii() {\n        return false;\n    }\n    match c {\n        '0'..='9' | 'A'..='Z' | 'a'..='z' => false,\n        '<' | '>' => false,\n        _ => true,\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Parse an escape sequence. This always results in a \"primitive\" HIR,\n/// that is, an HIR with no sub-expressions.\n///\n/// This assumes the parser is positioned at the start of the sequence,\n/// immediately *after* the `\\`. It advances the parser to the first\n/// position immediately following the escape sequence.\n473 fn parse_escape(&self) -> Result<Hir, Error> {\n474     if self.is_done() {\n475         return Err(Error::new(ERR_ESCAPE_UNEXPECTED_EOF));\n476     }\n477     let ch = self.char();\n478     // Put some of the more complicated routines into helpers.\n479     match ch {\n480         '0'..='9' => return Err(Error::new(ERR_BACKREF_UNSUPPORTED)),\n481         'p' | 'P' => {\n482             return Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED))\n483         }\n484         'x' | 'u' | 'U' => return self.parse_hex(),\n485         'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n486             return Ok(self.parse_perl_class());\n487         }\n488         _ => {}\n489     }\n490 \n491     // Handle all of the one letter sequences inline.\n492     self.bump();\n493     if hir::is_meta_character(ch) || hir::is_escapeable_character(ch) {\n494         return Ok(self.hir_char(ch));\n495     }\n496     let special = |ch| Ok(self.hir_char(ch));\n497     match ch {\n498         'a' => special('\\x07'),\n499         'f' => special('\\x0C'),\n500         't' => special('\\t'),\n501         'n' => special('\\n'),\n502         'r' => special('\\r'),\n503         'v' => special('\\x0B'),\n504         'A' => Ok(Hir::look(hir::Look::Start)),\n505         'z' => Ok(Hir::look(hir::Look::End)),\n506         'b' => {\n507             let mut hir = Hir::look(hir::Look::Word);\n508             if !self.is_done() && self.char() == '{' {\n509                 if let Some(special) =\n510                     self.maybe_parse_special_word_boundary()?\n511                 {\n512                     hir = special;\n513                 }\n514             }\n515             Ok(hir)\n516         }\n517         'B' => Ok(Hir::look(hir::Look::WordNegate)),\n518         '<' => Ok(Hir::look(hir::Look::WordStart)),\n519         '>' => Ok(Hir::look(hir::Look::WordEnd)),\n520         _ => Err(Error::new(ERR_ESCAPE_UNRECOGNIZED)),\n521     }\n522 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}