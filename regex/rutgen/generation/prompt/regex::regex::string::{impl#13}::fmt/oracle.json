{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/regex/string.rs\n// crate name is regex\npub type Locations = CaptureLocations;\nuse alloc::{borrow::Cow, string::String, sync::Arc};\nuse regex_automata::{meta, util::captures, Input, PatternID};\nuse crate::{error::Error, RegexBuilder};\npub struct Captures<'h> {\n    haystack: &'h str,\n    caps: captures::Captures,\n    static_captures_len: Option<usize>,\n}\npub struct Captures<'h> {\n    haystack: &'h [u8],\n    caps: captures::Captures,\n    static_captures_len: Option<usize>,\n}\nimpl<'h> core::fmt::Debug for Captures<'h> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        /// A little helper type to provide a nice map-like debug\n        /// representation for our capturing group spans.\n        ///\n        /// regex-automata has something similar, but it includes the pattern\n        /// ID in its debug output, which is confusing. It also doesn't include\n        /// that strings that match because a regex-automata `Captures` doesn't\n        /// borrow the haystack.\n        struct CapturesDebugMap<'a> {\n            caps: &'a Captures<'a>,\n        }\n        impl<'a> core::fmt::Debug for CapturesDebugMap<'a> {\n            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                let mut map = f.debug_map();\n                let names = self.caps.caps.group_info().pattern_names(PatternID::ZERO);\n                for (group_index, maybe_name) in names.enumerate() {\n                    let key = Key(group_index, maybe_name);\n                    match self.caps.get(group_index) {\n                        None => map.entry(&key, &None::<()>),\n                        Some(mat) => map.entry(&key, &Value(mat)),\n                    };\n                }\n                map.finish()\n            }\n        }\n        struct Key<'a>(usize, Option<&'a str>);\n        impl<'a> core::fmt::Debug for Key<'a> {\n            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                write!(f, \"{}\", self.0)?;\n                if let Some(name) = self.1 {\n                    write!(f, \"/{:?}\", name)?;\n                }\n                Ok(())\n            }\n        }\n        struct Value<'a>(Match<'a>);\n        impl<'a> core::fmt::Debug for Value<'a> {\n            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                write!(f, \"{}..{}/{:?}\", self.0.start(), self.0.end(), self.0.as_str())\n            }\n        }\n        f.debug_tuple(\"Captures\").field(&CapturesDebugMap { caps: self }).finish()\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1921 fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n1922     /// A little helper type to provide a nice map-like debug\n1923     /// representation for our capturing group spans.\n1924     ///\n1925     /// regex-automata has something similar, but it includes the pattern\n1926     /// ID in its debug output, which is confusing. It also doesn't include\n1927     /// that strings that match because a regex-automata `Captures` doesn't\n1928     /// borrow the haystack.\n1929     struct CapturesDebugMap<'a> {\n1930         caps: &'a Captures<'a>,\n1931     }\n1932 \n1933     impl<'a> core::fmt::Debug for CapturesDebugMap<'a> {\n1934         fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n1935             let mut map = f.debug_map();\n1936             let names =\n1937                 self.caps.caps.group_info().pattern_names(PatternID::ZERO);\n1938             for (group_index, maybe_name) in names.enumerate() {\n1939                 let key = Key(group_index, maybe_name);\n1940                 match self.caps.get(group_index) {\n1941                     None => map.entry(&key, &None::<()>),\n1942                     Some(mat) => map.entry(&key, &Value(mat)),\n1943                 };\n1944             }\n1945             map.finish()\n1946         }\n1947     }\n1948 \n1949     struct Key<'a>(usize, Option<&'a str>);\n1950 \n1951     impl<'a> core::fmt::Debug for Key<'a> {\n1952         fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n1953             write!(f, \"{}\", self.0)?;\n1954             if let Some(name) = self.1 {\n1955                 write!(f, \"/{:?}\", name)?;\n1956             }\n1957             Ok(())\n1958         }\n1959     }\n1960 \n1961     struct Value<'a>(Match<'a>);\n1962 \n1963     impl<'a> core::fmt::Debug for Value<'a> {\n1964         fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n1965             write!(\n1966                 f,\n1967                 \"{}..{}/{:?}\",\n1968                 self.0.start(),\n1969                 self.0.end(),\n1970                 self.0.as_str()\n1971             )\n1972         }\n1973     }\n1974 \n1975     f.debug_tuple(\"Captures\")\n1976         .field(&CapturesDebugMap { caps: self })\n1977         .finish()\n1978 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}