{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/prefilter/mod.rs\n// crate name is regex_automata\nuse core::{borrow::Borrow, fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\n#[cfg(feature = \"alloc\")]\nuse alloc::sync::Arc;\n#[cfg(feature = \"syntax\")]\nuse regex_syntax::hir::{literal, Hir};\nuse crate::util::search::{MatchKind, Span};\npub(crate) use crate::util::prefilter::{\n    aho_corasick::AhoCorasick, byteset::ByteSet, memchr::{Memchr, Memchr2, Memchr3},\n    memmem::Memmem, teddy::Teddy,\n};\n#[derive(Clone, Debug)]\npub(crate) struct Memchr(u8);\n#[derive(Clone, Debug)]\npub(crate) struct Memchr3(u8, u8, u8);\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[derive(Clone, Debug)]\npub(crate) struct Memmem {\n    #[cfg(not(all(feature = \"std\", feature = \"perf-literal-substring\")))]\n    _unused: (),\n    #[cfg(all(feature = \"std\", feature = \"perf-literal-substring\"))]\n    finder: memchr::memmem::Finder<'static>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Teddy {\n    #[cfg(not(feature = \"perf-literal-multisubstring\"))]\n    _unused: (),\n    /// The actual Teddy searcher.\n    ///\n    /// Technically, it's possible that Teddy doesn't actually get used, since\n    /// Teddy does require its haystack to at least be of a certain size\n    /// (usually around the size of whatever vector is being used, so ~16\n    /// or ~32 bytes). For haystacks shorter than that, the implementation\n    /// currently uses Rabin-Karp.\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    searcher: aho_corasick::packed::Searcher,\n    /// When running an anchored search, the packed searcher can't handle it so\n    /// we defer to Aho-Corasick itself. Kind of sad, but changing the packed\n    /// searchers to support anchored search would be difficult at worst and\n    /// annoying at best. Since packed searchers only apply to small numbers of\n    /// literals, we content ourselves that this is not much of an added cost.\n    /// (That packed searchers only work with a small number of literals is\n    /// also why we use a DFA here. Otherwise, the memory usage of a DFA would\n    /// likely be unacceptable.)\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    anchored_ac: aho_corasick::dfa::DFA,\n    /// The length of the smallest literal we look for.\n    ///\n    /// We use this as a heuristic to figure out whether this will be \"fast\" or\n    /// not. Generally, the longer the better, because longer needles are more\n    /// discriminating and thus reduce false positive rate.\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    minimum_len: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) struct AhoCorasick {\n    #[cfg(not(feature = \"perf-literal-multisubstring\"))]\n    _unused: (),\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    ac: aho_corasick::AhoCorasick,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Memchr2(u8, u8);\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]\npub(crate) struct ByteSet {\n    bits: BitSet,\n}\n#[derive(Clone, Debug)]\npub(crate) enum Choice {\n    Memchr(Memchr),\n    Memchr2(Memchr2),\n    Memchr3(Memchr3),\n    Memmem(Memmem),\n    Teddy(Teddy),\n    ByteSet(ByteSet),\n    AhoCorasick(AhoCorasick),\n}\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\nimpl Choice {\n    pub(crate) fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Choice> {\n        if needles.len() == 0 {\n            debug!(\"prefilter building failed: found empty set of literals\");\n            return None;\n        }\n        if needles.iter().any(|n| n.as_ref().is_empty()) {\n            debug!(\"prefilter building failed: literals match empty string\");\n            return None;\n        }\n        if let Some(pre) = Memchr::new(kind, needles) {\n            debug!(\"prefilter built: memchr\");\n            return Some(Choice::Memchr(pre));\n        }\n        if let Some(pre) = Memchr2::new(kind, needles) {\n            debug!(\"prefilter built: memchr2\");\n            return Some(Choice::Memchr2(pre));\n        }\n        if let Some(pre) = Memchr3::new(kind, needles) {\n            debug!(\"prefilter built: memchr3\");\n            return Some(Choice::Memchr3(pre));\n        }\n        if let Some(pre) = Memmem::new(kind, needles) {\n            debug!(\"prefilter built: memmem\");\n            return Some(Choice::Memmem(pre));\n        }\n        if let Some(pre) = Teddy::new(kind, needles) {\n            debug!(\"prefilter built: teddy\");\n            return Some(Choice::Teddy(pre));\n        }\n        if let Some(pre) = ByteSet::new(kind, needles) {\n            debug!(\"prefilter built: byteset\");\n            return Some(Choice::ByteSet(pre));\n        }\n        if let Some(pre) = AhoCorasick::new(kind, needles) {\n            debug!(\"prefilter built: aho-corasick\");\n            return Some(Choice::AhoCorasick(pre));\n        }\n        debug!(\"prefilter building failed: no strategy could be found\");\n        None\n    }\n}\nimpl Memchr {\n    pub(crate) fn new<B: AsRef<[u8]>>(\n        _kind: MatchKind,\n        needles: &[B],\n    ) -> Option<Memchr> {\n        #[cfg(not(feature = \"perf-literal-substring\"))] { None }\n        #[cfg(feature = \"perf-literal-substring\")]\n        {\n            if needles.len() != 1 {\n                return None;\n            }\n            if needles[0].as_ref().len() != 1 {\n                return None;\n            }\n            Some(Memchr(needles[0].as_ref()[0]))\n        }\n    }\n}\nimpl Memchr3 {\n    pub(crate) fn new<B: AsRef<[u8]>>(\n        _kind: MatchKind,\n        needles: &[B],\n    ) -> Option<Memchr3> {\n        #[cfg(not(feature = \"perf-literal-substring\"))] { None }\n        #[cfg(feature = \"perf-literal-substring\")]\n        {\n            if needles.len() != 3 {\n                return None;\n            }\n            if !needles.iter().all(|n| n.as_ref().len() == 1) {\n                return None;\n            }\n            let b1 = needles[0].as_ref()[0];\n            let b2 = needles[1].as_ref()[0];\n            let b3 = needles[2].as_ref()[0];\n            Some(Memchr3(b1, b2, b3))\n        }\n    }\n}\nimpl ByteSet {\n    pub(crate) fn new<B: AsRef<[u8]>>(\n        _kind: MatchKind,\n        needles: &[B],\n    ) -> Option<ByteSet> {\n        #[cfg(not(feature = \"perf-literal-multisubstring\"))] { None }\n        #[cfg(feature = \"perf-literal-multisubstring\")]\n        {\n            let mut set = [false; 256];\n            for needle in needles.iter() {\n                let needle = needle.as_ref();\n                if needle.len() != 1 {\n                    return None;\n                }\n                set[usize::from(needle[0])] = true;\n            }\n            Some(ByteSet(set))\n        }\n    }\n}\nimpl Memmem {\n    pub(crate) fn new<B: AsRef<[u8]>>(\n        _kind: MatchKind,\n        needles: &[B],\n    ) -> Option<Memmem> {\n        #[cfg(not(all(feature = \"std\", feature = \"perf-literal-substring\")))] { None }\n        #[cfg(all(feature = \"std\", feature = \"perf-literal-substring\"))]\n        {\n            if needles.len() != 1 {\n                return None;\n            }\n            let needle = needles[0].as_ref();\n            let finder = memchr::memmem::Finder::new(needle).into_owned();\n            Some(Memmem { finder })\n        }\n    }\n}\nimpl Teddy {\n    pub(crate) fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Teddy> {\n        #[cfg(not(feature = \"perf-literal-multisubstring\"))] { None }\n        #[cfg(feature = \"perf-literal-multisubstring\")]\n        {\n            let (packed_match_kind, ac_match_kind) = match kind {\n                MatchKind::LeftmostFirst | MatchKind::All => {\n                    (\n                        aho_corasick::packed::MatchKind::LeftmostFirst,\n                        aho_corasick::MatchKind::LeftmostFirst,\n                    )\n                }\n            };\n            let minimum_len = needles\n                .iter()\n                .map(|n| n.as_ref().len())\n                .min()\n                .unwrap_or(0);\n            let packed = aho_corasick::packed::Config::new()\n                .match_kind(packed_match_kind)\n                .builder()\n                .extend(needles)\n                .build()?;\n            let anchored_ac = aho_corasick::dfa::DFA::builder()\n                .match_kind(ac_match_kind)\n                .start_kind(aho_corasick::StartKind::Anchored)\n                .prefilter(false)\n                .build(needles)\n                .ok()?;\n            Some(Teddy {\n                searcher: packed,\n                anchored_ac,\n                minimum_len,\n            })\n        }\n    }\n}\nimpl AhoCorasick {\n    pub(crate) fn new<B: AsRef<[u8]>>(\n        kind: MatchKind,\n        needles: &[B],\n    ) -> Option<AhoCorasick> {\n        #[cfg(not(feature = \"perf-literal-multisubstring\"))] { None }\n        #[cfg(feature = \"perf-literal-multisubstring\")]\n        {\n            let ac_match_kind = match kind {\n                MatchKind::LeftmostFirst | MatchKind::All => {\n                    aho_corasick::MatchKind::LeftmostFirst\n                }\n            };\n            let ac_kind = if needles.len() <= 500 {\n                aho_corasick::AhoCorasickKind::DFA\n            } else {\n                aho_corasick::AhoCorasickKind::ContiguousNFA\n            };\n            let result = aho_corasick::AhoCorasick::builder()\n                .kind(Some(ac_kind))\n                .match_kind(ac_match_kind)\n                .start_kind(aho_corasick::StartKind::Both)\n                .prefilter(false)\n                .build(needles);\n            let ac = match result {\n                Ok(ac) => ac,\n                Err(_err) => {\n                    debug!(\"aho-corasick prefilter failed to build: {}\", _err);\n                    return None;\n                }\n            };\n            Some(AhoCorasick { ac })\n        }\n    }\n}\nimpl Memchr2 {\n    pub(crate) fn new<B: AsRef<[u8]>>(\n        _kind: MatchKind,\n        needles: &[B],\n    ) -> Option<Memchr2> {\n        #[cfg(not(feature = \"perf-literal-substring\"))] { None }\n        #[cfg(feature = \"perf-literal-substring\")]\n        {\n            if needles.len() != 2 {\n                return None;\n            }\n            if !needles.iter().all(|n| n.as_ref().len() == 1) {\n                return None;\n            }\n            let b1 = needles[0].as_ref()[0];\n            let b2 = needles[1].as_ref()[0];\n            Some(Memchr2(b1, b2))\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Select what is believed to be the best prefilter algorithm for the\n/// match semantics and sequence of needles given.\n///\n/// This selection algorithm uses the needles as given without any\n/// modification. For example, if `[bar]` is given, then this doesn't\n/// try to select `memchr` for `b`. Instead, it would select `memmem`\n/// for `bar`. If callers would want `memchr` selected for `[bar]`, then\n/// callers should massages the literals themselves. That is, callers are\n/// responsible for heuristics surrounding which sequence of literals is\n/// best.\n///\n/// What this selection algorithm does is attempt to use the fastest\n/// prefilter that works for the literals given. So if `[a, b]`, is given,\n/// then `memchr2` is selected.\n///\n/// Of course, which prefilter is selected is also subject to what\n/// is available. For example, if `alloc` isn't enabled, then\n/// that limits which prefilters can be selected. Similarly, if\n/// `perf-literal-substring` isn't enabled, then nothing from the `memchr`\n/// crate can be returned.\n577 pub(crate) fn new<B: AsRef<[u8]>>(\n578     kind: MatchKind,\n579     needles: &[B],\n580 ) -> Option<Choice> {\n581     // An empty set means the regex matches nothing, so no sense in\n582     // building a prefilter.\n583     if needles.len() == 0 {\n584         debug!(\"prefilter building failed: found empty set of literals\");\n585         return None;\n586     }\n587     // If the regex can match the empty string, then the prefilter\n588     // will by definition match at every position. This is obviously\n589     // completely ineffective.\n590     if needles.iter().any(|n| n.as_ref().is_empty()) {\n591         debug!(\"prefilter building failed: literals match empty string\");\n592         return None;\n593     }\n594     // BREADCRUMBS: Perhaps the literal optimizer should special case\n595     // sequences of length two or three if the leading bytes of each are\n596     // \"rare\"? Or perhaps, if there are two or three total possible leading\n597     // bytes, regardless of the number of literals, and all are rare...\n598     // Then well, perhaps we should use memchr2 or memchr3 in those cases?\n599     if let Some(pre) = Memchr::new(kind, needles) {\n600         debug!(\"prefilter built: memchr\");\n601         return Some(Choice::Memchr(pre));\n602     }\n603     if let Some(pre) = Memchr2::new(kind, needles) {\n604         debug!(\"prefilter built: memchr2\");\n605         return Some(Choice::Memchr2(pre));\n606     }\n607     if let Some(pre) = Memchr3::new(kind, needles) {\n608         debug!(\"prefilter built: memchr3\");\n609         return Some(Choice::Memchr3(pre));\n610     }\n611     if let Some(pre) = Memmem::new(kind, needles) {\n612         debug!(\"prefilter built: memmem\");\n613         return Some(Choice::Memmem(pre));\n614     }\n615     if let Some(pre) = Teddy::new(kind, needles) {\n616         debug!(\"prefilter built: teddy\");\n617         return Some(Choice::Teddy(pre));\n618     }\n619     if let Some(pre) = ByteSet::new(kind, needles) {\n620         debug!(\"prefilter built: byteset\");\n621         return Some(Choice::ByteSet(pre));\n622     }\n623     if let Some(pre) = AhoCorasick::new(kind, needles) {\n624         debug!(\"prefilter built: aho-corasick\");\n625         return Some(Choice::AhoCorasick(pre));\n626     }\n627     debug!(\"prefilter building failed: no strategy could be found\");\n628     None\n629 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}