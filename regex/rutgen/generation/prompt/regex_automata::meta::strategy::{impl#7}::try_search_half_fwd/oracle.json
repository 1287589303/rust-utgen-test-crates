{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseSuffix {\n    core: Core,\n    pre: Prefilter,\n}\n#[derive(Debug)]\npub(crate) struct HybridEngine(\n    #[cfg(feature = \"hybrid\")]\n    hybrid::regex::Regex,\n    #[cfg(not(feature = \"hybrid\"))]\n    (),\n);\n#[derive(Debug)]\npub(crate) struct DFAEngine(\n    #[cfg(feature = \"dfa-build\")]\n    dfa::regex::Regex,\n    #[cfg(not(feature = \"dfa-build\"))]\n    (),\n);\n#[derive(Debug)]\npub(crate) struct Hybrid(Option<HybridEngine>);\n#[derive(Debug)]\npub(crate) struct DFA(Option<DFAEngine>);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug)]\npub(crate) struct HybridCache(\n    #[cfg(feature = \"hybrid\")]\n    Option<hybrid::regex::Cache>,\n    #[cfg(not(feature = \"hybrid\"))]\n    (),\n);\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[derive(Debug)]\npub(crate) struct RetryFailError {\n    offset: usize,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\nimpl ReverseSuffix {\n    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_start(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_fwd(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {\n        if let Some(e) = self.core.dfa.get(&input) {\n            trace!(\n                \"using full DFA for forward reverse suffix search at {:?}\", input\n                .get_span()\n            );\n            e.try_search_half_fwd(&input)\n        } else if let Some(e) = self.core.hybrid.get(&input) {\n            trace!(\n                \"using lazy DFA for forward reverse suffix search at {:?}\", input\n                .get_span()\n            );\n            e.try_search_half_fwd(&mut cache.hybrid, &input)\n        } else {\n            unreachable!(\"ReverseSuffix always has a DFA\")\n        }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_rev_limited(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n}\nimpl HybridEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Option<HybridEngine> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {\n        #[cfg(feature = \"hybrid\")]\n        {\n            let fwd = self.0.forward();\n            let mut fwdcache = cache.0.as_mut().unwrap().as_parts_mut().0;\n            fwd.try_search_fwd(&mut fwdcache, input).map_err(|e| e.into())\n        }\n        #[cfg(not(feature = \"hybrid\"))] { unreachable!() }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd_stopat(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev_limited(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n    #[inline]\n    pub(crate) fn try_which_overlapping_matches(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), RetryFailError> {}\n}\nimpl DFAEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Option<DFAEngine> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {\n        #[cfg(feature = \"dfa-build\")]\n        {\n            use crate::dfa::Automaton;\n            self.0.forward().try_search_fwd(input).map_err(|e| e.into())\n        }\n        #[cfg(not(feature = \"dfa-build\"))] { unreachable!() }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd_stopat(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev_limited(\n        &self,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n    #[inline]\n    pub(crate) fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), RetryFailError> {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl Hybrid {\n    pub(crate) fn none() -> Hybrid {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Hybrid {}\n    pub(crate) fn create_cache(&self) -> HybridCache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&HybridEngine> {\n        let engine = self.0.as_ref()?;\n        Some(engine)\n    }\n    pub(crate) fn is_some(&self) -> bool {}\n}\nimpl DFA {\n    pub(crate) fn none() -> DFA {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> DFA {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&DFAEngine> {\n        let engine = self.0.as_ref()?;\n        Some(engine)\n    }\n    pub(crate) fn is_some(&self) -> bool {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1245 fn try_search_half_fwd(\n1246     &self,\n1247     cache: &mut Cache,\n1248     input: &Input<'_>,\n1249 ) -> Result<Option<HalfMatch>, RetryFailError> {\n1250     if let Some(e) = self.core.dfa.get(&input) {\n1251         trace!(\n1252             \"using full DFA for forward reverse suffix search at {:?}\",\n1253             input.get_span()\n1254         );\n1255         e.try_search_half_fwd(&input)\n1256     } else if let Some(e) = self.core.hybrid.get(&input) {\n1257         trace!(\n1258             \"using lazy DFA for forward reverse suffix search at {:?}\",\n1259             input.get_span()\n1260         );\n1261         e.try_search_half_fwd(&mut cache.hybrid, &input)\n1262     } else {\n1263         unreachable!(\"ReverseSuffix always has a DFA\")\n1264     }\n1265 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}