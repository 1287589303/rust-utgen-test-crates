{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/parser.rs\n// crate name is regex_syntax\nuse crate::{ast, hir, Error};\n#[derive(Clone, Debug)]\npub struct Parser {\n    ast: ast::parse::Parser,\n    hir: hir::translate::Translator,\n}\n#[derive(Clone, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}\n#[non_exhaustive]\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Error {\n    /// An error that occurred while translating concrete syntax into abstract\n    /// syntax (AST).\n    Parse(ast::Error),\n    /// An error that occurred while translating abstract syntax into a high\n    /// level intermediate representation (HIR).\n    Translate(hir::Error),\n}\nimpl Parser {\n    pub fn new() -> Parser {\n        ParserBuilder::new().build()\n    }\n    pub fn parse(&mut self, pattern: &str) -> Result<hir::Hir, Error> {\n        let ast = self.ast.parse(pattern)?;\n        let hir = self.hir.translate(pattern, &ast)?;\n        Ok(hir)\n    }\n}\npub fn parse(pattern: &str) -> Result<hir::Hir, Error> {\n    Parser::new().parse(pattern)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// A convenience routine for parsing a regex using default options.\n///\n/// This is equivalent to `Parser::new().parse(pattern)`.\n///\n/// If you need to set non-default options, then use a [`ParserBuilder`].\n///\n/// This routine returns an [`Hir`](hir::Hir) value. Namely, it automatically\n/// parses the pattern as an [`Ast`](ast::Ast) and then invokes the translator\n/// to convert the `Ast` into an `Hir`. If you need access to the `Ast`, then\n/// you should use a [`ast::parse::Parser`].\n13 pub fn parse(pattern: &str) -> Result<hir::Hir, Error> {\n14     Parser::new().parse(pattern)\n15 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}