{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/backtrack.rs\n// crate name is regex_automata\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchError, Span},\n    },\n};\n#[derive(Clone, Debug)]\npub struct BoundedBacktracker {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used on the heap for doing backtracking instead of the\n    /// traditional recursive approach. We don't want recursion because then\n    /// we're likely to hit a stack overflow for bigger regexes.\n    stack: Vec<Frame>,\n    /// The set of (StateID, HaystackOffset) pairs that have been visited\n    /// by the backtracker within a single search. If such a pair has been\n    /// visited, then we avoid doing the work for that pair again. This is\n    /// what \"bounds\" the backtracking and prevents it from having worst case\n    /// exponential time.\n    visited: Visited,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\nimpl BoundedBacktracker {\n    #[inline]\n    pub fn try_search(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        caps: &mut Captures,\n    ) -> Result<(), MatchError> {}\n    #[inline]\n    pub fn try_search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<PatternID>, MatchError> {\n        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n        if !utf8empty {\n            let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;\n            return Ok(maybe_hm.map(|hm| hm.pattern()));\n        }\n        let min = self.get_nfa().group_info().implicit_slot_len();\n        if slots.len() >= min {\n            let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;\n            return Ok(maybe_hm.map(|hm| hm.pattern()));\n        }\n        if self.get_nfa().pattern_len() == 1 {\n            let mut enough = [None, None];\n            let got = self.try_search_slots_imp(cache, input, &mut enough)?;\n            slots.copy_from_slice(&enough[..slots.len()]);\n            return Ok(got.map(|hm| hm.pattern()));\n        }\n        let mut enough = vec![None; min];\n        let got = self.try_search_slots_imp(cache, input, &mut enough)?;\n        slots.copy_from_slice(&enough[..slots.len()]);\n        Ok(got.map(|hm| hm.pattern()))\n    }\n    #[inline(never)]\n    fn try_search_slots_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {\n        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n        let hm = match self.search_imp(cache, input, slots)? {\n            None => return Ok(None),\n            Some(hm) if !utf8empty => return Ok(Some(hm)),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_fwd(\n            input,\n            hm,\n            hm.offset(),\n            |input| {\n                Ok(self.search_imp(cache, input, slots)?.map(|hm| (hm, hm.offset())))\n            },\n        )\n    }\n    fn search_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn backtrack(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        at: usize,\n        start_id: StateID,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn step(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        mut sid: StateID,\n        mut at: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {}\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {\n        self.0.start_pattern.len()\n    }\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {}\n    #[inline]\n    pub fn states(&self) -> &[State] {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {\n        &self.0.group_info()\n    }\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {\n        self.0.has_empty\n    }\n    #[inline]\n    pub fn is_utf8(&self) -> bool {\n        self.0.utf8\n    }\n    #[inline]\n    pub fn is_reverse(&self) -> bool {}\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {}\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {}\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl GroupInfo {\n    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>\n    where\n        P: IntoIterator<Item = G>,\n        G: IntoIterator<Item = Option<N>>,\n        N: AsRef<str>,\n    {}\n    pub fn empty() -> GroupInfo {}\n    #[inline]\n    pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {}\n    #[inline]\n    pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {}\n    #[inline]\n    pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {}\n    #[inline]\n    pub fn all_names(&self) -> GroupInfoAllNames<'_> {}\n    #[inline]\n    pub fn slots(&self, pid: PatternID, group_index: usize) -> Option<(usize, usize)> {}\n    #[inline]\n    pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn group_len(&self, pid: PatternID) -> usize {}\n    #[inline]\n    pub fn all_group_len(&self) -> usize {}\n    #[inline]\n    pub fn slot_len(&self) -> usize {}\n    #[inline]\n    pub fn implicit_slot_len(&self) -> usize {\n        self.pattern_len() * 2\n    }\n    #[inline]\n    pub fn explicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes a leftmost forward search and writes the spans of capturing\n/// groups that participated in a match into the provided `slots`, and\n/// returns the matching pattern ID. The contents of the slots for patterns\n/// other than the matching pattern are unspecified. If no match was found,\n/// then `None` is returned and the contents of all `slots` is unspecified.\n///\n/// This is like [`BoundedBacktracker::try_search`], but it accepts a raw\n/// slots slice instead of a `Captures` value. This is useful in contexts\n/// where you don't want or need to allocate a `Captures`.\n///\n/// It is legal to pass _any_ number of slots to this routine. If the regex\n/// engine would otherwise write a slot offset that doesn't fit in the\n/// provided slice, then it is simply skipped. In general though, there are\n/// usually three slice lengths you might want to use:\n///\n/// * An empty slice, if you only care about which pattern matched.\n/// * A slice with\n/// [`pattern_len() * 2`](crate::nfa::thompson::NFA::pattern_len)\n/// slots, if you only care about the overall match spans for each matching\n/// pattern.\n/// * A slice with\n/// [`slot_len()`](crate::util::captures::GroupInfo::slot_len) slots, which\n/// permits recording match offsets for every capturing group in every\n/// pattern.\n///\n/// # Errors\n///\n/// This routine only errors if the search could not complete. For this\n/// backtracking regex engine, this only occurs when the haystack length\n/// exceeds [`BoundedBacktracker::max_haystack_len`].\n///\n/// When a search cannot complete, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example\n///\n/// This example shows how to find the overall match offsets in a\n/// multi-pattern search without allocating a `Captures` value. Indeed, we\n/// can put our slots right on the stack.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     nfa::thompson::backtrack::BoundedBacktracker,\n///     PatternID, Input,\n/// };\n///\n/// let re = BoundedBacktracker::new_many(&[\n///     r\"\\pL+\",\n///     r\"\\d+\",\n/// ])?;\n/// let mut cache = re.create_cache();\n/// let input = Input::new(\"!@#123\");\n///\n/// // We only care about the overall match offsets here, so we just\n/// // allocate two slots for each pattern. Each slot records the start\n/// // and end of the match.\n/// let mut slots = [None; 4];\n/// let pid = re.try_search_slots(&mut cache, &input, &mut slots)?;\n/// assert_eq!(Some(PatternID::must(1)), pid);\n///\n/// // The overall match offsets are always at 'pid * 2' and 'pid * 2 + 1'.\n/// // See 'GroupInfo' for more details on the mapping between groups and\n/// // slot indices.\n/// let slot_start = pid.unwrap().as_usize() * 2;\n/// let slot_end = slot_start + 1;\n/// assert_eq!(Some(3), slots[slot_start].map(|s| s.get()));\n/// assert_eq!(Some(6), slots[slot_end].map(|s| s.get()));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1293 pub fn try_search_slots(\n1294     &self,\n1295     cache: &mut Cache,\n1296     input: &Input<'_>,\n1297     slots: &mut [Option<NonMaxUsize>],\n1298 ) -> Result<Option<PatternID>, MatchError> {\n1299     let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n1300     if !utf8empty {\n1301         let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;\n1302         return Ok(maybe_hm.map(|hm| hm.pattern()));\n1303     }\n1304     // See PikeVM::try_search_slots for why we do this.\n1305     let min = self.get_nfa().group_info().implicit_slot_len();\n1306     if slots.len() >= min {\n1307         let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;\n1308         return Ok(maybe_hm.map(|hm| hm.pattern()));\n1309     }\n1310     if self.get_nfa().pattern_len() == 1 {\n1311         let mut enough = [None, None];\n1312         let got = self.try_search_slots_imp(cache, input, &mut enough)?;\n1313         // This is OK because we know `enough_slots` is strictly bigger\n1314         // than `slots`, otherwise this special case isn't reached.\n1315         slots.copy_from_slice(&enough[..slots.len()]);\n1316         return Ok(got.map(|hm| hm.pattern()));\n1317     }\n1318     let mut enough = vec![None; min];\n1319     let got = self.try_search_slots_imp(cache, input, &mut enough)?;\n1320     // This is OK because we know `enough_slots` is strictly bigger than\n1321     // `slots`, otherwise this special case isn't reached.\n1322     slots.copy_from_slice(&enough[..slots.len()]);\n1323     Ok(got.map(|hm| hm.pattern()))\n1324 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}