{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError> {\n        let config = start::Config::from_input_forward(input);\n        self.start_state(&config)\n            .map_err(|err| match err {\n                StartError::Quit { byte } => {\n                    let offset = input\n                        .start()\n                        .checked_sub(1)\n                        .expect(\"no quit in start without look-behind\");\n                    MatchError::quit(byte, offset)\n                }\n                StartError::UnsupportedAnchored { mode } => {\n                    MatchError::unsupported_anchored(mode)\n                }\n            })\n    }\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError> {\n        let config = start::Config::from_input_reverse(input);\n        self.start_state(&config)\n            .map_err(|err| match err {\n                StartError::Quit { byte } => {\n                    let offset = input.end();\n                    MatchError::quit(byte, offset)\n                }\n                StartError::UnsupportedAnchored { mode } => {\n                    MatchError::unsupported_anchored(mode)\n                }\n            })\n    }\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID> {\n        None\n    }\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8] {\n        &[]\n    }\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter> {\n        None\n    }\n    #[inline]\n    fn try_search_fwd(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        let hm = match search::find_fwd(&self, input)? {\n            None => return Ok(None),\n            Some(hm) if !utf8empty => return Ok(Some(hm)),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_fwd(\n            input,\n            hm,\n            hm.offset(),\n            |input| {\n                let got = search::find_fwd(&self, input)?;\n                Ok(got.map(|hm| (hm, hm.offset())))\n            },\n        )\n    }\n    #[inline]\n    fn try_search_rev(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        let hm = match search::find_rev(self, input)? {\n            None => return Ok(None),\n            Some(hm) if !utf8empty => return Ok(Some(hm)),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_rev(\n            input,\n            hm,\n            hm.offset(),\n            |input| {\n                let got = search::find_rev(self, input)?;\n                Ok(got.map(|hm| (hm, hm.offset())))\n            },\n        )\n    }\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        search::find_overlapping_fwd(self, input, state)?;\n        match state.get_match() {\n            None => Ok(()),\n            Some(_) if !utf8empty => Ok(()),\n            Some(_) => {\n                skip_empty_utf8_splits_overlapping(\n                    input,\n                    state,\n                    |input, state| { search::find_overlapping_fwd(self, input, state) },\n                )\n            }\n        }\n    }\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        search::find_overlapping_rev(self, input, state)?;\n        match state.get_match() {\n            None => Ok(()),\n            Some(_) if !utf8empty => Ok(()),\n            Some(_) => {\n                skip_empty_utf8_splits_overlapping(\n                    input,\n                    state,\n                    |input, state| { search::find_overlapping_rev(self, input, state) },\n                )\n            }\n        }\n    }\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError> {\n        let mut state = OverlappingState::start();\n        while let Some(m) = {\n            self.try_search_overlapping_fwd(input, &mut state)?;\n            state.get_match()\n        } {\n            let _ = patset.insert(m.pattern());\n            if patset.is_full() || input.get_earliest() {\n                break;\n            }\n        }\n        Ok(())\n    }\n}\n#[derive(Clone)]\npub struct DFA<T> {\n    tt: Transitions<T>,\n    st: StartTable<T>,\n    special: Special,\n    pre: Option<Prefilter>,\n    quitset: ByteSet,\n    flags: Flags,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone)]\npub(crate) struct StartByteMap {\n    map: [Start; 256],\n}\n#[derive(Clone)]\nstruct StartTable<T> {\n    /// The initial start state IDs as a contiguous table of native endian\n    /// encoded integers, represented by `S`.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8] and has no alignment\n    /// requirements.\n    ///\n    /// The first `2 * stride` (currently always 8) entries always correspond\n    /// to the starts states for the entire DFA, with the first 4 entries being\n    /// for unanchored searches and the second 4 entries being for anchored\n    /// searches. To keep things simple, we always use 8 entries even if the\n    /// `StartKind` is not both.\n    ///\n    /// After that, there are `stride * patterns` state IDs, where `patterns`\n    /// may be zero in the case of a DFA with no patterns or in the case where\n    /// the DFA was built without enabling starting states for each pattern.\n    table: T,\n    /// The starting state configuration supported. When 'both', both\n    /// unanchored and anchored searches work. When 'unanchored', anchored\n    /// searches panic. When 'anchored', unanchored searches panic.\n    kind: StartKind,\n    /// The start state configuration for every possible byte.\n    start_map: StartByteMap,\n    /// The number of starting state IDs per pattern.\n    stride: usize,\n    /// The total number of patterns for which starting states are encoded.\n    /// This is `None` for DFAs that were built without start states for each\n    /// pattern. Thus, one cannot use this field to say how many patterns\n    /// are in the DFA in all cases. It is specific to how many patterns are\n    /// represented in this start table.\n    pattern_len: Option<usize>,\n    /// The universal starting state for unanchored searches. This is only\n    /// present when the DFA supports unanchored searches and when all starting\n    /// state IDs for an unanchored search are equivalent.\n    universal_start_unanchored: Option<StateID>,\n    /// The universal starting state for anchored searches. This is only\n    /// present when the DFA supports anchored searches and when all starting\n    /// state IDs for an anchored search are equivalent.\n    universal_start_anchored: Option<StateID>,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]\npub(crate) struct ByteSet {\n    bits: BitSet,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\n#[derive(Clone)]\npub(crate) struct StartTable<T> {\n    /// The initial start state IDs.\n    ///\n    /// In practice, T is either `Vec<u32>` or `&[u32]`.\n    ///\n    /// The first `2 * stride` (currently always 8) entries always correspond\n    /// to the starts states for the entire DFA, with the first 4 entries being\n    /// for unanchored searches and the second 4 entries being for anchored\n    /// searches. To keep things simple, we always use 8 entries even if the\n    /// `StartKind` is not both.\n    ///\n    /// After that, there are `stride * patterns` state IDs, where `patterns`\n    /// may be zero in the case of a DFA with no patterns or in the case where\n    /// the DFA was built without enabling starting states for each pattern.\n    table: T,\n    /// The starting state configuration supported. When 'both', both\n    /// unanchored and anchored searches work. When 'unanchored', anchored\n    /// searches panic. When 'anchored', unanchored searches panic.\n    kind: StartKind,\n    /// The start state configuration for every possible byte.\n    start_map: StartByteMap,\n    /// The number of starting state IDs per pattern.\n    stride: usize,\n    /// The total number of patterns for which starting states are encoded.\n    /// This is `None` for DFAs that were built without start states for each\n    /// pattern. Thus, one cannot use this field to say how many patterns\n    /// are in the DFA in all cases. It is specific to how many patterns are\n    /// represented in this start table.\n    pattern_len: Option<usize>,\n    /// The universal starting state for unanchored searches. This is only\n    /// present when the DFA supports unanchored searches and when all starting\n    /// state IDs for an unanchored search are equivalent.\n    universal_start_unanchored: Option<StateID>,\n    /// The universal starting state for anchored searches. This is only\n    /// present when the DFA supports anchored searches and when all starting\n    /// state IDs for an anchored search are equivalent.\n    universal_start_anchored: Option<StateID>,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Flags {\n    /// Whether the DFA can match the empty string. When this is false, all\n    /// matches returned by this DFA are guaranteed to have non-zero length.\n    pub(crate) has_empty: bool,\n    /// Whether the DFA should only produce matches with spans that correspond\n    /// to valid UTF-8. This also includes omitting any zero-width matches that\n    /// split the UTF-8 encoding of a codepoint.\n    pub(crate) is_utf8: bool,\n    /// Whether the DFA is always anchored or not, regardless of `Input`\n    /// configuration. This is useful for avoiding a reverse scan even when\n    /// executing unanchored searches.\n    pub(crate) is_always_start_anchored: bool,\n}\n#[derive(Clone)]\nstruct Transitions<T> {\n    /// The raw encoding of each state in this DFA.\n    ///\n    /// Each state has the following information:\n    ///\n    /// * A set of transitions to subsequent states. Transitions to the dead\n    ///   state are omitted.\n    /// * If the state can be accelerated, then any additional accelerator\n    ///   information.\n    /// * If the state is a match state, then the state contains all pattern\n    ///   IDs that match when in that state.\n    ///\n    /// To decode a state, use Transitions::state.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8].\n    sparse: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride and is documented above.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is\n    /// if the DFA's kind uses byte classes which is the default. Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    ///\n    /// N.B. Equivalence classes aren't particularly useful in a sparse DFA\n    /// in the current implementation, since equivalence classes generally tend\n    /// to correspond to continuous ranges of bytes that map to the same\n    /// transition. So in a sparse DFA, equivalence classes don't really lead\n    /// to a space savings. In the future, it would be good to try and remove\n    /// them from sparse DFAs entirely, but requires a bit of work since sparse\n    /// DFAs are built from dense DFAs, which are in turn built on top of\n    /// equivalence classes.\n    classes: ByteClasses,\n    /// The total number of states in this DFA. Note that a DFA always has at\n    /// least one state---the dead state---even the empty DFA. In particular,\n    /// the dead state always has ID 0 and is correspondingly always the first\n    /// state. The dead state is never a match state.\n    state_len: usize,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[non_exhaustive]\n#[derive(Clone, Debug)]\npub enum StartError {\n    /// An error that occurs when a starting configuration's look-behind byte\n    /// is in this DFA's quit set.\n    Quit {\n        /// The quit byte that was found.\n        byte: u8,\n    },\n    /// An error that occurs when the caller requests an anchored mode that\n    /// isn't supported by the DFA.\n    UnsupportedAnchored {\n        /// The anchored mode given that is unsupported.\n        mode: Anchored,\n    },\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Start {\n    /// This occurs when the starting position is not any of the ones below.\n    NonWordByte = 0,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is an ASCII word byte.\n    WordByte = 1,\n    /// This occurs when the starting position of the search corresponds to the\n    /// beginning of the haystack.\n    Text = 2,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\n`.\n    LineLF = 3,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\r`.\n    LineCR = 4,\n    /// This occurs when a custom line terminator has been set via a\n    /// `LookMatcher`, and when that line terminator is neither a `\\r` or a\n    /// `\\n`.\n    ///\n    /// If the custom line terminator is a word byte, then this start\n    /// configuration is still selected. DFAs that implement word boundary\n    /// assertions will likely need to check whether the custom line terminator\n    /// is a word byte, in which case, it should behave as if the byte\n    /// satisfies `\\b` in addition to multi-line anchors.\n    CustomLineTerminator = 5,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\nunsafe impl<T: AsRef<[u8]>> Automaton for DFA<T> {\n    #[inline]\n    fn is_special_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_dead_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_quit_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_match_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_start_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_accel_state(&self, id: StateID) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next_state(&self, current: StateID, input: u8) -> StateID {}\n    #[inline]\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID {}\n    #[inline]\n    fn next_eoi_state(&self, current: StateID) -> StateID {}\n    #[inline]\n    fn pattern_len(&self) -> usize {}\n    #[inline]\n    fn match_len(&self, id: StateID) -> usize {}\n    #[inline]\n    fn match_pattern(&self, id: StateID, match_index: usize) -> PatternID {}\n    #[inline]\n    fn has_empty(&self) -> bool {}\n    #[inline]\n    fn is_utf8(&self) -> bool {}\n    #[inline]\n    fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError> {\n        let anchored = config.get_anchored();\n        let start = match config.get_look_behind() {\n            None => Start::Text,\n            Some(byte) => {\n                if !self.quitset.is_empty() && self.quitset.contains(byte) {\n                    return Err(StartError::quit(byte));\n                }\n                self.st.start_map.get(byte)\n            }\n        };\n        self.st.start(anchored, start)\n    }\n    #[inline]\n    fn universal_start_state(&self, mode: Anchored) -> Option<StateID> {}\n    #[inline]\n    fn accelerator(&self, id: StateID) -> &[u8] {}\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter> {}\n}\nimpl Config {\n    pub fn new() -> Config {}\n    pub fn from_input_forward(input: &Input<'_>) -> Config {}\n    pub fn from_input_reverse(input: &Input<'_>) -> Config {}\n    pub fn look_behind(mut self, byte: Option<u8>) -> Config {}\n    pub fn anchored(mut self, mode: Anchored) -> Config {}\n    pub fn get_look_behind(&self) -> Option<u8> {\n        self.look_behind\n    }\n    pub fn get_anchored(&self) -> Anchored {\n        self.anchored\n    }\n}\nimpl StartError {\n    pub(crate) fn quit(byte: u8) -> StartError {\n        StartError::Quit { byte }\n    }\n    pub(crate) fn unsupported_anchored(mode: Anchored) -> StartError {}\n}\nimpl StartByteMap {\n    pub(crate) fn new(lookm: &LookMatcher) -> StartByteMap {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, byte: u8) -> Start {\n        self.map[usize::from(byte)]\n    }\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(StartByteMap, usize), DeserializeError> {}\n    pub(crate) fn write_to(&self, dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n}\nimpl<T: AsRef<[u8]>> StartTable<T> {\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n    fn validate(&self, sp: &Special, seen: &Seen) -> Result<(), DeserializeError> {}\n    fn as_ref(&self) -> StartTable<&'_ [u8]> {}\n    #[cfg(feature = \"alloc\")]\n    fn to_owned(&self) -> StartTable<alloc::vec::Vec<u8>> {}\n    fn start(&self, anchored: Anchored, start: Start) -> Result<StateID, StartError> {\n        let start_index = start.as_usize();\n        let index = match anchored {\n            Anchored::No => {\n                if !self.kind.has_unanchored() {\n                    return Err(StartError::unsupported_anchored(anchored));\n                }\n                start_index\n            }\n            Anchored::Yes => {\n                if !self.kind.has_anchored() {\n                    return Err(StartError::unsupported_anchored(anchored));\n                }\n                self.stride + start_index\n            }\n            Anchored::Pattern(pid) => {\n                let len = match self.pattern_len {\n                    None => return Err(StartError::unsupported_anchored(anchored)),\n                    Some(len) => len,\n                };\n                if pid.as_usize() >= len {\n                    return Ok(DEAD);\n                }\n                (2 * self.stride) + (self.stride * pid.as_usize()) + start_index\n            }\n        };\n        let start = index * StateID::SIZE;\n        Ok(wire::read_state_id_unchecked(&self.table()[start..]).0)\n    }\n    fn iter(&self) -> StartStateIter<'_, T> {}\n    fn len(&self) -> usize {}\n    fn table(&self) -> &[u8] {}\n    fn memory_usage(&self) -> usize {}\n}\nimpl ByteSet {\n    pub(crate) fn empty() -> ByteSet {}\n    pub(crate) fn add(&mut self, byte: u8) {}\n    pub(crate) fn remove(&mut self, byte: u8) {}\n    pub(crate) fn contains(&self, byte: u8) -> bool {\n        let bucket = byte / 128;\n        let bit = byte % 128;\n        self.bits.0[usize::from(bucket)] & (1 << bit) > 0\n    }\n    pub(crate) fn contains_range(&self, start: u8, end: u8) -> bool {}\n    pub(crate) fn iter(&self) -> ByteSetIter {}\n    pub(crate) fn iter_ranges(&self) -> ByteSetRangeIter {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_empty(&self) -> bool {\n        self.bits.0 == [0, 0]\n    }\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteSet, usize), DeserializeError> {}\n    pub(crate) fn write_to<E: crate::util::wire::Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1197 fn start_state(\n1198     &self,\n1199     config: &start::Config,\n1200 ) -> Result<StateID, StartError> {\n1201     let anchored = config.get_anchored();\n1202     let start = match config.get_look_behind() {\n1203         None => Start::Text,\n1204         Some(byte) => {\n1205             if !self.quitset.is_empty() && self.quitset.contains(byte) {\n1206                 return Err(StartError::quit(byte));\n1207             }\n1208             self.st.start_map.get(byte)\n1209         }\n1210     };\n1211     self.st.start(anchored, start)\n1212 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}