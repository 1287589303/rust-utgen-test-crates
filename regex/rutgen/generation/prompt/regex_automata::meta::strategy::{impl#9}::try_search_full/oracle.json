{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseInner {\n    core: Core,\n    preinner: Prefilter,\n    nfarev: NFA,\n    hybrid: wrappers::ReverseHybrid,\n    dfa: wrappers::ReverseDFA,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Debug)]\npub(crate) struct RetryQuadraticError(());\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Debug)]\npub(crate) struct RetryFailError {\n    offset: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Debug)]\npub(crate) struct ReverseHybrid(Option<ReverseHybridEngine>);\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[derive(Debug)]\npub(crate) struct ReverseDFA(Option<ReverseDFAEngine>);\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Span {\n    /// The start offset of the span, inclusive.\n    pub start: usize,\n    /// The end offset of the span, exclusive.\n    pub end: usize,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct Match {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The underlying match span.\n    span: Span,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\n#[derive(Debug)]\npub(crate) enum RetryError {\n    Quadratic(RetryQuadraticError),\n    Fail(RetryFailError),\n}\nimpl ReverseInner {\n    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseInner, Core> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_full(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryError> {\n        let mut span = input.get_span();\n        let mut min_match_start = 0;\n        let mut min_pre_start = 0;\n        loop {\n            let litmatch = match self.preinner.find(input.haystack(), span) {\n                None => return Ok(None),\n                Some(span) => span,\n            };\n            if litmatch.start < min_pre_start {\n                trace!(\n                    \"found inner prefilter match at {:?}, which starts \\\n\t\t\t\t\t before the end of the last forward scan at {}, \\\n\t\t\t\t\t quitting to avoid quadratic behavior\",\n                    litmatch, min_pre_start,\n                );\n                return Err(RetryError::Quadratic(RetryQuadraticError::new()));\n            }\n            trace!(\"reverse inner scan found inner match at {:?}\", litmatch);\n            let revinput = input\n                .clone()\n                .anchored(Anchored::Yes)\n                .span(input.start()..litmatch.start);\n            match self.try_search_half_rev_limited(cache, &revinput, min_match_start)? {\n                None => {\n                    if span.start >= span.end {\n                        break;\n                    }\n                    span.start = litmatch.start.checked_add(1).unwrap();\n                }\n                Some(hm_start) => {\n                    let fwdinput = input\n                        .clone()\n                        .anchored(Anchored::Pattern(hm_start.pattern()))\n                        .span(hm_start.offset()..input.end());\n                    match self.try_search_half_fwd_stopat(cache, &fwdinput)? {\n                        Err(stopat) => {\n                            min_pre_start = stopat;\n                            span.start = litmatch.start.checked_add(1).unwrap();\n                        }\n                        Ok(hm_end) => {\n                            return Ok(\n                                Some(\n                                    Match::new(\n                                        hm_start.pattern(),\n                                        hm_start.offset()..hm_end.offset(),\n                                    ),\n                                ),\n                            );\n                        }\n                    }\n                }\n            }\n            min_match_start = litmatch.end;\n        }\n        Ok(None)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_fwd_stopat(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {\n        if let Some(e) = self.core.dfa.get(&input) {\n            trace!(\n                \"using full DFA for forward reverse inner search at {:?}\", input\n                .get_span()\n            );\n            e.try_search_half_fwd_stopat(&input)\n        } else if let Some(e) = self.core.hybrid.get(&input) {\n            trace!(\n                \"using lazy DFA for forward reverse inner search at {:?}\", input\n                .get_span()\n            );\n            e.try_search_half_fwd_stopat(&mut cache.hybrid, &input)\n        } else {\n            unreachable!(\"ReverseInner always has a DFA\")\n        }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_rev_limited(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        if let Some(e) = self.dfa.get(&input) {\n            trace!(\n                \"using full DFA for reverse inner search at {:?}, \\\n                 but will be stopped at {} to avoid quadratic behavior\",\n                input.get_span(), min_start,\n            );\n            e.try_search_half_rev_limited(&input, min_start)\n        } else if let Some(e) = self.hybrid.get(&input) {\n            trace!(\n                \"using lazy DFA for reverse inner search at {:?}, \\\n                 but will be stopped at {} to avoid quadratic behavior\",\n                input.get_span(), min_start,\n            );\n            e.try_search_half_rev_limited(&mut cache.revhybrid, &input, min_start)\n        } else {\n            unreachable!(\"ReverseInner always has a DFA\")\n        }\n    }\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {}\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {\n        #[cfg(not(feature = \"alloc\"))] { unreachable!() }\n        #[cfg(feature = \"alloc\")] { self.pre.find(haystack, span) }\n    }\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {}\n}\nimpl RetryQuadraticError {\n    pub(crate) fn new() -> RetryQuadraticError {\n        RetryQuadraticError(())\n    }\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {\n        self.set_anchored(mode);\n        self\n    }\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {\n        self.span\n    }\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {\n        self.pattern\n    }\n    #[inline]\n    pub fn offset(&self) -> usize {\n        self.offset\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1626 fn try_search_full(\n1627     &self,\n1628     cache: &mut Cache,\n1629     input: &Input<'_>,\n1630 ) -> Result<Option<Match>, RetryError> {\n1631     let mut span = input.get_span();\n1632     let mut min_match_start = 0;\n1633     let mut min_pre_start = 0;\n1634     loop {\n1635         let litmatch = match self.preinner.find(input.haystack(), span) {\n1636             None => return Ok(None),\n1637             Some(span) => span,\n1638         };\n1639         if litmatch.start < min_pre_start {\n1640             trace!(\n1641                 \"found inner prefilter match at {:?}, which starts \\\n1642 \t before the end of the last forward scan at {}, \\\n1643 \t quitting to avoid quadratic behavior\",\n1644                 litmatch,\n1645                 min_pre_start,\n1646             );\n1647             return Err(RetryError::Quadratic(RetryQuadraticError::new()));\n1648         }\n1649         trace!(\"reverse inner scan found inner match at {:?}\", litmatch);\n1650         let revinput = input\n1651             .clone()\n1652             .anchored(Anchored::Yes)\n1653             .span(input.start()..litmatch.start);\n1654         // Note that in addition to the literal search above scanning past\n1655         // our minimum start point, this routine can also return an error\n1656         // as a result of detecting possible quadratic behavior if the\n1657         // reverse scan goes past the minimum start point. That is, the\n1658         // literal search might not, but the reverse regex search for the\n1659         // prefix might!\n1660         match self.try_search_half_rev_limited(\n1661             cache,\n1662             &revinput,\n1663             min_match_start,\n1664         )? {\n1665             None => {\n1666                 if span.start >= span.end {\n1667                     break;\n1668                 }\n1669                 span.start = litmatch.start.checked_add(1).unwrap();\n1670             }\n1671             Some(hm_start) => {\n1672                 let fwdinput = input\n1673                     .clone()\n1674                     .anchored(Anchored::Pattern(hm_start.pattern()))\n1675                     .span(hm_start.offset()..input.end());\n1676                 match self.try_search_half_fwd_stopat(cache, &fwdinput)? {\n1677                     Err(stopat) => {\n1678                         min_pre_start = stopat;\n1679                         span.start =\n1680                             litmatch.start.checked_add(1).unwrap();\n1681                     }\n1682                     Ok(hm_end) => {\n1683                         return Ok(Some(Match::new(\n1684                             hm_start.pattern(),\n1685                             hm_start.offset()..hm_end.offset(),\n1686                         )))\n1687                     }\n1688                 }\n1689             }\n1690         }\n1691         min_match_start = litmatch.end;\n1692     }\n1693     Ok(None)\n1694 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}