{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        search::find_overlapping_fwd(self, input, state)?;\n        match state.get_match() {\n            None => Ok(()),\n            Some(_) if !utf8empty => Ok(()),\n            Some(_) => {\n                skip_empty_utf8_splits_overlapping(\n                    input,\n                    state,\n                    |input, state| { search::find_overlapping_fwd(self, input, state) },\n                )\n            }\n        }\n    }\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct OverlappingState {\n    /// The match reported by the most recent overlapping search to use this\n    /// state.\n    ///\n    /// If a search does not find any matches, then it is expected to clear\n    /// this value.\n    pub(crate) mat: Option<HalfMatch>,\n    /// The state ID of the state at which the search was in when the call\n    /// terminated. When this is a match state, `last_match` must be set to a\n    /// non-None value.\n    ///\n    /// A `None` value indicates the start state of the corresponding\n    /// automaton. We cannot use the actual ID, since any one automaton may\n    /// have many start states, and which one is in use depends on several\n    /// search-time factors.\n    pub(crate) id: Option<StateID>,\n    /// The position of the search.\n    ///\n    /// When `id` is None (i.e., we are starting a search), this is set to\n    /// the beginning of the search as given by the caller regardless of its\n    /// current value. Subsequent calls to an overlapping search pick up at\n    /// this offset.\n    pub(crate) at: usize,\n    /// The index into the matching patterns of the next match to report if the\n    /// current state is a match state. Note that this may be 1 greater than\n    /// the total number of matches to report for the current match state. (In\n    /// which case, no more matches should be reported at the current position\n    /// and the search should advance to the next position.)\n    pub(crate) next_match_index: Option<usize>,\n    /// This is set to true when a reverse overlapping search has entered its\n    /// EOI transitions.\n    ///\n    /// This isn't used in a forward search because it knows to stop once the\n    /// position exceeds the end of the search range. In a reverse search,\n    /// since we use unsigned offsets, we don't \"know\" once we've gone past\n    /// `0`. So the only way to detect it is with this extra flag. The reverse\n    /// overlapping search knows to terminate specifically after it has\n    /// reported all matches after following the EOI transition.\n    pub(crate) rev_eoi: bool,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\nimpl OverlappingState {\n    pub fn start() -> OverlappingState {}\n    pub fn get_match(&self) -> Option<HalfMatch> {\n        self.mat\n    }\n}\n#[inline(never)]\npub fn find_overlapping_fwd<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    state: &mut OverlappingState,\n) -> Result<(), MatchError> {\n    state.mat = None;\n    if input.is_done() {\n        return Ok(());\n    }\n    let pre = if input.get_anchored().is_anchored() {\n        None\n    } else {\n        dfa.get_prefilter()\n    };\n    if pre.is_some() {\n        find_overlapping_fwd_imp(dfa, input, pre, state)\n    } else {\n        find_overlapping_fwd_imp(dfa, input, None, state)\n    }\n}\n#[cold]\n#[inline(never)]\nfn skip_empty_utf8_splits_overlapping<F>(\n    input: &Input<'_>,\n    state: &mut OverlappingState,\n    mut search: F,\n) -> Result<(), MatchError>\nwhere\n    F: FnMut(&Input<'_>, &mut OverlappingState) -> Result<(), MatchError>,\n{\n    let mut hm = match state.get_match() {\n        None => return Ok(()),\n        Some(hm) => hm,\n    };\n    if input.get_anchored().is_anchored() {\n        if !input.is_char_boundary(hm.offset()) {\n            state.mat = None;\n        }\n        return Ok(());\n    }\n    while !input.is_char_boundary(hm.offset()) {\n        search(input, state)?;\n        hm = match state.get_match() {\n            None => return Ok(()),\n            Some(hm) => hm,\n        };\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes an overlapping forward search. Matches, if one exists, can be\n/// obtained via the [`OverlappingState::get_match`] method.\n///\n/// This routine is principally only useful when searching for multiple\n/// patterns on inputs where multiple patterns may match the same regions\n/// of text. In particular, callers must preserve the automaton's search\n/// state from prior calls so that the implementation knows where the last\n/// match occurred.\n///\n/// When using this routine to implement an iterator of overlapping\n/// matches, the `start` of the search should always be set to the end\n/// of the last match. If more patterns match at the previous location,\n/// then they will be immediately returned. (This is tracked by the given\n/// overlapping state.) Otherwise, the search continues at the starting\n/// position given.\n///\n/// If for some reason you want the search to forget about its previous\n/// state and restart the search at a particular position, then setting the\n/// state to [`OverlappingState::start`] will accomplish that.\n///\n/// # Errors\n///\n/// This routine errors if the search could not complete. This can occur\n/// in a number of circumstances:\n///\n/// * The configuration of the DFA may permit it to \"quit\" the search.\n/// For example, setting quit bytes or enabling heuristic support for\n/// Unicode word boundaries. The default configuration does not enable any\n/// option that could result in the DFA quitting.\n/// * When the provided `Input` configuration is not supported. For\n/// example, by providing an unsupported anchor mode.\n///\n/// When a search returns an error, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example\n///\n/// This example shows how to run a basic overlapping search with a\n/// [`dense::DFA`](crate::dfa::dense::DFA). Notice that we build the\n/// automaton with a `MatchKind::All` configuration. Overlapping searches\n/// are unlikely to work as one would expect when using the default\n/// `MatchKind::LeftmostFirst` match semantics, since leftmost-first\n/// matching is fundamentally incompatible with overlapping searches.\n/// Namely, overlapping searches need to report matches as they are seen,\n/// where as leftmost-first searches will continue searching even after a\n/// match has been observed in order to find the conventional end position\n/// of the match. More concretely, leftmost-first searches use dead states\n/// to terminate a search after a specific match can no longer be extended.\n/// Overlapping searches instead do the opposite by continuing the search\n/// to find totally new matches (potentially of other patterns).\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     dfa::{Automaton, OverlappingState, dense},\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = dense::Builder::new()\n///     .configure(dense::Config::new().match_kind(MatchKind::All))\n///     .build_many(&[r\"[[:word:]]+$\", r\"[[:^space:]]+$\"])?;\n/// let haystack = \"@foo\";\n/// let mut state = OverlappingState::start();\n///\n/// let expected = Some(HalfMatch::must(1, 4));\n/// dfa.try_search_overlapping_fwd(&Input::new(haystack), &mut state)?;\n/// assert_eq!(expected, state.get_match());\n///\n/// // The first pattern also matches at the same position, so re-running\n/// // the search will yield another match. Notice also that the first\n/// // pattern is returned after the second. This is because the second\n/// // pattern begins its match before the first, is therefore an earlier\n/// // match and is thus reported first.\n/// let expected = Some(HalfMatch::must(0, 4));\n/// dfa.try_search_overlapping_fwd(&Input::new(haystack), &mut state)?;\n/// assert_eq!(expected, state.get_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1582 fn try_search_overlapping_fwd(\n1583     &self,\n1584     input: &Input<'_>,\n1585     state: &mut OverlappingState,\n1586 ) -> Result<(), MatchError> {\n1587     let utf8empty = self.has_empty() && self.is_utf8();\n1588     search::find_overlapping_fwd(self, input, state)?;\n1589     match state.get_match() {\n1590         None => Ok(()),\n1591         Some(_) if !utf8empty => Ok(()),\n1592         Some(_) => skip_empty_utf8_splits_overlapping(\n1593             input,\n1594             state,\n1595             |input, state| {\n1596                 search::find_overlapping_fwd(self, input, state)\n1597             },\n1598         ),\n1599     }\n1600 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}