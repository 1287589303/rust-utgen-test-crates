{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/prefilter/mod.rs\n// crate name is regex_automata\nuse core::{borrow::Borrow, fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\n#[cfg(feature = \"alloc\")]\nuse alloc::sync::Arc;\n#[cfg(feature = \"syntax\")]\nuse regex_syntax::hir::{literal, Hir};\nuse crate::util::search::{MatchKind, Span};\npub(crate) use crate::util::prefilter::{\n    aho_corasick::AhoCorasick, byteset::ByteSet, memchr::{Memchr, Memchr2, Memchr3},\n    memmem::Memmem, teddy::Teddy,\n};\npub(crate) trait PrefilterI: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn find(&self, haystack: &[u8], span: Span) -> Option<Span>;\n    fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span>;\n    fn memory_usage(&self) -> usize;\n    fn is_fast(&self) -> bool;\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Memchr3(u8, u8, u8);\n#[derive(Clone, Debug)]\npub(crate) struct Memchr2(u8, u8);\n#[derive(Clone, Debug)]\npub(crate) struct AhoCorasick {\n    #[cfg(not(feature = \"perf-literal-multisubstring\"))]\n    _unused: (),\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    ac: aho_corasick::AhoCorasick,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Teddy {\n    #[cfg(not(feature = \"perf-literal-multisubstring\"))]\n    _unused: (),\n    /// The actual Teddy searcher.\n    ///\n    /// Technically, it's possible that Teddy doesn't actually get used, since\n    /// Teddy does require its haystack to at least be of a certain size\n    /// (usually around the size of whatever vector is being used, so ~16\n    /// or ~32 bytes). For haystacks shorter than that, the implementation\n    /// currently uses Rabin-Karp.\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    searcher: aho_corasick::packed::Searcher,\n    /// When running an anchored search, the packed searcher can't handle it so\n    /// we defer to Aho-Corasick itself. Kind of sad, but changing the packed\n    /// searchers to support anchored search would be difficult at worst and\n    /// annoying at best. Since packed searchers only apply to small numbers of\n    /// literals, we content ourselves that this is not much of an added cost.\n    /// (That packed searchers only work with a small number of literals is\n    /// also why we use a DFA here. Otherwise, the memory usage of a DFA would\n    /// likely be unacceptable.)\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    anchored_ac: aho_corasick::dfa::DFA,\n    /// The length of the smallest literal we look for.\n    ///\n    /// We use this as a heuristic to figure out whether this will be \"fast\" or\n    /// not. Generally, the longer the better, because longer needles are more\n    /// discriminating and thus reduce false positive rate.\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    minimum_len: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Memchr(u8);\n#[derive(Clone, Debug)]\npub(crate) struct Memmem {\n    #[cfg(not(all(feature = \"std\", feature = \"perf-literal-substring\")))]\n    _unused: (),\n    #[cfg(all(feature = \"std\", feature = \"perf-literal-substring\"))]\n    finder: memchr::memmem::Finder<'static>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[derive(Clone, Debug)]\npub(crate) enum Choice {\n    Memchr(Memchr),\n    Memchr2(Memchr2),\n    Memchr3(Memchr3),\n    Memmem(Memmem),\n    Teddy(Teddy),\n    ByteSet(ByteSet),\n    AhoCorasick(AhoCorasick),\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {}\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {\n        #[cfg(not(feature = \"alloc\"))] { None }\n        #[cfg(feature = \"alloc\")]\n        {\n            let pre: Arc<dyn PrefilterI> = match choice {\n                Choice::Memchr(p) => Arc::new(p),\n                Choice::Memchr2(p) => Arc::new(p),\n                Choice::Memchr3(p) => Arc::new(p),\n                Choice::Memmem(p) => Arc::new(p),\n                Choice::Teddy(p) => Arc::new(p),\n                Choice::ByteSet(p) => Arc::new(p),\n                Choice::AhoCorasick(p) => Arc::new(p),\n            };\n            let is_fast = pre.is_fast();\n            Some(Prefilter {\n                pre,\n                is_fast,\n                max_needle_len,\n            })\n        }\n    }\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// This turns a prefilter selection into a `Prefilter`. That is, in turns\n/// the enum given into a trait object.\n216 fn from_choice(\n217     choice: Choice,\n218     max_needle_len: usize,\n219 ) -> Option<Prefilter> {\n220     #[cfg(not(feature = \"alloc\"))]\n221     {\n222         None\n223     }\n224     #[cfg(feature = \"alloc\")]\n225     {\n226         let pre: Arc<dyn PrefilterI> = match choice {\n227             Choice::Memchr(p) => Arc::new(p),\n228             Choice::Memchr2(p) => Arc::new(p),\n229             Choice::Memchr3(p) => Arc::new(p),\n230             Choice::Memmem(p) => Arc::new(p),\n231             Choice::Teddy(p) => Arc::new(p),\n232             Choice::ByteSet(p) => Arc::new(p),\n233             Choice::AhoCorasick(p) => Arc::new(p),\n234         };\n235         let is_fast = pre.is_fast();\n236         Some(Prefilter { pre, is_fast, max_needle_len })\n237     }\n238 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}