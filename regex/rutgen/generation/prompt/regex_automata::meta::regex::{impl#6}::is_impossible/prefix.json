{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/regex.rs\n// crate name is regex_automata\ntype CachePool = Pool<Cache, CachePoolFn>;\ntype CachePoolGuard<'a> = PoolGuard<'a, Cache, CachePoolFn>;\ntype CachePoolFn = Box<dyn Fn() -> Cache + Send + Sync + UnwindSafe + RefUnwindSafe>;\nuse core::{borrow::Borrow, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::{boxed::Box, sync::Arc, vec, vec::Vec};\nuse regex_syntax::{ast, hir::{self, Hir}};\nuse crate::{\n    meta::{\n        error::BuildError, strategy::{self, Strategy},\n        wrappers,\n    },\n    nfa::thompson::WhichCaptures,\n    util::{\n        captures::{Captures, GroupInfo},\n        iter, pool::{Pool, PoolGuard},\n        prefilter::Prefilter, primitives::{NonMaxUsize, PatternID},\n        search::{HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n    },\n};\n#[derive(Clone, Debug)]\npub(crate) struct RegexInfo(Arc<RegexInfoI>);\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Span {\n    /// The start offset of the span, inclusive.\n    pub start: usize,\n    /// The end offset of the span, exclusive.\n    pub end: usize,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug)]\nstruct RegexInfoI {\n    config: Config,\n    props: Vec<hir::Properties>,\n    props_union: hir::Properties,\n}\nimpl RegexInfo {\n    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {}\n    pub(crate) fn config(&self) -> &Config {}\n    pub(crate) fn props(&self) -> &[hir::Properties] {}\n    pub(crate) fn props_union(&self) -> &hir::Properties {\n        &self.0.props_union\n    }\n    pub(crate) fn pattern_len(&self) -> usize {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_anchored_start(&self, input: &Input<'_>) -> bool {\n        input.get_anchored().is_anchored() || self.is_always_anchored_start()\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_start(&self) -> bool {\n        use regex_syntax::hir::Look;\n        self.props_union().look_set_prefix().contains(Look::Start)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_end(&self) -> bool {\n        use regex_syntax::hir::Look;\n        self.props_union().look_set_suffix().contains(Look::End)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_impossible(&self, input: &Input<'_>) -> bool {\n        if input.start() > 0 && self.is_always_anchored_start() {\n            return true;\n        }\n        if input.end() < input.haystack().len() && self.is_always_anchored_end() {\n            return true;\n        }\n        let minlen = match self.props_union().minimum_len() {\n            None => return false,\n            Some(minlen) => minlen,\n        };\n        if input.get_span().len() < minlen {\n            return true;\n        }\n        if self.is_anchored_start(input) && self.is_always_anchored_end() {\n            let maxlen = match self.props_union().maximum_len() {\n                None => return false,\n                Some(maxlen) => maxlen,\n            };\n            if input.get_span().len() > maxlen {\n                return true;\n            }\n        }\n        false\n    }\n}\nimpl Span {\n    #[inline]\n    pub fn range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.end.saturating_sub(self.start)\n    }\n    #[inline]\n    pub fn contains(&self, offset: usize) -> bool {}\n    #[inline]\n    pub fn offset(&self, offset: usize) -> Span {}\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {\n        self.span\n    }\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns true if and only if it is known that a match is impossible\n/// for the given input. This is useful for short-circuiting and avoiding\n/// running the regex engine if it's known no match can be reported.\n///\n/// Note that this doesn't necessarily detect every possible case. For\n/// example, when `pattern_len() == 0`, a match is impossible, but that\n/// case is so rare that it's fine to be handled by the regex engine\n/// itself. That is, it's not worth the cost of adding it here in order to\n/// make it a little faster. The reason is that this is called for every\n/// search. so there is some cost to adding checks here. Arguably, some of\n/// the checks that are here already probably shouldn't be here...\n1997 fn is_impossible(&self, input: &Input<'_>) -> bool {\n1998     // The underlying regex is anchored, so if we don't start the search\n1999     // at position 0, a match is impossible, because the anchor can only\n2000     // match at position 0.\n2001     if input.start() > 0 && self.is_always_anchored_start() {\n2002         return true;\n2003     }\n2004     // Same idea, but for the end anchor.\n2005     if input.end() < input.haystack().len()\n2006         && self.is_always_anchored_end()\n2007     {\n2008         return true;\n2009     }\n2010     // If the haystack is smaller than the minimum length required, then\n2011     // we know there can be no match.\n2012     let minlen = match self.props_union().minimum_len() {\n2013         None => return false,\n2014         Some(minlen) => minlen,\n2015     };\n2016     if input.get_span().len() < minlen {\n2017         return true;\n2018     }\n2019     // Same idea as minimum, but for maximum. This is trickier. We can\n2020     // only apply the maximum when we know the entire span that we're\n2021     // searching *has* to match according to the regex (and possibly the\n2022     // input configuration). If we know there is too much for the regex\n2023     // to match, we can bail early.\n2024     //\n2025     // I don't think we can apply the maximum otherwise unfortunately.\n2026     if self.is_anchored_start(input) && self.is_always_anchored_end() {\n2027         let maxlen = match self.props_union().maximum_len() {\n2028             None => return false,\n2029             Some(maxlen) => maxlen,\n2030         };\n2031         if input.get_span().len() > maxlen {\n2032             return true;\n2033         }\n2034     }\n2035     false\n2036 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}