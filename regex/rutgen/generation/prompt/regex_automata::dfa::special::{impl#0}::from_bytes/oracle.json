{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/special.rs\n// crate name is regex_automata\nuse crate::{\n    dfa::DEAD,\n    util::{primitives::StateID, wire::{self, DeserializeError, Endian, SerializeError}},\n};\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\nimpl Special {\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn new() -> Special {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {}\n    pub(crate) fn from_bytes(\n        mut slice: &[u8],\n    ) -> Result<(Special, usize), DeserializeError> {\n        wire::check_slice_len(slice, 8 * StateID::SIZE, \"special states\")?;\n        let mut nread = 0;\n        let mut read_id = |what| -> Result<StateID, DeserializeError> {\n            let (id, nr) = wire::try_read_state_id(slice, what)?;\n            nread += nr;\n            slice = &slice[StateID::SIZE..];\n            Ok(id)\n        };\n        let max = read_id(\"special max id\")?;\n        let quit_id = read_id(\"special quit id\")?;\n        let min_match = read_id(\"special min match id\")?;\n        let max_match = read_id(\"special max match id\")?;\n        let min_accel = read_id(\"special min accel id\")?;\n        let max_accel = read_id(\"special max accel id\")?;\n        let min_start = read_id(\"special min start id\")?;\n        let max_start = read_id(\"special max start id\")?;\n        let special = Special {\n            max,\n            quit_id,\n            min_match,\n            max_match,\n            min_accel,\n            max_accel,\n            min_start,\n            max_start,\n        };\n        special.validate()?;\n        assert_eq!(nread, special.write_to_len());\n        Ok((special, nread))\n    }\n    pub(crate) fn validate(&self) -> Result<(), DeserializeError> {\n        if self.min_match == DEAD && self.max_match != DEAD {\n            err!(\"min_match is DEAD, but max_match is not\");\n        }\n        if self.min_match != DEAD && self.max_match == DEAD {\n            err!(\"max_match is DEAD, but min_match is not\");\n        }\n        if self.min_accel == DEAD && self.max_accel != DEAD {\n            err!(\"min_accel is DEAD, but max_accel is not\");\n        }\n        if self.min_accel != DEAD && self.max_accel == DEAD {\n            err!(\"max_accel is DEAD, but min_accel is not\");\n        }\n        if self.min_start == DEAD && self.max_start != DEAD {\n            err!(\"min_start is DEAD, but max_start is not\");\n        }\n        if self.min_start != DEAD && self.max_start == DEAD {\n            err!(\"max_start is DEAD, but min_start is not\");\n        }\n        if self.min_match > self.max_match {\n            err!(\"min_match should not be greater than max_match\");\n        }\n        if self.min_accel > self.max_accel {\n            err!(\"min_accel should not be greater than max_accel\");\n        }\n        if self.min_start > self.max_start {\n            err!(\"min_start should not be greater than max_start\");\n        }\n        if self.matches() && self.quit_id >= self.min_match {\n            err!(\"quit_id should not be greater than min_match\");\n        }\n        if self.accels() && self.quit_id >= self.min_accel {\n            err!(\"quit_id should not be greater than min_accel\");\n        }\n        if self.starts() && self.quit_id >= self.min_start {\n            err!(\"quit_id should not be greater than min_start\");\n        }\n        if self.matches() && self.accels() && self.min_accel < self.min_match {\n            err!(\"min_match should not be greater than min_accel\");\n        }\n        if self.matches() && self.starts() && self.min_start < self.min_match {\n            err!(\"min_match should not be greater than min_start\");\n        }\n        if self.accels() && self.starts() && self.min_start < self.min_accel {\n            err!(\"min_accel should not be greater than min_start\");\n        }\n        if self.max < self.quit_id {\n            err!(\"quit_id should not be greater than max\");\n        }\n        if self.max < self.max_match {\n            err!(\"max_match should not be greater than max\");\n        }\n        if self.max < self.max_accel {\n            err!(\"max_accel should not be greater than max\");\n        }\n        if self.max < self.max_start {\n            err!(\"max_start should not be greater than max\");\n        }\n        Ok(())\n    }\n    pub(crate) fn validate_state_len(\n        &self,\n        len: usize,\n        stride2: usize,\n    ) -> Result<(), DeserializeError> {}\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {\n        8 * StateID::SIZE\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_max(&mut self) {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_no_special_start_states(&mut self) {}\n    #[inline]\n    pub(crate) fn is_special_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_dead_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_quit_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_match_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_accel_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_start_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn match_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn matches(&self) -> bool {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn accel_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn accels(&self) -> bool {}\n    #[inline]\n    pub(crate) fn starts(&self) -> bool {}\n}\npub(crate) fn check_slice_len<T>(\n    slice: &[T],\n    at_least_len: usize,\n    what: &'static str,\n) -> Result<(), DeserializeError> {\n    if slice.len() < at_least_len {\n        return Err(DeserializeError::buffer_too_small(what));\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Deserialize the given bytes into special state ranges. If the slice\n/// given is not big enough, then this returns an error. Similarly, if\n/// any of the expected invariants around special state ranges aren't\n/// upheld, an error is returned. Note that this does not guarantee that\n/// the information returned is correct.\n///\n/// Upon success, this returns the number of bytes read in addition to the\n/// special state IDs themselves.\n223 pub(crate) fn from_bytes(\n224     mut slice: &[u8],\n225 ) -> Result<(Special, usize), DeserializeError> {\n226     wire::check_slice_len(slice, 8 * StateID::SIZE, \"special states\")?;\n227 \n228     let mut nread = 0;\n229     let mut read_id = |what| -> Result<StateID, DeserializeError> {\n230         let (id, nr) = wire::try_read_state_id(slice, what)?;\n231         nread += nr;\n232         slice = &slice[StateID::SIZE..];\n233         Ok(id)\n234     };\n235 \n236     let max = read_id(\"special max id\")?;\n237     let quit_id = read_id(\"special quit id\")?;\n238     let min_match = read_id(\"special min match id\")?;\n239     let max_match = read_id(\"special max match id\")?;\n240     let min_accel = read_id(\"special min accel id\")?;\n241     let max_accel = read_id(\"special max accel id\")?;\n242     let min_start = read_id(\"special min start id\")?;\n243     let max_start = read_id(\"special max start id\")?;\n244 \n245     let special = Special {\n246         max,\n247         quit_id,\n248         min_match,\n249         max_match,\n250         min_accel,\n251         max_accel,\n252         min_start,\n253         max_start,\n254     };\n255     special.validate()?;\n256     assert_eq!(nread, special.write_to_len());\n257     Ok((special, nread))\n258 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}