{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/dense.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\npub(crate) type OwnedDFA = DFA<alloc::vec::Vec<u32>>;\n#[cfg(feature = \"dfa-build\")]\nuse core::cmp;\nuse core::{fmt, iter, mem::size_of, slice};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{\n    collections::{BTreeMap, BTreeSet},\n    vec, vec::Vec,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::{\n    dfa::{accel::Accel, determinize, minimize::Minimizer, remapper::Remapper, sparse},\n    nfa::thompson, util::{look::LookMatcher, search::MatchKind},\n};\nuse crate::{\n    dfa::{\n        accel::Accels, automaton::{fmt_state_indicator, Automaton, StartError},\n        special::Special, start::StartKind, DEAD,\n    },\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        int::{Pointer, Usize},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-dense\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\npub(crate) struct TransitionTable<T> {\n    /// A contiguous region of memory representing the transition table in\n    /// row-major order. The representation is dense. That is, every state\n    /// has precisely the same number of transitions. The maximum number of\n    /// transitions per state is 257 (256 for each possible byte value, plus 1\n    /// for the special EOI transition). If a DFA has been instructed to use\n    /// byte classes (the default), then the number of transitions is usually\n    /// substantially fewer.\n    ///\n    /// In practice, T is either `Vec<u32>` or `&[u32]`.\n    table: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is if\n    /// the DFA's kind uses byte classes (which is the default). Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    classes: ByteClasses,\n    /// The stride of each DFA state, expressed as a power-of-two exponent.\n    ///\n    /// The stride of a DFA corresponds to the total amount of space used by\n    /// each DFA state in the transition table. This may be bigger than the\n    /// size of a DFA's alphabet, since the stride is always the smallest\n    /// power of two greater than or equal to the alphabet size.\n    ///\n    /// While this wastes space, this avoids the need for integer division\n    /// to convert between premultiplied state IDs and their corresponding\n    /// indices. Instead, we can use simple bit-shifts.\n    ///\n    /// See the docs for the `stride2` method for more details.\n    ///\n    /// The minimum `stride2` value is `1` (corresponding to a stride of `2`)\n    /// while the maximum `stride2` value is `9` (corresponding to a stride of\n    /// `512`). The maximum is not `8` since the maximum alphabet size is `257`\n    /// when accounting for the special EOI transition. However, an alphabet\n    /// length of that size is exceptionally rare since the alphabet is shrunk\n    /// into equivalence classes.\n    stride2: usize,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\nimpl<'a> TransitionTable<&'a [u32]> {\n    unsafe fn from_bytes_unchecked(\n        mut slice: &'a [u8],\n    ) -> Result<(TransitionTable<&'a [u32]>, usize), DeserializeError> {\n        let slice_start = slice.as_ptr().as_usize();\n        let (state_len, nr) = wire::try_read_u32_as_usize(slice, \"state length\")?;\n        slice = &slice[nr..];\n        let (stride2, nr) = wire::try_read_u32_as_usize(slice, \"stride2\")?;\n        slice = &slice[nr..];\n        let (classes, nr) = ByteClasses::from_bytes(slice)?;\n        slice = &slice[nr..];\n        if stride2 > 9 {\n            return Err(\n                DeserializeError::generic(\"dense DFA has invalid stride2 (too big)\"),\n            );\n        }\n        if stride2 < 1 {\n            return Err(\n                DeserializeError::generic(\"dense DFA has invalid stride2 (too small)\"),\n            );\n        }\n        let stride = 1usize.checked_shl(u32::try_from(stride2).unwrap()).unwrap();\n        if classes.alphabet_len() > stride {\n            return Err(\n                DeserializeError::generic(\n                    \"alphabet size cannot be bigger than transition table stride\",\n                ),\n            );\n        }\n        let trans_len = wire::shl(state_len, stride2, \"dense table transition length\")?;\n        let table_bytes_len = wire::mul(\n            trans_len,\n            StateID::SIZE,\n            \"dense table state byte length\",\n        )?;\n        wire::check_slice_len(slice, table_bytes_len, \"transition table\")?;\n        wire::check_alignment::<StateID>(slice)?;\n        let table_bytes = &slice[..table_bytes_len];\n        slice = &slice[table_bytes_len..];\n        let table = core::slice::from_raw_parts(\n            table_bytes.as_ptr().cast::<u32>(),\n            trans_len,\n        );\n        let tt = TransitionTable {\n            table,\n            classes,\n            stride2,\n        };\n        Ok((tt, slice.as_ptr().as_usize() - slice_start))\n    }\n}\nimpl ByteClasses {\n    #[inline]\n    pub fn empty() -> ByteClasses {}\n    #[inline]\n    pub fn singletons() -> ByteClasses {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteClasses, usize), DeserializeError> {\n        wire::check_slice_len(slice, 256, \"byte class map\")?;\n        let mut classes = ByteClasses::empty();\n        for (b, &class) in slice[..256].iter().enumerate() {\n            classes.set(u8::try_from(b).unwrap(), class);\n        }\n        for &b in classes.0.iter() {\n            if usize::from(b) >= classes.alphabet_len() {\n                return Err(\n                    DeserializeError::generic(\n                        \"found equivalence class greater than alphabet len\",\n                    ),\n                );\n            }\n        }\n        Ok((classes, 256))\n    }\n    pub(crate) fn write_to(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[inline]\n    pub fn set(&mut self, byte: u8, class: u8) {}\n    #[inline]\n    pub fn get(&self, byte: u8) -> u8 {}\n    #[inline]\n    pub fn get_by_unit(&self, unit: Unit) -> usize {}\n    #[inline]\n    pub fn eoi(&self) -> Unit {}\n    #[inline]\n    pub fn alphabet_len(&self) -> usize {\n        usize::from(self.0[255]) + 1 + 1\n    }\n    #[inline]\n    pub fn stride2(&self) -> usize {}\n    #[inline]\n    pub fn is_singleton(&self) -> bool {}\n    #[inline]\n    pub fn iter(&self) -> ByteClassIter<'_> {}\n    pub fn representatives<R: core::ops::RangeBounds<u8>>(\n        &self,\n        range: R,\n    ) -> ByteClassRepresentatives<'_> {}\n    #[inline]\n    pub fn elements(&self, class: Unit) -> ByteClassElements {}\n    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges {}\n}\nimpl DeserializeError {\n    pub(crate) fn generic(msg: &'static str) -> DeserializeError {\n        DeserializeError(DeserializeErrorKind::Generic {\n            msg,\n        })\n    }\n    pub(crate) fn buffer_too_small(what: &'static str) -> DeserializeError {}\n    fn invalid_usize(what: &'static str) -> DeserializeError {}\n    fn version_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn endian_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn alignment_mismatch(alignment: usize, address: usize) -> DeserializeError {}\n    fn label_mismatch(expected: &'static str) -> DeserializeError {}\n    fn arithmetic_overflow(what: &'static str) -> DeserializeError {}\n    fn pattern_id_error(err: PatternIDError, what: &'static str) -> DeserializeError {}\n    pub(crate) fn state_id_error(\n        err: StateIDError,\n        what: &'static str,\n    ) -> DeserializeError {}\n}\npub(crate) fn shl(\n    a: usize,\n    b: usize,\n    what: &'static str,\n) -> Result<usize, DeserializeError> {\n    let amount = u32::try_from(b)\n        .map_err(|_| DeserializeError::arithmetic_overflow(what))?;\n    match a.checked_shl(amount) {\n        Some(c) => Ok(c),\n        None => Err(DeserializeError::arithmetic_overflow(what)),\n    }\n}\npub(crate) fn try_read_u32_as_usize(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(usize, usize), DeserializeError> {\n    try_read_u32(slice, what)\n        .and_then(|(n, nr)| {\n            usize::try_from(n)\n                .map(|n| (n, nr))\n                .map_err(|_| DeserializeError::invalid_usize(what))\n        })\n}\npub(crate) fn check_slice_len<T>(\n    slice: &[T],\n    at_least_len: usize,\n    what: &'static str,\n) -> Result<(), DeserializeError> {\n    if slice.len() < at_least_len {\n        return Err(DeserializeError::buffer_too_small(what));\n    }\n    Ok(())\n}\npub(crate) fn check_alignment<T>(slice: &[u8]) -> Result<(), DeserializeError> {\n    let alignment = core::mem::align_of::<T>();\n    let address = slice.as_ptr().as_usize();\n    if address % alignment == 0 {\n        return Ok(());\n    }\n    Err(DeserializeError::alignment_mismatch(alignment, address))\n}\npub(crate) fn mul(\n    a: usize,\n    b: usize,\n    what: &'static str,\n) -> Result<usize, DeserializeError> {\n    match a.checked_mul(b) {\n        Some(c) => Ok(c),\n        None => Err(DeserializeError::arithmetic_overflow(what)),\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Deserialize a transition table starting at the beginning of `slice`.\n/// Upon success, return the total number of bytes read along with the\n/// transition table.\n///\n/// If there was a problem deserializing any part of the transition table,\n/// then this returns an error. Notably, if the given slice does not have\n/// the same alignment as `StateID`, then this will return an error (among\n/// other possible errors).\n///\n/// This is guaranteed to execute in constant time.\n///\n/// # Safety\n///\n/// This routine is not safe because it does not check the validity of the\n/// transition table itself. In particular, the transition table can be\n/// quite large, so checking its validity can be somewhat expensive. An\n/// invalid transition table is not safe because other code may rely on the\n/// transition table being correct (such as explicit bounds check elision).\n/// Therefore, an invalid transition table can lead to undefined behavior.\n///\n/// Callers that use this function must either pass on the safety invariant\n/// or guarantee that the bytes given contain a valid transition table.\n/// This guarantee is upheld by the bytes written by `write_to`.\n3362 unsafe fn from_bytes_unchecked(\n3363     mut slice: &'a [u8],\n3364 ) -> Result<(TransitionTable<&'a [u32]>, usize), DeserializeError> {\n3365     let slice_start = slice.as_ptr().as_usize();\n3366 \n3367     let (state_len, nr) =\n3368         wire::try_read_u32_as_usize(slice, \"state length\")?;\n3369     slice = &slice[nr..];\n3370 \n3371     let (stride2, nr) = wire::try_read_u32_as_usize(slice, \"stride2\")?;\n3372     slice = &slice[nr..];\n3373 \n3374     let (classes, nr) = ByteClasses::from_bytes(slice)?;\n3375     slice = &slice[nr..];\n3376 \n3377     // The alphabet length (determined by the byte class map) cannot be\n3378     // bigger than the stride (total space used by each DFA state).\n3379     if stride2 > 9 {\n3380         return Err(DeserializeError::generic(\n3381             \"dense DFA has invalid stride2 (too big)\",\n3382         ));\n3383     }\n3384     // It also cannot be zero, since even a DFA that never matches anything\n3385     // has a non-zero number of states with at least two equivalence\n3386     // classes: one for all 256 byte values and another for the EOI\n3387     // sentinel.\n3388     if stride2 < 1 {\n3389         return Err(DeserializeError::generic(\n3390             \"dense DFA has invalid stride2 (too small)\",\n3391         ));\n3392     }\n3393     // This is OK since 1 <= stride2 <= 9.\n3394     let stride =\n3395         1usize.checked_shl(u32::try_from(stride2).unwrap()).unwrap();\n3396     if classes.alphabet_len() > stride {\n3397         return Err(DeserializeError::generic(\n3398             \"alphabet size cannot be bigger than transition table stride\",\n3399         ));\n3400     }\n3401 \n3402     let trans_len =\n3403         wire::shl(state_len, stride2, \"dense table transition length\")?;\n3404     let table_bytes_len = wire::mul(\n3405         trans_len,\n3406         StateID::SIZE,\n3407         \"dense table state byte length\",\n3408     )?;\n3409     wire::check_slice_len(slice, table_bytes_len, \"transition table\")?;\n3410     wire::check_alignment::<StateID>(slice)?;\n3411     let table_bytes = &slice[..table_bytes_len];\n3412     slice = &slice[table_bytes_len..];\n3413     // SAFETY: Since StateID is always representable as a u32, all we need\n3414     // to do is ensure that we have the proper length and alignment. We've\n3415     // checked both above, so the cast below is safe.\n3416     //\n3417     // N.B. This is the only not-safe code in this function.\n3418     let table = core::slice::from_raw_parts(\n3419         table_bytes.as_ptr().cast::<u32>(),\n3420         trans_len,\n3421     );\n3422     let tt = TransitionTable { table, classes, stride2 };\n3423     Ok((tt, slice.as_ptr().as_usize() - slice_start))\n3424 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}