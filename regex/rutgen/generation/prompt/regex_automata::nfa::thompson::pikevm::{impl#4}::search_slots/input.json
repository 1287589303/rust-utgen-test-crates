{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/pikevm.rs\n// crate name is regex_automata\n#[cfg(feature = \"internal-instrument-pikevm\")]\nuse core::cell::RefCell;\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n        sparse_set::SparseSet,\n    },\n};\n#[derive(Clone, Debug)]\npub struct PikeVM {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used while computing epsilon closure. This effectively lets us\n    /// move what is more naturally expressed through recursion to a stack\n    /// on the heap.\n    stack: Vec<FollowEpsilon>,\n    /// The current active states being explored for the current byte in the\n    /// haystack.\n    curr: ActiveStates,\n    /// The next set of states we're building that will be explored for the\n    /// next byte in the haystack.\n    next: ActiveStates,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\nimpl PikeVM {\n    #[inline]\n    pub fn search(&self, cache: &mut Cache, input: &Input<'_>, caps: &mut Captures) {}\n    #[inline]\n    pub fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {\n        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n        if !utf8empty {\n            let hm = self.search_slots_imp(cache, input, slots)?;\n            return Some(hm.pattern());\n        }\n        let min = self.get_nfa().group_info().implicit_slot_len();\n        if slots.len() >= min {\n            let hm = self.search_slots_imp(cache, input, slots)?;\n            return Some(hm.pattern());\n        }\n        if self.get_nfa().pattern_len() == 1 {\n            let mut enough = [None, None];\n            let got = self.search_slots_imp(cache, input, &mut enough);\n            slots.copy_from_slice(&enough[..slots.len()]);\n            return got.map(|hm| hm.pattern());\n        }\n        let mut enough = vec![None; min];\n        let got = self.search_slots_imp(cache, input, &mut enough);\n        slots.copy_from_slice(&enough[..slots.len()]);\n        got.map(|hm| hm.pattern())\n    }\n    #[inline(never)]\n    fn search_slots_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {\n        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n        let hm = match self.search_imp(cache, input, slots) {\n            None => return None,\n            Some(hm) if !utf8empty => return Some(hm),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_fwd(\n                input,\n                hm,\n                hm.offset(),\n                |input| {\n                    Ok(self.search_imp(cache, input, slots).map(|hm| (hm, hm.offset())))\n                },\n            )\n            .unwrap()\n    }\n    #[inline]\n    pub fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) {}\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {\n        self.pattern\n    }\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {\n        self.0.start_pattern.len()\n    }\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {}\n    #[inline]\n    pub fn states(&self) -> &[State] {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {\n        &self.0.group_info()\n    }\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {\n        self.0.has_empty\n    }\n    #[inline]\n    pub fn is_utf8(&self) -> bool {\n        self.0.utf8\n    }\n    #[inline]\n    pub fn is_reverse(&self) -> bool {}\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {}\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {}\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl GroupInfo {\n    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>\n    where\n        P: IntoIterator<Item = G>,\n        G: IntoIterator<Item = Option<N>>,\n        N: AsRef<str>,\n    {}\n    pub fn empty() -> GroupInfo {}\n    #[inline]\n    pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {}\n    #[inline]\n    pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {}\n    #[inline]\n    pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {}\n    #[inline]\n    pub fn all_names(&self) -> GroupInfoAllNames<'_> {}\n    #[inline]\n    pub fn slots(&self, pid: PatternID, group_index: usize) -> Option<(usize, usize)> {}\n    #[inline]\n    pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn group_len(&self, pid: PatternID) -> usize {}\n    #[inline]\n    pub fn all_group_len(&self) -> usize {}\n    #[inline]\n    pub fn slot_len(&self) -> usize {}\n    #[inline]\n    pub fn implicit_slot_len(&self) -> usize {\n        self.pattern_len() * 2\n    }\n    #[inline]\n    pub fn explicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes a leftmost forward search and writes the spans of capturing\n/// groups that participated in a match into the provided `slots`, and\n/// returns the matching pattern ID. The contents of the slots for patterns\n/// other than the matching pattern are unspecified. If no match was found,\n/// then `None` is returned and the contents of `slots` is unspecified.\n///\n/// This is like [`PikeVM::search`], but it accepts a raw slots slice\n/// instead of a `Captures` value. This is useful in contexts where you\n/// don't want or need to allocate a `Captures`.\n///\n/// It is legal to pass _any_ number of slots to this routine. If the regex\n/// engine would otherwise write a slot offset that doesn't fit in the\n/// provided slice, then it is simply skipped. In general though, there are\n/// usually three slice lengths you might want to use:\n///\n/// * An empty slice, if you only care about which pattern matched.\n/// * A slice with\n/// [`pattern_len() * 2`](crate::nfa::thompson::NFA::pattern_len)\n/// slots, if you only care about the overall match spans for each matching\n/// pattern.\n/// * A slice with\n/// [`slot_len()`](crate::util::captures::GroupInfo::slot_len) slots, which\n/// permits recording match offsets for every capturing group in every\n/// pattern.\n///\n/// # Example\n///\n/// This example shows how to find the overall match offsets in a\n/// multi-pattern search without allocating a `Captures` value. Indeed, we\n/// can put our slots right on the stack.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{nfa::thompson::pikevm::PikeVM, PatternID, Input};\n///\n/// let re = PikeVM::new_many(&[\n///     r\"\\pL+\",\n///     r\"\\d+\",\n/// ])?;\n/// let mut cache = re.create_cache();\n/// let input = Input::new(\"!@#123\");\n///\n/// // We only care about the overall match offsets here, so we just\n/// // allocate two slots for each pattern. Each slot records the start\n/// // and end of the match.\n/// let mut slots = [None; 4];\n/// let pid = re.search_slots(&mut cache, &input, &mut slots);\n/// assert_eq!(Some(PatternID::must(1)), pid);\n///\n/// // The overall match offsets are always at 'pid * 2' and 'pid * 2 + 1'.\n/// // See 'GroupInfo' for more details on the mapping between groups and\n/// // slot indices.\n/// let slot_start = pid.unwrap().as_usize() * 2;\n/// let slot_end = slot_start + 1;\n/// assert_eq!(Some(3), slots[slot_start].map(|s| s.get()));\n/// assert_eq!(Some(6), slots[slot_end].map(|s| s.get()));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1091 pub fn search_slots(\n1092     &self,\n1093     cache: &mut Cache,\n1094     input: &Input<'_>,\n1095     slots: &mut [Option<NonMaxUsize>],\n1096 ) -> Option<PatternID> {\n1097     let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n1098     if !utf8empty {\n1099         let hm = self.search_slots_imp(cache, input, slots)?;\n1100         return Some(hm.pattern());\n1101     }\n1102     // There is an unfortunate special case where if the regex can\n1103     // match the empty string and UTF-8 mode is enabled, the search\n1104     // implementation requires that the slots have at least as much space\n1105     // to report the bounds of any match. This is so zero-width matches\n1106     // that split a codepoint can be filtered out.\n1107     //\n1108     // Note that if utf8empty is true, we specialize the case for when\n1109     // the number of patterns is 1. In that case, we can just use a stack\n1110     // allocation. Otherwise we resort to a heap allocation, which we\n1111     // convince ourselves we're fine with due to the pathological nature of\n1112     // this case.\n1113     let min = self.get_nfa().group_info().implicit_slot_len();\n1114     if slots.len() >= min {\n1115         let hm = self.search_slots_imp(cache, input, slots)?;\n1116         return Some(hm.pattern());\n1117     }\n1118     if self.get_nfa().pattern_len() == 1 {\n1119         let mut enough = [None, None];\n1120         let got = self.search_slots_imp(cache, input, &mut enough);\n1121         // This is OK because we know `enough` is strictly bigger than\n1122         // `slots`, otherwise this special case isn't reached.\n1123         slots.copy_from_slice(&enough[..slots.len()]);\n1124         return got.map(|hm| hm.pattern());\n1125     }\n1126     let mut enough = vec![None; min];\n1127     let got = self.search_slots_imp(cache, input, &mut enough);\n1128     // This is OK because we know `enough` is strictly bigger than `slots`,\n1129     // otherwise this special case isn't reached.\n1130     slots.copy_from_slice(&enough[..slots.len()]);\n1131     got.map(|hm| hm.pattern())\n1132 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}