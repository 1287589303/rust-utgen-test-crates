{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/hir/mod.rs\n// crate name is regex_lite\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\nuse crate::{error::Error, utf8};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) struct Hir {\n    kind: HirKind,\n    is_start_anchored: bool,\n    is_match_empty: bool,\n    static_explicit_captures_len: Option<usize>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) enum HirKind {\n    Empty,\n    Char(char),\n    Class(Class),\n    Look(Look),\n    Repetition(Repetition),\n    Capture(Capture),\n    Concat(Vec<Hir>),\n    Alternation(Vec<Hir>),\n}\nimpl Hir {\n    pub(crate) fn parse(config: Config, pattern: &str) -> Result<Hir, Error> {}\n    pub(crate) fn kind(&self) -> &HirKind {}\n    pub(crate) fn is_start_anchored(&self) -> bool {}\n    pub(crate) fn is_match_empty(&self) -> bool {}\n    pub(crate) fn static_explicit_captures_len(&self) -> Option<usize> {}\n    fn fail() -> Hir {\n        let kind = HirKind::Class(Class { ranges: vec![] });\n        Hir {\n            kind,\n            is_start_anchored: false,\n            is_match_empty: false,\n            static_explicit_captures_len: Some(0),\n        }\n    }\n    fn empty() -> Hir {}\n    fn char(ch: char) -> Hir {}\n    fn class(class: Class) -> Hir {}\n    fn look(look: Look) -> Hir {}\n    fn repetition(rep: Repetition) -> Hir {}\n    fn capture(cap: Capture) -> Hir {}\n    fn concat(mut subs: Vec<Hir>) -> Hir {}\n    fn alternation(mut subs: Vec<Hir>) -> Hir {\n        if subs.is_empty() {\n            Hir::fail()\n        } else if subs.len() == 1 {\n            subs.pop().unwrap()\n        } else {\n            let mut it = subs.iter().peekable();\n            let mut is_start_anchored = it\n                .peek()\n                .map_or(false, |sub| sub.is_start_anchored);\n            let mut is_match_empty = it.peek().map_or(false, |sub| sub.is_match_empty);\n            let mut static_explicit_captures_len = it\n                .peek()\n                .and_then(|sub| sub.static_explicit_captures_len);\n            for sub in it {\n                is_start_anchored = is_start_anchored && sub.is_start_anchored;\n                is_match_empty = is_match_empty || sub.is_match_empty;\n                if static_explicit_captures_len != sub.static_explicit_captures_len {\n                    static_explicit_captures_len = None;\n                }\n            }\n            Hir {\n                kind: HirKind::Alternation(subs),\n                is_start_anchored,\n                is_match_empty,\n                static_explicit_captures_len,\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n337 fn alternation(mut subs: Vec<Hir>) -> Hir {\n338     if subs.is_empty() {\n339         Hir::fail()\n340     } else if subs.len() == 1 {\n341         subs.pop().unwrap()\n342     } else {\n343         let mut it = subs.iter().peekable();\n344         let mut is_start_anchored =\n345             it.peek().map_or(false, |sub| sub.is_start_anchored);\n346         let mut is_match_empty =\n347             it.peek().map_or(false, |sub| sub.is_match_empty);\n348         let mut static_explicit_captures_len =\n349             it.peek().and_then(|sub| sub.static_explicit_captures_len);\n350         for sub in it {\n351             is_start_anchored = is_start_anchored && sub.is_start_anchored;\n352             is_match_empty = is_match_empty || sub.is_match_empty;\n353             if static_explicit_captures_len\n354                 != sub.static_explicit_captures_len\n355             {\n356                 static_explicit_captures_len = None;\n357             }\n358         }\n359         Hir {\n360             kind: HirKind::Alternation(subs),\n361             is_start_anchored,\n362             is_match_empty,\n363             static_explicit_captures_len,\n364         }\n365     }\n366 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}