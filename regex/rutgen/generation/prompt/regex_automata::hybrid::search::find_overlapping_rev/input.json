{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/hybrid/search.rs\n// crate name is regex_automata\nuse crate::{\n    hybrid::{\n        dfa::{Cache, OverlappingState, DFA},\n        id::LazyStateID,\n    },\n    util::{prefilter::Prefilter, search::{HalfMatch, Input, MatchError, Span}},\n};\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// The transition table.\n    ///\n    /// Given a `current` LazyStateID and an `input` byte, the next state can\n    /// be computed via `trans[untagged(current) + equiv_class(input)]`. Notice\n    /// that no multiplication is used. That's because state identifiers are\n    /// \"premultiplied.\"\n    ///\n    /// Note that the next state may be the \"unknown\" state. In this case, the\n    /// next state is not known and determinization for `current` on `input`\n    /// must be performed.\n    trans: Vec<LazyStateID>,\n    /// The starting states for this DFA.\n    ///\n    /// These are computed lazily. Initially, these are all set to \"unknown\"\n    /// lazy state IDs.\n    ///\n    /// When 'starts_for_each_pattern' is disabled (the default), then the size\n    /// of this is constrained to the possible starting configurations based\n    /// on the search parameters. (At time of writing, that's 4.) However,\n    /// when starting states for each pattern is enabled, then there are N\n    /// additional groups of starting states, where each group reflects the\n    /// different possible configurations and N is the number of patterns.\n    starts: Vec<LazyStateID>,\n    /// A sequence of NFA/DFA powerset states that have been computed for this\n    /// lazy DFA. This sequence is indexable by untagged LazyStateIDs. (Every\n    /// tagged LazyStateID can be used to index this sequence by converting it\n    /// to its untagged form.)\n    states: Vec<State>,\n    /// A map from states to their corresponding IDs. This map may be accessed\n    /// via the raw byte representation of a state, which means that a `State`\n    /// does not need to be allocated to determine whether it already exists\n    /// in this map. Indeed, the existence of such a state is what determines\n    /// whether we allocate a new `State` or not.\n    ///\n    /// The higher level idea here is that we do just enough determinization\n    /// for a state to check whether we've already computed it. If we have,\n    /// then we can save a little (albeit not much) work. The real savings is\n    /// in memory usage. If we never checked for trivially duplicate states,\n    /// then our memory usage would explode to unreasonable levels.\n    states_to_id: StateMap,\n    /// Sparse sets used to track which NFA states have been visited during\n    /// various traversals.\n    sparses: SparseSets,\n    /// Scratch space for traversing the NFA graph. (We use space on the heap\n    /// instead of the call stack.)\n    stack: Vec<NFAStateID>,\n    /// Scratch space for building a NFA/DFA powerset state. This is used to\n    /// help amortize allocation since not every powerset state generated is\n    /// added to the cache. In particular, if it already exists in the cache,\n    /// then there is no need to allocate a new `State` for it.\n    scratch_state_builder: StateBuilderEmpty,\n    /// A simple abstraction for handling the saving of at most a single state\n    /// across a cache clearing. This is required for correctness. Namely, if\n    /// adding a new state after clearing the cache fails, then the caller\n    /// must retain the ability to continue using the state ID given. The\n    /// state corresponding to the state ID is what we preserve across cache\n    /// clearings.\n    state_saver: StateSaver,\n    /// The memory usage, in bytes, used by 'states' and 'states_to_id'. We\n    /// track this as new states are added since states use a variable amount\n    /// of heap. Tracking this as we add states makes it possible to compute\n    /// the total amount of memory used by the determinizer in constant time.\n    memory_usage_state: usize,\n    /// The number of times the cache has been cleared. When a minimum cache\n    /// clear count is set, then the cache will return an error instead of\n    /// clearing the cache if the count has been exceeded.\n    clear_count: usize,\n    /// The total number of bytes searched since the last time this cache was\n    /// cleared, not including the current search.\n    ///\n    /// This can be added to the length of the current search to get the true\n    /// total number of bytes searched.\n    ///\n    /// This is generally only non-zero when the\n    /// `Cache::search_{start,update,finish}` APIs are used to track search\n    /// progress.\n    bytes_searched: usize,\n    /// The progress of the current search.\n    ///\n    /// This is only non-`None` when callers utlize the `Cache::search_start`,\n    /// `Cache::search_update` and `Cache::search_finish` APIs.\n    ///\n    /// The purpose of recording search progress is to be able to make a\n    /// determination about the efficiency of the cache. Namely, by keeping\n    /// track of the\n    progress: Option<SearchProgress>,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct LazyStateID(u32);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug)]\npub struct DFA {\n    config: Config,\n    nfa: thompson::NFA,\n    stride2: usize,\n    start_map: StartByteMap,\n    classes: ByteClasses,\n    quitset: ByteSet,\n    cache_capacity: usize,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Debug)]\npub struct CacheError(());\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct OverlappingState {\n    /// The match reported by the most recent overlapping search to use this\n    /// state.\n    ///\n    /// If a search does not find any matches, then it is expected to clear\n    /// this value.\n    pub(crate) mat: Option<HalfMatch>,\n    /// The state ID of the state at which the search was in when the call\n    /// terminated. When this is a match state, `last_match` must be set to a\n    /// non-None value.\n    ///\n    /// A `None` value indicates the start state of the corresponding\n    /// automaton. We cannot use the actual ID, since any one automaton may\n    /// have many start states, and which one is in use depends on several\n    /// search-time factors.\n    pub(crate) id: Option<LazyStateID>,\n    /// The position of the search.\n    ///\n    /// When `id` is None (i.e., we are starting a search), this is set to\n    /// the beginning of the search as given by the caller regardless of its\n    /// current value. Subsequent calls to an overlapping search pick up at\n    /// this offset.\n    pub(crate) at: usize,\n    /// The index into the matching patterns of the next match to report if the\n    /// current state is a match state. Note that this may be 1 greater than\n    /// the total number of matches to report for the current match state. (In\n    /// which case, no more matches should be reported at the current position\n    /// and the search should advance to the next position.)\n    pub(crate) next_match_index: Option<usize>,\n    /// This is set to true when a reverse overlapping search has entered its\n    /// EOI transitions.\n    ///\n    /// This isn't used in a forward search because it knows to stop once the\n    /// position exceeds the end of the search range. In a reverse search,\n    /// since we use unsigned offsets, we don't \"know\" once we've gone past\n    /// `0`. So the only way to detect it is with this extra flag. The reverse\n    /// overlapping search knows to terminate specifically after it has\n    /// reported all matches after following the EOI transition.\n    pub(crate) rev_eoi: bool,\n}\nimpl Cache {\n    pub fn new(dfa: &DFA) -> Cache {}\n    pub fn reset(&mut self, dfa: &DFA) {}\n    #[inline]\n    pub fn search_start(&mut self, at: usize) {\n        if let Some(p) = self.progress.take() {\n            self.bytes_searched += p.len();\n        }\n        self.progress = Some(SearchProgress { start: at, at });\n    }\n    #[inline]\n    pub fn search_update(&mut self, at: usize) {\n        let p = self.progress.as_mut().expect(\"no in-progress search to update\");\n        p.at = at;\n    }\n    #[inline]\n    pub fn search_finish(&mut self, at: usize) {\n        let mut p = self.progress.take().expect(\"no in-progress search to finish\");\n        p.at = at;\n        self.bytes_searched += p.len();\n    }\n    pub fn search_total_len(&self) -> usize {}\n    pub fn clear_count(&self) -> usize {}\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl LazyStateID {\n    #[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n    const MAX_BIT: usize = 31;\n    #[cfg(target_pointer_width = \"16\")]\n    const MAX_BIT: usize = 15;\n    const MASK_UNKNOWN: usize = 1 << (LazyStateID::MAX_BIT);\n    const MASK_DEAD: usize = 1 << (LazyStateID::MAX_BIT - 1);\n    const MASK_QUIT: usize = 1 << (LazyStateID::MAX_BIT - 2);\n    const MASK_START: usize = 1 << (LazyStateID::MAX_BIT - 3);\n    const MASK_MATCH: usize = 1 << (LazyStateID::MAX_BIT - 4);\n    const MAX: usize = LazyStateID::MASK_MATCH - 1;\n    #[inline]\n    pub(crate) fn new(id: usize) -> Result<LazyStateID, LazyStateIDError> {}\n    #[inline]\n    const fn new_unchecked(id: usize) -> LazyStateID {}\n    #[inline]\n    pub(crate) fn as_usize_untagged(&self) -> usize {}\n    #[inline]\n    pub(crate) const fn as_usize_unchecked(&self) -> usize {}\n    #[inline]\n    pub(crate) const fn to_unknown(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_dead(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_quit(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_start(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_match(&self) -> LazyStateID {}\n    #[inline]\n    pub const fn is_tagged(&self) -> bool {\n        self.as_usize_unchecked() > LazyStateID::MAX\n    }\n    #[inline]\n    pub const fn is_unknown(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_UNKNOWN > 0\n    }\n    #[inline]\n    pub const fn is_dead(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_DEAD > 0\n    }\n    #[inline]\n    pub const fn is_quit(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_QUIT > 0\n    }\n    #[inline]\n    pub const fn is_start(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_START > 0\n    }\n    #[inline]\n    pub const fn is_match(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_MATCH > 0\n    }\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {\n        self.get_span().start > self.get_span().end\n    }\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl DFA {\n    #[inline]\n    pub fn next_state(\n        &self,\n        cache: &mut Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> Result<LazyStateID, CacheError> {\n        let class = usize::from(self.classes.get(input));\n        let offset = current.as_usize_untagged() + class;\n        let sid = cache.trans[offset];\n        if !sid.is_unknown() {\n            return Ok(sid);\n        }\n        let unit = alphabet::Unit::u8(input);\n        Lazy::new(self, cache).cache_next_state(current, unit)\n    }\n    #[inline]\n    pub fn next_state_untagged(\n        &self,\n        cache: &Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> LazyStateID {}\n    #[inline]\n    pub unsafe fn next_state_untagged_unchecked(\n        &self,\n        cache: &Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> LazyStateID {}\n    #[inline]\n    pub fn next_eoi_state(\n        &self,\n        cache: &mut Cache,\n        current: LazyStateID,\n    ) -> Result<LazyStateID, CacheError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state(\n        &self,\n        cache: &mut Cache,\n        config: &start::Config,\n    ) -> Result<LazyStateID, StartError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state_forward(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<LazyStateID, MatchError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state_reverse(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<LazyStateID, MatchError> {}\n    #[inline]\n    pub fn match_len(&self, cache: &Cache, id: LazyStateID) -> usize {\n        assert!(id.is_match());\n        LazyRef::new(self, cache).get_cached_state(id).match_len()\n    }\n    #[inline]\n    pub fn match_pattern(\n        &self,\n        cache: &Cache,\n        id: LazyStateID,\n        match_index: usize,\n    ) -> PatternID {\n        if self.pattern_len() == 1 {\n            return PatternID::ZERO;\n        }\n        LazyRef::new(self, cache).get_cached_state(id).match_pattern(match_index)\n    }\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {\n        HalfMatch { pattern, offset }\n    }\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {\n        MatchError::new(MatchErrorKind::Quit {\n            byte,\n            offset,\n        })\n    }\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {}\n}\n#[inline(never)]\npub(crate) fn find_overlapping_rev(\n    dfa: &DFA,\n    cache: &mut Cache,\n    input: &Input<'_>,\n    state: &mut OverlappingState,\n) -> Result<(), MatchError> {\n    state.mat = None;\n    if input.is_done() {\n        return Ok(());\n    }\n    let mut sid = match state.id {\n        None => {\n            let sid = init_rev(dfa, cache, input)?;\n            state.id = Some(sid);\n            if input.start() == input.end() {\n                state.rev_eoi = true;\n            } else {\n                state.at = input.end() - 1;\n            }\n            sid\n        }\n        Some(sid) => {\n            if let Some(match_index) = state.next_match_index {\n                let match_len = dfa.match_len(cache, sid);\n                if match_index < match_len {\n                    state.next_match_index = Some(match_index + 1);\n                    let pattern = dfa.match_pattern(cache, sid, match_index);\n                    state.mat = Some(HalfMatch::new(pattern, state.at));\n                    return Ok(());\n                }\n            }\n            if state.rev_eoi {\n                return Ok(());\n            } else if state.at == input.start() {\n                state.rev_eoi = true;\n            } else {\n                state.at -= 1;\n            }\n            sid\n        }\n    };\n    cache.search_start(state.at);\n    while !state.rev_eoi {\n        sid = dfa\n            .next_state(cache, sid, input.haystack()[state.at])\n            .map_err(|_| gave_up(state.at))?;\n        if sid.is_tagged() {\n            state.id = Some(sid);\n            if sid.is_start() {} else if sid.is_match() {\n                state.next_match_index = Some(1);\n                let pattern = dfa.match_pattern(cache, sid, 0);\n                state.mat = Some(HalfMatch::new(pattern, state.at + 1));\n                cache.search_finish(state.at);\n                return Ok(());\n            } else if sid.is_dead() {\n                cache.search_finish(state.at);\n                return Ok(());\n            } else if sid.is_quit() {\n                cache.search_finish(state.at);\n                return Err(MatchError::quit(input.haystack()[state.at], state.at));\n            } else {\n                debug_assert!(sid.is_unknown());\n                unreachable!(\"sid being unknown is a bug\");\n            }\n        }\n        if state.at == input.start() {\n            break;\n        }\n        state.at -= 1;\n        cache.search_update(state.at);\n    }\n    let result = eoi_rev(dfa, cache, input, &mut sid, &mut state.mat);\n    state.rev_eoi = true;\n    state.id = Some(sid);\n    if state.mat.is_some() {\n        state.next_match_index = Some(1);\n    }\n    cache.search_finish(input.start());\n    result\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn init_rev(\n    dfa: &DFA,\n    cache: &mut Cache,\n    input: &Input<'_>,\n) -> Result<LazyStateID, MatchError> {\n    let sid = dfa.start_state_reverse(cache, input)?;\n    debug_assert!(! sid.is_match());\n    Ok(sid)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn eoi_rev(\n    dfa: &DFA,\n    cache: &mut Cache,\n    input: &Input<'_>,\n    sid: &mut LazyStateID,\n    mat: &mut Option<HalfMatch>,\n) -> Result<(), MatchError> {\n    let sp = input.get_span();\n    if sp.start > 0 {\n        let byte = input.haystack()[sp.start - 1];\n        *sid = dfa.next_state(cache, *sid, byte).map_err(|_| gave_up(sp.start))?;\n        if sid.is_match() {\n            let pattern = dfa.match_pattern(cache, *sid, 0);\n            *mat = Some(HalfMatch::new(pattern, sp.start));\n        } else if sid.is_quit() {\n            return Err(MatchError::quit(byte, sp.start - 1));\n        }\n    } else {\n        *sid = dfa.next_eoi_state(cache, *sid).map_err(|_| gave_up(sp.start))?;\n        if sid.is_match() {\n            let pattern = dfa.match_pattern(cache, *sid, 0);\n            *mat = Some(HalfMatch::new(pattern, 0));\n        }\n        debug_assert!(! sid.is_quit());\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n567 pub(crate) fn find_overlapping_rev(\n568     dfa: &DFA,\n569     cache: &mut Cache,\n570     input: &Input<'_>,\n571     state: &mut OverlappingState,\n572 ) -> Result<(), MatchError> {\n573     state.mat = None;\n574     if input.is_done() {\n575         return Ok(());\n576     }\n577     let mut sid = match state.id {\n578         None => {\n579             let sid = init_rev(dfa, cache, input)?;\n580             state.id = Some(sid);\n581             if input.start() == input.end() {\n582                 state.rev_eoi = true;\n583             } else {\n584                 state.at = input.end() - 1;\n585             }\n586             sid\n587         }\n588         Some(sid) => {\n589             if let Some(match_index) = state.next_match_index {\n590                 let match_len = dfa.match_len(cache, sid);\n591                 if match_index < match_len {\n592                     state.next_match_index = Some(match_index + 1);\n593                     let pattern = dfa.match_pattern(cache, sid, match_index);\n594                     state.mat = Some(HalfMatch::new(pattern, state.at));\n595                     return Ok(());\n596                 }\n597             }\n598             // Once we've reported all matches at a given position, we need\n599             // to advance the search to the next position. However, if we've\n600             // already followed the EOI transition, then we know we're done\n601             // with the search and there cannot be any more matches to report.\n602             if state.rev_eoi {\n603                 return Ok(());\n604             } else if state.at == input.start() {\n605                 // At this point, we should follow the EOI transition. This\n606                 // will cause us the skip the main loop below and fall through\n607                 // to the final 'eoi_rev' transition.\n608                 state.rev_eoi = true;\n609             } else {\n610                 // We haven't hit the end of the search yet, so move on.\n611                 state.at -= 1;\n612             }\n613             sid\n614         }\n615     };\n616     cache.search_start(state.at);\n617     while !state.rev_eoi {\n618         sid = dfa\n619             .next_state(cache, sid, input.haystack()[state.at])\n620             .map_err(|_| gave_up(state.at))?;\n621         if sid.is_tagged() {\n622             state.id = Some(sid);\n623             if sid.is_start() {\n624                 // do nothing\n625             } else if sid.is_match() {\n626                 state.next_match_index = Some(1);\n627                 let pattern = dfa.match_pattern(cache, sid, 0);\n628                 state.mat = Some(HalfMatch::new(pattern, state.at + 1));\n629                 cache.search_finish(state.at);\n630                 return Ok(());\n631             } else if sid.is_dead() {\n632                 cache.search_finish(state.at);\n633                 return Ok(());\n634             } else if sid.is_quit() {\n635                 cache.search_finish(state.at);\n636                 return Err(MatchError::quit(\n637                     input.haystack()[state.at],\n638                     state.at,\n639                 ));\n640             } else {\n641                 debug_assert!(sid.is_unknown());\n642                 unreachable!(\"sid being unknown is a bug\");\n643             }\n644         }\n645         if state.at == input.start() {\n646             break;\n647         }\n648         state.at -= 1;\n649         cache.search_update(state.at);\n650     }\n651 \n652     let result = eoi_rev(dfa, cache, input, &mut sid, &mut state.mat);\n653     state.rev_eoi = true;\n654     state.id = Some(sid);\n655     if state.mat.is_some() {\n656         // '1' is always correct here since if we get to this point, this\n657         // always corresponds to the first (index '0') match discovered at\n658         // this position. So the next match to report at this position (if\n659         // it exists) is at index '1'.\n660         state.next_match_index = Some(1);\n661     }\n662     cache.search_finish(input.start());\n663     result\n664 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}