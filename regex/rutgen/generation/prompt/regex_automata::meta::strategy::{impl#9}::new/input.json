{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseInner {\n    core: Core,\n    preinner: Prefilter,\n    nfarev: NFA,\n    hybrid: wrappers::ReverseHybrid,\n    dfa: wrappers::ReverseDFA,\n}\n#[derive(Clone, Debug)]\npub struct Compiler {\n    /// A regex parser, used when compiling an NFA directly from a pattern\n    /// string.\n    parser: ParserBuilder,\n    /// The compiler configuration.\n    config: Config,\n    /// The builder for actually constructing an NFA. This provides a\n    /// convenient abstraction for writing a compiler.\n    builder: RefCell<Builder>,\n    /// State used for compiling character classes to UTF-8 byte automata.\n    /// State is not retained between character class compilations. This just\n    /// serves to amortize allocation to the extent possible.\n    utf8_state: RefCell<Utf8State>,\n    /// State used for arranging character classes in reverse into a trie.\n    trie_state: RefCell<RangeTrie>,\n    /// State used for caching common suffixes when compiling reverse UTF-8\n    /// automata (for Unicode character classes).\n    utf8_suffix: RefCell<Utf8SuffixMap>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Debug)]\npub(crate) struct DFA(Option<DFAEngine>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Debug)]\npub(crate) struct ReverseHybrid(Option<ReverseHybridEngine>);\n#[derive(Clone, Debug)]\npub(crate) struct RegexInfo(Arc<RegexInfoI>);\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Debug)]\npub(crate) struct ReverseDFA(Option<ReverseDFAEngine>);\n#[derive(Debug)]\npub(crate) struct Hybrid(Option<HybridEngine>);\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\n#[derive(Clone, Copy, Debug)]\npub enum WhichCaptures {\n    /// All capture states, including those corresponding to both implicit and\n    /// explicit capture groups, are included in the Thompson NFA.\n    All,\n    /// Only capture states corresponding to implicit capture groups are\n    /// included. Implicit capture groups appear in every pattern implicitly\n    /// and correspond to the overall match of a pattern.\n    ///\n    /// This is useful when one only cares about the overall match of a\n    /// pattern. By excluding capture states from explicit capture groups,\n    /// one might be able to reduce the memory usage of a multi-pattern regex\n    /// substantially if it was otherwise written to have many explicit capture\n    /// groups.\n    Implicit,\n    /// No capture states are compiled into the Thompson NFA.\n    ///\n    /// This is useful when capture states are either not needed (for example,\n    /// if one is only trying to build a DFA) or if they aren't supported (for\n    /// example, a reverse NFA).\n    None,\n}\nimpl ReverseInner {\n    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseInner, Core> {\n        if !core.info.config().get_auto_prefilter() {\n            debug!(\n                \"skipping reverse inner optimization because \\\n                 automatic prefilters are disabled\"\n            );\n            return Err(core);\n        }\n        if core.info.config().get_match_kind() != MatchKind::LeftmostFirst {\n            debug!(\n                \"skipping reverse inner optimization because \\\n\t\t\t\t match kind is {:?} but this only supports leftmost-first\",\n                core.info.config().get_match_kind(),\n            );\n            return Err(core);\n        }\n        if core.info.is_always_anchored_start() {\n            debug!(\n                \"skipping reverse inner optimization because \\\n\t\t\t\t the regex is always anchored at the start\",\n            );\n            return Err(core);\n        }\n        if !core.hybrid.is_some() && !core.dfa.is_some() {\n            debug!(\n                \"skipping reverse inner optimization because \\\n\t\t\t\t we don't have a lazy DFA or a full DFA\"\n            );\n            return Err(core);\n        }\n        if core.pre.as_ref().map_or(false, |p| p.is_fast()) {\n            debug!(\n                \"skipping reverse inner optimization because \\\n\t\t\t\t we already have a prefilter that we think is fast\"\n            );\n            return Err(core);\n        } else if core.pre.is_some() {\n            debug!(\n                \"core engine has a prefix prefilter, but it is \\\n                 probably not fast, so continuing with attempt to \\\n                 use reverse inner prefilter\"\n            );\n        }\n        let (concat_prefix, preinner) = match reverse_inner::extract(hirs) {\n            Some(x) => x,\n            None => return Err(core),\n        };\n        debug!(\"building reverse NFA for prefix before inner literal\");\n        let mut lookm = LookMatcher::new();\n        lookm.set_line_terminator(core.info.config().get_line_terminator());\n        let thompson_config = thompson::Config::new()\n            .reverse(true)\n            .utf8(core.info.config().get_utf8_empty())\n            .nfa_size_limit(core.info.config().get_nfa_size_limit())\n            .shrink(false)\n            .which_captures(WhichCaptures::None)\n            .look_matcher(lookm);\n        let result = thompson::Compiler::new()\n            .configure(thompson_config)\n            .build_from_hir(&concat_prefix);\n        let nfarev = match result {\n            Ok(nfarev) => nfarev,\n            Err(_err) => {\n                debug!(\n                    \"skipping reverse inner optimization because the \\\n\t\t\t\t\t reverse NFA failed to build: {}\",\n                    _err,\n                );\n                return Err(core);\n            }\n        };\n        debug!(\"building reverse DFA for prefix before inner literal\");\n        let dfa = if !core.info.config().get_dfa() {\n            wrappers::ReverseDFA::none()\n        } else {\n            wrappers::ReverseDFA::new(&core.info, &nfarev)\n        };\n        let hybrid = if !core.info.config().get_hybrid() {\n            wrappers::ReverseHybrid::none()\n        } else if dfa.is_some() {\n            debug!(\n                \"skipping lazy DFA for reverse inner optimization \\\n\t\t\t\t because we have a full DFA\"\n            );\n            wrappers::ReverseHybrid::none()\n        } else {\n            wrappers::ReverseHybrid::new(&core.info, &nfarev)\n        };\n        Ok(ReverseInner {\n            core,\n            preinner,\n            nfarev,\n            hybrid,\n            dfa,\n        })\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_full(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_fwd_stopat(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_rev_limited(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n}\nimpl Compiler {\n    pub fn new() -> Compiler {\n        Compiler {\n            parser: ParserBuilder::new(),\n            config: Config::default(),\n            builder: RefCell::new(Builder::new()),\n            utf8_state: RefCell::new(Utf8State::new()),\n            trie_state: RefCell::new(RangeTrie::new()),\n            utf8_suffix: RefCell::new(Utf8SuffixMap::new(1000)),\n        }\n    }\n    pub fn build(&self, pattern: &str) -> Result<NFA, BuildError> {}\n    pub fn build_many<P: AsRef<str>>(&self, patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn build_from_hir(&self, expr: &Hir) -> Result<NFA, BuildError> {\n        self.build_many_from_hir(&[expr])\n    }\n    pub fn build_many_from_hir<H: Borrow<Hir>>(\n        &self,\n        exprs: &[H],\n    ) -> Result<NFA, BuildError> {}\n    pub fn configure(&mut self, config: Config) -> &mut Compiler {\n        self.config = self.config.overwrite(config);\n        self\n    }\n    pub fn syntax(&mut self, config: crate::util::syntax::Config) -> &mut Compiler {}\n}\nimpl Config {\n    pub fn new() -> Config {\n        Config::default()\n    }\n    pub fn match_kind(self, kind: MatchKind) -> Config {}\n    pub fn utf8_empty(self, yes: bool) -> Config {}\n    pub fn auto_prefilter(self, yes: bool) -> Config {}\n    pub fn prefilter(self, pre: Option<Prefilter>) -> Config {}\n    pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {\n        self.which_captures = Some(which_captures);\n        self\n    }\n    pub fn nfa_size_limit(mut self, bytes: Option<usize>) -> Config {\n        self.nfa_size_limit = Some(bytes);\n        self\n    }\n    pub fn onepass_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn hybrid_cache_capacity(self, limit: usize) -> Config {}\n    pub fn dfa_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn dfa_state_limit(self, limit: Option<usize>) -> Config {}\n    pub fn byte_classes(self, yes: bool) -> Config {}\n    pub fn line_terminator(self, byte: u8) -> Config {}\n    pub fn hybrid(self, yes: bool) -> Config {}\n    pub fn dfa(self, yes: bool) -> Config {}\n    pub fn onepass(self, yes: bool) -> Config {}\n    pub fn backtrack(self, yes: bool) -> Config {}\n    pub fn get_match_kind(&self) -> MatchKind {\n        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)\n    }\n    pub fn get_utf8_empty(&self) -> bool {\n        self.utf8_empty.unwrap_or(true)\n    }\n    pub fn get_auto_prefilter(&self) -> bool {\n        self.autopre.unwrap_or(true)\n    }\n    pub fn get_prefilter(&self) -> Option<&Prefilter> {}\n    pub fn get_which_captures(&self) -> WhichCaptures {}\n    pub fn get_nfa_size_limit(&self) -> Option<usize> {\n        self.nfa_size_limit.unwrap_or(Some(10 * (1 << 20)))\n    }\n    pub fn get_onepass_size_limit(&self) -> Option<usize> {}\n    pub fn get_hybrid_cache_capacity(&self) -> usize {}\n    pub fn get_dfa_size_limit(&self) -> Option<usize> {}\n    pub fn get_dfa_state_limit(&self) -> Option<usize> {}\n    pub fn get_byte_classes(&self) -> bool {}\n    pub fn get_line_terminator(&self) -> u8 {\n        self.line_terminator.unwrap_or(b'\\n')\n    }\n    pub fn get_hybrid(&self) -> bool {\n        #[cfg(feature = \"hybrid\")] { self.hybrid.unwrap_or(true) }\n        #[cfg(not(feature = \"hybrid\"))] { false }\n    }\n    pub fn get_dfa(&self) -> bool {\n        #[cfg(feature = \"dfa-build\")] { self.dfa.unwrap_or(true) }\n        #[cfg(not(feature = \"dfa-build\"))] { false }\n    }\n    pub fn get_onepass(&self) -> bool {}\n    pub fn get_backtrack(&self) -> bool {}\n    pub(crate) fn overwrite(&self, o: Config) -> Config {}\n}\nimpl DFA {\n    pub(crate) fn none() -> DFA {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> DFA {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&DFAEngine> {}\n    pub(crate) fn is_some(&self) -> bool {\n        self.0.is_some()\n    }\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl ReverseHybrid {\n    pub(crate) fn none() -> ReverseHybrid {\n        ReverseHybrid(None)\n    }\n    pub(crate) fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseHybrid {\n        ReverseHybrid(ReverseHybridEngine::new(info, nfarev))\n    }\n    pub(crate) fn create_cache(&self) -> ReverseHybridCache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&ReverseHybridEngine> {}\n}\nimpl RegexInfo {\n    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {}\n    pub(crate) fn config(&self) -> &Config {\n        &self.0.config\n    }\n    pub(crate) fn props(&self) -> &[hir::Properties] {}\n    pub(crate) fn props_union(&self) -> &hir::Properties {}\n    pub(crate) fn pattern_len(&self) -> usize {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_anchored_start(&self, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_start(&self) -> bool {\n        use regex_syntax::hir::Look;\n        self.props_union().look_set_prefix().contains(Look::Start)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_end(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_impossible(&self, input: &Input<'_>) -> bool {}\n}\nimpl LookMatcher {\n    pub fn new() -> LookMatcher {\n        LookMatcher {\n            lineterm: DebugByte(b'\\n'),\n        }\n    }\n    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {\n        self.lineterm.0 = byte;\n        self\n    }\n    pub fn get_line_terminator(&self) -> u8 {}\n    #[inline]\n    pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_inline(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn matches_set(&self, set: LookSet, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_set_inline(\n        &self,\n        set: LookSet,\n        haystack: &[u8],\n        at: usize,\n    ) -> bool {}\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn add_to_byteset(\n        &self,\n        look: Look,\n        set: &mut crate::util::alphabet::ByteClassSet,\n    ) {}\n    #[inline]\n    pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_unicode_negate(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n}\nimpl ReverseDFA {\n    pub(crate) fn none() -> ReverseDFA {\n        ReverseDFA(None)\n    }\n    pub(crate) fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseDFA {\n        ReverseDFA(ReverseDFAEngine::new(info, nfarev))\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&ReverseDFAEngine> {}\n    pub(crate) fn is_some(&self) -> bool {\n        self.0.is_some()\n    }\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl Hybrid {\n    pub(crate) fn none() -> Hybrid {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Hybrid {}\n    pub(crate) fn create_cache(&self) -> HybridCache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&HybridEngine> {}\n    pub(crate) fn is_some(&self) -> bool {\n        self.0.is_some()\n    }\n}\npub(crate) fn extract(hirs: &[&Hir]) -> Option<(Hir, Prefilter)> {\n    if hirs.len() != 1 {\n        debug!(\n            \"skipping reverse inner optimization since it only \\\n\t\t \t supports 1 pattern, {} were given\",\n            hirs.len(),\n        );\n        return None;\n    }\n    let mut concat = match top_concat(hirs[0]) {\n        Some(concat) => concat,\n        None => {\n            debug!(\n                \"skipping reverse inner optimization because a top-level \\\n\t\t \t     concatenation could not found\",\n            );\n            return None;\n        }\n    };\n    for i in 1..concat.len() {\n        let hir = &concat[i];\n        let pre = match prefilter(hir) {\n            None => continue,\n            Some(pre) => pre,\n        };\n        if !pre.is_fast() {\n            debug!(\n                \"skipping extracted inner prefilter because \\\n\t\t\t\t it probably isn't fast\"\n            );\n            continue;\n        }\n        let concat_suffix = Hir::concat(concat.split_off(i));\n        let concat_prefix = Hir::concat(concat);\n        let pre2 = match prefilter(&concat_suffix) {\n            None => pre,\n            Some(pre2) => if pre2.is_fast() { pre2 } else { pre }\n        };\n        return Some((concat_prefix, pre2));\n    }\n    debug!(\n        \"skipping reverse inner optimization because a top-level \\\n\t     sub-expression with a fast prefilter could not be found\"\n    );\n    None\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1510 fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseInner, Core> {\n1511     if !core.info.config().get_auto_prefilter() {\n1512         debug!(\n1513             \"skipping reverse inner optimization because \\\n1514              automatic prefilters are disabled\"\n1515         );\n1516         return Err(core);\n1517     }\n1518     // Currently we hard-code the assumption of leftmost-first match\n1519     // semantics. This isn't a huge deal because 'all' semantics tend to\n1520     // only be used for forward overlapping searches with multiple regexes,\n1521     // and this optimization only supports a single pattern at the moment.\n1522     if core.info.config().get_match_kind() != MatchKind::LeftmostFirst {\n1523         debug!(\n1524             \"skipping reverse inner optimization because \\\n1525  match kind is {:?} but this only supports leftmost-first\",\n1526             core.info.config().get_match_kind(),\n1527         );\n1528         return Err(core);\n1529     }\n1530     // It's likely that a reverse inner scan has too much overhead for it\n1531     // to be worth it when the regex is anchored at the start. It is\n1532     // possible for it to be quite a bit faster if the initial literal\n1533     // scan fails to detect a match, in which case, we can say \"no match\"\n1534     // very quickly. But this could be undesirable, e.g., scanning too far\n1535     // or when the literal scan matches. If it matches, then confirming the\n1536     // match requires a reverse scan followed by a forward scan to confirm\n1537     // or reject, which is a fair bit of work.\n1538     //\n1539     // Note that the caller can still request an anchored search even\n1540     // when the regex isn't anchored. We detect that case in the search\n1541     // routines below and just fallback to the core engine. Currently this\n1542     // optimization assumes all searches are unanchored, so if we do want\n1543     // to enable this optimization for anchored searches, it will need a\n1544     // little work to support it.\n1545     if core.info.is_always_anchored_start() {\n1546         debug!(\n1547             \"skipping reverse inner optimization because \\\n1548  the regex is always anchored at the start\",\n1549         );\n1550         return Err(core);\n1551     }\n1552     // Only DFAs can do reverse searches (currently), so we need one of\n1553     // them in order to do this optimization. It's possible (although\n1554     // pretty unlikely) that we have neither and need to give up.\n1555     if !core.hybrid.is_some() && !core.dfa.is_some() {\n1556         debug!(\n1557             \"skipping reverse inner optimization because \\\n1558  we don't have a lazy DFA or a full DFA\"\n1559         );\n1560         return Err(core);\n1561     }\n1562     if core.pre.as_ref().map_or(false, |p| p.is_fast()) {\n1563         debug!(\n1564             \"skipping reverse inner optimization because \\\n1565  we already have a prefilter that we think is fast\"\n1566         );\n1567         return Err(core);\n1568     } else if core.pre.is_some() {\n1569         debug!(\n1570             \"core engine has a prefix prefilter, but it is \\\n1571              probably not fast, so continuing with attempt to \\\n1572              use reverse inner prefilter\"\n1573         );\n1574     }\n1575     let (concat_prefix, preinner) = match reverse_inner::extract(hirs) {\n1576         Some(x) => x,\n1577         // N.B. the 'extract' function emits debug messages explaining\n1578         // why we bailed out here.\n1579         None => return Err(core),\n1580     };\n1581     debug!(\"building reverse NFA for prefix before inner literal\");\n1582     let mut lookm = LookMatcher::new();\n1583     lookm.set_line_terminator(core.info.config().get_line_terminator());\n1584     let thompson_config = thompson::Config::new()\n1585         .reverse(true)\n1586         .utf8(core.info.config().get_utf8_empty())\n1587         .nfa_size_limit(core.info.config().get_nfa_size_limit())\n1588         .shrink(false)\n1589         .which_captures(WhichCaptures::None)\n1590         .look_matcher(lookm);\n1591     let result = thompson::Compiler::new()\n1592         .configure(thompson_config)\n1593         .build_from_hir(&concat_prefix);\n1594     let nfarev = match result {\n1595         Ok(nfarev) => nfarev,\n1596         Err(_err) => {\n1597             debug!(\n1598                 \"skipping reverse inner optimization because the \\\n1599 \t reverse NFA failed to build: {}\",\n1600                 _err,\n1601             );\n1602             return Err(core);\n1603         }\n1604     };\n1605     debug!(\"building reverse DFA for prefix before inner literal\");\n1606     let dfa = if !core.info.config().get_dfa() {\n1607         wrappers::ReverseDFA::none()\n1608     } else {\n1609         wrappers::ReverseDFA::new(&core.info, &nfarev)\n1610     };\n1611     let hybrid = if !core.info.config().get_hybrid() {\n1612         wrappers::ReverseHybrid::none()\n1613     } else if dfa.is_some() {\n1614         debug!(\n1615             \"skipping lazy DFA for reverse inner optimization \\\n1616  because we have a full DFA\"\n1617         );\n1618         wrappers::ReverseHybrid::none()\n1619     } else {\n1620         wrappers::ReverseHybrid::new(&core.info, &nfarev)\n1621     };\n1622     Ok(ReverseInner { core, preinner, nfarev, hybrid, dfa })\n1623 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}