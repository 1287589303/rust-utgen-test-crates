{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/pikevm.rs\n// crate name is regex_automata\n#[cfg(feature = \"internal-instrument-pikevm\")]\nuse core::cell::RefCell;\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n        sparse_set::SparseSet,\n    },\n};\n#[derive(Clone, Debug)]\npub struct PikeVM {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used while computing epsilon closure. This effectively lets us\n    /// move what is more naturally expressed through recursion to a stack\n    /// on the heap.\n    stack: Vec<FollowEpsilon>,\n    /// The current active states being explored for the current byte in the\n    /// haystack.\n    curr: ActiveStates,\n    /// The next set of states we're building that will be explored for the\n    /// next byte in the haystack.\n    next: ActiveStates,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\nimpl PikeVM {\n    #[inline]\n    pub fn is_match<'h, I: Into<Input<'h>>>(&self, cache: &mut Cache, input: I) -> bool {\n        let input = input.into().earliest(true);\n        self.search_slots(cache, &input, &mut []).is_some()\n    }\n    #[inline]\n    pub fn find<'h, I: Into<Input<'h>>>(\n        &self,\n        cache: &mut Cache,\n        input: I,\n    ) -> Option<Match> {}\n    #[inline]\n    pub fn captures<'h, I: Into<Input<'h>>>(\n        &self,\n        cache: &mut Cache,\n        input: I,\n        caps: &mut Captures,\n    ) {}\n    #[inline]\n    pub fn find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(\n        &'r self,\n        cache: &'c mut Cache,\n        input: I,\n    ) -> FindMatches<'r, 'c, 'h> {}\n    #[inline]\n    pub fn captures_iter<'r, 'c, 'h, I: Into<Input<'h>>>(\n        &'r self,\n        cache: &'c mut Cache,\n        input: I,\n    ) -> CapturesMatches<'r, 'c, 'h> {}\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {\n        self.set_earliest(yes);\n        self\n    }\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {}\n    #[inline]\n    pub fn start(&self) -> usize {}\n    #[inline]\n    pub fn end(&self) -> usize {}\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns true if and only if this `PikeVM` matches the given haystack.\n///\n/// This routine may short circuit if it knows that scanning future\n/// input will never lead to a different result. In particular, if the\n/// underlying NFA enters a match state, then this routine will return\n/// `true` immediately without inspecting any future input. (Consider how\n/// this might make a difference given the regex `a+` on the haystack\n/// `aaaaaaaaaaaaaaa`. This routine can stop after it sees the first `a`,\n/// but routines like `find` need to continue searching because `+` is\n/// greedy by default.)\n///\n/// # Example\n///\n/// This shows basic usage:\n///\n/// ```\n/// use regex_automata::nfa::thompson::pikevm::PikeVM;\n///\n/// let re = PikeVM::new(\"foo[0-9]+bar\")?;\n/// let mut cache = re.create_cache();\n///\n/// assert!(re.is_match(&mut cache, \"foo12345bar\"));\n/// assert!(!re.is_match(&mut cache, \"foobar\"));\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: consistency with search APIs\n///\n/// `is_match` is guaranteed to return `true` whenever `find` returns a\n/// match. This includes searches that are executed entirely within a\n/// codepoint:\n///\n/// ```\n/// use regex_automata::{nfa::thompson::pikevm::PikeVM, Input};\n///\n/// let re = PikeVM::new(\"a*\")?;\n/// let mut cache = re.create_cache();\n///\n/// assert!(!re.is_match(&mut cache, Input::new(\"☃\").span(1..2)));\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// Notice that when UTF-8 mode is disabled, then the above reports a\n/// match because the restriction against zero-width matches that split a\n/// codepoint has been lifted:\n///\n/// ```\n/// use regex_automata::{nfa::thompson::{pikevm::PikeVM, NFA}, Input};\n///\n/// let re = PikeVM::builder()\n///     .thompson(NFA::config().utf8(false))\n///     .build(\"a*\")?;\n/// let mut cache = re.create_cache();\n///\n/// assert!(re.is_match(&mut cache, Input::new(\"☃\").span(1..2)));\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n767 pub fn is_match<'h, I: Into<Input<'h>>>(\n768     &self,\n769     cache: &mut Cache,\n770     input: I,\n771 ) -> bool {\n772     let input = input.into().earliest(true);\n773     self.search_slots(cache, &input, &mut []).is_some()\n774 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}