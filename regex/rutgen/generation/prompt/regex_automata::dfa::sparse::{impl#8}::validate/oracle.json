{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\nstruct Transitions<T> {\n    /// The raw encoding of each state in this DFA.\n    ///\n    /// Each state has the following information:\n    ///\n    /// * A set of transitions to subsequent states. Transitions to the dead\n    ///   state are omitted.\n    /// * If the state can be accelerated, then any additional accelerator\n    ///   information.\n    /// * If the state is a match state, then the state contains all pattern\n    ///   IDs that match when in that state.\n    ///\n    /// To decode a state, use Transitions::state.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8].\n    sparse: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride and is documented above.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is\n    /// if the DFA's kind uses byte classes which is the default. Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    ///\n    /// N.B. Equivalence classes aren't particularly useful in a sparse DFA\n    /// in the current implementation, since equivalence classes generally tend\n    /// to correspond to continuous ranges of bytes that map to the same\n    /// transition. So in a sparse DFA, equivalence classes don't really lead\n    /// to a space savings. In the future, it would be good to try and remove\n    /// them from sparse DFAs entirely, but requires a bit of work since sparse\n    /// DFAs are built from dense DFAs, which are in turn built on top of\n    /// equivalence classes.\n    classes: ByteClasses,\n    /// The total number of states in this DFA. Note that a DFA always has at\n    /// least one state---the dead state---even the empty DFA. In particular,\n    /// the dead state always has ID 0 and is correspondingly always the first\n    /// state. The dead state is never a match state.\n    state_len: usize,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\n#[derive(Debug)]\nstruct Seen {\n    #[cfg(feature = \"alloc\")]\n    set: alloc::collections::BTreeSet<StateID>,\n    #[cfg(not(feature = \"alloc\"))]\n    set: core::marker::PhantomData<StateID>,\n}\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\nstruct StateIter<'a, T> {\n    trans: &'a Transitions<T>,\n    id: usize,\n}\nimpl<T: AsRef<[u8]>> Transitions<T> {\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n    fn validate(&self, sp: &Special) -> Result<Seen, DeserializeError> {\n        let mut verified = Seen::new();\n        let mut len = 0;\n        let mut id = DEAD;\n        while id.as_usize() < self.sparse().len() {\n            if sp.is_special_state(id) {\n                let is_actually_special = sp.is_dead_state(id) || sp.is_quit_state(id)\n                    || sp.is_match_state(id) || sp.is_start_state(id)\n                    || sp.is_accel_state(id);\n                if !is_actually_special {\n                    return Err(\n                        DeserializeError::generic(\n                            \"found sparse state tagged as special but \\\n                         wasn't actually special\",\n                        ),\n                    );\n                }\n            }\n            let state = self.try_state(sp, id)?;\n            verified.insert(id);\n            id = StateID::new(\n                    wire::add(\n                        id.as_usize(),\n                        state.write_to_len(),\n                        \"next state ID offset\",\n                    )?,\n                )\n                .map_err(|err| {\n                    DeserializeError::state_id_error(err, \"next state ID offset\")\n                })?;\n            len += 1;\n        }\n        for state in self.states() {\n            for i in 0..state.ntrans {\n                let to = state.next_at(i);\n                #[cfg(not(feature = \"alloc\"))]\n                {\n                    let _ = self.try_state(sp, to)?;\n                }\n                #[cfg(feature = \"alloc\")]\n                {\n                    if !verified.contains(&to) {\n                        return Err(\n                            DeserializeError::generic(\n                                \"found transition that points to a \\\n                             non-existent state\",\n                            ),\n                        );\n                    }\n                }\n            }\n        }\n        if len != self.state_len {\n            return Err(DeserializeError::generic(\"mismatching sparse state length\"));\n        }\n        Ok(verified)\n    }\n    fn as_ref(&self) -> Transitions<&'_ [u8]> {}\n    #[cfg(feature = \"alloc\")]\n    fn to_owned(&self) -> Transitions<alloc::vec::Vec<u8>> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn state(&self, id: StateID) -> State<'_> {}\n    fn try_state(\n        &self,\n        sp: &Special,\n        id: StateID,\n    ) -> Result<State<'_>, DeserializeError> {\n        if id.as_usize() > self.sparse().len() {\n            return Err(\n                DeserializeError::generic(\"invalid caller provided sparse state ID\"),\n            );\n        }\n        let mut state = &self.sparse()[id.as_usize()..];\n        let (mut ntrans, _) = wire::try_read_u16_as_usize(\n            state,\n            \"state transition length\",\n        )?;\n        let is_match = ((1 << 15) & ntrans) != 0;\n        ntrans &= !(1 << 15);\n        state = &state[2..];\n        if ntrans > 257 || ntrans == 0 {\n            return Err(DeserializeError::generic(\"invalid transition length\"));\n        }\n        if is_match && !sp.is_match_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"state marked as match but not in match ID range\",\n                ),\n            );\n        } else if !is_match && sp.is_match_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"state in match ID range but not marked as match state\",\n                ),\n            );\n        }\n        let input_ranges_len = ntrans.checked_mul(2).unwrap();\n        wire::check_slice_len(state, input_ranges_len, \"sparse byte pairs\")?;\n        let (input_ranges, state) = state.split_at(input_ranges_len);\n        for pair in input_ranges.chunks(2) {\n            let (start, end) = (pair[0], pair[1]);\n            if start > end {\n                return Err(DeserializeError::generic(\"invalid input range\"));\n            }\n        }\n        let next_len = ntrans\n            .checked_mul(self.id_len())\n            .expect(\"state size * #trans should always fit in a usize\");\n        wire::check_slice_len(state, next_len, \"sparse trans state IDs\")?;\n        let (next, state) = state.split_at(next_len);\n        for idbytes in next.chunks(self.id_len()) {\n            let (id, _) = wire::read_state_id(idbytes, \"sparse state ID in try_state\")?;\n            wire::check_slice_len(\n                self.sparse(),\n                id.as_usize(),\n                \"invalid sparse state ID\",\n            )?;\n        }\n        let (pattern_ids, state) = if is_match {\n            let (npats, nr) = wire::try_read_u32_as_usize(state, \"pattern ID length\")?;\n            let state = &state[nr..];\n            if npats == 0 {\n                return Err(\n                    DeserializeError::generic(\n                        \"state marked as a match, but pattern length is zero\",\n                    ),\n                );\n            }\n            let pattern_ids_len = wire::mul(npats, 4, \"sparse pattern ID byte length\")?;\n            wire::check_slice_len(state, pattern_ids_len, \"sparse pattern IDs\")?;\n            let (pattern_ids, state) = state.split_at(pattern_ids_len);\n            for patbytes in pattern_ids.chunks(PatternID::SIZE) {\n                wire::read_pattern_id(patbytes, \"sparse pattern ID in try_state\")?;\n            }\n            (pattern_ids, state)\n        } else {\n            (&[][..], state)\n        };\n        if is_match && pattern_ids.is_empty() {\n            return Err(\n                DeserializeError::generic(\n                    \"state marked as a match, but has no pattern IDs\",\n                ),\n            );\n        }\n        if sp.is_match_state(id) && pattern_ids.is_empty() {\n            return Err(\n                DeserializeError::generic(\n                    \"state marked special as a match, but has no pattern IDs\",\n                ),\n            );\n        }\n        if sp.is_match_state(id) != is_match {\n            return Err(\n                DeserializeError::generic(\n                    \"whether state is a match or not is inconsistent\",\n                ),\n            );\n        }\n        if state.is_empty() {\n            return Err(DeserializeError::generic(\"no accelerator length\"));\n        }\n        let (accel_len, state) = (usize::from(state[0]), &state[1..]);\n        if accel_len > 3 {\n            return Err(DeserializeError::generic(\"sparse invalid accelerator length\"));\n        } else if accel_len == 0 && sp.is_accel_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"got no accelerators in state, but in accelerator ID range\",\n                ),\n            );\n        } else if accel_len > 0 && !sp.is_accel_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"state in accelerator ID range, but has no accelerators\",\n                ),\n            );\n        }\n        wire::check_slice_len(state, accel_len, \"sparse corrupt accelerator length\")?;\n        let (accel, _) = (&state[..accel_len], &state[accel_len..]);\n        let state = State {\n            id,\n            is_match,\n            ntrans,\n            input_ranges,\n            next,\n            pattern_ids,\n            accel,\n        };\n        if sp.is_quit_state(state.next_at(state.ntrans - 1)) {\n            return Err(\n                DeserializeError::generic(\n                    \"state with EOI transition to quit state is illegal\",\n                ),\n            );\n        }\n        Ok(state)\n    }\n    fn states(&self) -> StateIter<'_, T> {\n        StateIter {\n            trans: self,\n            id: DEAD.as_usize(),\n        }\n    }\n    fn sparse(&self) -> &[u8] {\n        self.sparse.as_ref()\n    }\n    fn id_len(&self) -> usize {}\n    fn memory_usage(&self) -> usize {}\n}\nimpl Special {\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn new() -> Special {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {}\n    pub(crate) fn from_bytes(\n        mut slice: &[u8],\n    ) -> Result<(Special, usize), DeserializeError> {}\n    pub(crate) fn validate(&self) -> Result<(), DeserializeError> {}\n    pub(crate) fn validate_state_len(\n        &self,\n        len: usize,\n        stride2: usize,\n    ) -> Result<(), DeserializeError> {}\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_max(&mut self) {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_no_special_start_states(&mut self) {}\n    #[inline]\n    pub(crate) fn is_special_state(&self, id: StateID) -> bool {\n        id <= self.max\n    }\n    #[inline]\n    pub(crate) fn is_dead_state(&self, id: StateID) -> bool {\n        id == DEAD\n    }\n    #[inline]\n    pub(crate) fn is_quit_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.quit_id == id\n    }\n    #[inline]\n    pub(crate) fn is_match_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_match <= id && id <= self.max_match\n    }\n    #[inline]\n    pub(crate) fn is_accel_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_accel <= id && id <= self.max_accel\n    }\n    #[inline]\n    pub(crate) fn is_start_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_start <= id && id <= self.max_start\n    }\n    #[inline]\n    pub(crate) fn match_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn matches(&self) -> bool {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn accel_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn accels(&self) -> bool {}\n    #[inline]\n    pub(crate) fn starts(&self) -> bool {}\n}\n#[cfg(not(feature = \"alloc\"))]\nimpl Seen {\n    fn new() -> Seen {\n        Seen {\n            set: core::marker::PhantomData,\n        }\n    }\n    fn insert(&mut self, _id: StateID) {}\n    fn contains(&self, _id: &StateID) -> bool {\n        true\n    }\n}\nimpl DeserializeError {\n    pub(crate) fn generic(msg: &'static str) -> DeserializeError {\n        DeserializeError(DeserializeErrorKind::Generic {\n            msg,\n        })\n    }\n    pub(crate) fn buffer_too_small(what: &'static str) -> DeserializeError {}\n    fn invalid_usize(what: &'static str) -> DeserializeError {}\n    fn version_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn endian_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn alignment_mismatch(alignment: usize, address: usize) -> DeserializeError {}\n    fn label_mismatch(expected: &'static str) -> DeserializeError {}\n    fn arithmetic_overflow(what: &'static str) -> DeserializeError {}\n    fn pattern_id_error(err: PatternIDError, what: &'static str) -> DeserializeError {}\n    pub(crate) fn state_id_error(\n        err: StateIDError,\n        what: &'static str,\n    ) -> DeserializeError {}\n}\nimpl<'a> State<'a> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next(&self, input: u8) -> StateID {}\n    fn next_eoi(&self) -> StateID {}\n    fn id(&self) -> StateID {}\n    fn range(&self, i: usize) -> (u8, u8) {}\n    fn next_at(&self, i: usize) -> StateID {\n        let start = i * StateID::SIZE;\n        let end = start + StateID::SIZE;\n        let bytes = self.next[start..end].try_into().unwrap();\n        StateID::from_ne_bytes_unchecked(bytes)\n    }\n    fn pattern_id(&self, match_index: usize) -> PatternID {}\n    fn pattern_len(&self) -> usize {}\n    fn accelerator(&self) -> &'a [u8] {}\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {\n        let mut len = 2 + (self.ntrans * 2) + (self.ntrans * StateID::SIZE)\n            + (1 + self.accel.len());\n        if self.is_match {\n            len += size_of::<u32>() + self.pattern_ids.len();\n        }\n        len\n    }\n}\npub(crate) fn add(\n    a: usize,\n    b: usize,\n    what: &'static str,\n) -> Result<usize, DeserializeError> {\n    match a.checked_add(b) {\n        Some(c) => Ok(c),\n        None => Err(DeserializeError::arithmetic_overflow(what)),\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Validates that every state ID in this transition table is valid.\n///\n/// That is, every state ID can be used to correctly index a state in this\n/// table.\n1387 fn validate(&self, sp: &Special) -> Result<Seen, DeserializeError> {\n1388     let mut verified = Seen::new();\n1389     // We need to make sure that we decode the correct number of states.\n1390     // Otherwise, an empty set of transitions would validate even if the\n1391     // recorded state length is non-empty.\n1392     let mut len = 0;\n1393     // We can't use the self.states() iterator because it assumes the state\n1394     // encodings are valid. It could panic if they aren't.\n1395     let mut id = DEAD;\n1396     while id.as_usize() < self.sparse().len() {\n1397         // Before we even decode the state, we check that the ID itself\n1398         // is well formed. That is, if it's a special state then it must\n1399         // actually be a quit, dead, accel, match or start state.\n1400         if sp.is_special_state(id) {\n1401             let is_actually_special = sp.is_dead_state(id)\n1402                 || sp.is_quit_state(id)\n1403                 || sp.is_match_state(id)\n1404                 || sp.is_start_state(id)\n1405                 || sp.is_accel_state(id);\n1406             if !is_actually_special {\n1407                 // This is kind of a cryptic error message...\n1408                 return Err(DeserializeError::generic(\n1409                     \"found sparse state tagged as special but \\\n1410                      wasn't actually special\",\n1411                 ));\n1412             }\n1413         }\n1414         let state = self.try_state(sp, id)?;\n1415         verified.insert(id);\n1416         // The next ID should be the offset immediately following `state`.\n1417         id = StateID::new(wire::add(\n1418             id.as_usize(),\n1419             state.write_to_len(),\n1420             \"next state ID offset\",\n1421         )?)\n1422         .map_err(|err| {\n1423             DeserializeError::state_id_error(err, \"next state ID offset\")\n1424         })?;\n1425         len += 1;\n1426     }\n1427     // Now that we've checked that all top-level states are correct and\n1428     // importantly, collected a set of valid state IDs, we have all the\n1429     // information we need to check that all transitions are correct too.\n1430     //\n1431     // Note that we can't use `valid_ids` to iterate because it will\n1432     // be empty in no-std no-alloc contexts. (And yes, that means our\n1433     // verification isn't quite as good.) We can use `self.states()`\n1434     // though at least, since we know that all states can at least be\n1435     // decoded and traversed correctly.\n1436     for state in self.states() {\n1437         // Check that all transitions in this state are correct.\n1438         for i in 0..state.ntrans {\n1439             let to = state.next_at(i);\n1440             // For no-alloc, we just check that the state can decode. It is\n1441             // technically possible that the state ID could still point to\n1442             // a non-existent state even if it decodes (fuzzing proved this\n1443             // to be true), but it shouldn't result in any memory unsafety\n1444             // or panics in non-debug mode.\n1445             #[cfg(not(feature = \"alloc\"))]\n1446             {\n1447                 let _ = self.try_state(sp, to)?;\n1448             }\n1449             #[cfg(feature = \"alloc\")]\n1450             {\n1451                 if !verified.contains(&to) {\n1452                     return Err(DeserializeError::generic(\n1453                         \"found transition that points to a \\\n1454                          non-existent state\",\n1455                     ));\n1456                 }\n1457             }\n1458         }\n1459     }\n1460     if len != self.state_len {\n1461         return Err(DeserializeError::generic(\n1462             \"mismatching sparse state length\",\n1463         ));\n1464     }\n1465     Ok(verified)\n1466 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}