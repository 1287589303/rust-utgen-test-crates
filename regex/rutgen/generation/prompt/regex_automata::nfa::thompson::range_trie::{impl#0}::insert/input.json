{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/range_trie.rs\n// crate name is regex_automata\nuse core::{cell::RefCell, fmt, mem, ops::RangeInclusive};\nuse alloc::{format, string::String, vec, vec::Vec};\nuse regex_syntax::utf8::Utf8Range;\nuse crate::util::primitives::StateID;\nconst FINAL: StateID = StateID::ZERO;\nconst ROOT: StateID = StateID::new_unchecked(1);\n#[derive(Clone)]\npub struct RangeTrie {\n    /// The states in this trie. The first is always the shared final state.\n    /// The second is always the root state. Otherwise, there is no\n    /// particular order.\n    states: Vec<State>,\n    /// A free-list of states. When a range trie is cleared, all of its states\n    /// are added to this list. Creating a new state reuses states from this\n    /// list before allocating a new one.\n    free: Vec<State>,\n    /// A stack for traversing this trie to yield sequences of byte ranges in\n    /// lexicographic order.\n    iter_stack: RefCell<Vec<NextIter>>,\n    /// A buffer that stores the current sequence during iteration.\n    iter_ranges: RefCell<Vec<Utf8Range>>,\n    /// A stack used for traversing the trie in order to (deeply) duplicate\n    /// a state. States are recursively duplicated when ranges are split.\n    dupe_stack: Vec<NextDupe>,\n    /// A stack used for traversing the trie during insertion of a new\n    /// sequence of byte ranges.\n    insert_stack: Vec<NextInsert>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Split {\n    partitions: [SplitRange; 3],\n    len: usize,\n}\n#[derive(Clone, Debug)]\nstruct NextInsert {\n    /// The next state to begin inserting ranges. This state should be the\n    /// state at which `ranges[0]` should be inserted.\n    state_id: StateID,\n    /// The ranges to insert. We used a fixed-size array here to avoid an\n    /// allocation.\n    ranges: [Utf8Range; 4],\n    /// The number of valid ranges in the above array.\n    len: u8,\n}\n#[derive(Clone)]\nstruct State {\n    /// A sorted sequence of non-overlapping transitions to other states. Each\n    /// transition corresponds to a single range of bytes.\n    transitions: Vec<Transition>,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Default)]\nstruct State {\n    transitions: Vec<Transition>,\n    chunks: Vec<(usize, usize)>,\n}\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub(crate) struct State(Arc<[u8]>);\n#[derive(Clone, Debug)]\nstruct NextDupe {\n    /// The state we want to duplicate.\n    old_id: StateID,\n    /// The ID of the new state that is a duplicate of old_id.\n    new_id: StateID,\n}\n#[derive(Clone)]\nstruct Transition {\n    /// The byte range.\n    range: Utf8Range,\n    /// The next state to transition to.\n    next_id: StateID,\n}\n#[derive(Clone, Debug)]\nstruct NextIter {\n    state_id: StateID,\n    tidx: usize,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\nenum SplitRange {\n    Old(Utf8Range),\n    New(Utf8Range),\n    Both(Utf8Range),\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum State {\n    /// An empty state whose only purpose is to forward the automaton to\n    /// another state via an unconditional epsilon transition.\n    ///\n    /// Unconditional epsilon transitions are quite useful during the\n    /// construction of an NFA, as they permit the insertion of no-op\n    /// placeholders that make it easier to compose NFA sub-graphs. When\n    /// the Thompson NFA builder produces a final NFA, all unconditional\n    /// epsilon transitions are removed, and state identifiers are remapped\n    /// accordingly.\n    Empty {\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// A state that only transitions to another state if the current input\n    /// byte is in a particular range of bytes.\n    ByteRange { trans: Transition },\n    /// A state with possibly many transitions, represented in a sparse\n    /// fashion. Transitions must be ordered lexicographically by input range\n    /// and be non-overlapping. As such, this may only be used when every\n    /// transition has equal priority. (In practice, this is only used for\n    /// encoding large UTF-8 automata.) In contrast, a `Union` state has each\n    /// alternate in order of priority. Priority is used to implement greedy\n    /// matching and also alternations themselves, e.g., `abc|a` where `abc`\n    /// has priority over `a`.\n    ///\n    /// To clarify, it is possible to remove `Sparse` and represent all things\n    /// that `Sparse` is used for via `Union`. But this creates a more bloated\n    /// NFA with more epsilon transitions than is necessary in the special case\n    /// of character classes.\n    Sparse { transitions: Vec<Transition> },\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around.\n    Look { look: Look, next: StateID },\n    /// An empty state that records the start of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureStart {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An empty state that records the end of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureEnd {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union { alternates: Vec<StateID> },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via later transitions are\n    /// preferred over earlier transitions.\n    ///\n    /// This \"reverse\" state exists for convenience during compilation that\n    /// permits easy construction of non-greedy combinations of NFA states. At\n    /// the end of compilation, Union and UnionReverse states are merged into\n    /// one Union type of state, where the latter has its epsilon transitions\n    /// reversed to reflect the priority inversion.\n    ///\n    /// The \"convenience\" here arises from the fact that as new states are\n    /// added to the list of `alternates`, we would like that add operation\n    /// to be amortized constant time. But if we used a `Union`, we'd need to\n    /// prepend the state, which takes O(n) time. There are other approaches we\n    /// could use to solve this, but this seems simple enough.\n    UnionReverse { alternates: Vec<StateID> },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose a\n    /// `Fail` state to represent it.\n    Fail,\n    /// A match state. There is at most one such occurrence of this state in\n    /// an NFA for each pattern compiled into the NFA. At time of writing, a\n    /// match state is always produced for every pattern given, but in theory,\n    /// if a pattern can never lead to a match, then the match state could be\n    /// omitted.\n    ///\n    /// `pattern_id` refers to the ID of the pattern itself, which corresponds\n    /// to the pattern's index (starting at 0).\n    Match { pattern_id: PatternID },\n}\nimpl RangeTrie {\n    pub fn new() -> RangeTrie {}\n    pub fn clear(&mut self) {}\n    pub fn iter<E, F: FnMut(&[Utf8Range]) -> Result<(), E>>(\n        &self,\n        mut f: F,\n    ) -> Result<(), E> {}\n    pub fn insert(&mut self, ranges: &[Utf8Range]) {\n        assert!(! ranges.is_empty());\n        assert!(ranges.len() <= 4);\n        let mut stack = mem::replace(&mut self.insert_stack, vec![]);\n        stack.clear();\n        stack.push(NextInsert::new(ROOT, ranges));\n        while let Some(next) = stack.pop() {\n            let (state_id, ranges) = (next.state_id(), next.ranges());\n            assert!(! ranges.is_empty());\n            let (mut new, rest) = (ranges[0], &ranges[1..]);\n            let mut i = self.state(state_id).find(new);\n            if i == self.state(state_id).transitions.len() {\n                let next_id = NextInsert::push(self, &mut stack, rest);\n                self.add_transition(state_id, new, next_id);\n                continue;\n            }\n            'OUTER: loop {\n                let old = self.state(state_id).transitions[i].clone();\n                let split = match Split::new(old.range, new) {\n                    Some(split) => split,\n                    None => {\n                        let next_id = NextInsert::push(self, &mut stack, rest);\n                        self.add_transition_at(i, state_id, new, next_id);\n                        continue;\n                    }\n                };\n                let splits = split.as_slice();\n                if splits.len() == 1 {\n                    if !rest.is_empty() {\n                        stack.push(NextInsert::new(old.next_id, rest));\n                    }\n                    break;\n                }\n                let mut first = true;\n                let mut add_trans = |trie: &mut RangeTrie, pos, from, range, to| {\n                    if first {\n                        trie.set_transition_at(pos, from, range, to);\n                        first = false;\n                    } else {\n                        trie.add_transition_at(pos, from, range, to);\n                    }\n                };\n                for (j, &srange) in splits.iter().enumerate() {\n                    match srange {\n                        SplitRange::Old(r) => {\n                            let dup_id = self.duplicate(old.next_id);\n                            add_trans(self, i, state_id, r, dup_id);\n                        }\n                        SplitRange::New(r) => {\n                            {\n                                let trans = &self.state(state_id).transitions;\n                                if j + 1 == splits.len() && i < trans.len()\n                                    && intersects(r, trans[i].range)\n                                {\n                                    new = r;\n                                    continue 'OUTER;\n                                }\n                            }\n                            let next_id = NextInsert::push(self, &mut stack, rest);\n                            add_trans(self, i, state_id, r, next_id);\n                        }\n                        SplitRange::Both(r) => {\n                            if !rest.is_empty() {\n                                stack.push(NextInsert::new(old.next_id, rest));\n                            }\n                            add_trans(self, i, state_id, r, old.next_id);\n                        }\n                    }\n                    i += 1;\n                }\n                break;\n            }\n        }\n        self.insert_stack = stack;\n    }\n    pub fn add_empty(&mut self) -> StateID {}\n    fn duplicate(&mut self, old_id: StateID) -> StateID {\n        if old_id == FINAL {\n            return FINAL;\n        }\n        let mut stack = mem::replace(&mut self.dupe_stack, vec![]);\n        stack.clear();\n        let new_id = self.add_empty();\n        stack.push(NextDupe { old_id, new_id });\n        while let Some(NextDupe { old_id, new_id }) = stack.pop() {\n            for i in 0..self.state(old_id).transitions.len() {\n                let t = self.state(old_id).transitions[i].clone();\n                if t.next_id == FINAL {\n                    self.add_transition(new_id, t.range, FINAL);\n                    continue;\n                }\n                let new_child_id = self.add_empty();\n                self.add_transition(new_id, t.range, new_child_id);\n                stack\n                    .push(NextDupe {\n                        old_id: t.next_id,\n                        new_id: new_child_id,\n                    });\n            }\n        }\n        self.dupe_stack = stack;\n        new_id\n    }\n    fn add_transition(&mut self, from_id: StateID, range: Utf8Range, next_id: StateID) {\n        self.state_mut(from_id).transitions.push(Transition { range, next_id });\n    }\n    fn add_transition_at(\n        &mut self,\n        i: usize,\n        from_id: StateID,\n        range: Utf8Range,\n        next_id: StateID,\n    ) {\n        self.state_mut(from_id).transitions.insert(i, Transition { range, next_id });\n    }\n    fn set_transition_at(\n        &mut self,\n        i: usize,\n        from_id: StateID,\n        range: Utf8Range,\n        next_id: StateID,\n    ) {}\n    fn state(&self, id: StateID) -> &State {\n        &self.states[id]\n    }\n    fn state_mut(&mut self, id: StateID) -> &mut State {}\n}\nimpl Split {\n    fn new(o: Utf8Range, n: Utf8Range) -> Option<Split> {\n        let range = |r: RangeInclusive<u8>| Utf8Range {\n            start: *r.start(),\n            end: *r.end(),\n        };\n        let old = |r| SplitRange::Old(range(r));\n        let new = |r| SplitRange::New(range(r));\n        let both = |r| SplitRange::Both(range(r));\n        let (a, b, x, y) = (o.start, o.end, n.start, n.end);\n        if b < x || y < a {\n            None\n        } else if a == x && b == y {\n            Some(Split::parts1(both(a..=b)))\n        } else if a == x && b < y {\n            Some(Split::parts2(both(a..=b), new(b + 1..=y)))\n        } else if b == y && a > x {\n            Some(Split::parts2(new(x..=a - 1), both(a..=b)))\n        } else if x == a && y < b {\n            Some(Split::parts2(both(x..=y), old(y + 1..=b)))\n        } else if y == b && x > a {\n            Some(Split::parts2(old(a..=x - 1), both(x..=y)))\n        } else if a > x && b < y {\n            Some(Split::parts3(new(x..=a - 1), both(a..=b), new(b + 1..=y)))\n        } else if x > a && y < b {\n            Some(Split::parts3(old(a..=x - 1), both(x..=y), old(y + 1..=b)))\n        } else if b == x && a < y {\n            Some(Split::parts3(old(a..=b - 1), both(b..=b), new(b + 1..=y)))\n        } else if y == a && x < b {\n            Some(Split::parts3(new(x..=y - 1), both(y..=y), old(y + 1..=b)))\n        } else if b > x && b < y {\n            Some(Split::parts3(old(a..=x - 1), both(x..=b), new(b + 1..=y)))\n        } else if y > a && y < b {\n            Some(Split::parts3(new(x..=a - 1), both(a..=y), old(y + 1..=b)))\n        } else {\n            unreachable!()\n        }\n    }\n    fn parts1(r1: SplitRange) -> Split {}\n    fn parts2(r1: SplitRange, r2: SplitRange) -> Split {}\n    fn parts3(r1: SplitRange, r2: SplitRange, r3: SplitRange) -> Split {}\n    fn as_slice(&self) -> &[SplitRange] {\n        &self.partitions[..self.len]\n    }\n}\nimpl NextInsert {\n    fn new(state_id: StateID, ranges: &[Utf8Range]) -> NextInsert {\n        let len = ranges.len();\n        assert!(len > 0);\n        assert!(len <= 4);\n        let mut tmp = [Utf8Range { start: 0, end: 0 }; 4];\n        tmp[..len].copy_from_slice(ranges);\n        NextInsert {\n            state_id,\n            ranges: tmp,\n            len: u8::try_from(len).unwrap(),\n        }\n    }\n    fn push(\n        trie: &mut RangeTrie,\n        stack: &mut Vec<NextInsert>,\n        ranges: &[Utf8Range],\n    ) -> StateID {\n        if ranges.is_empty() {\n            FINAL\n        } else {\n            let next_id = trie.add_empty();\n            stack.push(NextInsert::new(next_id, ranges));\n            next_id\n        }\n    }\n    fn state_id(&self) -> StateID {\n        self.state_id\n    }\n    fn ranges(&self) -> &[Utf8Range] {\n        &self.ranges[..usize::try_from(self.len).unwrap()]\n    }\n}\nimpl State {\n    fn find(&self, range: Utf8Range) -> usize {\n        /// Returns the position `i` at which `pred(xs[i])` first returns true\n        /// such that for all `j >= i`, `pred(xs[j]) == true`. If `pred` never\n        /// returns true, then `xs.len()` is returned.\n        ///\n        /// We roll our own binary search because it doesn't seem like the\n        /// standard library's binary search can be used here. Namely, if\n        /// there is an overlapping range, then we want to find the first such\n        /// occurrence, but there may be many. Or at least, it's not quite\n        /// clear to me how to do it.\n        fn binary_search<T, F>(xs: &[T], mut pred: F) -> usize\n        where\n            F: FnMut(&T) -> bool,\n        {\n            let (mut left, mut right) = (0, xs.len());\n            while left < right {\n                let mid = (left + right) / 2;\n                if pred(&xs[mid]) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            left\n        }\n        binary_search(&self.transitions, |t| range.start <= t.range.end)\n    }\n    fn clear(&mut self) {}\n}\nfn intersects(r1: Utf8Range, r2: Utf8Range) -> bool {\n    !(r1.end < r2.start || r2.end < r1.start)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Inserts a new sequence of ranges into this trie.\n///\n/// The sequence given must be non-empty and must not have a length\n/// exceeding 4.\n295 pub fn insert(&mut self, ranges: &[Utf8Range]) {\n296     assert!(!ranges.is_empty());\n297     assert!(ranges.len() <= 4);\n298 \n299     let mut stack = mem::replace(&mut self.insert_stack, vec![]);\n300     stack.clear();\n301 \n302     stack.push(NextInsert::new(ROOT, ranges));\n303     while let Some(next) = stack.pop() {\n304         let (state_id, ranges) = (next.state_id(), next.ranges());\n305         assert!(!ranges.is_empty());\n306 \n307         let (mut new, rest) = (ranges[0], &ranges[1..]);\n308 \n309         // i corresponds to the position of the existing transition on\n310         // which we are operating. Typically, the result is to remove the\n311         // transition and replace it with two or more new transitions\n312         // corresponding to the partitions generated by splitting the\n313         // 'new' with the ith transition's range.\n314         let mut i = self.state(state_id).find(new);\n315 \n316         // In this case, there is no overlap *and* the new range is greater\n317         // than all existing ranges. So we can just add it to the end.\n318         if i == self.state(state_id).transitions.len() {\n319             let next_id = NextInsert::push(self, &mut stack, rest);\n320             self.add_transition(state_id, new, next_id);\n321             continue;\n322         }\n323 \n324         // The need for this loop is a bit subtle, buf basically, after\n325         // we've handled the partitions from our initial split, it's\n326         // possible that there will be a partition leftover that overlaps\n327         // with a subsequent transition. If so, then we have to repeat\n328         // the split process again with the leftovers and that subsequent\n329         // transition.\n330         'OUTER: loop {\n331             let old = self.state(state_id).transitions[i].clone();\n332             let split = match Split::new(old.range, new) {\n333                 Some(split) => split,\n334                 None => {\n335                     let next_id = NextInsert::push(self, &mut stack, rest);\n336                     self.add_transition_at(i, state_id, new, next_id);\n337                     continue;\n338                 }\n339             };\n340             let splits = split.as_slice();\n341             // If we only have one partition, then the ranges must be\n342             // equivalent. There's nothing to do here for this state, so\n343             // just move on to the next one.\n344             if splits.len() == 1 {\n345                 // ... but only if we have anything left to do.\n346                 if !rest.is_empty() {\n347                     stack.push(NextInsert::new(old.next_id, rest));\n348                 }\n349                 break;\n350             }\n351             // At this point, we know that 'split' is non-empty and there\n352             // must be some overlap AND that the two ranges are not\n353             // equivalent. Therefore, the existing range MUST be removed\n354             // and split up somehow. Instead of actually doing the removal\n355             // and then a subsequent insertion---with all the memory\n356             // shuffling that entails---we simply overwrite the transition\n357             // at position `i` for the first new transition we want to\n358             // insert. After that, we're forced to do expensive inserts.\n359             let mut first = true;\n360             let mut add_trans =\n361                 |trie: &mut RangeTrie, pos, from, range, to| {\n362                     if first {\n363                         trie.set_transition_at(pos, from, range, to);\n364                         first = false;\n365                     } else {\n366                         trie.add_transition_at(pos, from, range, to);\n367                     }\n368                 };\n369             for (j, &srange) in splits.iter().enumerate() {\n370                 match srange {\n371                     SplitRange::Old(r) => {\n372                         // Deep clone the state pointed to by the ith\n373                         // transition. This is always necessary since 'old'\n374                         // is always coupled with at least a 'both'\n375                         // partition. We don't want any new changes made\n376                         // via the 'both' partition to impact the part of\n377                         // the transition that doesn't overlap with the\n378                         // new range.\n379                         let dup_id = self.duplicate(old.next_id);\n380                         add_trans(self, i, state_id, r, dup_id);\n381                     }\n382                     SplitRange::New(r) => {\n383                         // This is a bit subtle, but if this happens to be\n384                         // the last partition in our split, it is possible\n385                         // that this overlaps with a subsequent transition.\n386                         // If it does, then we must repeat the whole\n387                         // splitting process over again with `r` and the\n388                         // subsequent transition.\n389                         {\n390                             let trans = &self.state(state_id).transitions;\n391                             if j + 1 == splits.len()\n392                                 && i < trans.len()\n393                                 && intersects(r, trans[i].range)\n394                             {\n395                                 new = r;\n396                                 continue 'OUTER;\n397                             }\n398                         }\n399 \n400                         // ... otherwise, setup exploration for a new\n401                         // empty state and add a brand new transition for\n402                         // this new range.\n403                         let next_id =\n404                             NextInsert::push(self, &mut stack, rest);\n405                         add_trans(self, i, state_id, r, next_id);\n406                     }\n407                     SplitRange::Both(r) => {\n408                         // Continue adding the remaining ranges on this\n409                         // path and update the transition with the new\n410                         // range.\n411                         if !rest.is_empty() {\n412                             stack.push(NextInsert::new(old.next_id, rest));\n413                         }\n414                         add_trans(self, i, state_id, r, old.next_id);\n415                     }\n416                 }\n417                 i += 1;\n418             }\n419             // If we've reached this point, then we know that there are\n420             // no subsequent transitions with any overlap. Therefore, we\n421             // can stop processing this range and move on to the next one.\n422             break;\n423         }\n424     }\n425     self.insert_stack = stack;\n426 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}