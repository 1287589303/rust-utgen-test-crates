{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/dense.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\npub(crate) type OwnedDFA = DFA<alloc::vec::Vec<u32>>;\n#[cfg(feature = \"dfa-build\")]\nuse core::cmp;\nuse core::{fmt, iter, mem::size_of, slice};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{\n    collections::{BTreeMap, BTreeSet},\n    vec, vec::Vec,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::{\n    dfa::{accel::Accel, determinize, minimize::Minimizer, remapper::Remapper, sparse},\n    nfa::thompson, util::{look::LookMatcher, search::MatchKind},\n};\nuse crate::{\n    dfa::{\n        accel::Accels, automaton::{fmt_state_indicator, Automaton, StartError},\n        special::Special, start::StartKind, DEAD,\n    },\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        int::{Pointer, Usize},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-dense\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\npub(crate) struct TransitionTable<T> {\n    /// A contiguous region of memory representing the transition table in\n    /// row-major order. The representation is dense. That is, every state\n    /// has precisely the same number of transitions. The maximum number of\n    /// transitions per state is 257 (256 for each possible byte value, plus 1\n    /// for the special EOI transition). If a DFA has been instructed to use\n    /// byte classes (the default), then the number of transitions is usually\n    /// substantially fewer.\n    ///\n    /// In practice, T is either `Vec<u32>` or `&[u32]`.\n    table: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is if\n    /// the DFA's kind uses byte classes (which is the default). Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    classes: ByteClasses,\n    /// The stride of each DFA state, expressed as a power-of-two exponent.\n    ///\n    /// The stride of a DFA corresponds to the total amount of space used by\n    /// each DFA state in the transition table. This may be bigger than the\n    /// size of a DFA's alphabet, since the stride is always the smallest\n    /// power of two greater than or equal to the alphabet size.\n    ///\n    /// While this wastes space, this avoids the need for integer division\n    /// to convert between premultiplied state IDs and their corresponding\n    /// indices. Instead, we can use simple bit-shifts.\n    ///\n    /// See the docs for the `stride2` method for more details.\n    ///\n    /// The minimum `stride2` value is `1` (corresponding to a stride of `2`)\n    /// while the maximum `stride2` value is `9` (corresponding to a stride of\n    /// `512`). The maximum is not `8` since the maximum alphabet size is `257`\n    /// when accounting for the special EOI transition. However, an alphabet\n    /// length of that size is exceptionally rare since the alphabet is shrunk\n    /// into equivalence classes.\n    stride2: usize,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Clone)]\npub struct DFA<T> {\n    /// The transition table for this DFA. This includes the transitions\n    /// themselves, along with the stride, number of states and the equivalence\n    /// class mapping.\n    tt: TransitionTable<T>,\n    /// The set of starting state identifiers for this DFA. The starting state\n    /// IDs act as pointers into the transition table. The specific starting\n    /// state chosen for each search is dependent on the context at which the\n    /// search begins.\n    st: StartTable<T>,\n    /// The set of match states and the patterns that match for each\n    /// corresponding match state.\n    ///\n    /// This structure is technically only needed because of support for\n    /// multi-regexes. Namely, multi-regexes require answering not just whether\n    /// a match exists, but _which_ patterns match. So we need to store the\n    /// matching pattern IDs for each match state. We do this even when there\n    /// is only one pattern for the sake of simplicity. In practice, this uses\n    /// up very little space for the case of one pattern.\n    ms: MatchStates<T>,\n    /// Information about which states are \"special.\" Special states are states\n    /// that are dead, quit, matching, starting or accelerated. For more info,\n    /// see the docs for `Special`.\n    special: Special,\n    /// The accelerators for this DFA.\n    ///\n    /// If a state is accelerated, then there exist only a small number of\n    /// bytes that can cause the DFA to leave the state. This permits searching\n    /// to use optimized routines to find those specific bytes instead of using\n    /// the transition table.\n    ///\n    /// All accelerated states exist in a contiguous range in the DFA's\n    /// transition table. See dfa/special.rs for more details on how states are\n    /// arranged.\n    accels: Accels<T>,\n    /// Any prefilter attached to this DFA.\n    ///\n    /// Note that currently prefilters are not serialized. When deserializing\n    /// a DFA from bytes, this is always set to `None`.\n    pre: Option<Prefilter>,\n    /// The set of \"quit\" bytes for this DFA.\n    ///\n    /// This is only used when computing the start state for a particular\n    /// position in a haystack. Namely, in the case where there is a quit\n    /// byte immediately before the start of the search, this set needs to be\n    /// explicitly consulted. In all other cases, quit bytes are detected by\n    /// the DFA itself, by transitioning all quit bytes to a special \"quit\n    /// state.\"\n    quitset: ByteSet,\n    /// Various flags describing the behavior of this DFA.\n    flags: Flags,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\npub(crate) struct StateIter<'a, T> {\n    tt: &'a TransitionTable<T>,\n    it: iter::Enumerate<slice::Chunks<'a, StateID>>,\n}\n#[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]\npub struct Unit(UnitKind);\n#[derive(Debug)]\npub(crate) struct StateTransitionIter<'a> {\n    len: usize,\n    it: iter::Enumerate<slice::Iter<'a, StateID>>,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\nimpl<T: AsRef<[u32]>> TransitionTable<T> {\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError> {\n        let sp = &dfa.special;\n        for state in self.states() {\n            if sp.is_special_state(state.id()) {\n                let is_actually_special = sp.is_dead_state(state.id())\n                    || sp.is_quit_state(state.id()) || sp.is_match_state(state.id())\n                    || sp.is_start_state(state.id()) || sp.is_accel_state(state.id());\n                if !is_actually_special {\n                    return Err(\n                        DeserializeError::generic(\n                            \"found dense state tagged as special but \\\n                         wasn't actually special\",\n                        ),\n                    );\n                }\n                if sp.is_match_state(state.id()) && dfa.match_len(state.id()) == 0 {\n                    return Err(\n                        DeserializeError::generic(\n                            \"found match state with zero pattern IDs\",\n                        ),\n                    );\n                }\n            }\n            for (_, to) in state.transitions() {\n                if !self.is_valid(to) {\n                    return Err(\n                        DeserializeError::generic(\n                            \"found invalid state ID in transition table\",\n                        ),\n                    );\n                }\n            }\n        }\n        Ok(())\n    }\n    fn as_ref(&self) -> TransitionTable<&'_ [u32]> {}\n    #[cfg(feature = \"alloc\")]\n    fn to_owned(&self) -> TransitionTable<alloc::vec::Vec<u32>> {}\n    fn state(&self, id: StateID) -> State<'_> {}\n    fn states(&self) -> StateIter<'_, T> {\n        StateIter {\n            tt: self,\n            it: self.table().chunks(self.stride()).enumerate(),\n        }\n    }\n    fn to_index(&self, id: StateID) -> usize {}\n    fn to_state_id(&self, index: usize) -> StateID {}\n    #[cfg(feature = \"dfa-build\")]\n    fn next_state_id(&self, id: StateID) -> StateID {}\n    #[cfg(feature = \"dfa-build\")]\n    fn prev_state_id(&self, id: StateID) -> StateID {}\n    fn table(&self) -> &[StateID] {}\n    fn len(&self) -> usize {}\n    fn stride(&self) -> usize {}\n    fn alphabet_len(&self) -> usize {}\n    fn is_valid(&self, id: StateID) -> bool {\n        let id = id.as_usize();\n        id < self.table().len() && id % self.stride() == 0\n    }\n    fn memory_usage(&self) -> usize {}\n}\nimpl Special {\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn new() -> Special {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {}\n    pub(crate) fn from_bytes(\n        mut slice: &[u8],\n    ) -> Result<(Special, usize), DeserializeError> {}\n    pub(crate) fn validate(&self) -> Result<(), DeserializeError> {}\n    pub(crate) fn validate_state_len(\n        &self,\n        len: usize,\n        stride2: usize,\n    ) -> Result<(), DeserializeError> {}\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_max(&mut self) {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_no_special_start_states(&mut self) {}\n    #[inline]\n    pub(crate) fn is_special_state(&self, id: StateID) -> bool {\n        id <= self.max\n    }\n    #[inline]\n    pub(crate) fn is_dead_state(&self, id: StateID) -> bool {\n        id == DEAD\n    }\n    #[inline]\n    pub(crate) fn is_quit_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.quit_id == id\n    }\n    #[inline]\n    pub(crate) fn is_match_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_match <= id && id <= self.max_match\n    }\n    #[inline]\n    pub(crate) fn is_accel_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_accel <= id && id <= self.max_accel\n    }\n    #[inline]\n    pub(crate) fn is_start_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_start <= id && id <= self.max_start\n    }\n    #[inline]\n    pub(crate) fn match_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn matches(&self) -> bool {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn accel_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn accels(&self) -> bool {}\n    #[inline]\n    pub(crate) fn starts(&self) -> bool {}\n}\nimpl DeserializeError {\n    pub(crate) fn generic(msg: &'static str) -> DeserializeError {\n        DeserializeError(DeserializeErrorKind::Generic {\n            msg,\n        })\n    }\n    pub(crate) fn buffer_too_small(what: &'static str) -> DeserializeError {}\n    fn invalid_usize(what: &'static str) -> DeserializeError {}\n    fn version_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn endian_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn alignment_mismatch(alignment: usize, address: usize) -> DeserializeError {}\n    fn label_mismatch(expected: &'static str) -> DeserializeError {}\n    fn arithmetic_overflow(what: &'static str) -> DeserializeError {}\n    fn pattern_id_error(err: PatternIDError, what: &'static str) -> DeserializeError {}\n    pub(crate) fn state_id_error(\n        err: StateIDError,\n        what: &'static str,\n    ) -> DeserializeError {}\n}\nimpl<'a> State<'a> {\n    pub(crate) fn transitions(&self) -> StateTransitionIter<'_> {\n        StateTransitionIter {\n            len: self.transitions.len(),\n            it: self.transitions.iter().enumerate(),\n        }\n    }\n    pub(crate) fn sparse_transitions(&self) -> StateSparseTransitionIter<'_> {}\n    pub(crate) fn id(&self) -> StateID {\n        self.id\n    }\n    #[cfg(feature = \"dfa-build\")]\n    fn accelerate(&self, classes: &ByteClasses) -> Option<Accel> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Validates that every state ID in this transition table is valid.\n///\n/// That is, every state ID can be used to correctly index a state in this\n/// table.\n3596 fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError> {\n3597     let sp = &dfa.special;\n3598     for state in self.states() {\n3599         // We check that the ID itself is well formed. That is, if it's\n3600         // a special state then it must actually be a quit, dead, accel,\n3601         // match or start state.\n3602         if sp.is_special_state(state.id()) {\n3603             let is_actually_special = sp.is_dead_state(state.id())\n3604                 || sp.is_quit_state(state.id())\n3605                 || sp.is_match_state(state.id())\n3606                 || sp.is_start_state(state.id())\n3607                 || sp.is_accel_state(state.id());\n3608             if !is_actually_special {\n3609                 // This is kind of a cryptic error message...\n3610                 return Err(DeserializeError::generic(\n3611                     \"found dense state tagged as special but \\\n3612                      wasn't actually special\",\n3613                 ));\n3614             }\n3615             if sp.is_match_state(state.id())\n3616                 && dfa.match_len(state.id()) == 0\n3617             {\n3618                 return Err(DeserializeError::generic(\n3619                     \"found match state with zero pattern IDs\",\n3620                 ));\n3621             }\n3622         }\n3623         for (_, to) in state.transitions() {\n3624             if !self.is_valid(to) {\n3625                 return Err(DeserializeError::generic(\n3626                     \"found invalid state ID in transition table\",\n3627                 ));\n3628             }\n3629         }\n3630     }\n3631     Ok(())\n3632 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}