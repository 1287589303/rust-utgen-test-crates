{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/regex.rs\n// crate name is regex_automata\ntype CachePool = Pool<Cache, CachePoolFn>;\ntype CachePoolGuard<'a> = PoolGuard<'a, Cache, CachePoolFn>;\ntype CachePoolFn = Box<dyn Fn() -> Cache + Send + Sync + UnwindSafe + RefUnwindSafe>;\nuse core::{borrow::Borrow, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::{boxed::Box, sync::Arc, vec, vec::Vec};\nuse regex_syntax::{ast, hir::{self, Hir}};\nuse crate::{\n    meta::{\n        error::BuildError, strategy::{self, Strategy},\n        wrappers,\n    },\n    nfa::thompson::WhichCaptures,\n    util::{\n        captures::{Captures, GroupInfo},\n        iter, pool::{Pool, PoolGuard},\n        prefilter::Prefilter, primitives::{NonMaxUsize, PatternID},\n        search::{HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n    },\n};\n#[derive(Debug)]\npub struct Regex {\n    /// The actual regex implementation.\n    imp: Arc<RegexI>,\n    /// A thread safe pool of caches.\n    ///\n    /// For the higher level search APIs, a `Cache` is automatically plucked\n    /// from this pool before running a search. The lower level `with` methods\n    /// permit the caller to provide their own cache, thereby bypassing\n    /// accesses to this pool.\n    ///\n    /// Note that we put this outside the `Arc` so that cloning a `Regex`\n    /// results in creating a fresh `CachePool`. This in turn permits callers\n    /// to clone regexes into separate threads where each such regex gets\n    /// the pool's \"thread owner\" optimization. Otherwise, if one shares the\n    /// `Regex` directly, then the pool will go through a slower mutex path for\n    /// all threads except for the \"owner.\"\n    pool: CachePool,\n}\n#[derive(Debug)]\nstruct RegexI {\n    /// The core matching engine.\n    ///\n    /// Why is this reference counted when RegexI is already wrapped in an Arc?\n    /// Well, we need to capture this in a closure to our `Pool` below in order\n    /// to create new `Cache` values when needed. So since it needs to be in\n    /// two places, we make it reference counted.\n    ///\n    /// We make `RegexI` itself reference counted too so that `Regex` itself\n    /// stays extremely small and very cheap to clone.\n    strat: Arc<dyn Strategy>,\n    /// Metadata about the regexes driving the strategy. The metadata is also\n    /// usually stored inside the strategy too, but we put it here as well\n    /// so that we can get quick access to it (without virtual calls) before\n    /// executing the regex engine. For example, we use this metadata to\n    /// detect a subset of cases where we know a match is impossible, and can\n    /// thus avoid calling into the strategy at all.\n    ///\n    /// Since `RegexInfo` is stored in multiple places, it is also reference\n    /// counted.\n    info: RegexInfo,\n}\nimpl Regex {\n    pub fn create_captures(&self) -> Captures {}\n    pub fn create_cache(&self) -> Cache {}\n    pub fn pattern_len(&self) -> usize {}\n    pub fn captures_len(&self) -> usize {}\n    #[inline]\n    pub fn static_captures_len(&self) -> Option<usize> {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {}\n    #[inline]\n    pub fn get_config(&self) -> &Config {}\n    #[inline]\n    pub fn is_accelerated(&self) -> bool {\n        self.imp.strat.is_accelerated()\n    }\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns true if this regex has a high chance of being \"accelerated.\"\n///\n/// The precise meaning of \"accelerated\" is specifically left unspecified,\n/// but the general meaning is that the search is a high likelihood of\n/// running faster than a character-at-a-time loop inside a standard\n/// regex engine.\n///\n/// When a regex is accelerated, it is only a *probabilistic* claim. That\n/// is, just because the regex is believed to be accelerated, that doesn't\n/// mean it will definitely execute searches very fast. Similarly, if a\n/// regex is *not* accelerated, that is also a probabilistic claim. That\n/// is, a regex for which `is_accelerated` returns `false` could still run\n/// searches more quickly than a regex for which `is_accelerated` returns\n/// `true`.\n///\n/// Whether a regex is marked as accelerated or not is dependent on\n/// implementations details that may change in a semver compatible release.\n/// That is, a regex that is accelerated in a `x.y.1` release might not be\n/// accelerated in a `x.y.2` release.\n///\n/// Basically, the value of acceleration boils down to a hedge: a hodge\n/// podge of internal heuristics combine to make a probabilistic guess\n/// that this regex search may run \"fast.\" The value in knowing this from\n/// a caller's perspective is that it may act as a signal that no further\n/// work should be done to accelerate a search. For example, a grep-like\n/// tool might try to do some extra work extracting literals from a regex\n/// to create its own heuristic acceleration strategies. But it might\n/// choose to defer to this crate's acceleration strategy if one exists.\n/// This routine permits querying whether such a strategy is active for a\n/// particular regex.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::meta::Regex;\n///\n/// // A simple literal is very likely to be accelerated.\n/// let re = Regex::new(r\"foo\")?;\n/// assert!(re.is_accelerated());\n///\n/// // A regex with no literals is likely to not be accelerated.\n/// let re = Regex::new(r\"\\w\")?;\n/// assert!(!re.is_accelerated());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1872 pub fn is_accelerated(&self) -> bool {\n1873     self.imp.strat.is_accelerated()\n1874 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}