{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/unicode.rs\n// crate name is regex_syntax\ntype Range = &'static [(char, char)];\ntype PropertyValues = &'static [(&'static str, &'static str)];\nuse alloc::{\n    string::{String, ToString},\n    vec::Vec,\n};\nuse crate::hir;\nfn symbolic_name_normalize(x: &str) -> String {\n    let mut tmp = x.as_bytes().to_vec();\n    let len = symbolic_name_normalize_bytes(&mut tmp).len();\n    tmp.truncate(len);\n    String::from_utf8(tmp).unwrap()\n}\nfn symbolic_name_normalize_bytes(slice: &mut [u8]) -> &mut [u8] {\n    let mut start = 0;\n    let mut starts_with_is = false;\n    if slice.len() >= 2 {\n        starts_with_is = slice[0..2] == b\"is\"[..] || slice[0..2] == b\"IS\"[..]\n            || slice[0..2] == b\"iS\"[..] || slice[0..2] == b\"Is\"[..];\n        if starts_with_is {\n            start = 2;\n        }\n    }\n    let mut next_write = 0;\n    for i in start..slice.len() {\n        let b = slice[i];\n        if b == b' ' || b == b'_' || b == b'-' {\n            continue;\n        } else if b'A' <= b && b <= b'Z' {\n            slice[next_write] = b + (b'a' - b'A');\n            next_write += 1;\n        } else if b <= 0x7F {\n            slice[next_write] = b;\n            next_write += 1;\n        }\n    }\n    if starts_with_is && next_write == 1 && slice[0] == b'c' {\n        slice[0] = b'i';\n        slice[1] = b's';\n        slice[2] = b'c';\n        next_write = 3;\n    }\n    &mut slice[..next_write]\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Like symbolic_name_normalize_bytes, but operates on a string.\n879 fn symbolic_name_normalize(x: &str) -> String {\n880     let mut tmp = x.as_bytes().to_vec();\n881     let len = symbolic_name_normalize_bytes(&mut tmp).len();\n882     tmp.truncate(len);\n883     // This should always succeed because `symbolic_name_normalize_bytes`\n884     // guarantees that `&tmp[..len]` is always valid UTF-8.\n885     //\n886     // N.B. We could avoid the additional UTF-8 check here, but it's unlikely\n887     // to be worth skipping the additional safety check. A benchmark must\n888     // justify it first.\n889     String::from_utf8(tmp).unwrap()\n890 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}