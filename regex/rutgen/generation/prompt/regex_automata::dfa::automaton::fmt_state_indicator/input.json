{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\npub(crate) fn fmt_state_indicator<A: Automaton>(\n    f: &mut core::fmt::Formatter<'_>,\n    dfa: A,\n    id: StateID,\n) -> core::fmt::Result {\n    if dfa.is_dead_state(id) {\n        write!(f, \"D\")?;\n        if dfa.is_start_state(id) {\n            write!(f, \">\")?;\n        } else {\n            write!(f, \" \")?;\n        }\n    } else if dfa.is_quit_state(id) {\n        write!(f, \"Q \")?;\n    } else if dfa.is_start_state(id) {\n        if dfa.is_accel_state(id) {\n            write!(f, \"A>\")?;\n        } else {\n            write!(f, \" >\")?;\n        }\n    } else if dfa.is_match_state(id) {\n        if dfa.is_accel_state(id) {\n            write!(f, \"A*\")?;\n        } else {\n            write!(f, \" *\")?;\n        }\n    } else if dfa.is_accel_state(id) {\n        write!(f, \"A \")?;\n    } else {\n        write!(f, \"  \")?;\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Write a prefix \"state\" indicator for fmt::Debug impls.\n///\n/// Specifically, this tries to succinctly distinguish the different types of\n/// states: dead states, quit states, accelerated states, start states and\n/// match states. It even accounts for the possible overlappings of different\n/// state types.\n2207 pub(crate) fn fmt_state_indicator<A: Automaton>(\n2208     f: &mut core::fmt::Formatter<'_>,\n2209     dfa: A,\n2210     id: StateID,\n2211 ) -> core::fmt::Result {\n2212     if dfa.is_dead_state(id) {\n2213         write!(f, \"D\")?;\n2214         if dfa.is_start_state(id) {\n2215             write!(f, \">\")?;\n2216         } else {\n2217             write!(f, \" \")?;\n2218         }\n2219     } else if dfa.is_quit_state(id) {\n2220         write!(f, \"Q \")?;\n2221     } else if dfa.is_start_state(id) {\n2222         if dfa.is_accel_state(id) {\n2223             write!(f, \"A>\")?;\n2224         } else {\n2225             write!(f, \" >\")?;\n2226         }\n2227     } else if dfa.is_match_state(id) {\n2228         if dfa.is_accel_state(id) {\n2229             write!(f, \"A*\")?;\n2230         } else {\n2231             write!(f, \" *\")?;\n2232         }\n2233     } else if dfa.is_accel_state(id) {\n2234         write!(f, \"A \")?;\n2235     } else {\n2236         write!(f, \"  \")?;\n2237     }\n2238     Ok(())\n2239 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}