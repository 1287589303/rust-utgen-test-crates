{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\npub(crate) fn fmt_state_indicator<A: Automaton>(\n    f: &mut core::fmt::Formatter<'_>,\n    dfa: A,\n    id: StateID,\n) -> core::fmt::Result {\n    if dfa.is_dead_state(id) {\n        write!(f, \"D\")?;\n        if dfa.is_start_state(id) {\n            write!(f, \">\")?;\n        } else {\n            write!(f, \" \")?;\n        }\n    } else if dfa.is_quit_state(id) {\n        write!(f, \"Q \")?;\n    } else if dfa.is_start_state(id) {\n        if dfa.is_accel_state(id) {\n            write!(f, \"A>\")?;\n        } else {\n            write!(f, \" >\")?;\n        }\n    } else if dfa.is_match_state(id) {\n        if dfa.is_accel_state(id) {\n            write!(f, \"A*\")?;\n        } else {\n            write!(f, \" *\")?;\n        }\n    } else if dfa.is_accel_state(id) {\n        write!(f, \"A \")?;\n    } else {\n        write!(f, \"  \")?;\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Write a prefix \"state\" indicator for fmt::Debug impls.\n///\n/// Specifically, this tries to succinctly distinguish the different types of\n/// states: dead states, quit states, accelerated states, start states and\n/// match states. It even accounts for the possible overlappings of different\n/// state types.\n2207 pub(crate) fn fmt_state_indicator<A: Automaton>(\n2208     f: &mut core::fmt::Formatter<'_>,\n2209     dfa: A,\n2210     id: StateID,\n2211 ) -> core::fmt::Result {\n2212     if dfa.is_dead_state(id) {\n2213         write!(f, \"D\")?;\n2214         if dfa.is_start_state(id) {\n2215             write!(f, \">\")?;\n2216         } else {\n2217             write!(f, \" \")?;\n2218         }\n2219     } else if dfa.is_quit_state(id) {\n2220         write!(f, \"Q \")?;\n2221     } else if dfa.is_start_state(id) {\n2222         if dfa.is_accel_state(id) {\n2223             write!(f, \"A>\")?;\n2224         } else {\n2225             write!(f, \" >\")?;\n2226         }\n2227     } else if dfa.is_match_state(id) {\n2228         if dfa.is_accel_state(id) {\n2229             write!(f, \"A*\")?;\n2230         } else {\n2231             write!(f, \" *\")?;\n2232         }\n2233     } else if dfa.is_accel_state(id) {\n2234         write!(f, \"A \")?;\n2235     } else {\n2236         write!(f, \"  \")?;\n2237     }\n2238     Ok(())\n2239 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}