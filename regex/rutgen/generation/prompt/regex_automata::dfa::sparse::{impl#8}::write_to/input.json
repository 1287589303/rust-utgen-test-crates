{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\nstruct Transitions<T> {\n    /// The raw encoding of each state in this DFA.\n    ///\n    /// Each state has the following information:\n    ///\n    /// * A set of transitions to subsequent states. Transitions to the dead\n    ///   state are omitted.\n    /// * If the state can be accelerated, then any additional accelerator\n    ///   information.\n    /// * If the state is a match state, then the state contains all pattern\n    ///   IDs that match when in that state.\n    ///\n    /// To decode a state, use Transitions::state.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8].\n    sparse: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride and is documented above.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is\n    /// if the DFA's kind uses byte classes which is the default. Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    ///\n    /// N.B. Equivalence classes aren't particularly useful in a sparse DFA\n    /// in the current implementation, since equivalence classes generally tend\n    /// to correspond to continuous ranges of bytes that map to the same\n    /// transition. So in a sparse DFA, equivalence classes don't really lead\n    /// to a space savings. In the future, it would be good to try and remove\n    /// them from sparse DFAs entirely, but requires a bit of work since sparse\n    /// DFAs are built from dense DFAs, which are in turn built on top of\n    /// equivalence classes.\n    classes: ByteClasses,\n    /// The total number of states in this DFA. Note that a DFA always has at\n    /// least one state---the dead state---even the empty DFA. In particular,\n    /// the dead state always has ID 0 and is correspondingly always the first\n    /// state. The dead state is never a match state.\n    state_len: usize,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Debug)]\npub struct SerializeError {\n    /// The name of the thing that a buffer is too small for.\n    ///\n    /// Currently, the only kind of serialization error is one that is\n    /// committed by a caller: providing a destination buffer that is too\n    /// small to fit the serialized object. This makes sense conceptually,\n    /// since every valid inhabitant of a type should be serializable.\n    ///\n    /// This is somewhat exposed in the public API of this crate. For example,\n    /// the `to_bytes_{big,little}_endian` APIs return a `Vec<u8>` and are\n    /// guaranteed to never panic or error. This is only possible because the\n    /// implementation guarantees that it will allocate a `Vec<u8>` that is\n    /// big enough.\n    ///\n    /// In summary, if a new serialization error kind needs to be added, then\n    /// it will need careful consideration.\n    what: &'static str,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\nimpl<T: AsRef<[u8]>> Transitions<T> {\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {\n        let nwrite = self.write_to_len();\n        if dst.len() < nwrite {\n            return Err(SerializeError::buffer_too_small(\"sparse transition table\"));\n        }\n        dst = &mut dst[..nwrite];\n        E::write_u32(u32::try_from(self.state_len).unwrap(), dst);\n        dst = &mut dst[size_of::<u32>()..];\n        E::write_u32(u32::try_from(self.pattern_len).unwrap(), dst);\n        dst = &mut dst[size_of::<u32>()..];\n        let n = self.classes.write_to(dst)?;\n        dst = &mut dst[n..];\n        E::write_u32(u32::try_from(self.sparse().len()).unwrap(), dst);\n        dst = &mut dst[size_of::<u32>()..];\n        let mut id = DEAD;\n        while id.as_usize() < self.sparse().len() {\n            let state = self.state(id);\n            let n = state.write_to::<E>(&mut dst)?;\n            dst = &mut dst[n..];\n            id = StateID::new(id.as_usize() + state.write_to_len()).unwrap();\n        }\n        Ok(nwrite)\n    }\n    fn write_to_len(&self) -> usize {\n        size_of::<u32>() + size_of::<u32>() + self.classes.write_to_len()\n            + size_of::<u32>() + self.sparse().len()\n    }\n    fn validate(&self, sp: &Special) -> Result<Seen, DeserializeError> {}\n    fn as_ref(&self) -> Transitions<&'_ [u8]> {}\n    #[cfg(feature = \"alloc\")]\n    fn to_owned(&self) -> Transitions<alloc::vec::Vec<u8>> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn state(&self, id: StateID) -> State<'_> {\n        let mut state = &self.sparse()[id.as_usize()..];\n        let mut ntrans = wire::read_u16(&state).as_usize();\n        let is_match = (1 << 15) & ntrans != 0;\n        ntrans &= !(1 << 15);\n        state = &state[2..];\n        let (input_ranges, state) = state.split_at(ntrans * 2);\n        let (next, state) = state.split_at(ntrans * StateID::SIZE);\n        let (pattern_ids, state) = if is_match {\n            let npats = wire::read_u32(&state).as_usize();\n            state[4..].split_at(npats * 4)\n        } else {\n            (&[][..], state)\n        };\n        let accel_len = usize::from(state[0]);\n        let accel = &state[1..accel_len + 1];\n        State {\n            id,\n            is_match,\n            ntrans,\n            input_ranges,\n            next,\n            pattern_ids,\n            accel,\n        }\n    }\n    fn try_state(\n        &self,\n        sp: &Special,\n        id: StateID,\n    ) -> Result<State<'_>, DeserializeError> {}\n    fn states(&self) -> StateIter<'_, T> {}\n    fn sparse(&self) -> &[u8] {\n        self.sparse.as_ref()\n    }\n    fn id_len(&self) -> usize {}\n    fn memory_usage(&self) -> usize {}\n}\nimpl<'a> State<'a> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next(&self, input: u8) -> StateID {}\n    fn next_eoi(&self) -> StateID {}\n    fn id(&self) -> StateID {}\n    fn range(&self, i: usize) -> (u8, u8) {}\n    fn next_at(&self, i: usize) -> StateID {}\n    fn pattern_id(&self, match_index: usize) -> PatternID {}\n    fn pattern_len(&self) -> usize {}\n    fn accelerator(&self) -> &'a [u8] {}\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {\n        let mut len = 2 + (self.ntrans * 2) + (self.ntrans * StateID::SIZE)\n            + (1 + self.accel.len());\n        if self.is_match {\n            len += size_of::<u32>() + self.pattern_ids.len();\n        }\n        len\n    }\n}\nimpl ByteClasses {\n    #[inline]\n    pub fn empty() -> ByteClasses {}\n    #[inline]\n    pub fn singletons() -> ByteClasses {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteClasses, usize), DeserializeError> {}\n    pub(crate) fn write_to(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {\n        let nwrite = self.write_to_len();\n        if dst.len() < nwrite {\n            return Err(SerializeError::buffer_too_small(\"byte class map\"));\n        }\n        for b in 0..=255 {\n            dst[0] = self.get(b);\n            dst = &mut dst[1..];\n        }\n        Ok(nwrite)\n    }\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[inline]\n    pub fn set(&mut self, byte: u8, class: u8) {}\n    #[inline]\n    pub fn get(&self, byte: u8) -> u8 {}\n    #[inline]\n    pub fn get_by_unit(&self, unit: Unit) -> usize {}\n    #[inline]\n    pub fn eoi(&self) -> Unit {}\n    #[inline]\n    pub fn alphabet_len(&self) -> usize {}\n    #[inline]\n    pub fn stride2(&self) -> usize {}\n    #[inline]\n    pub fn is_singleton(&self) -> bool {}\n    #[inline]\n    pub fn iter(&self) -> ByteClassIter<'_> {}\n    pub fn representatives<R: core::ops::RangeBounds<u8>>(\n        &self,\n        range: R,\n    ) -> ByteClassRepresentatives<'_> {}\n    #[inline]\n    pub fn elements(&self, class: Unit) -> ByteClassElements {}\n    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges {}\n}\nimpl SerializeError {\n    pub(crate) fn buffer_too_small(what: &'static str) -> SerializeError {\n        SerializeError { what }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Writes a serialized form of this transition table to the buffer given.\n/// If the buffer is too small, then an error is returned. To determine\n/// how big the buffer must be, use `write_to_len`.\n1333 fn write_to<E: Endian>(\n1334     &self,\n1335     mut dst: &mut [u8],\n1336 ) -> Result<usize, SerializeError> {\n1337     let nwrite = self.write_to_len();\n1338     if dst.len() < nwrite {\n1339         return Err(SerializeError::buffer_too_small(\n1340             \"sparse transition table\",\n1341         ));\n1342     }\n1343     dst = &mut dst[..nwrite];\n1344 \n1345     // write state length\n1346     E::write_u32(u32::try_from(self.state_len).unwrap(), dst);\n1347     dst = &mut dst[size_of::<u32>()..];\n1348 \n1349     // write pattern length\n1350     E::write_u32(u32::try_from(self.pattern_len).unwrap(), dst);\n1351     dst = &mut dst[size_of::<u32>()..];\n1352 \n1353     // write byte class map\n1354     let n = self.classes.write_to(dst)?;\n1355     dst = &mut dst[n..];\n1356 \n1357     // write number of bytes in sparse transitions\n1358     E::write_u32(u32::try_from(self.sparse().len()).unwrap(), dst);\n1359     dst = &mut dst[size_of::<u32>()..];\n1360 \n1361     // write actual transitions\n1362     let mut id = DEAD;\n1363     while id.as_usize() < self.sparse().len() {\n1364         let state = self.state(id);\n1365         let n = state.write_to::<E>(&mut dst)?;\n1366         dst = &mut dst[n..];\n1367         // The next ID is the offset immediately following `state`.\n1368         id = StateID::new(id.as_usize() + state.write_to_len()).unwrap();\n1369     }\n1370     Ok(nwrite)\n1371 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}