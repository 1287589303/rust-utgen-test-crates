{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/print.rs\n// crate name is regex_syntax\nuse core::fmt;\nuse crate::{\n    hir::{\n        self, visitor::{self, Visitor},\n        Hir, HirKind,\n    },\n    is_meta_character,\n};\npub trait Visitor {\n    type Output;\n    type Err;\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n    fn start(&mut self) {}\n    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_concat_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}\n#[derive(Debug)]\nstruct Writer<W> {\n    wtr: W,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassUnicodeRange {\n    start: char,\n    end: char,\n}\n#[derive(Clone, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}\n#[derive(Debug)]\npub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the translator's Ast was parsed from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error, derived from the Ast given to the translator.\n    span: Span,\n}\n#[derive(Debug)]\npub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum HirKind {\n    /// The empty regular expression, which matches everything, including the\n    /// empty string.\n    Empty,\n    /// A literalstring that matches exactly these bytes.\n    Literal(Literal),\n    /// A single character class that matches any of the characters in the\n    /// class. A class can either consist of Unicode scalar values as\n    /// characters, or it can use bytes.\n    ///\n    /// A class may be empty. In which case, it matches nothing.\n    Class(Class),\n    /// A look-around assertion. A look-around match always has zero length.\n    Look(Look),\n    /// A repetition operation applied to a sub-expression.\n    Repetition(Repetition),\n    /// A capturing group, which contains a sub-expression.\n    Capture(Capture),\n    /// A concatenation of expressions.\n    ///\n    /// A concatenation matches only if each of its sub-expressions match one\n    /// after the other.\n    ///\n    /// Concatenations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Concat(Vec<Hir>),\n    /// An alternation of expressions.\n    ///\n    /// An alternation matches only if at least one of its sub-expressions\n    /// match. If multiple sub-expressions match, then the leftmost is\n    /// preferred.\n    ///\n    /// Alternations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Alternation(Vec<Hir>),\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Look {\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    Start = 1 << 0,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    End = 1 << 1,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLF = 1 << 2,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\n` character.\n    EndLF = 1 << 3,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following either a `\\r` or `\\n` character, but never after\n    /// a `\\r` when a `\\n` follows.\n    StartCRLF = 1 << 4,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\r` or `\\n` character, but never before a `\\n` when a `\\r`\n    /// precedes it.\n    EndCRLF = 1 << 5,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordAscii = 1 << 6,\n    /// Match an ASCII-only negation of a word boundary.\n    WordAsciiNegate = 1 << 7,\n    /// Match a Unicode-aware word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordUnicode = 1 << 8,\n    /// Match a Unicode-aware negation of a word boundary.\n    WordUnicodeNegate = 1 << 9,\n    /// Match the start of an ASCII-only word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStartAscii = 1 << 10,\n    /// Match the end of an ASCII-only word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEndAscii = 1 << 11,\n    /// Match the start of a Unicode word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStartUnicode = 1 << 12,\n    /// Match the end of a Unicode word boundary. That is, this matches a\n    /// position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEndUnicode = 1 << 13,\n    /// Match the start half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalfAscii = 1 << 14,\n    /// Match the end half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the end of the haystack or where the\n    /// following character is not a word character.\n    WordEndHalfAscii = 1 << 15,\n    /// Match the start half of a Unicode word boundary. That is, this matches\n    /// a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalfUnicode = 1 << 16,\n    /// Match the end half of a Unicode word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the following\n    /// character is not a word character.\n    WordEndHalfUnicode = 1 << 17,\n}\n#[derive(Debug)]\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n    #[allow(dead_code)]\n    PerlClassNotFound,\n}\n#[non_exhaustive]\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Error {\n    /// An error that occurred while translating concrete syntax into abstract\n    /// syntax (AST).\n    Parse(ast::Error),\n    /// An error that occurred while translating abstract syntax into a high\n    /// level intermediate representation (HIR).\n    Translate(hir::Error),\n}\nimpl<W: fmt::Write> Visitor for Writer<W> {\n    type Output = ();\n    type Err = fmt::Error;\n    fn finish(self) -> fmt::Result {}\n    fn visit_pre(&mut self, hir: &Hir) -> fmt::Result {\n        match *hir.kind() {\n            HirKind::Empty => {\n                self.wtr.write_str(r\"(?:)\")?;\n            }\n            HirKind::Repetition(_) => {}\n            HirKind::Literal(hir::Literal(ref bytes)) => {\n                let result = core::str::from_utf8(bytes);\n                let len = result.map_or(bytes.len(), |s| s.chars().count());\n                if len > 1 {\n                    self.wtr.write_str(r\"(?:\")?;\n                }\n                match result {\n                    Ok(string) => {\n                        for c in string.chars() {\n                            self.write_literal_char(c)?;\n                        }\n                    }\n                    Err(_) => {\n                        for &b in bytes.iter() {\n                            self.write_literal_byte(b)?;\n                        }\n                    }\n                }\n                if len > 1 {\n                    self.wtr.write_str(r\")\")?;\n                }\n            }\n            HirKind::Class(hir::Class::Unicode(ref cls)) => {\n                if cls.ranges().is_empty() {\n                    return self.wtr.write_str(\"[a&&b]\");\n                }\n                self.wtr.write_str(\"[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_char(range.start())?;\n                    } else if u32::from(range.start()) + 1 == u32::from(range.end()) {\n                        self.write_literal_char(range.start())?;\n                        self.write_literal_char(range.end())?;\n                    } else {\n                        self.write_literal_char(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_char(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"]\")?;\n            }\n            HirKind::Class(hir::Class::Bytes(ref cls)) => {\n                if cls.ranges().is_empty() {\n                    return self.wtr.write_str(\"[a&&b]\");\n                }\n                self.wtr.write_str(\"(?-u:[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                    } else if range.start() + 1 == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                        self.write_literal_class_byte(range.end())?;\n                    } else {\n                        self.write_literal_class_byte(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_class_byte(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"])\")?;\n            }\n            HirKind::Look(ref look) => {\n                match *look {\n                    hir::Look::Start => {\n                        self.wtr.write_str(r\"\\A\")?;\n                    }\n                    hir::Look::End => {\n                        self.wtr.write_str(r\"\\z\")?;\n                    }\n                    hir::Look::StartLF => {\n                        self.wtr.write_str(\"(?m:^)\")?;\n                    }\n                    hir::Look::EndLF => {\n                        self.wtr.write_str(\"(?m:$)\")?;\n                    }\n                    hir::Look::StartCRLF => {\n                        self.wtr.write_str(\"(?mR:^)\")?;\n                    }\n                    hir::Look::EndCRLF => {\n                        self.wtr.write_str(\"(?mR:$)\")?;\n                    }\n                    hir::Look::WordAscii => {\n                        self.wtr.write_str(r\"(?-u:\\b)\")?;\n                    }\n                    hir::Look::WordAsciiNegate => {\n                        self.wtr.write_str(r\"(?-u:\\B)\")?;\n                    }\n                    hir::Look::WordUnicode => {\n                        self.wtr.write_str(r\"\\b\")?;\n                    }\n                    hir::Look::WordUnicodeNegate => {\n                        self.wtr.write_str(r\"\\B\")?;\n                    }\n                    hir::Look::WordStartAscii => {\n                        self.wtr.write_str(r\"(?-u:\\b{start})\")?;\n                    }\n                    hir::Look::WordEndAscii => {\n                        self.wtr.write_str(r\"(?-u:\\b{end})\")?;\n                    }\n                    hir::Look::WordStartUnicode => {\n                        self.wtr.write_str(r\"\\b{start}\")?;\n                    }\n                    hir::Look::WordEndUnicode => {\n                        self.wtr.write_str(r\"\\b{end}\")?;\n                    }\n                    hir::Look::WordStartHalfAscii => {\n                        self.wtr.write_str(r\"(?-u:\\b{start-half})\")?;\n                    }\n                    hir::Look::WordEndHalfAscii => {\n                        self.wtr.write_str(r\"(?-u:\\b{end-half})\")?;\n                    }\n                    hir::Look::WordStartHalfUnicode => {\n                        self.wtr.write_str(r\"\\b{start-half}\")?;\n                    }\n                    hir::Look::WordEndHalfUnicode => {\n                        self.wtr.write_str(r\"\\b{end-half}\")?;\n                    }\n                }\n            }\n            HirKind::Capture(hir::Capture { ref name, .. }) => {\n                self.wtr.write_str(\"(\")?;\n                if let Some(ref name) = *name {\n                    write!(self.wtr, \"?P<{}>\", name)?;\n                }\n            }\n            HirKind::Concat(_) | HirKind::Alternation(_) => {\n                self.wtr.write_str(r\"(?:\")?;\n            }\n        }\n        Ok(())\n    }\n    fn visit_post(&mut self, hir: &Hir) -> fmt::Result {}\n    fn visit_alternation_in(&mut self) -> fmt::Result {}\n}\nimpl<W: fmt::Write> Writer<W> {\n    fn write_literal_char(&mut self, c: char) -> fmt::Result {\n        if is_meta_character(c) {\n            self.wtr.write_str(\"\\\\\")?;\n        }\n        self.wtr.write_char(c)\n    }\n    fn write_literal_byte(&mut self, b: u8) -> fmt::Result {\n        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {\n            self.write_literal_char(char::try_from(b).unwrap())\n        } else {\n            write!(self.wtr, \"(?-u:\\\\x{:02X})\", b)\n        }\n    }\n    fn write_literal_class_byte(&mut self, b: u8) -> fmt::Result {\n        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {\n            self.write_literal_char(char::try_from(b).unwrap())\n        } else {\n            write!(self.wtr, \"\\\\x{:02X}\", b)\n        }\n    }\n}\nimpl ClassBytesRange {\n    pub fn new(start: u8, end: u8) -> ClassBytesRange {}\n    pub fn start(&self) -> u8 {\n        self.start\n    }\n    pub fn end(&self) -> u8 {\n        self.end\n    }\n    pub fn len(&self) -> usize {}\n}\nimpl ClassUnicodeRange {\n    pub fn new(start: char, end: char) -> ClassUnicodeRange {}\n    pub fn start(&self) -> char {\n        self.start\n    }\n    pub fn end(&self) -> char {\n        self.end\n    }\n    pub fn len(&self) -> usize {}\n}\nimpl Hir {\n    pub fn kind(&self) -> &HirKind {\n        &self.kind\n    }\n    pub fn into_kind(mut self) -> HirKind {}\n    pub fn properties(&self) -> &Properties {}\n    fn into_parts(mut self) -> (HirKind, Properties) {}\n}\nimpl ClassBytes {\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {}\n    pub fn empty() -> ClassBytes {}\n    pub fn push(&mut self, range: ClassBytesRange) {}\n    pub fn iter(&self) -> ClassBytesIter<'_> {\n        ClassBytesIter(self.set.iter())\n    }\n    pub fn ranges(&self) -> &[ClassBytesRange] {\n        self.set.intervals()\n    }\n    pub fn case_fold_simple(&mut self) {}\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassBytes) {}\n    pub fn intersect(&mut self, other: &ClassBytes) {}\n    pub fn difference(&mut self, other: &ClassBytes) {}\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_unicode_class(&self) -> Option<ClassUnicode> {}\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {}\n    pub fn empty() -> ClassUnicode {}\n    pub fn push(&mut self, range: ClassUnicodeRange) {}\n    pub fn iter(&self) -> ClassUnicodeIter<'_> {\n        ClassUnicodeIter(self.set.iter())\n    }\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {\n        self.set.intervals()\n    }\n    pub fn case_fold_simple(&mut self) {}\n    pub fn try_case_fold_simple(&mut self) -> core::result::Result<(), CaseFoldError> {}\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassUnicode) {}\n    pub fn intersect(&mut self, other: &ClassUnicode) {}\n    pub fn difference(&mut self, other: &ClassUnicode) {}\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_byte_class(&self) -> Option<ClassBytes> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n 90 fn visit_pre(&mut self, hir: &Hir) -> fmt::Result {\n 91     match *hir.kind() {\n 92         HirKind::Empty => {\n 93             // Technically an empty sub-expression could be \"printed\" by\n 94             // just ignoring it, but in practice, you could have a\n 95             // repetition operator attached to an empty expression, and you\n 96             // really need something in the concrete syntax to make that\n 97             // work as you'd expect.\n 98             self.wtr.write_str(r\"(?:)\")?;\n 99         }\n100         // Repetition operators are strictly suffix oriented.\n101         HirKind::Repetition(_) => {}\n102         HirKind::Literal(hir::Literal(ref bytes)) => {\n103             // See the comment on the 'Concat' and 'Alternation' case below\n104             // for why we put parens here. Literals are, conceptually,\n105             // a special case of concatenation where each element is a\n106             // character. The HIR flattens this into a Box<[u8]>, but we\n107             // still need to treat it like a concatenation for correct\n108             // printing. As a special case, we don't write parens if there\n109             // is only one character. One character means there is no\n110             // concat so we don't need parens. Adding parens would still be\n111             // correct, but we drop them here because it tends to create\n112             // rather noisy regexes even in simple cases.\n113             let result = core::str::from_utf8(bytes);\n114             let len = result.map_or(bytes.len(), |s| s.chars().count());\n115             if len > 1 {\n116                 self.wtr.write_str(r\"(?:\")?;\n117             }\n118             match result {\n119                 Ok(string) => {\n120                     for c in string.chars() {\n121                         self.write_literal_char(c)?;\n122                     }\n123                 }\n124                 Err(_) => {\n125                     for &b in bytes.iter() {\n126                         self.write_literal_byte(b)?;\n127                     }\n128                 }\n129             }\n130             if len > 1 {\n131                 self.wtr.write_str(r\")\")?;\n132             }\n133         }\n134         HirKind::Class(hir::Class::Unicode(ref cls)) => {\n135             if cls.ranges().is_empty() {\n136                 return self.wtr.write_str(\"[a&&b]\");\n137             }\n138             self.wtr.write_str(\"[\")?;\n139             for range in cls.iter() {\n140                 if range.start() == range.end() {\n141                     self.write_literal_char(range.start())?;\n142                 } else if u32::from(range.start()) + 1\n143                     == u32::from(range.end())\n144                 {\n145                     self.write_literal_char(range.start())?;\n146                     self.write_literal_char(range.end())?;\n147                 } else {\n148                     self.write_literal_char(range.start())?;\n149                     self.wtr.write_str(\"-\")?;\n150                     self.write_literal_char(range.end())?;\n151                 }\n152             }\n153             self.wtr.write_str(\"]\")?;\n154         }\n155         HirKind::Class(hir::Class::Bytes(ref cls)) => {\n156             if cls.ranges().is_empty() {\n157                 return self.wtr.write_str(\"[a&&b]\");\n158             }\n159             self.wtr.write_str(\"(?-u:[\")?;\n160             for range in cls.iter() {\n161                 if range.start() == range.end() {\n162                     self.write_literal_class_byte(range.start())?;\n163                 } else if range.start() + 1 == range.end() {\n164                     self.write_literal_class_byte(range.start())?;\n165                     self.write_literal_class_byte(range.end())?;\n166                 } else {\n167                     self.write_literal_class_byte(range.start())?;\n168                     self.wtr.write_str(\"-\")?;\n169                     self.write_literal_class_byte(range.end())?;\n170                 }\n171             }\n172             self.wtr.write_str(\"])\")?;\n173         }\n174         HirKind::Look(ref look) => match *look {\n175             hir::Look::Start => {\n176                 self.wtr.write_str(r\"\\A\")?;\n177             }\n178             hir::Look::End => {\n179                 self.wtr.write_str(r\"\\z\")?;\n180             }\n181             hir::Look::StartLF => {\n182                 self.wtr.write_str(\"(?m:^)\")?;\n183             }\n184             hir::Look::EndLF => {\n185                 self.wtr.write_str(\"(?m:$)\")?;\n186             }\n187             hir::Look::StartCRLF => {\n188                 self.wtr.write_str(\"(?mR:^)\")?;\n189             }\n190             hir::Look::EndCRLF => {\n191                 self.wtr.write_str(\"(?mR:$)\")?;\n192             }\n193             hir::Look::WordAscii => {\n194                 self.wtr.write_str(r\"(?-u:\\b)\")?;\n195             }\n196             hir::Look::WordAsciiNegate => {\n197                 self.wtr.write_str(r\"(?-u:\\B)\")?;\n198             }\n199             hir::Look::WordUnicode => {\n200                 self.wtr.write_str(r\"\\b\")?;\n201             }\n202             hir::Look::WordUnicodeNegate => {\n203                 self.wtr.write_str(r\"\\B\")?;\n204             }\n205             hir::Look::WordStartAscii => {\n206                 self.wtr.write_str(r\"(?-u:\\b{start})\")?;\n207             }\n208             hir::Look::WordEndAscii => {\n209                 self.wtr.write_str(r\"(?-u:\\b{end})\")?;\n210             }\n211             hir::Look::WordStartUnicode => {\n212                 self.wtr.write_str(r\"\\b{start}\")?;\n213             }\n214             hir::Look::WordEndUnicode => {\n215                 self.wtr.write_str(r\"\\b{end}\")?;\n216             }\n217             hir::Look::WordStartHalfAscii => {\n218                 self.wtr.write_str(r\"(?-u:\\b{start-half})\")?;\n219             }\n220             hir::Look::WordEndHalfAscii => {\n221                 self.wtr.write_str(r\"(?-u:\\b{end-half})\")?;\n222             }\n223             hir::Look::WordStartHalfUnicode => {\n224                 self.wtr.write_str(r\"\\b{start-half}\")?;\n225             }\n226             hir::Look::WordEndHalfUnicode => {\n227                 self.wtr.write_str(r\"\\b{end-half}\")?;\n228             }\n229         },\n230         HirKind::Capture(hir::Capture { ref name, .. }) => {\n231             self.wtr.write_str(\"(\")?;\n232             if let Some(ref name) = *name {\n233                 write!(self.wtr, \"?P<{}>\", name)?;\n234             }\n235         }\n236         // Why do this? Wrapping concats and alts in non-capturing groups\n237         // is not *always* necessary, but is sometimes necessary. For\n238         // example, 'concat(a, alt(b, c))' should be written as 'a(?:b|c)'\n239         // and not 'ab|c'. The former is clearly the intended meaning, but\n240         // the latter is actually 'alt(concat(a, b), c)'.\n241         //\n242         // It would be possible to only group these things in cases where\n243         // it's strictly necessary, but it requires knowing the parent\n244         // expression. And since this technique is simpler and always\n245         // correct, we take this route. More to the point, it is a non-goal\n246         // of an HIR printer to show a nice easy-to-read regex. Indeed,\n247         // its construction forbids it from doing so. Therefore, inserting\n248         // extra groups where they aren't necessary is perfectly okay.\n249         HirKind::Concat(_) | HirKind::Alternation(_) => {\n250             self.wtr.write_str(r\"(?:\")?;\n251         }\n252     }\n253     Ok(())\n254 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}