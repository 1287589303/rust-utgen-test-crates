{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/hybrid/search.rs\n// crate name is regex_automata\nuse crate::{\n    hybrid::{\n        dfa::{Cache, OverlappingState, DFA},\n        id::LazyStateID,\n    },\n    util::{prefilter::Prefilter, search::{HalfMatch, Input, MatchError, Span}},\n};\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct LazyStateID(u32);\n#[derive(Clone, Copy, Default, Eq, PartialEq)]\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where\n    /// `i = Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u32,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// The transition table.\n    ///\n    /// Given a `current` LazyStateID and an `input` byte, the next state can\n    /// be computed via `trans[untagged(current) + equiv_class(input)]`. Notice\n    /// that no multiplication is used. That's because state identifiers are\n    /// \"premultiplied.\"\n    ///\n    /// Note that the next state may be the \"unknown\" state. In this case, the\n    /// next state is not known and determinization for `current` on `input`\n    /// must be performed.\n    trans: Vec<LazyStateID>,\n    /// The starting states for this DFA.\n    ///\n    /// These are computed lazily. Initially, these are all set to \"unknown\"\n    /// lazy state IDs.\n    ///\n    /// When 'starts_for_each_pattern' is disabled (the default), then the size\n    /// of this is constrained to the possible starting configurations based\n    /// on the search parameters. (At time of writing, that's 4.) However,\n    /// when starting states for each pattern is enabled, then there are N\n    /// additional groups of starting states, where each group reflects the\n    /// different possible configurations and N is the number of patterns.\n    starts: Vec<LazyStateID>,\n    /// A sequence of NFA/DFA powerset states that have been computed for this\n    /// lazy DFA. This sequence is indexable by untagged LazyStateIDs. (Every\n    /// tagged LazyStateID can be used to index this sequence by converting it\n    /// to its untagged form.)\n    states: Vec<State>,\n    /// A map from states to their corresponding IDs. This map may be accessed\n    /// via the raw byte representation of a state, which means that a `State`\n    /// does not need to be allocated to determine whether it already exists\n    /// in this map. Indeed, the existence of such a state is what determines\n    /// whether we allocate a new `State` or not.\n    ///\n    /// The higher level idea here is that we do just enough determinization\n    /// for a state to check whether we've already computed it. If we have,\n    /// then we can save a little (albeit not much) work. The real savings is\n    /// in memory usage. If we never checked for trivially duplicate states,\n    /// then our memory usage would explode to unreasonable levels.\n    states_to_id: StateMap,\n    /// Sparse sets used to track which NFA states have been visited during\n    /// various traversals.\n    sparses: SparseSets,\n    /// Scratch space for traversing the NFA graph. (We use space on the heap\n    /// instead of the call stack.)\n    stack: Vec<NFAStateID>,\n    /// Scratch space for building a NFA/DFA powerset state. This is used to\n    /// help amortize allocation since not every powerset state generated is\n    /// added to the cache. In particular, if it already exists in the cache,\n    /// then there is no need to allocate a new `State` for it.\n    scratch_state_builder: StateBuilderEmpty,\n    /// A simple abstraction for handling the saving of at most a single state\n    /// across a cache clearing. This is required for correctness. Namely, if\n    /// adding a new state after clearing the cache fails, then the caller\n    /// must retain the ability to continue using the state ID given. The\n    /// state corresponding to the state ID is what we preserve across cache\n    /// clearings.\n    state_saver: StateSaver,\n    /// The memory usage, in bytes, used by 'states' and 'states_to_id'. We\n    /// track this as new states are added since states use a variable amount\n    /// of heap. Tracking this as we add states makes it possible to compute\n    /// the total amount of memory used by the determinizer in constant time.\n    memory_usage_state: usize,\n    /// The number of times the cache has been cleared. When a minimum cache\n    /// clear count is set, then the cache will return an error instead of\n    /// clearing the cache if the count has been exceeded.\n    clear_count: usize,\n    /// The total number of bytes searched since the last time this cache was\n    /// cleared, not including the current search.\n    ///\n    /// This can be added to the length of the current search to get the true\n    /// total number of bytes searched.\n    ///\n    /// This is generally only non-zero when the\n    /// `Cache::search_{start,update,finish}` APIs are used to track search\n    /// progress.\n    bytes_searched: usize,\n    /// The progress of the current search.\n    ///\n    /// This is only non-`None` when callers utlize the `Cache::search_start`,\n    /// `Cache::search_update` and `Cache::search_finish` APIs.\n    ///\n    /// The purpose of recording search progress is to be able to make a\n    /// determination about the efficiency of the cache. Namely, by keeping\n    /// track of the\n    progress: Option<SearchProgress>,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Debug)]\npub struct DFA {\n    config: Config,\n    nfa: thompson::NFA,\n    stride2: usize,\n    start_map: StartByteMap,\n    classes: ByteClasses,\n    quitset: ByteSet,\n    cache_capacity: usize,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Span {\n    /// The start offset of the span, inclusive.\n    pub start: usize,\n    /// The end offset of the span, exclusive.\n    pub end: usize,\n}\n#[derive(Clone, Debug)]\npub struct CacheError(());\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct OverlappingState {\n    /// The match reported by the most recent overlapping search to use this\n    /// state.\n    ///\n    /// If a search does not find any matches, then it is expected to clear\n    /// this value.\n    pub(crate) mat: Option<HalfMatch>,\n    /// The state ID of the state at which the search was in when the call\n    /// terminated. When this is a match state, `last_match` must be set to a\n    /// non-None value.\n    ///\n    /// A `None` value indicates the start state of the corresponding\n    /// automaton. We cannot use the actual ID, since any one automaton may\n    /// have many start states, and which one is in use depends on several\n    /// search-time factors.\n    pub(crate) id: Option<LazyStateID>,\n    /// The position of the search.\n    ///\n    /// When `id` is None (i.e., we are starting a search), this is set to\n    /// the beginning of the search as given by the caller regardless of its\n    /// current value. Subsequent calls to an overlapping search pick up at\n    /// this offset.\n    pub(crate) at: usize,\n    /// The index into the matching patterns of the next match to report if the\n    /// current state is a match state. Note that this may be 1 greater than\n    /// the total number of matches to report for the current match state. (In\n    /// which case, no more matches should be reported at the current position\n    /// and the search should advance to the next position.)\n    pub(crate) next_match_index: Option<usize>,\n    /// This is set to true when a reverse overlapping search has entered its\n    /// EOI transitions.\n    ///\n    /// This isn't used in a forward search because it knows to stop once the\n    /// position exceeds the end of the search range. In a reverse search,\n    /// since we use unsigned offsets, we don't \"know\" once we've gone past\n    /// `0`. So the only way to detect it is with this extra flag. The reverse\n    /// overlapping search knows to terminate specifically after it has\n    /// reported all matches after following the EOI transition.\n    pub(crate) rev_eoi: bool,\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {\n        MatchError::new(MatchErrorKind::Quit {\n            byte,\n            offset,\n        })\n    }\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {}\n}\nimpl LazyStateID {\n    #[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n    const MAX_BIT: usize = 31;\n    #[cfg(target_pointer_width = \"16\")]\n    const MAX_BIT: usize = 15;\n    const MASK_UNKNOWN: usize = 1 << (LazyStateID::MAX_BIT);\n    const MASK_DEAD: usize = 1 << (LazyStateID::MAX_BIT - 1);\n    const MASK_QUIT: usize = 1 << (LazyStateID::MAX_BIT - 2);\n    const MASK_START: usize = 1 << (LazyStateID::MAX_BIT - 3);\n    const MASK_MATCH: usize = 1 << (LazyStateID::MAX_BIT - 4);\n    const MAX: usize = LazyStateID::MASK_MATCH - 1;\n    #[inline]\n    pub(crate) fn new(id: usize) -> Result<LazyStateID, LazyStateIDError> {}\n    #[inline]\n    const fn new_unchecked(id: usize) -> LazyStateID {}\n    #[inline]\n    pub(crate) fn as_usize_untagged(&self) -> usize {}\n    #[inline]\n    pub(crate) const fn as_usize_unchecked(&self) -> usize {}\n    #[inline]\n    pub(crate) const fn to_unknown(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_dead(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_quit(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_start(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_match(&self) -> LazyStateID {}\n    #[inline]\n    pub const fn is_tagged(&self) -> bool {\n        self.as_usize_unchecked() > LazyStateID::MAX\n    }\n    #[inline]\n    pub const fn is_unknown(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_UNKNOWN > 0\n    }\n    #[inline]\n    pub const fn is_dead(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_DEAD > 0\n    }\n    #[inline]\n    pub const fn is_quit(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_QUIT > 0\n    }\n    #[inline]\n    pub const fn is_start(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_START > 0\n    }\n    #[inline]\n    pub const fn is_match(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_MATCH > 0\n    }\n}\nimpl LookSet {\n    #[inline]\n    pub fn empty() -> LookSet {}\n    #[inline]\n    pub fn full() -> LookSet {}\n    #[inline]\n    pub fn singleton(look: Look) -> LookSet {}\n    #[inline]\n    pub fn len(self) -> usize {}\n    #[inline]\n    pub fn is_empty(self) -> bool {\n        self.len() == 0\n    }\n    #[inline]\n    pub fn contains(self, look: Look) -> bool {}\n    #[inline]\n    pub fn contains_anchor(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_haystack(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_line(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_lf(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_crlf(&self) -> bool {}\n    #[inline]\n    pub fn contains_word(self) -> bool {}\n    #[inline]\n    pub fn contains_word_unicode(self) -> bool {}\n    #[inline]\n    pub fn contains_word_ascii(self) -> bool {}\n    #[inline]\n    pub fn iter(self) -> LookSetIter {}\n    #[inline]\n    pub fn insert(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_insert(&mut self, look: Look) {}\n    #[inline]\n    pub fn remove(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_remove(&mut self, look: Look) {}\n    #[inline]\n    pub fn subtract(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_subtract(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn union(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_union(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn intersect(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_intersect(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn read_repr(slice: &[u8]) -> LookSet {}\n    #[inline]\n    pub fn write_repr(self, slice: &mut [u8]) {}\n    pub fn available(self) -> Result<(), UnicodeWordBoundaryError> {}\n}\nimpl Cache {\n    pub fn new(dfa: &DFA) -> Cache {}\n    pub fn reset(&mut self, dfa: &DFA) {}\n    #[inline]\n    pub fn search_start(&mut self, at: usize) {\n        if let Some(p) = self.progress.take() {\n            self.bytes_searched += p.len();\n        }\n        self.progress = Some(SearchProgress { start: at, at });\n    }\n    #[inline]\n    pub fn search_update(&mut self, at: usize) {\n        let p = self.progress.as_mut().expect(\"no in-progress search to update\");\n        p.at = at;\n    }\n    #[inline]\n    pub fn search_finish(&mut self, at: usize) {\n        let mut p = self.progress.take().expect(\"no in-progress search to finish\");\n        p.at = at;\n        self.bytes_searched += p.len();\n    }\n    pub fn search_total_len(&self) -> usize {}\n    pub fn clear_count(&self) -> usize {}\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {}\n    #[inline]\n    pub fn states(&self) -> &[State] {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {}\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {}\n    #[inline]\n    pub fn is_utf8(&self) -> bool {}\n    #[inline]\n    pub fn is_reverse(&self) -> bool {}\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {}\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {}\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {\n        self.0.look_set_prefix_any\n    }\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {\n        HalfMatch { pattern, offset }\n    }\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {}\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {\n        #[cfg(not(feature = \"alloc\"))] { unreachable!() }\n        #[cfg(feature = \"alloc\")] { self.pre.find(haystack, span) }\n    }\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {}\n}\nimpl DFA {\n    #[inline]\n    pub fn next_state(\n        &self,\n        cache: &mut Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> Result<LazyStateID, CacheError> {\n        let class = usize::from(self.classes.get(input));\n        let offset = current.as_usize_untagged() + class;\n        let sid = cache.trans[offset];\n        if !sid.is_unknown() {\n            return Ok(sid);\n        }\n        let unit = alphabet::Unit::u8(input);\n        Lazy::new(self, cache).cache_next_state(current, unit)\n    }\n    #[inline]\n    pub fn next_state_untagged(\n        &self,\n        cache: &Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> LazyStateID {}\n    #[inline]\n    pub unsafe fn next_state_untagged_unchecked(\n        &self,\n        cache: &Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> LazyStateID {}\n    #[inline]\n    pub fn next_eoi_state(\n        &self,\n        cache: &mut Cache,\n        current: LazyStateID,\n    ) -> Result<LazyStateID, CacheError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state(\n        &self,\n        cache: &mut Cache,\n        config: &start::Config,\n    ) -> Result<LazyStateID, StartError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state_forward(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<LazyStateID, MatchError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state_reverse(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<LazyStateID, MatchError> {}\n    #[inline]\n    pub fn match_len(&self, cache: &Cache, id: LazyStateID) -> usize {\n        assert!(id.is_match());\n        LazyRef::new(self, cache).get_cached_state(id).match_len()\n    }\n    #[inline]\n    pub fn match_pattern(\n        &self,\n        cache: &Cache,\n        id: LazyStateID,\n        match_index: usize,\n    ) -> PatternID {\n        if self.pattern_len() == 1 {\n            return PatternID::ZERO;\n        }\n        LazyRef::new(self, cache).get_cached_state(id).match_pattern(match_index)\n    }\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn find_overlapping_fwd_imp(\n    dfa: &DFA,\n    cache: &mut Cache,\n    input: &Input<'_>,\n    pre: Option<&'_ Prefilter>,\n    state: &mut OverlappingState,\n) -> Result<(), MatchError> {\n    let universal_start = dfa.get_nfa().look_set_prefix_any().is_empty();\n    let mut sid = match state.id {\n        None => {\n            state.at = input.start();\n            init_fwd(dfa, cache, input)?\n        }\n        Some(sid) => {\n            if let Some(match_index) = state.next_match_index {\n                let match_len = dfa.match_len(cache, sid);\n                if match_index < match_len {\n                    state.next_match_index = Some(match_index + 1);\n                    let pattern = dfa.match_pattern(cache, sid, match_index);\n                    state.mat = Some(HalfMatch::new(pattern, state.at));\n                    return Ok(());\n                }\n            }\n            state.at += 1;\n            if state.at > input.end() {\n                return Ok(());\n            }\n            sid\n        }\n    };\n    cache.search_start(state.at);\n    while state.at < input.end() {\n        sid = dfa\n            .next_state(cache, sid, input.haystack()[state.at])\n            .map_err(|_| gave_up(state.at))?;\n        if sid.is_tagged() {\n            state.id = Some(sid);\n            if sid.is_start() {\n                if let Some(ref pre) = pre {\n                    let span = Span::from(state.at..input.end());\n                    match pre.find(input.haystack(), span) {\n                        None => return Ok(()),\n                        Some(ref span) => {\n                            if span.start > state.at {\n                                state.at = span.start;\n                                if !universal_start {\n                                    sid = prefilter_restart(dfa, cache, &input, state.at)?;\n                                }\n                                continue;\n                            }\n                        }\n                    }\n                }\n            } else if sid.is_match() {\n                state.next_match_index = Some(1);\n                let pattern = dfa.match_pattern(cache, sid, 0);\n                state.mat = Some(HalfMatch::new(pattern, state.at));\n                cache.search_finish(state.at);\n                return Ok(());\n            } else if sid.is_dead() {\n                cache.search_finish(state.at);\n                return Ok(());\n            } else if sid.is_quit() {\n                cache.search_finish(state.at);\n                return Err(MatchError::quit(input.haystack()[state.at], state.at));\n            } else {\n                debug_assert!(sid.is_unknown());\n                unreachable!(\"sid being unknown is a bug\");\n            }\n        }\n        state.at += 1;\n        cache.search_update(state.at);\n    }\n    let result = eoi_fwd(dfa, cache, input, &mut sid, &mut state.mat);\n    state.id = Some(sid);\n    if state.mat.is_some() {\n        state.next_match_index = Some(1);\n    }\n    cache.search_finish(input.end());\n    result\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn prefilter_restart(\n    dfa: &DFA,\n    cache: &mut Cache,\n    input: &Input<'_>,\n    at: usize,\n) -> Result<LazyStateID, MatchError> {\n    let mut input = input.clone();\n    input.set_start(at);\n    init_fwd(dfa, cache, &input)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn init_fwd(\n    dfa: &DFA,\n    cache: &mut Cache,\n    input: &Input<'_>,\n) -> Result<LazyStateID, MatchError> {\n    let sid = dfa.start_state_forward(cache, input)?;\n    debug_assert!(! sid.is_match());\n    Ok(sid)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn eoi_fwd(\n    dfa: &DFA,\n    cache: &mut Cache,\n    input: &Input<'_>,\n    sid: &mut LazyStateID,\n    mat: &mut Option<HalfMatch>,\n) -> Result<(), MatchError> {\n    let sp = input.get_span();\n    match input.haystack().get(sp.end) {\n        Some(&b) => {\n            *sid = dfa.next_state(cache, *sid, b).map_err(|_| gave_up(sp.end))?;\n            if sid.is_match() {\n                let pattern = dfa.match_pattern(cache, *sid, 0);\n                *mat = Some(HalfMatch::new(pattern, sp.end));\n            } else if sid.is_quit() {\n                return Err(MatchError::quit(b, sp.end));\n            }\n        }\n        None => {\n            *sid = dfa\n                .next_eoi_state(cache, *sid)\n                .map_err(|_| gave_up(input.haystack().len()))?;\n            if sid.is_match() {\n                let pattern = dfa.match_pattern(cache, *sid, 0);\n                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));\n            }\n            debug_assert!(! sid.is_quit());\n        }\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n466 fn find_overlapping_fwd_imp(\n467     dfa: &DFA,\n468     cache: &mut Cache,\n469     input: &Input<'_>,\n470     pre: Option<&'_ Prefilter>,\n471     state: &mut OverlappingState,\n472 ) -> Result<(), MatchError> {\n473     // See 'prefilter_restart' docs for explanation.\n474     let universal_start = dfa.get_nfa().look_set_prefix_any().is_empty();\n475     let mut sid = match state.id {\n476         None => {\n477             state.at = input.start();\n478             init_fwd(dfa, cache, input)?\n479         }\n480         Some(sid) => {\n481             if let Some(match_index) = state.next_match_index {\n482                 let match_len = dfa.match_len(cache, sid);\n483                 if match_index < match_len {\n484                     state.next_match_index = Some(match_index + 1);\n485                     let pattern = dfa.match_pattern(cache, sid, match_index);\n486                     state.mat = Some(HalfMatch::new(pattern, state.at));\n487                     return Ok(());\n488                 }\n489             }\n490             // Once we've reported all matches at a given position, we need to\n491             // advance the search to the next position.\n492             state.at += 1;\n493             if state.at > input.end() {\n494                 return Ok(());\n495             }\n496             sid\n497         }\n498     };\n499 \n500     // NOTE: We don't optimize the crap out of this routine primarily because\n501     // it seems like most overlapping searches will have higher match counts,\n502     // and thus, throughput is perhaps not as important. But if you have a use\n503     // case for something faster, feel free to file an issue.\n504     cache.search_start(state.at);\n505     while state.at < input.end() {\n506         sid = dfa\n507             .next_state(cache, sid, input.haystack()[state.at])\n508             .map_err(|_| gave_up(state.at))?;\n509         if sid.is_tagged() {\n510             state.id = Some(sid);\n511             if sid.is_start() {\n512                 if let Some(ref pre) = pre {\n513                     let span = Span::from(state.at..input.end());\n514                     match pre.find(input.haystack(), span) {\n515                         None => return Ok(()),\n516                         Some(ref span) => {\n517                             if span.start > state.at {\n518                                 state.at = span.start;\n519                                 if !universal_start {\n520                                     sid = prefilter_restart(\n521                                         dfa, cache, &input, state.at,\n522                                     )?;\n523                                 }\n524                                 continue;\n525                             }\n526                         }\n527                     }\n528                 }\n529             } else if sid.is_match() {\n530                 state.next_match_index = Some(1);\n531                 let pattern = dfa.match_pattern(cache, sid, 0);\n532                 state.mat = Some(HalfMatch::new(pattern, state.at));\n533                 cache.search_finish(state.at);\n534                 return Ok(());\n535             } else if sid.is_dead() {\n536                 cache.search_finish(state.at);\n537                 return Ok(());\n538             } else if sid.is_quit() {\n539                 cache.search_finish(state.at);\n540                 return Err(MatchError::quit(\n541                     input.haystack()[state.at],\n542                     state.at,\n543                 ));\n544             } else {\n545                 debug_assert!(sid.is_unknown());\n546                 unreachable!(\"sid being unknown is a bug\");\n547             }\n548         }\n549         state.at += 1;\n550         cache.search_update(state.at);\n551     }\n552 \n553     let result = eoi_fwd(dfa, cache, input, &mut sid, &mut state.mat);\n554     state.id = Some(sid);\n555     if state.mat.is_some() {\n556         // '1' is always correct here since if we get to this point, this\n557         // always corresponds to the first (index '0') match discovered at\n558         // this position. So the next match to report at this position (if\n559         // it exists) is at index '1'.\n560         state.next_match_index = Some(1);\n561     }\n562     cache.search_finish(input.end());\n563     result\n564 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}