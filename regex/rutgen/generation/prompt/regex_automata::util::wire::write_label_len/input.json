{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/wire.rs\n// crate name is regex_automata\n#[cfg(target_endian = \"little\")]\npub(crate) type NE = LE;\n#[cfg(target_endian = \"big\")]\npub(crate) type NE = BE;\nuse core::{cmp, mem::size_of};\n#[cfg(feature = \"alloc\")]\nuse alloc::{vec, vec::Vec};\nuse crate::util::{\n    int::Pointer, primitives::{PatternID, PatternIDError, StateID, StateIDError},\n};\npub(crate) fn write_label_len(label: &str) -> usize {\n    if label.len() > 255 {\n        panic!(\"label must not be longer than 255 bytes\");\n    }\n    if label.as_bytes().iter().position(|&b| b == 0).is_some() {\n        panic!(\"label must not contain NUL bytes\");\n    }\n    let label_len = label.len() + 1;\n    label_len + padding_len(label_len)\n}\npub(crate) fn padding_len(non_padding_len: usize) -> usize {\n    (4 - (non_padding_len & 0b11)) & 0b11\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the total number of bytes (including padding) that would be written\n/// for the given label. This panics if the given label contains a NUL byte or\n/// is longer than 255 bytes. (The size restriction exists so that searching\n/// for a label during deserialization can be done in small bounded space.)\n480 pub(crate) fn write_label_len(label: &str) -> usize {\n481     if label.len() > 255 {\n482         panic!(\"label must not be longer than 255 bytes\");\n483     }\n484     if label.as_bytes().iter().position(|&b| b == 0).is_some() {\n485         panic!(\"label must not contain NUL bytes\");\n486     }\n487     let label_len = label.len() + 1; // +1 for the NUL terminator\n488     label_len + padding_len(label_len)\n489 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}