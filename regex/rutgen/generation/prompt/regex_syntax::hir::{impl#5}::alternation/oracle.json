{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Properties(Box<PropertiesI>);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum HirKind {\n    /// The empty regular expression, which matches everything, including the\n    /// empty string.\n    Empty,\n    /// A literalstring that matches exactly these bytes.\n    Literal(Literal),\n    /// A single character class that matches any of the characters in the\n    /// class. A class can either consist of Unicode scalar values as\n    /// characters, or it can use bytes.\n    ///\n    /// A class may be empty. In which case, it matches nothing.\n    Class(Class),\n    /// A look-around assertion. A look-around match always has zero length.\n    Look(Look),\n    /// A repetition operation applied to a sub-expression.\n    Repetition(Repetition),\n    /// A capturing group, which contains a sub-expression.\n    Capture(Capture),\n    /// A concatenation of expressions.\n    ///\n    /// A concatenation matches only if each of its sub-expressions match one\n    /// after the other.\n    ///\n    /// Concatenations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Concat(Vec<Hir>),\n    /// An alternation of expressions.\n    ///\n    /// An alternation matches only if at least one of its sub-expressions\n    /// match. If multiple sub-expressions match, then the leftmost is\n    /// preferred.\n    ///\n    /// Alternations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Alternation(Vec<Hir>),\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum Class {\n    /// A set of characters represented by Unicode scalar values.\n    Unicode(ClassUnicode),\n    /// A set of characters represented by arbitrary bytes (one byte per\n    /// character).\n    Bytes(ClassBytes),\n}\nimpl Hir {\n    #[inline]\n    pub fn empty() -> Hir {}\n    #[inline]\n    pub fn fail() -> Hir {\n        let class = Class::Bytes(ClassBytes::empty());\n        let props = Properties::class(&class);\n        Hir {\n            kind: HirKind::Class(class),\n            props,\n        }\n    }\n    #[inline]\n    pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir {}\n    #[inline]\n    pub fn class(class: Class) -> Hir {\n        if class.is_empty() {\n            return Hir::fail();\n        } else if let Some(bytes) = class.literal() {\n            return Hir::literal(bytes);\n        }\n        let props = Properties::class(&class);\n        Hir {\n            kind: HirKind::Class(class),\n            props,\n        }\n    }\n    #[inline]\n    pub fn look(look: Look) -> Hir {}\n    #[inline]\n    pub fn repetition(mut rep: Repetition) -> Hir {}\n    #[inline]\n    pub fn capture(capture: Capture) -> Hir {}\n    pub fn concat(subs: Vec<Hir>) -> Hir {}\n    pub fn alternation(subs: Vec<Hir>) -> Hir {\n        let mut new = Vec::with_capacity(subs.len());\n        for sub in subs {\n            let (kind, props) = sub.into_parts();\n            match kind {\n                HirKind::Alternation(subs2) => {\n                    new.extend(subs2);\n                }\n                kind => {\n                    new.push(Hir { kind, props });\n                }\n            }\n        }\n        if new.is_empty() {\n            return Hir::fail();\n        } else if new.len() == 1 {\n            return new.pop().unwrap();\n        }\n        if let Some(singletons) = singleton_chars(&new) {\n            let it = singletons\n                .into_iter()\n                .map(|ch| ClassUnicodeRange {\n                    start: ch,\n                    end: ch,\n                });\n            return Hir::class(Class::Unicode(ClassUnicode::new(it)));\n        }\n        if let Some(singletons) = singleton_bytes(&new) {\n            let it = singletons\n                .into_iter()\n                .map(|b| ClassBytesRange {\n                    start: b,\n                    end: b,\n                });\n            return Hir::class(Class::Bytes(ClassBytes::new(it)));\n        }\n        if let Some(cls) = class_chars(&new) {\n            return Hir::class(cls);\n        }\n        if let Some(cls) = class_bytes(&new) {\n            return Hir::class(cls);\n        }\n        new = match lift_common_prefix(new) {\n            Ok(hir) => return hir,\n            Err(unchanged) => unchanged,\n        };\n        let props = Properties::alternation(&new);\n        Hir {\n            kind: HirKind::Alternation(new),\n            props,\n        }\n    }\n    #[inline]\n    pub fn dot(dot: Dot) -> Hir {}\n}\nimpl Properties {\n    fn empty() -> Properties {}\n    fn literal(lit: &Literal) -> Properties {}\n    fn class(class: &Class) -> Properties {}\n    fn look(look: Look) -> Properties {}\n    fn repetition(rep: &Repetition) -> Properties {}\n    fn capture(capture: &Capture) -> Properties {}\n    fn concat(concat: &[Hir]) -> Properties {}\n    fn alternation(alts: &[Hir]) -> Properties {\n        Properties::union(alts.iter().map(|hir| hir.properties()))\n    }\n}\nfn singleton_bytes(hirs: &[Hir]) -> Option<Vec<u8>> {\n    let mut singletons = vec![];\n    for hir in hirs.iter() {\n        let literal = match *hir.kind() {\n            HirKind::Literal(Literal(ref bytes)) => bytes,\n            _ => return None,\n        };\n        if literal.len() != 1 {\n            return None;\n        }\n        singletons.push(literal[0]);\n    }\n    Some(singletons)\n}\nfn lift_common_prefix(hirs: Vec<Hir>) -> Result<Hir, Vec<Hir>> {\n    if hirs.len() <= 1 {\n        return Err(hirs);\n    }\n    let mut prefix = match hirs[0].kind() {\n        HirKind::Concat(ref xs) => &**xs,\n        _ => return Err(hirs),\n    };\n    if prefix.is_empty() {\n        return Err(hirs);\n    }\n    for h in hirs.iter().skip(1) {\n        let concat = match h.kind() {\n            HirKind::Concat(ref xs) => xs,\n            _ => return Err(hirs),\n        };\n        let common_len = prefix\n            .iter()\n            .zip(concat.iter())\n            .take_while(|(x, y)| x == y)\n            .count();\n        prefix = &prefix[..common_len];\n        if prefix.is_empty() {\n            return Err(hirs);\n        }\n    }\n    let len = prefix.len();\n    assert_ne!(0, len);\n    let mut prefix_concat = vec![];\n    let mut suffix_alts = vec![];\n    for h in hirs {\n        let mut concat = match h.into_kind() {\n            HirKind::Concat(xs) => xs,\n            _ => unreachable!(),\n        };\n        suffix_alts.push(Hir::concat(concat.split_off(len)));\n        if prefix_concat.is_empty() {\n            prefix_concat = concat;\n        }\n    }\n    let mut concat = prefix_concat;\n    concat.push(Hir::alternation(suffix_alts));\n    Ok(Hir::concat(concat))\n}\nfn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>> {\n    let mut singletons = vec![];\n    for hir in hirs.iter() {\n        let literal = match *hir.kind() {\n            HirKind::Literal(Literal(ref bytes)) => bytes,\n            _ => return None,\n        };\n        let ch = match crate::debug::utf8_decode(literal) {\n            None => return None,\n            Some(Err(_)) => return None,\n            Some(Ok(ch)) => ch,\n        };\n        if literal.len() != ch.len_utf8() {\n            return None;\n        }\n        singletons.push(ch);\n    }\n    Some(singletons)\n}\nfn class_chars(hirs: &[Hir]) -> Option<Class> {\n    let mut cls = ClassUnicode::new(vec![]);\n    for hir in hirs.iter() {\n        match *hir.kind() {\n            HirKind::Class(Class::Unicode(ref cls2)) => {\n                cls.union(cls2);\n            }\n            HirKind::Class(Class::Bytes(ref cls2)) => {\n                cls.union(&cls2.to_unicode_class()?);\n            }\n            _ => return None,\n        };\n    }\n    Some(Class::Unicode(cls))\n}\nfn class_bytes(hirs: &[Hir]) -> Option<Class> {\n    let mut cls = ClassBytes::new(vec![]);\n    for hir in hirs.iter() {\n        match *hir.kind() {\n            HirKind::Class(Class::Unicode(ref cls2)) => {\n                cls.union(&cls2.to_byte_class()?);\n            }\n            HirKind::Class(Class::Bytes(ref cls2)) => {\n                cls.union(cls2);\n            }\n            _ => return None,\n        };\n    }\n    Some(Class::Bytes(cls))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the alternation of the given expressions.\n///\n/// This flattens and simplifies the alternation as appropriate. This may\n/// include factoring out common prefixes or even rewriting the alternation\n/// as a character class.\n///\n/// Note that an empty alternation is equivalent to `Hir::fail()`. (It\n/// is not possible for one to write an empty alternation, or even an\n/// alternation with a single sub-expression, in the concrete syntax of a\n/// regex.)\n///\n/// # Example\n///\n/// This is a simple example showing how an alternation might get\n/// simplified.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};\n///\n/// let hir = Hir::alternation(vec![\n///     Hir::literal([b'a']),\n///     Hir::literal([b'b']),\n///     Hir::literal([b'c']),\n///     Hir::literal([b'd']),\n///     Hir::literal([b'e']),\n///     Hir::literal([b'f']),\n/// ]);\n/// let expected = Hir::class(Class::Unicode(ClassUnicode::new([\n///     ClassUnicodeRange::new('a', 'f'),\n/// ])));\n/// assert_eq!(expected, hir);\n/// ```\n///\n/// And another example showing how common prefixes might get factored\n/// out.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};\n///\n/// let hir = Hir::alternation(vec![\n///     Hir::concat(vec![\n///         Hir::literal(\"abc\".as_bytes()),\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('A', 'Z'),\n///         ]))),\n///     ]),\n///     Hir::concat(vec![\n///         Hir::literal(\"abc\".as_bytes()),\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('a', 'z'),\n///         ]))),\n///     ]),\n/// ]);\n/// let expected = Hir::concat(vec![\n///     Hir::literal(\"abc\".as_bytes()),\n///     Hir::alternation(vec![\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('A', 'Z'),\n///         ]))),\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('a', 'z'),\n///         ]))),\n///     ]),\n/// ]);\n/// assert_eq!(expected, hir);\n/// ```\n///\n/// Note that these sorts of simplifications are not guaranteed.\n572 pub fn alternation(subs: Vec<Hir>) -> Hir {\n573     // We rebuild the alternation by simplifying it. We proceed similarly\n574     // as the concatenation case. But in this case, there's no literal\n575     // simplification happening. We're just flattening alternations.\n576     let mut new = Vec::with_capacity(subs.len());\n577     for sub in subs {\n578         let (kind, props) = sub.into_parts();\n579         match kind {\n580             HirKind::Alternation(subs2) => {\n581                 new.extend(subs2);\n582             }\n583             kind => {\n584                 new.push(Hir { kind, props });\n585             }\n586         }\n587     }\n588     if new.is_empty() {\n589         return Hir::fail();\n590     } else if new.len() == 1 {\n591         return new.pop().unwrap();\n592     }\n593     // Now that it's completely flattened, look for the special case of\n594     // 'char1|char2|...|charN' and collapse that into a class. Note that\n595     // we look for 'char' first and then bytes. The issue here is that if\n596     // we find both non-ASCII codepoints and non-ASCII singleton bytes,\n597     // then it isn't actually possible to smush them into a single class.\n598     // (Because classes are either \"all codepoints\" or \"all bytes.\" You\n599     // can have a class that both matches non-ASCII but valid UTF-8 and\n600     // invalid UTF-8.) So we look for all chars and then all bytes, and\n601     // don't handle anything else.\n602     if let Some(singletons) = singleton_chars(&new) {\n603         let it = singletons\n604             .into_iter()\n605             .map(|ch| ClassUnicodeRange { start: ch, end: ch });\n606         return Hir::class(Class::Unicode(ClassUnicode::new(it)));\n607     }\n608     if let Some(singletons) = singleton_bytes(&new) {\n609         let it = singletons\n610             .into_iter()\n611             .map(|b| ClassBytesRange { start: b, end: b });\n612         return Hir::class(Class::Bytes(ClassBytes::new(it)));\n613     }\n614     // Similar to singleton chars, we can also look for alternations of\n615     // classes. Those can be smushed into a single class.\n616     if let Some(cls) = class_chars(&new) {\n617         return Hir::class(cls);\n618     }\n619     if let Some(cls) = class_bytes(&new) {\n620         return Hir::class(cls);\n621     }\n622     // Factor out a common prefix if we can, which might potentially\n623     // simplify the expression and unlock other optimizations downstream.\n624     // It also might generally make NFA matching and DFA construction\n625     // faster by reducing the scope of branching in the regex.\n626     new = match lift_common_prefix(new) {\n627         Ok(hir) => return hir,\n628         Err(unchanged) => unchanged,\n629     };\n630     let props = Properties::alternation(&new);\n631     Hir { kind: HirKind::Alternation(new), props }\n632 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}