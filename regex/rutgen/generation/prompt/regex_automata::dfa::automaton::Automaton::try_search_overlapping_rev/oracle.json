{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        search::find_overlapping_rev(self, input, state)?;\n        match state.get_match() {\n            None => Ok(()),\n            Some(_) if !utf8empty => Ok(()),\n            Some(_) => {\n                skip_empty_utf8_splits_overlapping(\n                    input,\n                    state,\n                    |input, state| { search::find_overlapping_rev(self, input, state) },\n                )\n            }\n        }\n    }\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct OverlappingState {\n    /// The match reported by the most recent overlapping search to use this\n    /// state.\n    ///\n    /// If a search does not find any matches, then it is expected to clear\n    /// this value.\n    pub(crate) mat: Option<HalfMatch>,\n    /// The state ID of the state at which the search was in when the call\n    /// terminated. When this is a match state, `last_match` must be set to a\n    /// non-None value.\n    ///\n    /// A `None` value indicates the start state of the corresponding\n    /// automaton. We cannot use the actual ID, since any one automaton may\n    /// have many start states, and which one is in use depends on several\n    /// search-time factors.\n    pub(crate) id: Option<StateID>,\n    /// The position of the search.\n    ///\n    /// When `id` is None (i.e., we are starting a search), this is set to\n    /// the beginning of the search as given by the caller regardless of its\n    /// current value. Subsequent calls to an overlapping search pick up at\n    /// this offset.\n    pub(crate) at: usize,\n    /// The index into the matching patterns of the next match to report if the\n    /// current state is a match state. Note that this may be 1 greater than\n    /// the total number of matches to report for the current match state. (In\n    /// which case, no more matches should be reported at the current position\n    /// and the search should advance to the next position.)\n    pub(crate) next_match_index: Option<usize>,\n    /// This is set to true when a reverse overlapping search has entered its\n    /// EOI transitions.\n    ///\n    /// This isn't used in a forward search because it knows to stop once the\n    /// position exceeds the end of the search range. In a reverse search,\n    /// since we use unsigned offsets, we don't \"know\" once we've gone past\n    /// `0`. So the only way to detect it is with this extra flag. The reverse\n    /// overlapping search knows to terminate specifically after it has\n    /// reported all matches after following the EOI transition.\n    pub(crate) rev_eoi: bool,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\nimpl OverlappingState {\n    pub fn start() -> OverlappingState {}\n    pub fn get_match(&self) -> Option<HalfMatch> {\n        self.mat\n    }\n}\n#[inline(never)]\npub(crate) fn find_overlapping_rev<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    state: &mut OverlappingState,\n) -> Result<(), MatchError> {\n    state.mat = None;\n    if input.is_done() {\n        return Ok(());\n    }\n    let mut sid = match state.id {\n        None => {\n            let sid = init_rev(dfa, input)?;\n            state.id = Some(sid);\n            if input.start() == input.end() {\n                state.rev_eoi = true;\n            } else {\n                state.at = input.end() - 1;\n            }\n            sid\n        }\n        Some(sid) => {\n            if let Some(match_index) = state.next_match_index {\n                let match_len = dfa.match_len(sid);\n                if match_index < match_len {\n                    state.next_match_index = Some(match_index + 1);\n                    let pattern = dfa.match_pattern(sid, match_index);\n                    state.mat = Some(HalfMatch::new(pattern, state.at));\n                    return Ok(());\n                }\n            }\n            if state.rev_eoi {\n                return Ok(());\n            } else if state.at == input.start() {\n                state.rev_eoi = true;\n            } else {\n                state.at -= 1;\n            }\n            sid\n        }\n    };\n    while !state.rev_eoi {\n        sid = dfa.next_state(sid, input.haystack()[state.at]);\n        if dfa.is_special_state(sid) {\n            state.id = Some(sid);\n            if dfa.is_start_state(sid) {\n                if dfa.is_accel_state(sid) {\n                    let needles = dfa.accelerator(sid);\n                    state.at = accel::find_rev(needles, input.haystack(), state.at)\n                        .map(|i| i + 1)\n                        .unwrap_or(input.start());\n                }\n            } else if dfa.is_match_state(sid) {\n                state.next_match_index = Some(1);\n                let pattern = dfa.match_pattern(sid, 0);\n                state.mat = Some(HalfMatch::new(pattern, state.at + 1));\n                return Ok(());\n            } else if dfa.is_accel_state(sid) {\n                let needles = dfa.accelerator(sid);\n                state.at = accel::find_rev(needles, input.haystack(), state.at)\n                    .map(|i| i + 1)\n                    .unwrap_or(input.start());\n            } else if dfa.is_dead_state(sid) {\n                return Ok(());\n            } else {\n                return Err(MatchError::quit(input.haystack()[state.at], state.at));\n            }\n        }\n        if state.at == input.start() {\n            break;\n        }\n        state.at -= 1;\n    }\n    let result = eoi_rev(dfa, input, &mut sid, &mut state.mat);\n    state.rev_eoi = true;\n    state.id = Some(sid);\n    if state.mat.is_some() {\n        state.next_match_index = Some(1);\n    }\n    result\n}\n#[cold]\n#[inline(never)]\nfn skip_empty_utf8_splits_overlapping<F>(\n    input: &Input<'_>,\n    state: &mut OverlappingState,\n    mut search: F,\n) -> Result<(), MatchError>\nwhere\n    F: FnMut(&Input<'_>, &mut OverlappingState) -> Result<(), MatchError>,\n{\n    let mut hm = match state.get_match() {\n        None => return Ok(()),\n        Some(hm) => hm,\n    };\n    if input.get_anchored().is_anchored() {\n        if !input.is_char_boundary(hm.offset()) {\n            state.mat = None;\n        }\n        return Ok(());\n    }\n    while !input.is_char_boundary(hm.offset()) {\n        search(input, state)?;\n        hm = match state.get_match() {\n            None => return Ok(()),\n            Some(hm) => hm,\n        };\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes a reverse overlapping forward search. Matches, if one exists,\n/// can be obtained via the [`OverlappingState::get_match`] method.\n///\n/// When using this routine to implement an iterator of overlapping\n/// matches, the `start` of the search should remain invariant throughout\n/// iteration. The `OverlappingState` given to the search will keep track\n/// of the current position of the search. (This is because multiple\n/// matches may be reported at the same position, so only the search\n/// implementation itself knows when to advance the position.)\n///\n/// If for some reason you want the search to forget about its previous\n/// state and restart the search at a particular position, then setting the\n/// state to [`OverlappingState::start`] will accomplish that.\n///\n/// # Errors\n///\n/// This routine errors if the search could not complete. This can occur\n/// in a number of circumstances:\n///\n/// * The configuration of the DFA may permit it to \"quit\" the search.\n/// For example, setting quit bytes or enabling heuristic support for\n/// Unicode word boundaries. The default configuration does not enable any\n/// option that could result in the DFA quitting.\n/// * When the provided `Input` configuration is not supported. For\n/// example, by providing an unsupported anchor mode.\n///\n/// When a search returns an error, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example: UTF-8 mode\n///\n/// This examples demonstrates that UTF-8 mode applies to reverse\n/// DFAs. When UTF-8 mode is enabled in the underlying NFA, then all\n/// matches reported must correspond to valid UTF-8 spans. This includes\n/// prohibiting zero-width matches that split a codepoint.\n///\n/// UTF-8 mode is enabled by default. Notice below how the only zero-width\n/// matches reported are those at UTF-8 boundaries:\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense::DFA, Automaton, OverlappingState},\n///     nfa::thompson,\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .configure(DFA::config().match_kind(MatchKind::All))\n///     .thompson(thompson::Config::new().reverse(true))\n///     .build_many(&[r\"\", r\"笘ソ"])?;\n///\n/// // Run the reverse DFA to collect all matches.\n/// let input = Input::new(\"笘ソ");\n/// let mut state = OverlappingState::start();\n/// let mut matches = vec![];\n/// loop {\n///     dfa.try_search_overlapping_rev(&input, &mut state)?;\n///     match state.get_match() {\n///         None => break,\n///         Some(hm) => matches.push(hm),\n///     }\n/// }\n///\n/// // No matches split a codepoint.\n/// let expected = vec![\n///     HalfMatch::must(0, 3),\n///     HalfMatch::must(1, 0),\n///     HalfMatch::must(0, 0),\n/// ];\n/// assert_eq!(expected, matches);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// Now let's look at the same example, but with UTF-8 mode on the\n/// original NFA disabled (which results in disabling UTF-8 mode on the\n/// DFA):\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense::DFA, Automaton, OverlappingState},\n///     nfa::thompson,\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .configure(DFA::config().match_kind(MatchKind::All))\n///     .thompson(thompson::Config::new().reverse(true).utf8(false))\n///     .build_many(&[r\"\", r\"笘ソ"])?;\n///\n/// // Run the reverse DFA to collect all matches.\n/// let input = Input::new(\"笘ソ");\n/// let mut state = OverlappingState::start();\n/// let mut matches = vec![];\n/// loop {\n///     dfa.try_search_overlapping_rev(&input, &mut state)?;\n///     match state.get_match() {\n///         None => break,\n///         Some(hm) => matches.push(hm),\n///     }\n/// }\n///\n/// // Now *all* positions match, even within a codepoint,\n/// // because we lifted the requirement that matches\n/// // correspond to valid UTF-8 spans.\n/// let expected = vec![\n///     HalfMatch::must(0, 3),\n///     HalfMatch::must(0, 2),\n///     HalfMatch::must(0, 1),\n///     HalfMatch::must(1, 0),\n///     HalfMatch::must(0, 0),\n/// ];\n/// assert_eq!(expected, matches);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1719 fn try_search_overlapping_rev(\n1720     &self,\n1721     input: &Input<'_>,\n1722     state: &mut OverlappingState,\n1723 ) -> Result<(), MatchError> {\n1724     let utf8empty = self.has_empty() && self.is_utf8();\n1725     search::find_overlapping_rev(self, input, state)?;\n1726     match state.get_match() {\n1727         None => Ok(()),\n1728         Some(_) if !utf8empty => Ok(()),\n1729         Some(_) => skip_empty_utf8_splits_overlapping(\n1730             input,\n1731             state,\n1732             |input, state| {\n1733                 search::find_overlapping_rev(self, input, state)\n1734             },\n1735         ),\n1736     }\n1737 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}