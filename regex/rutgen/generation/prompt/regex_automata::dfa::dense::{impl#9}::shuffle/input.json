{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/dense.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\npub(crate) type OwnedDFA = DFA<alloc::vec::Vec<u32>>;\n#[cfg(feature = \"dfa-build\")]\nuse core::cmp;\nuse core::{fmt, iter, mem::size_of, slice};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{\n    collections::{BTreeMap, BTreeSet},\n    vec, vec::Vec,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::{\n    dfa::{accel::Accel, determinize, minimize::Minimizer, remapper::Remapper, sparse},\n    nfa::thompson, util::{look::LookMatcher, search::MatchKind},\n};\nuse crate::{\n    dfa::{\n        accel::Accels, automaton::{fmt_state_indicator, Automaton, StartError},\n        special::Special, start::StartKind, DEAD,\n    },\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        int::{Pointer, Usize},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-dense\";\nconst VERSION: u32 = 2;\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\npub(crate) trait U16 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn high_u8(self) -> u8;\n}\npub(crate) trait U32 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn high_u16(self) -> u16;\n}\npub(crate) trait Usize {\n    fn as_u8(self) -> u8;\n    fn as_u16(self) -> u16;\n    fn as_u32(self) -> u32;\n    fn as_u64(self) -> u64;\n}\npub(crate) trait U8 {\n    fn as_usize(self) -> usize;\n}\npub(crate) trait U64 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn low_u32(self) -> u32;\n    fn high_u32(self) -> u32;\n}\npub(crate) trait I32 {\n    fn as_usize(self) -> usize;\n    fn to_bits(self) -> u32;\n    fn from_bits(n: u32) -> i32;\n}\npub(crate) trait Pointer {\n    fn as_usize(self) -> usize;\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Debug)]\npub(super) struct Remapper {\n    /// A map from the index of a state to its pre-multiplied identifier.\n    ///\n    /// When a state is swapped with another, then their corresponding\n    /// locations in this map are also swapped. Thus, its new position will\n    /// still point to its old pre-multiplied StateID.\n    ///\n    /// While there is a bit more to it, this then allows us to rewrite the\n    /// state IDs in a DFA's transition table in a single pass. This is done\n    /// by iterating over every ID in this map, then iterating over each\n    /// transition for the state at that ID and re-mapping the transition from\n    /// `old_id` to `map[dfa.to_index(old_id)]`. That is, we find the position\n    /// in this map where `old_id` *started*, and set it to where it ended up\n    /// after all swaps have been completed.\n    map: Vec<StateID>,\n    /// A mapper from state index to state ID (and back).\n    idxmap: IndexMapper,\n}\npub(crate) struct StartStateIter<'a> {\n    st: StartTable<&'a [u32]>,\n    i: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Start {\n    /// This occurs when the starting position is not any of the ones below.\n    NonWordByte = 0,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is an ASCII word byte.\n    WordByte = 1,\n    /// This occurs when the starting position of the search corresponds to the\n    /// beginning of the haystack.\n    Text = 2,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\n`.\n    LineLF = 3,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\r`.\n    LineCR = 4,\n    /// This occurs when a custom line terminator has been set via a\n    /// `LookMatcher`, and when that line terminator is neither a `\\r` or a\n    /// `\\n`.\n    ///\n    /// If the custom line terminator is a word byte, then this start\n    /// configuration is still selected. DFAs that implement word boundary\n    /// assertions will likely need to check whether the custom line terminator\n    /// is a word byte, in which case, it should behave as if the byte\n    /// satisfies `\\b` in addition to multi-line anchors.\n    CustomLineTerminator = 5,\n}\n#[cfg(feature = \"dfa-build\")]\nimpl OwnedDFA {\n    pub(crate) fn set_start_state(\n        &mut self,\n        anchored: Anchored,\n        start: Start,\n        id: StateID,\n    ) {}\n    pub(crate) fn set_transition(\n        &mut self,\n        from: StateID,\n        byte: alphabet::Unit,\n        to: StateID,\n    ) {}\n    pub(crate) fn add_empty_state(&mut self) -> Result<StateID, BuildError> {}\n    pub(crate) fn swap_states(&mut self, id1: StateID, id2: StateID) {}\n    pub(crate) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {}\n    pub(crate) fn remap_state(&mut self, id: StateID, map: impl Fn(StateID) -> StateID) {}\n    pub(crate) fn truncate_states(&mut self, len: usize) {}\n    pub(crate) fn minimize(&mut self) {}\n    pub(crate) fn set_pattern_map(\n        &mut self,\n        map: &BTreeMap<StateID, Vec<PatternID>>,\n    ) -> Result<(), BuildError> {}\n    pub(crate) fn accelerate(&mut self) {}\n    pub(crate) fn shuffle(\n        &mut self,\n        mut matches: BTreeMap<StateID, Vec<PatternID>>,\n    ) -> Result<(), BuildError> {\n        self.special.quit_id = self.to_state_id(1);\n        if self.state_len() <= 2 {\n            self.special.set_max();\n            return Ok(());\n        }\n        let mut is_start: BTreeSet<StateID> = BTreeSet::new();\n        for (start_id, _, _) in self.starts() {\n            if start_id == DEAD {\n                continue;\n            }\n            assert!(\n                ! matches.contains_key(& start_id),\n                \"{:?} is both a start and a match state, which is not allowed\", start_id,\n            );\n            is_start.insert(start_id);\n        }\n        let mut remapper = Remapper::new(self);\n        if matches.is_empty() {\n            self.special.min_match = DEAD;\n            self.special.max_match = DEAD;\n        } else {\n            let mut next_id = self.to_state_id(2);\n            let mut new_matches = BTreeMap::new();\n            self.special.min_match = next_id;\n            for (id, pids) in matches {\n                remapper.swap(self, next_id, id);\n                new_matches.insert(next_id, pids);\n                if is_start.contains(&next_id) {\n                    is_start.remove(&next_id);\n                    is_start.insert(id);\n                }\n                next_id = self.tt.next_state_id(next_id);\n            }\n            matches = new_matches;\n            self.special.max_match = cmp::max(\n                self.special.min_match,\n                self.tt.prev_state_id(next_id),\n            );\n        }\n        {\n            let mut next_id = self.to_state_id(2);\n            if self.special.matches() {\n                next_id = self.tt.next_state_id(self.special.max_match);\n            }\n            self.special.min_start = next_id;\n            for id in is_start {\n                remapper.swap(self, next_id, id);\n                next_id = self.tt.next_state_id(next_id);\n            }\n            self.special.max_start = cmp::max(\n                self.special.min_start,\n                self.tt.prev_state_id(next_id),\n            );\n        }\n        remapper.remap(self);\n        self.set_pattern_map(&matches)?;\n        self.special.set_max();\n        self.special.validate().expect(\"special state ranges should validate\");\n        self.special\n            .validate_state_len(self.state_len(), self.stride2())\n            .expect(\"special state ranges should be consistent with state length\");\n        Ok(())\n    }\n    fn set_universal_starts(&mut self) {}\n}\nimpl Special {\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn new() -> Special {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {}\n    pub(crate) fn from_bytes(\n        mut slice: &[u8],\n    ) -> Result<(Special, usize), DeserializeError> {}\n    pub(crate) fn validate(&self) -> Result<(), DeserializeError> {\n        if self.min_match == DEAD && self.max_match != DEAD {\n            err!(\"min_match is DEAD, but max_match is not\");\n        }\n        if self.min_match != DEAD && self.max_match == DEAD {\n            err!(\"max_match is DEAD, but min_match is not\");\n        }\n        if self.min_accel == DEAD && self.max_accel != DEAD {\n            err!(\"min_accel is DEAD, but max_accel is not\");\n        }\n        if self.min_accel != DEAD && self.max_accel == DEAD {\n            err!(\"max_accel is DEAD, but min_accel is not\");\n        }\n        if self.min_start == DEAD && self.max_start != DEAD {\n            err!(\"min_start is DEAD, but max_start is not\");\n        }\n        if self.min_start != DEAD && self.max_start == DEAD {\n            err!(\"max_start is DEAD, but min_start is not\");\n        }\n        if self.min_match > self.max_match {\n            err!(\"min_match should not be greater than max_match\");\n        }\n        if self.min_accel > self.max_accel {\n            err!(\"min_accel should not be greater than max_accel\");\n        }\n        if self.min_start > self.max_start {\n            err!(\"min_start should not be greater than max_start\");\n        }\n        if self.matches() && self.quit_id >= self.min_match {\n            err!(\"quit_id should not be greater than min_match\");\n        }\n        if self.accels() && self.quit_id >= self.min_accel {\n            err!(\"quit_id should not be greater than min_accel\");\n        }\n        if self.starts() && self.quit_id >= self.min_start {\n            err!(\"quit_id should not be greater than min_start\");\n        }\n        if self.matches() && self.accels() && self.min_accel < self.min_match {\n            err!(\"min_match should not be greater than min_accel\");\n        }\n        if self.matches() && self.starts() && self.min_start < self.min_match {\n            err!(\"min_match should not be greater than min_start\");\n        }\n        if self.accels() && self.starts() && self.min_start < self.min_accel {\n            err!(\"min_accel should not be greater than min_start\");\n        }\n        if self.max < self.quit_id {\n            err!(\"quit_id should not be greater than max\");\n        }\n        if self.max < self.max_match {\n            err!(\"max_match should not be greater than max\");\n        }\n        if self.max < self.max_accel {\n            err!(\"max_accel should not be greater than max\");\n        }\n        if self.max < self.max_start {\n            err!(\"max_start should not be greater than max\");\n        }\n        Ok(())\n    }\n    pub(crate) fn validate_state_len(\n        &self,\n        len: usize,\n        stride2: usize,\n    ) -> Result<(), DeserializeError> {\n        if (self.max.as_usize() >> stride2) >= len {\n            err!(\"max should not be greater than or equal to state length\");\n        }\n        Ok(())\n    }\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_max(&mut self) {\n        use core::cmp::max;\n        self.max = max(\n            self.quit_id,\n            max(self.max_match, max(self.max_accel, self.max_start)),\n        );\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_no_special_start_states(&mut self) {}\n    #[inline]\n    pub(crate) fn is_special_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_dead_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_quit_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_match_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_accel_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_start_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn match_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn matches(&self) -> bool {\n        self.min_match != DEAD\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn accel_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn accels(&self) -> bool {}\n    #[inline]\n    pub(crate) fn starts(&self) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Shuffle the states in this DFA so that starting states, match\n/// states and accelerated states are all contiguous.\n///\n/// See dfa/special.rs for more details.\n2799 pub(crate) fn shuffle(\n2800     &mut self,\n2801     mut matches: BTreeMap<StateID, Vec<PatternID>>,\n2802 ) -> Result<(), BuildError> {\n2803     // The determinizer always adds a quit state and it is always second.\n2804     self.special.quit_id = self.to_state_id(1);\n2805     // If all we have are the dead and quit states, then we're done and\n2806     // the DFA will never produce a match.\n2807     if self.state_len() <= 2 {\n2808         self.special.set_max();\n2809         return Ok(());\n2810     }\n2811 \n2812     // Collect all our non-DEAD start states into a convenient set and\n2813     // confirm there is no overlap with match states. In the classicl DFA\n2814     // construction, start states can be match states. But because of\n2815     // look-around, we delay all matches by a byte, which prevents start\n2816     // states from being match states.\n2817     let mut is_start: BTreeSet<StateID> = BTreeSet::new();\n2818     for (start_id, _, _) in self.starts() {\n2819         // If a starting configuration points to a DEAD state, then we\n2820         // don't want to shuffle it. The DEAD state is always the first\n2821         // state with ID=0. So we can just leave it be.\n2822         if start_id == DEAD {\n2823             continue;\n2824         }\n2825         assert!(\n2826             !matches.contains_key(&start_id),\n2827             \"{:?} is both a start and a match state, which is not allowed\",\n2828             start_id,\n2829         );\n2830         is_start.insert(start_id);\n2831     }\n2832 \n2833     // We implement shuffling by a sequence of pairwise swaps of states.\n2834     // Since we have a number of things referencing states via their\n2835     // IDs and swapping them changes their IDs, we need to record every\n2836     // swap we make so that we can remap IDs. The remapper handles this\n2837     // book-keeping for us.\n2838     let mut remapper = Remapper::new(self);\n2839 \n2840     // Shuffle matching states.\n2841     if matches.is_empty() {\n2842         self.special.min_match = DEAD;\n2843         self.special.max_match = DEAD;\n2844     } else {\n2845         // The determinizer guarantees that the first two states are the\n2846         // dead and quit states, respectively. We want our match states to\n2847         // come right after quit.\n2848         let mut next_id = self.to_state_id(2);\n2849         let mut new_matches = BTreeMap::new();\n2850         self.special.min_match = next_id;\n2851         for (id, pids) in matches {\n2852             remapper.swap(self, next_id, id);\n2853             new_matches.insert(next_id, pids);\n2854             // If we swapped a start state, then update our set.\n2855             if is_start.contains(&next_id) {\n2856                 is_start.remove(&next_id);\n2857                 is_start.insert(id);\n2858             }\n2859             next_id = self.tt.next_state_id(next_id);\n2860         }\n2861         matches = new_matches;\n2862         self.special.max_match = cmp::max(\n2863             self.special.min_match,\n2864             self.tt.prev_state_id(next_id),\n2865         );\n2866     }\n2867 \n2868     // Shuffle starting states.\n2869     {\n2870         let mut next_id = self.to_state_id(2);\n2871         if self.special.matches() {\n2872             next_id = self.tt.next_state_id(self.special.max_match);\n2873         }\n2874         self.special.min_start = next_id;\n2875         for id in is_start {\n2876             remapper.swap(self, next_id, id);\n2877             next_id = self.tt.next_state_id(next_id);\n2878         }\n2879         self.special.max_start = cmp::max(\n2880             self.special.min_start,\n2881             self.tt.prev_state_id(next_id),\n2882         );\n2883     }\n2884 \n2885     // Finally remap all transitions in our DFA.\n2886     remapper.remap(self);\n2887     self.set_pattern_map(&matches)?;\n2888     self.special.set_max();\n2889     self.special.validate().expect(\"special state ranges should validate\");\n2890     self.special\n2891         .validate_state_len(self.state_len(), self.stride2())\n2892         .expect(\n2893             \"special state ranges should be consistent with state length\",\n2894         );\n2895     Ok(())\n2896 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}