{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        let hm = match search::find_rev(self, input)? {\n            None => return Ok(None),\n            Some(hm) if !utf8empty => return Ok(Some(hm)),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_rev(\n            input,\n            hm,\n            hm.offset(),\n            |input| {\n                let got = search::find_rev(self, input)?;\n                Ok(got.map(|hm| (hm, hm.offset())))\n            },\n        )\n    }\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {\n        self.offset\n    }\n}\n#[inline(never)]\npub fn find_rev<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n) -> Result<Option<HalfMatch>, MatchError> {\n    if input.is_done() {\n        return Ok(None);\n    }\n    if input.get_earliest() {\n        find_rev_imp(dfa, input, true)\n    } else {\n        find_rev_imp(dfa, input, false)\n    }\n}\n#[cold]\n#[inline(never)]\npub(crate) fn skip_splits_rev<T, F>(\n    input: &Input<'_>,\n    init_value: T,\n    match_offset: usize,\n    find: F,\n) -> Result<Option<T>, MatchError>\nwhere\n    F: FnMut(&Input<'_>) -> Result<Option<(T, usize)>, MatchError>,\n{\n    skip_splits(false, input, init_value, match_offset, find)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes a reverse search and returns the start of the position of the\n/// leftmost match that is found. If no match exists, then `None` is\n/// returned.\n///\n/// # Errors\n///\n/// This routine errors if the search could not complete. This can occur\n/// in a number of circumstances:\n///\n/// * The configuration of the DFA may permit it to \"quit\" the search.\n/// For example, setting quit bytes or enabling heuristic support for\n/// Unicode word boundaries. The default configuration does not enable any\n/// option that could result in the DFA quitting.\n/// * When the provided `Input` configuration is not supported. For\n/// example, by providing an unsupported anchor mode.\n///\n/// When a search returns an error, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example\n///\n/// This example shows how to use this method with a\n/// [`dense::DFA`](crate::dfa::dense::DFA). In particular, this\n/// routine is principally useful when used in conjunction with the\n/// [`nfa::thompson::Config::reverse`](crate::nfa::thompson::Config::reverse)\n/// configuration. In general, it's unlikely to be correct to use\n/// both `try_search_fwd` and `try_search_rev` with the same DFA since\n/// any particular DFA will only support searching in one direction with\n/// respect to the pattern.\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson,\n///     dfa::{Automaton, dense},\n///     HalfMatch, Input,\n/// };\n///\n/// let dfa = dense::Builder::new()\n///     .thompson(thompson::Config::new().reverse(true))\n///     .build(\"foo[0-9]+\")?;\n/// let expected = Some(HalfMatch::must(0, 0));\n/// assert_eq!(expected, dfa.try_search_rev(&Input::new(b\"foo12345\"))?);\n///\n/// // Even though a match is found after reading the last byte (`c`),\n/// // the leftmost first match semantics demand that we find the earliest\n/// // match that prefers earlier parts of the pattern over latter parts.\n/// let dfa = dense::Builder::new()\n///     .thompson(thompson::Config::new().reverse(true))\n///     .build(\"abc|c\")?;\n/// let expected = Some(HalfMatch::must(0, 0));\n/// assert_eq!(expected, dfa.try_search_rev(&Input::new(b\"abc\"))?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: UTF-8 mode\n///\n/// This examples demonstrates that UTF-8 mode applies to reverse\n/// DFAs. When UTF-8 mode is enabled in the underlying NFA, then all\n/// matches reported must correspond to valid UTF-8 spans. This includes\n/// prohibiting zero-width matches that split a codepoint.\n///\n/// UTF-8 mode is enabled by default. Notice below how the only zero-width\n/// matches reported are those at UTF-8 boundaries:\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense::DFA, Automaton},\n///     nfa::thompson,\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .thompson(thompson::Config::new().reverse(true))\n///     .build(r\"\")?;\n///\n/// // Run the reverse DFA to collect all matches.\n/// let mut input = Input::new(\"☃\");\n/// let mut matches = vec![];\n/// loop {\n///     match dfa.try_search_rev(&input)? {\n///         None => break,\n///         Some(hm) => {\n///             matches.push(hm);\n///             if hm.offset() == 0 || input.end() == 0 {\n///                 break;\n///             } else if hm.offset() < input.end() {\n///                 input.set_end(hm.offset());\n///             } else {\n///                 // This is only necessary to handle zero-width\n///                 // matches, which of course occur in this example.\n///                 // Without this, the search would never advance\n///                 // backwards beyond the initial match.\n///                 input.set_end(input.end() - 1);\n///             }\n///         }\n///     }\n/// }\n///\n/// // No matches split a codepoint.\n/// let expected = vec![\n///     HalfMatch::must(0, 3),\n///     HalfMatch::must(0, 0),\n/// ];\n/// assert_eq!(expected, matches);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// Now let's look at the same example, but with UTF-8 mode on the\n/// original NFA disabled (which results in disabling UTF-8 mode on the\n/// DFA):\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{dense::DFA, Automaton},\n///     nfa::thompson,\n///     HalfMatch, Input, MatchKind,\n/// };\n///\n/// let dfa = DFA::builder()\n///     .thompson(thompson::Config::new().reverse(true).utf8(false))\n///     .build(r\"\")?;\n///\n/// // Run the reverse DFA to collect all matches.\n/// let mut input = Input::new(\"☃\");\n/// let mut matches = vec![];\n/// loop {\n///     match dfa.try_search_rev(&input)? {\n///         None => break,\n///         Some(hm) => {\n///             matches.push(hm);\n///             if hm.offset() == 0 || input.end() == 0 {\n///                 break;\n///             } else if hm.offset() < input.end() {\n///                 input.set_end(hm.offset());\n///             } else {\n///                 // This is only necessary to handle zero-width\n///                 // matches, which of course occur in this example.\n///                 // Without this, the search would never advance\n///                 // backwards beyond the initial match.\n///                 input.set_end(input.end() - 1);\n///             }\n///         }\n///     }\n/// }\n///\n/// // No matches split a codepoint.\n/// let expected = vec![\n///     HalfMatch::must(0, 3),\n///     HalfMatch::must(0, 2),\n///     HalfMatch::must(0, 1),\n///     HalfMatch::must(0, 0),\n/// ];\n/// assert_eq!(expected, matches);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1486 fn try_search_rev(\n1487     &self,\n1488     input: &Input<'_>,\n1489 ) -> Result<Option<HalfMatch>, MatchError> {\n1490     let utf8empty = self.has_empty() && self.is_utf8();\n1491     let hm = match search::find_rev(self, input)? {\n1492         None => return Ok(None),\n1493         Some(hm) if !utf8empty => return Ok(Some(hm)),\n1494         Some(hm) => hm,\n1495     };\n1496     empty::skip_splits_rev(input, hm, hm.offset(), |input| {\n1497         let got = search::find_rev(self, input)?;\n1498         Ok(got.map(|hm| (hm, hm.offset())))\n1499     })\n1500 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}