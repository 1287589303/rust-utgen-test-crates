{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/empty.rs\n// crate name is regex_automata\nuse crate::util::search::{Input, MatchError};\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {\n        self.set_span(Span { start, ..self.get_span() });\n    }\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {\n        self.set_span(Span { end, ..self.get_span() });\n    }\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {}\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {\n        self.anchored\n    }\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {\n        utf8::is_boundary(self.haystack(), offset)\n    }\n}\nimpl Anchored {\n    #[inline]\n    pub fn is_anchored(&self) -> bool {\n        matches!(* self, Anchored::Yes | Anchored::Pattern(_))\n    }\n    #[inline]\n    pub fn pattern(&self) -> Option<PatternID> {}\n}\nfn skip_splits<T, F>(\n    forward: bool,\n    input: &Input<'_>,\n    init_value: T,\n    mut match_offset: usize,\n    mut find: F,\n) -> Result<Option<T>, MatchError>\nwhere\n    F: FnMut(&Input<'_>) -> Result<Option<(T, usize)>, MatchError>,\n{\n    if input.get_anchored().is_anchored() {\n        return Ok(\n            if input.is_char_boundary(match_offset) { Some(init_value) } else { None },\n        );\n    }\n    let mut value = init_value;\n    let mut input = input.clone();\n    while !input.is_char_boundary(match_offset) {\n        if forward {\n            input.set_start(input.start().checked_add(1).unwrap());\n        } else {\n            input\n                .set_end(\n                    match input.end().checked_sub(1) {\n                        None => return Ok(None),\n                        Some(end) => end,\n                    },\n                );\n        }\n        match find(&input)? {\n            None => return Ok(None),\n            Some((new_value, new_match_end)) => {\n                value = new_value;\n                match_offset = new_match_end;\n            }\n        }\n    }\n    Ok(Some(value))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n187 fn skip_splits<T, F>(\n188     forward: bool,\n189     input: &Input<'_>,\n190     init_value: T,\n191     mut match_offset: usize,\n192     mut find: F,\n193 ) -> Result<Option<T>, MatchError>\n194 where\n195     F: FnMut(&Input<'_>) -> Result<Option<(T, usize)>, MatchError>,\n196 {\n197     // If our config says to do an anchored search, then we're definitely\n198     // done. We just need to determine whether we have a valid match or\n199     // not. If we don't, then we're not allowed to continue, so we report\n200     // no match.\n201     //\n202     // This is actually quite a subtle correctness thing. The key here is\n203     // that if we got an empty match that splits a codepoint after doing an\n204     // anchored search in UTF-8 mode, then that implies that we must have\n205     // *started* the search at a location that splits a codepoint. This\n206     // follows from the fact that if a match is reported from an anchored\n207     // search, then the start offset of the match *must* match the start\n208     // offset of the search.\n209     //\n210     // It also follows that no other non-empty match is possible. For\n211     // example, you might write a regex like '(?:)|SOMETHING' and start its\n212     // search in the middle of a codepoint. The first branch is an empty\n213     // regex that will bubble up a match at the first position, and then\n214     // get rejected here and report no match. But what if 'SOMETHING' could\n215     // have matched? We reason that such a thing is impossible, because\n216     // if it does, it must report a match that starts in the middle of a\n217     // codepoint. This in turn implies that a match is reported whose span\n218     // does not correspond to valid UTF-8, and this breaks the promise\n219     // made when UTF-8 mode is enabled. (That promise *can* be broken, for\n220     // example, by enabling UTF-8 mode but building an by hand NFA that\n221     // produces non-empty matches that span invalid UTF-8. This is an unchecked\n222     // but documented precondition violation of UTF-8 mode, and is documented\n223     // to have unspecified behavior.)\n224     //\n225     // I believe this actually means that if an anchored search is run, and\n226     // UTF-8 mode is enabled and the start position splits a codepoint,\n227     // then it is correct to immediately report no match without even\n228     // executing the regex engine. But it doesn't really seem worth writing\n229     // out that case in every regex engine to save a tiny bit of work in an\n230     // extremely pathological case, so we just handle it here.\n231     if input.get_anchored().is_anchored() {\n232         return Ok(if input.is_char_boundary(match_offset) {\n233             Some(init_value)\n234         } else {\n235             None\n236         });\n237     }\n238     // Otherwise, we have an unanchored search, so just keep looking for\n239     // matches until we have one that does not split a codepoint or we hit\n240     // EOI.\n241     let mut value = init_value;\n242     let mut input = input.clone();\n243     while !input.is_char_boundary(match_offset) {\n244         if forward {\n245             // The unwrap is OK here because overflowing usize while\n246             // iterating over a slice is impossible, at it would require\n247             // a slice of length greater than isize::MAX, which is itself\n248             // impossible.\n249             input.set_start(input.start().checked_add(1).unwrap());\n250         } else {\n251             input.set_end(match input.end().checked_sub(1) {\n252                 None => return Ok(None),\n253                 Some(end) => end,\n254             });\n255         }\n256         match find(&input)? {\n257             None => return Ok(None),\n258             Some((new_value, new_match_end)) => {\n259                 value = new_value;\n260                 match_offset = new_match_end;\n261             }\n262         }\n263     }\n264     Ok(Some(value))\n265 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}