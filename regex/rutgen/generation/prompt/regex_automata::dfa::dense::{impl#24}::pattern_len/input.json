{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/dense.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\npub(crate) type OwnedDFA = DFA<alloc::vec::Vec<u32>>;\n#[cfg(feature = \"dfa-build\")]\nuse core::cmp;\nuse core::{fmt, iter, mem::size_of, slice};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{\n    collections::{BTreeMap, BTreeSet},\n    vec, vec::Vec,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::{\n    dfa::{accel::Accel, determinize, minimize::Minimizer, remapper::Remapper, sparse},\n    nfa::thompson, util::{look::LookMatcher, search::MatchKind},\n};\nuse crate::{\n    dfa::{\n        accel::Accels, automaton::{fmt_state_indicator, Automaton, StartError},\n        special::Special, start::StartKind, DEAD,\n    },\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        int::{Pointer, Usize},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-dense\";\nconst VERSION: u32 = 2;\n#[derive(Clone, Debug)]\nstruct MatchStates<T> {\n    /// Slices is a flattened sequence of pairs, where each pair points to a\n    /// sub-slice of pattern_ids. The first element of the pair is an offset\n    /// into pattern_ids and the second element of the pair is the number\n    /// of 32-bit pattern IDs starting at that position. That is, each pair\n    /// corresponds to a single DFA match state and its corresponding match\n    /// IDs. The number of pairs always corresponds to the number of distinct\n    /// DFA match states.\n    ///\n    /// In practice, T is either Vec<u32> or &[u32].\n    slices: T,\n    /// A flattened sequence of pattern IDs for each DFA match state. The only\n    /// way to correctly read this sequence is indirectly via `slices`.\n    ///\n    /// In practice, T is either Vec<u32> or &[u32].\n    pattern_ids: T,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\nimpl<T: AsRef<[u32]>> MatchStates<T> {\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError> {}\n    #[cfg(feature = \"dfa-build\")]\n    fn to_map(&self, dfa: &DFA<T>) -> BTreeMap<StateID, Vec<PatternID>> {}\n    fn as_ref(&self) -> MatchStates<&'_ [u32]> {}\n    #[cfg(feature = \"alloc\")]\n    fn to_owned(&self) -> MatchStates<alloc::vec::Vec<u32>> {}\n    fn match_state_id(&self, dfa: &DFA<T>, index: usize) -> StateID {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn pattern_id(&self, state_index: usize, match_index: usize) -> PatternID {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn pattern_len(&self, state_index: usize) -> usize {\n        self.slices()[state_index * 2 + 1].as_usize()\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn pattern_id_slice(&self, state_index: usize) -> &[PatternID] {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn slices(&self) -> &[PatternID] {\n        wire::u32s_to_pattern_ids(self.slices.as_ref())\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn len(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn pattern_ids(&self) -> &[PatternID] {}\n    fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the number of patterns in the given match state.\n///\n/// The match state index is the state index minus the state index of the\n/// first match state in the DFA.\n4630 fn pattern_len(&self, state_index: usize) -> usize {\n4631     self.slices()[state_index * 2 + 1].as_usize()\n4632 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}