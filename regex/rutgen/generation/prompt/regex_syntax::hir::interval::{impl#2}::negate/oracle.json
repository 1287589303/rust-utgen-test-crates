{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/interval.rs\n// crate name is regex_syntax\nuse core::{char, cmp, fmt::Debug, slice};\nuse alloc::vec::Vec;\nuse crate::unicode;\npub trait Interval: Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord {\n    type Bound: Bound;\n    fn lower(&self) -> Self::Bound;\n    fn upper(&self) -> Self::Bound;\n    fn set_lower(&mut self, bound: Self::Bound);\n    fn set_upper(&mut self, bound: Self::Bound);\n    fn case_fold_simple(\n        &self,\n        intervals: &mut Vec<Self>,\n    ) -> Result<(), unicode::CaseFoldError>;\n    fn create(lower: Self::Bound, upper: Self::Bound) -> Self {\n        let mut int = Self::default();\n        if lower <= upper {\n            int.set_lower(lower);\n            int.set_upper(upper);\n        } else {\n            int.set_lower(upper);\n            int.set_upper(lower);\n        }\n        int\n    }\n    fn union(&self, other: &Self) -> Option<Self> {\n        if !self.is_contiguous(other) {\n            return None;\n        }\n        let lower = cmp::min(self.lower(), other.lower());\n        let upper = cmp::max(self.upper(), other.upper());\n        Some(Self::create(lower, upper))\n    }\n    fn intersect(&self, other: &Self) -> Option<Self> {\n        let lower = cmp::max(self.lower(), other.lower());\n        let upper = cmp::min(self.upper(), other.upper());\n        if lower <= upper { Some(Self::create(lower, upper)) } else { None }\n    }\n    fn difference(&self, other: &Self) -> (Option<Self>, Option<Self>) {\n        if self.is_subset(other) {\n            return (None, None);\n        }\n        if self.is_intersection_empty(other) {\n            return (Some(self.clone()), None);\n        }\n        let add_lower = other.lower() > self.lower();\n        let add_upper = other.upper() < self.upper();\n        assert!(add_lower || add_upper);\n        let mut ret = (None, None);\n        if add_lower {\n            let upper = other.lower().decrement();\n            ret.0 = Some(Self::create(self.lower(), upper));\n        }\n        if add_upper {\n            let lower = other.upper().increment();\n            let range = Self::create(lower, self.upper());\n            if ret.0.is_none() {\n                ret.0 = Some(range);\n            } else {\n                ret.1 = Some(range);\n            }\n        }\n        ret\n    }\n    fn is_contiguous(&self, other: &Self) -> bool;\n    fn is_intersection_empty(&self, other: &Self) -> bool;\n    fn is_subset(&self, other: &Self) -> bool;\n}\n#[derive(Clone, Debug)]\npub struct IntervalSet<I> {\n    /// A sorted set of non-overlapping ranges.\n    ranges: Vec<I>,\n    /// While not required at all for correctness, we keep track of whether an\n    /// interval set has been case folded or not. This helps us avoid doing\n    /// redundant work if, for example, a set has already been cased folded.\n    /// And note that whether a set is folded or not is preserved through\n    /// all of the pairwise set operations. That is, if both interval sets\n    /// have been case folded, then any of difference, union, intersection or\n    /// symmetric difference all produce a case folded set.\n    ///\n    /// Note that when this is true, it *must* be the case that the set is case\n    /// folded. But when it's false, the set *may* be case folded. In other\n    /// words, we only set this to true when we know it to be case, but we're\n    /// okay with it being false if it would otherwise be costly to determine\n    /// whether it should be true. This means code cannot assume that a false\n    /// value necessarily indicates that the set is not case folded.\n    ///\n    /// Bottom line: this is a performance optimization.\n    folded: bool,\n}\nimpl<I: Interval> IntervalSet<I> {\n    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {}\n    pub fn push(&mut self, interval: I) {}\n    pub fn iter(&self) -> IntervalSetIter<'_, I> {}\n    pub fn intervals(&self) -> &[I] {}\n    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {}\n    pub fn union(&mut self, other: &IntervalSet<I>) {}\n    pub fn intersect(&mut self, other: &IntervalSet<I>) {}\n    pub fn difference(&mut self, other: &IntervalSet<I>) {}\n    pub fn symmetric_difference(&mut self, other: &IntervalSet<I>) {}\n    pub fn negate(&mut self) {\n        if self.ranges.is_empty() {\n            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n            self.ranges.push(I::create(min, max));\n            self.folded = true;\n            return;\n        }\n        let drain_end = self.ranges.len();\n        if self.ranges[0].lower() > I::Bound::min_value() {\n            let upper = self.ranges[0].lower().decrement();\n            self.ranges.push(I::create(I::Bound::min_value(), upper));\n        }\n        for i in 1..drain_end {\n            let lower = self.ranges[i - 1].upper().increment();\n            let upper = self.ranges[i].lower().decrement();\n            self.ranges.push(I::create(lower, upper));\n        }\n        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n            let lower = self.ranges[drain_end - 1].upper().increment();\n            self.ranges.push(I::create(lower, I::Bound::max_value()));\n        }\n        self.ranges.drain(..drain_end);\n    }\n    fn canonicalize(&mut self) {}\n    fn is_canonical(&self) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Negate this interval set.\n///\n/// For all `x` where `x` is any element, if `x` was in this set, then it\n/// will not be in this set after negation.\n296 pub fn negate(&mut self) {\n297     if self.ranges.is_empty() {\n298         let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n299         self.ranges.push(I::create(min, max));\n300         // The set containing everything must case folded.\n301         self.folded = true;\n302         return;\n303     }\n304 \n305     // There should be a way to do this in-place with constant memory,\n306     // but I couldn't figure out a simple way to do it. So just append\n307     // the negation to the end of this range, and then drain it before\n308     // we're done.\n309     let drain_end = self.ranges.len();\n310 \n311     // We do checked arithmetic below because of the canonical ordering\n312     // invariant.\n313     if self.ranges[0].lower() > I::Bound::min_value() {\n314         let upper = self.ranges[0].lower().decrement();\n315         self.ranges.push(I::create(I::Bound::min_value(), upper));\n316     }\n317     for i in 1..drain_end {\n318         let lower = self.ranges[i - 1].upper().increment();\n319         let upper = self.ranges[i].lower().decrement();\n320         self.ranges.push(I::create(lower, upper));\n321     }\n322     if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n323         let lower = self.ranges[drain_end - 1].upper().increment();\n324         self.ranges.push(I::create(lower, I::Bound::max_value()));\n325     }\n326     self.ranges.drain(..drain_end);\n327     // We don't need to update whether this set is folded or not, because\n328     // it is conservatively preserved through negation. Namely, if a set\n329     // is not folded, then it is possible that its negation is folded, for\n330     // example, [^â˜ƒ]. But we're fine with assuming that the set is not\n331     // folded in that case. (`folded` permits false negatives but not false\n332     // positives.)\n333     //\n334     // But what about when a set is folded, is its negation also\n335     // necessarily folded? Yes. Because if a set is folded, then for every\n336     // character in the set, it necessarily included its equivalence class\n337     // of case folded characters. Negating it in turn means that all\n338     // equivalence classes in the set are negated, and any equivalence\n339     // class that was previously not in the set is now entirely in the set.\n340 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}