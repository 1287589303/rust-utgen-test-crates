{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/literal.rs\n// crate name is regex_syntax\nuse core::{cmp, mem, num::NonZeroUsize};\nuse alloc::{vec, vec::Vec};\nuse crate::hir::{self, Hir};\n#[derive(Clone, Debug)]\npub struct Extractor {\n    kind: ExtractKind,\n    limit_class: usize,\n    limit_repeat: usize,\n    limit_literal_len: usize,\n    limit_total: usize,\n}\n#[non_exhaustive]\n#[derive(Clone, Debug)]\npub enum ExtractKind {\n    /// Extracts only prefix literals from a regex.\n    Prefix,\n    /// Extracts only suffix literals from a regex.\n    ///\n    /// Note that the sequence returned by suffix literals currently may\n    /// not correctly represent leftmost-first or \"preference\" order match\n    /// semantics.\n    Suffix,\n}\nimpl Extractor {\n    pub fn new() -> Extractor {}\n    pub fn extract(&self, hir: &Hir) -> Seq {}\n    pub fn kind(&mut self, kind: ExtractKind) -> &mut Extractor {}\n    pub fn limit_class(&mut self, limit: usize) -> &mut Extractor {}\n    pub fn limit_repeat(&mut self, limit: usize) -> &mut Extractor {}\n    pub fn limit_literal_len(&mut self, limit: usize) -> &mut Extractor {}\n    pub fn limit_total(&mut self, limit: usize) -> &mut Extractor {\n        self.limit_total = limit;\n        self\n    }\n    fn extract_concat<'a, I: Iterator<Item = &'a Hir>>(&self, it: I) -> Seq {}\n    fn extract_alternation<'a, I: Iterator<Item = &'a Hir>>(&self, it: I) -> Seq {}\n    fn extract_repetition(&self, rep: &hir::Repetition) -> Seq {}\n    fn extract_class_unicode(&self, cls: &hir::ClassUnicode) -> Seq {}\n    fn extract_class_bytes(&self, cls: &hir::ClassBytes) -> Seq {}\n    fn class_over_limit_unicode(&self, cls: &hir::ClassUnicode) -> bool {}\n    fn class_over_limit_bytes(&self, cls: &hir::ClassBytes) -> bool {}\n    fn cross(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {}\n    fn union(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {}\n    fn enforce_literal_len(&self, seq: &mut Seq) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Configure a limit on the total number of literals that will be\n/// returned.\n///\n/// This is useful as a practical measure for avoiding the creation of\n/// large sequences of literals. While the extractor will automatically\n/// handle local creations of large sequences (for example, `[A-Z]` yields\n/// an infinite sequence by default), large sequences can be created\n/// through non-local means as well.\n///\n/// For example, `[ab]{3}{3}` would yield a sequence of length `512 = 2^9`\n/// despite each of the repetitions being small on their own. This limit\n/// thus represents a \"catch all\" for avoiding locally small sequences from\n/// combining into large sequences.\n///\n/// # Example\n///\n/// This example shows how reducing the limit will change the literal\n/// sequence returned.\n///\n/// ```\n/// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n///\n/// let hir = parse(r\"[ab]{2}{2}\")?;\n///\n/// let got = Extractor::new().extract(&hir);\n/// let expected = Seq::new([\n///     \"aaaa\", \"aaab\", \"aaba\", \"aabb\",\n///     \"abaa\", \"abab\", \"abba\", \"abbb\",\n///     \"baaa\", \"baab\", \"baba\", \"babb\",\n///     \"bbaa\", \"bbab\", \"bbba\", \"bbbb\",\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// // The default limit is not too big, but big enough to extract all\n/// // literals from '[ab]{2}{2}'. If we shrink the limit to less than 16,\n/// // then we'll get a truncated set. Notice that it returns a sequence of\n/// // length 4 even though our limit was 10. This is because the sequence\n/// // is difficult to increase without blowing the limit. Notice also\n/// // that every literal in the sequence is now inexact because they were\n/// // stripped of some suffix.\n/// let got = Extractor::new().limit_total(10).extract(&hir);\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"aa\"),\n///     Literal::inexact(\"ab\"),\n///     Literal::inexact(\"ba\"),\n///     Literal::inexact(\"bb\"),\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n385 pub fn limit_total(&mut self, limit: usize) -> &mut Extractor {\n386     self.limit_total = limit;\n387     self\n388 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}