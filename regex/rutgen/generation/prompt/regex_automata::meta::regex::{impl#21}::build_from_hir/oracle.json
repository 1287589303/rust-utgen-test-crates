{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/regex.rs\n// crate name is regex_automata\ntype CachePool = Pool<Cache, CachePoolFn>;\ntype CachePoolGuard<'a> = PoolGuard<'a, Cache, CachePoolFn>;\ntype CachePoolFn = Box<dyn Fn() -> Cache + Send + Sync + UnwindSafe + RefUnwindSafe>;\nuse core::{borrow::Borrow, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::{boxed::Box, sync::Arc, vec, vec::Vec};\nuse regex_syntax::{ast, hir::{self, Hir}};\nuse crate::{\n    meta::{\n        error::BuildError, strategy::{self, Strategy},\n        wrappers,\n    },\n    nfa::thompson::WhichCaptures,\n    util::{\n        captures::{Captures, GroupInfo},\n        iter, pool::{Pool, PoolGuard},\n        prefilter::Prefilter, primitives::{NonMaxUsize, PatternID},\n        search::{HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n    },\n};\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    ast: ast::parse::ParserBuilder,\n    hir: hir::translate::TranslatorBuilder,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Debug)]\npub struct Regex {\n    /// The actual regex implementation.\n    imp: Arc<RegexI>,\n    /// A thread safe pool of caches.\n    ///\n    /// For the higher level search APIs, a `Cache` is automatically plucked\n    /// from this pool before running a search. The lower level `with` methods\n    /// permit the caller to provide their own cache, thereby bypassing\n    /// accesses to this pool.\n    ///\n    /// Note that we put this outside the `Arc` so that cloning a `Regex`\n    /// results in creating a fresh `CachePool`. This in turn permits callers\n    /// to clone regexes into separate threads where each such regex gets\n    /// the pool's \"thread owner\" optimization. Otherwise, if one shares the\n    /// `Regex` directly, then the pool will go through a slower mutex path for\n    /// all threads except for the \"owner.\"\n    pool: CachePool,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\nimpl Builder {\n    pub fn new() -> Builder {}\n    pub fn build(&self, pattern: &str) -> Result<Regex, BuildError> {}\n    pub fn build_many<P: AsRef<str>>(\n        &self,\n        patterns: &[P],\n    ) -> Result<Regex, BuildError> {}\n    pub fn build_from_hir(&self, hir: &Hir) -> Result<Regex, BuildError> {\n        self.build_many_from_hir(&[hir])\n    }\n    pub fn build_many_from_hir<H: Borrow<Hir>>(\n        &self,\n        hirs: &[H],\n    ) -> Result<Regex, BuildError> {\n        let config = self.config.clone();\n        let hirs: Vec<&Hir> = hirs.iter().map(|hir| hir.borrow()).collect();\n        let info = RegexInfo::new(config, &hirs);\n        let strat = strategy::new(&info, &hirs)?;\n        let pool = {\n            let strat = Arc::clone(&strat);\n            let create: CachePoolFn = Box::new(move || strat.create_cache());\n            Pool::new(create)\n        };\n        Ok(Regex {\n            imp: Arc::new(RegexI { strat, info }),\n            pool,\n        })\n    }\n    pub fn configure(&mut self, config: Config) -> &mut Builder {}\n    pub fn syntax(&mut self, config: crate::util::syntax::Config) -> &mut Builder {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Builds a `Regex` directly from an `Hir` expression.\n///\n/// This is useful if you needed to parse a pattern string into an `Hir`\n/// for other reasons (such as analysis or transformations). This routine\n/// permits building a `Regex` directly from the `Hir` expression instead\n/// of first converting the `Hir` back to a pattern string.\n///\n/// When using this method, any options set via [`Builder::syntax`] are\n/// ignored. Namely, the syntax options only apply when parsing a pattern\n/// string, which isn't relevant here.\n///\n/// If there was a problem building the underlying regex matcher for the\n/// given `Hir`, then an error is returned.\n///\n/// # Example\n///\n/// This example shows how one can hand-construct an `Hir` expression and\n/// build a regex from it without doing any parsing at all.\n///\n/// ```\n/// use {\n///     regex_automata::{meta::Regex, Match},\n///     regex_syntax::hir::{Hir, Look},\n/// };\n///\n/// // (?Rm)^foo$\n/// let hir = Hir::concat(vec![\n///     Hir::look(Look::StartCRLF),\n///     Hir::literal(\"foo\".as_bytes()),\n///     Hir::look(Look::EndCRLF),\n/// ]);\n/// let re = Regex::builder()\n///     .build_from_hir(&hir)?;\n/// let hay = \"\\r\\nfoo\\r\\n\";\n/// assert_eq!(Some(Match::must(0, 2..5)), re.find(hay));\n///\n/// Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n3482 pub fn build_from_hir(&self, hir: &Hir) -> Result<Regex, BuildError> {\n3483     self.build_many_from_hir(&[hir])\n3484 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}