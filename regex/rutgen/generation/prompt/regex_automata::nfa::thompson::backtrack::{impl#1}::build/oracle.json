{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/backtrack.rs\n// crate name is regex_automata\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchError, Span},\n    },\n};\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    #[cfg(feature = \"syntax\")]\n    thompson: thompson::Compiler,\n}\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug)]\npub struct Compiler {\n    /// A regex parser, used when compiling an NFA directly from a pattern\n    /// string.\n    parser: ParserBuilder,\n    /// The compiler configuration.\n    config: Config,\n    /// The builder for actually constructing an NFA. This provides a\n    /// convenient abstraction for writing a compiler.\n    builder: RefCell<Builder>,\n    /// State used for compiling character classes to UTF-8 byte automata.\n    /// State is not retained between character class compilations. This just\n    /// serves to amortize allocation to the extent possible.\n    utf8_state: RefCell<Utf8State>,\n    /// State used for arranging character classes in reverse into a trie.\n    trie_state: RefCell<RangeTrie>,\n    /// State used for caching common suffixes when compiling reverse UTF-8\n    /// automata (for Unicode character classes).\n    utf8_suffix: RefCell<Utf8SuffixMap>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug)]\npub struct BoundedBacktracker {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\nimpl Builder {\n    pub fn new() -> Builder {}\n    #[cfg(feature = \"syntax\")]\n    pub fn build(&self, pattern: &str) -> Result<BoundedBacktracker, BuildError> {\n        self.build_many(&[pattern])\n    }\n    #[cfg(feature = \"syntax\")]\n    pub fn build_many<P: AsRef<str>>(\n        &self,\n        patterns: &[P],\n    ) -> Result<BoundedBacktracker, BuildError> {\n        let nfa = self.thompson.build_many(patterns)?;\n        self.build_from_nfa(nfa)\n    }\n    pub fn build_from_nfa(&self, nfa: NFA) -> Result<BoundedBacktracker, BuildError> {}\n    pub fn configure(&mut self, config: Config) -> &mut Builder {}\n    #[cfg(feature = \"syntax\")]\n    pub fn syntax(&mut self, config: crate::util::syntax::Config) -> &mut Builder {}\n    #[cfg(feature = \"syntax\")]\n    pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Build a `BoundedBacktracker` from the given pattern.\n///\n/// If there was a problem parsing or compiling the pattern, then an error\n/// is returned.\n277 pub fn build(\n278     &self,\n279     pattern: &str,\n280 ) -> Result<BoundedBacktracker, BuildError> {\n281     self.build_many(&[pattern])\n282 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}