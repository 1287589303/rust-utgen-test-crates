{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/compiler.rs\n// crate name is regex_automata\nuse core::{borrow::Borrow, cell::RefCell};\nuse alloc::{sync::Arc, vec, vec::Vec};\nuse regex_syntax::{\n    hir::{self, Hir},\n    utf8::{Utf8Range, Utf8Sequences},\n    ParserBuilder,\n};\nuse crate::{\n    nfa::thompson::{\n        builder::Builder, error::BuildError, literal_trie::LiteralTrie,\n        map::{Utf8BoundedMap, Utf8SuffixKey, Utf8SuffixMap},\n        nfa::{Transition, NFA},\n        range_trie::RangeTrie,\n    },\n    util::{\n        look::{Look, LookMatcher},\n        primitives::{PatternID, StateID},\n    },\n};\n#[derive(Clone, Debug)]\npub struct Compiler {\n    /// A regex parser, used when compiling an NFA directly from a pattern\n    /// string.\n    parser: ParserBuilder,\n    /// The compiler configuration.\n    config: Config,\n    /// The builder for actually constructing an NFA. This provides a\n    /// convenient abstraction for writing a compiler.\n    builder: RefCell<Builder>,\n    /// State used for compiling character classes to UTF-8 byte automata.\n    /// State is not retained between character class compilations. This just\n    /// serves to amortize allocation to the extent possible.\n    utf8_state: RefCell<Utf8State>,\n    /// State used for arranging character classes in reverse into a trie.\n    trie_state: RefCell<RangeTrie>,\n    /// State used for caching common suffixes when compiling reverse UTF-8\n    /// automata (for Unicode character classes).\n    utf8_suffix: RefCell<Utf8SuffixMap>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone)]\npub struct RangeTrie {\n    /// The states in this trie. The first is always the shared final state.\n    /// The second is always the root state. Otherwise, there is no\n    /// particular order.\n    states: Vec<State>,\n    /// A free-list of states. When a range trie is cleared, all of its states\n    /// are added to this list. Creating a new state reuses states from this\n    /// list before allocating a new one.\n    free: Vec<State>,\n    /// A stack for traversing this trie to yield sequences of byte ranges in\n    /// lexicographic order.\n    iter_stack: RefCell<Vec<NextIter>>,\n    /// A buffer that stores the current sequence during iteration.\n    iter_ranges: RefCell<Vec<Utf8Range>>,\n    /// A stack used for traversing the trie in order to (deeply) duplicate\n    /// a state. States are recursively duplicated when ranges are split.\n    dupe_stack: Vec<NextDupe>,\n    /// A stack used for traversing the trie during insertion of a new\n    /// sequence of byte ranges.\n    insert_stack: Vec<NextInsert>,\n}\n#[derive(Debug)]\nstruct Utf8Compiler<'a> {\n    builder: &'a mut Builder,\n    state: &'a mut Utf8State,\n    target: StateID,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    #[cfg(feature = \"dfa-build\")]\n    dfa: dense::Builder,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    dfa: dfa::Builder,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    #[cfg(feature = \"syntax\")]\n    thompson: thompson::Compiler,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    #[cfg(feature = \"syntax\")]\n    thompson: thompson::Compiler,\n}\n#[derive(Clone, Debug)]\nstruct Utf8State {\n    compiled: Utf8BoundedMap,\n    uncompiled: Vec<Utf8Node>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Builder {\n    /// The ID of the pattern that we're currently building.\n    ///\n    /// Callers are required to set (and unset) this by calling\n    /// {start,finish}_pattern. Otherwise, most methods will panic.\n    pattern_id: Option<PatternID>,\n    /// A sequence of intermediate NFA states. Once a state is added to this\n    /// sequence, it is assigned a state ID equivalent to its index. Once a\n    /// state is added, it is still expected to be mutated, e.g., to set its\n    /// transition to a state that didn't exist at the time it was added.\n    states: Vec<State>,\n    /// The starting states for each individual pattern. Starting at any\n    /// of these states will result in only an anchored search for the\n    /// corresponding pattern. The vec is indexed by pattern ID. When the NFA\n    /// contains a single regex, then `start_pattern[0]` and `start_anchored`\n    /// are always equivalent.\n    start_pattern: Vec<StateID>,\n    /// A map from pattern ID to capture group index to name. (If no name\n    /// exists, then a None entry is present. Thus, all capturing groups are\n    /// present in this mapping.)\n    ///\n    /// The outer vec is indexed by pattern ID, while the inner vec is indexed\n    /// by capture index offset for the corresponding pattern.\n    ///\n    /// The first capture group for each pattern is always unnamed and is thus\n    /// always None.\n    captures: Vec<Vec<Option<Arc<str>>>>,\n    /// The combined memory used by each of the 'State's in 'states'. This\n    /// only includes heap usage by each state, and not the size of the state\n    /// itself. In other words, this tracks heap memory used that isn't\n    /// captured via `size_of::<State>() * states.len()`.\n    memory_states: usize,\n    /// Whether this NFA only matches UTF-8 and whether regex engines using\n    /// this NFA for searching should report empty matches that split a\n    /// codepoint.\n    utf8: bool,\n    /// Whether this NFA should be matched in reverse or not.\n    reverse: bool,\n    /// The matcher to use for look-around assertions.\n    look_matcher: LookMatcher,\n    /// A size limit to respect when building an NFA. If the total heap memory\n    /// of the intermediate NFA states exceeds (or would exceed) this amount,\n    /// then an error is returned.\n    size_limit: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    ast: ast::parse::ParserBuilder,\n    hir: hir::translate::TranslatorBuilder,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct Utf8SuffixMap {\n    /// The current version of this map. Only entries with matching versions\n    /// are considered during lookups. If an entry is found with a mismatched\n    /// version, then the map behaves as if the entry does not exist.\n    version: u16,\n    /// The total number of entries this map can store.\n    capacity: usize,\n    /// The actual entries, keyed by hash. Collisions between different states\n    /// result in the old state being dropped.\n    map: Vec<Utf8SuffixEntry>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct ThompsonRef {\n    pub(crate) start: StateID,\n    pub(crate) end: StateID,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    #[cfg(feature = \"syntax\")]\n    thompson: thompson::Compiler,\n}\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    #[cfg(feature = \"syntax\")]\n    thompson: thompson::Compiler,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    #[cfg(feature = \"syntax\")]\n    thompson: thompson::Compiler,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Transition {\n    /// The inclusive start of the byte range.\n    pub start: u8,\n    /// The inclusive end of the byte range.\n    pub end: u8,\n    /// The identifier of the state to transition to.\n    pub next: StateID,\n}\nimpl Compiler {\n    fn compile<H: Borrow<Hir>>(&self, exprs: &[H]) -> Result<NFA, BuildError> {}\n    fn c(&self, expr: &Hir) -> Result<ThompsonRef, BuildError> {}\n    fn c_concat<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>\n    where\n        I: DoubleEndedIterator<Item = Result<ThompsonRef, BuildError>>,\n    {}\n    fn c_alt_slice(&self, exprs: &[Hir]) -> Result<ThompsonRef, BuildError> {}\n    fn c_alt_iter<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>\n    where\n        I: Iterator<Item = Result<ThompsonRef, BuildError>>,\n    {}\n    fn c_cap(\n        &self,\n        index: u32,\n        name: Option<&str>,\n        expr: &Hir,\n    ) -> Result<ThompsonRef, BuildError> {}\n    fn c_repetition(&self, rep: &hir::Repetition) -> Result<ThompsonRef, BuildError> {}\n    fn c_bounded(\n        &self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n        max: u32,\n    ) -> Result<ThompsonRef, BuildError> {}\n    fn c_at_least(\n        &self,\n        expr: &Hir,\n        greedy: bool,\n        n: u32,\n    ) -> Result<ThompsonRef, BuildError> {}\n    fn c_zero_or_one(\n        &self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> Result<ThompsonRef, BuildError> {}\n    fn c_exactly(&self, expr: &Hir, n: u32) -> Result<ThompsonRef, BuildError> {}\n    fn c_byte_class(&self, cls: &hir::ClassBytes) -> Result<ThompsonRef, BuildError> {}\n    fn c_unicode_class(\n        &self,\n        cls: &hir::ClassUnicode,\n    ) -> Result<ThompsonRef, BuildError> {\n        if cls.is_ascii() {\n            let end = self.add_empty()?;\n            let mut trans = Vec::with_capacity(cls.ranges().len());\n            for r in cls.iter() {\n                trans\n                    .push(Transition {\n                        start: u8::try_from(u32::from(r.start())).unwrap(),\n                        end: u8::try_from(u32::from(r.end())).unwrap(),\n                        next: end,\n                    });\n            }\n            Ok(ThompsonRef {\n                start: self.add_sparse(trans)?,\n                end,\n            })\n        } else if self.is_reverse() {\n            if !self.config.get_shrink() {\n                self.c_unicode_class_reverse_with_suffix(cls)\n            } else {\n                let mut trie = self.trie_state.borrow_mut();\n                trie.clear();\n                for rng in cls.iter() {\n                    for mut seq in Utf8Sequences::new(rng.start(), rng.end()) {\n                        seq.reverse();\n                        trie.insert(seq.as_slice());\n                    }\n                }\n                let mut builder = self.builder.borrow_mut();\n                let mut utf8_state = self.utf8_state.borrow_mut();\n                let mut utf8c = Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;\n                trie.iter(|seq| {\n                    utf8c.add(&seq)?;\n                    Ok(())\n                })?;\n                utf8c.finish()\n            }\n        } else {\n            let mut builder = self.builder.borrow_mut();\n            let mut utf8_state = self.utf8_state.borrow_mut();\n            let mut utf8c = Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;\n            for rng in cls.iter() {\n                for seq in Utf8Sequences::new(rng.start(), rng.end()) {\n                    utf8c.add(seq.as_slice())?;\n                }\n            }\n            utf8c.finish()\n        }\n    }\n    fn c_unicode_class_reverse_with_suffix(\n        &self,\n        cls: &hir::ClassUnicode,\n    ) -> Result<ThompsonRef, BuildError> {\n        let mut cache = self.utf8_suffix.borrow_mut();\n        cache.clear();\n        let union = self.add_union()?;\n        let alt_end = self.add_empty()?;\n        for urng in cls.iter() {\n            for seq in Utf8Sequences::new(urng.start(), urng.end()) {\n                let mut end = alt_end;\n                for brng in seq.as_slice() {\n                    let key = Utf8SuffixKey {\n                        from: end,\n                        start: brng.start,\n                        end: brng.end,\n                    };\n                    let hash = cache.hash(&key);\n                    if let Some(id) = cache.get(&key, hash) {\n                        end = id;\n                        continue;\n                    }\n                    let compiled = self.c_range(brng.start, brng.end)?;\n                    self.patch(compiled.end, end)?;\n                    end = compiled.start;\n                    cache.set(key, hash, end);\n                }\n                self.patch(union, end)?;\n            }\n        }\n        Ok(ThompsonRef {\n            start: union,\n            end: alt_end,\n        })\n    }\n    fn c_look(&self, anchor: &hir::Look) -> Result<ThompsonRef, BuildError> {}\n    fn c_literal(&self, bytes: &[u8]) -> Result<ThompsonRef, BuildError> {}\n    fn c_range(&self, start: u8, end: u8) -> Result<ThompsonRef, BuildError> {}\n    fn c_empty(&self) -> Result<ThompsonRef, BuildError> {}\n    fn c_fail(&self) -> Result<ThompsonRef, BuildError> {}\n    fn patch(&self, from: StateID, to: StateID) -> Result<(), BuildError> {}\n    fn start_pattern(&self) -> Result<PatternID, BuildError> {}\n    fn finish_pattern(&self, start_id: StateID) -> Result<PatternID, BuildError> {}\n    fn add_empty(&self) -> Result<StateID, BuildError> {\n        self.builder.borrow_mut().add_empty()\n    }\n    fn add_range(&self, start: u8, end: u8) -> Result<StateID, BuildError> {}\n    fn add_sparse(&self, ranges: Vec<Transition>) -> Result<StateID, BuildError> {\n        self.builder.borrow_mut().add_sparse(ranges)\n    }\n    fn add_look(&self, mut look: Look) -> Result<StateID, BuildError> {}\n    fn add_union(&self) -> Result<StateID, BuildError> {}\n    fn add_union_reverse(&self) -> Result<StateID, BuildError> {}\n    fn add_capture_start(\n        &self,\n        capture_index: u32,\n        name: Option<&str>,\n    ) -> Result<StateID, BuildError> {}\n    fn add_capture_end(&self, capture_index: u32) -> Result<StateID, BuildError> {}\n    fn add_fail(&self) -> Result<StateID, BuildError> {}\n    fn add_match(&self) -> Result<StateID, BuildError> {}\n    fn is_reverse(&self) -> bool {\n        self.config.get_reverse()\n    }\n}\nimpl Config {\n    pub fn new() -> Config {}\n    pub fn utf8(mut self, yes: bool) -> Config {}\n    pub fn reverse(mut self, yes: bool) -> Config {}\n    pub fn nfa_size_limit(mut self, bytes: Option<usize>) -> Config {}\n    pub fn shrink(mut self, yes: bool) -> Config {}\n    #[deprecated(since = \"0.3.5\", note = \"use which_captures instead\")]\n    pub fn captures(self, yes: bool) -> Config {}\n    pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {}\n    pub fn look_matcher(mut self, m: LookMatcher) -> Config {}\n    #[cfg(test)]\n    fn unanchored_prefix(mut self, yes: bool) -> Config {}\n    pub fn get_utf8(&self) -> bool {}\n    pub fn get_reverse(&self) -> bool {}\n    pub fn get_nfa_size_limit(&self) -> Option<usize> {}\n    pub fn get_shrink(&self) -> bool {\n        self.shrink.unwrap_or(false)\n    }\n    #[deprecated(since = \"0.3.5\", note = \"use get_which_captures instead\")]\n    pub fn get_captures(&self) -> bool {}\n    pub fn get_which_captures(&self) -> WhichCaptures {}\n    pub fn get_look_matcher(&self) -> LookMatcher {}\n    fn get_unanchored_prefix(&self) -> bool {}\n    pub(crate) fn overwrite(&self, o: Config) -> Config {}\n}\nimpl RangeTrie {\n    pub fn new() -> RangeTrie {}\n    pub fn clear(&mut self) {\n        self.free.extend(self.states.drain(..));\n        self.add_empty();\n        self.add_empty();\n    }\n    pub fn iter<E, F: FnMut(&[Utf8Range]) -> Result<(), E>>(\n        &self,\n        mut f: F,\n    ) -> Result<(), E> {\n        let mut stack = self.iter_stack.borrow_mut();\n        stack.clear();\n        let mut ranges = self.iter_ranges.borrow_mut();\n        ranges.clear();\n        stack\n            .push(NextIter {\n                state_id: ROOT,\n                tidx: 0,\n            });\n        while let Some(NextIter { mut state_id, mut tidx }) = stack.pop() {\n            loop {\n                let state = self.state(state_id);\n                if tidx >= state.transitions.len() {\n                    ranges.pop();\n                    break;\n                }\n                let t = &state.transitions[tidx];\n                ranges.push(t.range);\n                if t.next_id == FINAL {\n                    f(&ranges)?;\n                    ranges.pop();\n                    tidx += 1;\n                } else {\n                    stack\n                        .push(NextIter {\n                            state_id,\n                            tidx: tidx + 1,\n                        });\n                    state_id = t.next_id;\n                    tidx = 0;\n                }\n            }\n        }\n        Ok(())\n    }\n    pub fn insert(&mut self, ranges: &[Utf8Range]) {\n        assert!(! ranges.is_empty());\n        assert!(ranges.len() <= 4);\n        let mut stack = mem::replace(&mut self.insert_stack, vec![]);\n        stack.clear();\n        stack.push(NextInsert::new(ROOT, ranges));\n        while let Some(next) = stack.pop() {\n            let (state_id, ranges) = (next.state_id(), next.ranges());\n            assert!(! ranges.is_empty());\n            let (mut new, rest) = (ranges[0], &ranges[1..]);\n            let mut i = self.state(state_id).find(new);\n            if i == self.state(state_id).transitions.len() {\n                let next_id = NextInsert::push(self, &mut stack, rest);\n                self.add_transition(state_id, new, next_id);\n                continue;\n            }\n            'OUTER: loop {\n                let old = self.state(state_id).transitions[i].clone();\n                let split = match Split::new(old.range, new) {\n                    Some(split) => split,\n                    None => {\n                        let next_id = NextInsert::push(self, &mut stack, rest);\n                        self.add_transition_at(i, state_id, new, next_id);\n                        continue;\n                    }\n                };\n                let splits = split.as_slice();\n                if splits.len() == 1 {\n                    if !rest.is_empty() {\n                        stack.push(NextInsert::new(old.next_id, rest));\n                    }\n                    break;\n                }\n                let mut first = true;\n                let mut add_trans = |trie: &mut RangeTrie, pos, from, range, to| {\n                    if first {\n                        trie.set_transition_at(pos, from, range, to);\n                        first = false;\n                    } else {\n                        trie.add_transition_at(pos, from, range, to);\n                    }\n                };\n                for (j, &srange) in splits.iter().enumerate() {\n                    match srange {\n                        SplitRange::Old(r) => {\n                            let dup_id = self.duplicate(old.next_id);\n                            add_trans(self, i, state_id, r, dup_id);\n                        }\n                        SplitRange::New(r) => {\n                            {\n                                let trans = &self.state(state_id).transitions;\n                                if j + 1 == splits.len() && i < trans.len()\n                                    && intersects(r, trans[i].range)\n                                {\n                                    new = r;\n                                    continue 'OUTER;\n                                }\n                            }\n                            let next_id = NextInsert::push(self, &mut stack, rest);\n                            add_trans(self, i, state_id, r, next_id);\n                        }\n                        SplitRange::Both(r) => {\n                            if !rest.is_empty() {\n                                stack.push(NextInsert::new(old.next_id, rest));\n                            }\n                            add_trans(self, i, state_id, r, old.next_id);\n                        }\n                    }\n                    i += 1;\n                }\n                break;\n            }\n        }\n        self.insert_stack = stack;\n    }\n    pub fn add_empty(&mut self) -> StateID {}\n    fn duplicate(&mut self, old_id: StateID) -> StateID {}\n    fn add_transition(&mut self, from_id: StateID, range: Utf8Range, next_id: StateID) {}\n    fn add_transition_at(\n        &mut self,\n        i: usize,\n        from_id: StateID,\n        range: Utf8Range,\n        next_id: StateID,\n    ) {}\n    fn set_transition_at(\n        &mut self,\n        i: usize,\n        from_id: StateID,\n        range: Utf8Range,\n        next_id: StateID,\n    ) {}\n    fn state(&self, id: StateID) -> &State {}\n    fn state_mut(&mut self, id: StateID) -> &mut State {}\n}\nimpl<'a> Utf8Compiler<'a> {\n    fn new(\n        builder: &'a mut Builder,\n        state: &'a mut Utf8State,\n    ) -> Result<Utf8Compiler<'a>, BuildError> {\n        let target = builder.add_empty()?;\n        state.clear();\n        let mut utf8c = Utf8Compiler {\n            builder,\n            state,\n            target,\n        };\n        utf8c.add_empty();\n        Ok(utf8c)\n    }\n    fn finish(&mut self) -> Result<ThompsonRef, BuildError> {\n        self.compile_from(0)?;\n        let node = self.pop_root();\n        let start = self.compile(node)?;\n        Ok(ThompsonRef {\n            start,\n            end: self.target,\n        })\n    }\n    fn add(&mut self, ranges: &[Utf8Range]) -> Result<(), BuildError> {\n        let prefix_len = ranges\n            .iter()\n            .zip(&self.state.uncompiled)\n            .take_while(|&(range, node)| {\n                node.last\n                    .as_ref()\n                    .map_or(false, |t| { (t.start, t.end) == (range.start, range.end) })\n            })\n            .count();\n        assert!(prefix_len < ranges.len());\n        self.compile_from(prefix_len)?;\n        self.add_suffix(&ranges[prefix_len..]);\n        Ok(())\n    }\n    fn compile_from(&mut self, from: usize) -> Result<(), BuildError> {}\n    fn compile(&mut self, node: Vec<Transition>) -> Result<StateID, BuildError> {}\n    fn add_suffix(&mut self, ranges: &[Utf8Range]) {}\n    fn add_empty(&mut self) {}\n    fn pop_freeze(&mut self, next: StateID) -> Vec<Transition> {}\n    fn pop_root(&mut self) -> Vec<Transition> {}\n    fn top_last_freeze(&mut self, next: StateID) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Compile the given Unicode character class.\n///\n/// This routine specifically tries to use various types of compression,\n/// since UTF-8 automata of large classes can get quite large. The specific\n/// type of compression used depends on forward vs reverse compilation, and\n/// whether NFA shrinking is enabled or not.\n///\n/// Aside from repetitions causing lots of repeat group, this is like the\n/// single most expensive part of regex compilation. Therefore, a large part\n/// of the expense of compilation may be reduce by disabling Unicode in the\n/// pattern.\n///\n/// This routine compiles an empty character class into a \"fail\" state.\n1373 fn c_unicode_class(\n1374     &self,\n1375     cls: &hir::ClassUnicode,\n1376 ) -> Result<ThompsonRef, BuildError> {\n1377     // If all we have are ASCII ranges wrapped in a Unicode package, then\n1378     // there is zero reason to bring out the big guns. We can fit all ASCII\n1379     // ranges within a single sparse state.\n1380     if cls.is_ascii() {\n1381         let end = self.add_empty()?;\n1382         let mut trans = Vec::with_capacity(cls.ranges().len());\n1383         for r in cls.iter() {\n1384             // The unwraps below are OK because we've verified that this\n1385             // class only contains ASCII codepoints.\n1386             trans.push(Transition {\n1387                 // FIXME(1.59): use the 'TryFrom<char> for u8' impl.\n1388                 start: u8::try_from(u32::from(r.start())).unwrap(),\n1389                 end: u8::try_from(u32::from(r.end())).unwrap(),\n1390                 next: end,\n1391             });\n1392         }\n1393         Ok(ThompsonRef { start: self.add_sparse(trans)?, end })\n1394     } else if self.is_reverse() {\n1395         if !self.config.get_shrink() {\n1396             // When we don't want to spend the extra time shrinking, we\n1397             // compile the UTF-8 automaton in reverse using something like\n1398             // the \"naive\" approach, but will attempt to re-use common\n1399             // suffixes.\n1400             self.c_unicode_class_reverse_with_suffix(cls)\n1401         } else {\n1402             // When we want to shrink our NFA for reverse UTF-8 automata,\n1403             // we cannot feed UTF-8 sequences directly to the UTF-8\n1404             // compiler, since the UTF-8 compiler requires all sequences\n1405             // to be lexicographically sorted. Instead, we organize our\n1406             // sequences into a range trie, which can then output our\n1407             // sequences in the correct order. Unfortunately, building the\n1408             // range trie is fairly expensive (but not nearly as expensive\n1409             // as building a DFA). Hence the reason why the 'shrink' option\n1410             // exists, so that this path can be toggled off. For example,\n1411             // we might want to turn this off if we know we won't be\n1412             // compiling a DFA.\n1413             let mut trie = self.trie_state.borrow_mut();\n1414             trie.clear();\n1415 \n1416             for rng in cls.iter() {\n1417                 for mut seq in Utf8Sequences::new(rng.start(), rng.end()) {\n1418                     seq.reverse();\n1419                     trie.insert(seq.as_slice());\n1420                 }\n1421             }\n1422             let mut builder = self.builder.borrow_mut();\n1423             let mut utf8_state = self.utf8_state.borrow_mut();\n1424             let mut utf8c =\n1425                 Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;\n1426             trie.iter(|seq| {\n1427                 utf8c.add(&seq)?;\n1428                 Ok(())\n1429             })?;\n1430             utf8c.finish()\n1431         }\n1432     } else {\n1433         // In the forward direction, we always shrink our UTF-8 automata\n1434         // because we can stream it right into the UTF-8 compiler. There\n1435         // is almost no downside (in either memory or time) to using this\n1436         // approach.\n1437         let mut builder = self.builder.borrow_mut();\n1438         let mut utf8_state = self.utf8_state.borrow_mut();\n1439         let mut utf8c =\n1440             Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;\n1441         for rng in cls.iter() {\n1442             for seq in Utf8Sequences::new(rng.start(), rng.end()) {\n1443                 utf8c.add(seq.as_slice())?;\n1444             }\n1445         }\n1446         utf8c.finish()\n1447     }\n1448 \n1449     // For reference, the code below is the \"naive\" version of compiling a\n1450     // UTF-8 automaton. It is deliciously simple (and works for both the\n1451     // forward and reverse cases), but will unfortunately produce very\n1452     // large NFAs. When compiling a forward automaton, the size difference\n1453     // can sometimes be an order of magnitude. For example, the '\\w' regex\n1454     // will generate about ~3000 NFA states using the naive approach below,\n1455     // but only 283 states when using the approach above. This is because\n1456     // the approach above actually compiles a *minimal* (or near minimal,\n1457     // because of the bounded hashmap for reusing equivalent states) UTF-8\n1458     // automaton.\n1459     //\n1460     // The code below is kept as a reference point in order to make it\n1461     // easier to understand the higher level goal here. Although, it will\n1462     // almost certainly bit-rot, so keep that in mind. Also, if you try to\n1463     // use it, some of the tests in this module will fail because they look\n1464     // for terser byte code produce by the more optimized handling above.\n1465     // But the integration test suite should still pass.\n1466     //\n1467     // One good example of the substantial difference this can make is to\n1468     // compare and contrast performance of the Pike VM when the code below\n1469     // is active vs the code above. Here's an example to try:\n1470     //\n1471     //   regex-cli find match pikevm -b -p '(?m)^\\w{20}' non-ascii-file\n1472     //\n1473     // With Unicode classes generated below, this search takes about 45s on\n1474     // my machine. But with the compressed version above, the search takes\n1475     // only around 1.4s. The NFA is also 20% smaller. This is in part due\n1476     // to the compression, but also because of the utilization of 'sparse'\n1477     // NFA states. They lead to much less state shuffling during the NFA\n1478     // search.\n1479     /*\n1480     let it = cls\n1481         .iter()\n1482         .flat_map(|rng| Utf8Sequences::new(rng.start(), rng.end()))\n1483         .map(|seq| {\n1484             let it = seq\n1485                 .as_slice()\n1486                 .iter()\n1487                 .map(|rng| self.c_range(rng.start, rng.end));\n1488             self.c_concat(it)\n1489         });\n1490     self.c_alt_iter(it)\n1491     */\n1492 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}