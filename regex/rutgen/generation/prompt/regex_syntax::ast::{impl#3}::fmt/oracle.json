{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/mod.rs\n// crate name is regex_syntax\nuse core::cmp::Ordering;\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\npub use crate::ast::visitor::{visit, Visitor};\n#[derive(Clone, Copy, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[non_exhaustive]\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum ErrorKind {\n    /// The capturing group limit was exceeded.\n    ///\n    /// Note that this represents a limit on the total number of capturing\n    /// groups in a regex and not necessarily the number of nested capturing\n    /// groups. That is, the nest limit can be low and it is still possible for\n    /// this error to occur.\n    CaptureLimitExceeded,\n    /// An invalid escape sequence was found in a character class set.\n    ClassEscapeInvalid,\n    /// An invalid character class range was found. An invalid range is any\n    /// range where the start is greater than the end.\n    ClassRangeInvalid,\n    /// An invalid range boundary was found in a character class. Range\n    /// boundaries must be a single literal codepoint, but this error indicates\n    /// that something else was found, such as a nested class.\n    ClassRangeLiteral,\n    /// An opening `[` was found with no corresponding closing `]`.\n    ClassUnclosed,\n    /// Note that this error variant is no longer used. Namely, a decimal\n    /// number can only appear as a repetition quantifier. When the number\n    /// in a repetition quantifier is empty, then it gets its own specialized\n    /// error, `RepetitionCountDecimalEmpty`.\n    DecimalEmpty,\n    /// An invalid decimal number was given where one was expected.\n    DecimalInvalid,\n    /// A bracketed hex literal was empty.\n    EscapeHexEmpty,\n    /// A bracketed hex literal did not correspond to a Unicode scalar value.\n    EscapeHexInvalid,\n    /// An invalid hexadecimal digit was found.\n    EscapeHexInvalidDigit,\n    /// EOF was found before an escape sequence was completed.\n    EscapeUnexpectedEof,\n    /// An unrecognized escape sequence.\n    EscapeUnrecognized,\n    /// A dangling negation was used when setting flags, e.g., `i-`.\n    FlagDanglingNegation,\n    /// A flag was used twice, e.g., `i-i`.\n    FlagDuplicate {\n        /// The position of the original flag. The error position\n        /// points to the duplicate flag.\n        original: Span,\n    },\n    /// The negation operator was used twice, e.g., `-i-s`.\n    FlagRepeatedNegation {\n        /// The position of the original negation operator. The error position\n        /// points to the duplicate negation operator.\n        original: Span,\n    },\n    /// Expected a flag but got EOF, e.g., `(?`.\n    FlagUnexpectedEof,\n    /// Unrecognized flag, e.g., `a`.\n    FlagUnrecognized,\n    /// A duplicate capture name was found.\n    GroupNameDuplicate {\n        /// The position of the initial occurrence of the capture name. The\n        /// error position itself points to the duplicate occurrence.\n        original: Span,\n    },\n    /// A capture group name is empty, e.g., `(?P<>abc)`.\n    GroupNameEmpty,\n    /// An invalid character was seen for a capture group name. This includes\n    /// errors where the first character is a digit (even though subsequent\n    /// characters are allowed to be digits).\n    GroupNameInvalid,\n    /// A closing `>` could not be found for a capture group name.\n    GroupNameUnexpectedEof,\n    /// An unclosed group, e.g., `(ab`.\n    ///\n    /// The span of this error corresponds to the unclosed parenthesis.\n    GroupUnclosed,\n    /// An unopened group, e.g., `ab)`.\n    GroupUnopened,\n    /// The nest limit was exceeded. The limit stored here is the limit\n    /// configured in the parser.\n    NestLimitExceeded(u32),\n    /// The range provided in a counted repetition operator is invalid. The\n    /// range is invalid if the start is greater than the end.\n    RepetitionCountInvalid,\n    /// An opening `{` was not followed by a valid decimal value.\n    /// For example, `x{}` or `x{]}` would fail.\n    RepetitionCountDecimalEmpty,\n    /// An opening `{` was found with no corresponding closing `}`.\n    RepetitionCountUnclosed,\n    /// A repetition operator was applied to a missing sub-expression. This\n    /// occurs, for example, in the regex consisting of just a `*` or even\n    /// `(?i)*`. It is, however, possible to create a repetition operating on\n    /// an empty sub-expression. For example, `()*` is still considered valid.\n    RepetitionMissing,\n    /// The special word boundary syntax, `\\b{something}`, was used, but\n    /// either EOF without `}` was seen, or an invalid character in the\n    /// braces was seen.\n    SpecialWordBoundaryUnclosed,\n    /// The special word boundary syntax, `\\b{something}`, was used, but\n    /// `something` was not recognized as a valid word boundary kind.\n    SpecialWordBoundaryUnrecognized,\n    /// The syntax `\\b{` was observed, but afterwards the end of the pattern\n    /// was observed without being able to tell whether it was meant to be a\n    /// bounded repetition on the `\\b` or the beginning of a special word\n    /// boundary assertion.\n    SpecialWordOrRepetitionUnexpectedEof,\n    /// The Unicode class is not valid. This typically occurs when a `\\p` is\n    /// followed by something other than a `{`.\n    UnicodeClassInvalid,\n    /// When octal support is disabled, this error is produced when an octal\n    /// escape is used. The octal escape is assumed to be an invocation of\n    /// a backreference, which is the common case.\n    UnsupportedBackreference,\n    /// When syntax similar to PCRE's look-around is used, this error is\n    /// returned. Some example syntaxes that are rejected include, but are\n    /// not necessarily limited to, `(?=re)`, `(?!re)`, `(?<=re)` and\n    /// `(?<!re)`. Note that all of these syntaxes are otherwise invalid; this\n    /// error is used to improve the user experience.\n    UnsupportedLookAround,\n}\nimpl core::fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        use self::ErrorKind::*;\n        match *self {\n            CaptureLimitExceeded => {\n                write!(\n                    f,\n                    \"exceeded the maximum number of \\\n                 capturing groups ({})\",\n                    u32::MAX\n                )\n            }\n            ClassEscapeInvalid => {\n                write!(f, \"invalid escape sequence found in character class\")\n            }\n            ClassRangeInvalid => {\n                write!(\n                    f,\n                    \"invalid character class range, \\\n                 the start must be <= the end\"\n                )\n            }\n            ClassRangeLiteral => write!(f, \"invalid range boundary, must be a literal\"),\n            ClassUnclosed => write!(f, \"unclosed character class\"),\n            DecimalEmpty => write!(f, \"decimal literal empty\"),\n            DecimalInvalid => write!(f, \"decimal literal invalid\"),\n            EscapeHexEmpty => write!(f, \"hexadecimal literal empty\"),\n            EscapeHexInvalid => {\n                write!(f, \"hexadecimal literal is not a Unicode scalar value\")\n            }\n            EscapeHexInvalidDigit => write!(f, \"invalid hexadecimal digit\"),\n            EscapeUnexpectedEof => {\n                write!(\n                    f,\n                    \"incomplete escape sequence, \\\n                 reached end of pattern prematurely\"\n                )\n            }\n            EscapeUnrecognized => write!(f, \"unrecognized escape sequence\"),\n            FlagDanglingNegation => write!(f, \"dangling flag negation operator\"),\n            FlagDuplicate { .. } => write!(f, \"duplicate flag\"),\n            FlagRepeatedNegation { .. } => write!(f, \"flag negation operator repeated\"),\n            FlagUnexpectedEof => write!(f, \"expected flag but got end of regex\"),\n            FlagUnrecognized => write!(f, \"unrecognized flag\"),\n            GroupNameDuplicate { .. } => write!(f, \"duplicate capture group name\"),\n            GroupNameEmpty => write!(f, \"empty capture group name\"),\n            GroupNameInvalid => write!(f, \"invalid capture group character\"),\n            GroupNameUnexpectedEof => write!(f, \"unclosed capture group name\"),\n            GroupUnclosed => write!(f, \"unclosed group\"),\n            GroupUnopened => write!(f, \"unopened group\"),\n            NestLimitExceeded(limit) => {\n                write!(\n                    f,\n                    \"exceed the maximum number of \\\n                 nested parentheses/brackets ({})\",\n                    limit\n                )\n            }\n            RepetitionCountInvalid => {\n                write!(\n                    f,\n                    \"invalid repetition count range, \\\n                 the start must be <= the end\"\n                )\n            }\n            RepetitionCountDecimalEmpty => {\n                write!(f, \"repetition quantifier expects a valid decimal\")\n            }\n            RepetitionCountUnclosed => write!(f, \"unclosed counted repetition\"),\n            RepetitionMissing => write!(f, \"repetition operator missing expression\"),\n            SpecialWordBoundaryUnclosed => {\n                write!(\n                    f,\n                    \"special word boundary assertion is either \\\n                     unclosed or contains an invalid character\",\n                )\n            }\n            SpecialWordBoundaryUnrecognized => {\n                write!(\n                    f,\n                    \"unrecognized special word boundary assertion, \\\n                     valid choices are: start, end, start-half \\\n                     or end-half\",\n                )\n            }\n            SpecialWordOrRepetitionUnexpectedEof => {\n                write!(\n                    f,\n                    \"found either the beginning of a special word \\\n                     boundary or a bounded repetition on a \\\\b with \\\n                     an opening brace, but no closing brace\",\n                )\n            }\n            UnicodeClassInvalid => write!(f, \"invalid Unicode character class\"),\n            UnsupportedBackreference => write!(f, \"backreferences are not supported\"),\n            UnsupportedLookAround => {\n                write!(\n                    f,\n                    \"look-around, including look-ahead and look-behind, \\\n                 is not supported\"\n                )\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n202 fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n203     use self::ErrorKind::*;\n204     match *self {\n205         CaptureLimitExceeded => write!(\n206             f,\n207             \"exceeded the maximum number of \\\n208              capturing groups ({})\",\n209             u32::MAX\n210         ),\n211         ClassEscapeInvalid => {\n212             write!(f, \"invalid escape sequence found in character class\")\n213         }\n214         ClassRangeInvalid => write!(\n215             f,\n216             \"invalid character class range, \\\n217              the start must be <= the end\"\n218         ),\n219         ClassRangeLiteral => {\n220             write!(f, \"invalid range boundary, must be a literal\")\n221         }\n222         ClassUnclosed => write!(f, \"unclosed character class\"),\n223         DecimalEmpty => write!(f, \"decimal literal empty\"),\n224         DecimalInvalid => write!(f, \"decimal literal invalid\"),\n225         EscapeHexEmpty => write!(f, \"hexadecimal literal empty\"),\n226         EscapeHexInvalid => {\n227             write!(f, \"hexadecimal literal is not a Unicode scalar value\")\n228         }\n229         EscapeHexInvalidDigit => write!(f, \"invalid hexadecimal digit\"),\n230         EscapeUnexpectedEof => write!(\n231             f,\n232             \"incomplete escape sequence, \\\n233              reached end of pattern prematurely\"\n234         ),\n235         EscapeUnrecognized => write!(f, \"unrecognized escape sequence\"),\n236         FlagDanglingNegation => {\n237             write!(f, \"dangling flag negation operator\")\n238         }\n239         FlagDuplicate { .. } => write!(f, \"duplicate flag\"),\n240         FlagRepeatedNegation { .. } => {\n241             write!(f, \"flag negation operator repeated\")\n242         }\n243         FlagUnexpectedEof => {\n244             write!(f, \"expected flag but got end of regex\")\n245         }\n246         FlagUnrecognized => write!(f, \"unrecognized flag\"),\n247         GroupNameDuplicate { .. } => {\n248             write!(f, \"duplicate capture group name\")\n249         }\n250         GroupNameEmpty => write!(f, \"empty capture group name\"),\n251         GroupNameInvalid => write!(f, \"invalid capture group character\"),\n252         GroupNameUnexpectedEof => write!(f, \"unclosed capture group name\"),\n253         GroupUnclosed => write!(f, \"unclosed group\"),\n254         GroupUnopened => write!(f, \"unopened group\"),\n255         NestLimitExceeded(limit) => write!(\n256             f,\n257             \"exceed the maximum number of \\\n258              nested parentheses/brackets ({})\",\n259             limit\n260         ),\n261         RepetitionCountInvalid => write!(\n262             f,\n263             \"invalid repetition count range, \\\n264              the start must be <= the end\"\n265         ),\n266         RepetitionCountDecimalEmpty => {\n267             write!(f, \"repetition quantifier expects a valid decimal\")\n268         }\n269         RepetitionCountUnclosed => {\n270             write!(f, \"unclosed counted repetition\")\n271         }\n272         RepetitionMissing => {\n273             write!(f, \"repetition operator missing expression\")\n274         }\n275         SpecialWordBoundaryUnclosed => {\n276             write!(\n277                 f,\n278                 \"special word boundary assertion is either \\\n279                  unclosed or contains an invalid character\",\n280             )\n281         }\n282         SpecialWordBoundaryUnrecognized => {\n283             write!(\n284                 f,\n285                 \"unrecognized special word boundary assertion, \\\n286                  valid choices are: start, end, start-half \\\n287                  or end-half\",\n288             )\n289         }\n290         SpecialWordOrRepetitionUnexpectedEof => {\n291             write!(\n292                 f,\n293                 \"found either the beginning of a special word \\\n294                  boundary or a bounded repetition on a \\\\b with \\\n295                  an opening brace, but no closing brace\",\n296             )\n297         }\n298         UnicodeClassInvalid => {\n299             write!(f, \"invalid Unicode character class\")\n300         }\n301         UnsupportedBackreference => {\n302             write!(f, \"backreferences are not supported\")\n303         }\n304         UnsupportedLookAround => write!(\n305             f,\n306             \"look-around, including look-ahead and look-behind, \\\n307              is not supported\"\n308         ),\n309     }\n310 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}