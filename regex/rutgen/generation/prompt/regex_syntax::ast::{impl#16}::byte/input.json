{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/mod.rs\n// crate name is regex_syntax\nuse core::cmp::Ordering;\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\npub use crate::ast::visitor::{visit, Visitor};\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum LiteralKind {\n    /// The literal is written verbatim, e.g., `a` or `â˜ƒ`.\n    Verbatim,\n    /// The literal is written as an escape because it is otherwise a special\n    /// regex meta character, e.g., `\\*` or `\\[`.\n    Meta,\n    /// The literal is written as an escape despite the fact that the escape is\n    /// unnecessary, e.g., `\\%` or `\\/`.\n    Superfluous,\n    /// The literal is written as an octal escape, e.g., `\\141`.\n    Octal,\n    /// The literal is written as a hex code with a fixed number of digits\n    /// depending on the type of the escape, e.g., `\\x61` or `\\u0061` or\n    /// `\\U00000061`.\n    HexFixed(HexLiteralKind),\n    /// The literal is written as a hex code with a bracketed number of\n    /// digits. The only restriction is that the bracketed hex code must refer\n    /// to a valid Unicode scalar value.\n    HexBrace(HexLiteralKind),\n    /// The literal is written as a specially recognized escape, e.g., `\\f`\n    /// or `\\n`.\n    Special(SpecialLiteralKind),\n}\nimpl Literal {\n    pub fn byte(&self) -> Option<u8> {\n        match self.kind {\n            LiteralKind::HexFixed(HexLiteralKind::X) => u8::try_from(self.c).ok(),\n            _ => None,\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// If this literal was written as a `\\x` hex escape, then this returns\n/// the corresponding byte value. Otherwise, this returns `None`.\n689 pub fn byte(&self) -> Option<u8> {\n690     match self.kind {\n691         LiteralKind::HexFixed(HexLiteralKind::X) => {\n692             u8::try_from(self.c).ok()\n693         }\n694         _ => None,\n695     }\n696 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}