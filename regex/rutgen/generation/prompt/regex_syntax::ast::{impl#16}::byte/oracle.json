{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/mod.rs\n// crate name is regex_syntax\nuse core::cmp::Ordering;\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\npub use crate::ast::visitor::{visit, Visitor};\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum LiteralKind {\n    /// The literal is written verbatim, e.g., `a` or `â˜ƒ`.\n    Verbatim,\n    /// The literal is written as an escape because it is otherwise a special\n    /// regex meta character, e.g., `\\*` or `\\[`.\n    Meta,\n    /// The literal is written as an escape despite the fact that the escape is\n    /// unnecessary, e.g., `\\%` or `\\/`.\n    Superfluous,\n    /// The literal is written as an octal escape, e.g., `\\141`.\n    Octal,\n    /// The literal is written as a hex code with a fixed number of digits\n    /// depending on the type of the escape, e.g., `\\x61` or `\\u0061` or\n    /// `\\U00000061`.\n    HexFixed(HexLiteralKind),\n    /// The literal is written as a hex code with a bracketed number of\n    /// digits. The only restriction is that the bracketed hex code must refer\n    /// to a valid Unicode scalar value.\n    HexBrace(HexLiteralKind),\n    /// The literal is written as a specially recognized escape, e.g., `\\f`\n    /// or `\\n`.\n    Special(SpecialLiteralKind),\n}\nimpl Literal {\n    pub fn byte(&self) -> Option<u8> {\n        match self.kind {\n            LiteralKind::HexFixed(HexLiteralKind::X) => u8::try_from(self.c).ok(),\n            _ => None,\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// If this literal was written as a `\\x` hex escape, then this returns\n/// the corresponding byte value. Otherwise, this returns `None`.\n689 pub fn byte(&self) -> Option<u8> {\n690     match self.kind {\n691         LiteralKind::HexFixed(HexLiteralKind::X) => {\n692             u8::try_from(self.c).ok()\n693         }\n694         _ => None,\n695     }\n696 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}