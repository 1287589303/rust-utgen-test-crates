{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/limited.rs\n// crate name is regex_automata\nuse crate::{\n    meta::error::{RetryError, RetryQuadraticError},\n    HalfMatch, Input, MatchError,\n};\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Debug)]\npub(crate) struct RetryQuadraticError(());\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Debug)]\npub(crate) enum RetryError {\n    Quadratic(RetryQuadraticError),\n    Fail(RetryFailError),\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl RetryQuadraticError {\n    pub(crate) fn new() -> RetryQuadraticError {\n        RetryQuadraticError(())\n    }\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {\n        HalfMatch { pattern, offset }\n    }\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {\n        MatchError::new(MatchErrorKind::Quit {\n            byte,\n            offset,\n        })\n    }\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {}\n}\n#[cfg(feature = \"dfa-build\")]\npub(crate) fn dfa_try_search_half_rev(\n    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,\n    input: &Input<'_>,\n    min_start: usize,\n) -> Result<Option<HalfMatch>, RetryError> {\n    use crate::dfa::Automaton;\n    let mut mat = None;\n    let mut sid = dfa.start_state_reverse(input)?;\n    if input.start() == input.end() {\n        dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;\n        return Ok(mat);\n    }\n    let mut at = input.end() - 1;\n    loop {\n        sid = dfa.next_state(sid, input.haystack()[at]);\n        if dfa.is_special_state(sid) {\n            if dfa.is_match_state(sid) {\n                let pattern = dfa.match_pattern(sid, 0);\n                mat = Some(HalfMatch::new(pattern, at + 1));\n            } else if dfa.is_dead_state(sid) {\n                return Ok(mat);\n            } else if dfa.is_quit_state(sid) {\n                return Err(MatchError::quit(input.haystack()[at], at).into());\n            }\n        }\n        if at == input.start() {\n            break;\n        }\n        at -= 1;\n        if at < min_start {\n            trace!(\n                \"reached position {} which is before the previous literal \\\n\t\t\t\t match, quitting to avoid quadratic behavior\",\n                at,\n            );\n            return Err(RetryError::Quadratic(RetryQuadraticError::new()));\n        }\n    }\n    let was_dead = dfa.is_dead_state(sid);\n    dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;\n    if at == input.start() && mat.map_or(false, |m| m.offset() > input.start())\n        && !was_dead\n    {\n        trace!(\n            \"reached beginning of search at offset {} without hitting \\\n             a dead state, quitting to avoid potential false positive match\",\n            at,\n        );\n        return Err(RetryError::Quadratic(RetryQuadraticError::new()));\n    }\n    Ok(mat)\n}\n#[cfg(feature = \"dfa-build\")]\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn dfa_eoi_rev(\n    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,\n    input: &Input<'_>,\n    sid: &mut crate::util::primitives::StateID,\n    mat: &mut Option<HalfMatch>,\n) -> Result<(), MatchError> {\n    use crate::dfa::Automaton;\n    let sp = input.get_span();\n    if sp.start > 0 {\n        let byte = input.haystack()[sp.start - 1];\n        *sid = dfa.next_state(*sid, byte);\n        if dfa.is_match_state(*sid) {\n            let pattern = dfa.match_pattern(*sid, 0);\n            *mat = Some(HalfMatch::new(pattern, sp.start));\n        } else if dfa.is_quit_state(*sid) {\n            return Err(MatchError::quit(byte, sp.start - 1));\n        }\n    } else {\n        *sid = dfa.next_eoi_state(*sid);\n        if dfa.is_match_state(*sid) {\n            let pattern = dfa.match_pattern(*sid, 0);\n            *mat = Some(HalfMatch::new(pattern, 0));\n        }\n        debug_assert!(! dfa.is_quit_state(* sid));\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n 45 pub(crate) fn dfa_try_search_half_rev(\n 46     dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,\n 47     input: &Input<'_>,\n 48     min_start: usize,\n 49 ) -> Result<Option<HalfMatch>, RetryError> {\n 50     use crate::dfa::Automaton;\n 51 \n 52     let mut mat = None;\n 53     let mut sid = dfa.start_state_reverse(input)?;\n 54     if input.start() == input.end() {\n 55         dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;\n 56         return Ok(mat);\n 57     }\n 58     let mut at = input.end() - 1;\n 59     loop {\n 60         sid = dfa.next_state(sid, input.haystack()[at]);\n 61         if dfa.is_special_state(sid) {\n 62             if dfa.is_match_state(sid) {\n 63                 let pattern = dfa.match_pattern(sid, 0);\n 64                 // Since reverse searches report the beginning of a\n 65                 // match and the beginning is inclusive (not exclusive\n 66                 // like the end of a match), we add 1 to make it\n 67                 // inclusive.\n 68                 mat = Some(HalfMatch::new(pattern, at + 1));\n 69             } else if dfa.is_dead_state(sid) {\n 70                 return Ok(mat);\n 71             } else if dfa.is_quit_state(sid) {\n 72                 return Err(MatchError::quit(input.haystack()[at], at).into());\n 73             }\n 74         }\n 75         if at == input.start() {\n 76             break;\n 77         }\n 78         at -= 1;\n 79         if at < min_start {\n 80             trace!(\n 81                 \"reached position {} which is before the previous literal \\\n 82 \t\t\t\t match, quitting to avoid quadratic behavior\",\n 83                 at,\n 84             );\n 85             return Err(RetryError::Quadratic(RetryQuadraticError::new()));\n 86         }\n 87     }\n 88     let was_dead = dfa.is_dead_state(sid);\n 89     dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;\n 90     // If we reach the beginning of the search and we could otherwise still\n 91     // potentially keep matching if there was more to match, then we actually\n 92     // return an error to indicate giving up on this optimization. Why? Because\n 93     // we can't prove that the real match begins at where we would report it.\n 94     //\n 95     // This only happens when all of the following are true:\n 96     //\n 97     // 1) We reach the starting point of our search span.\n 98     // 2) The match we found is before the starting point.\n 99     // 3) The FSM reports we could possibly find a longer match.\n100     //\n101     // We need (1) because otherwise the search stopped before the starting\n102     // point and there is no possible way to find a more leftmost position.\n103     //\n104     // We need (2) because if the match found has an offset equal to the minimum\n105     // possible offset, then there is no possible more leftmost match.\n106     //\n107     // We need (3) because if the FSM couldn't continue anyway (i.e., it's in\n108     // a dead state), then we know we couldn't find anything more leftmost\n109     // than what we have. (We have to check the state we were in prior to the\n110     // EOI transition since the EOI transition will usually bring us to a dead\n111     // state by virtue of it represents the end-of-input.)\n112     if at == input.start()\n113         && mat.map_or(false, |m| m.offset() > input.start())\n114         && !was_dead\n115     {\n116         trace!(\n117             \"reached beginning of search at offset {} without hitting \\\n118              a dead state, quitting to avoid potential false positive match\",\n119             at,\n120         );\n121         return Err(RetryError::Quadratic(RetryQuadraticError::new()));\n122     }\n123     Ok(mat)\n124 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}