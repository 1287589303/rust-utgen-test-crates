{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/search.rs\n// crate name is regex_automata\nuse core::ops::{Range, RangeBounds};\nuse crate::util::{escape::DebugByte, primitives::PatternID, utf8};\n#[cfg(feature = \"alloc\")]\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct PatternSet {\n    /// The number of patterns set to 'true' in this set.\n    len: usize,\n    /// A map from PatternID to boolean of whether a pattern matches or not.\n    ///\n    /// This should probably be a bitset, but it's probably unlikely to matter\n    /// much in practice.\n    ///\n    /// The main downside of this representation (and similarly for a bitset)\n    /// is that iteration scales with the capacity of the set instead of\n    /// the length of the set. This doesn't seem likely to be a problem in\n    /// practice.\n    ///\n    /// Another alternative is to just use a 'SparseSet' for this. It does use\n    /// more memory (quite a bit more), but that seems fine I think compared\n    /// to the memory being used by the regex engine. The real hiccup with\n    /// it is that it yields pattern IDs in the order they were inserted.\n    /// Which is actually kind of nice, but at the time of writing, pattern\n    /// IDs are yielded in ascending order in the regex crate RegexSet API.\n    /// If we did change to 'SparseSet', we could provide an additional\n    /// 'iter_match_order' iterator, but keep the ascending order one for\n    /// compatibility.\n    which: alloc::boxed::Box<[bool]>,\n}\n#[cfg(feature = \"alloc\")]\nimpl PatternSet {\n    pub fn new(capacity: usize) -> PatternSet {\n        assert!(\n            capacity <= PatternID::LIMIT, \"pattern set capacity exceeds limit of {}\",\n            PatternID::LIMIT,\n        );\n        PatternSet {\n            len: 0,\n            which: alloc::vec![false; capacity].into_boxed_slice(),\n        }\n    }\n    pub fn clear(&mut self) {}\n    pub fn contains(&self, pid: PatternID) -> bool {}\n    pub fn insert(&mut self, pid: PatternID) -> bool {}\n    pub fn try_insert(&mut self, pid: PatternID) -> Result<bool, PatternSetInsertError> {}\n    pub fn is_empty(&self) -> bool {}\n    pub fn is_full(&self) -> bool {}\n    pub fn len(&self) -> usize {}\n    pub fn capacity(&self) -> usize {}\n    pub fn iter(&self) -> PatternSetIter<'_> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Create a new set of pattern identifiers with the given capacity.\n///\n/// The given capacity typically corresponds to (at least) the number of\n/// patterns in a compiled regex object.\n///\n/// # Panics\n///\n/// This panics if the given capacity exceeds [`PatternID::LIMIT`]. This is\n/// impossible if you use the `pattern_len()` method as defined on any of\n/// the regex engines in this crate. Namely, a regex will fail to build by\n/// returning an error if the number of patterns given to it exceeds the\n/// limit. Therefore, the number of patterns in a valid regex is always\n/// a correct capacity to provide here.\n1189 pub fn new(capacity: usize) -> PatternSet {\n1190     assert!(\n1191         capacity <= PatternID::LIMIT,\n1192         \"pattern set capacity exceeds limit of {}\",\n1193         PatternID::LIMIT,\n1194     );\n1195     PatternSet {\n1196         len: 0,\n1197         which: alloc::vec![false; capacity].into_boxed_slice(),\n1198     }\n1199 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}