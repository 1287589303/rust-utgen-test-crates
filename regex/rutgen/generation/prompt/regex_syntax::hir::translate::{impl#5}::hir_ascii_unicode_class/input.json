{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/translate.rs\n// crate name is regex_syntax\ntype Result<T> = core::result::Result<T, Error>;\nuse core::cell::{Cell, RefCell};\nuse alloc::{boxed::Box, string::ToString, vec, vec::Vec};\nuse crate::{\n    ast::{self, Ast, Span, Visitor},\n    either::Either, hir::{self, Error, ErrorKind, Hir, HirKind},\n    unicode::{self, ClassQuery},\n};\npub trait Visitor {\n    type Output;\n    type Err;\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n    fn start(&mut self);\n    fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_concat_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}\n#[derive(Clone, Debug)]\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}\n#[derive(Clone, Debug)]\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    utf8: bool,\n    /// The line terminator to use for `.`.\n    line_terminator: u8,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassAscii {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of ASCII class.\n    pub kind: ClassAsciiKind,\n    /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated\n    /// but `[[:^alpha:]]` is.\n    pub negated: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the translator's Ast was parsed from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error, derived from the Ast given to the translator.\n    span: Span,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum ClassAsciiKind {\n    /// `[0-9A-Za-z]`\n    Alnum,\n    /// `[A-Za-z]`\n    Alpha,\n    /// `[\\x00-\\x7F]`\n    Ascii,\n    /// `[ \\t]`\n    Blank,\n    /// `[\\x00-\\x1F\\x7F]`\n    Cntrl,\n    /// `[0-9]`\n    Digit,\n    /// `[!-~]`\n    Graph,\n    /// `[a-z]`\n    Lower,\n    /// `[ -~]`\n    Print,\n    /// `[!-/:-@\\[-`{-~]`\n    Punct,\n    /// `[\\t\\n\\v\\f\\r ]`\n    Space,\n    /// `[A-Z]`\n    Upper,\n    /// `[0-9A-Za-z_]`\n    Word,\n    /// `[0-9A-Fa-f]`\n    Xdigit,\n}\nimpl<'t, 'p> TranslatorI<'t, 'p> {\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {}\n    fn trans(&self) -> &Translator {}\n    fn push(&self, frame: HirFrame) {}\n    fn push_char(&self, ch: char) {}\n    fn push_byte(&self, byte: u8) {}\n    fn pop(&self) -> Option<HirFrame> {}\n    fn pop_concat_expr(&self) -> Option<Hir> {}\n    fn pop_alt_expr(&self) -> Option<Hir> {}\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {}\n    fn flags(&self) -> Flags {}\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {}\n    fn ast_literal_to_scalar(&self, lit: &ast::Literal) -> Result<Either<char, u8>> {}\n    fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>> {}\n    fn hir_dot(&self, span: Span) -> Result<Hir> {}\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {}\n    fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir {}\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {}\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {}\n    fn hir_ascii_unicode_class(\n        &self,\n        ast: &ast::ClassAscii,\n    ) -> Result<hir::ClassUnicode> {\n        let mut cls = hir::ClassUnicode::new(\n            ascii_class_as_chars(&ast.kind)\n                .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),\n        );\n        self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n        Ok(cls)\n    }\n    fn hir_ascii_byte_class(&self, ast: &ast::ClassAscii) -> Result<hir::ClassBytes> {}\n    fn hir_perl_unicode_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassUnicode> {}\n    fn hir_perl_byte_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassBytes> {}\n    fn convert_unicode_class_error(\n        &self,\n        span: &Span,\n        result: core::result::Result<hir::ClassUnicode, unicode::Error>,\n    ) -> Result<hir::ClassUnicode> {}\n    fn unicode_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassUnicode,\n    ) -> Result<()> {\n        if self.flags().case_insensitive() {\n            class\n                .try_case_fold_simple()\n                .map_err(|_| {\n                    self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)\n                })?;\n        }\n        if negated {\n            class.negate();\n        }\n        Ok(())\n    }\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {}\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {}\n}\nfn ascii_class_as_chars(\n    kind: &ast::ClassAsciiKind,\n) -> impl Iterator<Item = (char, char)> {\n    ascii_class(kind).map(|(s, e)| (char::from(s), char::from(e)))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1061 fn hir_ascii_unicode_class(\n1062     &self,\n1063     ast: &ast::ClassAscii,\n1064 ) -> Result<hir::ClassUnicode> {\n1065     let mut cls = hir::ClassUnicode::new(\n1066         ascii_class_as_chars(&ast.kind)\n1067             .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),\n1068     );\n1069     self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n1070     Ok(cls)\n1071 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}