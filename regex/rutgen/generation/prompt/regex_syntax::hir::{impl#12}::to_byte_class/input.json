{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Debug)]\npub struct IntervalSet<I> {\n    /// A sorted set of non-overlapping ranges.\n    ranges: Vec<I>,\n    /// While not required at all for correctness, we keep track of whether an\n    /// interval set has been case folded or not. This helps us avoid doing\n    /// redundant work if, for example, a set has already been cased folded.\n    /// And note that whether a set is folded or not is preserved through\n    /// all of the pairwise set operations. That is, if both interval sets\n    /// have been case folded, then any of difference, union, intersection or\n    /// symmetric difference all produce a case folded set.\n    ///\n    /// Note that when this is true, it *must* be the case that the set is case\n    /// folded. But when it's false, the set *may* be case folded. In other\n    /// words, we only set this to true when we know it to be case, but we're\n    /// okay with it being false if it would otherwise be costly to determine\n    /// whether it should be true. This means code cannot assume that a false\n    /// value necessarily indicates that the set is not case folded.\n    ///\n    /// Bottom line: this is a performance optimization.\n    folded: bool,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassUnicodeRange {\n    start: char,\n    end: char,\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {}\n    pub fn empty() -> ClassUnicode {}\n    pub fn push(&mut self, range: ClassUnicodeRange) {}\n    pub fn iter(&self) -> ClassUnicodeIter<'_> {}\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {\n        self.set.intervals()\n    }\n    pub fn case_fold_simple(&mut self) {}\n    pub fn try_case_fold_simple(&mut self) -> core::result::Result<(), CaseFoldError> {}\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassUnicode) {}\n    pub fn intersect(&mut self, other: &ClassUnicode) {}\n    pub fn difference(&mut self, other: &ClassUnicode) {}\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {}\n    pub fn is_ascii(&self) -> bool {\n        self.set.intervals().last().map_or(true, |r| r.end <= '\\x7F')\n    }\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_byte_class(&self) -> Option<ClassBytes> {\n        if !self.is_ascii() {\n            return None;\n        }\n        Some(\n            ClassBytes::new(\n                self\n                    .ranges()\n                    .iter()\n                    .map(|r| {\n                        ClassBytesRange {\n                            start: u8::try_from(r.start).unwrap(),\n                            end: u8::try_from(r.end).unwrap(),\n                        }\n                    }),\n            ),\n        )\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// If this class consists of only ASCII ranges, then return its\n/// corresponding and equivalent byte class.\n1207 pub fn to_byte_class(&self) -> Option<ClassBytes> {\n1208     if !self.is_ascii() {\n1209         return None;\n1210     }\n1211     Some(ClassBytes::new(self.ranges().iter().map(|r| {\n1212         // Since we are guaranteed that our codepoint range is ASCII, the\n1213         // 'u8::try_from' calls below are guaranteed to be correct.\n1214         ClassBytesRange {\n1215             start: u8::try_from(r.start).unwrap(),\n1216             end: u8::try_from(r.end).unwrap(),\n1217         }\n1218     })))\n1219 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}