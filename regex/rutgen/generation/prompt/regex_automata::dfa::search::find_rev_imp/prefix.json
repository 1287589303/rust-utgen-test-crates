{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/search.rs\n// crate name is regex_automata\nuse crate::{\n    dfa::{accel, automaton::{Automaton, OverlappingState}},\n    util::{\n        prefilter::Prefilter, primitives::StateID,\n        search::{Anchored, HalfMatch, Input, Span},\n    },\n    MatchError,\n};\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {\n        HalfMatch { pattern, offset }\n    }\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {\n        MatchError::new(MatchErrorKind::Quit {\n            byte,\n            offset,\n        })\n    }\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {}\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn find_rev_imp<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    earliest: bool,\n) -> Result<Option<HalfMatch>, MatchError> {\n    let mut mat = None;\n    let mut sid = init_rev(dfa, input)?;\n    if input.start() == input.end() {\n        eoi_rev(dfa, input, &mut sid, &mut mat)?;\n        return Ok(mat);\n    }\n    let mut at = input.end() - 1;\n    macro_rules! next_unchecked {\n        ($sid:expr, $at:expr) => {\n            { let byte = * input.haystack().get_unchecked($at); dfa\n            .next_state_unchecked($sid, byte) }\n        };\n    }\n    loop {\n        let mut prev_sid;\n        while at >= input.start() {\n            prev_sid = unsafe { next_unchecked!(sid, at) };\n            if dfa.is_special_state(prev_sid) || at <= input.start().saturating_add(3) {\n                core::mem::swap(&mut prev_sid, &mut sid);\n                break;\n            }\n            at -= 1;\n            sid = unsafe { next_unchecked!(prev_sid, at) };\n            if dfa.is_special_state(sid) {\n                break;\n            }\n            at -= 1;\n            prev_sid = unsafe { next_unchecked!(sid, at) };\n            if dfa.is_special_state(prev_sid) {\n                core::mem::swap(&mut prev_sid, &mut sid);\n                break;\n            }\n            at -= 1;\n            sid = unsafe { next_unchecked!(prev_sid, at) };\n            if dfa.is_special_state(sid) {\n                break;\n            }\n            at -= 1;\n        }\n        if dfa.is_special_state(sid) {\n            if dfa.is_start_state(sid) {\n                if dfa.is_accel_state(sid) {\n                    let needles = dfa.accelerator(sid);\n                    at = accel::find_rev(needles, input.haystack(), at)\n                        .map(|i| i + 1)\n                        .unwrap_or(input.start());\n                }\n            } else if dfa.is_match_state(sid) {\n                let pattern = dfa.match_pattern(sid, 0);\n                mat = Some(HalfMatch::new(pattern, at + 1));\n                if earliest {\n                    return Ok(mat);\n                }\n                if dfa.is_accel_state(sid) {\n                    let needles = dfa.accelerator(sid);\n                    at = accel::find_rev(needles, input.haystack(), at)\n                        .map(|i| i + 1)\n                        .unwrap_or(input.start());\n                }\n            } else if dfa.is_accel_state(sid) {\n                let needles = dfa.accelerator(sid);\n                at = accel::find_rev(needles, input.haystack(), at)\n                    .map(|i| i + 1)\n                    .unwrap_or(input.start());\n            } else if dfa.is_dead_state(sid) {\n                return Ok(mat);\n            } else {\n                return Err(MatchError::quit(input.haystack()[at], at));\n            }\n        }\n        if at == input.start() {\n            break;\n        }\n        at -= 1;\n    }\n    eoi_rev(dfa, input, &mut sid, &mut mat)?;\n    Ok(mat)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn eoi_rev<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    sid: &mut StateID,\n    mat: &mut Option<HalfMatch>,\n) -> Result<(), MatchError> {\n    let sp = input.get_span();\n    if sp.start > 0 {\n        let byte = input.haystack()[sp.start - 1];\n        *sid = dfa.next_state(*sid, byte);\n        if dfa.is_match_state(*sid) {\n            let pattern = dfa.match_pattern(*sid, 0);\n            *mat = Some(HalfMatch::new(pattern, sp.start));\n        } else if dfa.is_quit_state(*sid) {\n            return Err(MatchError::quit(byte, sp.start - 1));\n        }\n    } else {\n        *sid = dfa.next_eoi_state(*sid);\n        if dfa.is_match_state(*sid) {\n            let pattern = dfa.match_pattern(*sid, 0);\n            *mat = Some(HalfMatch::new(pattern, 0));\n        }\n    }\n    Ok(())\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\npub(crate) fn find_rev(needles: &[u8], haystack: &[u8], at: usize) -> Option<usize> {\n    let bs = needles;\n    match needles.len() {\n        1 => memchr::memrchr(bs[0], &haystack[..at]),\n        2 => memchr::memrchr2(bs[0], bs[1], &haystack[..at]),\n        3 => memchr::memrchr3(bs[0], bs[1], bs[2], &haystack[..at]),\n        0 => panic!(\"cannot find with empty needles\"),\n        n => panic!(\"invalid needles length: {}\", n),\n    }\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn init_rev<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n) -> Result<StateID, MatchError> {\n    let sid = dfa.start_state_reverse(input)?;\n    debug_assert!(! dfa.is_match_state(sid));\n    Ok(sid)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n204 fn find_rev_imp<A: Automaton + ?Sized>(\n205     dfa: &A,\n206     input: &Input<'_>,\n207     earliest: bool,\n208 ) -> Result<Option<HalfMatch>, MatchError> {\n209     let mut mat = None;\n210     let mut sid = init_rev(dfa, input)?;\n211     // In reverse search, the loop below can't handle the case of searching an\n212     // empty slice. Ideally we could write something congruent to the forward\n213     // search, i.e., 'while at >= start', but 'start' might be 0. Since we use\n214     // an unsigned offset, 'at >= 0' is trivially always true. We could avoid\n215     // this extra case handling by using a signed offset, but Rust makes it\n216     // annoying to do. So... We just handle the empty case separately.\n217     if input.start() == input.end() {\n218         eoi_rev(dfa, input, &mut sid, &mut mat)?;\n219         return Ok(mat);\n220     }\n221 \n222     let mut at = input.end() - 1;\n223     macro_rules! next_unchecked {\n224         ($sid:expr, $at:expr) => {{\n225             let byte = *input.haystack().get_unchecked($at);\n226             dfa.next_state_unchecked($sid, byte)\n227         }};\n228     }\n229     loop {\n230         // SAFETY: See comments in 'find_fwd' for a safety argument.\n231         let mut prev_sid;\n232         while at >= input.start() {\n233             prev_sid = unsafe { next_unchecked!(sid, at) };\n234             if dfa.is_special_state(prev_sid)\n235                 || at <= input.start().saturating_add(3)\n236             {\n237                 core::mem::swap(&mut prev_sid, &mut sid);\n238                 break;\n239             }\n240             at -= 1;\n241 \n242             sid = unsafe { next_unchecked!(prev_sid, at) };\n243             if dfa.is_special_state(sid) {\n244                 break;\n245             }\n246             at -= 1;\n247 \n248             prev_sid = unsafe { next_unchecked!(sid, at) };\n249             if dfa.is_special_state(prev_sid) {\n250                 core::mem::swap(&mut prev_sid, &mut sid);\n251                 break;\n252             }\n253             at -= 1;\n254 \n255             sid = unsafe { next_unchecked!(prev_sid, at) };\n256             if dfa.is_special_state(sid) {\n257                 break;\n258             }\n259             at -= 1;\n260         }\n261         if dfa.is_special_state(sid) {\n262             if dfa.is_start_state(sid) {\n263                 if dfa.is_accel_state(sid) {\n264                     let needles = dfa.accelerator(sid);\n265                     at = accel::find_rev(needles, input.haystack(), at)\n266                         .map(|i| i + 1)\n267                         .unwrap_or(input.start());\n268                 }\n269             } else if dfa.is_match_state(sid) {\n270                 let pattern = dfa.match_pattern(sid, 0);\n271                 // Since reverse searches report the beginning of a match\n272                 // and the beginning is inclusive (not exclusive like the\n273                 // end of a match), we add 1 to make it inclusive.\n274                 mat = Some(HalfMatch::new(pattern, at + 1));\n275                 if earliest {\n276                     return Ok(mat);\n277                 }\n278                 if dfa.is_accel_state(sid) {\n279                     let needles = dfa.accelerator(sid);\n280                     at = accel::find_rev(needles, input.haystack(), at)\n281                         .map(|i| i + 1)\n282                         .unwrap_or(input.start());\n283                 }\n284             } else if dfa.is_accel_state(sid) {\n285                 let needles = dfa.accelerator(sid);\n286                 // If the accelerator returns nothing, why don't we quit the\n287                 // search? Well, if the accelerator doesn't find anything, that\n288                 // doesn't mean we don't have a match. It just means that we\n289                 // can't leave the current state given one of the 255 possible\n290                 // byte values. However, there might be an EOI transition. So\n291                 // we set 'at' to the end of the haystack, which will cause\n292                 // this loop to stop and fall down into the EOI transition.\n293                 at = accel::find_rev(needles, input.haystack(), at)\n294                     .map(|i| i + 1)\n295                     .unwrap_or(input.start());\n296             } else if dfa.is_dead_state(sid) {\n297                 return Ok(mat);\n298             } else {\n299                 return Err(MatchError::quit(input.haystack()[at], at));\n300             }\n301         }\n302         if at == input.start() {\n303             break;\n304         }\n305         at -= 1;\n306     }\n307     eoi_rev(dfa, input, &mut sid, &mut mat)?;\n308     Ok(mat)\n309 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}