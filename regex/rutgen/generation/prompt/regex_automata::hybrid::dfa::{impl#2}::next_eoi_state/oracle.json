{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/hybrid/dfa.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype StateMap = std::collections::HashMap<State, LazyStateID>;\n#[cfg(not(feature = \"std\"))]\ntype StateMap = alloc::collections::BTreeMap<State, LazyStateID>;\nuse core::{iter, mem::size_of};\nuse alloc::vec::Vec;\nuse crate::{\n    hybrid::{\n        error::{BuildError, CacheError, StartError},\n        id::{LazyStateID, LazyStateIDError},\n        search,\n    },\n    nfa::thompson,\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        determinize::{self, State, StateBuilderEmpty, StateBuilderNFA},\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID as NFAStateID},\n        search::{Anchored, HalfMatch, Input, MatchError, MatchKind, PatternSet},\n        sparse_set::SparseSets, start::{self, Start, StartByteMap},\n    },\n};\nconst MIN_STATES: usize = SENTINEL_STATES + 2;\nconst SENTINEL_STATES: usize = 3;\n#[derive(Clone, Debug)]\npub struct DFA {\n    config: Config,\n    nfa: thompson::NFA,\n    stride2: usize,\n    start_map: StartByteMap,\n    classes: ByteClasses,\n    quitset: ByteSet,\n    cache_capacity: usize,\n}\n#[derive(Debug)]\nstruct Lazy<'i, 'c> {\n    dfa: &'i DFA,\n    cache: &'c mut Cache,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct LazyStateID(u32);\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]\npub struct Unit(UnitKind);\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// The transition table.\n    ///\n    /// Given a `current` LazyStateID and an `input` byte, the next state can\n    /// be computed via `trans[untagged(current) + equiv_class(input)]`. Notice\n    /// that no multiplication is used. That's because state identifiers are\n    /// \"premultiplied.\"\n    ///\n    /// Note that the next state may be the \"unknown\" state. In this case, the\n    /// next state is not known and determinization for `current` on `input`\n    /// must be performed.\n    trans: Vec<LazyStateID>,\n    /// The starting states for this DFA.\n    ///\n    /// These are computed lazily. Initially, these are all set to \"unknown\"\n    /// lazy state IDs.\n    ///\n    /// When 'starts_for_each_pattern' is disabled (the default), then the size\n    /// of this is constrained to the possible starting configurations based\n    /// on the search parameters. (At time of writing, that's 4.) However,\n    /// when starting states for each pattern is enabled, then there are N\n    /// additional groups of starting states, where each group reflects the\n    /// different possible configurations and N is the number of patterns.\n    starts: Vec<LazyStateID>,\n    /// A sequence of NFA/DFA powerset states that have been computed for this\n    /// lazy DFA. This sequence is indexable by untagged LazyStateIDs. (Every\n    /// tagged LazyStateID can be used to index this sequence by converting it\n    /// to its untagged form.)\n    states: Vec<State>,\n    /// A map from states to their corresponding IDs. This map may be accessed\n    /// via the raw byte representation of a state, which means that a `State`\n    /// does not need to be allocated to determine whether it already exists\n    /// in this map. Indeed, the existence of such a state is what determines\n    /// whether we allocate a new `State` or not.\n    ///\n    /// The higher level idea here is that we do just enough determinization\n    /// for a state to check whether we've already computed it. If we have,\n    /// then we can save a little (albeit not much) work. The real savings is\n    /// in memory usage. If we never checked for trivially duplicate states,\n    /// then our memory usage would explode to unreasonable levels.\n    states_to_id: StateMap,\n    /// Sparse sets used to track which NFA states have been visited during\n    /// various traversals.\n    sparses: SparseSets,\n    /// Scratch space for traversing the NFA graph. (We use space on the heap\n    /// instead of the call stack.)\n    stack: Vec<NFAStateID>,\n    /// Scratch space for building a NFA/DFA powerset state. This is used to\n    /// help amortize allocation since not every powerset state generated is\n    /// added to the cache. In particular, if it already exists in the cache,\n    /// then there is no need to allocate a new `State` for it.\n    scratch_state_builder: StateBuilderEmpty,\n    /// A simple abstraction for handling the saving of at most a single state\n    /// across a cache clearing. This is required for correctness. Namely, if\n    /// adding a new state after clearing the cache fails, then the caller\n    /// must retain the ability to continue using the state ID given. The\n    /// state corresponding to the state ID is what we preserve across cache\n    /// clearings.\n    state_saver: StateSaver,\n    /// The memory usage, in bytes, used by 'states' and 'states_to_id'. We\n    /// track this as new states are added since states use a variable amount\n    /// of heap. Tracking this as we add states makes it possible to compute\n    /// the total amount of memory used by the determinizer in constant time.\n    memory_usage_state: usize,\n    /// The number of times the cache has been cleared. When a minimum cache\n    /// clear count is set, then the cache will return an error instead of\n    /// clearing the cache if the count has been exceeded.\n    clear_count: usize,\n    /// The total number of bytes searched since the last time this cache was\n    /// cleared, not including the current search.\n    ///\n    /// This can be added to the length of the current search to get the true\n    /// total number of bytes searched.\n    ///\n    /// This is generally only non-zero when the\n    /// `Cache::search_{start,update,finish}` APIs are used to track search\n    /// progress.\n    bytes_searched: usize,\n    /// The progress of the current search.\n    ///\n    /// This is only non-`None` when callers utlize the `Cache::search_start`,\n    /// `Cache::search_update` and `Cache::search_finish` APIs.\n    ///\n    /// The purpose of recording search progress is to be able to make a\n    /// determination about the efficiency of the cache. Namely, by keeping\n    /// track of the\n    progress: Option<SearchProgress>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone)]\npub(crate) struct StartByteMap {\n    map: [Start; 256],\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug)]\npub struct CacheError(());\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]\npub(crate) struct ByteSet {\n    bits: BitSet,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\nimpl DFA {\n    #[inline]\n    pub fn next_state(\n        &self,\n        cache: &mut Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> Result<LazyStateID, CacheError> {}\n    #[inline]\n    pub fn next_state_untagged(\n        &self,\n        cache: &Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> LazyStateID {}\n    #[inline]\n    pub unsafe fn next_state_untagged_unchecked(\n        &self,\n        cache: &Cache,\n        current: LazyStateID,\n        input: u8,\n    ) -> LazyStateID {}\n    #[inline]\n    pub fn next_eoi_state(\n        &self,\n        cache: &mut Cache,\n        current: LazyStateID,\n    ) -> Result<LazyStateID, CacheError> {\n        let eoi = self.classes.eoi().as_usize();\n        let offset = current.as_usize_untagged() + eoi;\n        let sid = cache.trans[offset];\n        if !sid.is_unknown() {\n            return Ok(sid);\n        }\n        let unit = self.classes.eoi();\n        Lazy::new(self, cache).cache_next_state(current, unit)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state(\n        &self,\n        cache: &mut Cache,\n        config: &start::Config,\n    ) -> Result<LazyStateID, StartError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state_forward(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<LazyStateID, MatchError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn start_state_reverse(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<LazyStateID, MatchError> {}\n    #[inline]\n    pub fn match_len(&self, cache: &Cache, id: LazyStateID) -> usize {}\n    #[inline]\n    pub fn match_pattern(\n        &self,\n        cache: &Cache,\n        id: LazyStateID,\n        match_index: usize,\n    ) -> PatternID {}\n}\nimpl<'i, 'c> Lazy<'i, 'c> {\n    fn new(dfa: &'i DFA, cache: &'c mut Cache) -> Lazy<'i, 'c> {\n        Lazy { dfa, cache }\n    }\n    fn as_ref<'a>(&'a self) -> LazyRef<'i, 'a> {}\n    #[cold]\n    #[inline(never)]\n    fn cache_next_state(\n        &mut self,\n        mut current: LazyStateID,\n        unit: alphabet::Unit,\n    ) -> Result<LazyStateID, CacheError> {\n        let stride2 = self.dfa.stride2();\n        let empty_builder = self.get_state_builder();\n        let builder = determinize::next(\n            self.dfa.get_nfa(),\n            self.dfa.get_config().get_match_kind(),\n            &mut self.cache.sparses,\n            &mut self.cache.stack,\n            &self.cache.states[current.as_usize_untagged() >> stride2],\n            unit,\n            empty_builder,\n        );\n        let save_state = !self.as_ref().state_builder_fits_in_cache(&builder);\n        if save_state {\n            self.save_state(current);\n        }\n        let next = self.add_builder_state(builder, |sid| sid)?;\n        if save_state {\n            current = self.saved_state_id();\n        }\n        self.set_transition(current, unit, next);\n        Ok(next)\n    }\n    #[cold]\n    #[inline(never)]\n    fn cache_start_group(\n        &mut self,\n        anchored: Anchored,\n        start: Start,\n    ) -> Result<LazyStateID, StartError> {}\n    fn cache_start_one(\n        &mut self,\n        nfa_start_id: NFAStateID,\n        start: Start,\n    ) -> Result<LazyStateID, CacheError> {}\n    fn add_builder_state(\n        &mut self,\n        builder: StateBuilderNFA,\n        idmap: impl Fn(LazyStateID) -> LazyStateID,\n    ) -> Result<LazyStateID, CacheError> {}\n    fn add_state(\n        &mut self,\n        state: State,\n        idmap: impl Fn(LazyStateID) -> LazyStateID,\n    ) -> Result<LazyStateID, CacheError> {}\n    fn next_state_id(&mut self) -> Result<LazyStateID, CacheError> {}\n    fn try_clear_cache(&mut self) -> Result<(), CacheError> {}\n    fn reset_cache(&mut self) {}\n    fn clear_cache(&mut self) {}\n    fn init_cache(&mut self) {}\n    fn save_state(&mut self, id: LazyStateID) {}\n    fn saved_state_id(&mut self) -> LazyStateID {}\n    fn set_all_transitions(&mut self, from: LazyStateID, to: LazyStateID) {}\n    fn set_transition(\n        &mut self,\n        from: LazyStateID,\n        unit: alphabet::Unit,\n        to: LazyStateID,\n    ) {}\n    fn set_start_state(&mut self, anchored: Anchored, start: Start, id: LazyStateID) {}\n    fn get_state_builder(&mut self) -> StateBuilderEmpty {}\n    fn put_state_builder(&mut self, builder: StateBuilderNFA) {}\n}\nimpl LazyStateID {\n    #[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n    const MAX_BIT: usize = 31;\n    #[cfg(target_pointer_width = \"16\")]\n    const MAX_BIT: usize = 15;\n    const MASK_UNKNOWN: usize = 1 << (LazyStateID::MAX_BIT);\n    const MASK_DEAD: usize = 1 << (LazyStateID::MAX_BIT - 1);\n    const MASK_QUIT: usize = 1 << (LazyStateID::MAX_BIT - 2);\n    const MASK_START: usize = 1 << (LazyStateID::MAX_BIT - 3);\n    const MASK_MATCH: usize = 1 << (LazyStateID::MAX_BIT - 4);\n    const MAX: usize = LazyStateID::MASK_MATCH - 1;\n    #[inline]\n    pub(crate) fn new(id: usize) -> Result<LazyStateID, LazyStateIDError> {}\n    #[inline]\n    const fn new_unchecked(id: usize) -> LazyStateID {}\n    #[inline]\n    pub(crate) fn as_usize_untagged(&self) -> usize {\n        self.as_usize_unchecked() & LazyStateID::MAX\n    }\n    #[inline]\n    pub(crate) const fn as_usize_unchecked(&self) -> usize {}\n    #[inline]\n    pub(crate) const fn to_unknown(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_dead(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_quit(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_start(&self) -> LazyStateID {}\n    #[inline]\n    pub(crate) const fn to_match(&self) -> LazyStateID {}\n    #[inline]\n    pub const fn is_tagged(&self) -> bool {}\n    #[inline]\n    pub const fn is_unknown(&self) -> bool {\n        self.as_usize_unchecked() & LazyStateID::MASK_UNKNOWN > 0\n    }\n    #[inline]\n    pub const fn is_dead(&self) -> bool {}\n    #[inline]\n    pub const fn is_quit(&self) -> bool {}\n    #[inline]\n    pub const fn is_start(&self) -> bool {}\n    #[inline]\n    pub const fn is_match(&self) -> bool {}\n}\nimpl ByteClasses {\n    #[inline]\n    pub fn empty() -> ByteClasses {}\n    #[inline]\n    pub fn singletons() -> ByteClasses {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteClasses, usize), DeserializeError> {}\n    pub(crate) fn write_to(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[inline]\n    pub fn set(&mut self, byte: u8, class: u8) {}\n    #[inline]\n    pub fn get(&self, byte: u8) -> u8 {}\n    #[inline]\n    pub fn get_by_unit(&self, unit: Unit) -> usize {}\n    #[inline]\n    pub fn eoi(&self) -> Unit {\n        Unit::eoi(self.alphabet_len().checked_sub(1).unwrap())\n    }\n    #[inline]\n    pub fn alphabet_len(&self) -> usize {}\n    #[inline]\n    pub fn stride2(&self) -> usize {}\n    #[inline]\n    pub fn is_singleton(&self) -> bool {}\n    #[inline]\n    pub fn iter(&self) -> ByteClassIter<'_> {}\n    pub fn representatives<R: core::ops::RangeBounds<u8>>(\n        &self,\n        range: R,\n    ) -> ByteClassRepresentatives<'_> {}\n    #[inline]\n    pub fn elements(&self, class: Unit) -> ByteClassElements {}\n    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges {}\n}\nimpl Unit {\n    pub fn u8(byte: u8) -> Unit {}\n    pub fn eoi(num_byte_equiv_classes: usize) -> Unit {}\n    pub fn as_u8(self) -> Option<u8> {}\n    pub fn as_eoi(self) -> Option<u16> {}\n    pub fn as_usize(self) -> usize {\n        match self.0 {\n            UnitKind::U8(b) => usize::from(b),\n            UnitKind::EOI(eoi) => usize::from(eoi),\n        }\n    }\n    pub fn is_byte(self, byte: u8) -> bool {}\n    pub fn is_eoi(self) -> bool {}\n    pub fn is_word_byte(self) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Transitions from the current state to the next state for the special\n/// EOI symbol.\n///\n/// The given cache is used to either reuse pre-computed state\n/// transitions, or to store this newly computed transition for future\n/// reuse. Thus, this routine guarantees that it will never return a state\n/// ID that has an \"unknown\" tag.\n///\n/// This routine must be called at the end of every search in a correct\n/// implementation of search. Namely, lazy DFAs in this crate delay matches\n/// by one byte in order to support look-around operators. Thus, after\n/// reaching the end of a haystack, a search implementation must follow one\n/// last EOI transition.\n///\n/// It is best to think of EOI as an additional symbol in the alphabet of a\n/// DFA that is distinct from every other symbol. That is, the alphabet of\n/// lazy DFAs in this crate has a logical size of 257 instead of 256, where\n/// 256 corresponds to every possible inhabitant of `u8`. (In practice, the\n/// physical alphabet size may be smaller because of alphabet compression\n/// via equivalence classes, but EOI is always represented somehow in the\n/// alphabet.)\n///\n/// # State identifier validity\n///\n/// The only valid value for `current` is the lazy state ID returned\n/// by the most recent call to `next_state`, `next_state_untagged`,\n/// `next_state_untagged_unchecked`, `start_state_forward` or\n/// `state_state_reverse` for the given `cache`. Any state ID returned from\n/// prior calls to these routines (with the same `cache`) is considered\n/// invalid (even if it gives an appearance of working). State IDs returned\n/// from _any_ prior call for different `cache` values are also always\n/// invalid.\n///\n/// The returned ID is always a valid ID when `current` refers to a valid\n/// ID.\n///\n/// These validity rules are not checked, even in debug mode. Callers are\n/// required to uphold these rules themselves.\n///\n/// Violating these state ID validity rules will not sacrifice memory\n/// safety, but _may_ produce an incorrect result or a panic.\n///\n/// # Panics\n///\n/// If the given ID does not refer to a valid state, then this routine\n/// may panic but it also may not panic and instead return an invalid or\n/// incorrect ID.\n///\n/// # Example\n///\n/// This shows a simplistic example for walking a DFA for a given haystack,\n/// and then finishing the search with the final EOI transition.\n///\n/// ```\n/// use regex_automata::{hybrid::dfa::DFA, Input};\n///\n/// let dfa = DFA::new(r\"[a-z]+r\")?;\n/// let mut cache = dfa.create_cache();\n/// let haystack = \"bar\".as_bytes();\n///\n/// // The start state is determined by inspecting the position and the\n/// // initial bytes of the haystack.\n/// let mut sid = dfa.start_state_forward(\n///     &mut cache, &Input::new(haystack),\n/// )?;\n/// // Walk all the bytes in the haystack.\n/// for &b in haystack {\n///     sid = dfa.next_state(&mut cache, sid, b)?;\n/// }\n/// // Matches are always delayed by 1 byte, so we must explicitly walk\n/// // the special \"EOI\" transition at the end of the search. Without this\n/// // final transition, the assert below will fail since the DFA will not\n/// // have entered a match state yet!\n/// sid = dfa.next_eoi_state(&mut cache, sid)?;\n/// assert!(sid.is_match());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1506 pub fn next_eoi_state(\n1507     &self,\n1508     cache: &mut Cache,\n1509     current: LazyStateID,\n1510 ) -> Result<LazyStateID, CacheError> {\n1511     let eoi = self.classes.eoi().as_usize();\n1512     let offset = current.as_usize_untagged() + eoi;\n1513     let sid = cache.trans[offset];\n1514     if !sid.is_unknown() {\n1515         return Ok(sid);\n1516     }\n1517     let unit = self.classes.eoi();\n1518     Lazy::new(self, cache).cache_next_state(current, unit)\n1519 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}