{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Properties(Box<PropertiesI>);\n#[derive(Clone, Copy, Default, Eq, PartialEq)]\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where `i =\n    /// Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u32,\n}\n#[derive(Clone, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct PropertiesI {\n    minimum_len: Option<usize>,\n    maximum_len: Option<usize>,\n    look_set: LookSet,\n    look_set_prefix: LookSet,\n    look_set_suffix: LookSet,\n    look_set_prefix_any: LookSet,\n    look_set_suffix_any: LookSet,\n    utf8: bool,\n    explicit_captures_len: usize,\n    static_explicit_captures_len: Option<usize>,\n    literal: bool,\n    alternation_literal: bool,\n}\nimpl Properties {\n    fn empty() -> Properties {}\n    fn literal(lit: &Literal) -> Properties {}\n    fn class(class: &Class) -> Properties {}\n    fn look(look: Look) -> Properties {}\n    fn repetition(rep: &Repetition) -> Properties {}\n    fn capture(capture: &Capture) -> Properties {}\n    fn concat(concat: &[Hir]) -> Properties {\n        let mut props = PropertiesI {\n            minimum_len: Some(0),\n            maximum_len: Some(0),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: true,\n            alternation_literal: true,\n        };\n        for x in concat.iter() {\n            let p = x.properties();\n            props.look_set.set_union(p.look_set());\n            props.utf8 = props.utf8 && p.is_utf8();\n            props.explicit_captures_len = props\n                .explicit_captures_len\n                .saturating_add(p.explicit_captures_len());\n            props.static_explicit_captures_len = p\n                .static_explicit_captures_len()\n                .and_then(|len1| { Some((len1, props.static_explicit_captures_len?)) })\n                .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));\n            props.literal = props.literal && p.is_literal();\n            props.alternation_literal = props.alternation_literal\n                && p.is_alternation_literal();\n            if let Some(minimum_len) = props.minimum_len {\n                match p.minimum_len() {\n                    None => props.minimum_len = None,\n                    Some(len) => {\n                        props.minimum_len = Some(minimum_len.saturating_add(len));\n                    }\n                }\n            }\n            if let Some(maximum_len) = props.maximum_len {\n                match p.maximum_len() {\n                    None => props.maximum_len = None,\n                    Some(len) => props.maximum_len = maximum_len.checked_add(len),\n                }\n            }\n        }\n        let mut it = concat.iter();\n        while let Some(x) = it.next() {\n            props.look_set_prefix.set_union(x.properties().look_set_prefix());\n            props.look_set_prefix_any.set_union(x.properties().look_set_prefix_any());\n            if x.properties().maximum_len().map_or(true, |x| x > 0) {\n                break;\n            }\n        }\n        let mut it = concat.iter().rev();\n        while let Some(x) = it.next() {\n            props.look_set_suffix.set_union(x.properties().look_set_suffix());\n            props.look_set_suffix_any.set_union(x.properties().look_set_suffix_any());\n            if x.properties().maximum_len().map_or(true, |x| x > 0) {\n                break;\n            }\n        }\n        Properties(Box::new(props))\n    }\n    fn alternation(alts: &[Hir]) -> Properties {}\n}\nimpl LookSet {\n    #[inline]\n    pub fn empty() -> LookSet {\n        LookSet { bits: 0 }\n    }\n    #[inline]\n    pub fn full() -> LookSet {}\n    #[inline]\n    pub fn singleton(look: Look) -> LookSet {}\n    #[inline]\n    pub fn len(self) -> usize {}\n    #[inline]\n    pub fn is_empty(self) -> bool {}\n    #[inline]\n    pub fn contains(self, look: Look) -> bool {}\n    #[inline]\n    pub fn contains_anchor(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_haystack(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_line(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_lf(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_crlf(&self) -> bool {}\n    #[inline]\n    pub fn contains_word(self) -> bool {}\n    #[inline]\n    pub fn contains_word_unicode(self) -> bool {}\n    #[inline]\n    pub fn contains_word_ascii(self) -> bool {}\n    #[inline]\n    pub fn iter(self) -> LookSetIter {}\n    #[inline]\n    pub fn insert(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_insert(&mut self, look: Look) {}\n    #[inline]\n    pub fn remove(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_remove(&mut self, look: Look) {}\n    #[inline]\n    pub fn subtract(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_subtract(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn union(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_union(&mut self, other: LookSet) {\n        *self = self.union(other);\n    }\n    #[inline]\n    pub fn intersect(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_intersect(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn read_repr(slice: &[u8]) -> LookSet {}\n    #[inline]\n    pub fn write_repr(self, slice: &mut [u8]) {}\n}\nimpl Hir {\n    pub fn kind(&self) -> &HirKind {}\n    pub fn into_kind(mut self) -> HirKind {}\n    pub fn properties(&self) -> &Properties {\n        &self.props\n    }\n    fn into_parts(mut self) -> (HirKind, Properties) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Create a new set of HIR properties for a concatenation.\n2571 fn concat(concat: &[Hir]) -> Properties {\n2572     // The base case is an empty concatenation, which matches the empty\n2573     // string. Note though that empty concatenations aren't possible,\n2574     // because the Hir::concat smart constructor rewrites those as\n2575     // Hir::empty.\n2576     let mut props = PropertiesI {\n2577         minimum_len: Some(0),\n2578         maximum_len: Some(0),\n2579         look_set: LookSet::empty(),\n2580         look_set_prefix: LookSet::empty(),\n2581         look_set_suffix: LookSet::empty(),\n2582         look_set_prefix_any: LookSet::empty(),\n2583         look_set_suffix_any: LookSet::empty(),\n2584         utf8: true,\n2585         explicit_captures_len: 0,\n2586         static_explicit_captures_len: Some(0),\n2587         literal: true,\n2588         alternation_literal: true,\n2589     };\n2590     // Handle properties that need to visit every child hir.\n2591     for x in concat.iter() {\n2592         let p = x.properties();\n2593         props.look_set.set_union(p.look_set());\n2594         props.utf8 = props.utf8 && p.is_utf8();\n2595         props.explicit_captures_len = props\n2596             .explicit_captures_len\n2597             .saturating_add(p.explicit_captures_len());\n2598         props.static_explicit_captures_len = p\n2599             .static_explicit_captures_len()\n2600             .and_then(|len1| {\n2601                 Some((len1, props.static_explicit_captures_len?))\n2602             })\n2603             .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));\n2604         props.literal = props.literal && p.is_literal();\n2605         props.alternation_literal =\n2606             props.alternation_literal && p.is_alternation_literal();\n2607         if let Some(minimum_len) = props.minimum_len {\n2608             match p.minimum_len() {\n2609                 None => props.minimum_len = None,\n2610                 Some(len) => {\n2611                     // We use saturating arithmetic here because the\n2612                     // minimum is just a lower bound. We can't go any\n2613                     // higher than what our number types permit.\n2614                     props.minimum_len =\n2615                         Some(minimum_len.saturating_add(len));\n2616                 }\n2617             }\n2618         }\n2619         if let Some(maximum_len) = props.maximum_len {\n2620             match p.maximum_len() {\n2621                 None => props.maximum_len = None,\n2622                 Some(len) => {\n2623                     props.maximum_len = maximum_len.checked_add(len)\n2624                 }\n2625             }\n2626         }\n2627     }\n2628     // Handle the prefix properties, which only requires visiting\n2629     // child exprs until one matches more than the empty string.\n2630     let mut it = concat.iter();\n2631     while let Some(x) = it.next() {\n2632         props.look_set_prefix.set_union(x.properties().look_set_prefix());\n2633         props\n2634             .look_set_prefix_any\n2635             .set_union(x.properties().look_set_prefix_any());\n2636         if x.properties().maximum_len().map_or(true, |x| x > 0) {\n2637             break;\n2638         }\n2639     }\n2640     // Same thing for the suffix properties, but in reverse.\n2641     let mut it = concat.iter().rev();\n2642     while let Some(x) = it.next() {\n2643         props.look_set_suffix.set_union(x.properties().look_set_suffix());\n2644         props\n2645             .look_set_suffix_any\n2646             .set_union(x.properties().look_set_suffix_any());\n2647         if x.properties().maximum_len().map_or(true, |x| x > 0) {\n2648             break;\n2649         }\n2650     }\n2651     Properties(Box::new(props))\n2652 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}