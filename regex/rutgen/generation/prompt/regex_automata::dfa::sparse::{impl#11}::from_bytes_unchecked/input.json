{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\npub(crate) trait Usize {\n    fn as_u8(self) -> u8;\n    fn as_u16(self) -> u16;\n    fn as_u32(self) -> u32;\n    fn as_u64(self) -> u64;\n}\n#[derive(Clone)]\nstruct StartTable<T> {\n    /// The initial start state IDs as a contiguous table of native endian\n    /// encoded integers, represented by `S`.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8] and has no alignment\n    /// requirements.\n    ///\n    /// The first `2 * stride` (currently always 8) entries always correspond\n    /// to the starts states for the entire DFA, with the first 4 entries being\n    /// for unanchored searches and the second 4 entries being for anchored\n    /// searches. To keep things simple, we always use 8 entries even if the\n    /// `StartKind` is not both.\n    ///\n    /// After that, there are `stride * patterns` state IDs, where `patterns`\n    /// may be zero in the case of a DFA with no patterns or in the case where\n    /// the DFA was built without enabling starting states for each pattern.\n    table: T,\n    /// The starting state configuration supported. When 'both', both\n    /// unanchored and anchored searches work. When 'unanchored', anchored\n    /// searches panic. When 'anchored', unanchored searches panic.\n    kind: StartKind,\n    /// The start state configuration for every possible byte.\n    start_map: StartByteMap,\n    /// The number of starting state IDs per pattern.\n    stride: usize,\n    /// The total number of patterns for which starting states are encoded.\n    /// This is `None` for DFAs that were built without start states for each\n    /// pattern. Thus, one cannot use this field to say how many patterns\n    /// are in the DFA in all cases. It is specific to how many patterns are\n    /// represented in this start table.\n    pattern_len: Option<usize>,\n    /// The universal starting state for unanchored searches. This is only\n    /// present when the DFA supports unanchored searches and when all starting\n    /// state IDs for an unanchored search are equivalent.\n    universal_start_unanchored: Option<StateID>,\n    /// The universal starting state for anchored searches. This is only\n    /// present when the DFA supports anchored searches and when all starting\n    /// state IDs for an anchored search are equivalent.\n    universal_start_anchored: Option<StateID>,\n}\n#[derive(Clone)]\npub(crate) struct StartByteMap {\n    map: [Start; 256],\n}\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum StartKind {\n    /// Support both anchored and unanchored searches.\n    Both,\n    /// Support only unanchored searches. Requesting an anchored search will\n    /// panic.\n    ///\n    /// Note that even if an unanchored search is requested, the pattern itself\n    /// may still be anchored. For example, `^abc` will only match `abc` at the\n    /// start of a haystack. This will remain true, even if the regex engine\n    /// only supported unanchored searches.\n    Unanchored,\n    /// Support only anchored searches. Requesting an unanchored search will\n    /// panic.\n    Anchored,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Start {\n    /// This occurs when the starting position is not any of the ones below.\n    NonWordByte = 0,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is an ASCII word byte.\n    WordByte = 1,\n    /// This occurs when the starting position of the search corresponds to the\n    /// beginning of the haystack.\n    Text = 2,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\n`.\n    LineLF = 3,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\r`.\n    LineCR = 4,\n    /// This occurs when a custom line terminator has been set via a\n    /// `LookMatcher`, and when that line terminator is neither a `\\r` or a\n    /// `\\n`.\n    ///\n    /// If the custom line terminator is a word byte, then this start\n    /// configuration is still selected. DFAs that implement word boundary\n    /// assertions will likely need to check whether the custom line terminator\n    /// is a word byte, in which case, it should behave as if the byte\n    /// satisfies `\\b` in addition to multi-line anchors.\n    CustomLineTerminator = 5,\n}\nimpl<'a> StartTable<&'a [u8]> {\n    unsafe fn from_bytes_unchecked(\n        mut slice: &'a [u8],\n    ) -> Result<(StartTable<&'a [u8]>, usize), DeserializeError> {\n        let slice_start = slice.as_ptr().as_usize();\n        let (kind, nr) = StartKind::from_bytes(slice)?;\n        slice = &slice[nr..];\n        let (start_map, nr) = StartByteMap::from_bytes(slice)?;\n        slice = &slice[nr..];\n        let (stride, nr) = wire::try_read_u32_as_usize(\n            slice,\n            \"sparse start table stride\",\n        )?;\n        slice = &slice[nr..];\n        if stride != Start::len() {\n            return Err(\n                DeserializeError::generic(\"invalid sparse starting table stride\"),\n            );\n        }\n        let (maybe_pattern_len, nr) = wire::try_read_u32_as_usize(\n            slice,\n            \"sparse start table patterns\",\n        )?;\n        slice = &slice[nr..];\n        let pattern_len = if maybe_pattern_len.as_u32() == u32::MAX {\n            None\n        } else {\n            Some(maybe_pattern_len)\n        };\n        if pattern_len.map_or(false, |len| len > PatternID::LIMIT) {\n            return Err(DeserializeError::generic(\"sparse invalid number of patterns\"));\n        }\n        let (universal_unanchored, nr) = wire::try_read_u32(\n            slice,\n            \"universal unanchored start\",\n        )?;\n        slice = &slice[nr..];\n        let universal_start_unanchored = if universal_unanchored == u32::MAX {\n            None\n        } else {\n            Some(\n                StateID::try_from(universal_unanchored)\n                    .map_err(|e| {\n                        DeserializeError::state_id_error(e, \"universal unanchored start\")\n                    })?,\n            )\n        };\n        let (universal_anchored, nr) = wire::try_read_u32(\n            slice,\n            \"universal anchored start\",\n        )?;\n        slice = &slice[nr..];\n        let universal_start_anchored = if universal_anchored == u32::MAX {\n            None\n        } else {\n            Some(\n                StateID::try_from(universal_anchored)\n                    .map_err(|e| {\n                        DeserializeError::state_id_error(e, \"universal anchored start\")\n                    })?,\n            )\n        };\n        let pattern_table_size = wire::mul(\n            stride,\n            pattern_len.unwrap_or(0),\n            \"sparse invalid pattern length\",\n        )?;\n        let start_state_len = wire::add(\n            wire::mul(2, stride, \"start state stride too big\")?,\n            pattern_table_size,\n            \"sparse invalid 'any' pattern starts size\",\n        )?;\n        let table_bytes_len = wire::mul(\n            start_state_len,\n            StateID::SIZE,\n            \"sparse pattern table bytes length\",\n        )?;\n        wire::check_slice_len(slice, table_bytes_len, \"sparse start ID table\")?;\n        let table = &slice[..table_bytes_len];\n        slice = &slice[table_bytes_len..];\n        let sl = StartTable {\n            table,\n            kind,\n            start_map,\n            stride,\n            pattern_len,\n            universal_start_unanchored,\n            universal_start_anchored,\n        };\n        Ok((sl, slice.as_ptr().as_usize() - slice_start))\n    }\n}\nimpl StartKind {\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(StartKind, usize), DeserializeError> {\n        wire::check_slice_len(slice, size_of::<u32>(), \"start kind bytes\")?;\n        let (n, nr) = wire::try_read_u32(slice, \"start kind integer\")?;\n        match n {\n            0 => Ok((StartKind::Both, nr)),\n            1 => Ok((StartKind::Unanchored, nr)),\n            2 => Ok((StartKind::Anchored, nr)),\n            _ => Err(DeserializeError::generic(\"unrecognized start kind\")),\n        }\n    }\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn has_unanchored(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn has_anchored(&self) -> bool {}\n}\nimpl Start {\n    pub(crate) fn from_usize(n: usize) -> Option<Start> {}\n    pub(crate) fn len() -> usize {\n        6\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn as_u8(&self) -> u8 {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn as_usize(&self) -> usize {}\n}\nimpl StartByteMap {\n    pub(crate) fn new(lookm: &LookMatcher) -> StartByteMap {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, byte: u8) -> Start {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(StartByteMap, usize), DeserializeError> {\n        wire::check_slice_len(slice, 256, \"start byte map\")?;\n        let mut map = [Start::NonWordByte; 256];\n        for (i, &repr) in slice[..256].iter().enumerate() {\n            map[i] = match Start::from_usize(usize::from(repr)) {\n                Some(start) => start,\n                None => {\n                    return Err(\n                        DeserializeError::generic(\"found invalid starting configuration\"),\n                    );\n                }\n            };\n        }\n        Ok((StartByteMap { map }, 256))\n    }\n    pub(crate) fn write_to(&self, dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n}\nimpl DeserializeError {\n    pub(crate) fn generic(msg: &'static str) -> DeserializeError {\n        DeserializeError(DeserializeErrorKind::Generic {\n            msg,\n        })\n    }\n    pub(crate) fn buffer_too_small(what: &'static str) -> DeserializeError {}\n    fn invalid_usize(what: &'static str) -> DeserializeError {}\n    fn version_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn endian_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn alignment_mismatch(alignment: usize, address: usize) -> DeserializeError {}\n    fn label_mismatch(expected: &'static str) -> DeserializeError {}\n    fn arithmetic_overflow(what: &'static str) -> DeserializeError {}\n    fn pattern_id_error(err: PatternIDError, what: &'static str) -> DeserializeError {}\n    pub(crate) fn state_id_error(\n        err: StateIDError,\n        what: &'static str,\n    ) -> DeserializeError {}\n}\npub(crate) fn add(\n    a: usize,\n    b: usize,\n    what: &'static str,\n) -> Result<usize, DeserializeError> {\n    match a.checked_add(b) {\n        Some(c) => Ok(c),\n        None => Err(DeserializeError::arithmetic_overflow(what)),\n    }\n}\npub(crate) fn try_read_u32_as_usize(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(usize, usize), DeserializeError> {\n    try_read_u32(slice, what)\n        .and_then(|(n, nr)| {\n            usize::try_from(n)\n                .map(|n| (n, nr))\n                .map_err(|_| DeserializeError::invalid_usize(what))\n        })\n}\npub(crate) fn mul(\n    a: usize,\n    b: usize,\n    what: &'static str,\n) -> Result<usize, DeserializeError> {\n    match a.checked_mul(b) {\n        Some(c) => Ok(c),\n        None => Err(DeserializeError::arithmetic_overflow(what)),\n    }\n}\npub(crate) fn check_slice_len<T>(\n    slice: &[T],\n    at_least_len: usize,\n    what: &'static str,\n) -> Result<(), DeserializeError> {\n    if slice.len() < at_least_len {\n        return Err(DeserializeError::buffer_too_small(what));\n    }\n    Ok(())\n}\npub(crate) fn try_read_u32(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(u32, usize), DeserializeError> {\n    check_slice_len(slice, size_of::<u32>(), what)?;\n    Ok((read_u32(slice), size_of::<u32>()))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1854 unsafe fn from_bytes_unchecked(\n1855     mut slice: &'a [u8],\n1856 ) -> Result<(StartTable<&'a [u8]>, usize), DeserializeError> {\n1857     let slice_start = slice.as_ptr().as_usize();\n1858 \n1859     let (kind, nr) = StartKind::from_bytes(slice)?;\n1860     slice = &slice[nr..];\n1861 \n1862     let (start_map, nr) = StartByteMap::from_bytes(slice)?;\n1863     slice = &slice[nr..];\n1864 \n1865     let (stride, nr) =\n1866         wire::try_read_u32_as_usize(slice, \"sparse start table stride\")?;\n1867     slice = &slice[nr..];\n1868     if stride != Start::len() {\n1869         return Err(DeserializeError::generic(\n1870             \"invalid sparse starting table stride\",\n1871         ));\n1872     }\n1873 \n1874     let (maybe_pattern_len, nr) =\n1875         wire::try_read_u32_as_usize(slice, \"sparse start table patterns\")?;\n1876     slice = &slice[nr..];\n1877     let pattern_len = if maybe_pattern_len.as_u32() == u32::MAX {\n1878         None\n1879     } else {\n1880         Some(maybe_pattern_len)\n1881     };\n1882     if pattern_len.map_or(false, |len| len > PatternID::LIMIT) {\n1883         return Err(DeserializeError::generic(\n1884             \"sparse invalid number of patterns\",\n1885         ));\n1886     }\n1887 \n1888     let (universal_unanchored, nr) =\n1889         wire::try_read_u32(slice, \"universal unanchored start\")?;\n1890     slice = &slice[nr..];\n1891     let universal_start_unanchored = if universal_unanchored == u32::MAX {\n1892         None\n1893     } else {\n1894         Some(StateID::try_from(universal_unanchored).map_err(|e| {\n1895             DeserializeError::state_id_error(\n1896                 e,\n1897                 \"universal unanchored start\",\n1898             )\n1899         })?)\n1900     };\n1901 \n1902     let (universal_anchored, nr) =\n1903         wire::try_read_u32(slice, \"universal anchored start\")?;\n1904     slice = &slice[nr..];\n1905     let universal_start_anchored = if universal_anchored == u32::MAX {\n1906         None\n1907     } else {\n1908         Some(StateID::try_from(universal_anchored).map_err(|e| {\n1909             DeserializeError::state_id_error(e, \"universal anchored start\")\n1910         })?)\n1911     };\n1912 \n1913     let pattern_table_size = wire::mul(\n1914         stride,\n1915         pattern_len.unwrap_or(0),\n1916         \"sparse invalid pattern length\",\n1917     )?;\n1918     // Our start states always start with a single stride of start states\n1919     // for the entire automaton which permit it to match any pattern. What\n1920     // follows it are an optional set of start states for each pattern.\n1921     let start_state_len = wire::add(\n1922         wire::mul(2, stride, \"start state stride too big\")?,\n1923         pattern_table_size,\n1924         \"sparse invalid 'any' pattern starts size\",\n1925     )?;\n1926     let table_bytes_len = wire::mul(\n1927         start_state_len,\n1928         StateID::SIZE,\n1929         \"sparse pattern table bytes length\",\n1930     )?;\n1931     wire::check_slice_len(\n1932         slice,\n1933         table_bytes_len,\n1934         \"sparse start ID table\",\n1935     )?;\n1936     let table = &slice[..table_bytes_len];\n1937     slice = &slice[table_bytes_len..];\n1938 \n1939     let sl = StartTable {\n1940         table,\n1941         kind,\n1942         start_map,\n1943         stride,\n1944         pattern_len,\n1945         universal_start_unanchored,\n1946         universal_start_anchored,\n1947     };\n1948     Ok((sl, slice.as_ptr().as_usize() - slice_start))\n1949 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}