{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseInner {\n    core: Core,\n    preinner: Prefilter,\n    nfarev: NFA,\n    hybrid: wrappers::ReverseHybrid,\n    dfa: wrappers::ReverseDFA,\n}\n#[derive(Debug)]\npub(crate) struct ReverseDFAEngine(\n    #[cfg(feature = \"dfa-build\")]\n    dfa::dense::DFA<Vec<u32>>,\n    #[cfg(not(feature = \"dfa-build\"))]\n    (),\n);\n#[derive(Debug)]\npub(crate) struct ReverseDFA(Option<ReverseDFAEngine>);\n#[derive(Debug)]\npub(crate) struct ReverseHybridEngine(\n    #[cfg(feature = \"hybrid\")]\n    hybrid::dfa::DFA,\n    #[cfg(not(feature = \"hybrid\"))]\n    (),\n);\n#[derive(Debug)]\npub(crate) struct ReverseHybrid(Option<ReverseHybridEngine>);\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) struct ReverseHybridCache(\n    #[cfg(feature = \"hybrid\")]\n    Option<hybrid::dfa::Cache>,\n    #[cfg(not(feature = \"hybrid\"))]\n    (),\n);\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Debug)]\npub(crate) enum RetryError {\n    Quadratic(RetryQuadraticError),\n    Fail(RetryFailError),\n}\nimpl ReverseInner {\n    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseInner, Core> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_full(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_fwd_stopat(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_rev_limited(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        if let Some(e) = self.dfa.get(&input) {\n            trace!(\n                \"using full DFA for reverse inner search at {:?}, \\\n                 but will be stopped at {} to avoid quadratic behavior\",\n                input.get_span(), min_start,\n            );\n            e.try_search_half_rev_limited(&input, min_start)\n        } else if let Some(e) = self.hybrid.get(&input) {\n            trace!(\n                \"using lazy DFA for reverse inner search at {:?}, \\\n                 but will be stopped at {} to avoid quadratic behavior\",\n                input.get_span(), min_start,\n            );\n            e.try_search_half_rev_limited(&mut cache.revhybrid, &input, min_start)\n        } else {\n            unreachable!(\"ReverseInner always has a DFA\")\n        }\n    }\n}\nimpl ReverseDFAEngine {\n    pub(crate) fn new(info: &RegexInfo, nfarev: &NFA) -> Option<ReverseDFAEngine> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev_limited(\n        &self,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        #[cfg(feature = \"dfa-build\")]\n        {\n            let dfa = &self.0;\n            crate::meta::limited::dfa_try_search_half_rev(dfa, input, min_start)\n        }\n        #[cfg(not(feature = \"dfa-build\"))] { unreachable!() }\n    }\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl ReverseDFA {\n    pub(crate) fn none() -> ReverseDFA {}\n    pub(crate) fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseDFA {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&ReverseDFAEngine> {\n        let engine = self.0.as_ref()?;\n        Some(engine)\n    }\n    pub(crate) fn is_some(&self) -> bool {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl ReverseHybridEngine {\n    pub(crate) fn new(info: &RegexInfo, nfarev: &NFA) -> Option<ReverseHybridEngine> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev_limited(\n        &self,\n        cache: &mut ReverseHybridCache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        #[cfg(feature = \"hybrid\")]\n        {\n            let dfa = &self.0;\n            let mut cache = cache.0.as_mut().unwrap();\n            crate::meta::limited::hybrid_try_search_half_rev(\n                dfa,\n                &mut cache,\n                input,\n                min_start,\n            )\n        }\n        #[cfg(not(feature = \"hybrid\"))] { unreachable!() }\n    }\n}\nimpl ReverseHybrid {\n    pub(crate) fn none() -> ReverseHybrid {}\n    pub(crate) fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseHybrid {}\n    pub(crate) fn create_cache(&self) -> ReverseHybridCache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&ReverseHybridEngine> {\n        let engine = self.0.as_ref()?;\n        Some(engine)\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1720 fn try_search_half_rev_limited(\n1721     &self,\n1722     cache: &mut Cache,\n1723     input: &Input<'_>,\n1724     min_start: usize,\n1725 ) -> Result<Option<HalfMatch>, RetryError> {\n1726     if let Some(e) = self.dfa.get(&input) {\n1727         trace!(\n1728             \"using full DFA for reverse inner search at {:?}, \\\n1729              but will be stopped at {} to avoid quadratic behavior\",\n1730             input.get_span(),\n1731             min_start,\n1732         );\n1733         e.try_search_half_rev_limited(&input, min_start)\n1734     } else if let Some(e) = self.hybrid.get(&input) {\n1735         trace!(\n1736             \"using lazy DFA for reverse inner search at {:?}, \\\n1737              but will be stopped at {} to avoid quadratic behavior\",\n1738             input.get_span(),\n1739             min_start,\n1740         );\n1741         e.try_search_half_rev_limited(\n1742             &mut cache.revhybrid,\n1743             &input,\n1744             min_start,\n1745         )\n1746     } else {\n1747         unreachable!(\"ReverseInner always has a DFA\")\n1748     }\n1749 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}