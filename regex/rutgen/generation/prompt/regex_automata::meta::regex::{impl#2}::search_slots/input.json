{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/regex.rs\n// crate name is regex_automata\ntype CachePool = Pool<Cache, CachePoolFn>;\ntype CachePoolGuard<'a> = PoolGuard<'a, Cache, CachePoolFn>;\ntype CachePoolFn = Box<dyn Fn() -> Cache + Send + Sync + UnwindSafe + RefUnwindSafe>;\nuse core::{borrow::Borrow, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::{boxed::Box, sync::Arc, vec, vec::Vec};\nuse regex_syntax::{ast, hir::{self, Hir}};\nuse crate::{\n    meta::{\n        error::BuildError, strategy::{self, Strategy},\n        wrappers,\n    },\n    nfa::thompson::WhichCaptures,\n    util::{\n        captures::{Captures, GroupInfo},\n        iter, pool::{Pool, PoolGuard},\n        prefilter::Prefilter, primitives::{NonMaxUsize, PatternID},\n        search::{HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n    },\n};\n#[derive(Debug)]\npub struct Regex {\n    /// The actual regex implementation.\n    imp: Arc<RegexI>,\n    /// A thread safe pool of caches.\n    ///\n    /// For the higher level search APIs, a `Cache` is automatically plucked\n    /// from this pool before running a search. The lower level `with` methods\n    /// permit the caller to provide their own cache, thereby bypassing\n    /// accesses to this pool.\n    ///\n    /// Note that we put this outside the `Arc` so that cloning a `Regex`\n    /// results in creating a fresh `CachePool`. This in turn permits callers\n    /// to clone regexes into separate threads where each such regex gets\n    /// the pool's \"thread owner\" optimization. Otherwise, if one shares the\n    /// `Regex` directly, then the pool will go through a slower mutex path for\n    /// all threads except for the \"owner.\"\n    pool: CachePool,\n}\n#[derive(Clone, Debug)]\npub(crate) struct RegexInfo(Arc<RegexInfoI>);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Debug)]\nstruct RegexI {\n    /// The core matching engine.\n    ///\n    /// Why is this reference counted when RegexI is already wrapped in an Arc?\n    /// Well, we need to capture this in a closure to our `Pool` below in order\n    /// to create new `Cache` values when needed. So since it needs to be in\n    /// two places, we make it reference counted.\n    ///\n    /// We make `RegexI` itself reference counted too so that `Regex` itself\n    /// stays extremely small and very cheap to clone.\n    strat: Arc<dyn Strategy>,\n    /// Metadata about the regexes driving the strategy. The metadata is also\n    /// usually stored inside the strategy too, but we put it here as well\n    /// so that we can get quick access to it (without virtual calls) before\n    /// executing the regex engine. For example, we use this metadata to\n    /// detect a subset of cases where we know a match is impossible, and can\n    /// thus avoid calling into the strategy at all.\n    ///\n    /// Since `RegexInfo` is stored in multiple places, it is also reference\n    /// counted.\n    info: RegexInfo,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\nimpl Regex {\n    #[inline]\n    pub fn search(&self, input: &Input<'_>) -> Option<Match> {}\n    #[inline]\n    pub fn search_half(&self, input: &Input<'_>) -> Option<HalfMatch> {}\n    #[inline]\n    pub fn search_captures(&self, input: &Input<'_>, caps: &mut Captures) {}\n    #[inline]\n    pub fn search_slots(\n        &self,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {\n        if self.imp.info.is_impossible(input) {\n            return None;\n        }\n        let mut guard = self.pool.get();\n        let result = self.imp.strat.search_slots(&mut guard, input, slots);\n        PoolGuard::put(guard);\n        result\n    }\n    #[inline]\n    pub fn which_overlapping_matches(&self, input: &Input<'_>, patset: &mut PatternSet) {}\n}\nimpl RegexInfo {\n    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {}\n    pub(crate) fn config(&self) -> &Config {}\n    pub(crate) fn props(&self) -> &[hir::Properties] {}\n    pub(crate) fn props_union(&self) -> &hir::Properties {}\n    pub(crate) fn pattern_len(&self) -> usize {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_anchored_start(&self, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_start(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_end(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_impossible(&self, input: &Input<'_>) -> bool {\n        if input.start() > 0 && self.is_always_anchored_start() {\n            return true;\n        }\n        if input.end() < input.haystack().len() && self.is_always_anchored_end() {\n            return true;\n        }\n        let minlen = match self.props_union().minimum_len() {\n            None => return false,\n            Some(minlen) => minlen,\n        };\n        if input.get_span().len() < minlen {\n            return true;\n        }\n        if self.is_anchored_start(input) && self.is_always_anchored_end() {\n            let maxlen = match self.props_union().maximum_len() {\n                None => return false,\n                Some(maxlen) => maxlen,\n            };\n            if input.get_span().len() > maxlen {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes a leftmost forward search and writes the spans of capturing\n/// groups that participated in a match into the provided `slots`, and\n/// returns the matching pattern ID. The contents of the slots for patterns\n/// other than the matching pattern are unspecified. If no match was found,\n/// then `None` is returned and the contents of `slots` is unspecified.\n///\n/// This is like [`Regex::search`], but it accepts a raw slots slice\n/// instead of a `Captures` value. This is useful in contexts where you\n/// don't want or need to allocate a `Captures`.\n///\n/// It is legal to pass _any_ number of slots to this routine. If the regex\n/// engine would otherwise write a slot offset that doesn't fit in the\n/// provided slice, then it is simply skipped. In general though, there are\n/// usually three slice lengths you might want to use:\n///\n/// * An empty slice, if you only care about which pattern matched.\n/// * A slice with [`pattern_len() * 2`](Regex::pattern_len) slots, if you\n/// only care about the overall match spans for each matching pattern.\n/// * A slice with\n/// [`slot_len()`](crate::util::captures::GroupInfo::slot_len) slots, which\n/// permits recording match offsets for every capturing group in every\n/// pattern.\n///\n/// # Example\n///\n/// This example shows how to find the overall match offsets in a\n/// multi-pattern search without allocating a `Captures` value. Indeed, we\n/// can put our slots right on the stack.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{meta::Regex, PatternID, Input};\n///\n/// let re = Regex::new_many(&[\n///     r\"\\pL+\",\n///     r\"\\d+\",\n/// ])?;\n/// let input = Input::new(\"!@#123\");\n///\n/// // We only care about the overall match offsets here, so we just\n/// // allocate two slots for each pattern. Each slot records the start\n/// // and end of the match.\n/// let mut slots = [None; 4];\n/// let pid = re.search_slots(&input, &mut slots);\n/// assert_eq!(Some(PatternID::must(1)), pid);\n///\n/// // The overall match offsets are always at 'pid * 2' and 'pid * 2 + 1'.\n/// // See 'GroupInfo' for more details on the mapping between groups and\n/// // slot indices.\n/// let slot_start = pid.unwrap().as_usize() * 2;\n/// let slot_end = slot_start + 1;\n/// assert_eq!(Some(3), slots[slot_start].map(|s| s.get()));\n/// assert_eq!(Some(6), slots[slot_end].map(|s| s.get()));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1126 pub fn search_slots(\n1127     &self,\n1128     input: &Input<'_>,\n1129     slots: &mut [Option<NonMaxUsize>],\n1130 ) -> Option<PatternID> {\n1131     if self.imp.info.is_impossible(input) {\n1132         return None;\n1133     }\n1134     let mut guard = self.pool.get();\n1135     let result = self.imp.strat.search_slots(&mut guard, input, slots);\n1136     // See 'Regex::search' for why we put the guard back explicitly.\n1137     PoolGuard::put(guard);\n1138     result\n1139 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}