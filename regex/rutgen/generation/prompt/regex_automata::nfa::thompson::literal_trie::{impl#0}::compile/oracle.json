{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/literal_trie.rs\n// crate name is regex_automata\nuse core::mem;\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, compiler::ThompsonRef, BuildError, Builder},\n    util::primitives::{IteratorIndexExt, StateID},\n};\n#[derive(Clone)]\npub(crate) struct LiteralTrie {\n    /// The set of trie states. Each state contains one or more chunks, where\n    /// each chunk is a sparse set of transitions to other states. A leaf state\n    /// is always a match state that contains only empty chunks (i.e., no\n    /// transitions).\n    states: Vec<State>,\n    /// Whether to add literals in reverse to the trie. Useful when building\n    /// a reverse NFA automaton.\n    rev: bool,\n}\n#[derive(Clone, Debug, Default)]\npub struct Builder {\n    /// The ID of the pattern that we're currently building.\n    ///\n    /// Callers are required to set (and unset) this by calling\n    /// {start,finish}_pattern. Otherwise, most methods will panic.\n    pattern_id: Option<PatternID>,\n    /// A sequence of intermediate NFA states. Once a state is added to this\n    /// sequence, it is assigned a state ID equivalent to its index. Once a\n    /// state is added, it is still expected to be mutated, e.g., to set its\n    /// transition to a state that didn't exist at the time it was added.\n    states: Vec<State>,\n    /// The starting states for each individual pattern. Starting at any\n    /// of these states will result in only an anchored search for the\n    /// corresponding pattern. The vec is indexed by pattern ID. When the NFA\n    /// contains a single regex, then `start_pattern[0]` and `start_anchored`\n    /// are always equivalent.\n    start_pattern: Vec<StateID>,\n    /// A map from pattern ID to capture group index to name. (If no name\n    /// exists, then a None entry is present. Thus, all capturing groups are\n    /// present in this mapping.)\n    ///\n    /// The outer vec is indexed by pattern ID, while the inner vec is indexed\n    /// by capture index offset for the corresponding pattern.\n    ///\n    /// The first capture group for each pattern is always unnamed and is thus\n    /// always None.\n    captures: Vec<Vec<Option<Arc<str>>>>,\n    /// The combined memory used by each of the 'State's in 'states'. This\n    /// only includes heap usage by each state, and not the size of the state\n    /// itself. In other words, this tracks heap memory used that isn't\n    /// captured via `size_of::<State>() * states.len()`.\n    memory_states: usize,\n    /// Whether this NFA only matches UTF-8 and whether regex engines using\n    /// this NFA for searching should report empty matches that split a\n    /// codepoint.\n    utf8: bool,\n    /// Whether this NFA should be matched in reverse or not.\n    reverse: bool,\n    /// The matcher to use for look-around assertions.\n    look_matcher: LookMatcher,\n    /// A size limit to respect when building an NFA. If the total heap memory\n    /// of the intermediate NFA states exceeds (or would exceed) this amount,\n    /// then an error is returned.\n    size_limit: Option<usize>,\n}\n#[derive(Clone, Default)]\nstruct State {\n    transitions: Vec<Transition>,\n    chunks: Vec<(usize, usize)>,\n}\n#[derive(Debug)]\nstruct Frame<'a> {\n    /// The remaining chunks to visit for a trie state.\n    chunks: StateChunksIter<'a>,\n    /// The transitions of the current chunk that we're iterating over. Since\n    /// every trie state has at least one chunk, every frame is initialized\n    /// with the first chunk's transitions ready to be consumed.\n    transitions: core::slice::Iter<'a, Transition>,\n    /// The NFA state IDs pointing to the start of each chunk compiled by\n    /// this trie state. This ultimately gets converted to an NFA union once\n    /// the entire trie state (and all of its children) have been compiled.\n    /// The order of these matters for leftmost-first match semantics, since\n    /// earlier matches in the union are preferred over later ones.\n    union: Vec<StateID>,\n    /// The actual NFA transitions for a single chunk in a trie state. This\n    /// gets converted to an NFA sparse state, and its corresponding NFA state\n    /// ID should get added to 'union'.\n    sparse: Vec<thompson::Transition>,\n}\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone)]\nstruct State {\n    /// A sorted sequence of non-overlapping transitions to other states. Each\n    /// transition corresponds to a single range of bytes.\n    transitions: Vec<Transition>,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy)]\nstruct Transition {\n    byte: u8,\n    next: StateID,\n}\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Transition {\n    /// The inclusive start of the byte range.\n    pub start: u8,\n    /// The inclusive end of the byte range.\n    pub end: u8,\n    /// The identifier of the state to transition to.\n    pub next: StateID,\n}\n#[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub(crate) struct State(Arc<[u8]>);\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Debug)]\nstruct StateChunksIter<'a> {\n    transitions: &'a [Transition],\n    chunks: core::slice::Iter<'a, (usize, usize)>,\n    active: Option<&'a [Transition]>,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct ThompsonRef {\n    pub(crate) start: StateID,\n    pub(crate) end: StateID,\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum State {\n    /// An empty state whose only purpose is to forward the automaton to\n    /// another state via an unconditional epsilon transition.\n    ///\n    /// Unconditional epsilon transitions are quite useful during the\n    /// construction of an NFA, as they permit the insertion of no-op\n    /// placeholders that make it easier to compose NFA sub-graphs. When\n    /// the Thompson NFA builder produces a final NFA, all unconditional\n    /// epsilon transitions are removed, and state identifiers are remapped\n    /// accordingly.\n    Empty {\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// A state that only transitions to another state if the current input\n    /// byte is in a particular range of bytes.\n    ByteRange { trans: Transition },\n    /// A state with possibly many transitions, represented in a sparse\n    /// fashion. Transitions must be ordered lexicographically by input range\n    /// and be non-overlapping. As such, this may only be used when every\n    /// transition has equal priority. (In practice, this is only used for\n    /// encoding large UTF-8 automata.) In contrast, a `Union` state has each\n    /// alternate in order of priority. Priority is used to implement greedy\n    /// matching and also alternations themselves, e.g., `abc|a` where `abc`\n    /// has priority over `a`.\n    ///\n    /// To clarify, it is possible to remove `Sparse` and represent all things\n    /// that `Sparse` is used for via `Union`. But this creates a more bloated\n    /// NFA with more epsilon transitions than is necessary in the special case\n    /// of character classes.\n    Sparse { transitions: Vec<Transition> },\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around.\n    Look { look: Look, next: StateID },\n    /// An empty state that records the start of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureStart {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An empty state that records the end of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureEnd {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union { alternates: Vec<StateID> },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via later transitions are\n    /// preferred over earlier transitions.\n    ///\n    /// This \"reverse\" state exists for convenience during compilation that\n    /// permits easy construction of non-greedy combinations of NFA states. At\n    /// the end of compilation, Union and UnionReverse states are merged into\n    /// one Union type of state, where the latter has its epsilon transitions\n    /// reversed to reflect the priority inversion.\n    ///\n    /// The \"convenience\" here arises from the fact that as new states are\n    /// added to the list of `alternates`, we would like that add operation\n    /// to be amortized constant time. But if we used a `Union`, we'd need to\n    /// prepend the state, which takes O(n) time. There are other approaches we\n    /// could use to solve this, but this seems simple enough.\n    UnionReverse { alternates: Vec<StateID> },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose a\n    /// `Fail` state to represent it.\n    Fail,\n    /// A match state. There is at most one such occurrence of this state in\n    /// an NFA for each pattern compiled into the NFA. At time of writing, a\n    /// match state is always produced for every pattern given, but in theory,\n    /// if a pattern can never lead to a match, then the match state could be\n    /// omitted.\n    ///\n    /// `pattern_id` refers to the ID of the pattern itself, which corresponds\n    /// to the pattern's index (starting at 0).\n    Match { pattern_id: PatternID },\n}\nimpl LiteralTrie {\n    pub(crate) fn forward() -> LiteralTrie {}\n    pub(crate) fn reverse() -> LiteralTrie {}\n    pub(crate) fn add(&mut self, bytes: &[u8]) -> Result<(), BuildError> {}\n    fn get_or_add_state(\n        &mut self,\n        from: StateID,\n        byte: u8,\n    ) -> Result<StateID, BuildError> {}\n    pub(crate) fn compile(\n        &self,\n        builder: &mut Builder,\n    ) -> Result<ThompsonRef, BuildError> {\n        let end = builder.add_empty()?;\n        let mut stack = vec![];\n        let mut f = Frame::new(&self.states[StateID::ZERO]);\n        loop {\n            if let Some(t) = f.transitions.next() {\n                if self.states[t.next].is_leaf() {\n                    f.sparse\n                        .push(thompson::Transition {\n                            start: t.byte,\n                            end: t.byte,\n                            next: end,\n                        });\n                } else {\n                    f.sparse\n                        .push(thompson::Transition {\n                            start: t.byte,\n                            end: t.byte,\n                            next: StateID::ZERO,\n                        });\n                    stack.push(f);\n                    f = Frame::new(&self.states[t.next]);\n                }\n                continue;\n            }\n            if !f.sparse.is_empty() {\n                let chunk_id = if f.sparse.len() == 1 {\n                    builder.add_range(f.sparse.pop().unwrap())?\n                } else {\n                    let sparse = mem::replace(&mut f.sparse, vec![]);\n                    builder.add_sparse(sparse)?\n                };\n                f.union.push(chunk_id);\n            }\n            if let Some(chunk) = f.chunks.next() {\n                f.union.push(end);\n                f.transitions = chunk.iter();\n                continue;\n            }\n            let start = builder.add_union(f.union)?;\n            match stack.pop() {\n                None => {\n                    return Ok(ThompsonRef { start, end });\n                }\n                Some(mut parent) => {\n                    parent.sparse.last_mut().unwrap().next = start;\n                    f = parent;\n                }\n            }\n        }\n    }\n    #[cfg(test)]\n    fn compile_to_hir(&self) -> regex_syntax::hir::Hir {}\n    #[cfg(test)]\n    fn compile_state_to_hir(&self, sid: StateID) -> regex_syntax::hir::Hir {}\n}\nimpl Builder {\n    pub fn new() -> Builder {}\n    pub fn clear(&mut self) {}\n    pub fn build(\n        &self,\n        start_anchored: StateID,\n        start_unanchored: StateID,\n    ) -> Result<NFA, BuildError> {}\n    pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {}\n    pub fn finish_pattern(\n        &mut self,\n        start_id: StateID,\n    ) -> Result<PatternID, BuildError> {}\n    pub fn current_pattern_id(&self) -> PatternID {}\n    pub fn pattern_len(&self) -> usize {}\n    pub fn add_empty(&mut self) -> Result<StateID, BuildError> {\n        self.add(State::Empty {\n            next: StateID::ZERO,\n        })\n    }\n    pub fn add_union(\n        &mut self,\n        alternates: Vec<StateID>,\n    ) -> Result<StateID, BuildError> {\n        self.add(State::Union { alternates })\n    }\n    pub fn add_union_reverse(\n        &mut self,\n        alternates: Vec<StateID>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_range(&mut self, trans: Transition) -> Result<StateID, BuildError> {\n        self.add(State::ByteRange { trans })\n    }\n    pub fn add_sparse(\n        &mut self,\n        transitions: Vec<Transition>,\n    ) -> Result<StateID, BuildError> {\n        self.add(State::Sparse { transitions })\n    }\n    pub fn add_look(\n        &mut self,\n        next: StateID,\n        look: Look,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_capture_start(\n        &mut self,\n        next: StateID,\n        group_index: u32,\n        name: Option<Arc<str>>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_capture_end(\n        &mut self,\n        next: StateID,\n        group_index: u32,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_fail(&mut self) -> Result<StateID, BuildError> {}\n    pub fn add_match(&mut self) -> Result<StateID, BuildError> {}\n    fn add(&mut self, state: State) -> Result<StateID, BuildError> {}\n    pub fn patch(&mut self, from: StateID, to: StateID) -> Result<(), BuildError> {}\n    pub fn set_utf8(&mut self, yes: bool) {}\n    pub fn get_utf8(&self) -> bool {}\n    pub fn set_reverse(&mut self, yes: bool) {}\n    pub fn get_reverse(&self) -> bool {}\n    pub fn set_look_matcher(&mut self, m: LookMatcher) {}\n    pub fn get_look_matcher(&self) -> &LookMatcher {}\n    pub fn set_size_limit(&mut self, limit: Option<usize>) -> Result<(), BuildError> {}\n    pub fn get_size_limit(&self) -> Option<usize> {}\n    pub fn memory_usage(&self) -> usize {}\n    fn check_size_limit(&self) -> Result<(), BuildError> {}\n}\nimpl State {\n    fn add_match(&mut self) {}\n    fn is_leaf(&self) -> bool {\n        self.transitions.is_empty()\n    }\n    fn chunks(&self) -> StateChunksIter<'_> {}\n    fn active_chunk(&self) -> &[Transition] {}\n    fn active_chunk_start(&self) -> usize {}\n}\nimpl<'a> Frame<'a> {\n    fn new(state: &'a State) -> Frame<'a> {\n        let mut chunks = state.chunks();\n        let chunk = chunks.next().unwrap();\n        let transitions = chunk.iter();\n        Frame {\n            chunks,\n            transitions,\n            union: vec![],\n            sparse: vec![],\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Compile this literal trie to the NFA builder given.\n///\n/// This forwards any errors that may occur while using the given builder.\n151 pub(crate) fn compile(\n152     &self,\n153     builder: &mut Builder,\n154 ) -> Result<ThompsonRef, BuildError> {\n155     // Compilation proceeds via depth-first traversal of the trie.\n156     //\n157     // This is overall pretty brutal. The recursive version of this is\n158     // deliciously simple. (See 'compile_to_hir' below for what it might\n159     // look like.) But recursion on a trie means your call stack grows\n160     // in accordance with the longest literal, which just does not seem\n161     // appropriate. So we push the call stack to the heap. But as a result,\n162     // the trie traversal becomes pretty brutal because we essentially\n163     // have to encode the state of a double for-loop into an explicit call\n164     // frame. If someone can simplify this without using recursion, that'd\n165     // be great.\n166 \n167     // 'end' is our match state for this trie, but represented in the the\n168     // NFA. Any time we see a match in the trie, we insert a transition\n169     // from the current state we're in to 'end'.\n170     let end = builder.add_empty()?;\n171     let mut stack = vec![];\n172     let mut f = Frame::new(&self.states[StateID::ZERO]);\n173     loop {\n174         if let Some(t) = f.transitions.next() {\n175             if self.states[t.next].is_leaf() {\n176                 f.sparse.push(thompson::Transition {\n177                     start: t.byte,\n178                     end: t.byte,\n179                     next: end,\n180                 });\n181             } else {\n182                 f.sparse.push(thompson::Transition {\n183                     start: t.byte,\n184                     end: t.byte,\n185                     // This is a little funny, but when the frame we create\n186                     // below completes, it will pop this parent frame off\n187                     // and modify this transition to point to the correct\n188                     // state.\n189                     next: StateID::ZERO,\n190                 });\n191                 stack.push(f);\n192                 f = Frame::new(&self.states[t.next]);\n193             }\n194             continue;\n195         }\n196         // At this point, we have visited all transitions in f.chunk, so\n197         // add it as a sparse NFA state. Unless the chunk was empty, in\n198         // which case, we don't do anything.\n199         if !f.sparse.is_empty() {\n200             let chunk_id = if f.sparse.len() == 1 {\n201                 builder.add_range(f.sparse.pop().unwrap())?\n202             } else {\n203                 let sparse = mem::replace(&mut f.sparse, vec![]);\n204                 builder.add_sparse(sparse)?\n205             };\n206             f.union.push(chunk_id);\n207         }\n208         // Now we need to look to see if there are other chunks to visit.\n209         if let Some(chunk) = f.chunks.next() {\n210             // If we're here, it means we're on the second (or greater)\n211             // chunk, which implies there is a match at this point. So\n212             // connect this state to the final end state.\n213             f.union.push(end);\n214             // Advance to the next chunk.\n215             f.transitions = chunk.iter();\n216             continue;\n217         }\n218         // Now that we are out of chunks, we have completely visited\n219         // this state. So turn our union of chunks into an NFA union\n220         // state, and add that union state to the parent state's current\n221         // sparse state. (If there is no parent, we're done.)\n222         let start = builder.add_union(f.union)?;\n223         match stack.pop() {\n224             None => {\n225                 return Ok(ThompsonRef { start, end });\n226             }\n227             Some(mut parent) => {\n228                 // OK because the only way a frame gets pushed on to the\n229                 // stack (aside from the root) is when a transition has\n230                 // been added to 'sparse'.\n231                 parent.sparse.last_mut().unwrap().next = start;\n232                 f = parent;\n233             }\n234         }\n235     }\n236 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}