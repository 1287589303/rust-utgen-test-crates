{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/nfa.rs\n// crate name is regex_automata\nuse core::{fmt, mem};\nuse alloc::{boxed::Box, format, string::String, sync::Arc, vec, vec::Vec};\n#[cfg(feature = \"syntax\")]\nuse crate::nfa::thompson::{\n    compiler::{Compiler, Config},\n    error::BuildError,\n};\nuse crate::{\n    nfa::thompson::builder::Builder,\n    util::{\n        alphabet::{self, ByteClassSet, ByteClasses},\n        captures::{GroupInfo, GroupInfoError},\n        look::{Look, LookMatcher, LookSet},\n        primitives::{IteratorIndexExt, PatternID, PatternIDIter, SmallIndex, StateID},\n        sparse_set::SparseSet,\n    },\n};\n#[derive(Default)]\npub(super) struct Inner {\n    /// The state sequence. This sequence is guaranteed to be indexable by all\n    /// starting state IDs, and it is also guaranteed to contain at most one\n    /// `Match` state for each pattern compiled into this NFA. (A pattern may\n    /// not have a corresponding `Match` state if a `Match` state is impossible\n    /// to reach.)\n    states: Vec<State>,\n    /// The anchored starting state of this NFA.\n    start_anchored: StateID,\n    /// The unanchored starting state of this NFA.\n    start_unanchored: StateID,\n    /// The starting states for each individual pattern. Starting at any\n    /// of these states will result in only an anchored search for the\n    /// corresponding pattern. The vec is indexed by pattern ID. When the NFA\n    /// contains a single regex, then `start_pattern[0]` and `start_anchored`\n    /// are always equivalent.\n    start_pattern: Vec<StateID>,\n    /// Info about the capturing groups in this NFA. This is responsible for\n    /// mapping groups to slots, mapping groups to names and names to groups.\n    group_info: GroupInfo,\n    /// A representation of equivalence classes over the transitions in this\n    /// NFA. Two bytes in the same equivalence class must not discriminate\n    /// between a match or a non-match. This map can be used to shrink the\n    /// total size of a DFA's transition table with a small match-time cost.\n    ///\n    /// Note that the NFA's transitions are *not* defined in terms of these\n    /// equivalence classes. The NFA's transitions are defined on the original\n    /// byte values. For the most part, this is because they wouldn't really\n    /// help the NFA much since the NFA already uses a sparse representation\n    /// to represent transitions. Byte classes are most effective in a dense\n    /// representation.\n    byte_class_set: ByteClassSet,\n    /// This is generated from `byte_class_set`, and essentially represents the\n    /// same thing but supports different access patterns. Namely, this permits\n    /// looking up the equivalence class of a byte very cheaply.\n    ///\n    /// Ideally we would just store this, but because of annoying code\n    /// structure reasons, we keep both this and `byte_class_set` around for\n    /// now. I think I would prefer that `byte_class_set` were computed in the\n    /// `Builder`, but right now, we compute it as states are added to the\n    /// `NFA`.\n    byte_classes: ByteClasses,\n    /// Whether this NFA has a `Capture` state anywhere.\n    has_capture: bool,\n    /// When the empty string is in the language matched by this NFA.\n    has_empty: bool,\n    /// Whether UTF-8 mode is enabled for this NFA. Briefly, this means that\n    /// all non-empty matches produced by this NFA correspond to spans of valid\n    /// UTF-8, and any empty matches produced by this NFA that split a UTF-8\n    /// encoded codepoint should be filtered out by the corresponding regex\n    /// engine.\n    utf8: bool,\n    /// Whether this NFA is meant to be matched in reverse or not.\n    reverse: bool,\n    /// The matcher to be used for look-around assertions.\n    look_matcher: LookMatcher,\n    /// The union of all look-around assertions that occur anywhere within\n    /// this NFA. If this set is empty, then it means there are precisely zero\n    /// conditional epsilon transitions in the NFA.\n    look_set_any: LookSet,\n    /// The union of all look-around assertions that occur as a zero-length\n    /// prefix for any of the patterns in this NFA.\n    look_set_prefix_any: LookSet,\n    /// Heap memory used indirectly by NFA states and other things (like the\n    /// various capturing group representations above). Since each state\n    /// might use a different amount of heap, we need to keep track of this\n    /// incrementally.\n    memory_extra: usize,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, PartialEq)]\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where\n    /// `i = Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u32,\n}\n#[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub(crate) struct State(Arc<[u8]>);\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[cfg(feature = \"alloc\")]\n#[derive(Clone, Debug)]\npub(crate) struct ByteClassSet(ByteSet);\n#[derive(Clone, Default)]\nstruct State {\n    transitions: Vec<Transition>,\n    chunks: Vec<(usize, usize)>,\n}\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone)]\nstruct State {\n    /// A sorted sequence of non-overlapping transitions to other states. Each\n    /// transition corresponds to a single range of bytes.\n    transitions: Vec<Transition>,\n}\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum State {\n    /// An empty state whose only purpose is to forward the automaton to\n    /// another state via an unconditional epsilon transition.\n    ///\n    /// Unconditional epsilon transitions are quite useful during the\n    /// construction of an NFA, as they permit the insertion of no-op\n    /// placeholders that make it easier to compose NFA sub-graphs. When\n    /// the Thompson NFA builder produces a final NFA, all unconditional\n    /// epsilon transitions are removed, and state identifiers are remapped\n    /// accordingly.\n    Empty {\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// A state that only transitions to another state if the current input\n    /// byte is in a particular range of bytes.\n    ByteRange { trans: Transition },\n    /// A state with possibly many transitions, represented in a sparse\n    /// fashion. Transitions must be ordered lexicographically by input range\n    /// and be non-overlapping. As such, this may only be used when every\n    /// transition has equal priority. (In practice, this is only used for\n    /// encoding large UTF-8 automata.) In contrast, a `Union` state has each\n    /// alternate in order of priority. Priority is used to implement greedy\n    /// matching and also alternations themselves, e.g., `abc|a` where `abc`\n    /// has priority over `a`.\n    ///\n    /// To clarify, it is possible to remove `Sparse` and represent all things\n    /// that `Sparse` is used for via `Union`. But this creates a more bloated\n    /// NFA with more epsilon transitions than is necessary in the special case\n    /// of character classes.\n    Sparse { transitions: Vec<Transition> },\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around.\n    Look { look: Look, next: StateID },\n    /// An empty state that records the start of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureStart {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An empty state that records the end of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureEnd {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union { alternates: Vec<StateID> },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via later transitions are\n    /// preferred over earlier transitions.\n    ///\n    /// This \"reverse\" state exists for convenience during compilation that\n    /// permits easy construction of non-greedy combinations of NFA states. At\n    /// the end of compilation, Union and UnionReverse states are merged into\n    /// one Union type of state, where the latter has its epsilon transitions\n    /// reversed to reflect the priority inversion.\n    ///\n    /// The \"convenience\" here arises from the fact that as new states are\n    /// added to the list of `alternates`, we would like that add operation\n    /// to be amortized constant time. But if we used a `Union`, we'd need to\n    /// prepend the state, which takes O(n) time. There are other approaches we\n    /// could use to solve this, but this seems simple enough.\n    UnionReverse { alternates: Vec<StateID> },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose a\n    /// `Fail` state to represent it.\n    Fail,\n    /// A match state. There is at most one such occurrence of this state in\n    /// an NFA for each pattern compiled into the NFA. At time of writing, a\n    /// match state is always produced for every pattern given, but in theory,\n    /// if a pattern can never lead to a match, then the match state could be\n    /// omitted.\n    ///\n    /// `pattern_id` refers to the ID of the pattern itself, which corresponds\n    /// to the pattern's index (starting at 0).\n    Match { pattern_id: PatternID },\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\nimpl Inner {\n    pub(super) fn into_nfa(mut self) -> NFA {}\n    pub(super) fn group_info(&self) -> &GroupInfo {}\n    pub(super) fn add(&mut self, state: State) -> StateID {}\n    pub(super) fn set_starts(\n        &mut self,\n        start_anchored: StateID,\n        start_unanchored: StateID,\n        start_pattern: &[StateID],\n    ) {\n        self.start_anchored = start_anchored;\n        self.start_unanchored = start_unanchored;\n        self.start_pattern = start_pattern.to_vec();\n    }\n    pub(super) fn set_utf8(&mut self, yes: bool) {}\n    pub(super) fn set_reverse(&mut self, yes: bool) {}\n    pub(super) fn set_look_matcher(&mut self, m: LookMatcher) {}\n    pub(super) fn set_captures(\n        &mut self,\n        captures: &[Vec<Option<Arc<str>>>],\n    ) -> Result<(), GroupInfoError> {}\n    pub(super) fn remap(&mut self, old_to_new: &[StateID]) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Set the starting state identifiers for this NFA.\n///\n/// `start_anchored` and `start_unanchored` may be equivalent. When they\n/// are, then the NFA can only execute anchored searches. This might\n/// occur, for example, for patterns that are unconditionally anchored.\n/// e.g., `^foo`.\n1392 pub(super) fn set_starts(\n1393     &mut self,\n1394     start_anchored: StateID,\n1395     start_unanchored: StateID,\n1396     start_pattern: &[StateID],\n1397 ) {\n1398     self.start_anchored = start_anchored;\n1399     self.start_unanchored = start_unanchored;\n1400     self.start_pattern = start_pattern.to_vec();\n1401 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}