{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/reverse_inner.rs\n// crate name is regex_automata\nuse alloc::vec::Vec;\nuse regex_syntax::hir::{self, literal, Hir, HirKind};\nuse crate::{util::prefilter::Prefilter, MatchKind};\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {}\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {\n        #[cfg(not(feature = \"alloc\"))] { unreachable!() }\n        #[cfg(feature = \"alloc\")] { self.is_fast }\n    }\n}\npub(crate) fn extract(hirs: &[&Hir]) -> Option<(Hir, Prefilter)> {\n    if hirs.len() != 1 {\n        debug!(\n            \"skipping reverse inner optimization since it only \\\n\t\t \t supports 1 pattern, {} were given\",\n            hirs.len(),\n        );\n        return None;\n    }\n    let mut concat = match top_concat(hirs[0]) {\n        Some(concat) => concat,\n        None => {\n            debug!(\n                \"skipping reverse inner optimization because a top-level \\\n\t\t \t     concatenation could not found\",\n            );\n            return None;\n        }\n    };\n    for i in 1..concat.len() {\n        let hir = &concat[i];\n        let pre = match prefilter(hir) {\n            None => continue,\n            Some(pre) => pre,\n        };\n        if !pre.is_fast() {\n            debug!(\n                \"skipping extracted inner prefilter because \\\n\t\t\t\t it probably isn't fast\"\n            );\n            continue;\n        }\n        let concat_suffix = Hir::concat(concat.split_off(i));\n        let concat_prefix = Hir::concat(concat);\n        let pre2 = match prefilter(&concat_suffix) {\n            None => pre,\n            Some(pre2) => if pre2.is_fast() { pre2 } else { pre }\n        };\n        return Some((concat_prefix, pre2));\n    }\n    debug!(\n        \"skipping reverse inner optimization because a top-level \\\n\t     sub-expression with a fast prefilter could not be found\"\n    );\n    None\n}\nfn prefilter(hir: &Hir) -> Option<Prefilter> {\n    let mut extractor = literal::Extractor::new();\n    extractor.kind(literal::ExtractKind::Prefix);\n    let mut prefixes = extractor.extract(hir);\n    debug!(\n        \"inner prefixes (len={:?}) extracted before optimization: {:?}\", prefixes.len(),\n        prefixes\n    );\n    prefixes.make_inexact();\n    prefixes.optimize_for_prefix_by_preference();\n    debug!(\n        \"inner prefixes (len={:?}) extracted after optimization: {:?}\", prefixes.len(),\n        prefixes\n    );\n    prefixes.literals().and_then(|lits| Prefilter::new(MatchKind::LeftmostFirst, lits))\n}\nfn top_concat(mut hir: &Hir) -> Option<Vec<Hir>> {\n    loop {\n        hir = match hir.kind() {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Look(_)\n            | HirKind::Repetition(_)\n            | HirKind::Alternation(_) => return None,\n            HirKind::Capture(hir::Capture { ref sub, .. }) => sub,\n            HirKind::Concat(ref subs) => {\n                let concat = Hir::concat(subs.iter().map(|h| flatten(h)).collect());\n                return match concat.into_kind() {\n                    HirKind::Concat(xs) => Some(xs),\n                    _ => return None,\n                };\n            }\n        };\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Attempts to extract an \"inner\" prefilter from the given HIR expressions. If\n/// one was found, then a concatenation of the HIR expressions that precede it\n/// is returned.\n///\n/// The idea here is that the prefilter returned can be used to find candidate\n/// matches. And then the HIR returned can be used to build a reverse regex\n/// matcher, which will find the start of the candidate match. Finally, the\n/// match still has to be confirmed with a normal anchored forward scan to find\n/// the end position of the match.\n///\n/// Note that this assumes leftmost-first match semantics, so callers must\n/// not call this otherwise.\n 53 pub(crate) fn extract(hirs: &[&Hir]) -> Option<(Hir, Prefilter)> {\n 54     if hirs.len() != 1 {\n 55         debug!(\n 56             \"skipping reverse inner optimization since it only \\\n 57 \t\t \t supports 1 pattern, {} were given\",\n 58             hirs.len(),\n 59         );\n 60         return None;\n 61     }\n 62     let mut concat = match top_concat(hirs[0]) {\n 63         Some(concat) => concat,\n 64         None => {\n 65             debug!(\n 66                 \"skipping reverse inner optimization because a top-level \\\n 67 \t\t \t     concatenation could not found\",\n 68             );\n 69             return None;\n 70         }\n 71     };\n 72     // We skip the first HIR because if it did have a prefix prefilter in it,\n 73     // we probably wouldn't be here looking for an inner prefilter.\n 74     for i in 1..concat.len() {\n 75         let hir = &concat[i];\n 76         let pre = match prefilter(hir) {\n 77             None => continue,\n 78             Some(pre) => pre,\n 79         };\n 80         // Even if we got a prefilter, if it isn't consider \"fast,\" then we\n 81         // probably don't want to bother with it. Namely, since the reverse\n 82         // inner optimization requires some overhead, it likely only makes\n 83         // sense if the prefilter scan itself is (believed) to be much faster\n 84         // than the regex engine.\n 85         if !pre.is_fast() {\n 86             debug!(\n 87                 \"skipping extracted inner prefilter because \\\n 88 \t\t\t\t it probably isn't fast\"\n 89             );\n 90             continue;\n 91         }\n 92         let concat_suffix = Hir::concat(concat.split_off(i));\n 93         let concat_prefix = Hir::concat(concat);\n 94         // Look for a prefilter again. Why? Because above we only looked for\n 95         // a prefilter on the individual 'hir', but we might be able to find\n 96         // something better and more discriminatory by looking at the entire\n 97         // suffix. We don't do this above to avoid making this loop worst case\n 98         // quadratic in the length of 'concat'.\n 99         let pre2 = match prefilter(&concat_suffix) {\n100             None => pre,\n101             Some(pre2) => {\n102                 if pre2.is_fast() {\n103                     pre2\n104                 } else {\n105                     pre\n106                 }\n107             }\n108         };\n109         return Some((concat_prefix, pre2));\n110     }\n111     debug!(\n112         \"skipping reverse inner optimization because a top-level \\\n113 \t     sub-expression with a fast prefilter could not be found\"\n114     );\n115     None\n116 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}