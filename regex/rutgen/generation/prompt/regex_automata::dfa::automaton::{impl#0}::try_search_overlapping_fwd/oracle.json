{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError> {\n        let config = start::Config::from_input_forward(input);\n        self.start_state(&config)\n            .map_err(|err| match err {\n                StartError::Quit { byte } => {\n                    let offset = input\n                        .start()\n                        .checked_sub(1)\n                        .expect(\"no quit in start without look-behind\");\n                    MatchError::quit(byte, offset)\n                }\n                StartError::UnsupportedAnchored { mode } => {\n                    MatchError::unsupported_anchored(mode)\n                }\n            })\n    }\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError> {\n        let config = start::Config::from_input_reverse(input);\n        self.start_state(&config)\n            .map_err(|err| match err {\n                StartError::Quit { byte } => {\n                    let offset = input.end();\n                    MatchError::quit(byte, offset)\n                }\n                StartError::UnsupportedAnchored { mode } => {\n                    MatchError::unsupported_anchored(mode)\n                }\n            })\n    }\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID> {\n        None\n    }\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8] {\n        &[]\n    }\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter> {\n        None\n    }\n    #[inline]\n    fn try_search_fwd(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        let hm = match search::find_fwd(&self, input)? {\n            None => return Ok(None),\n            Some(hm) if !utf8empty => return Ok(Some(hm)),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_fwd(\n            input,\n            hm,\n            hm.offset(),\n            |input| {\n                let got = search::find_fwd(&self, input)?;\n                Ok(got.map(|hm| (hm, hm.offset())))\n            },\n        )\n    }\n    #[inline]\n    fn try_search_rev(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        let hm = match search::find_rev(self, input)? {\n            None => return Ok(None),\n            Some(hm) if !utf8empty => return Ok(Some(hm)),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_rev(\n            input,\n            hm,\n            hm.offset(),\n            |input| {\n                let got = search::find_rev(self, input)?;\n                Ok(got.map(|hm| (hm, hm.offset())))\n            },\n        )\n    }\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        search::find_overlapping_fwd(self, input, state)?;\n        match state.get_match() {\n            None => Ok(()),\n            Some(_) if !utf8empty => Ok(()),\n            Some(_) => {\n                skip_empty_utf8_splits_overlapping(\n                    input,\n                    state,\n                    |input, state| { search::find_overlapping_fwd(self, input, state) },\n                )\n            }\n        }\n    }\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        search::find_overlapping_rev(self, input, state)?;\n        match state.get_match() {\n            None => Ok(()),\n            Some(_) if !utf8empty => Ok(()),\n            Some(_) => {\n                skip_empty_utf8_splits_overlapping(\n                    input,\n                    state,\n                    |input, state| { search::find_overlapping_rev(self, input, state) },\n                )\n            }\n        }\n    }\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError> {\n        let mut state = OverlappingState::start();\n        while let Some(m) = {\n            self.try_search_overlapping_fwd(input, &mut state)?;\n            state.get_match()\n        } {\n            let _ = patset.insert(m.pattern());\n            if patset.is_full() || input.get_earliest() {\n                break;\n            }\n        }\n        Ok(())\n    }\n}\npub(crate) trait U16 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn high_u8(self) -> u8;\n}\npub(crate) trait U32 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn high_u16(self) -> u16;\n}\npub(crate) trait Usize {\n    fn as_u8(self) -> u8;\n    fn as_u16(self) -> u16;\n    fn as_u32(self) -> u32;\n    fn as_u64(self) -> u64;\n}\npub(crate) trait U8 {\n    fn as_usize(self) -> usize;\n}\npub(crate) trait U64 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn low_u32(self) -> u32;\n    fn high_u32(self) -> u32;\n}\npub(crate) trait I32 {\n    fn as_usize(self) -> usize;\n    fn to_bits(self) -> u32;\n    fn from_bits(n: u32) -> i32;\n}\npub(crate) trait Pointer {\n    fn as_usize(self) -> usize;\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct OverlappingState {\n    /// The match reported by the most recent overlapping search to use this\n    /// state.\n    ///\n    /// If a search does not find any matches, then it is expected to clear\n    /// this value.\n    pub(crate) mat: Option<HalfMatch>,\n    /// The state ID of the state at which the search was in when the call\n    /// terminated. When this is a match state, `last_match` must be set to a\n    /// non-None value.\n    ///\n    /// A `None` value indicates the start state of the corresponding\n    /// automaton. We cannot use the actual ID, since any one automaton may\n    /// have many start states, and which one is in use depends on several\n    /// search-time factors.\n    pub(crate) id: Option<StateID>,\n    /// The position of the search.\n    ///\n    /// When `id` is None (i.e., we are starting a search), this is set to\n    /// the beginning of the search as given by the caller regardless of its\n    /// current value. Subsequent calls to an overlapping search pick up at\n    /// this offset.\n    pub(crate) at: usize,\n    /// The index into the matching patterns of the next match to report if the\n    /// current state is a match state. Note that this may be 1 greater than\n    /// the total number of matches to report for the current match state. (In\n    /// which case, no more matches should be reported at the current position\n    /// and the search should advance to the next position.)\n    pub(crate) next_match_index: Option<usize>,\n    /// This is set to true when a reverse overlapping search has entered its\n    /// EOI transitions.\n    ///\n    /// This isn't used in a forward search because it knows to stop once the\n    /// position exceeds the end of the search range. In a reverse search,\n    /// since we use unsigned offsets, we don't \"know\" once we've gone past\n    /// `0`. So the only way to detect it is with this extra flag. The reverse\n    /// overlapping search knows to terminate specifically after it has\n    /// reported all matches after following the EOI transition.\n    pub(crate) rev_eoi: bool,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\nunsafe impl<'a, A: Automaton + ?Sized> Automaton for &'a A {\n    #[inline]\n    fn next_state(&self, current: StateID, input: u8) -> StateID {}\n    #[inline]\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID {}\n    #[inline]\n    fn next_eoi_state(&self, current: StateID) -> StateID {}\n    #[inline]\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError> {}\n    #[inline]\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError> {}\n    #[inline]\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError> {}\n    #[inline]\n    fn universal_start_state(&self, mode: Anchored) -> Option<StateID> {}\n    #[inline]\n    fn is_special_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_dead_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_quit_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_match_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_start_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn is_accel_state(&self, id: StateID) -> bool {}\n    #[inline]\n    fn pattern_len(&self) -> usize {}\n    #[inline]\n    fn match_len(&self, id: StateID) -> usize {}\n    #[inline]\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID {}\n    #[inline]\n    fn has_empty(&self) -> bool {}\n    #[inline]\n    fn is_utf8(&self) -> bool {}\n    #[inline]\n    fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    fn accelerator(&self, id: StateID) -> &[u8] {}\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter> {}\n    #[inline]\n    fn try_search_fwd(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[inline]\n    fn try_search_rev(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        (**self).try_search_overlapping_fwd(input, state)\n    }\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {}\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1965 fn try_search_overlapping_fwd(\n1966     &self,\n1967     input: &Input<'_>,\n1968     state: &mut OverlappingState,\n1969 ) -> Result<(), MatchError> {\n1970     (**self).try_search_overlapping_fwd(input, state)\n1971 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}