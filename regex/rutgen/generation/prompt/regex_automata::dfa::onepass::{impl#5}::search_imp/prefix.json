{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/onepass.rs\n// crate name is regex_automata\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    dfa::{remapper::Remapper, DEAD},\n    nfa::thompson::{self, NFA},\n    util::{\n        alphabet::ByteClasses, captures::Captures, escape::DebugByte,\n        int::{Usize, U32, U64, U8},\n        look::{Look, LookSet, UnicodeWordBoundaryError},\n        primitives::{NonMaxUsize, PatternID, StateID},\n        search::{Anchored, Input, Match, MatchError, MatchKind, Span},\n        sparse_set::SparseSet,\n    },\n};\npub(super) trait Remappable: core::fmt::Debug {\n    fn state_len(&self) -> usize;\n    fn stride2(&self) -> usize;\n    fn swap_states(&mut self, id1: StateID, id2: StateID);\n    fn remap(&mut self, map: impl Fn(StateID) -> StateID);\n}\n#[derive(Clone)]\npub struct DFA {\n    /// The configuration provided by the caller.\n    config: Config,\n    /// The NFA used to build this DFA.\n    ///\n    /// NOTE: We probably don't need to store the NFA here, but we use enough\n    /// bits from it that it's convenient to do so. And there really isn't much\n    /// cost to doing so either, since an NFA is reference counted internally.\n    nfa: NFA,\n    /// The transition table. Given a state ID 's' and a byte of haystack 'b',\n    /// the next state is `table[sid + classes[byte]]`.\n    ///\n    /// The stride of this table (i.e., the number of columns) is always\n    /// a power of 2, even if the alphabet length is smaller. This makes\n    /// converting between state IDs and state indices very cheap.\n    ///\n    /// Note that the stride always includes room for one extra \"transition\"\n    /// that isn't actually a transition. It is a 'PatternEpsilons' that is\n    /// used for match states only. Because of this, the maximum number of\n    /// active columns in the transition table is 257, which means the maximum\n    /// stride is 512 (the next power of 2 greater than or equal to 257).\n    table: Vec<Transition>,\n    /// The DFA state IDs of the starting states.\n    ///\n    /// `starts[0]` is always present and corresponds to the starting state\n    /// when searching for matches of any pattern in the DFA.\n    ///\n    /// `starts[i]` where i>0 corresponds to the starting state for the pattern\n    /// ID 'i-1'. These starting states are optional.\n    starts: Vec<StateID>,\n    /// Every state ID >= this value corresponds to a match state.\n    ///\n    /// This is what a search uses to detect whether a state is a match state\n    /// or not. It requires only a simple comparison instead of bit-unpacking\n    /// the PatternEpsilons from every state.\n    min_match_id: StateID,\n    /// The alphabet of this DFA, split into equivalence classes. Bytes in the\n    /// same equivalence class can never discriminate between a match and a\n    /// non-match.\n    classes: ByteClasses,\n    /// The number of elements in each state in the transition table. This may\n    /// be less than the stride, since the stride is always a power of 2 and\n    /// the alphabet length can be anything up to and including 256.\n    alphabet_len: usize,\n    /// The number of columns in the transition table, expressed as a power of\n    /// 2.\n    stride2: usize,\n    /// The offset at which the PatternEpsilons for a match state is stored in\n    /// the transition table.\n    ///\n    /// PERF: One wonders whether it would be better to put this in a separate\n    /// allocation, since only match states have a non-empty PatternEpsilons\n    /// and the number of match states tends be dwarfed by the number of\n    /// non-match states. So this would save '8*len(non_match_states)' for each\n    /// DFA. The question is whether moving this to a different allocation will\n    /// lead to a perf hit during searches. You might think dealing with match\n    /// states is rare, but some regexes spend a lot of time in match states\n    /// gobbling up input. But... match state handling is already somewhat\n    /// expensive, so maybe this wouldn't do much? Either way, it's worth\n    /// experimenting.\n    pateps_offset: usize,\n    /// The first explicit slot index. This refers to the first slot appearing\n    /// immediately after the last implicit slot. It is always 'patterns.len()\n    /// * 2'.\n    ///\n    /// We record this because we only store the explicit slots in our DFA\n    /// transition table that need to be saved. Implicit slots are handled\n    /// automatically as part of the search.\n    explicit_slot_start: usize,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Scratch space used to store slots during a search. Basically, we use\n    /// the caller provided slots to store slots known when a match occurs.\n    /// But after a match occurs, we might continue a search but ultimately\n    /// fail to extend the match. When continuing the search, we need some\n    /// place to store candidate capture offsets without overwriting the slot\n    /// offsets recorded for the most recently seen match.\n    explicit_slots: Vec<Option<NonMaxUsize>>,\n    /// The number of slots in the caller-provided 'Captures' value for the\n    /// current search. This is always at most 'explicit_slots.len()', but\n    /// might be less than it, if the caller provided fewer slots to fill.\n    explicit_slot_len: usize,\n}\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Copy, Eq, PartialEq)]\nstruct Transition(u64);\n#[derive(Clone, Copy)]\nstruct Slots(u32);\n#[derive(Clone, Copy)]\nstruct Epsilons(u64);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Copy, Default, Eq, PartialEq)]\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where\n    /// `i = Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u32,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Transition {\n    /// The inclusive start of the byte range.\n    pub start: u8,\n    /// The inclusive end of the byte range.\n    pub end: u8,\n    /// The identifier of the state to transition to.\n    pub next: StateID,\n}\n#[derive(Debug)]\npub struct PatternIter<'a> {\n    it: PatternIDIter,\n    /// We explicitly associate a lifetime with this iterator even though we\n    /// don't actually borrow anything from the NFA. We do this for backward\n    /// compatibility purposes. If we ever do need to borrow something from\n    /// the NFA, then we can and just get rid of this marker without breaking\n    /// the public API.\n    _marker: core::marker::PhantomData<&'a ()>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone)]\nstruct Transition {\n    /// The byte range.\n    range: Utf8Range,\n    /// The next state to transition to.\n    next_id: StateID,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy)]\nstruct Transition {\n    byte: u8,\n    next: StateID,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\nimpl DFA {\n    fn search_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<PatternID>, MatchError> {\n        if input.is_done() {\n            return Ok(None);\n        }\n        let explicit_slots_len = core::cmp::min(\n            Slots::LIMIT,\n            slots.len().saturating_sub(self.explicit_slot_start),\n        );\n        cache.setup_search(explicit_slots_len);\n        for slot in cache.explicit_slots() {\n            *slot = None;\n        }\n        for slot in slots.iter_mut() {\n            *slot = None;\n        }\n        for pid in self.nfa.patterns() {\n            let i = pid.as_usize() * 2;\n            if i >= slots.len() {\n                break;\n            }\n            slots[i] = NonMaxUsize::new(input.start());\n        }\n        let mut pid = None;\n        let mut next_sid = match input.get_anchored() {\n            Anchored::Yes => self.start(),\n            Anchored::Pattern(pid) => self.start_pattern(pid)?,\n            Anchored::No => {\n                if !self.nfa.is_always_start_anchored() {\n                    return Err(MatchError::unsupported_anchored(Anchored::No));\n                }\n                self.start()\n            }\n        };\n        let leftmost_first = matches!(\n            self.config.get_match_kind(), MatchKind::LeftmostFirst\n        );\n        for at in input.start()..input.end() {\n            let sid = next_sid;\n            let trans = self.transition(sid, input.haystack()[at]);\n            next_sid = trans.state_id();\n            let epsilons = trans.epsilons();\n            if sid >= self.min_match_id {\n                if self.find_match(cache, input, at, sid, slots, &mut pid) {\n                    if input.get_earliest() || (leftmost_first && trans.match_wins()) {\n                        return Ok(pid);\n                    }\n                }\n            }\n            if sid == DEAD\n                || (!epsilons.looks().is_empty()\n                    && !self\n                        .nfa\n                        .look_matcher()\n                        .matches_set_inline(epsilons.looks(), input.haystack(), at))\n            {\n                return Ok(pid);\n            }\n            epsilons.slots().apply(at, cache.explicit_slots());\n        }\n        if next_sid >= self.min_match_id {\n            self.find_match(cache, input, input.end(), next_sid, slots, &mut pid);\n        }\n        Ok(pid)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_match(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        at: usize,\n        sid: StateID,\n        slots: &mut [Option<NonMaxUsize>],\n        matched_pid: &mut Option<PatternID>,\n    ) -> bool {\n        debug_assert!(sid >= self.min_match_id);\n        let pateps = self.pattern_epsilons(sid);\n        let epsilons = pateps.epsilons();\n        if !epsilons.looks().is_empty()\n            && !self\n                .nfa\n                .look_matcher()\n                .matches_set_inline(epsilons.looks(), input.haystack(), at)\n        {\n            return false;\n        }\n        let pid = pateps.pattern_id_unchecked();\n        let slot_end = pid.as_usize().wrapping_mul(2).wrapping_add(1);\n        if slot_end < slots.len() {\n            slots[slot_end] = NonMaxUsize::new(at);\n        }\n        if self.explicit_slot_start < slots.len() {\n            slots[self.explicit_slot_start..].copy_from_slice(cache.explicit_slots());\n            epsilons.slots().apply(at, &mut slots[self.explicit_slot_start..]);\n        }\n        *matched_pid = Some(pid);\n        true\n    }\n}\nimpl Cache {\n    pub fn new(re: &DFA) -> Cache {}\n    pub fn reset(&mut self, re: &DFA) {}\n    pub fn memory_usage(&self) -> usize {}\n    fn explicit_slots(&mut self) -> &mut [Option<NonMaxUsize>] {\n        &mut self.explicit_slots[..self.explicit_slot_len]\n    }\n    fn setup_search(&mut self, explicit_slot_len: usize) {\n        self.explicit_slot_len = explicit_slot_len;\n    }\n}\nimpl LookMatcher {\n    pub fn new() -> LookMatcher {}\n    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {}\n    pub fn get_line_terminator(&self) -> u8 {}\n    #[inline]\n    pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_inline(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn matches_set(&self, set: LookSet, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_set_inline(\n        &self,\n        set: LookSet,\n        haystack: &[u8],\n        at: usize,\n    ) -> bool {\n        if set.contains(Look::Start) {\n            if !self.is_start(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::End) {\n            if !self.is_end(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::StartLF) {\n            if !self.is_start_lf(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::EndLF) {\n            if !self.is_end_lf(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::StartCRLF) {\n            if !self.is_start_crlf(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::EndCRLF) {\n            if !self.is_end_crlf(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::WordAscii) {\n            if !self.is_word_ascii(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::WordAsciiNegate) {\n            if !self.is_word_ascii_negate(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::WordUnicode) {\n            if !self.is_word_unicode(haystack, at).unwrap() {\n                return false;\n            }\n        }\n        if set.contains(Look::WordUnicodeNegate) {\n            if !self.is_word_unicode_negate(haystack, at).unwrap() {\n                return false;\n            }\n        }\n        if set.contains(Look::WordStartAscii) {\n            if !self.is_word_start_ascii(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::WordEndAscii) {\n            if !self.is_word_end_ascii(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::WordStartUnicode) {\n            if !self.is_word_start_unicode(haystack, at).unwrap() {\n                return false;\n            }\n        }\n        if set.contains(Look::WordEndUnicode) {\n            if !self.is_word_end_unicode(haystack, at).unwrap() {\n                return false;\n            }\n        }\n        if set.contains(Look::WordStartHalfAscii) {\n            if !self.is_word_start_half_ascii(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::WordEndHalfAscii) {\n            if !self.is_word_end_half_ascii(haystack, at) {\n                return false;\n            }\n        }\n        if set.contains(Look::WordStartHalfUnicode) {\n            if !self.is_word_start_half_unicode(haystack, at).unwrap() {\n                return false;\n            }\n        }\n        if set.contains(Look::WordEndHalfUnicode) {\n            if !self.is_word_end_half_unicode(haystack, at).unwrap() {\n                return false;\n            }\n        }\n        true\n    }\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn add_to_byteset(\n        &self,\n        look: Look,\n        set: &mut crate::util::alphabet::ByteClassSet,\n    ) {}\n    #[inline]\n    pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_unicode_negate(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {\n        self.anchored\n    }\n    #[inline]\n    pub fn get_earliest(&self) -> bool {\n        self.earliest\n    }\n    #[inline]\n    pub fn is_done(&self) -> bool {\n        self.get_span().start > self.get_span().end\n    }\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {\n        PatternIter {\n            it: PatternID::iter(self.pattern_len()),\n            _marker: core::marker::PhantomData,\n        }\n    }\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {}\n    #[inline]\n    pub fn states(&self) -> &[State] {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {}\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {}\n    #[inline]\n    pub fn is_utf8(&self) -> bool {}\n    #[inline]\n    pub fn is_reverse(&self) -> bool {}\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {\n        self.start_anchored() == self.start_unanchored()\n    }\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {\n        &self.0.look_matcher\n    }\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {}\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {}\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {\n        MatchError::new(MatchErrorKind::UnsupportedAnchored {\n            mode,\n        })\n    }\n}\nimpl Transition {\n    const STATE_ID_BITS: u64 = 21;\n    const STATE_ID_SHIFT: u64 = 64 - Transition::STATE_ID_BITS;\n    const STATE_ID_LIMIT: u64 = 1 << Transition::STATE_ID_BITS;\n    const MATCH_WINS_SHIFT: u64 = 64 - (Transition::STATE_ID_BITS + 1);\n    const INFO_MASK: u64 = 0x000003FF_FFFFFFFF;\n    fn new(match_wins: bool, sid: StateID, epsilons: Epsilons) -> Transition {}\n    fn is_dead(self) -> bool {}\n    fn match_wins(&self) -> bool {\n        (self.0 >> Transition::MATCH_WINS_SHIFT & 1) == 1\n    }\n    fn state_id(&self) -> StateID {\n        StateID::new_unchecked((self.0 >> Transition::STATE_ID_SHIFT).as_usize())\n    }\n    fn set_state_id(&mut self, sid: StateID) {}\n    fn epsilons(&self) -> Epsilons {\n        Epsilons(self.0 & Transition::INFO_MASK)\n    }\n}\nimpl Slots {\n    const LIMIT: usize = 32;\n    fn insert(self, slot: usize) -> Slots {}\n    fn remove(self, slot: usize) -> Slots {}\n    fn is_empty(self) -> bool {}\n    fn iter(self) -> SlotsIter {}\n    fn apply(self, at: usize, caller_explicit_slots: &mut [Option<NonMaxUsize>]) {\n        if self.is_empty() {\n            return;\n        }\n        let at = NonMaxUsize::new(at);\n        for slot in self.iter() {\n            if slot >= caller_explicit_slots.len() {\n                break;\n            }\n            caller_explicit_slots[slot] = at;\n        }\n    }\n}\nimpl Epsilons {\n    const SLOT_MASK: u64 = 0x000003FF_FFFFFC00;\n    const SLOT_SHIFT: u64 = 10;\n    const LOOK_MASK: u64 = 0x00000000_000003FF;\n    fn empty() -> Epsilons {}\n    fn is_empty(self) -> bool {}\n    fn slots(self) -> Slots {\n        Slots((self.0 >> Epsilons::SLOT_SHIFT).low_u32())\n    }\n    fn set_slots(self, slots: Slots) -> Epsilons {}\n    fn looks(self) -> LookSet {\n        LookSet {\n            bits: (self.0 & Epsilons::LOOK_MASK).low_u32(),\n        }\n    }\n    fn set_looks(self, look_set: LookSet) -> Epsilons {}\n}\nimpl Config {\n    pub fn new() -> Config {}\n    pub fn match_kind(mut self, kind: MatchKind) -> Config {}\n    pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {}\n    pub fn byte_classes(mut self, yes: bool) -> Config {}\n    pub fn size_limit(mut self, limit: Option<usize>) -> Config {}\n    pub fn get_match_kind(&self) -> MatchKind {\n        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)\n    }\n    pub fn get_starts_for_each_pattern(&self) -> bool {}\n    pub fn get_byte_classes(&self) -> bool {}\n    pub fn get_size_limit(&self) -> Option<usize> {}\n    pub(crate) fn overwrite(&self, o: Config) -> Config {}\n}\nimpl NonMaxUsize {\n    #[inline]\n    pub fn new(value: usize) -> Option<NonMaxUsize> {\n        NonZeroUsize::new(value.wrapping_add(1)).map(NonMaxUsize)\n    }\n    #[inline]\n    pub fn get(self) -> usize {}\n}\nimpl LookSet {\n    #[inline]\n    pub fn empty() -> LookSet {}\n    #[inline]\n    pub fn full() -> LookSet {}\n    #[inline]\n    pub fn singleton(look: Look) -> LookSet {}\n    #[inline]\n    pub fn len(self) -> usize {}\n    #[inline]\n    pub fn is_empty(self) -> bool {\n        self.len() == 0\n    }\n    #[inline]\n    pub fn contains(self, look: Look) -> bool {}\n    #[inline]\n    pub fn contains_anchor(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_haystack(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_line(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_lf(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_crlf(&self) -> bool {}\n    #[inline]\n    pub fn contains_word(self) -> bool {}\n    #[inline]\n    pub fn contains_word_unicode(self) -> bool {}\n    #[inline]\n    pub fn contains_word_ascii(self) -> bool {}\n    #[inline]\n    pub fn iter(self) -> LookSetIter {}\n    #[inline]\n    pub fn insert(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_insert(&mut self, look: Look) {}\n    #[inline]\n    pub fn remove(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_remove(&mut self, look: Look) {}\n    #[inline]\n    pub fn subtract(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_subtract(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn union(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_union(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn intersect(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_intersect(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn read_repr(slice: &[u8]) -> LookSet {}\n    #[inline]\n    pub fn write_repr(self, slice: &mut [u8]) {}\n    pub fn available(self) -> Result<(), UnicodeWordBoundaryError> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n2040 fn search_imp(\n2041     &self,\n2042     cache: &mut Cache,\n2043     input: &Input<'_>,\n2044     slots: &mut [Option<NonMaxUsize>],\n2045 ) -> Result<Option<PatternID>, MatchError> {\n2046     // PERF: Some ideas. I ran out of steam after my initial impl to try\n2047     // many of these.\n2048     //\n2049     // 1) Try doing more state shuffling. Right now, all we do is push\n2050     // match states to the end of the transition table so that we can do\n2051     // 'if sid >= self.min_match_id' to know whether we're in a match\n2052     // state or not. But what about doing something like dense DFAs and\n2053     // pushing dead, match and states with captures/looks all toward the\n2054     // beginning of the transition table. Then we could do 'if sid <=\n2055     // self.max_special_id', in which case, we need to do some special\n2056     // handling of some sort. Otherwise, we get the happy path, just\n2057     // like in a DFA search. The main argument against this is that the\n2058     // one-pass DFA is likely to be used most often with capturing groups\n2059     // and if capturing groups are common, then this might wind up being a\n2060     // pessimization.\n2061     //\n2062     // 2) Consider moving 'PatternEpsilons' out of the transition table.\n2063     // It is only needed for match states and usually a small minority of\n2064     // states are match states. Therefore, we're using an extra 'u64' for\n2065     // most states.\n2066     //\n2067     // 3) I played around with the match state handling and it seems like\n2068     // there is probably a lot left on the table for improvement. The\n2069     // key tension is that the 'find_match' routine is a giant mess, but\n2070     // splitting it out into a non-inlineable function is a non-starter\n2071     // because the match state might consume input, so 'find_match' COULD\n2072     // be called quite a lot, and a function call at that point would trash\n2073     // perf. In theory, we could detect whether a match state consumes\n2074     // input and then specialize our search routine based on that. In that\n2075     // case, maybe an extra function call is OK, but even then, it might be\n2076     // too much of a latency hit. Another idea is to just try and figure\n2077     // out how to reduce the code size of 'find_match'. RE2 has a trick\n2078     // here where the match handling isn't done if we know the next byte of\n2079     // input yields a match too. Maybe we adopt that?\n2080     //\n2081     // This just might be a tricky DFA to optimize.\n2082 \n2083     if input.is_done() {\n2084         return Ok(None);\n2085     }\n2086     // We unfortunately have a bit of book-keeping to do to set things\n2087     // up. We do have to setup our cache and clear all of our slots. In\n2088     // particular, clearing the slots is necessary for the case where we\n2089     // report a match, but one of the capturing groups didn't participate\n2090     // in the match but had a span set from a previous search. That would\n2091     // be bad. In theory, we could avoid all this slot clearing if we knew\n2092     // that every slot was always activated for every match. Then we would\n2093     // know they would always be overwritten when a match is found.\n2094     let explicit_slots_len = core::cmp::min(\n2095         Slots::LIMIT,\n2096         slots.len().saturating_sub(self.explicit_slot_start),\n2097     );\n2098     cache.setup_search(explicit_slots_len);\n2099     for slot in cache.explicit_slots() {\n2100         *slot = None;\n2101     }\n2102     for slot in slots.iter_mut() {\n2103         *slot = None;\n2104     }\n2105     // We set the starting slots for every pattern up front. This does\n2106     // increase our latency somewhat, but it avoids having to do it every\n2107     // time we see a match state (which could be many times in a single\n2108     // search if the match state consumes input).\n2109     for pid in self.nfa.patterns() {\n2110         let i = pid.as_usize() * 2;\n2111         if i >= slots.len() {\n2112             break;\n2113         }\n2114         slots[i] = NonMaxUsize::new(input.start());\n2115     }\n2116     let mut pid = None;\n2117     let mut next_sid = match input.get_anchored() {\n2118         Anchored::Yes => self.start(),\n2119         Anchored::Pattern(pid) => self.start_pattern(pid)?,\n2120         Anchored::No => {\n2121             // If the regex is itself always anchored, then we're fine,\n2122             // even if the search is configured to be unanchored.\n2123             if !self.nfa.is_always_start_anchored() {\n2124                 return Err(MatchError::unsupported_anchored(\n2125                     Anchored::No,\n2126                 ));\n2127             }\n2128             self.start()\n2129         }\n2130     };\n2131     let leftmost_first =\n2132         matches!(self.config.get_match_kind(), MatchKind::LeftmostFirst);\n2133     for at in input.start()..input.end() {\n2134         let sid = next_sid;\n2135         let trans = self.transition(sid, input.haystack()[at]);\n2136         next_sid = trans.state_id();\n2137         let epsilons = trans.epsilons();\n2138         if sid >= self.min_match_id {\n2139             if self.find_match(cache, input, at, sid, slots, &mut pid) {\n2140                 if input.get_earliest()\n2141                     || (leftmost_first && trans.match_wins())\n2142                 {\n2143                     return Ok(pid);\n2144                 }\n2145             }\n2146         }\n2147         if sid == DEAD\n2148             || (!epsilons.looks().is_empty()\n2149                 && !self.nfa.look_matcher().matches_set_inline(\n2150                     epsilons.looks(),\n2151                     input.haystack(),\n2152                     at,\n2153                 ))\n2154         {\n2155             return Ok(pid);\n2156         }\n2157         epsilons.slots().apply(at, cache.explicit_slots());\n2158     }\n2159     if next_sid >= self.min_match_id {\n2160         self.find_match(\n2161             cache,\n2162             input,\n2163             input.end(),\n2164             next_sid,\n2165             slots,\n2166             &mut pid,\n2167         );\n2168     }\n2169     Ok(pid)\n2170 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}