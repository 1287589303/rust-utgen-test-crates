{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/regex/bytes.rs\n// crate name is regex\npub type Locations = CaptureLocations;\nuse alloc::{borrow::Cow, string::String, sync::Arc, vec::Vec};\nuse regex_automata::{meta, util::captures, Input, PatternID};\nuse crate::{bytes::RegexBuilder, error::Error};\n#[derive(Clone)]\npub struct Regex {\n    pub(crate) meta: meta::Regex,\n    pub(crate) pattern: Arc<str>,\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\npub struct Match<'h> {\n    haystack: &'h [u8],\n    start: usize,\n    end: usize,\n}\npub struct Captures<'h> {\n    haystack: &'h [u8],\n    caps: captures::Captures,\n    static_captures_len: Option<usize>,\n}\n#[derive(Debug)]\npub struct CaptureMatches<'r, 'h> {\n    haystack: &'h [u8],\n    it: meta::CapturesMatches<'r, 'h>,\n}\n#[derive(Clone)]\npub struct Regex {\n    pub(crate) meta: meta::Regex,\n    pub(crate) pattern: Arc<str>,\n}\n#[derive(Debug)]\npub struct Matches<'r, 'h> {\n    haystack: &'h [u8],\n    it: meta::FindMatches<'r, 'h>,\n}\nimpl Regex {\n    pub fn new(re: &str) -> Result<Regex, Error> {}\n    #[inline]\n    pub fn is_match(&self, haystack: &[u8]) -> bool {}\n    #[inline]\n    pub fn find<'h>(&self, haystack: &'h [u8]) -> Option<Match<'h>> {}\n    #[inline]\n    pub fn find_iter<'r, 'h>(&'r self, haystack: &'h [u8]) -> Matches<'r, 'h> {\n        Matches {\n            haystack,\n            it: self.meta.find_iter(haystack),\n        }\n    }\n    #[inline]\n    pub fn captures<'h>(&self, haystack: &'h [u8]) -> Option<Captures<'h>> {}\n    #[inline]\n    pub fn captures_iter<'r, 'h>(\n        &'r self,\n        haystack: &'h [u8],\n    ) -> CaptureMatches<'r, 'h> {\n        CaptureMatches {\n            haystack,\n            it: self.meta.captures_iter(haystack),\n        }\n    }\n    #[inline]\n    pub fn split<'r, 'h>(&'r self, haystack: &'h [u8]) -> Split<'r, 'h> {}\n    #[inline]\n    pub fn splitn<'r, 'h>(&'r self, haystack: &'h [u8], limit: usize) -> SplitN<'r, 'h> {}\n    #[inline]\n    pub fn replace<'h, R: Replacer>(&self, haystack: &'h [u8], rep: R) -> Cow<'h, [u8]> {}\n    #[inline]\n    pub fn replace_all<'h, R: Replacer>(\n        &self,\n        haystack: &'h [u8],\n        rep: R,\n    ) -> Cow<'h, [u8]> {}\n    #[inline]\n    pub fn replacen<'h, R: Replacer>(\n        &self,\n        haystack: &'h [u8],\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'h, [u8]> {\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(haystack).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(haystack);\n            }\n            let mut new = Vec::with_capacity(haystack.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                new.extend_from_slice(&haystack[last_match..m.start()]);\n                new.extend_from_slice(&rep);\n                last_match = m.end();\n                if limit > 0 && i >= limit - 1 {\n                    break;\n                }\n            }\n            new.extend_from_slice(&haystack[last_match..]);\n            return Cow::Owned(new);\n        }\n        let mut it = self.captures_iter(haystack).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(haystack);\n        }\n        let mut new = Vec::with_capacity(haystack.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            let m = cap.get(0).unwrap();\n            new.extend_from_slice(&haystack[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n            if limit > 0 && i >= limit - 1 {\n                break;\n            }\n        }\n        new.extend_from_slice(&haystack[last_match..]);\n        Cow::Owned(new)\n    }\n}\nimpl<'h> Match<'h> {\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.end\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    pub fn len(&self) -> usize {}\n    #[inline]\n    pub fn range(&self) -> core::ops::Range<usize> {}\n    #[inline]\n    pub fn as_bytes(&self) -> &'h [u8] {}\n    #[inline]\n    fn new(haystack: &'h [u8], start: usize, end: usize) -> Match<'h> {}\n}\nimpl<'h> Captures<'h> {\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<Match<'h>> {\n        self.caps.get_group(i).map(|sp| Match::new(self.haystack, sp.start, sp.end))\n    }\n    #[inline]\n    pub fn name(&self, name: &str) -> Option<Match<'h>> {}\n    pub fn extract<const N: usize>(&self) -> (&'h [u8], [&'h [u8]; N]) {}\n    #[inline]\n    pub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>) {}\n    #[inline]\n    pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> {}\n    #[inline]\n    pub fn len(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Replaces at most `limit` non-overlapping matches in the haystack with\n/// the replacement provided. If `limit` is `0`, then all non-overlapping\n/// matches are replaced. That is, `Regex::replace_all(hay, rep)` is\n/// equivalent to `Regex::replacen(hay, 0, rep)`.\n///\n/// If no match is found, then the haystack is returned unchanged. In that\n/// case, this implementation will likely return a `Cow::Borrowed` value\n/// such that no allocation is performed.\n///\n/// When a `Cow::Borrowed` is returned, the value returned is guaranteed\n/// to be equivalent to the `haystack` given.\n///\n/// The documentation for [`Regex::replace`] goes into more detail about\n/// what kinds of replacement strings are supported.\n///\n/// # Time complexity\n///\n/// Since iterators over all matches requires running potentially many\n/// searches on the haystack, and since each search has worst case\n/// `O(m * n)` time complexity, the overall worst case time complexity for\n/// this routine is `O(m * n^2)`.\n///\n/// Although note that the worst case time here has an upper bound given\n/// by the `limit` parameter.\n///\n/// # Fallibility\n///\n/// See the corresponding section in the docs for [`Regex::replace_all`]\n/// for tips on how to deal with a replacement routine that can fail.\n///\n/// # Example\n///\n/// This example shows how to flip the order of whitespace (excluding line\n/// terminators) delimited fields, and normalizes the whitespace that\n/// delimits the fields. But we only do it for the first two matches.\n///\n/// ```\n/// use regex::bytes::Regex;\n///\n/// let re = Regex::new(r\"(?m)^(\\S+)[\\s--\\r\\n]+(\\S+)$\").unwrap();\n/// let hay = b\"\n/// Greetings  1973\n/// Wild\\t1973\n/// BornToRun\\t\\t\\t\\t1975\n/// Darkness                    1978\n/// TheRiver 1980\n/// \";\n/// let new = re.replacen(hay, 2, b\"$2 $1\");\n/// assert_eq!(new, &b\"\n/// 1973 Greetings\n/// 1973 Wild\n/// BornToRun\\t\\t\\t\\t1975\n/// Darkness                    1978\n/// TheRiver 1980\n/// \"[..]);\n/// ```\n920 pub fn replacen<'h, R: Replacer>(\n921     &self,\n922     haystack: &'h [u8],\n923     limit: usize,\n924     mut rep: R,\n925 ) -> Cow<'h, [u8]> {\n926     // If we know that the replacement doesn't have any capture expansions,\n927     // then we can use the fast path. The fast path can make a tremendous\n928     // difference:\n929     //\n930     //   1) We use `find_iter` instead of `captures_iter`. Not asking for\n931     //      captures generally makes the regex engines faster.\n932     //   2) We don't need to look up all of the capture groups and do\n933     //      replacements inside the replacement string. We just push it\n934     //      at each match and be done with it.\n935     if let Some(rep) = rep.no_expansion() {\n936         let mut it = self.find_iter(haystack).enumerate().peekable();\n937         if it.peek().is_none() {\n938             return Cow::Borrowed(haystack);\n939         }\n940         let mut new = Vec::with_capacity(haystack.len());\n941         let mut last_match = 0;\n942         for (i, m) in it {\n943             new.extend_from_slice(&haystack[last_match..m.start()]);\n944             new.extend_from_slice(&rep);\n945             last_match = m.end();\n946             if limit > 0 && i >= limit - 1 {\n947                 break;\n948             }\n949         }\n950         new.extend_from_slice(&haystack[last_match..]);\n951         return Cow::Owned(new);\n952     }\n953 \n954     // The slower path, which we use if the replacement needs access to\n955     // capture groups.\n956     let mut it = self.captures_iter(haystack).enumerate().peekable();\n957     if it.peek().is_none() {\n958         return Cow::Borrowed(haystack);\n959     }\n960     let mut new = Vec::with_capacity(haystack.len());\n961     let mut last_match = 0;\n962     for (i, cap) in it {\n963         // unwrap on 0 is OK because captures only reports matches\n964         let m = cap.get(0).unwrap();\n965         new.extend_from_slice(&haystack[last_match..m.start()]);\n966         rep.replace_append(&cap, &mut new);\n967         last_match = m.end();\n968         if limit > 0 && i >= limit - 1 {\n969             break;\n970         }\n971     }\n972     new.extend_from_slice(&haystack[last_match..]);\n973     Cow::Owned(new)\n974 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}