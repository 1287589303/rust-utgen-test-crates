{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Properties(Box<PropertiesI>);\n#[derive(Clone, Copy, Default, Eq, PartialEq)]\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where `i =\n    /// Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u32,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct PropertiesI {\n    minimum_len: Option<usize>,\n    maximum_len: Option<usize>,\n    look_set: LookSet,\n    look_set_prefix: LookSet,\n    look_set_suffix: LookSet,\n    look_set_prefix_any: LookSet,\n    look_set_suffix_any: LookSet,\n    utf8: bool,\n    explicit_captures_len: usize,\n    static_explicit_captures_len: Option<usize>,\n    literal: bool,\n    alternation_literal: bool,\n}\nimpl Properties {\n    #[inline]\n    pub fn minimum_len(&self) -> Option<usize> {\n        self.0.minimum_len\n    }\n    #[inline]\n    pub fn maximum_len(&self) -> Option<usize> {\n        self.0.maximum_len\n    }\n    #[inline]\n    pub fn look_set(&self) -> LookSet {\n        self.0.look_set\n    }\n    #[inline]\n    pub fn look_set_prefix(&self) -> LookSet {\n        self.0.look_set_prefix\n    }\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {\n        self.0.look_set_prefix_any\n    }\n    #[inline]\n    pub fn look_set_suffix(&self) -> LookSet {\n        self.0.look_set_suffix\n    }\n    #[inline]\n    pub fn look_set_suffix_any(&self) -> LookSet {\n        self.0.look_set_suffix_any\n    }\n    #[inline]\n    pub fn is_utf8(&self) -> bool {\n        self.0.utf8\n    }\n    #[inline]\n    pub fn explicit_captures_len(&self) -> usize {\n        self.0.explicit_captures_len\n    }\n    #[inline]\n    pub fn static_explicit_captures_len(&self) -> Option<usize> {\n        self.0.static_explicit_captures_len\n    }\n    #[inline]\n    pub fn is_literal(&self) -> bool {\n        self.0.literal\n    }\n    #[inline]\n    pub fn is_alternation_literal(&self) -> bool {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    pub fn union<I, P>(props: I) -> Properties\n    where\n        I: IntoIterator<Item = P>,\n        P: core::borrow::Borrow<Properties>,\n    {\n        let mut it = props.into_iter().peekable();\n        let fix = if it.peek().is_none() { LookSet::empty() } else { LookSet::full() };\n        let static_explicit_captures_len = it\n            .peek()\n            .and_then(|p| p.borrow().static_explicit_captures_len());\n        let mut props = PropertiesI {\n            minimum_len: None,\n            maximum_len: None,\n            look_set: LookSet::empty(),\n            look_set_prefix: fix,\n            look_set_suffix: fix,\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len,\n            literal: false,\n            alternation_literal: true,\n        };\n        let (mut min_poisoned, mut max_poisoned) = (false, false);\n        for prop in it {\n            let p = prop.borrow();\n            props.look_set.set_union(p.look_set());\n            props.look_set_prefix.set_intersect(p.look_set_prefix());\n            props.look_set_suffix.set_intersect(p.look_set_suffix());\n            props.look_set_prefix_any.set_union(p.look_set_prefix_any());\n            props.look_set_suffix_any.set_union(p.look_set_suffix_any());\n            props.utf8 = props.utf8 && p.is_utf8();\n            props.explicit_captures_len = props\n                .explicit_captures_len\n                .saturating_add(p.explicit_captures_len());\n            if props.static_explicit_captures_len != p.static_explicit_captures_len() {\n                props.static_explicit_captures_len = None;\n            }\n            props.alternation_literal = props.alternation_literal && p.is_literal();\n            if !min_poisoned {\n                if let Some(xmin) = p.minimum_len() {\n                    if props.minimum_len.map_or(true, |pmin| xmin < pmin) {\n                        props.minimum_len = Some(xmin);\n                    }\n                } else {\n                    props.minimum_len = None;\n                    min_poisoned = true;\n                }\n            }\n            if !max_poisoned {\n                if let Some(xmax) = p.maximum_len() {\n                    if props.maximum_len.map_or(true, |pmax| xmax > pmax) {\n                        props.maximum_len = Some(xmax);\n                    }\n                } else {\n                    props.maximum_len = None;\n                    max_poisoned = true;\n                }\n            }\n        }\n        Properties(Box::new(props))\n    }\n}\nimpl LookSet {\n    #[inline]\n    pub fn empty() -> LookSet {\n        LookSet { bits: 0 }\n    }\n    #[inline]\n    pub fn full() -> LookSet {\n        LookSet { bits: !0 }\n    }\n    #[inline]\n    pub fn singleton(look: Look) -> LookSet {}\n    #[inline]\n    pub fn len(self) -> usize {}\n    #[inline]\n    pub fn is_empty(self) -> bool {}\n    #[inline]\n    pub fn contains(self, look: Look) -> bool {}\n    #[inline]\n    pub fn contains_anchor(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_haystack(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_line(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_lf(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_crlf(&self) -> bool {}\n    #[inline]\n    pub fn contains_word(self) -> bool {}\n    #[inline]\n    pub fn contains_word_unicode(self) -> bool {}\n    #[inline]\n    pub fn contains_word_ascii(self) -> bool {}\n    #[inline]\n    pub fn iter(self) -> LookSetIter {}\n    #[inline]\n    pub fn insert(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_insert(&mut self, look: Look) {}\n    #[inline]\n    pub fn remove(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_remove(&mut self, look: Look) {}\n    #[inline]\n    pub fn subtract(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_subtract(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn union(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_union(&mut self, other: LookSet) {\n        *self = self.union(other);\n    }\n    #[inline]\n    pub fn intersect(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_intersect(&mut self, other: LookSet) {\n        *self = self.intersect(other);\n    }\n    #[inline]\n    pub fn read_repr(slice: &[u8]) -> LookSet {}\n    #[inline]\n    pub fn write_repr(self, slice: &mut [u8]) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns a new set of properties that corresponds to the union of the\n/// iterator of properties given.\n///\n/// This is useful when one has multiple `Hir` expressions and wants\n/// to combine them into a single alternation without constructing the\n/// corresponding `Hir`. This routine provides a way of combining the\n/// properties of each `Hir` expression into one set of properties\n/// representing the union of those expressions.\n///\n/// # Example: union with HIRs that never match\n///\n/// This example shows that unioning properties together with one that\n/// represents a regex that never matches will \"poison\" certain attributes,\n/// like the minimum and maximum lengths.\n///\n/// ```\n/// use regex_syntax::{hir::Properties, parse};\n///\n/// let hir1 = parse(\"ab?c?\")?;\n/// assert_eq!(Some(1), hir1.properties().minimum_len());\n/// assert_eq!(Some(3), hir1.properties().maximum_len());\n///\n/// let hir2 = parse(r\"[a&&b]\")?;\n/// assert_eq!(None, hir2.properties().minimum_len());\n/// assert_eq!(None, hir2.properties().maximum_len());\n///\n/// let hir3 = parse(r\"wxy?z?\")?;\n/// assert_eq!(Some(2), hir3.properties().minimum_len());\n/// assert_eq!(Some(4), hir3.properties().maximum_len());\n///\n/// let unioned = Properties::union([\n///\t\thir1.properties(),\n///\t\thir2.properties(),\n///\t\thir3.properties(),\n///\t]);\n/// assert_eq!(None, unioned.minimum_len());\n/// assert_eq!(None, unioned.maximum_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// The maximum length can also be \"poisoned\" by a pattern that has no\n/// upper bound on the length of a match. The minimum length remains\n/// unaffected:\n///\n/// ```\n/// use regex_syntax::{hir::Properties, parse};\n///\n/// let hir1 = parse(\"ab?c?\")?;\n/// assert_eq!(Some(1), hir1.properties().minimum_len());\n/// assert_eq!(Some(3), hir1.properties().maximum_len());\n///\n/// let hir2 = parse(r\"a+\")?;\n/// assert_eq!(Some(1), hir2.properties().minimum_len());\n/// assert_eq!(None, hir2.properties().maximum_len());\n///\n/// let hir3 = parse(r\"wxy?z?\")?;\n/// assert_eq!(Some(2), hir3.properties().minimum_len());\n/// assert_eq!(Some(4), hir3.properties().maximum_len());\n///\n/// let unioned = Properties::union([\n///\t\thir1.properties(),\n///\t\thir2.properties(),\n///\t\thir3.properties(),\n///\t]);\n/// assert_eq!(Some(1), unioned.minimum_len());\n/// assert_eq!(None, unioned.maximum_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n2310 pub fn union<I, P>(props: I) -> Properties\n2311 where\n2312     I: IntoIterator<Item = P>,\n2313     P: core::borrow::Borrow<Properties>,\n2314 {\n2315     let mut it = props.into_iter().peekable();\n2316     // While empty alternations aren't possible, we still behave as if they\n2317     // are. When we have an empty alternate, then clearly the look-around\n2318     // prefix and suffix is empty. Otherwise, it is the intersection of all\n2319     // prefixes and suffixes (respectively) of the branches.\n2320     let fix = if it.peek().is_none() {\n2321         LookSet::empty()\n2322     } else {\n2323         LookSet::full()\n2324     };\n2325     // And also, an empty alternate means we have 0 static capture groups,\n2326     // but we otherwise start with the number corresponding to the first\n2327     // alternate. If any subsequent alternate has a different number of\n2328     // static capture groups, then we overall have a variation and not a\n2329     // static number of groups.\n2330     let static_explicit_captures_len =\n2331         it.peek().and_then(|p| p.borrow().static_explicit_captures_len());\n2332     // The base case is an empty alternation, which matches nothing.\n2333     // Note though that empty alternations aren't possible, because the\n2334     // Hir::alternation smart constructor rewrites those as empty character\n2335     // classes.\n2336     let mut props = PropertiesI {\n2337         minimum_len: None,\n2338         maximum_len: None,\n2339         look_set: LookSet::empty(),\n2340         look_set_prefix: fix,\n2341         look_set_suffix: fix,\n2342         look_set_prefix_any: LookSet::empty(),\n2343         look_set_suffix_any: LookSet::empty(),\n2344         utf8: true,\n2345         explicit_captures_len: 0,\n2346         static_explicit_captures_len,\n2347         literal: false,\n2348         alternation_literal: true,\n2349     };\n2350     let (mut min_poisoned, mut max_poisoned) = (false, false);\n2351     // Handle properties that need to visit every child hir.\n2352     for prop in it {\n2353         let p = prop.borrow();\n2354         props.look_set.set_union(p.look_set());\n2355         props.look_set_prefix.set_intersect(p.look_set_prefix());\n2356         props.look_set_suffix.set_intersect(p.look_set_suffix());\n2357         props.look_set_prefix_any.set_union(p.look_set_prefix_any());\n2358         props.look_set_suffix_any.set_union(p.look_set_suffix_any());\n2359         props.utf8 = props.utf8 && p.is_utf8();\n2360         props.explicit_captures_len = props\n2361             .explicit_captures_len\n2362             .saturating_add(p.explicit_captures_len());\n2363         if props.static_explicit_captures_len\n2364             != p.static_explicit_captures_len()\n2365         {\n2366             props.static_explicit_captures_len = None;\n2367         }\n2368         props.alternation_literal =\n2369             props.alternation_literal && p.is_literal();\n2370         if !min_poisoned {\n2371             if let Some(xmin) = p.minimum_len() {\n2372                 if props.minimum_len.map_or(true, |pmin| xmin < pmin) {\n2373                     props.minimum_len = Some(xmin);\n2374                 }\n2375             } else {\n2376                 props.minimum_len = None;\n2377                 min_poisoned = true;\n2378             }\n2379         }\n2380         if !max_poisoned {\n2381             if let Some(xmax) = p.maximum_len() {\n2382                 if props.maximum_len.map_or(true, |pmax| xmax > pmax) {\n2383                     props.maximum_len = Some(xmax);\n2384                 }\n2385             } else {\n2386                 props.maximum_len = None;\n2387                 max_poisoned = true;\n2388             }\n2389         }\n2390     }\n2391     Properties(Box::new(props))\n2392 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}