{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/pikevm.rs\n// crate name is regex_automata\n#[cfg(feature = \"internal-instrument-pikevm\")]\nuse core::cell::RefCell;\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n        sparse_set::SparseSet,\n    },\n};\n#[derive(Clone, Debug)]\npub struct PikeVM {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug)]\nstruct ActiveStates {\n    /// The set of active NFA states. This set preserves insertion order, which\n    /// is critical for simulating the match semantics of backtracking regex\n    /// engines.\n    set: SparseSet,\n    /// The slots for every NFA state, where each slot stores a (possibly\n    /// absent) offset. Every capturing group has two slots. One for a start\n    /// offset and one for an end offset.\n    slot_table: SlotTable,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug)]\nenum FollowEpsilon {\n    /// Explore the epsilon transitions from a state ID.\n    Explore(StateID),\n    /// Reset the given `slot` to the given `offset` (which might be `None`).\n    RestoreCapture { slot: SmallIndex, offset: Option<NonMaxUsize> },\n}\nimpl PikeVM {\n    fn search_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {}\n    fn which_overlapping_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn nexts(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn nexts_overlapping(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        patset: &mut PatternSet,\n    ) {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slot_table: &mut SlotTable,\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        sid: StateID,\n    ) -> Option<PatternID> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn epsilon_closure(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        sid: StateID,\n    ) {\n        instrument!(| c | { c.record_closure(sid); c.record_stack_push(sid); });\n        stack.push(FollowEpsilon::Explore(sid));\n        while let Some(frame) = stack.pop() {\n            match frame {\n                FollowEpsilon::RestoreCapture { slot, offset: pos } => {\n                    curr_slots[slot] = pos;\n                }\n                FollowEpsilon::Explore(sid) => {\n                    self.epsilon_closure_explore(\n                        stack,\n                        curr_slots,\n                        next,\n                        input,\n                        at,\n                        sid,\n                    );\n                }\n            }\n        }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn epsilon_closure_explore(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        mut sid: StateID,\n    ) {\n        loop {\n            instrument!(| c | c.record_set_insert(sid));\n            if !next.set.insert(sid) {\n                return;\n            }\n            match *self.nfa.state(sid) {\n                State::Fail\n                | State::Match { .. }\n                | State::ByteRange { .. }\n                | State::Sparse { .. }\n                | State::Dense { .. } => {\n                    next.slot_table.for_state(sid).copy_from_slice(curr_slots);\n                    return;\n                }\n                State::Look { look, next } => {\n                    if !self\n                        .nfa\n                        .look_matcher()\n                        .matches_inline(look, input.haystack(), at)\n                    {\n                        return;\n                    }\n                    sid = next;\n                }\n                State::Union { ref alternates } => {\n                    sid = match alternates.get(0) {\n                        None => return,\n                        Some(&sid) => sid,\n                    };\n                    instrument!(\n                        | c | { for & alt in & alternates[1..] { c\n                        .record_stack_push(alt); } }\n                    );\n                    stack\n                        .extend(\n                            alternates[1..]\n                                .iter()\n                                .copied()\n                                .rev()\n                                .map(FollowEpsilon::Explore),\n                        );\n                }\n                State::BinaryUnion { alt1, alt2 } => {\n                    sid = alt1;\n                    instrument!(| c | c.record_stack_push(sid));\n                    stack.push(FollowEpsilon::Explore(alt2));\n                }\n                State::Capture { next, slot, .. } => {\n                    if slot.as_usize() < curr_slots.len() {\n                        instrument!(| c | c.record_stack_push(sid));\n                        stack\n                            .push(FollowEpsilon::RestoreCapture {\n                                slot,\n                                offset: curr_slots[slot],\n                            });\n                        curr_slots[slot] = Some(NonMaxUsize::new(at).unwrap());\n                    }\n                    sid = next;\n                }\n            }\n        }\n    }\n    fn start_config(&self, input: &Input<'_>) -> Option<(bool, StateID)> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Compute the epsilon closure of 'sid', writing the closure into 'next'\n/// while copying slot values from 'curr_slots' into corresponding states\n/// in 'next'. 'curr_slots' should be the slot values corresponding to\n/// 'sid'.\n///\n/// The given 'stack' is used to perform a depth first traversal of the\n/// NFA by recursively following all epsilon transitions out of 'sid'.\n/// Conditional epsilon transitions are followed if and only if they are\n/// satisfied for the position 'at' in the 'input' haystack.\n///\n/// While this routine may write to 'curr_slots', once it returns, any\n/// writes are undone and the original values (even if absent) are\n/// restored.\n1611 fn epsilon_closure(\n1612     &self,\n1613     stack: &mut Vec<FollowEpsilon>,\n1614     curr_slots: &mut [Option<NonMaxUsize>],\n1615     next: &mut ActiveStates,\n1616     input: &Input<'_>,\n1617     at: usize,\n1618     sid: StateID,\n1619 ) {\n1620     instrument!(|c| {\n1621         c.record_closure(sid);\n1622         c.record_stack_push(sid);\n1623     });\n1624     stack.push(FollowEpsilon::Explore(sid));\n1625     while let Some(frame) = stack.pop() {\n1626         match frame {\n1627             FollowEpsilon::RestoreCapture { slot, offset: pos } => {\n1628                 curr_slots[slot] = pos;\n1629             }\n1630             FollowEpsilon::Explore(sid) => {\n1631                 self.epsilon_closure_explore(\n1632                     stack, curr_slots, next, input, at, sid,\n1633                 );\n1634             }\n1635         }\n1636     }\n1637 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}