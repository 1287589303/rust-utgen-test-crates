{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {\n        let utf8empty = self.has_empty() && self.is_utf8();\n        let hm = match search::find_fwd(&self, input)? {\n            None => return Ok(None),\n            Some(hm) if !utf8empty => return Ok(Some(hm)),\n            Some(hm) => hm,\n        };\n        empty::skip_splits_fwd(\n            input,\n            hm,\n            hm.offset(),\n            |input| {\n                let got = search::find_fwd(&self, input)?;\n                Ok(got.map(|hm| (hm, hm.offset())))\n            },\n        )\n    }\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {\n        self.offset\n    }\n}\n#[inline(never)]\npub fn find_fwd<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n) -> Result<Option<HalfMatch>, MatchError> {\n    if input.is_done() {\n        return Ok(None);\n    }\n    let pre = if input.get_anchored().is_anchored() {\n        None\n    } else {\n        dfa.get_prefilter()\n    };\n    if pre.is_some() {\n        if input.get_earliest() {\n            find_fwd_imp(dfa, input, pre, true)\n        } else {\n            find_fwd_imp(dfa, input, pre, false)\n        }\n    } else {\n        if input.get_earliest() {\n            find_fwd_imp(dfa, input, None, true)\n        } else {\n            find_fwd_imp(dfa, input, None, false)\n        }\n    }\n}\n#[cold]\n#[inline(never)]\npub(crate) fn skip_splits_fwd<T, F>(\n    input: &Input<'_>,\n    init_value: T,\n    match_offset: usize,\n    find: F,\n) -> Result<Option<T>, MatchError>\nwhere\n    F: FnMut(&Input<'_>) -> Result<Option<(T, usize)>, MatchError>,\n{\n    skip_splits(true, input, init_value, match_offset, find)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes a forward search and returns the end position of the leftmost\n/// match that is found. If no match exists, then `None` is returned.\n///\n/// In particular, this method continues searching even after it enters\n/// a match state. The search only terminates once it has reached the\n/// end of the input or when it has entered a dead or quit state. Upon\n/// termination, the position of the last byte seen while still in a match\n/// state is returned.\n///\n/// # Errors\n///\n/// This routine errors if the search could not complete. This can occur\n/// in a number of circumstances:\n///\n/// * The configuration of the DFA may permit it to \"quit\" the search.\n/// For example, setting quit bytes or enabling heuristic support for\n/// Unicode word boundaries. The default configuration does not enable any\n/// option that could result in the DFA quitting.\n/// * When the provided `Input` configuration is not supported. For\n/// example, by providing an unsupported anchor mode.\n///\n/// When a search returns an error, callers cannot know whether a match\n/// exists or not.\n///\n/// # Notes for implementors\n///\n/// Implementors of this trait are not required to implement any particular\n/// match semantics (such as leftmost-first), which are instead manifest in\n/// the DFA's transitions. But this search routine should behave as a\n/// general \"leftmost\" search.\n///\n/// In particular, this method must continue searching even after it enters\n/// a match state. The search should only terminate once it has reached\n/// the end of the input or when it has entered a dead or quit state. Upon\n/// termination, the position of the last byte seen while still in a match\n/// state is returned.\n///\n/// Since this trait provides an implementation for this method by default,\n/// it's unlikely that one will need to implement this.\n///\n/// # Example\n///\n/// This example shows how to use this method with a\n/// [`dense::DFA`](crate::dfa::dense::DFA).\n///\n/// ```\n/// use regex_automata::{dfa::{Automaton, dense}, HalfMatch, Input};\n///\n/// let dfa = dense::DFA::new(\"foo[0-9]+\")?;\n/// let expected = Some(HalfMatch::must(0, 8));\n/// assert_eq!(expected, dfa.try_search_fwd(&Input::new(b\"foo12345\"))?);\n///\n/// // Even though a match is found after reading the first byte (`a`),\n/// // the leftmost first match semantics demand that we find the earliest\n/// // match that prefers earlier parts of the pattern over latter parts.\n/// let dfa = dense::DFA::new(\"abc|a\")?;\n/// let expected = Some(HalfMatch::must(0, 3));\n/// assert_eq!(expected, dfa.try_search_fwd(&Input::new(b\"abc\"))?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: specific pattern search\n///\n/// This example shows how to build a multi-DFA that permits searching for\n/// specific patterns.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     dfa::{Automaton, dense},\n///     Anchored, HalfMatch, PatternID, Input,\n/// };\n///\n/// let dfa = dense::Builder::new()\n///     .configure(dense::Config::new().starts_for_each_pattern(true))\n///     .build_many(&[\"[a-z0-9]{6}\", \"[a-z][a-z0-9]{5}\"])?;\n/// let haystack = \"foo123\".as_bytes();\n///\n/// // Since we are using the default leftmost-first match and both\n/// // patterns match at the same starting position, only the first pattern\n/// // will be returned in this case when doing a search for any of the\n/// // patterns.\n/// let expected = Some(HalfMatch::must(0, 6));\n/// let got = dfa.try_search_fwd(&Input::new(haystack))?;\n/// assert_eq!(expected, got);\n///\n/// // But if we want to check whether some other pattern matches, then we\n/// // can provide its pattern ID.\n/// let input = Input::new(haystack)\n///     .anchored(Anchored::Pattern(PatternID::must(1)));\n/// let expected = Some(HalfMatch::must(1, 6));\n/// let got = dfa.try_search_fwd(&input)?;\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: specifying the bounds of a search\n///\n/// This example shows how providing the bounds of a search can produce\n/// different results than simply sub-slicing the haystack.\n///\n/// ```\n/// use regex_automata::{dfa::{Automaton, dense}, HalfMatch, Input};\n///\n/// // N.B. We disable Unicode here so that we use a simple ASCII word\n/// // boundary. Alternatively, we could enable heuristic support for\n/// // Unicode word boundaries.\n/// let dfa = dense::DFA::new(r\"(?-u)\\b[0-9]{3}\\b\")?;\n/// let haystack = \"foo123bar\".as_bytes();\n///\n/// // Since we sub-slice the haystack, the search doesn't know about the\n/// // larger context and assumes that `123` is surrounded by word\n/// // boundaries. And of course, the match position is reported relative\n/// // to the sub-slice as well, which means we get `3` instead of `6`.\n/// let input = Input::new(&haystack[3..6]);\n/// let expected = Some(HalfMatch::must(0, 3));\n/// let got = dfa.try_search_fwd(&input)?;\n/// assert_eq!(expected, got);\n///\n/// // But if we provide the bounds of the search within the context of the\n/// // entire haystack, then the search can take the surrounding context\n/// // into account. (And if we did find a match, it would be reported\n/// // as a valid offset into `haystack` instead of its sub-slice.)\n/// let input = Input::new(haystack).range(3..6);\n/// let expected = None;\n/// let got = dfa.try_search_fwd(&input)?;\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1297 fn try_search_fwd(\n1298     &self,\n1299     input: &Input<'_>,\n1300 ) -> Result<Option<HalfMatch>, MatchError> {\n1301     let utf8empty = self.has_empty() && self.is_utf8();\n1302     let hm = match search::find_fwd(&self, input)? {\n1303         None => return Ok(None),\n1304         Some(hm) if !utf8empty => return Ok(Some(hm)),\n1305         Some(hm) => hm,\n1306     };\n1307     // We get to this point when we know our DFA can match the empty string\n1308     // AND when UTF-8 mode is enabled. In this case, we skip any matches\n1309     // whose offset splits a codepoint. Such a match is necessarily a\n1310     // zero-width match, because UTF-8 mode requires the underlying NFA\n1311     // to be built such that all non-empty matches span valid UTF-8.\n1312     // Therefore, any match that ends in the middle of a codepoint cannot\n1313     // be part of a span of valid UTF-8 and thus must be an empty match.\n1314     // In such cases, we skip it, so as not to report matches that split a\n1315     // codepoint.\n1316     //\n1317     // Note that this is not a checked assumption. Callers *can* provide an\n1318     // NFA with UTF-8 mode enabled but produces non-empty matches that span\n1319     // invalid UTF-8. But doing so is documented to result in unspecified\n1320     // behavior.\n1321     empty::skip_splits_fwd(input, hm, hm.offset(), |input| {\n1322         let got = search::find_fwd(&self, input)?;\n1323         Ok(got.map(|hm| (hm, hm.offset())))\n1324     })\n1325 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}