{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/alphabet.rs\n// crate name is regex_automata\nuse crate::util::{escape::DebugByte, wire::{self, DeserializeError, SerializeError}};\n#[cfg(feature = \"alloc\")]\n#[derive(Clone, Debug)]\npub(crate) struct ByteClassSet(ByteSet);\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]\npub(crate) struct ByteSet {\n    bits: BitSet,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[cfg(feature = \"alloc\")]\nimpl ByteClassSet {\n    pub(crate) fn empty() -> Self {\n        ByteClassSet(ByteSet::empty())\n    }\n    pub(crate) fn set_range(&mut self, start: u8, end: u8) {}\n    pub(crate) fn add_set(&mut self, set: &ByteSet) {}\n    pub(crate) fn byte_classes(&self) -> ByteClasses {\n        let mut classes = ByteClasses::empty();\n        let mut class = 0u8;\n        let mut b = 0u8;\n        loop {\n            classes.set(b, class);\n            if b == 255 {\n                break;\n            }\n            if self.0.contains(b) {\n                class = class.checked_add(1).unwrap();\n            }\n            b = b.checked_add(1).unwrap();\n        }\n        classes\n    }\n}\nimpl ByteSet {\n    pub(crate) fn empty() -> ByteSet {}\n    pub(crate) fn add(&mut self, byte: u8) {}\n    pub(crate) fn remove(&mut self, byte: u8) {}\n    pub(crate) fn contains(&self, byte: u8) -> bool {\n        let bucket = byte / 128;\n        let bit = byte % 128;\n        self.bits.0[usize::from(bucket)] & (1 << bit) > 0\n    }\n    pub(crate) fn contains_range(&self, start: u8, end: u8) -> bool {}\n    pub(crate) fn iter(&self) -> ByteSetIter {}\n    pub(crate) fn iter_ranges(&self) -> ByteSetRangeIter {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_empty(&self) -> bool {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteSet, usize), DeserializeError> {}\n    pub(crate) fn write_to<E: crate::util::wire::Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n}\nimpl ByteClasses {\n    #[inline]\n    pub fn empty() -> ByteClasses {\n        ByteClasses([0; 256])\n    }\n    #[inline]\n    pub fn singletons() -> ByteClasses {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteClasses, usize), DeserializeError> {}\n    pub(crate) fn write_to(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[inline]\n    pub fn set(&mut self, byte: u8, class: u8) {\n        self.0[usize::from(byte)] = class;\n    }\n    #[inline]\n    pub fn get(&self, byte: u8) -> u8 {}\n    #[inline]\n    pub fn get_by_unit(&self, unit: Unit) -> usize {}\n    #[inline]\n    pub fn eoi(&self) -> Unit {}\n    #[inline]\n    pub fn alphabet_len(&self) -> usize {}\n    #[inline]\n    pub fn stride2(&self) -> usize {}\n    #[inline]\n    pub fn is_singleton(&self) -> bool {}\n    #[inline]\n    pub fn iter(&self) -> ByteClassIter<'_> {}\n    pub fn representatives<R: core::ops::RangeBounds<u8>>(\n        &self,\n        range: R,\n    ) -> ByteClassRepresentatives<'_> {}\n    #[inline]\n    pub fn elements(&self, class: Unit) -> ByteClassElements {}\n    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Convert this boolean set to a map that maps all byte values to their\n/// corresponding equivalence class. The last mapping indicates the largest\n/// equivalence class identifier (which is never bigger than 255).\n722 pub(crate) fn byte_classes(&self) -> ByteClasses {\n723     let mut classes = ByteClasses::empty();\n724     let mut class = 0u8;\n725     let mut b = 0u8;\n726     loop {\n727         classes.set(b, class);\n728         if b == 255 {\n729             break;\n730         }\n731         if self.0.contains(b) {\n732             class = class.checked_add(1).unwrap();\n733         }\n734         b = b.checked_add(1).unwrap();\n735     }\n736     classes\n737 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}