{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseSuffix {\n    core: Core,\n    pre: Prefilter,\n}\n#[derive(Debug)]\npub(crate) struct Hybrid(Option<HybridEngine>);\n#[derive(Debug)]\npub(crate) struct DFA(Option<DFAEngine>);\n#[derive(Debug)]\npub(crate) struct DFAEngine(\n    #[cfg(feature = \"dfa-build\")]\n    dfa::regex::Regex,\n    #[cfg(not(feature = \"dfa-build\"))]\n    (),\n);\n#[derive(Debug)]\npub(crate) struct HybridEngine(\n    #[cfg(feature = \"hybrid\")]\n    hybrid::regex::Regex,\n    #[cfg(not(feature = \"hybrid\"))]\n    (),\n);\n#[derive(Clone, Debug)]\npub(crate) struct HybridCache(\n    #[cfg(feature = \"hybrid\")]\n    Option<hybrid::regex::Cache>,\n    #[cfg(not(feature = \"hybrid\"))]\n    (),\n);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Debug)]\npub(crate) enum RetryError {\n    Quadratic(RetryQuadraticError),\n    Fail(RetryFailError),\n}\nimpl ReverseSuffix {\n    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_start(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_fwd(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_rev_limited(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        if let Some(e) = self.core.dfa.get(&input) {\n            trace!(\n                \"using full DFA for reverse suffix search at {:?}, \\\n                 but will be stopped at {} to avoid quadratic behavior\",\n                input.get_span(), min_start,\n            );\n            e.try_search_half_rev_limited(&input, min_start)\n        } else if let Some(e) = self.core.hybrid.get(&input) {\n            trace!(\n                \"using lazy DFA for reverse suffix search at {:?}, \\\n                 but will be stopped at {} to avoid quadratic behavior\",\n                input.get_span(), min_start,\n            );\n            e.try_search_half_rev_limited(&mut cache.hybrid, &input, min_start)\n        } else {\n            unreachable!(\"ReverseSuffix always has a DFA\")\n        }\n    }\n}\nimpl Hybrid {\n    pub(crate) fn none() -> Hybrid {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Hybrid {}\n    pub(crate) fn create_cache(&self) -> HybridCache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&HybridEngine> {\n        let engine = self.0.as_ref()?;\n        Some(engine)\n    }\n    pub(crate) fn is_some(&self) -> bool {}\n}\nimpl DFA {\n    pub(crate) fn none() -> DFA {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> DFA {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&DFAEngine> {\n        let engine = self.0.as_ref()?;\n        Some(engine)\n    }\n    pub(crate) fn is_some(&self) -> bool {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl DFAEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Option<DFAEngine> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd_stopat(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev(\n        &self,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev_limited(\n        &self,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        #[cfg(feature = \"dfa-build\")]\n        {\n            let dfa = self.0.reverse();\n            crate::meta::limited::dfa_try_search_half_rev(dfa, input, min_start)\n        }\n        #[cfg(not(feature = \"dfa-build\"))] { unreachable!() }\n    }\n    #[inline]\n    pub(crate) fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), RetryFailError> {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl HybridEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Option<HybridEngine> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd_stopat(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev_limited(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        #[cfg(feature = \"hybrid\")]\n        {\n            let dfa = self.0.reverse();\n            let mut cache = cache.0.as_mut().unwrap().as_parts_mut().1;\n            crate::meta::limited::hybrid_try_search_half_rev(\n                dfa,\n                &mut cache,\n                input,\n                min_start,\n            )\n        }\n        #[cfg(not(feature = \"hybrid\"))] { unreachable!() }\n    }\n    #[inline]\n    pub(crate) fn try_which_overlapping_matches(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), RetryFailError> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1268 fn try_search_half_rev_limited(\n1269     &self,\n1270     cache: &mut Cache,\n1271     input: &Input<'_>,\n1272     min_start: usize,\n1273 ) -> Result<Option<HalfMatch>, RetryError> {\n1274     if let Some(e) = self.core.dfa.get(&input) {\n1275         trace!(\n1276             \"using full DFA for reverse suffix search at {:?}, \\\n1277              but will be stopped at {} to avoid quadratic behavior\",\n1278             input.get_span(),\n1279             min_start,\n1280         );\n1281         e.try_search_half_rev_limited(&input, min_start)\n1282     } else if let Some(e) = self.core.hybrid.get(&input) {\n1283         trace!(\n1284             \"using lazy DFA for reverse suffix search at {:?}, \\\n1285              but will be stopped at {} to avoid quadratic behavior\",\n1286             input.get_span(),\n1287             min_start,\n1288         );\n1289         e.try_search_half_rev_limited(&mut cache.hybrid, &input, min_start)\n1290     } else {\n1291         unreachable!(\"ReverseSuffix always has a DFA\")\n1292     }\n1293 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}