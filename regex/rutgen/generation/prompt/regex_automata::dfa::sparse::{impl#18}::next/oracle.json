{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\nimpl<'a> State<'a> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next(&self, input: u8) -> StateID {\n        for i in 0..(self.ntrans - 1) {\n            let (start, end) = self.range(i);\n            if start <= input && input <= end {\n                return self.next_at(i);\n            }\n        }\n        DEAD\n    }\n    fn next_eoi(&self) -> StateID {}\n    fn id(&self) -> StateID {}\n    fn range(&self, i: usize) -> (u8, u8) {\n        (self.input_ranges[i * 2], self.input_ranges[i * 2 + 1])\n    }\n    fn next_at(&self, i: usize) -> StateID {\n        let start = i * StateID::SIZE;\n        let end = start + StateID::SIZE;\n        let bytes = self.next[start..end].try_into().unwrap();\n        StateID::from_ne_bytes_unchecked(bytes)\n    }\n    fn pattern_id(&self, match_index: usize) -> PatternID {}\n    fn pattern_len(&self) -> usize {}\n    fn accelerator(&self) -> &'a [u8] {}\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Searches for the next transition given an input byte. If no such\n/// transition could be found, then a dead state is returned.\n///\n/// This is marked as inline to help dramatically boost sparse searching,\n/// which decodes each state it enters to follow the next transition.\n2275 fn next(&self, input: u8) -> StateID {\n2276     // This straight linear search was observed to be much better than\n2277     // binary search on ASCII haystacks, likely because a binary search\n2278     // visits the ASCII case last but a linear search sees it first. A\n2279     // binary search does do a little better on non-ASCII haystacks, but\n2280     // not by much. There might be a better trade off lurking here.\n2281     for i in 0..(self.ntrans - 1) {\n2282         let (start, end) = self.range(i);\n2283         if start <= input && input <= end {\n2284             return self.next_at(i);\n2285         }\n2286         // We could bail early with an extra branch: if input < b1, then\n2287         // we know we'll never find a matching transition. Interestingly,\n2288         // this extra branch seems to not help performance, or will even\n2289         // hurt it. It's likely very dependent on the DFA itself and what\n2290         // is being searched.\n2291     }\n2292     DEAD\n2293 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}