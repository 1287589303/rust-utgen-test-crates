{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/builder.rs\n// crate name is regex_automata\nuse core::mem;\nuse alloc::{sync::Arc, vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{error::BuildError, nfa::{self, SparseTransitions, Transition, NFA}},\n    util::{\n        look::{Look, LookMatcher},\n        primitives::{IteratorIndexExt, PatternID, SmallIndex, StateID},\n    },\n};\n#[derive(Clone, Debug, Default)]\npub struct Builder {\n    /// The ID of the pattern that we're currently building.\n    ///\n    /// Callers are required to set (and unset) this by calling\n    /// {start,finish}_pattern. Otherwise, most methods will panic.\n    pattern_id: Option<PatternID>,\n    /// A sequence of intermediate NFA states. Once a state is added to this\n    /// sequence, it is assigned a state ID equivalent to its index. Once a\n    /// state is added, it is still expected to be mutated, e.g., to set its\n    /// transition to a state that didn't exist at the time it was added.\n    states: Vec<State>,\n    /// The starting states for each individual pattern. Starting at any\n    /// of these states will result in only an anchored search for the\n    /// corresponding pattern. The vec is indexed by pattern ID. When the NFA\n    /// contains a single regex, then `start_pattern[0]` and `start_anchored`\n    /// are always equivalent.\n    start_pattern: Vec<StateID>,\n    /// A map from pattern ID to capture group index to name. (If no name\n    /// exists, then a None entry is present. Thus, all capturing groups are\n    /// present in this mapping.)\n    ///\n    /// The outer vec is indexed by pattern ID, while the inner vec is indexed\n    /// by capture index offset for the corresponding pattern.\n    ///\n    /// The first capture group for each pattern is always unnamed and is thus\n    /// always None.\n    captures: Vec<Vec<Option<Arc<str>>>>,\n    /// The combined memory used by each of the 'State's in 'states'. This\n    /// only includes heap usage by each state, and not the size of the state\n    /// itself. In other words, this tracks heap memory used that isn't\n    /// captured via `size_of::<State>() * states.len()`.\n    memory_states: usize,\n    /// Whether this NFA only matches UTF-8 and whether regex engines using\n    /// this NFA for searching should report empty matches that split a\n    /// codepoint.\n    utf8: bool,\n    /// Whether this NFA should be matched in reverse or not.\n    reverse: bool,\n    /// The matcher to use for look-around assertions.\n    look_matcher: LookMatcher,\n    /// A size limit to respect when building an NFA. If the total heap memory\n    /// of the intermediate NFA states exceeds (or would exceed) this amount,\n    /// then an error is returned.\n    size_limit: Option<usize>,\n}\n#[derive(Clone, Default)]\nstruct State {\n    transitions: Vec<Transition>,\n    chunks: Vec<(usize, usize)>,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub(crate) struct State(Arc<[u8]>);\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone)]\nstruct State {\n    /// A sorted sequence of non-overlapping transitions to other states. Each\n    /// transition corresponds to a single range of bytes.\n    transitions: Vec<Transition>,\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum State {\n    /// An empty state whose only purpose is to forward the automaton to\n    /// another state via an unconditional epsilon transition.\n    ///\n    /// Unconditional epsilon transitions are quite useful during the\n    /// construction of an NFA, as they permit the insertion of no-op\n    /// placeholders that make it easier to compose NFA sub-graphs. When\n    /// the Thompson NFA builder produces a final NFA, all unconditional\n    /// epsilon transitions are removed, and state identifiers are remapped\n    /// accordingly.\n    Empty {\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// A state that only transitions to another state if the current input\n    /// byte is in a particular range of bytes.\n    ByteRange { trans: Transition },\n    /// A state with possibly many transitions, represented in a sparse\n    /// fashion. Transitions must be ordered lexicographically by input range\n    /// and be non-overlapping. As such, this may only be used when every\n    /// transition has equal priority. (In practice, this is only used for\n    /// encoding large UTF-8 automata.) In contrast, a `Union` state has each\n    /// alternate in order of priority. Priority is used to implement greedy\n    /// matching and also alternations themselves, e.g., `abc|a` where `abc`\n    /// has priority over `a`.\n    ///\n    /// To clarify, it is possible to remove `Sparse` and represent all things\n    /// that `Sparse` is used for via `Union`. But this creates a more bloated\n    /// NFA with more epsilon transitions than is necessary in the special case\n    /// of character classes.\n    Sparse { transitions: Vec<Transition> },\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around.\n    Look { look: Look, next: StateID },\n    /// An empty state that records the start of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureStart {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An empty state that records the end of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureEnd {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union { alternates: Vec<StateID> },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via later transitions are\n    /// preferred over earlier transitions.\n    ///\n    /// This \"reverse\" state exists for convenience during compilation that\n    /// permits easy construction of non-greedy combinations of NFA states. At\n    /// the end of compilation, Union and UnionReverse states are merged into\n    /// one Union type of state, where the latter has its epsilon transitions\n    /// reversed to reflect the priority inversion.\n    ///\n    /// The \"convenience\" here arises from the fact that as new states are\n    /// added to the list of `alternates`, we would like that add operation\n    /// to be amortized constant time. But if we used a `Union`, we'd need to\n    /// prepend the state, which takes O(n) time. There are other approaches we\n    /// could use to solve this, but this seems simple enough.\n    UnionReverse { alternates: Vec<StateID> },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose a\n    /// `Fail` state to represent it.\n    Fail,\n    /// A match state. There is at most one such occurrence of this state in\n    /// an NFA for each pattern compiled into the NFA. At time of writing, a\n    /// match state is always produced for every pattern given, but in theory,\n    /// if a pattern can never lead to a match, then the match state could be\n    /// omitted.\n    ///\n    /// `pattern_id` refers to the ID of the pattern itself, which corresponds\n    /// to the pattern's index (starting at 0).\n    Match { pattern_id: PatternID },\n}\nimpl Builder {\n    pub fn new() -> Builder {}\n    pub fn clear(&mut self) {}\n    pub fn build(\n        &self,\n        start_anchored: StateID,\n        start_unanchored: StateID,\n    ) -> Result<NFA, BuildError> {}\n    pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {}\n    pub fn finish_pattern(\n        &mut self,\n        start_id: StateID,\n    ) -> Result<PatternID, BuildError> {}\n    pub fn current_pattern_id(&self) -> PatternID {}\n    pub fn pattern_len(&self) -> usize {}\n    pub fn add_empty(&mut self) -> Result<StateID, BuildError> {}\n    pub fn add_union(\n        &mut self,\n        alternates: Vec<StateID>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_union_reverse(\n        &mut self,\n        alternates: Vec<StateID>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_range(&mut self, trans: Transition) -> Result<StateID, BuildError> {}\n    pub fn add_sparse(\n        &mut self,\n        transitions: Vec<Transition>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_look(\n        &mut self,\n        next: StateID,\n        look: Look,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_capture_start(\n        &mut self,\n        next: StateID,\n        group_index: u32,\n        name: Option<Arc<str>>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_capture_end(\n        &mut self,\n        next: StateID,\n        group_index: u32,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_fail(&mut self) -> Result<StateID, BuildError> {}\n    pub fn add_match(&mut self) -> Result<StateID, BuildError> {}\n    fn add(&mut self, state: State) -> Result<StateID, BuildError> {}\n    pub fn patch(&mut self, from: StateID, to: StateID) -> Result<(), BuildError> {}\n    pub fn set_utf8(&mut self, yes: bool) {}\n    pub fn get_utf8(&self) -> bool {}\n    pub fn set_reverse(&mut self, yes: bool) {}\n    pub fn get_reverse(&self) -> bool {}\n    pub fn set_look_matcher(&mut self, m: LookMatcher) {\n        self.look_matcher = m;\n    }\n    pub fn get_look_matcher(&self) -> &LookMatcher {}\n    pub fn set_size_limit(&mut self, limit: Option<usize>) -> Result<(), BuildError> {}\n    pub fn get_size_limit(&self) -> Option<usize> {}\n    pub fn memory_usage(&self) -> usize {}\n    fn check_size_limit(&self) -> Result<(), BuildError> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Sets the look-around matcher that should be used for the resulting NFA.\n///\n/// A look-around matcher can be used to configure how look-around\n/// assertions are matched. For example, a matcher might carry\n/// configuration that changes the line terminator used for `(?m:^)` and\n/// `(?m:$)` assertions.\n1257 pub fn set_look_matcher(&mut self, m: LookMatcher) {\n1258     self.look_matcher = m;\n1259 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}