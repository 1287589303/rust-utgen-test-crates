{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Clone, Debug)]\nstruct Pre<P> {\n    pre: P,\n    group_info: GroupInfo,\n}\n#[derive(Clone, Debug)]\npub(crate) struct RegexInfo(Arc<RegexInfoI>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Memmem {\n    #[cfg(not(all(feature = \"std\", feature = \"perf-literal-substring\")))]\n    _unused: (),\n    #[cfg(all(feature = \"std\", feature = \"perf-literal-substring\"))]\n    finder: memchr::memmem::Finder<'static>,\n}\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[derive(Clone, Debug)]\npub(crate) struct Memchr2(u8, u8);\n#[derive(Clone, Debug)]\npub(crate) struct Teddy {\n    #[cfg(not(feature = \"perf-literal-multisubstring\"))]\n    _unused: (),\n    /// The actual Teddy searcher.\n    ///\n    /// Technically, it's possible that Teddy doesn't actually get used, since\n    /// Teddy does require its haystack to at least be of a certain size\n    /// (usually around the size of whatever vector is being used, so ~16\n    /// or ~32 bytes). For haystacks shorter than that, the implementation\n    /// currently uses Rabin-Karp.\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    searcher: aho_corasick::packed::Searcher,\n    /// When running an anchored search, the packed searcher can't handle it so\n    /// we defer to Aho-Corasick itself. Kind of sad, but changing the packed\n    /// searchers to support anchored search would be difficult at worst and\n    /// annoying at best. Since packed searchers only apply to small numbers of\n    /// literals, we content ourselves that this is not much of an added cost.\n    /// (That packed searchers only work with a small number of literals is\n    /// also why we use a DFA here. Otherwise, the memory usage of a DFA would\n    /// likely be unacceptable.)\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    anchored_ac: aho_corasick::dfa::DFA,\n    /// The length of the smallest literal we look for.\n    ///\n    /// We use this as a heuristic to figure out whether this will be \"fast\" or\n    /// not. Generally, the longer the better, because longer needles are more\n    /// discriminating and thus reduce false positive rate.\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    minimum_len: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Memchr(u8);\n#[derive(Clone, Debug)]\npub(crate) struct Memchr3(u8, u8, u8);\n#[derive(Clone, Debug)]\npub(crate) struct AhoCorasick {\n    #[cfg(not(feature = \"perf-literal-multisubstring\"))]\n    _unused: (),\n    #[cfg(feature = \"perf-literal-multisubstring\")]\n    ac: aho_corasick::AhoCorasick,\n}\n#[derive(Clone, Debug)]\npub(crate) enum Choice {\n    Memchr(Memchr),\n    Memchr2(Memchr2),\n    Memchr3(Memchr3),\n    Memmem(Memmem),\n    Teddy(Teddy),\n    ByteSet(ByteSet),\n    AhoCorasick(AhoCorasick),\n}\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\nimpl Pre<()> {\n    fn from_prefixes(\n        info: &RegexInfo,\n        prefixes: &literal::Seq,\n    ) -> Option<Arc<dyn Strategy>> {\n        let kind = info.config().get_match_kind();\n        if !prefixes.is_exact() {\n            return None;\n        }\n        if info.pattern_len() != 1 {\n            return None;\n        }\n        if info.props()[0].explicit_captures_len() != 0 {\n            return None;\n        }\n        if !info.props()[0].look_set().is_empty() {\n            return None;\n        }\n        if kind != MatchKind::LeftmostFirst {\n            return None;\n        }\n        let prefixes = prefixes.literals().unwrap();\n        debug!(\n            \"trying to bypass regex engine by creating \\\n             prefilter from {} literals: {:?}\",\n            prefixes.len(), prefixes,\n        );\n        let choice = match prefilter::Choice::new(kind, prefixes) {\n            Some(choice) => choice,\n            None => {\n                debug!(\"regex bypass failed because no prefilter could be built\");\n                return None;\n            }\n        };\n        let strat: Arc<dyn Strategy> = match choice {\n            prefilter::Choice::Memchr(pre) => Pre::new(pre),\n            prefilter::Choice::Memchr2(pre) => Pre::new(pre),\n            prefilter::Choice::Memchr3(pre) => Pre::new(pre),\n            prefilter::Choice::Memmem(pre) => Pre::new(pre),\n            prefilter::Choice::Teddy(pre) => Pre::new(pre),\n            prefilter::Choice::ByteSet(pre) => Pre::new(pre),\n            prefilter::Choice::AhoCorasick(pre) => Pre::new(pre),\n        };\n        Some(strat)\n    }\n    fn from_alternation_literals(\n        info: &RegexInfo,\n        hirs: &[&Hir],\n    ) -> Option<Arc<dyn Strategy>> {}\n}\nimpl Choice {\n    pub(crate) fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Choice> {\n        if needles.len() == 0 {\n            debug!(\"prefilter building failed: found empty set of literals\");\n            return None;\n        }\n        if needles.iter().any(|n| n.as_ref().is_empty()) {\n            debug!(\"prefilter building failed: literals match empty string\");\n            return None;\n        }\n        if let Some(pre) = Memchr::new(kind, needles) {\n            debug!(\"prefilter built: memchr\");\n            return Some(Choice::Memchr(pre));\n        }\n        if let Some(pre) = Memchr2::new(kind, needles) {\n            debug!(\"prefilter built: memchr2\");\n            return Some(Choice::Memchr2(pre));\n        }\n        if let Some(pre) = Memchr3::new(kind, needles) {\n            debug!(\"prefilter built: memchr3\");\n            return Some(Choice::Memchr3(pre));\n        }\n        if let Some(pre) = Memmem::new(kind, needles) {\n            debug!(\"prefilter built: memmem\");\n            return Some(Choice::Memmem(pre));\n        }\n        if let Some(pre) = Teddy::new(kind, needles) {\n            debug!(\"prefilter built: teddy\");\n            return Some(Choice::Teddy(pre));\n        }\n        if let Some(pre) = ByteSet::new(kind, needles) {\n            debug!(\"prefilter built: byteset\");\n            return Some(Choice::ByteSet(pre));\n        }\n        if let Some(pre) = AhoCorasick::new(kind, needles) {\n            debug!(\"prefilter built: aho-corasick\");\n            return Some(Choice::AhoCorasick(pre));\n        }\n        debug!(\"prefilter building failed: no strategy could be found\");\n        None\n    }\n}\nimpl<P: PrefilterI> Pre<P> {\n    fn new(pre: P) -> Arc<dyn Strategy> {\n        let group_info = GroupInfo::new([[None::<&str>]]).unwrap();\n        Arc::new(Pre { pre, group_info })\n    }\n}\nimpl RegexInfo {\n    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {}\n    pub(crate) fn config(&self) -> &Config {\n        &self.0.config\n    }\n    pub(crate) fn props(&self) -> &[hir::Properties] {\n        &self.0.props\n    }\n    pub(crate) fn props_union(&self) -> &hir::Properties {}\n    pub(crate) fn pattern_len(&self) -> usize {\n        self.props().len()\n    }\n    pub(crate) fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_anchored_start(&self, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_start(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_end(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_impossible(&self, input: &Input<'_>) -> bool {}\n}\nimpl Config {\n    pub fn new() -> Config {}\n    pub fn match_kind(self, kind: MatchKind) -> Config {}\n    pub fn utf8_empty(self, yes: bool) -> Config {}\n    pub fn auto_prefilter(self, yes: bool) -> Config {}\n    pub fn prefilter(self, pre: Option<Prefilter>) -> Config {}\n    pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {}\n    pub fn nfa_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn onepass_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn hybrid_cache_capacity(self, limit: usize) -> Config {}\n    pub fn dfa_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn dfa_state_limit(self, limit: Option<usize>) -> Config {}\n    pub fn byte_classes(self, yes: bool) -> Config {}\n    pub fn line_terminator(self, byte: u8) -> Config {}\n    pub fn hybrid(self, yes: bool) -> Config {}\n    pub fn dfa(self, yes: bool) -> Config {}\n    pub fn onepass(self, yes: bool) -> Config {}\n    pub fn backtrack(self, yes: bool) -> Config {}\n    pub fn get_match_kind(&self) -> MatchKind {\n        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)\n    }\n    pub fn get_utf8_empty(&self) -> bool {}\n    pub fn get_auto_prefilter(&self) -> bool {}\n    pub fn get_prefilter(&self) -> Option<&Prefilter> {}\n    pub fn get_which_captures(&self) -> WhichCaptures {}\n    pub fn get_nfa_size_limit(&self) -> Option<usize> {}\n    pub fn get_onepass_size_limit(&self) -> Option<usize> {}\n    pub fn get_hybrid_cache_capacity(&self) -> usize {}\n    pub fn get_dfa_size_limit(&self) -> Option<usize> {}\n    pub fn get_dfa_state_limit(&self) -> Option<usize> {}\n    pub fn get_byte_classes(&self) -> bool {}\n    pub fn get_line_terminator(&self) -> u8 {}\n    pub fn get_hybrid(&self) -> bool {}\n    pub fn get_dfa(&self) -> bool {}\n    pub fn get_onepass(&self) -> bool {}\n    pub fn get_backtrack(&self) -> bool {}\n    pub(crate) fn overwrite(&self, o: Config) -> Config {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Given a sequence of prefixes, attempt to return a full `Strategy` using\n/// just the prefixes.\n///\n/// Basically, this occurs when the prefixes given not just prefixes,\n/// but an enumeration of the entire language matched by the regular\n/// expression.\n///\n/// A number of other conditions need to be true too. For example, there\n/// can be only one pattern, the number of explicit capture groups is 0, no\n/// look-around assertions and so on.\n///\n/// Note that this ignores `Config::get_auto_prefilter` because if this\n/// returns something, then it isn't a prefilter but a matcher itself.\n/// Therefore, it shouldn't suffer from the problems typical to prefilters\n/// (such as a high false positive rate).\n224 fn from_prefixes(\n225     info: &RegexInfo,\n226     prefixes: &literal::Seq,\n227 ) -> Option<Arc<dyn Strategy>> {\n228     let kind = info.config().get_match_kind();\n229     // Check to see if our prefixes are exact, which means we might be\n230     // able to bypass the regex engine entirely and just rely on literal\n231     // searches.\n232     if !prefixes.is_exact() {\n233         return None;\n234     }\n235     // We also require that we have a single regex pattern. Namely,\n236     // we reuse the prefilter infrastructure to implement search and\n237     // prefilters only report spans. Prefilters don't know about pattern\n238     // IDs. The multi-regex case isn't a lost cause, we might still use\n239     // Aho-Corasick and we might still just use a regular prefilter, but\n240     // that's done below.\n241     if info.pattern_len() != 1 {\n242         return None;\n243     }\n244     // We can't have any capture groups either. The literal engines don't\n245     // know how to deal with things like '(foo)(bar)'. In that case, a\n246     // prefilter will just be used and then the regex engine will resolve\n247     // the capture groups.\n248     if info.props()[0].explicit_captures_len() != 0 {\n249         return None;\n250     }\n251     // We also require that it has zero look-around assertions. Namely,\n252     // literal extraction treats look-around assertions as if they match\n253     // *every* empty string. But of course, that isn't true. So for\n254     // example, 'foo\\bquux' never matches anything, but 'fooquux' is\n255     // extracted from that as an exact literal. Such cases should just run\n256     // the regex engine. 'fooquux' will be used as a normal prefilter, and\n257     // then the regex engine will try to look for an actual match.\n258     if !info.props()[0].look_set().is_empty() {\n259         return None;\n260     }\n261     // Finally, currently, our prefilters are all oriented around\n262     // leftmost-first match semantics, so don't try to use them if the\n263     // caller asked for anything else.\n264     if kind != MatchKind::LeftmostFirst {\n265         return None;\n266     }\n267     // The above seems like a lot of requirements to meet, but it applies\n268     // to a lot of cases. 'foo', '[abc][123]' and 'foo|bar|quux' all meet\n269     // the above criteria, for example.\n270     //\n271     // Note that this is effectively a latency optimization. If we didn't\n272     // do this, then the extracted literals would still get bundled into\n273     // a prefilter, and every regex engine capable of running unanchored\n274     // searches supports prefilters. So this optimization merely sidesteps\n275     // having to run the regex engine at all to confirm the match. Thus, it\n276     // decreases the latency of a match.\n277 \n278     // OK because we know the set is exact and thus finite.\n279     let prefixes = prefixes.literals().unwrap();\n280     debug!(\n281         \"trying to bypass regex engine by creating \\\n282          prefilter from {} literals: {:?}\",\n283         prefixes.len(),\n284         prefixes,\n285     );\n286     let choice = match prefilter::Choice::new(kind, prefixes) {\n287         Some(choice) => choice,\n288         None => {\n289             debug!(\n290                 \"regex bypass failed because no prefilter could be built\"\n291             );\n292             return None;\n293         }\n294     };\n295     let strat: Arc<dyn Strategy> = match choice {\n296         prefilter::Choice::Memchr(pre) => Pre::new(pre),\n297         prefilter::Choice::Memchr2(pre) => Pre::new(pre),\n298         prefilter::Choice::Memchr3(pre) => Pre::new(pre),\n299         prefilter::Choice::Memmem(pre) => Pre::new(pre),\n300         prefilter::Choice::Teddy(pre) => Pre::new(pre),\n301         prefilter::Choice::ByteSet(pre) => Pre::new(pre),\n302         prefilter::Choice::AhoCorasick(pre) => Pre::new(pre),\n303     };\n304     Some(strat)\n305 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}