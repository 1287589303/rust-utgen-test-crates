{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/hybrid/dfa.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype StateMap = std::collections::HashMap<State, LazyStateID>;\n#[cfg(not(feature = \"std\"))]\ntype StateMap = alloc::collections::BTreeMap<State, LazyStateID>;\nuse core::{iter, mem::size_of};\nuse alloc::vec::Vec;\nuse crate::{\n    hybrid::{\n        error::{BuildError, CacheError, StartError},\n        id::{LazyStateID, LazyStateIDError},\n        search,\n    },\n    nfa::thompson,\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        determinize::{self, State, StateBuilderEmpty, StateBuilderNFA},\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID as NFAStateID},\n        search::{Anchored, HalfMatch, Input, MatchError, MatchKind, PatternSet},\n        sparse_set::SparseSets, start::{self, Start, StartByteMap},\n    },\n};\nconst MIN_STATES: usize = SENTINEL_STATES + 2;\nconst SENTINEL_STATES: usize = 3;\n#[derive(Clone, Debug)]\npub struct DFA {\n    config: Config,\n    nfa: thompson::NFA,\n    stride2: usize,\n    start_map: StartByteMap,\n    classes: ByteClasses,\n    quitset: ByteSet,\n    cache_capacity: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct OverlappingState {\n    /// The match reported by the most recent overlapping search to use this\n    /// state.\n    ///\n    /// If a search does not find any matches, then it is expected to clear\n    /// this value.\n    pub(crate) mat: Option<HalfMatch>,\n    /// The state ID of the state at which the search was in when the call\n    /// terminated. When this is a match state, `last_match` must be set to a\n    /// non-None value.\n    ///\n    /// A `None` value indicates the start state of the corresponding\n    /// automaton. We cannot use the actual ID, since any one automaton may\n    /// have many start states, and which one is in use depends on several\n    /// search-time factors.\n    pub(crate) id: Option<LazyStateID>,\n    /// The position of the search.\n    ///\n    /// When `id` is None (i.e., we are starting a search), this is set to\n    /// the beginning of the search as given by the caller regardless of its\n    /// current value. Subsequent calls to an overlapping search pick up at\n    /// this offset.\n    pub(crate) at: usize,\n    /// The index into the matching patterns of the next match to report if the\n    /// current state is a match state. Note that this may be 1 greater than\n    /// the total number of matches to report for the current match state. (In\n    /// which case, no more matches should be reported at the current position\n    /// and the search should advance to the next position.)\n    pub(crate) next_match_index: Option<usize>,\n    /// This is set to true when a reverse overlapping search has entered its\n    /// EOI transitions.\n    ///\n    /// This isn't used in a forward search because it knows to stop once the\n    /// position exceeds the end of the search range. In a reverse search,\n    /// since we use unsigned offsets, we don't \"know\" once we've gone past\n    /// `0`. So the only way to detect it is with this extra flag. The reverse\n    /// overlapping search knows to terminate specifically after it has\n    /// reported all matches after following the EOI transition.\n    pub(crate) rev_eoi: bool,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[cfg(feature = \"alloc\")]\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct PatternSet {\n    /// The number of patterns set to 'true' in this set.\n    len: usize,\n    /// A map from PatternID to boolean of whether a pattern matches or not.\n    ///\n    /// This should probably be a bitset, but it's probably unlikely to matter\n    /// much in practice.\n    ///\n    /// The main downside of this representation (and similarly for a bitset)\n    /// is that iteration scales with the capacity of the set instead of\n    /// the length of the set. This doesn't seem likely to be a problem in\n    /// practice.\n    ///\n    /// Another alternative is to just use a 'SparseSet' for this. It does use\n    /// more memory (quite a bit more), but that seems fine I think compared\n    /// to the memory being used by the regex engine. The real hiccup with\n    /// it is that it yields pattern IDs in the order they were inserted.\n    /// Which is actually kind of nice, but at the time of writing, pattern\n    /// IDs are yielded in ascending order in the regex crate RegexSet API.\n    /// If we did change to 'SparseSet', we could provide an additional\n    /// 'iter_match_order' iterator, but keep the ascending order one for\n    /// compatibility.\n    which: alloc::boxed::Box<[bool]>,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// The transition table.\n    ///\n    /// Given a `current` LazyStateID and an `input` byte, the next state can\n    /// be computed via `trans[untagged(current) + equiv_class(input)]`. Notice\n    /// that no multiplication is used. That's because state identifiers are\n    /// \"premultiplied.\"\n    ///\n    /// Note that the next state may be the \"unknown\" state. In this case, the\n    /// next state is not known and determinization for `current` on `input`\n    /// must be performed.\n    trans: Vec<LazyStateID>,\n    /// The starting states for this DFA.\n    ///\n    /// These are computed lazily. Initially, these are all set to \"unknown\"\n    /// lazy state IDs.\n    ///\n    /// When 'starts_for_each_pattern' is disabled (the default), then the size\n    /// of this is constrained to the possible starting configurations based\n    /// on the search parameters. (At time of writing, that's 4.) However,\n    /// when starting states for each pattern is enabled, then there are N\n    /// additional groups of starting states, where each group reflects the\n    /// different possible configurations and N is the number of patterns.\n    starts: Vec<LazyStateID>,\n    /// A sequence of NFA/DFA powerset states that have been computed for this\n    /// lazy DFA. This sequence is indexable by untagged LazyStateIDs. (Every\n    /// tagged LazyStateID can be used to index this sequence by converting it\n    /// to its untagged form.)\n    states: Vec<State>,\n    /// A map from states to their corresponding IDs. This map may be accessed\n    /// via the raw byte representation of a state, which means that a `State`\n    /// does not need to be allocated to determine whether it already exists\n    /// in this map. Indeed, the existence of such a state is what determines\n    /// whether we allocate a new `State` or not.\n    ///\n    /// The higher level idea here is that we do just enough determinization\n    /// for a state to check whether we've already computed it. If we have,\n    /// then we can save a little (albeit not much) work. The real savings is\n    /// in memory usage. If we never checked for trivially duplicate states,\n    /// then our memory usage would explode to unreasonable levels.\n    states_to_id: StateMap,\n    /// Sparse sets used to track which NFA states have been visited during\n    /// various traversals.\n    sparses: SparseSets,\n    /// Scratch space for traversing the NFA graph. (We use space on the heap\n    /// instead of the call stack.)\n    stack: Vec<NFAStateID>,\n    /// Scratch space for building a NFA/DFA powerset state. This is used to\n    /// help amortize allocation since not every powerset state generated is\n    /// added to the cache. In particular, if it already exists in the cache,\n    /// then there is no need to allocate a new `State` for it.\n    scratch_state_builder: StateBuilderEmpty,\n    /// A simple abstraction for handling the saving of at most a single state\n    /// across a cache clearing. This is required for correctness. Namely, if\n    /// adding a new state after clearing the cache fails, then the caller\n    /// must retain the ability to continue using the state ID given. The\n    /// state corresponding to the state ID is what we preserve across cache\n    /// clearings.\n    state_saver: StateSaver,\n    /// The memory usage, in bytes, used by 'states' and 'states_to_id'. We\n    /// track this as new states are added since states use a variable amount\n    /// of heap. Tracking this as we add states makes it possible to compute\n    /// the total amount of memory used by the determinizer in constant time.\n    memory_usage_state: usize,\n    /// The number of times the cache has been cleared. When a minimum cache\n    /// clear count is set, then the cache will return an error instead of\n    /// clearing the cache if the count has been exceeded.\n    clear_count: usize,\n    /// The total number of bytes searched since the last time this cache was\n    /// cleared, not including the current search.\n    ///\n    /// This can be added to the length of the current search to get the true\n    /// total number of bytes searched.\n    ///\n    /// This is generally only non-zero when the\n    /// `Cache::search_{start,update,finish}` APIs are used to track search\n    /// progress.\n    bytes_searched: usize,\n    /// The progress of the current search.\n    ///\n    /// This is only non-`None` when callers utlize the `Cache::search_start`,\n    /// `Cache::search_update` and `Cache::search_finish` APIs.\n    ///\n    /// The purpose of recording search progress is to be able to make a\n    /// determination about the efficiency of the cache. Namely, by keeping\n    /// track of the\n    progress: Option<SearchProgress>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]\npub(crate) struct ByteSet {\n    bits: BitSet,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[cfg(feature = \"alloc\")]\n#[derive(Clone, Debug)]\npub struct PatternSetInsertError {\n    attempted: PatternID,\n    capacity: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone)]\npub(crate) struct StartByteMap {\n    map: [Start; 256],\n}\nimpl DFA {\n    #[inline]\n    pub fn try_search_fwd(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[inline]\n    pub fn try_search_rev(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[inline]\n    pub fn try_search_overlapping_fwd(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {\n        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n        search::find_overlapping_fwd(self, cache, input, state)?;\n        match state.get_match() {\n            None => Ok(()),\n            Some(_) if !utf8empty => Ok(()),\n            Some(_) => {\n                skip_empty_utf8_splits_overlapping(\n                    input,\n                    state,\n                    |input, state| {\n                        search::find_overlapping_fwd(self, cache, input, state)\n                    },\n                )\n            }\n        }\n    }\n    #[inline]\n    pub fn try_search_overlapping_rev(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError> {}\n    #[inline]\n    pub fn try_which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError> {\n        let mut state = OverlappingState::start();\n        while let Some(m) = {\n            self.try_search_overlapping_fwd(cache, input, &mut state)?;\n            state.get_match()\n        } {\n            let _ = patset.try_insert(m.pattern());\n            if patset.is_full() || input.get_earliest() {\n                break;\n            }\n        }\n        Ok(())\n    }\n}\nimpl OverlappingState {\n    pub fn start() -> OverlappingState {\n        OverlappingState {\n            mat: None,\n            id: None,\n            at: 0,\n            next_match_index: None,\n            rev_eoi: false,\n        }\n    }\n    pub fn get_match(&self) -> Option<HalfMatch> {\n        self.mat\n    }\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {}\n    #[inline]\n    pub fn start(&self) -> usize {}\n    #[inline]\n    pub fn end(&self) -> usize {}\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {\n        self.earliest\n    }\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\n#[cfg(feature = \"alloc\")]\nimpl PatternSet {\n    pub fn new(capacity: usize) -> PatternSet {}\n    pub fn clear(&mut self) {}\n    pub fn contains(&self, pid: PatternID) -> bool {}\n    pub fn insert(&mut self, pid: PatternID) -> bool {}\n    pub fn try_insert(&mut self, pid: PatternID) -> Result<bool, PatternSetInsertError> {\n        if pid.as_usize() >= self.capacity() {\n            return Err(PatternSetInsertError {\n                attempted: pid,\n                capacity: self.capacity(),\n            });\n        }\n        if self.which[pid] {\n            return Ok(false);\n        }\n        self.len += 1;\n        self.which[pid] = true;\n        Ok(true)\n    }\n    pub fn is_empty(&self) -> bool {}\n    pub fn is_full(&self) -> bool {\n        self.len() == self.capacity()\n    }\n    pub fn len(&self) -> usize {}\n    pub fn capacity(&self) -> usize {}\n    pub fn iter(&self) -> PatternSetIter<'_> {}\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {\n        self.pattern\n    }\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Writes the set of patterns that match anywhere in the given search\n/// configuration to `patset`. If multiple patterns match at the same\n/// position and the underlying DFA supports overlapping matches, then all\n/// matching patterns are written to the given set.\n///\n/// Unless all of the patterns in this DFA are anchored, then generally\n/// speaking, this will visit every byte in the haystack.\n///\n/// This search routine *does not* clear the pattern set. This gives some\n/// flexibility to the caller (e.g., running multiple searches with the\n/// same pattern set), but does make the API bug-prone if you're reusing\n/// the same pattern set for multiple searches but intended them to be\n/// independent.\n///\n/// If a pattern ID matched but the given `PatternSet` does not have\n/// sufficient capacity to store it, then it is not inserted and silently\n/// dropped.\n///\n/// # Errors\n///\n/// This routine errors if the search could not complete. This can occur\n/// in a number of circumstances:\n///\n/// * The configuration of the lazy DFA may permit it to \"quit\" the search.\n/// For example, setting quit bytes or enabling heuristic support for\n/// Unicode word boundaries. The default configuration does not enable any\n/// option that could result in the lazy DFA quitting.\n/// * The configuration of the lazy DFA may also permit it to \"give up\"\n/// on a search if it makes ineffective use of its transition table\n/// cache. The default configuration does not enable this by default,\n/// although it is typically a good idea to.\n/// * When the provided `Input` configuration is not supported. For\n/// example, by providing an unsupported anchor mode.\n///\n/// When a search returns an error, callers cannot know whether a match\n/// exists or not.\n///\n/// # Example\n///\n/// This example shows how to find all matching patterns in a haystack,\n/// even when some patterns match at the same position as other patterns.\n///\n/// ```\n/// # if cfg!(miri) { return Ok(()); } // miri takes too long\n/// use regex_automata::{\n///     hybrid::dfa::DFA,\n///     Input, MatchKind, PatternSet,\n/// };\n///\n/// let patterns = &[\n///     r\"\\w+\", r\"\\d+\", r\"\\pL+\", r\"foo\", r\"bar\", r\"barfoo\", r\"foobar\",\n/// ];\n/// let dfa = DFA::builder()\n///     .configure(DFA::config().match_kind(MatchKind::All))\n///     .build_many(patterns)?;\n/// let mut cache = dfa.create_cache();\n///\n/// let input = Input::new(\"foobar\");\n/// let mut patset = PatternSet::new(dfa.pattern_len());\n/// dfa.try_which_overlapping_matches(&mut cache, &input, &mut patset)?;\n/// let expected = vec![0, 2, 3, 4, 6];\n/// let got: Vec<usize> = patset.iter().map(|p| p.as_usize()).collect();\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1128 pub fn try_which_overlapping_matches(\n1129     &self,\n1130     cache: &mut Cache,\n1131     input: &Input<'_>,\n1132     patset: &mut PatternSet,\n1133 ) -> Result<(), MatchError> {\n1134     let mut state = OverlappingState::start();\n1135     while let Some(m) = {\n1136         self.try_search_overlapping_fwd(cache, input, &mut state)?;\n1137         state.get_match()\n1138     } {\n1139         let _ = patset.try_insert(m.pattern());\n1140         // There's nothing left to find, so we can stop. Or the caller\n1141         // asked us to.\n1142         if patset.is_full() || input.get_earliest() {\n1143             break;\n1144         }\n1145     }\n1146     Ok(())\n1147 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}