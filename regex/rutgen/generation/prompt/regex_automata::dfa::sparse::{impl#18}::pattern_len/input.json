{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\nimpl<'a> State<'a> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next(&self, input: u8) -> StateID {}\n    fn next_eoi(&self) -> StateID {}\n    fn id(&self) -> StateID {}\n    fn range(&self, i: usize) -> (u8, u8) {}\n    fn next_at(&self, i: usize) -> StateID {}\n    fn pattern_id(&self, match_index: usize) -> PatternID {}\n    fn pattern_len(&self) -> usize {\n        assert_eq!(0, self.pattern_ids.len() % 4);\n        self.pattern_ids.len() / 4\n    }\n    fn accelerator(&self) -> &'a [u8] {}\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the total number of pattern IDs for this state. This is always\n/// zero when `is_match` is false.\n2328 fn pattern_len(&self) -> usize {\n2329     assert_eq!(0, self.pattern_ids.len() % 4);\n2330     self.pattern_ids.len() / 4\n2331 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}