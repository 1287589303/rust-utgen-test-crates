{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/search.rs\n// crate name is regex_automata\nuse crate::{\n    dfa::{accel, automaton::{Automaton, OverlappingState}},\n    util::{\n        prefilter::Prefilter, primitives::StateID,\n        search::{Anchored, HalfMatch, Input, Span},\n    },\n    MatchError,\n};\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Span {\n    /// The start offset of the span, inclusive.\n    pub start: usize,\n    /// The end offset of the span, exclusive.\n    pub end: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {\n        HalfMatch { pattern, offset }\n    }\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {\n        MatchError::new(MatchErrorKind::Quit {\n            byte,\n            offset,\n        })\n    }\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {}\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {}\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {\n        #[cfg(not(feature = \"alloc\"))] { unreachable!() }\n        #[cfg(feature = \"alloc\")] { self.pre.find(haystack, span) }\n    }\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {}\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn find_fwd_imp<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    pre: Option<&'_ Prefilter>,\n    earliest: bool,\n) -> Result<Option<HalfMatch>, MatchError> {\n    let universal_start = dfa.universal_start_state(Anchored::No).is_some();\n    let mut mat = None;\n    let mut sid = init_fwd(dfa, input)?;\n    let mut at = input.start();\n    macro_rules! next_unchecked {\n        ($sid:expr, $at:expr) => {\n            { let byte = * input.haystack().get_unchecked($at); dfa\n            .next_state_unchecked($sid, byte) }\n        };\n    }\n    if let Some(ref pre) = pre {\n        let span = Span::from(at..input.end());\n        match pre.find(input.haystack(), span) {\n            None => return Ok(mat),\n            Some(ref span) => {\n                at = span.start;\n                if !universal_start {\n                    sid = prefilter_restart(dfa, &input, at)?;\n                }\n            }\n        }\n    }\n    while at < input.end() {\n        let mut prev_sid;\n        while at < input.end() {\n            prev_sid = unsafe { next_unchecked!(sid, at) };\n            if dfa.is_special_state(prev_sid) || at + 3 >= input.end() {\n                core::mem::swap(&mut prev_sid, &mut sid);\n                break;\n            }\n            at += 1;\n            sid = unsafe { next_unchecked!(prev_sid, at) };\n            if dfa.is_special_state(sid) {\n                break;\n            }\n            at += 1;\n            prev_sid = unsafe { next_unchecked!(sid, at) };\n            if dfa.is_special_state(prev_sid) {\n                core::mem::swap(&mut prev_sid, &mut sid);\n                break;\n            }\n            at += 1;\n            sid = unsafe { next_unchecked!(prev_sid, at) };\n            if dfa.is_special_state(sid) {\n                break;\n            }\n            at += 1;\n        }\n        if dfa.is_special_state(sid) {\n            if dfa.is_start_state(sid) {\n                if let Some(ref pre) = pre {\n                    let span = Span::from(at..input.end());\n                    match pre.find(input.haystack(), span) {\n                        None => return Ok(mat),\n                        Some(ref span) => {\n                            if span.start > at {\n                                at = span.start;\n                                if !universal_start {\n                                    sid = prefilter_restart(dfa, &input, at)?;\n                                }\n                                continue;\n                            }\n                        }\n                    }\n                } else if dfa.is_accel_state(sid) {\n                    let needles = dfa.accelerator(sid);\n                    at = accel::find_fwd(needles, input.haystack(), at + 1)\n                        .unwrap_or(input.end());\n                    continue;\n                }\n            } else if dfa.is_match_state(sid) {\n                let pattern = dfa.match_pattern(sid, 0);\n                mat = Some(HalfMatch::new(pattern, at));\n                if earliest {\n                    return Ok(mat);\n                }\n                if dfa.is_accel_state(sid) {\n                    let needles = dfa.accelerator(sid);\n                    at = accel::find_fwd(needles, input.haystack(), at + 1)\n                        .unwrap_or(input.end());\n                    continue;\n                }\n            } else if dfa.is_accel_state(sid) {\n                let needs = dfa.accelerator(sid);\n                at = accel::find_fwd(needs, input.haystack(), at + 1)\n                    .unwrap_or(input.end());\n                continue;\n            } else if dfa.is_dead_state(sid) {\n                return Ok(mat);\n            } else {\n                return Err(MatchError::quit(input.haystack()[at], at));\n            }\n        }\n        at += 1;\n    }\n    eoi_fwd(dfa, input, &mut sid, &mut mat)?;\n    Ok(mat)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn prefilter_restart<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    at: usize,\n) -> Result<StateID, MatchError> {\n    let mut input = input.clone();\n    input.set_start(at);\n    init_fwd(dfa, &input)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn eoi_fwd<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    sid: &mut StateID,\n    mat: &mut Option<HalfMatch>,\n) -> Result<(), MatchError> {\n    let sp = input.get_span();\n    match input.haystack().get(sp.end) {\n        Some(&b) => {\n            *sid = dfa.next_state(*sid, b);\n            if dfa.is_match_state(*sid) {\n                let pattern = dfa.match_pattern(*sid, 0);\n                *mat = Some(HalfMatch::new(pattern, sp.end));\n            } else if dfa.is_quit_state(*sid) {\n                return Err(MatchError::quit(b, sp.end));\n            }\n        }\n        None => {\n            *sid = dfa.next_eoi_state(*sid);\n            if dfa.is_match_state(*sid) {\n                let pattern = dfa.match_pattern(*sid, 0);\n                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));\n            }\n        }\n    }\n    Ok(())\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn init_fwd<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n) -> Result<StateID, MatchError> {\n    let sid = dfa.start_state_forward(input)?;\n    debug_assert!(! dfa.is_match_state(sid));\n    Ok(sid)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\npub(crate) fn find_fwd(needles: &[u8], haystack: &[u8], at: usize) -> Option<usize> {\n    let bs = needles;\n    let i = match needles.len() {\n        1 => memchr::memchr(bs[0], &haystack[at..])?,\n        2 => memchr::memchr2(bs[0], bs[1], &haystack[at..])?,\n        3 => memchr::memchr3(bs[0], bs[1], bs[2], &haystack[at..])?,\n        0 => panic!(\"cannot find with empty needles\"),\n        n => panic!(\"invalid needles length: {}\", n),\n    };\n    Some(at + i)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n 45 fn find_fwd_imp<A: Automaton + ?Sized>(\n 46     dfa: &A,\n 47     input: &Input<'_>,\n 48     pre: Option<&'_ Prefilter>,\n 49     earliest: bool,\n 50 ) -> Result<Option<HalfMatch>, MatchError> {\n 51     // See 'prefilter_restart' docs for explanation.\n 52     let universal_start = dfa.universal_start_state(Anchored::No).is_some();\n 53     let mut mat = None;\n 54     let mut sid = init_fwd(dfa, input)?;\n 55     let mut at = input.start();\n 56     // This could just be a closure, but then I think it would be unsound\n 57     // because it would need to be safe to invoke. This way, the lack of safety\n 58     // is clearer in the code below.\n 59     macro_rules! next_unchecked {\n 60         ($sid:expr, $at:expr) => {{\n 61             let byte = *input.haystack().get_unchecked($at);\n 62             dfa.next_state_unchecked($sid, byte)\n 63         }};\n 64     }\n 65 \n 66     if let Some(ref pre) = pre {\n 67         let span = Span::from(at..input.end());\n 68         // If a prefilter doesn't report false positives, then we don't need to\n 69         // touch the DFA at all. However, since all matches include the pattern\n 70         // ID, and the prefilter infrastructure doesn't report pattern IDs, we\n 71         // limit this optimization to cases where there is exactly one pattern.\n 72         // In that case, any match must be the 0th pattern.\n 73         match pre.find(input.haystack(), span) {\n 74             None => return Ok(mat),\n 75             Some(ref span) => {\n 76                 at = span.start;\n 77                 if !universal_start {\n 78                     sid = prefilter_restart(dfa, &input, at)?;\n 79                 }\n 80             }\n 81         }\n 82     }\n 83     while at < input.end() {\n 84         // SAFETY: There are two safety invariants we need to uphold here in\n 85         // the loops below: that 'sid' and 'prev_sid' are valid state IDs\n 86         // for this DFA, and that 'at' is a valid index into 'haystack'.\n 87         // For the former, we rely on the invariant that next_state* and\n 88         // start_state_forward always returns a valid state ID (given a valid\n 89         // state ID in the former case). For the latter safety invariant, we\n 90         // always guard unchecked access with a check that 'at' is less than\n 91         // 'end', where 'end <= haystack.len()'. In the unrolled loop below, we\n 92         // ensure that 'at' is always in bounds.\n 93         //\n 94         // PERF: See a similar comment in src/hybrid/search.rs that justifies\n 95         // this extra work to make the search loop fast. The same reasoning and\n 96         // benchmarks apply here.\n 97         let mut prev_sid;\n 98         while at < input.end() {\n 99             prev_sid = unsafe { next_unchecked!(sid, at) };\n100             if dfa.is_special_state(prev_sid) || at + 3 >= input.end() {\n101                 core::mem::swap(&mut prev_sid, &mut sid);\n102                 break;\n103             }\n104             at += 1;\n105 \n106             sid = unsafe { next_unchecked!(prev_sid, at) };\n107             if dfa.is_special_state(sid) {\n108                 break;\n109             }\n110             at += 1;\n111 \n112             prev_sid = unsafe { next_unchecked!(sid, at) };\n113             if dfa.is_special_state(prev_sid) {\n114                 core::mem::swap(&mut prev_sid, &mut sid);\n115                 break;\n116             }\n117             at += 1;\n118 \n119             sid = unsafe { next_unchecked!(prev_sid, at) };\n120             if dfa.is_special_state(sid) {\n121                 break;\n122             }\n123             at += 1;\n124         }\n125         if dfa.is_special_state(sid) {\n126             if dfa.is_start_state(sid) {\n127                 if let Some(ref pre) = pre {\n128                     let span = Span::from(at..input.end());\n129                     match pre.find(input.haystack(), span) {\n130                         None => return Ok(mat),\n131                         Some(ref span) => {\n132                             // We want to skip any update to 'at' below\n133                             // at the end of this iteration and just\n134                             // jump immediately back to the next state\n135                             // transition at the leading position of the\n136                             // candidate match.\n137                             //\n138                             // ... but only if we actually made progress\n139                             // with our prefilter, otherwise if the start\n140                             // state has a self-loop, we can get stuck.\n141                             if span.start > at {\n142                                 at = span.start;\n143                                 if !universal_start {\n144                                     sid = prefilter_restart(dfa, &input, at)?;\n145                                 }\n146                                 continue;\n147                             }\n148                         }\n149                     }\n150                 } else if dfa.is_accel_state(sid) {\n151                     let needles = dfa.accelerator(sid);\n152                     at = accel::find_fwd(needles, input.haystack(), at + 1)\n153                         .unwrap_or(input.end());\n154                     continue;\n155                 }\n156             } else if dfa.is_match_state(sid) {\n157                 let pattern = dfa.match_pattern(sid, 0);\n158                 mat = Some(HalfMatch::new(pattern, at));\n159                 if earliest {\n160                     return Ok(mat);\n161                 }\n162                 if dfa.is_accel_state(sid) {\n163                     let needles = dfa.accelerator(sid);\n164                     at = accel::find_fwd(needles, input.haystack(), at + 1)\n165                         .unwrap_or(input.end());\n166                     continue;\n167                 }\n168             } else if dfa.is_accel_state(sid) {\n169                 let needs = dfa.accelerator(sid);\n170                 at = accel::find_fwd(needs, input.haystack(), at + 1)\n171                     .unwrap_or(input.end());\n172                 continue;\n173             } else if dfa.is_dead_state(sid) {\n174                 return Ok(mat);\n175             } else {\n176                 // It's important that this is a debug_assert, since this can\n177                 // actually be tripped even if DFA::from_bytes succeeds and\n178                 // returns a supposedly valid DFA.\n179                 return Err(MatchError::quit(input.haystack()[at], at));\n180             }\n181         }\n182         at += 1;\n183     }\n184     eoi_fwd(dfa, input, &mut sid, &mut mat)?;\n185     Ok(mat)\n186 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}