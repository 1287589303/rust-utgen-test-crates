{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Debug)]\npub struct IntervalSet<I> {\n    /// A sorted set of non-overlapping ranges.\n    ranges: Vec<I>,\n    /// While not required at all for correctness, we keep track of whether an\n    /// interval set has been case folded or not. This helps us avoid doing\n    /// redundant work if, for example, a set has already been cased folded.\n    /// And note that whether a set is folded or not is preserved through\n    /// all of the pairwise set operations. That is, if both interval sets\n    /// have been case folded, then any of difference, union, intersection or\n    /// symmetric difference all produce a case folded set.\n    ///\n    /// Note that when this is true, it *must* be the case that the set is case\n    /// folded. But when it's false, the set *may* be case folded. In other\n    /// words, we only set this to true when we know it to be case, but we're\n    /// okay with it being false if it would otherwise be costly to determine\n    /// whether it should be true. This means code cannot assume that a false\n    /// value necessarily indicates that the set is not case folded.\n    ///\n    /// Bottom line: this is a performance optimization.\n    folded: bool,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}\nimpl ClassBytes {\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {}\n    pub fn empty() -> ClassBytes {}\n    pub fn push(&mut self, range: ClassBytesRange) {}\n    pub fn iter(&self) -> ClassBytesIter<'_> {}\n    pub fn ranges(&self) -> &[ClassBytesRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n    pub fn union(&mut self, other: &ClassBytes) {}\n    pub fn intersect(&mut self, other: &ClassBytes) {}\n    pub fn difference(&mut self, other: &ClassBytes) {}\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_unicode_class(&self) -> Option<ClassUnicode> {}\n}\nimpl<I: Interval> IntervalSet<I> {\n    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {}\n    pub fn push(&mut self, interval: I) {}\n    pub fn iter(&self) -> IntervalSetIter<'_, I> {}\n    pub fn intervals(&self) -> &[I] {}\n    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {}\n    pub fn union(&mut self, other: &IntervalSet<I>) {}\n    pub fn intersect(&mut self, other: &IntervalSet<I>) {}\n    pub fn difference(&mut self, other: &IntervalSet<I>) {}\n    pub fn symmetric_difference(&mut self, other: &IntervalSet<I>) {}\n    pub fn negate(&mut self) {\n        if self.ranges.is_empty() {\n            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n            self.ranges.push(I::create(min, max));\n            self.folded = true;\n            return;\n        }\n        let drain_end = self.ranges.len();\n        if self.ranges[0].lower() > I::Bound::min_value() {\n            let upper = self.ranges[0].lower().decrement();\n            self.ranges.push(I::create(I::Bound::min_value(), upper));\n        }\n        for i in 1..drain_end {\n            let lower = self.ranges[i - 1].upper().increment();\n            let upper = self.ranges[i].lower().decrement();\n            self.ranges.push(I::create(lower, upper));\n        }\n        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n            let lower = self.ranges[drain_end - 1].upper().increment();\n            self.ranges.push(I::create(lower, I::Bound::max_value()));\n        }\n        self.ranges.drain(..drain_end);\n    }\n    fn canonicalize(&mut self) {}\n    fn is_canonical(&self) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Negate this byte class.\n///\n/// For all `b` where `b` is a any byte, if `b` was in this set, then it\n/// will not be in this set after negation.\n1407 pub fn negate(&mut self) {\n1408     self.set.negate();\n1409 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}