{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/pikevm.rs\n// crate name is regex_lite\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    int::{NonMaxUsize, U32},\n    nfa::{State, StateID, NFA},\n    pool::CachePoolGuard, utf8,\n};\npub(crate) trait U32 {\n    fn as_usize(self) -> usize;\n}\n#[derive(Clone, Debug)]\npub(crate) struct PikeVM {\n    nfa: NFA,\n}\n#[derive(Clone)]\npub(crate) struct NFA {\n    /// The pattern string this NFA was generated from.\n    ///\n    /// We put it here for lack of a better place to put it. ¯\\_(ツ)_/¯\n    pattern: String,\n    /// The states that make up this NFA.\n    states: Vec<State>,\n    /// The ID of the start state.\n    start: StateID,\n    /// Whether this NFA can only match at the beginning of a haystack.\n    is_start_anchored: bool,\n    /// Whether this NFA can match the empty string.\n    is_match_empty: bool,\n    /// If every match has the same number of matching capture groups, then\n    /// this corresponds to the number of groups.\n    static_explicit_captures_len: Option<usize>,\n    /// A map from capture group name to its corresponding index.\n    cap_name_to_index: CaptureNameMap,\n    /// A map from capture group index to the corresponding name, if one\n    /// exists.\n    cap_index_to_name: Vec<Option<Arc<str>>>,\n    /// Heap memory used indirectly by NFA states and other things (like the\n    /// various capturing group representations above). Since each state\n    /// might use a different amount of heap, we need to keep track of this\n    /// incrementally.\n    memory_extra: usize,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub(crate) struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Debug)]\nstruct ActiveStates {\n    /// The set of active NFA states. This set preserves insertion order, which\n    /// is critical for simulating the match semantics of backtracking regex\n    /// engines.\n    set: SparseSet,\n    /// The slots for every NFA state, where each slot stores a (possibly\n    /// absent) offset. Every capturing group has two slots. One for a start\n    /// offset and one for an end offset.\n    slot_table: SlotTable,\n}\n#[derive(Clone, Debug)]\nenum FollowEpsilon {\n    /// Explore the epsilon transitions from a state ID.\n    Explore(StateID),\n    /// Reset the given `slot` to the given `offset` (which might be `None`).\n    RestoreCapture { slot: u32, offset: Option<NonMaxUsize> },\n}\nimpl PikeVM {\n    pub(crate) fn new(nfa: NFA) -> PikeVM {}\n    pub(crate) fn nfa(&self) -> &NFA {}\n    pub(crate) fn find_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> FindMatches<'r, 'h> {}\n    pub(crate) fn captures_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> CapturesMatches<'r, 'h> {}\n    pub(crate) fn search(\n        &self,\n        cache: &mut Cache,\n        haystack: &[u8],\n        start: usize,\n        end: usize,\n        earliest: bool,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {}\n    fn nexts(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {}\n    fn next(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slot_table: &mut SlotTable,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        sid: StateID,\n    ) -> bool {}\n    fn epsilon_closure(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        sid: StateID,\n    ) {\n        stack.push(FollowEpsilon::Explore(sid));\n        while let Some(frame) = stack.pop() {\n            match frame {\n                FollowEpsilon::RestoreCapture { slot, offset } => {\n                    curr_slots[slot.as_usize()] = offset;\n                }\n                FollowEpsilon::Explore(sid) => {\n                    self.epsilon_closure_explore(\n                        stack,\n                        curr_slots,\n                        next,\n                        haystack,\n                        at,\n                        sid,\n                    );\n                }\n            }\n        }\n    }\n    fn epsilon_closure_explore(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        mut sid: StateID,\n    ) {\n        loop {\n            if !next.set.insert(sid) {\n                return;\n            }\n            match *self.nfa.state(sid) {\n                State::Fail\n                | State::Match { .. }\n                | State::Char { .. }\n                | State::Ranges { .. } => {\n                    next.slot_table.for_state(sid).copy_from_slice(curr_slots);\n                    return;\n                }\n                State::Goto { target, look: None } => {\n                    sid = target;\n                }\n                State::Goto { target, look: Some(look) } => {\n                    if !look.is_match(haystack, at) {\n                        return;\n                    }\n                    sid = target;\n                }\n                State::Splits { ref targets, reverse: false } => {\n                    sid = match targets.get(0) {\n                        None => return,\n                        Some(&sid) => sid,\n                    };\n                    stack\n                        .extend(\n                            targets[1..]\n                                .iter()\n                                .copied()\n                                .rev()\n                                .map(FollowEpsilon::Explore),\n                        );\n                }\n                State::Splits { ref targets, reverse: true } => {\n                    sid = match targets.last() {\n                        None => return,\n                        Some(&sid) => sid,\n                    };\n                    stack\n                        .extend(\n                            targets[..targets.len() - 1]\n                                .iter()\n                                .copied()\n                                .map(FollowEpsilon::Explore),\n                        );\n                }\n                State::Capture { target, slot } => {\n                    if slot.as_usize() < curr_slots.len() {\n                        stack\n                            .push(FollowEpsilon::RestoreCapture {\n                                slot,\n                                offset: curr_slots[slot.as_usize()],\n                            });\n                        curr_slots[slot.as_usize()] = Some(\n                            NonMaxUsize::new(at).unwrap(),\n                        );\n                    }\n                    sid = target;\n                }\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Compute the epsilon closure of `sid`, writing the closure into `next`\n/// while copying slot values from `curr_slots` into corresponding states\n/// in `next`. `curr_slots` should be the slot values corresponding to\n/// `sid`.\n///\n/// The given `stack` is used to perform a depth first traversal of the\n/// NFA by recursively following all epsilon transitions out of `sid`.\n/// Conditional epsilon transitions are followed if and only if they are\n/// satisfied for the position `at` in the `input` haystack.\n///\n/// While this routine may write to `curr_slots`, once it returns, any\n/// writes are undone and the original values (even if absent) are\n/// restored.\n307 fn epsilon_closure(\n308     &self,\n309     stack: &mut Vec<FollowEpsilon>,\n310     curr_slots: &mut [Option<NonMaxUsize>],\n311     next: &mut ActiveStates,\n312     haystack: &[u8],\n313     at: usize,\n314     sid: StateID,\n315 ) {\n316     stack.push(FollowEpsilon::Explore(sid));\n317     while let Some(frame) = stack.pop() {\n318         match frame {\n319             FollowEpsilon::RestoreCapture { slot, offset } => {\n320                 curr_slots[slot.as_usize()] = offset;\n321             }\n322             FollowEpsilon::Explore(sid) => {\n323                 self.epsilon_closure_explore(\n324                     stack, curr_slots, next, haystack, at, sid,\n325                 );\n326             }\n327         }\n328     }\n329 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}