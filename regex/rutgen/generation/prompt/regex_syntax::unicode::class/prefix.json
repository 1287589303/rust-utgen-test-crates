{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/unicode.rs\n// crate name is regex_syntax\ntype Range = &'static [(char, char)];\ntype PropertyValues = &'static [(&'static str, &'static str)];\nuse alloc::{\n    string::{String, ToString},\n    vec::Vec,\n};\nuse crate::hir;\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Debug)]\npub enum ClassQuery<'a> {\n    /// Return a class corresponding to a Unicode binary property, named by\n    /// a single letter.\n    OneLetter(char),\n    /// Return a class corresponding to a Unicode binary property.\n    ///\n    /// Note that, by special exception (see UTS#18, Section 1.2), both\n    /// general category values and script values are permitted here as if\n    /// they were a binary property.\n    Binary(&'a str),\n    /// Return a class corresponding to all codepoints whose property\n    /// (identified by `property_name`) corresponds to the given value\n    /// (identified by `property_value`).\n    ByValue {\n        /// A property name.\n        property_name: &'a str,\n        /// A property value.\n        property_value: &'a str,\n    },\n}\n#[derive(Debug)]\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n    #[allow(dead_code)]\n    PerlClassNotFound,\n}\n#[derive(Debug, Eq, PartialEq)]\nenum CanonicalClassQuery {\n    /// The canonical binary property name.\n    Binary(&'static str),\n    /// The canonical general category name.\n    GeneralCategory(&'static str),\n    /// The canonical script name.\n    Script(&'static str),\n    /// An arbitrary association between property and value, both of which\n    /// have been canonicalized.\n    ///\n    /// Note that by construction, the property name of ByValue will never\n    /// be General_Category or Script. Those two cases are subsumed by the\n    /// eponymous variants.\n    ByValue {\n        /// The canonical property name.\n        property_name: &'static str,\n        /// The canonical property value.\n        property_value: &'static str,\n    },\n}\nimpl<'a> ClassQuery<'a> {\n    fn canonicalize(&self) -> Result<CanonicalClassQuery, Error> {\n        match *self {\n            ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),\n            ClassQuery::Binary(name) => self.canonical_binary(name),\n            ClassQuery::ByValue { property_name, property_value } => {\n                let property_name = symbolic_name_normalize(property_name);\n                let property_value = symbolic_name_normalize(property_value);\n                let canon_name = match canonical_prop(&property_name)? {\n                    None => return Err(Error::PropertyNotFound),\n                    Some(canon_name) => canon_name,\n                };\n                Ok(\n                    match canon_name {\n                        \"General_Category\" => {\n                            let canon = match canonical_gencat(&property_value)? {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(canon) => canon,\n                            };\n                            CanonicalClassQuery::GeneralCategory(canon)\n                        }\n                        \"Script\" => {\n                            let canon = match canonical_script(&property_value)? {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(canon) => canon,\n                            };\n                            CanonicalClassQuery::Script(canon)\n                        }\n                        _ => {\n                            let vals = match property_values(canon_name)? {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(vals) => vals,\n                            };\n                            let canon_val = match canonical_value(\n                                vals,\n                                &property_value,\n                            ) {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(canon_val) => canon_val,\n                            };\n                            CanonicalClassQuery::ByValue {\n                                property_name: canon_name,\n                                property_value: canon_val,\n                            }\n                        }\n                    },\n                )\n            }\n        }\n    }\n    fn canonical_binary(&self, name: &str) -> Result<CanonicalClassQuery, Error> {}\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {}\n    pub fn empty() -> ClassUnicode {\n        ClassUnicode::new(vec![])\n    }\n    pub fn push(&mut self, range: ClassUnicodeRange) {}\n    pub fn iter(&self) -> ClassUnicodeIter<'_> {}\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn try_case_fold_simple(&mut self) -> core::result::Result<(), CaseFoldError> {}\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassUnicode) {\n        self.set.union(&other.set);\n    }\n    pub fn intersect(&mut self, other: &ClassUnicode) {}\n    pub fn difference(&mut self, other: &ClassUnicode) {}\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_byte_class(&self) -> Option<ClassBytes> {}\n}\npub fn class(query: ClassQuery<'_>) -> Result<hir::ClassUnicode, Error> {\n    use self::CanonicalClassQuery::*;\n    match query.canonicalize()? {\n        Binary(name) => bool_property(name),\n        GeneralCategory(name) => gencat(name),\n        Script(name) => script(name),\n        ByValue { property_name: \"Age\", property_value } => {\n            let mut class = hir::ClassUnicode::empty();\n            for set in ages(property_value)? {\n                class.union(&hir_class(set));\n            }\n            Ok(class)\n        }\n        ByValue { property_name: \"Script_Extensions\", property_value } => {\n            script_extension(property_value)\n        }\n        ByValue { property_name: \"Grapheme_Cluster_Break\", property_value } => {\n            gcb(property_value)\n        }\n        ByValue { property_name: \"Sentence_Break\", property_value } => sb(property_value),\n        ByValue { property_name: \"Word_Break\", property_value } => wb(property_value),\n        _ => Err(Error::PropertyNotFound),\n    }\n}\npub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode {\n    let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges\n        .iter()\n        .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))\n        .collect();\n    hir::ClassUnicode::new(hir_ranges)\n}\nfn script_extension(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> {\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::script_extension::BY_NAME;\n        property_set(BY_NAME, name).map(hir_class).ok_or(Error::PropertyValueNotFound)\n    }\n    imp(canonical_name)\n}\nfn sb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> {\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::sentence_break::BY_NAME;\n        property_set(BY_NAME, name).map(hir_class).ok_or(Error::PropertyValueNotFound)\n    }\n    imp(canonical_name)\n}\nfn gcb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> {\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::grapheme_cluster_break::BY_NAME;\n        property_set(BY_NAME, name).map(hir_class).ok_or(Error::PropertyValueNotFound)\n    }\n    imp(canonical_name)\n}\nfn script(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> {\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::script::BY_NAME;\n        property_set(BY_NAME, name).map(hir_class).ok_or(Error::PropertyValueNotFound)\n    }\n    imp(canonical_name)\n}\nfn wb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> {\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::word_break::BY_NAME;\n        property_set(BY_NAME, name).map(hir_class).ok_or(Error::PropertyValueNotFound)\n    }\n    imp(canonical_name)\n}\nfn bool_property(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> {\n    #[cfg(not(feature = \"unicode-bool\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-bool\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::property_bool::BY_NAME;\n        property_set(BY_NAME, name).map(hir_class).ok_or(Error::PropertyNotFound)\n    }\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        \"White_Space\" => perl_space(),\n        name => imp(name),\n    }\n}\nfn ages(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error> {\n    #[cfg(not(feature = \"unicode-age\"))]\n    fn imp(_: &str) -> Result<impl Iterator<Item = Range>, Error> {\n        use core::option::IntoIter;\n        Err::<IntoIter<Range>, _>(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-age\")]\n    fn imp(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error> {\n        use crate::unicode_tables::age;\n        const AGES: &[(&str, Range)] = &[\n            (\"V1_1\", age::V1_1),\n            (\"V2_0\", age::V2_0),\n            (\"V2_1\", age::V2_1),\n            (\"V3_0\", age::V3_0),\n            (\"V3_1\", age::V3_1),\n            (\"V3_2\", age::V3_2),\n            (\"V4_0\", age::V4_0),\n            (\"V4_1\", age::V4_1),\n            (\"V5_0\", age::V5_0),\n            (\"V5_1\", age::V5_1),\n            (\"V5_2\", age::V5_2),\n            (\"V6_0\", age::V6_0),\n            (\"V6_1\", age::V6_1),\n            (\"V6_2\", age::V6_2),\n            (\"V6_3\", age::V6_3),\n            (\"V7_0\", age::V7_0),\n            (\"V8_0\", age::V8_0),\n            (\"V9_0\", age::V9_0),\n            (\"V10_0\", age::V10_0),\n            (\"V11_0\", age::V11_0),\n            (\"V12_0\", age::V12_0),\n            (\"V12_1\", age::V12_1),\n            (\"V13_0\", age::V13_0),\n            (\"V14_0\", age::V14_0),\n            (\"V15_0\", age::V15_0),\n            (\"V15_1\", age::V15_1),\n            (\"V16_0\", age::V16_0),\n        ];\n        assert_eq!(AGES.len(), age::BY_NAME.len(), \"ages are out of sync\");\n        let pos = AGES.iter().position(|&(age, _)| canonical_age == age);\n        match pos {\n            None => Err(Error::PropertyValueNotFound),\n            Some(i) => Ok(AGES[..=i].iter().map(|&(_, classes)| classes)),\n        }\n    }\n    imp(canonical_age)\n}\nfn gencat(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> {\n    #[cfg(not(feature = \"unicode-gencat\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n    #[cfg(feature = \"unicode-gencat\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::general_category::BY_NAME;\n        match name {\n            \"ASCII\" => Ok(hir_class(&[('\\0', '\\x7F')])),\n            \"Any\" => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n            \"Assigned\" => {\n                let mut cls = gencat(\"Unassigned\")?;\n                cls.negate();\n                Ok(cls)\n            }\n            name => {\n                property_set(BY_NAME, name)\n                    .map(hir_class)\n                    .ok_or(Error::PropertyValueNotFound)\n            }\n        }\n    }\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        name => imp(name),\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Looks up a Unicode class given a query. If one doesn't exist, then\n/// `None` is returned.\n351 pub fn class(query: ClassQuery<'_>) -> Result<hir::ClassUnicode, Error> {\n352     use self::CanonicalClassQuery::*;\n353 \n354     match query.canonicalize()? {\n355         Binary(name) => bool_property(name),\n356         GeneralCategory(name) => gencat(name),\n357         Script(name) => script(name),\n358         ByValue { property_name: \"Age\", property_value } => {\n359             let mut class = hir::ClassUnicode::empty();\n360             for set in ages(property_value)? {\n361                 class.union(&hir_class(set));\n362             }\n363             Ok(class)\n364         }\n365         ByValue { property_name: \"Script_Extensions\", property_value } => {\n366             script_extension(property_value)\n367         }\n368         ByValue {\n369             property_name: \"Grapheme_Cluster_Break\",\n370             property_value,\n371         } => gcb(property_value),\n372         ByValue { property_name: \"Sentence_Break\", property_value } => {\n373             sb(property_value)\n374         }\n375         ByValue { property_name: \"Word_Break\", property_value } => {\n376             wb(property_value)\n377         }\n378         _ => {\n379             // What else should we support?\n380             Err(Error::PropertyNotFound)\n381         }\n382     }\n383 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}