{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/pikevm.rs\n// crate name is regex_automata\n#[cfg(feature = \"internal-instrument-pikevm\")]\nuse core::cell::RefCell;\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n        sparse_set::SparseSet,\n    },\n};\n#[derive(Clone, Debug)]\npub struct PikeVM {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug)]\nstruct SlotTable {\n    /// The actual table of offsets.\n    table: Vec<Option<NonMaxUsize>>,\n    /// The number of slots per state, i.e., the table's stride or the length\n    /// of each row.\n    slots_per_state: usize,\n    /// The number of slots in the caller-provided 'Captures' value for the\n    /// current search. Setting this to 'slots_per_state' is always correct,\n    /// but may be wasteful.\n    slots_for_captures: usize,\n}\n#[derive(Clone)]\npub(crate) struct SparseSet {\n    /// The number of elements currently in this set.\n    len: usize,\n    /// Dense contains the ids in the order in which they were inserted.\n    dense: Vec<StateID>,\n    /// Sparse maps ids to their location in dense.\n    ///\n    /// A state ID is in the set if and only if\n    /// sparse[id] < len && id == dense[sparse[id]].\n    ///\n    /// Note that these are indices into 'dense'. It's a little weird to use\n    /// StateID here, but we know our length can never exceed the bounds of\n    /// StateID (enforced by 'resize') and StateID will be at most 4 bytes\n    /// where as a usize is likely double that in most cases.\n    sparse: Vec<StateID>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Debug)]\nstruct ActiveStates {\n    /// The set of active NFA states. This set preserves insertion order, which\n    /// is critical for simulating the match semantics of backtracking regex\n    /// engines.\n    set: SparseSet,\n    /// The slots for every NFA state, where each slot stores a (possibly\n    /// absent) offset. Every capturing group has two slots. One for a start\n    /// offset and one for an end offset.\n    slot_table: SlotTable,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Look {\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    Start = 1 << 0,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    End = 1 << 1,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLF = 1 << 2,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\n` character.\n    EndLF = 1 << 3,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following either a `\\r` or `\\n` character, but never after\n    /// a `\\r` when a `\\n` follows.\n    StartCRLF = 1 << 4,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\r` or `\\n` character, but never before a `\\n` when a `\\r`\n    /// precedes it.\n    EndCRLF = 1 << 5,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordAscii = 1 << 6,\n    /// Match an ASCII-only negation of a word boundary.\n    WordAsciiNegate = 1 << 7,\n    /// Match a Unicode-aware word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordUnicode = 1 << 8,\n    /// Match a Unicode-aware negation of a word boundary.\n    WordUnicodeNegate = 1 << 9,\n    /// Match the start of an ASCII-only word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStartAscii = 1 << 10,\n    /// Match the end of an ASCII-only word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEndAscii = 1 << 11,\n    /// Match the start of a Unicode word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStartUnicode = 1 << 12,\n    /// Match the end of a Unicode word boundary. That is, this matches a\n    /// position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEndUnicode = 1 << 13,\n    /// Match the start half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalfAscii = 1 << 14,\n    /// Match the end half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the end of the haystack or where the\n    /// following character is not a word character.\n    WordEndHalfAscii = 1 << 15,\n    /// Match the start half of a Unicode word boundary. That is, this matches\n    /// a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalfUnicode = 1 << 16,\n    /// Match the end half of a Unicode word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the following\n    /// character is not a word character.\n    WordEndHalfUnicode = 1 << 17,\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\n#[derive(Clone, Debug)]\nenum FollowEpsilon {\n    /// Explore the epsilon transitions from a state ID.\n    Explore(StateID),\n    /// Reset the given `slot` to the given `offset` (which might be `None`).\n    RestoreCapture { slot: SmallIndex, offset: Option<NonMaxUsize> },\n}\nimpl PikeVM {\n    fn search_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {}\n    fn which_overlapping_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn nexts(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn nexts_overlapping(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        patset: &mut PatternSet,\n    ) {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slot_table: &mut SlotTable,\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        sid: StateID,\n    ) -> Option<PatternID> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn epsilon_closure(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        sid: StateID,\n    ) {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn epsilon_closure_explore(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        input: &Input<'_>,\n        at: usize,\n        mut sid: StateID,\n    ) {\n        loop {\n            instrument!(| c | c.record_set_insert(sid));\n            if !next.set.insert(sid) {\n                return;\n            }\n            match *self.nfa.state(sid) {\n                State::Fail\n                | State::Match { .. }\n                | State::ByteRange { .. }\n                | State::Sparse { .. }\n                | State::Dense { .. } => {\n                    next.slot_table.for_state(sid).copy_from_slice(curr_slots);\n                    return;\n                }\n                State::Look { look, next } => {\n                    if !self\n                        .nfa\n                        .look_matcher()\n                        .matches_inline(look, input.haystack(), at)\n                    {\n                        return;\n                    }\n                    sid = next;\n                }\n                State::Union { ref alternates } => {\n                    sid = match alternates.get(0) {\n                        None => return,\n                        Some(&sid) => sid,\n                    };\n                    instrument!(\n                        | c | { for & alt in & alternates[1..] { c\n                        .record_stack_push(alt); } }\n                    );\n                    stack\n                        .extend(\n                            alternates[1..]\n                                .iter()\n                                .copied()\n                                .rev()\n                                .map(FollowEpsilon::Explore),\n                        );\n                }\n                State::BinaryUnion { alt1, alt2 } => {\n                    sid = alt1;\n                    instrument!(| c | c.record_stack_push(sid));\n                    stack.push(FollowEpsilon::Explore(alt2));\n                }\n                State::Capture { next, slot, .. } => {\n                    if slot.as_usize() < curr_slots.len() {\n                        instrument!(| c | c.record_stack_push(sid));\n                        stack\n                            .push(FollowEpsilon::RestoreCapture {\n                                slot,\n                                offset: curr_slots[slot],\n                            });\n                        curr_slots[slot] = Some(NonMaxUsize::new(at).unwrap());\n                    }\n                    sid = next;\n                }\n            }\n        }\n    }\n    fn start_config(&self, input: &Input<'_>) -> Option<(bool, StateID)> {}\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {\n        &self.states()[id]\n    }\n    #[inline]\n    pub fn states(&self) -> &[State] {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {}\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {}\n    #[inline]\n    pub fn is_utf8(&self) -> bool {}\n    #[inline]\n    pub fn is_reverse(&self) -> bool {}\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {\n        &self.0.look_matcher\n    }\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {}\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl SlotTable {\n    fn new() -> SlotTable {}\n    fn reset(&mut self, re: &PikeVM) {}\n    fn memory_usage(&self) -> usize {}\n    fn setup_search(&mut self, captures_slot_len: usize) {}\n    fn for_state(&mut self, sid: StateID) -> &mut [Option<NonMaxUsize>] {\n        let i = sid.as_usize() * self.slots_per_state;\n        &mut self.table[i..i + self.slots_for_captures]\n    }\n    fn all_absent(&mut self) -> &mut [Option<NonMaxUsize>] {}\n}\nimpl SparseSet {\n    #[inline]\n    pub(crate) fn new(capacity: usize) -> SparseSet {}\n    #[inline]\n    pub(crate) fn resize(&mut self, new_capacity: usize) {}\n    #[inline]\n    pub(crate) fn capacity(&self) -> usize {}\n    #[inline]\n    pub(crate) fn len(&self) -> usize {}\n    #[inline]\n    pub(crate) fn is_empty(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn insert(&mut self, id: StateID) -> bool {\n        if self.contains(id) {\n            return false;\n        }\n        let i = self.len();\n        assert!(\n            i < self.capacity(), \"{:?} exceeds capacity of {:?} when inserting {:?}\", i,\n            self.capacity(), id,\n        );\n        let index = StateID::new_unchecked(i);\n        self.dense[index] = id;\n        self.sparse[id] = index;\n        self.len += 1;\n        true\n    }\n    #[inline]\n    pub(crate) fn contains(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn clear(&mut self) {}\n    #[inline]\n    pub(crate) fn iter(&self) -> SparseSetIter<'_> {}\n    #[inline]\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl NonMaxUsize {\n    #[inline]\n    pub fn new(value: usize) -> Option<NonMaxUsize> {\n        NonZeroUsize::new(value.wrapping_add(1)).map(NonMaxUsize)\n    }\n    #[inline]\n    pub fn get(self) -> usize {}\n}\nimpl LookMatcher {\n    pub fn new() -> LookMatcher {}\n    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {}\n    pub fn get_line_terminator(&self) -> u8 {}\n    #[inline]\n    pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_inline(&self, look: Look, haystack: &[u8], at: usize) -> bool {\n        match look {\n            Look::Start => self.is_start(haystack, at),\n            Look::End => self.is_end(haystack, at),\n            Look::StartLF => self.is_start_lf(haystack, at),\n            Look::EndLF => self.is_end_lf(haystack, at),\n            Look::StartCRLF => self.is_start_crlf(haystack, at),\n            Look::EndCRLF => self.is_end_crlf(haystack, at),\n            Look::WordAscii => self.is_word_ascii(haystack, at),\n            Look::WordAsciiNegate => self.is_word_ascii_negate(haystack, at),\n            Look::WordUnicode => self.is_word_unicode(haystack, at).unwrap(),\n            Look::WordUnicodeNegate => self.is_word_unicode_negate(haystack, at).unwrap(),\n            Look::WordStartAscii => self.is_word_start_ascii(haystack, at),\n            Look::WordEndAscii => self.is_word_end_ascii(haystack, at),\n            Look::WordStartUnicode => self.is_word_start_unicode(haystack, at).unwrap(),\n            Look::WordEndUnicode => self.is_word_end_unicode(haystack, at).unwrap(),\n            Look::WordStartHalfAscii => self.is_word_start_half_ascii(haystack, at),\n            Look::WordEndHalfAscii => self.is_word_end_half_ascii(haystack, at),\n            Look::WordStartHalfUnicode => {\n                self.is_word_start_half_unicode(haystack, at).unwrap()\n            }\n            Look::WordEndHalfUnicode => {\n                self.is_word_end_half_unicode(haystack, at).unwrap()\n            }\n        }\n    }\n    #[inline]\n    pub fn matches_set(&self, set: LookSet, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_set_inline(\n        &self,\n        set: LookSet,\n        haystack: &[u8],\n        at: usize,\n    ) -> bool {}\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn add_to_byteset(\n        &self,\n        look: Look,\n        set: &mut crate::util::alphabet::ByteClassSet,\n    ) {}\n    #[inline]\n    pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_unicode_negate(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {}\n    #[inline]\n    pub fn end(&self) -> usize {}\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl SmallIndex {\n    #[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n    pub const MAX: SmallIndex = SmallIndex::new_unchecked(core::i32::MAX as usize - 1);\n    #[cfg(target_pointer_width = \"16\")]\n    pub const MAX: SmallIndex = SmallIndex::new_unchecked(core::isize::MAX - 1);\n    pub const LIMIT: usize = SmallIndex::MAX.as_usize() + 1;\n    pub const ZERO: SmallIndex = SmallIndex::new_unchecked(0);\n    pub const SIZE: usize = core::mem::size_of::<SmallIndex>();\n    #[inline]\n    pub fn new(index: usize) -> Result<SmallIndex, SmallIndexError> {}\n    #[inline]\n    pub const fn new_unchecked(index: usize) -> SmallIndex {}\n    #[inline]\n    pub fn must(index: usize) -> SmallIndex {}\n    #[inline]\n    pub const fn as_usize(&self) -> usize {\n        self.0 as usize\n    }\n    #[inline]\n    pub const fn as_u64(&self) -> u64 {}\n    #[inline]\n    pub const fn as_u32(&self) -> u32 {}\n    #[inline]\n    pub const fn as_i32(&self) -> i32 {}\n    #[inline]\n    pub fn one_more(&self) -> usize {}\n    #[inline]\n    pub fn from_ne_bytes(bytes: [u8; 4]) -> Result<SmallIndex, SmallIndexError> {}\n    #[inline]\n    pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> SmallIndex {}\n    #[inline]\n    pub fn to_ne_bytes(&self) -> [u8; 4] {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Explore all of the epsilon transitions out of 'sid'. This is mostly\n/// split out from 'epsilon_closure' in order to clearly delineate\n/// the actual work of computing an epsilon closure from the stack\n/// book-keeping.\n///\n/// This will push any additional explorations needed on to 'stack'.\n///\n/// 'curr_slots' should refer to the slots for the currently active NFA\n/// state. That is, the current state we are stepping through. These\n/// slots are mutated in place as new 'Captures' states are traversed\n/// during epsilon closure, but the slots are restored to their original\n/// values once the full epsilon closure is completed. The ultimate use of\n/// 'curr_slots' is to copy them to the corresponding 'next_slots', so that\n/// the capturing group spans are forwarded from the currently active state\n/// to the next.\n///\n/// 'next' refers to the next set of active states. Computing an epsilon\n/// closure may increase the next set of active states.\n///\n/// 'input' refers to the caller's input configuration and 'at' refers to\n/// the current position in the haystack. These are used to check whether\n/// conditional epsilon transitions (like look-around) are satisfied at\n/// the current position. If they aren't, then the epsilon closure won't\n/// include them.\n1664 fn epsilon_closure_explore(\n1665     &self,\n1666     stack: &mut Vec<FollowEpsilon>,\n1667     curr_slots: &mut [Option<NonMaxUsize>],\n1668     next: &mut ActiveStates,\n1669     input: &Input<'_>,\n1670     at: usize,\n1671     mut sid: StateID,\n1672 ) {\n1673     // We can avoid pushing some state IDs on to our stack in precisely\n1674     // the cases where a 'push(x)' would be immediately followed by a 'x\n1675     // = pop()'. This is achieved by this outer-loop. We simply set 'sid'\n1676     // to be the next state ID we want to explore once we're done with\n1677     // our initial exploration. In practice, this avoids a lot of stack\n1678     // thrashing.\n1679     loop {\n1680         instrument!(|c| c.record_set_insert(sid));\n1681         // Record this state as part of our next set of active states. If\n1682         // we've already explored it, then no need to do it again.\n1683         if !next.set.insert(sid) {\n1684             return;\n1685         }\n1686         match *self.nfa.state(sid) {\n1687             State::Fail\n1688             | State::Match { .. }\n1689             | State::ByteRange { .. }\n1690             | State::Sparse { .. }\n1691             | State::Dense { .. } => {\n1692                 next.slot_table.for_state(sid).copy_from_slice(curr_slots);\n1693                 return;\n1694             }\n1695             State::Look { look, next } => {\n1696                 // OK because we don't permit building a searcher with a\n1697                 // Unicode word boundary if the requisite Unicode data is\n1698                 // unavailable.\n1699                 if !self.nfa.look_matcher().matches_inline(\n1700                     look,\n1701                     input.haystack(),\n1702                     at,\n1703                 ) {\n1704                     return;\n1705                 }\n1706                 sid = next;\n1707             }\n1708             State::Union { ref alternates } => {\n1709                 sid = match alternates.get(0) {\n1710                     None => return,\n1711                     Some(&sid) => sid,\n1712                 };\n1713                 instrument!(|c| {\n1714                     for &alt in &alternates[1..] {\n1715                         c.record_stack_push(alt);\n1716                     }\n1717                 });\n1718                 stack.extend(\n1719                     alternates[1..]\n1720                         .iter()\n1721                         .copied()\n1722                         .rev()\n1723                         .map(FollowEpsilon::Explore),\n1724                 );\n1725             }\n1726             State::BinaryUnion { alt1, alt2 } => {\n1727                 sid = alt1;\n1728                 instrument!(|c| c.record_stack_push(sid));\n1729                 stack.push(FollowEpsilon::Explore(alt2));\n1730             }\n1731             State::Capture { next, slot, .. } => {\n1732                 // There's no need to do anything with slots that\n1733                 // ultimately won't be copied into the caller-provided\n1734                 // 'Captures' value. So we just skip dealing with them at\n1735                 // all.\n1736                 if slot.as_usize() < curr_slots.len() {\n1737                     instrument!(|c| c.record_stack_push(sid));\n1738                     stack.push(FollowEpsilon::RestoreCapture {\n1739                         slot,\n1740                         offset: curr_slots[slot],\n1741                     });\n1742                     // OK because length of a slice must fit into an isize.\n1743                     curr_slots[slot] = Some(NonMaxUsize::new(at).unwrap());\n1744                 }\n1745                 sid = next;\n1746             }\n1747         }\n1748     }\n1749 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}