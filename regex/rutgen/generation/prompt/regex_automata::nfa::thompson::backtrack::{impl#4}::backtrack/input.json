{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/backtrack.rs\n// crate name is regex_automata\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchError, Span},\n    },\n};\n#[derive(Clone, Debug)]\npub struct BoundedBacktracker {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used on the heap for doing backtracking instead of the\n    /// traditional recursive approach. We don't want recursion because then\n    /// we're likely to hit a stack overflow for bigger regexes.\n    stack: Vec<Frame>,\n    /// The set of (StateID, HaystackOffset) pairs that have been visited\n    /// by the backtracker within a single search. If such a pair has been\n    /// visited, then we avoid doing the work for that pair again. This is\n    /// what \"bounds\" the backtracking and prevents it from having worst case\n    /// exponential time.\n    visited: Visited,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug)]\nenum Frame {\n    /// Look for a match starting at `sid` and the given position in the\n    /// haystack.\n    Step { sid: StateID, at: usize },\n    /// Reset the given `slot` to the given `offset` (which might be `None`).\n    /// This effectively gives a \"scope\" to capturing groups, such that an\n    /// offset for a particular group only gets returned if the match goes\n    /// through that capturing group. If backtracking ends up going down a\n    /// different branch that results in a different offset (or perhaps none at\n    /// all), then this \"restore capture\" frame will cause the offset to get\n    /// reset.\n    RestoreCapture { slot: SmallIndex, offset: Option<NonMaxUsize> },\n}\nimpl BoundedBacktracker {\n    #[inline]\n    pub fn try_search(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        caps: &mut Captures,\n    ) -> Result<(), MatchError> {}\n    #[inline]\n    pub fn try_search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<PatternID>, MatchError> {}\n    #[inline(never)]\n    fn try_search_slots_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    fn search_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn backtrack(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        at: usize,\n        start_id: StateID,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {\n        cache.stack.push(Frame::Step { sid: start_id, at });\n        while let Some(frame) = cache.stack.pop() {\n            match frame {\n                Frame::Step { sid, at } => {\n                    if let Some(hm) = self.step(cache, input, sid, at, slots) {\n                        return Some(hm);\n                    }\n                }\n                Frame::RestoreCapture { slot, offset } => {\n                    slots[slot] = offset;\n                }\n            }\n        }\n        None\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn step(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        mut sid: StateID,\n        mut at: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {\n        loop {\n            if !cache.visited.insert(sid, at - input.start()) {\n                return None;\n            }\n            match *self.nfa.state(sid) {\n                State::ByteRange { ref trans } => {\n                    if at >= input.end() {\n                        return None;\n                    }\n                    if !trans.matches(input.haystack(), at) {\n                        return None;\n                    }\n                    sid = trans.next;\n                    at += 1;\n                }\n                State::Sparse(ref sparse) => {\n                    if at >= input.end() {\n                        return None;\n                    }\n                    sid = sparse.matches(input.haystack(), at)?;\n                    at += 1;\n                }\n                State::Dense(ref dense) => {\n                    if at >= input.end() {\n                        return None;\n                    }\n                    sid = dense.matches(input.haystack(), at)?;\n                    at += 1;\n                }\n                State::Look { look, next } => {\n                    if !self\n                        .nfa\n                        .look_matcher()\n                        .matches_inline(look, input.haystack(), at)\n                    {\n                        return None;\n                    }\n                    sid = next;\n                }\n                State::Union { ref alternates } => {\n                    sid = match alternates.get(0) {\n                        None => return None,\n                        Some(&sid) => sid,\n                    };\n                    cache\n                        .stack\n                        .extend(\n                            alternates[1..]\n                                .iter()\n                                .copied()\n                                .rev()\n                                .map(|sid| Frame::Step { sid, at }),\n                        );\n                }\n                State::BinaryUnion { alt1, alt2 } => {\n                    sid = alt1;\n                    cache.stack.push(Frame::Step { sid: alt2, at });\n                }\n                State::Capture { next, slot, .. } => {\n                    if slot.as_usize() < slots.len() {\n                        cache\n                            .stack\n                            .push(Frame::RestoreCapture {\n                                slot,\n                                offset: slots[slot],\n                            });\n                        slots[slot] = NonMaxUsize::new(at);\n                    }\n                    sid = next;\n                }\n                State::Fail => return None,\n                State::Match { pattern_id } => {\n                    return Some(HalfMatch::new(pattern_id, at));\n                }\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Look for a match starting at `at` in `input` and write the matching\n/// pattern ID and group spans to `caps`. The search uses `start_id` as its\n/// starting state in the underlying NFA.\n///\n/// If no match was found, then the caller should increment `at` and try\n/// at the next position.\n1425 fn backtrack(\n1426     &self,\n1427     cache: &mut Cache,\n1428     input: &Input<'_>,\n1429     at: usize,\n1430     start_id: StateID,\n1431     slots: &mut [Option<NonMaxUsize>],\n1432 ) -> Option<HalfMatch> {\n1433     cache.stack.push(Frame::Step { sid: start_id, at });\n1434     while let Some(frame) = cache.stack.pop() {\n1435         match frame {\n1436             Frame::Step { sid, at } => {\n1437                 if let Some(hm) = self.step(cache, input, sid, at, slots) {\n1438                     return Some(hm);\n1439                 }\n1440             }\n1441             Frame::RestoreCapture { slot, offset } => {\n1442                 slots[slot] = offset;\n1443             }\n1444         }\n1445     }\n1446     None\n1447 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}