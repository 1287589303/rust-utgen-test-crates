{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/backtrack.rs\n// crate name is regex_automata\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchError, Span},\n    },\n};\n#[derive(Clone, Debug)]\npub struct BoundedBacktracker {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used on the heap for doing backtracking instead of the\n    /// traditional recursive approach. We don't want recursion because then\n    /// we're likely to hit a stack overflow for bigger regexes.\n    stack: Vec<Frame>,\n    /// The set of (StateID, HaystackOffset) pairs that have been visited\n    /// by the backtracker within a single search. If such a pair has been\n    /// visited, then we avoid doing the work for that pair again. This is\n    /// what \"bounds\" the backtracking and prevents it from having worst case\n    /// exponential time.\n    visited: Visited,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone, Debug)]\nenum Frame {\n    /// Look for a match starting at `sid` and the given position in the\n    /// haystack.\n    Step { sid: StateID, at: usize },\n    /// Reset the given `slot` to the given `offset` (which might be `None`).\n    /// This effectively gives a \"scope\" to capturing groups, such that an\n    /// offset for a particular group only gets returned if the match goes\n    /// through that capturing group. If backtracking ends up going down a\n    /// different branch that results in a different offset (or perhaps none at\n    /// all), then this \"restore capture\" frame will cause the offset to get\n    /// reset.\n    RestoreCapture { slot: SmallIndex, offset: Option<NonMaxUsize> },\n}\nimpl BoundedBacktracker {\n    #[inline]\n    pub fn try_search(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        caps: &mut Captures,\n    ) -> Result<(), MatchError> {}\n    #[inline]\n    pub fn try_search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<PatternID>, MatchError> {}\n    #[inline(never)]\n    fn try_search_slots_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    fn search_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn backtrack(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        at: usize,\n        start_id: StateID,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {\n        cache.stack.push(Frame::Step { sid: start_id, at });\n        while let Some(frame) = cache.stack.pop() {\n            match frame {\n                Frame::Step { sid, at } => {\n                    if let Some(hm) = self.step(cache, input, sid, at, slots) {\n                        return Some(hm);\n                    }\n                }\n                Frame::RestoreCapture { slot, offset } => {\n                    slots[slot] = offset;\n                }\n            }\n        }\n        None\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn step(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        mut sid: StateID,\n        mut at: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {\n        loop {\n            if !cache.visited.insert(sid, at - input.start()) {\n                return None;\n            }\n            match *self.nfa.state(sid) {\n                State::ByteRange { ref trans } => {\n                    if at >= input.end() {\n                        return None;\n                    }\n                    if !trans.matches(input.haystack(), at) {\n                        return None;\n                    }\n                    sid = trans.next;\n                    at += 1;\n                }\n                State::Sparse(ref sparse) => {\n                    if at >= input.end() {\n                        return None;\n                    }\n                    sid = sparse.matches(input.haystack(), at)?;\n                    at += 1;\n                }\n                State::Dense(ref dense) => {\n                    if at >= input.end() {\n                        return None;\n                    }\n                    sid = dense.matches(input.haystack(), at)?;\n                    at += 1;\n                }\n                State::Look { look, next } => {\n                    if !self\n                        .nfa\n                        .look_matcher()\n                        .matches_inline(look, input.haystack(), at)\n                    {\n                        return None;\n                    }\n                    sid = next;\n                }\n                State::Union { ref alternates } => {\n                    sid = match alternates.get(0) {\n                        None => return None,\n                        Some(&sid) => sid,\n                    };\n                    cache\n                        .stack\n                        .extend(\n                            alternates[1..]\n                                .iter()\n                                .copied()\n                                .rev()\n                                .map(|sid| Frame::Step { sid, at }),\n                        );\n                }\n                State::BinaryUnion { alt1, alt2 } => {\n                    sid = alt1;\n                    cache.stack.push(Frame::Step { sid: alt2, at });\n                }\n                State::Capture { next, slot, .. } => {\n                    if slot.as_usize() < slots.len() {\n                        cache\n                            .stack\n                            .push(Frame::RestoreCapture {\n                                slot,\n                                offset: slots[slot],\n                            });\n                        slots[slot] = NonMaxUsize::new(at);\n                    }\n                    sid = next;\n                }\n                State::Fail => return None,\n                State::Match { pattern_id } => {\n                    return Some(HalfMatch::new(pattern_id, at));\n                }\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Look for a match starting at `at` in `input` and write the matching\n/// pattern ID and group spans to `caps`. The search uses `start_id` as its\n/// starting state in the underlying NFA.\n///\n/// If no match was found, then the caller should increment `at` and try\n/// at the next position.\n1425 fn backtrack(\n1426     &self,\n1427     cache: &mut Cache,\n1428     input: &Input<'_>,\n1429     at: usize,\n1430     start_id: StateID,\n1431     slots: &mut [Option<NonMaxUsize>],\n1432 ) -> Option<HalfMatch> {\n1433     cache.stack.push(Frame::Step { sid: start_id, at });\n1434     while let Some(frame) = cache.stack.pop() {\n1435         match frame {\n1436             Frame::Step { sid, at } => {\n1437                 if let Some(hm) = self.step(cache, input, sid, at, slots) {\n1438                     return Some(hm);\n1439                 }\n1440             }\n1441             Frame::RestoreCapture { slot, offset } => {\n1442                 slots[slot] = offset;\n1443             }\n1444         }\n1445     }\n1446     None\n1447 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}