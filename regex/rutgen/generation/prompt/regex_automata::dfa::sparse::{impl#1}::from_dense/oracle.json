{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\npub(crate) trait Endian {\n    fn write_u16(n: u16, dst: &mut [u8]);\n    fn write_u32(n: u32, dst: &mut [u8]);\n    fn write_u128(n: u128, dst: &mut [u8]);\n}\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\n#[derive(Clone)]\npub struct DFA<T> {\n    tt: Transitions<T>,\n    st: StartTable<T>,\n    special: Special,\n    pre: Option<Prefilter>,\n    quitset: ByteSet,\n    flags: Flags,\n}\n#[derive(Clone)]\npub struct DFA<T> {\n    /// The transition table for this DFA. This includes the transitions\n    /// themselves, along with the stride, number of states and the equivalence\n    /// class mapping.\n    tt: TransitionTable<T>,\n    /// The set of starting state identifiers for this DFA. The starting state\n    /// IDs act as pointers into the transition table. The specific starting\n    /// state chosen for each search is dependent on the context at which the\n    /// search begins.\n    st: StartTable<T>,\n    /// The set of match states and the patterns that match for each\n    /// corresponding match state.\n    ///\n    /// This structure is technically only needed because of support for\n    /// multi-regexes. Namely, multi-regexes require answering not just whether\n    /// a match exists, but _which_ patterns match. So we need to store the\n    /// matching pattern IDs for each match state. We do this even when there\n    /// is only one pattern for the sake of simplicity. In practice, this uses\n    /// up very little space for the case of one pattern.\n    ms: MatchStates<T>,\n    /// Information about which states are \"special.\" Special states are states\n    /// that are dead, quit, matching, starting or accelerated. For more info,\n    /// see the docs for `Special`.\n    special: Special,\n    /// The accelerators for this DFA.\n    ///\n    /// If a state is accelerated, then there exist only a small number of\n    /// bytes that can cause the DFA to leave the state. This permits searching\n    /// to use optimized routines to find those specific bytes instead of using\n    /// the transition table.\n    ///\n    /// All accelerated states exist in a contiguous range in the DFA's\n    /// transition table. See dfa/special.rs for more details on how states are\n    /// arranged.\n    accels: Accels<T>,\n    /// Any prefilter attached to this DFA.\n    ///\n    /// Note that currently prefilters are not serialized. When deserializing\n    /// a DFA from bytes, this is always set to `None`.\n    pre: Option<Prefilter>,\n    /// The set of \"quit\" bytes for this DFA.\n    ///\n    /// This is only used when computing the start state for a particular\n    /// position in a haystack. Namely, in the case where there is a quit\n    /// byte immediately before the start of the search, this set needs to be\n    /// explicitly consulted. In all other cases, quit bytes are detected by\n    /// the DFA itself, by transitioning all quit bytes to a special \"quit\n    /// state.\"\n    quitset: ByteSet,\n    /// Various flags describing the behavior of this DFA.\n    flags: Flags,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\n#[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]\npub struct Unit(UnitKind);\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[cfg(feature = \"dfa-build\")]\nstruct StateMut<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a mut [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a mut [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a mut [u8],\n}\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]\npub(crate) struct ByteSet {\n    bits: BitSet,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone)]\npub(crate) struct StartTable<T> {\n    /// The initial start state IDs.\n    ///\n    /// In practice, T is either `Vec<u32>` or `&[u32]`.\n    ///\n    /// The first `2 * stride` (currently always 8) entries always correspond\n    /// to the starts states for the entire DFA, with the first 4 entries being\n    /// for unanchored searches and the second 4 entries being for anchored\n    /// searches. To keep things simple, we always use 8 entries even if the\n    /// `StartKind` is not both.\n    ///\n    /// After that, there are `stride * patterns` state IDs, where `patterns`\n    /// may be zero in the case of a DFA with no patterns or in the case where\n    /// the DFA was built without enabling starting states for each pattern.\n    table: T,\n    /// The starting state configuration supported. When 'both', both\n    /// unanchored and anchored searches work. When 'unanchored', anchored\n    /// searches panic. When 'anchored', unanchored searches panic.\n    kind: StartKind,\n    /// The start state configuration for every possible byte.\n    start_map: StartByteMap,\n    /// The number of starting state IDs per pattern.\n    stride: usize,\n    /// The total number of patterns for which starting states are encoded.\n    /// This is `None` for DFAs that were built without start states for each\n    /// pattern. Thus, one cannot use this field to say how many patterns\n    /// are in the DFA in all cases. It is specific to how many patterns are\n    /// represented in this start table.\n    pattern_len: Option<usize>,\n    /// The universal starting state for unanchored searches. This is only\n    /// present when the DFA supports unanchored searches and when all starting\n    /// state IDs for an unanchored search are equivalent.\n    universal_start_unanchored: Option<StateID>,\n    /// The universal starting state for anchored searches. This is only\n    /// present when the DFA supports anchored searches and when all starting\n    /// state IDs for an anchored search are equivalent.\n    universal_start_anchored: Option<StateID>,\n}\n#[derive(Clone)]\nstruct StartTable<T> {\n    /// The initial start state IDs as a contiguous table of native endian\n    /// encoded integers, represented by `S`.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8] and has no alignment\n    /// requirements.\n    ///\n    /// The first `2 * stride` (currently always 8) entries always correspond\n    /// to the starts states for the entire DFA, with the first 4 entries being\n    /// for unanchored searches and the second 4 entries being for anchored\n    /// searches. To keep things simple, we always use 8 entries even if the\n    /// `StartKind` is not both.\n    ///\n    /// After that, there are `stride * patterns` state IDs, where `patterns`\n    /// may be zero in the case of a DFA with no patterns or in the case where\n    /// the DFA was built without enabling starting states for each pattern.\n    table: T,\n    /// The starting state configuration supported. When 'both', both\n    /// unanchored and anchored searches work. When 'unanchored', anchored\n    /// searches panic. When 'anchored', unanchored searches panic.\n    kind: StartKind,\n    /// The start state configuration for every possible byte.\n    start_map: StartByteMap,\n    /// The number of starting state IDs per pattern.\n    stride: usize,\n    /// The total number of patterns for which starting states are encoded.\n    /// This is `None` for DFAs that were built without start states for each\n    /// pattern. Thus, one cannot use this field to say how many patterns\n    /// are in the DFA in all cases. It is specific to how many patterns are\n    /// represented in this start table.\n    pattern_len: Option<usize>,\n    /// The universal starting state for unanchored searches. This is only\n    /// present when the DFA supports unanchored searches and when all starting\n    /// state IDs for an unanchored search are equivalent.\n    universal_start_unanchored: Option<StateID>,\n    /// The universal starting state for anchored searches. This is only\n    /// present when the DFA supports anchored searches and when all starting\n    /// state IDs for an anchored search are equivalent.\n    universal_start_anchored: Option<StateID>,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Flags {\n    /// Whether the DFA can match the empty string. When this is false, all\n    /// matches returned by this DFA are guaranteed to have non-zero length.\n    pub(crate) has_empty: bool,\n    /// Whether the DFA should only produce matches with spans that correspond\n    /// to valid UTF-8. This also includes omitting any zero-width matches that\n    /// split the UTF-8 encoding of a codepoint.\n    pub(crate) is_utf8: bool,\n    /// Whether the DFA is always anchored or not, regardless of `Input`\n    /// configuration. This is useful for avoiding a reverse scan even when\n    /// executing unanchored searches.\n    pub(crate) is_always_start_anchored: bool,\n}\n#[derive(Clone)]\nstruct Transitions<T> {\n    /// The raw encoding of each state in this DFA.\n    ///\n    /// Each state has the following information:\n    ///\n    /// * A set of transitions to subsequent states. Transitions to the dead\n    ///   state are omitted.\n    /// * If the state can be accelerated, then any additional accelerator\n    ///   information.\n    /// * If the state is a match state, then the state contains all pattern\n    ///   IDs that match when in that state.\n    ///\n    /// To decode a state, use Transitions::state.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8].\n    sparse: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride and is documented above.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is\n    /// if the DFA's kind uses byte classes which is the default. Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    ///\n    /// N.B. Equivalence classes aren't particularly useful in a sparse DFA\n    /// in the current implementation, since equivalence classes generally tend\n    /// to correspond to continuous ranges of bytes that map to the same\n    /// transition. So in a sparse DFA, equivalence classes don't really lead\n    /// to a space savings. In the future, it would be good to try and remove\n    /// them from sparse DFAs entirely, but requires a bit of work since sparse\n    /// DFAs are built from dense DFAs, which are in turn built on top of\n    /// equivalence classes.\n    classes: ByteClasses,\n    /// The total number of states in this DFA. Note that a DFA always has at\n    /// least one state---the dead state---even the empty DFA. In particular,\n    /// the dead state always has ID 0 and is correspondingly always the first\n    /// state. The dead state is never a match state.\n    state_len: usize,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Debug)]\npub(crate) struct StateSparseTransitionIter<'a> {\n    dense: StateTransitionIter<'a>,\n    cur: Option<(alphabet::Unit, alphabet::Unit, StateID)>,\n}\npub(crate) struct StateIter<'a, T> {\n    tt: &'a TransitionTable<T>,\n    it: iter::Enumerate<slice::Chunks<'a, StateID>>,\n}\n#[cfg(feature = \"dfa-build\")]\nimpl DFA<Vec<u8>> {\n    pub fn always_match() -> Result<DFA<Vec<u8>>, BuildError> {}\n    pub fn never_match() -> Result<DFA<Vec<u8>>, BuildError> {}\n    pub(crate) fn from_dense<T: AsRef<[u32]>>(\n        dfa: &dense::DFA<T>,\n    ) -> Result<DFA<Vec<u8>>, BuildError> {\n        let mut sparse = Vec::with_capacity(StateID::SIZE * dfa.state_len());\n        let mut remap: Vec<StateID> = vec![DEAD; dfa.state_len()];\n        for state in dfa.states() {\n            let pos = sparse.len();\n            remap[dfa.to_index(state.id())] = StateID::new(pos)\n                .map_err(|_| BuildError::too_many_states())?;\n            sparse.push(0);\n            sparse.push(0);\n            let mut transition_len = 0;\n            for (unit1, unit2, _) in state.sparse_transitions() {\n                match (unit1.as_u8(), unit2.as_u8()) {\n                    (Some(b1), Some(b2)) => {\n                        transition_len += 1;\n                        sparse.push(b1);\n                        sparse.push(b2);\n                    }\n                    (None, None) => {}\n                    (Some(_), None) | (None, Some(_)) => unreachable!(),\n                }\n            }\n            transition_len += 1;\n            sparse.push(0);\n            sparse.push(0);\n            assert_ne!(transition_len, 0, \"transition length should be non-zero\",);\n            assert!(\n                transition_len <= 257, \"expected transition length {} to be <= 257\",\n                transition_len,\n            );\n            let ntrans = if dfa.is_match_state(state.id()) {\n                transition_len | (1 << 15)\n            } else {\n                transition_len\n            };\n            wire::NE::write_u16(ntrans, &mut sparse[pos..]);\n            let zeros = usize::try_from(transition_len)\n                .unwrap()\n                .checked_mul(StateID::SIZE)\n                .unwrap();\n            sparse.extend(iter::repeat(0).take(zeros));\n            if dfa.is_match_state(state.id()) {\n                let plen = dfa.match_pattern_len(state.id());\n                let mut pos = sparse.len();\n                let zeros = size_of::<u32>()\n                    .checked_mul(plen)\n                    .unwrap()\n                    .checked_add(size_of::<u32>())\n                    .unwrap();\n                sparse.extend(iter::repeat(0).take(zeros));\n                wire::NE::write_u32(\n                    plen.try_into().expect(\"pattern ID length fits in u32\"),\n                    &mut sparse[pos..],\n                );\n                pos += size_of::<u32>();\n                for &pid in dfa.pattern_id_slice(state.id()) {\n                    pos += wire::write_pattern_id::<wire::NE>(pid, &mut sparse[pos..]);\n                }\n            }\n            let accel = dfa.accelerator(state.id());\n            sparse.push(accel.len().try_into().unwrap());\n            sparse.extend_from_slice(accel);\n        }\n        let mut new = DFA {\n            tt: Transitions {\n                sparse,\n                classes: dfa.byte_classes().clone(),\n                state_len: dfa.state_len(),\n                pattern_len: dfa.pattern_len(),\n            },\n            st: StartTable::from_dense_dfa(dfa, &remap)?,\n            special: dfa.special().remap(|id| remap[dfa.to_index(id)]),\n            pre: dfa.get_prefilter().map(|p| p.clone()),\n            quitset: dfa.quitset().clone(),\n            flags: dfa.flags().clone(),\n        };\n        for old_state in dfa.states() {\n            let new_id = remap[dfa.to_index(old_state.id())];\n            let mut new_state = new.tt.state_mut(new_id);\n            let sparse = old_state.sparse_transitions();\n            for (i, (_, _, next)) in sparse.enumerate() {\n                let next = remap[dfa.to_index(next)];\n                new_state.set_next_at(i, next);\n            }\n        }\n        debug!(\n            \"created sparse DFA, memory usage: {} (dense memory usage: {})\", new\n            .memory_usage(), dfa.memory_usage(),\n        );\n        Ok(new)\n    }\n}\nimpl<T: AsRef<[u32]>> DFA<T> {\n    pub(crate) fn special(&self) -> &Special {\n        &self.special\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn special_mut(&mut self) -> &mut Special {}\n    pub(crate) fn quitset(&self) -> &ByteSet {\n        &self.quitset\n    }\n    pub(crate) fn flags(&self) -> &Flags {\n        &self.flags\n    }\n    pub(crate) fn states(&self) -> StateIter<'_, T> {\n        self.tt.states()\n    }\n    pub(crate) fn state_len(&self) -> usize {\n        self.tt.len()\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn pattern_id_slice(&self, id: StateID) -> &[PatternID] {\n        assert!(self.is_match_state(id));\n        self.ms.pattern_id_slice(self.match_state_index(id))\n    }\n    pub(crate) fn match_pattern_len(&self, id: StateID) -> usize {\n        assert!(self.is_match_state(id));\n        self.ms.pattern_len(self.match_state_index(id))\n    }\n    pub(crate) fn pattern_len(&self) -> usize {\n        self.ms.pattern_len\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn pattern_map(&self) -> BTreeMap<StateID, Vec<PatternID>> {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn quit_id(&self) -> StateID {}\n    pub(crate) fn to_index(&self, id: StateID) -> usize {\n        self.tt.to_index(id)\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn to_state_id(&self, index: usize) -> StateID {}\n    pub(crate) fn starts(&self) -> StartStateIter<'_> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn match_state_index(&self, id: StateID) -> usize {}\n    fn accelerator_index(&self, id: StateID) -> usize {}\n    fn accels(&self) -> Accels<&[u32]> {}\n    fn trans(&self) -> &[StateID] {}\n}\nimpl Special {\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn new() -> Special {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {\n        Special {\n            max: map(self.max),\n            quit_id: map(self.quit_id),\n            min_match: map(self.min_match),\n            max_match: map(self.max_match),\n            min_accel: map(self.min_accel),\n            max_accel: map(self.max_accel),\n            min_start: map(self.min_start),\n            max_start: map(self.max_start),\n        }\n    }\n    pub(crate) fn from_bytes(\n        mut slice: &[u8],\n    ) -> Result<(Special, usize), DeserializeError> {}\n    pub(crate) fn validate(&self) -> Result<(), DeserializeError> {}\n    pub(crate) fn validate_state_len(\n        &self,\n        len: usize,\n        stride2: usize,\n    ) -> Result<(), DeserializeError> {}\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_max(&mut self) {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_no_special_start_states(&mut self) {}\n    #[inline]\n    pub(crate) fn is_special_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_dead_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_quit_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_match_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_accel_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_start_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn match_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn matches(&self) -> bool {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn accel_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn accels(&self) -> bool {}\n    #[inline]\n    pub(crate) fn starts(&self) -> bool {}\n}\nimpl Unit {\n    pub fn u8(byte: u8) -> Unit {}\n    pub fn eoi(num_byte_equiv_classes: usize) -> Unit {}\n    pub fn as_u8(self) -> Option<u8> {\n        match self.0 {\n            UnitKind::U8(b) => Some(b),\n            UnitKind::EOI(_) => None,\n        }\n    }\n    pub fn as_eoi(self) -> Option<u16> {}\n    pub fn as_usize(self) -> usize {}\n    pub fn is_byte(self, byte: u8) -> bool {}\n    pub fn is_eoi(self) -> bool {}\n    pub fn is_word_byte(self) -> bool {}\n}\nimpl<'a> State<'a> {\n    pub(crate) fn transitions(&self) -> StateTransitionIter<'_> {}\n    pub(crate) fn sparse_transitions(&self) -> StateSparseTransitionIter<'_> {\n        StateSparseTransitionIter {\n            dense: self.transitions(),\n            cur: None,\n        }\n    }\n    pub(crate) fn id(&self) -> StateID {\n        self.id\n    }\n    #[cfg(feature = \"dfa-build\")]\n    fn accelerate(&self, classes: &ByteClasses) -> Option<Accel> {}\n}\n#[cfg(feature = \"dfa-build\")]\nimpl<'a> StateMut<'a> {\n    fn set_next_at(&mut self, i: usize, next: StateID) {\n        let start = i * StateID::SIZE;\n        let end = start + StateID::SIZE;\n        wire::write_state_id::<wire::NE>(next, &mut self.next[start..end]);\n    }\n}\npub(crate) fn write_pattern_id<E: Endian>(pid: PatternID, dst: &mut [u8]) -> usize {\n    E::write_u32(pid.as_u32(), dst);\n    PatternID::SIZE\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// The implementation for constructing a sparse DFA from a dense DFA.\n226 pub(crate) fn from_dense<T: AsRef<[u32]>>(\n227     dfa: &dense::DFA<T>,\n228 ) -> Result<DFA<Vec<u8>>, BuildError> {\n229     // In order to build the transition table, we need to be able to write\n230     // state identifiers for each of the \"next\" transitions in each state.\n231     // Our state identifiers correspond to the byte offset in the\n232     // transition table at which the state is encoded. Therefore, we do not\n233     // actually know what the state identifiers are until we've allocated\n234     // exactly as much space as we need for each state. Thus, construction\n235     // of the transition table happens in two passes.\n236     //\n237     // In the first pass, we fill out the shell of each state, which\n238     // includes the transition length, the input byte ranges and\n239     // zero-filled space for the transitions and accelerators, if present.\n240     // In this first pass, we also build up a map from the state identifier\n241     // index of the dense DFA to the state identifier in this sparse DFA.\n242     //\n243     // In the second pass, we fill in the transitions based on the map\n244     // built in the first pass.\n245 \n246     // The capacity given here reflects a minimum. (Well, the true minimum\n247     // is likely even bigger, but hopefully this saves a few reallocs.)\n248     let mut sparse = Vec::with_capacity(StateID::SIZE * dfa.state_len());\n249     // This maps state indices from the dense DFA to StateIDs in the sparse\n250     // DFA. We build out this map on the first pass, and then use it in the\n251     // second pass to back-fill our transitions.\n252     let mut remap: Vec<StateID> = vec![DEAD; dfa.state_len()];\n253     for state in dfa.states() {\n254         let pos = sparse.len();\n255 \n256         remap[dfa.to_index(state.id())] = StateID::new(pos)\n257             .map_err(|_| BuildError::too_many_states())?;\n258         // zero-filled space for the transition length\n259         sparse.push(0);\n260         sparse.push(0);\n261 \n262         let mut transition_len = 0;\n263         for (unit1, unit2, _) in state.sparse_transitions() {\n264             match (unit1.as_u8(), unit2.as_u8()) {\n265                 (Some(b1), Some(b2)) => {\n266                     transition_len += 1;\n267                     sparse.push(b1);\n268                     sparse.push(b2);\n269                 }\n270                 (None, None) => {}\n271                 (Some(_), None) | (None, Some(_)) => {\n272                     // can never occur because sparse_transitions never\n273                     // groups EOI with any other transition.\n274                     unreachable!()\n275                 }\n276             }\n277         }\n278         // Add dummy EOI transition. This is never actually read while\n279         // searching, but having space equivalent to the total number\n280         // of transitions is convenient. Otherwise, we'd need to track\n281         // a different number of transitions for the byte ranges as for\n282         // the 'next' states.\n283         //\n284         // N.B. The loop above is not guaranteed to yield the EOI\n285         // transition, since it may point to a DEAD state. By putting\n286         // it here, we always write the EOI transition, and thus\n287         // guarantee that our transition length is >0. Why do we always\n288         // need the EOI transition? Because in order to implement\n289         // Automaton::next_eoi_state, this lets us just ask for the last\n290         // transition. There are probably other/better ways to do this.\n291         transition_len += 1;\n292         sparse.push(0);\n293         sparse.push(0);\n294 \n295         // Check some assumptions about transition length.\n296         assert_ne!(\n297             transition_len, 0,\n298             \"transition length should be non-zero\",\n299         );\n300         assert!(\n301             transition_len <= 257,\n302             \"expected transition length {} to be <= 257\",\n303             transition_len,\n304         );\n305 \n306         // Fill in the transition length.\n307         // Since transition length is always <= 257, we use the most\n308         // significant bit to indicate whether this is a match state or\n309         // not.\n310         let ntrans = if dfa.is_match_state(state.id()) {\n311             transition_len | (1 << 15)\n312         } else {\n313             transition_len\n314         };\n315         wire::NE::write_u16(ntrans, &mut sparse[pos..]);\n316 \n317         // zero-fill the actual transitions.\n318         // Unwraps are OK since transition_length <= 257 and our minimum\n319         // support usize size is 16-bits.\n320         let zeros = usize::try_from(transition_len)\n321             .unwrap()\n322             .checked_mul(StateID::SIZE)\n323             .unwrap();\n324         sparse.extend(iter::repeat(0).take(zeros));\n325 \n326         // If this is a match state, write the pattern IDs matched by this\n327         // state.\n328         if dfa.is_match_state(state.id()) {\n329             let plen = dfa.match_pattern_len(state.id());\n330             // Write the actual pattern IDs with a u32 length prefix.\n331             // First, zero-fill space.\n332             let mut pos = sparse.len();\n333             // Unwraps are OK since it's guaranteed that plen <=\n334             // PatternID::LIMIT, which is in turn guaranteed to fit into a\n335             // u32.\n336             let zeros = size_of::<u32>()\n337                 .checked_mul(plen)\n338                 .unwrap()\n339                 .checked_add(size_of::<u32>())\n340                 .unwrap();\n341             sparse.extend(iter::repeat(0).take(zeros));\n342 \n343             // Now write the length prefix.\n344             wire::NE::write_u32(\n345                 // Will never fail since u32::MAX is invalid pattern ID.\n346                 // Thus, the number of pattern IDs is representable by a\n347                 // u32.\n348                 plen.try_into().expect(\"pattern ID length fits in u32\"),\n349                 &mut sparse[pos..],\n350             );\n351             pos += size_of::<u32>();\n352 \n353             // Now write the pattern IDs.\n354             for &pid in dfa.pattern_id_slice(state.id()) {\n355                 pos += wire::write_pattern_id::<wire::NE>(\n356                     pid,\n357                     &mut sparse[pos..],\n358                 );\n359             }\n360         }\n361 \n362         // And now add the accelerator, if one exists. An accelerator is\n363         // at most 4 bytes and at least 1 byte. The first byte is the\n364         // length, N. N bytes follow the length. The set of bytes that\n365         // follow correspond (exhaustively) to the bytes that must be seen\n366         // to leave this state.\n367         let accel = dfa.accelerator(state.id());\n368         sparse.push(accel.len().try_into().unwrap());\n369         sparse.extend_from_slice(accel);\n370     }\n371 \n372     let mut new = DFA {\n373         tt: Transitions {\n374             sparse,\n375             classes: dfa.byte_classes().clone(),\n376             state_len: dfa.state_len(),\n377             pattern_len: dfa.pattern_len(),\n378         },\n379         st: StartTable::from_dense_dfa(dfa, &remap)?,\n380         special: dfa.special().remap(|id| remap[dfa.to_index(id)]),\n381         pre: dfa.get_prefilter().map(|p| p.clone()),\n382         quitset: dfa.quitset().clone(),\n383         flags: dfa.flags().clone(),\n384     };\n385     // And here's our second pass. Iterate over all of the dense states\n386     // again, and update the transitions in each of the states in the\n387     // sparse DFA.\n388     for old_state in dfa.states() {\n389         let new_id = remap[dfa.to_index(old_state.id())];\n390         let mut new_state = new.tt.state_mut(new_id);\n391         let sparse = old_state.sparse_transitions();\n392         for (i, (_, _, next)) in sparse.enumerate() {\n393             let next = remap[dfa.to_index(next)];\n394             new_state.set_next_at(i, next);\n395         }\n396     }\n397     debug!(\n398         \"created sparse DFA, memory usage: {} (dense memory usage: {})\",\n399         new.memory_usage(),\n400         dfa.memory_usage(),\n401     );\n402     Ok(new)\n403 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}