{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/interpolate.rs\n// crate name is regex_lite\nuse alloc::string::String;\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\nstruct CaptureRef<'a> {\n    cap: Ref<'a>,\n    end: usize,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\nenum Ref<'a> {\n    Named(&'a str),\n    Number(usize),\n}\nfn find_cap_ref(replacement: &[u8]) -> Option<CaptureRef<'_>> {\n    let mut i = 0;\n    let rep: &[u8] = replacement;\n    if rep.len() <= 1 || rep[0] != b'$' {\n        return None;\n    }\n    i += 1;\n    if rep[i] == b'{' {\n        return find_cap_ref_braced(rep, i + 1);\n    }\n    let mut cap_end = i;\n    while rep.get(cap_end).copied().map_or(false, is_valid_cap_letter) {\n        cap_end += 1;\n    }\n    if cap_end == i {\n        return None;\n    }\n    let cap = core::str::from_utf8(&rep[i..cap_end]).expect(\"valid UTF-8 capture name\");\n    Some(CaptureRef {\n        cap: match cap.parse::<usize>() {\n            Ok(i) => Ref::Number(i),\n            Err(_) => Ref::Named(cap),\n        },\n        end: cap_end,\n    })\n}\nfn find_cap_ref_braced(rep: &[u8], mut i: usize) -> Option<CaptureRef<'_>> {\n    assert_eq!(b'{', rep[i.checked_sub(1).unwrap()]);\n    let start = i;\n    while rep.get(i).map_or(false, |&b| b != b'}') {\n        i += 1;\n    }\n    if !rep.get(i).map_or(false, |&b| b == b'}') {\n        return None;\n    }\n    let cap = match core::str::from_utf8(&rep[start..i]) {\n        Err(_) => return None,\n        Ok(cap) => cap,\n    };\n    Some(CaptureRef {\n        cap: match cap.parse::<usize>() {\n            Ok(i) => Ref::Number(i),\n            Err(_) => Ref::Named(cap),\n        },\n        end: i + 1,\n    })\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Parses a possible reference to a capture group name in the given text,\n/// starting at the beginning of `replacement`.\n///\n/// If no such valid reference could be found, None is returned.\n///\n/// Note that this returns a \"possible\" reference because this routine doesn't\n/// know whether the reference is to a valid group or not. If it winds up not\n/// being a valid reference, then it should be replaced with the empty string.\n213 fn find_cap_ref(replacement: &[u8]) -> Option<CaptureRef<'_>> {\n214     let mut i = 0;\n215     let rep: &[u8] = replacement;\n216     if rep.len() <= 1 || rep[0] != b'$' {\n217         return None;\n218     }\n219     i += 1;\n220     if rep[i] == b'{' {\n221         return find_cap_ref_braced(rep, i + 1);\n222     }\n223     let mut cap_end = i;\n224     while rep.get(cap_end).copied().map_or(false, is_valid_cap_letter) {\n225         cap_end += 1;\n226     }\n227     if cap_end == i {\n228         return None;\n229     }\n230     // We just verified that the range 0..cap_end is valid ASCII, so it must\n231     // therefore be valid UTF-8. If we really cared, we could avoid this UTF-8\n232     // check via an unchecked conversion or by parsing the number straight from\n233     // &[u8].\n234     let cap = core::str::from_utf8(&rep[i..cap_end])\n235         .expect(\"valid UTF-8 capture name\");\n236     Some(CaptureRef {\n237         cap: match cap.parse::<usize>() {\n238             Ok(i) => Ref::Number(i),\n239             Err(_) => Ref::Named(cap),\n240         },\n241         end: cap_end,\n242     })\n243 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}