{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/captures.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype CaptureNameMap = std::collections::HashMap<Arc<str>, SmallIndex>;\n#[cfg(not(feature = \"std\"))]\ntype CaptureNameMap = alloc::collections::BTreeMap<Arc<str>, SmallIndex>;\nuse alloc::{string::String, sync::Arc, vec, vec::Vec};\nuse crate::util::{\n    interpolate,\n    primitives::{NonMaxUsize, PatternID, PatternIDError, PatternIDIter, SmallIndex},\n    search::{Match, Span},\n};\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Debug, Default)]\nstruct GroupInfoInner {\n    slot_ranges: Vec<(SmallIndex, SmallIndex)>,\n    name_to_index: Vec<CaptureNameMap>,\n    index_to_name: Vec<Vec<Option<Arc<str>>>>,\n    memory_extra: usize,\n}\n#[derive(Clone, Debug)]\npub struct GroupInfoError {\n    kind: GroupInfoErrorKind,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct SmallIndexError {\n    attempted: u64,\n}\nimpl GroupInfo {\n    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>\n    where\n        P: IntoIterator<Item = G>,\n        G: IntoIterator<Item = Option<N>>,\n        N: AsRef<str>,\n    {\n        let mut group_info = GroupInfoInner {\n            slot_ranges: vec![],\n            name_to_index: vec![],\n            index_to_name: vec![],\n            memory_extra: 0,\n        };\n        for (pattern_index, groups) in pattern_groups.into_iter().enumerate() {\n            let pid = PatternID::new(pattern_index)\n                .map_err(GroupInfoError::too_many_patterns)?;\n            let mut groups_iter = groups.into_iter().enumerate();\n            match groups_iter.next() {\n                None => return Err(GroupInfoError::missing_groups(pid)),\n                Some((_, Some(_))) => {\n                    return Err(GroupInfoError::first_must_be_unnamed(pid));\n                }\n                Some((_, None)) => {}\n            }\n            group_info.add_first_group(pid);\n            for (group_index, maybe_name) in groups_iter {\n                let group = SmallIndex::new(group_index)\n                    .map_err(|_| { GroupInfoError::too_many_groups(pid, group_index) })?;\n                group_info.add_explicit_group(pid, group, maybe_name)?;\n            }\n        }\n        group_info.fixup_slot_ranges()?;\n        Ok(GroupInfo(Arc::new(group_info)))\n    }\n    pub fn empty() -> GroupInfo {}\n    #[inline]\n    pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {}\n    #[inline]\n    pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {}\n    #[inline]\n    pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {}\n    #[inline]\n    pub fn all_names(&self) -> GroupInfoAllNames<'_> {}\n    #[inline]\n    pub fn slots(&self, pid: PatternID, group_index: usize) -> Option<(usize, usize)> {}\n    #[inline]\n    pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn group_len(&self, pid: PatternID) -> usize {}\n    #[inline]\n    pub fn all_group_len(&self) -> usize {}\n    #[inline]\n    pub fn slot_len(&self) -> usize {}\n    #[inline]\n    pub fn implicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn explicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl GroupInfoInner {\n    fn add_first_group(&mut self, pid: PatternID) {\n        assert_eq!(pid.as_usize(), self.slot_ranges.len());\n        assert_eq!(pid.as_usize(), self.name_to_index.len());\n        assert_eq!(pid.as_usize(), self.index_to_name.len());\n        let slot_start = self.small_slot_len();\n        self.slot_ranges.push((slot_start, slot_start));\n        self.name_to_index.push(CaptureNameMap::new());\n        self.index_to_name.push(vec![None]);\n        self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();\n    }\n    fn add_explicit_group<N: AsRef<str>>(\n        &mut self,\n        pid: PatternID,\n        group: SmallIndex,\n        maybe_name: Option<N>,\n    ) -> Result<(), GroupInfoError> {\n        let end = &mut self.slot_ranges[pid].1;\n        *end = SmallIndex::new(end.as_usize() + 2)\n            .map_err(|_| { GroupInfoError::too_many_groups(pid, group.as_usize()) })?;\n        if let Some(name) = maybe_name {\n            let name = Arc::<str>::from(name.as_ref());\n            if self.name_to_index[pid].contains_key(&*name) {\n                return Err(GroupInfoError::duplicate(pid, &name));\n            }\n            let len = name.len();\n            self.name_to_index[pid].insert(Arc::clone(&name), group);\n            self.index_to_name[pid].push(Some(name));\n            self.memory_extra += 2 * (len + core::mem::size_of::<Option<Arc<str>>>());\n            self.memory_extra += core::mem::size_of::<SmallIndex>();\n        } else {\n            self.index_to_name[pid].push(None);\n            self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();\n        }\n        assert_eq!(group.one_more(), self.group_len(pid));\n        assert_eq!(group.one_more(), self.index_to_name[pid].len());\n        Ok(())\n    }\n    fn fixup_slot_ranges(&mut self) -> Result<(), GroupInfoError> {\n        use crate::util::primitives::IteratorIndexExt;\n        let offset = self.pattern_len().checked_mul(2).unwrap();\n        for (pid, &mut (ref mut start, ref mut end)) in self\n            .slot_ranges\n            .iter_mut()\n            .with_pattern_ids()\n        {\n            let group_len = 1 + ((end.as_usize() - start.as_usize()) / 2);\n            let new_end = match end.as_usize().checked_add(offset) {\n                Some(new_end) => new_end,\n                None => return Err(GroupInfoError::too_many_groups(pid, group_len)),\n            };\n            *end = SmallIndex::new(new_end)\n                .map_err(|_| { GroupInfoError::too_many_groups(pid, group_len) })?;\n            *start = SmallIndex::new(start.as_usize() + offset).unwrap();\n        }\n        Ok(())\n    }\n    fn pattern_len(&self) -> usize {}\n    fn group_len(&self, pid: PatternID) -> usize {}\n    fn small_slot_len(&self) -> SmallIndex {}\n}\nimpl GroupInfoError {\n    fn too_many_patterns(err: PatternIDError) -> GroupInfoError {}\n    fn too_many_groups(pattern: PatternID, minimum: usize) -> GroupInfoError {}\n    fn missing_groups(pattern: PatternID) -> GroupInfoError {\n        GroupInfoError {\n            kind: GroupInfoErrorKind::MissingGroups {\n                pattern,\n            },\n        }\n    }\n    fn first_must_be_unnamed(pattern: PatternID) -> GroupInfoError {\n        GroupInfoError {\n            kind: GroupInfoErrorKind::FirstMustBeUnnamed {\n                pattern,\n            },\n        }\n    }\n    fn duplicate(pattern: PatternID, name: &str) -> GroupInfoError {}\n}\nimpl SmallIndex {\n    #[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n    pub const MAX: SmallIndex = SmallIndex::new_unchecked(core::i32::MAX as usize - 1);\n    #[cfg(target_pointer_width = \"16\")]\n    pub const MAX: SmallIndex = SmallIndex::new_unchecked(core::isize::MAX - 1);\n    pub const LIMIT: usize = SmallIndex::MAX.as_usize() + 1;\n    pub const ZERO: SmallIndex = SmallIndex::new_unchecked(0);\n    pub const SIZE: usize = core::mem::size_of::<SmallIndex>();\n    #[inline]\n    pub fn new(index: usize) -> Result<SmallIndex, SmallIndexError> {\n        SmallIndex::try_from(index)\n    }\n    #[inline]\n    pub const fn new_unchecked(index: usize) -> SmallIndex {}\n    #[inline]\n    pub fn must(index: usize) -> SmallIndex {}\n    #[inline]\n    pub const fn as_usize(&self) -> usize {}\n    #[inline]\n    pub const fn as_u64(&self) -> u64 {}\n    #[inline]\n    pub const fn as_u32(&self) -> u32 {}\n    #[inline]\n    pub const fn as_i32(&self) -> i32 {}\n    #[inline]\n    pub fn one_more(&self) -> usize {}\n    #[inline]\n    pub fn from_ne_bytes(bytes: [u8; 4]) -> Result<SmallIndex, SmallIndexError> {}\n    #[inline]\n    pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> SmallIndex {}\n    #[inline]\n    pub fn to_ne_bytes(&self) -> [u8; 4] {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Creates a new group info from a sequence of patterns, where each\n/// sequence of patterns yields a sequence of possible group names. The\n/// index of each pattern in the sequence corresponds to its `PatternID`,\n/// and the index of each group in each pattern's sequence corresponds to\n/// its corresponding group index.\n///\n/// While this constructor is very generic and therefore perhaps hard to\n/// chew on, an example of a valid concrete type that can be passed to\n/// this constructor is `Vec<Vec<Option<String>>>`. The outer `Vec`\n/// corresponds to the patterns, i.e., one `Vec<Option<String>>` per\n/// pattern. The inner `Vec` corresponds to the capturing groups for\n/// each pattern. The `Option<String>` corresponds to the name of the\n/// capturing group, if present.\n///\n/// It is legal to pass an empty iterator to this constructor. It will\n/// return an empty group info with zero slots. An empty group info is\n/// useful for cases where you have no patterns or for cases where slots\n/// aren't being used at all (e.g., for most DFAs in this crate).\n///\n/// # Errors\n///\n/// This constructor returns an error if the given capturing groups are\n/// invalid in some way. Those reasons include, but are not necessarily\n/// limited to:\n///\n/// * Too many patterns (i.e., `PatternID` would overflow).\n/// * Too many capturing groups (e.g., `u32` would overflow).\n/// * A pattern is given that has no capturing groups. (All patterns must\n/// have at least an implicit capturing group at index `0`.)\n/// * The capturing group at index `0` has a name. It must be unnamed.\n/// * There are duplicate capturing group names within the same pattern.\n/// (Multiple capturing groups with the same name may exist, but they\n/// must be in different patterns.)\n///\n/// An example below shows how to trigger some of the above error\n/// conditions.\n///\n/// # Example\n///\n/// This example shows how to build a new `GroupInfo` and query it for\n/// information.\n///\n/// ```\n/// use regex_automata::util::captures::GroupInfo;\n///\n/// let info = GroupInfo::new(vec![\n///     vec![None, Some(\"foo\")],\n///     vec![None],\n///     vec![None, None, None, Some(\"bar\"), None],\n///     vec![None, None, Some(\"foo\")],\n/// ])?;\n/// // The number of patterns being tracked.\n/// assert_eq!(4, info.pattern_len());\n/// // 2 slots per group\n/// assert_eq!(22, info.slot_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: empty `GroupInfo`\n///\n/// This example shows how to build a new `GroupInfo` and query it for\n/// information.\n///\n/// ```\n/// use regex_automata::util::captures::GroupInfo;\n///\n/// let info = GroupInfo::empty();\n/// // Everything is zero.\n/// assert_eq!(0, info.pattern_len());\n/// assert_eq!(0, info.slot_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// # Example: error conditions\n///\n/// This example shows how to provoke some of the ways in which building\n/// a `GroupInfo` can fail.\n///\n/// ```\n/// use regex_automata::util::captures::GroupInfo;\n///\n/// // Either the group info is empty, or all patterns must have at least\n/// // one capturing group.\n/// assert!(GroupInfo::new(vec![\n///     vec![None, Some(\"a\")], // ok\n///     vec![None], // ok\n///     vec![], // not ok\n/// ]).is_err());\n/// // Note that building an empty group info is OK.\n/// assert!(GroupInfo::new(Vec::<Vec<Option<String>>>::new()).is_ok());\n///\n/// // The first group in each pattern must correspond to an implicit\n/// // anonymous group. i.e., One that is not named. By convention, this\n/// // group corresponds to the overall match of a regex. Every other group\n/// // in a pattern is explicit and optional.\n/// assert!(GroupInfo::new(vec![vec![Some(\"foo\")]]).is_err());\n///\n/// // There must not be duplicate group names within the same pattern.\n/// assert!(GroupInfo::new(vec![\n///     vec![None, Some(\"foo\"), Some(\"foo\")],\n/// ]).is_err());\n/// // But duplicate names across distinct patterns is OK.\n/// assert!(GroupInfo::new(vec![\n///     vec![None, Some(\"foo\")],\n///     vec![None, Some(\"foo\")],\n/// ]).is_ok());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// There are other ways for building a `GroupInfo` to fail but are\n/// difficult to show. For example, if the number of patterns given would\n/// overflow `PatternID`.\n1569 pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>\n1570 where\n1571     P: IntoIterator<Item = G>,\n1572     G: IntoIterator<Item = Option<N>>,\n1573     N: AsRef<str>,\n1574 {\n1575     let mut group_info = GroupInfoInner {\n1576         slot_ranges: vec![],\n1577         name_to_index: vec![],\n1578         index_to_name: vec![],\n1579         memory_extra: 0,\n1580     };\n1581     for (pattern_index, groups) in pattern_groups.into_iter().enumerate() {\n1582         // If we can't convert the pattern index to an ID, then the caller\n1583         // tried to build capture info for too many patterns.\n1584         let pid = PatternID::new(pattern_index)\n1585             .map_err(GroupInfoError::too_many_patterns)?;\n1586 \n1587         let mut groups_iter = groups.into_iter().enumerate();\n1588         match groups_iter.next() {\n1589             None => return Err(GroupInfoError::missing_groups(pid)),\n1590             Some((_, Some(_))) => {\n1591                 return Err(GroupInfoError::first_must_be_unnamed(pid))\n1592             }\n1593             Some((_, None)) => {}\n1594         }\n1595         group_info.add_first_group(pid);\n1596         // Now iterate over the rest, which correspond to all of the\n1597         // (conventionally) explicit capture groups in a regex pattern.\n1598         for (group_index, maybe_name) in groups_iter {\n1599             // Just like for patterns, if the group index can't be\n1600             // converted to a \"small\" index, then the caller has given too\n1601             // many groups for a particular pattern.\n1602             let group = SmallIndex::new(group_index).map_err(|_| {\n1603                 GroupInfoError::too_many_groups(pid, group_index)\n1604             })?;\n1605             group_info.add_explicit_group(pid, group, maybe_name)?;\n1606         }\n1607     }\n1608     group_info.fixup_slot_ranges()?;\n1609     Ok(GroupInfo(Arc::new(group_info)))\n1610 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}