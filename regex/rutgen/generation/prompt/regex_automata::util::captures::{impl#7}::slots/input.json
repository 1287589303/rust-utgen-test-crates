{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/captures.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype CaptureNameMap = std::collections::HashMap<Arc<str>, SmallIndex>;\n#[cfg(not(feature = \"std\"))]\ntype CaptureNameMap = alloc::collections::BTreeMap<Arc<str>, SmallIndex>;\nuse alloc::{string::String, sync::Arc, vec, vec::Vec};\nuse crate::util::{\n    interpolate,\n    primitives::{NonMaxUsize, PatternID, PatternIDError, PatternIDIter, SmallIndex},\n    search::{Match, Span},\n};\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Debug, Default)]\nstruct GroupInfoInner {\n    slot_ranges: Vec<(SmallIndex, SmallIndex)>,\n    name_to_index: Vec<CaptureNameMap>,\n    index_to_name: Vec<Vec<Option<Arc<str>>>>,\n    memory_extra: usize,\n}\nimpl GroupInfo {\n    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>\n    where\n        P: IntoIterator<Item = G>,\n        G: IntoIterator<Item = Option<N>>,\n        N: AsRef<str>,\n    {}\n    pub fn empty() -> GroupInfo {}\n    #[inline]\n    pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {}\n    #[inline]\n    pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {}\n    #[inline]\n    pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {}\n    #[inline]\n    pub fn all_names(&self) -> GroupInfoAllNames<'_> {}\n    #[inline]\n    pub fn slots(&self, pid: PatternID, group_index: usize) -> Option<(usize, usize)> {\n        self.slot(pid, group_index).map(|start| (start, start + 1))\n    }\n    #[inline]\n    pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {\n        if group_index >= self.group_len(pid) {\n            return None;\n        }\n        if group_index == 0 {\n            Some(pid.as_usize() * 2)\n        } else {\n            let (start, _) = self.0.slot_ranges[pid];\n            Some(start.as_usize() + ((group_index - 1) * 2))\n        }\n    }\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn group_len(&self, pid: PatternID) -> usize {}\n    #[inline]\n    pub fn all_group_len(&self) -> usize {}\n    #[inline]\n    pub fn slot_len(&self) -> usize {}\n    #[inline]\n    pub fn implicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn explicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the starting and ending slot corresponding to the given\n/// capturing group for the given pattern. The ending slot is always one\n/// more than the starting slot returned.\n///\n/// Note that this is like [`GroupInfo::slot`], except that it also returns\n/// the ending slot value for convenience.\n///\n/// If either the pattern ID or the capture index is invalid, then this\n/// returns None.\n///\n/// # Example\n///\n/// This example shows that the starting slots for the first capturing\n/// group of each pattern are distinct.\n///\n/// ```\n/// use regex_automata::{nfa::thompson::NFA, PatternID};\n///\n/// let nfa = NFA::new_many(&[\"a\", \"b\"])?;\n/// assert_ne!(\n///     nfa.group_info().slots(PatternID::must(0), 0),\n///     nfa.group_info().slots(PatternID::must(1), 0),\n/// );\n///\n/// // Also, the start and end slot values are never equivalent.\n/// let (start, end) = nfa.group_info().slots(PatternID::ZERO, 0).unwrap();\n/// assert_ne!(start, end);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n1869 pub fn slots(\n1870     &self,\n1871     pid: PatternID,\n1872     group_index: usize,\n1873 ) -> Option<(usize, usize)> {\n1874     // Since 'slot' only even returns valid starting slots, we know that\n1875     // there must also be an end slot and that end slot is always one more\n1876     // than the start slot.\n1877     self.slot(pid, group_index).map(|start| (start, start + 1))\n1878 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}