{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/hir/mod.rs\n// crate name is regex_lite\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\nuse crate::{error::Error, utf8};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) struct Hir {\n    kind: HirKind,\n    is_start_anchored: bool,\n    is_match_empty: bool,\n    static_explicit_captures_len: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub(super) struct Parser<'a> {\n    /// The configuration of the parser as given by the caller.\n    config: Config,\n    /// The pattern we're parsing as given by the caller.\n    pattern: &'a str,\n    /// The call depth of the parser. This is incremented for each\n    /// sub-expression parsed. Its peak value is the maximum nesting of the\n    /// pattern.\n    depth: Cell<u32>,\n    /// The current position of the parser.\n    pos: Cell<usize>,\n    /// The current codepoint of the parser. The codepoint corresponds to the\n    /// codepoint encoded in `pattern` beginning at `pos`.\n    ///\n    /// This is `None` if and only if `pos == pattern.len()`.\n    char: Cell<Option<char>>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The flags that are currently set.\n    flags: RefCell<Flags>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<String>>,\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Config {\n    /// The maximum number of times we're allowed to recurse.\n    ///\n    /// Note that unlike the regex-syntax parser, we actually use recursion in\n    /// this parser for simplicity. My hope is that by setting a conservative\n    /// default call limit and providing a way to configure it, that we can\n    /// keep this simplification. But if we must, we can re-work the parser to\n    /// put the call stack on the heap like regex-syntax does.\n    pub(crate) nest_limit: u32,\n    /// Various flags that control how a pattern is interpreted.\n    pub(crate) flags: Flags,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    msg: &'static str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) enum HirKind {\n    Empty,\n    Char(char),\n    Class(Class),\n    Look(Look),\n    Repetition(Repetition),\n    Capture(Capture),\n    Concat(Vec<Hir>),\n    Alternation(Vec<Hir>),\n}\nimpl Hir {\n    pub(crate) fn parse(config: Config, pattern: &str) -> Result<Hir, Error> {\n        self::parse::Parser::new(config, pattern).parse()\n    }\n    pub(crate) fn kind(&self) -> &HirKind {}\n    pub(crate) fn is_start_anchored(&self) -> bool {}\n    pub(crate) fn is_match_empty(&self) -> bool {}\n    pub(crate) fn static_explicit_captures_len(&self) -> Option<usize> {}\n    fn fail() -> Hir {}\n    fn empty() -> Hir {}\n    fn char(ch: char) -> Hir {}\n    fn class(class: Class) -> Hir {}\n    fn look(look: Look) -> Hir {}\n    fn repetition(rep: Repetition) -> Hir {}\n    fn capture(cap: Capture) -> Hir {}\n    fn concat(mut subs: Vec<Hir>) -> Hir {}\n    fn alternation(mut subs: Vec<Hir>) -> Hir {}\n}\nimpl<'a> Parser<'a> {\n    pub(super) fn parse(&self) -> Result<Hir, Error> {\n        let hir = self.parse_inner()?;\n        check_hir_nesting(&hir, self.config.nest_limit)?;\n        Ok(hir)\n    }\n    fn parse_inner(&self) -> Result<Hir, Error> {}\n    fn parse_primitive(&self) -> Result<Hir, Error> {}\n    fn parse_escape(&self) -> Result<Hir, Error> {}\n    fn maybe_parse_special_word_boundary(&self) -> Result<Option<Hir>, Error> {}\n    fn parse_hex(&self) -> Result<Hir, Error> {}\n    fn parse_hex_digits(&self, digit_len: usize) -> Result<Hir, Error> {}\n    fn parse_hex_brace(&self) -> Result<Hir, Error> {}\n    fn parse_decimal(&self) -> Result<u32, Error> {}\n    fn parse_uncounted_repetition(\n        &self,\n        mut concat: Vec<Hir>,\n    ) -> Result<Vec<Hir>, Error> {}\n    fn parse_counted_repetition(&self, mut concat: Vec<Hir>) -> Result<Vec<Hir>, Error> {}\n    fn parse_group(&self) -> Result<Option<Hir>, Error> {}\n    fn parse_capture_name(&self) -> Result<&str, Error> {}\n    fn parse_flags(&self) -> Result<Flags, Error> {}\n    fn parse_flag(&self, flags: &mut Flags, negate: bool) -> Result<(), Error> {}\n    fn parse_class(&self) -> Result<Hir, Error> {}\n    fn parse_class_range(&self, union: &mut Vec<hir::ClassRange>) -> Result<(), Error> {}\n    fn parse_class_item(&self) -> Result<Hir, Error> {}\n    fn maybe_parse_posix_class(&self) -> Option<hir::Class> {}\n    fn parse_perl_class(&self) -> Hir {}\n    fn hir_dot(&self) -> Hir {}\n    fn hir_anchor_start(&self) -> Hir {}\n    fn hir_anchor_end(&self) -> Hir {}\n    fn hir_char(&self, ch: char) -> Hir {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Parses the given pattern string with the given configuration into a\n/// structured representation. If the pattern is invalid, then an error\n/// is returned.\n177 pub(crate) fn parse(config: Config, pattern: &str) -> Result<Hir, Error> {\n178     self::parse::Parser::new(config, pattern).parse()\n179 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}