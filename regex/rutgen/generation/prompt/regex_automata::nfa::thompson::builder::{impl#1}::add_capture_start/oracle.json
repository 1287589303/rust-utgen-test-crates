{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/builder.rs\n// crate name is regex_automata\nuse core::mem;\nuse alloc::{sync::Arc, vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{error::BuildError, nfa::{self, SparseTransitions, Transition, NFA}},\n    util::{\n        look::{Look, LookMatcher},\n        primitives::{IteratorIndexExt, PatternID, SmallIndex, StateID},\n    },\n};\n#[derive(Clone, Debug, Default)]\npub struct Builder {\n    /// The ID of the pattern that we're currently building.\n    ///\n    /// Callers are required to set (and unset) this by calling\n    /// {start,finish}_pattern. Otherwise, most methods will panic.\n    pattern_id: Option<PatternID>,\n    /// A sequence of intermediate NFA states. Once a state is added to this\n    /// sequence, it is assigned a state ID equivalent to its index. Once a\n    /// state is added, it is still expected to be mutated, e.g., to set its\n    /// transition to a state that didn't exist at the time it was added.\n    states: Vec<State>,\n    /// The starting states for each individual pattern. Starting at any\n    /// of these states will result in only an anchored search for the\n    /// corresponding pattern. The vec is indexed by pattern ID. When the NFA\n    /// contains a single regex, then `start_pattern[0]` and `start_anchored`\n    /// are always equivalent.\n    start_pattern: Vec<StateID>,\n    /// A map from pattern ID to capture group index to name. (If no name\n    /// exists, then a None entry is present. Thus, all capturing groups are\n    /// present in this mapping.)\n    ///\n    /// The outer vec is indexed by pattern ID, while the inner vec is indexed\n    /// by capture index offset for the corresponding pattern.\n    ///\n    /// The first capture group for each pattern is always unnamed and is thus\n    /// always None.\n    captures: Vec<Vec<Option<Arc<str>>>>,\n    /// The combined memory used by each of the 'State's in 'states'. This\n    /// only includes heap usage by each state, and not the size of the state\n    /// itself. In other words, this tracks heap memory used that isn't\n    /// captured via `size_of::<State>() * states.len()`.\n    memory_states: usize,\n    /// Whether this NFA only matches UTF-8 and whether regex engines using\n    /// this NFA for searching should report empty matches that split a\n    /// codepoint.\n    utf8: bool,\n    /// Whether this NFA should be matched in reverse or not.\n    reverse: bool,\n    /// The matcher to use for look-around assertions.\n    look_matcher: LookMatcher,\n    /// A size limit to respect when building an NFA. If the total heap memory\n    /// of the intermediate NFA states exceeds (or would exceed) this amount,\n    /// then an error is returned.\n    size_limit: Option<usize>,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct SmallIndex(u32);\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Default)]\nstruct State {\n    transitions: Vec<Transition>,\n    chunks: Vec<(usize, usize)>,\n}\n#[derive(Clone)]\nstruct State {\n    /// A sorted sequence of non-overlapping transitions to other states. Each\n    /// transition corresponds to a single range of bytes.\n    transitions: Vec<Transition>,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub(crate) struct State(Arc<[u8]>);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct SmallIndexError {\n    attempted: u64,\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum State {\n    /// An empty state whose only purpose is to forward the automaton to\n    /// another state via an unconditional epsilon transition.\n    ///\n    /// Unconditional epsilon transitions are quite useful during the\n    /// construction of an NFA, as they permit the insertion of no-op\n    /// placeholders that make it easier to compose NFA sub-graphs. When\n    /// the Thompson NFA builder produces a final NFA, all unconditional\n    /// epsilon transitions are removed, and state identifiers are remapped\n    /// accordingly.\n    Empty {\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// A state that only transitions to another state if the current input\n    /// byte is in a particular range of bytes.\n    ByteRange { trans: Transition },\n    /// A state with possibly many transitions, represented in a sparse\n    /// fashion. Transitions must be ordered lexicographically by input range\n    /// and be non-overlapping. As such, this may only be used when every\n    /// transition has equal priority. (In practice, this is only used for\n    /// encoding large UTF-8 automata.) In contrast, a `Union` state has each\n    /// alternate in order of priority. Priority is used to implement greedy\n    /// matching and also alternations themselves, e.g., `abc|a` where `abc`\n    /// has priority over `a`.\n    ///\n    /// To clarify, it is possible to remove `Sparse` and represent all things\n    /// that `Sparse` is used for via `Union`. But this creates a more bloated\n    /// NFA with more epsilon transitions than is necessary in the special case\n    /// of character classes.\n    Sparse { transitions: Vec<Transition> },\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around.\n    Look { look: Look, next: StateID },\n    /// An empty state that records the start of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureStart {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An empty state that records the end of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureEnd {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union { alternates: Vec<StateID> },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via later transitions are\n    /// preferred over earlier transitions.\n    ///\n    /// This \"reverse\" state exists for convenience during compilation that\n    /// permits easy construction of non-greedy combinations of NFA states. At\n    /// the end of compilation, Union and UnionReverse states are merged into\n    /// one Union type of state, where the latter has its epsilon transitions\n    /// reversed to reflect the priority inversion.\n    ///\n    /// The \"convenience\" here arises from the fact that as new states are\n    /// added to the list of `alternates`, we would like that add operation\n    /// to be amortized constant time. But if we used a `Union`, we'd need to\n    /// prepend the state, which takes O(n) time. There are other approaches we\n    /// could use to solve this, but this seems simple enough.\n    UnionReverse { alternates: Vec<StateID> },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose a\n    /// `Fail` state to represent it.\n    Fail,\n    /// A match state. There is at most one such occurrence of this state in\n    /// an NFA for each pattern compiled into the NFA. At time of writing, a\n    /// match state is always produced for every pattern given, but in theory,\n    /// if a pattern can never lead to a match, then the match state could be\n    /// omitted.\n    ///\n    /// `pattern_id` refers to the ID of the pattern itself, which corresponds\n    /// to the pattern's index (starting at 0).\n    Match { pattern_id: PatternID },\n}\nimpl Builder {\n    pub fn new() -> Builder {}\n    pub fn clear(&mut self) {}\n    pub fn build(\n        &self,\n        start_anchored: StateID,\n        start_unanchored: StateID,\n    ) -> Result<NFA, BuildError> {}\n    pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {}\n    pub fn finish_pattern(\n        &mut self,\n        start_id: StateID,\n    ) -> Result<PatternID, BuildError> {}\n    pub fn current_pattern_id(&self) -> PatternID {\n        self.pattern_id.expect(\"must call 'start_pattern' first\")\n    }\n    pub fn pattern_len(&self) -> usize {}\n    pub fn add_empty(&mut self) -> Result<StateID, BuildError> {}\n    pub fn add_union(\n        &mut self,\n        alternates: Vec<StateID>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_union_reverse(\n        &mut self,\n        alternates: Vec<StateID>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_range(&mut self, trans: Transition) -> Result<StateID, BuildError> {}\n    pub fn add_sparse(\n        &mut self,\n        transitions: Vec<Transition>,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_look(\n        &mut self,\n        next: StateID,\n        look: Look,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_capture_start(\n        &mut self,\n        next: StateID,\n        group_index: u32,\n        name: Option<Arc<str>>,\n    ) -> Result<StateID, BuildError> {\n        let pid = self.current_pattern_id();\n        let group_index = match SmallIndex::try_from(group_index) {\n            Err(_) => return Err(BuildError::invalid_capture_index(group_index)),\n            Ok(group_index) => group_index,\n        };\n        if pid.as_usize() >= self.captures.len() {\n            for _ in 0..=(pid.as_usize() - self.captures.len()) {\n                self.captures.push(vec![]);\n            }\n        }\n        if group_index.as_usize() >= self.captures[pid].len() {\n            for _ in 0..(group_index.as_usize() - self.captures[pid].len()) {\n                self.captures[pid].push(None);\n            }\n            self.captures[pid].push(name);\n        }\n        self.add(State::CaptureStart {\n            pattern_id: pid,\n            group_index,\n            next,\n        })\n    }\n    pub fn add_capture_end(\n        &mut self,\n        next: StateID,\n        group_index: u32,\n    ) -> Result<StateID, BuildError> {}\n    pub fn add_fail(&mut self) -> Result<StateID, BuildError> {}\n    pub fn add_match(&mut self) -> Result<StateID, BuildError> {}\n    fn add(&mut self, state: State) -> Result<StateID, BuildError> {\n        let id = StateID::new(self.states.len())\n            .map_err(|_| BuildError::too_many_states(self.states.len()))?;\n        self.memory_states += state.memory_usage();\n        self.states.push(state);\n        self.check_size_limit()?;\n        Ok(id)\n    }\n    pub fn patch(&mut self, from: StateID, to: StateID) -> Result<(), BuildError> {}\n    pub fn set_utf8(&mut self, yes: bool) {}\n    pub fn get_utf8(&self) -> bool {}\n    pub fn set_reverse(&mut self, yes: bool) {}\n    pub fn get_reverse(&self) -> bool {}\n    pub fn set_look_matcher(&mut self, m: LookMatcher) {}\n    pub fn get_look_matcher(&self) -> &LookMatcher {}\n    pub fn set_size_limit(&mut self, limit: Option<usize>) -> Result<(), BuildError> {}\n    pub fn get_size_limit(&self) -> Option<usize> {}\n    pub fn memory_usage(&self) -> usize {}\n    fn check_size_limit(&self) -> Result<(), BuildError> {}\n}\nimpl SmallIndex {\n    #[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n    pub const MAX: SmallIndex = SmallIndex::new_unchecked(core::i32::MAX as usize - 1);\n    #[cfg(target_pointer_width = \"16\")]\n    pub const MAX: SmallIndex = SmallIndex::new_unchecked(core::isize::MAX - 1);\n    pub const LIMIT: usize = SmallIndex::MAX.as_usize() + 1;\n    pub const ZERO: SmallIndex = SmallIndex::new_unchecked(0);\n    pub const SIZE: usize = core::mem::size_of::<SmallIndex>();\n    #[inline]\n    pub fn new(index: usize) -> Result<SmallIndex, SmallIndexError> {}\n    #[inline]\n    pub const fn new_unchecked(index: usize) -> SmallIndex {}\n    #[inline]\n    pub fn must(index: usize) -> SmallIndex {}\n    #[inline]\n    pub const fn as_usize(&self) -> usize {\n        self.0 as usize\n    }\n    #[inline]\n    pub const fn as_u64(&self) -> u64 {}\n    #[inline]\n    pub const fn as_u32(&self) -> u32 {}\n    #[inline]\n    pub const fn as_i32(&self) -> i32 {}\n    #[inline]\n    pub fn one_more(&self) -> usize {}\n    #[inline]\n    pub fn from_ne_bytes(bytes: [u8; 4]) -> Result<SmallIndex, SmallIndexError> {}\n    #[inline]\n    pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> SmallIndex {}\n    #[inline]\n    pub fn to_ne_bytes(&self) -> [u8; 4] {}\n}\nimpl BuildError {\n    pub fn size_limit(&self) -> Option<usize> {}\n    fn kind(&self) -> &BuildErrorKind {}\n    #[cfg(feature = \"syntax\")]\n    pub(crate) fn syntax(err: regex_syntax::Error) -> BuildError {}\n    pub(crate) fn captures(err: captures::GroupInfoError) -> BuildError {}\n    pub(crate) fn word(err: look::UnicodeWordBoundaryError) -> BuildError {}\n    pub(crate) fn too_many_patterns(given: usize) -> BuildError {}\n    pub(crate) fn too_many_states(given: usize) -> BuildError {}\n    pub(crate) fn exceeded_size_limit(limit: usize) -> BuildError {}\n    pub(crate) fn invalid_capture_index(index: u32) -> BuildError {\n        BuildError {\n            kind: BuildErrorKind::InvalidCaptureIndex {\n                index,\n            },\n        }\n    }\n    #[cfg(feature = \"syntax\")]\n    pub(crate) fn unsupported_captures() -> BuildError {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Add a \"start capture\" NFA state.\n///\n/// A \"start capture\" NFA state corresponds to a state with exactly one\n/// outgoing unconditional epsilon transition to another state. Unlike\n/// \"empty\" states, a \"start capture\" state also carries with it an\n/// instruction for saving the current position of input to a particular\n/// location in memory. NFA simulations, like the Pike VM, may use this\n/// information to report the match locations of capturing groups in a\n/// regex pattern.\n///\n/// If the corresponding capturing group has a name, then callers should\n/// include it here.\n///\n/// Callers may provide a \"dummy\" state ID (typically [`StateID::ZERO`]),\n/// and then change it later with [`patch`](Builder::patch).\n///\n/// Note that unlike `start_pattern`/`finish_pattern`, capturing start and\n/// end states may be interleaved. Indeed, it is typical for many \"start\n/// capture\" NFA states to appear before the first \"end capture\" state.\n///\n/// # Errors\n///\n/// This returns an error if the state identifier space is exhausted, or if\n/// the configured heap size limit has been exceeded or if the given\n/// capture index overflows `usize`.\n///\n/// While the above are the only conditions in which this routine can\n/// currently return an error, it is possible to call this method with an\n/// inputs that results in the final `build()` step failing to produce an\n/// NFA. For example, if one adds two distinct capturing groups with the\n/// same name, then that will result in `build()` failing with an error.\n///\n/// See the [`GroupInfo`](crate::util::captures::GroupInfo) type for\n/// more information on what qualifies as valid capturing groups.\n///\n/// # Example\n///\n/// This example shows that an error occurs when one tries to add multiple\n/// capturing groups with the same name to the same pattern.\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson::Builder,\n///     util::primitives::StateID,\n/// };\n///\n/// let name = Some(std::sync::Arc::from(\"foo\"));\n/// let mut builder = Builder::new();\n/// builder.start_pattern()?;\n/// // 0th capture group should always be unnamed.\n/// let start = builder.add_capture_start(StateID::ZERO, 0, None)?;\n/// // OK\n/// builder.add_capture_start(StateID::ZERO, 1, name.clone())?;\n/// // This is not OK, but 'add_capture_start' still succeeds. We don't\n/// // get an error until we call 'build' below. Without this call, the\n/// // call to 'build' below would succeed.\n/// builder.add_capture_start(StateID::ZERO, 2, name.clone())?;\n/// // Finish our pattern so we can try to build the NFA.\n/// builder.finish_pattern(start)?;\n/// let result = builder.build(start, start);\n/// assert!(result.is_err());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// However, adding multiple capturing groups with the same name to\n/// distinct patterns is okay:\n///\n/// ```\n/// use std::sync::Arc;\n///\n/// use regex_automata::{\n///     nfa::thompson::{pikevm::PikeVM, Builder, Transition},\n///     util::{\n///         captures::Captures,\n///         primitives::{PatternID, StateID},\n///     },\n///     Span,\n/// };\n///\n/// // Hand-compile the patterns '(?P<foo>[a-z])' and '(?P<foo>[A-Z])'.\n/// let mut builder = Builder::new();\n/// // We compile them to support an unanchored search, which requires\n/// // adding an implicit '(?s-u:.)*?' prefix before adding either pattern.\n/// let unanchored_prefix = builder.add_union_reverse(vec![])?;\n/// let any = builder.add_range(Transition {\n///     start: b'\\x00', end: b'\\xFF', next: StateID::ZERO,\n/// })?;\n/// builder.patch(unanchored_prefix, any)?;\n/// builder.patch(any, unanchored_prefix)?;\n///\n/// // Compile an alternation that permits matching multiple patterns.\n/// let alt = builder.add_union(vec![])?;\n/// builder.patch(unanchored_prefix, alt)?;\n///\n/// // Compile '(?P<foo>[a-z]+)'.\n/// builder.start_pattern()?;\n/// let start0 = builder.add_capture_start(StateID::ZERO, 0, None)?;\n/// // N.B. 0th capture group must always be unnamed.\n/// let foo_start0 = builder.add_capture_start(\n///     StateID::ZERO, 1, Some(Arc::from(\"foo\")),\n/// )?;\n/// let lowercase = builder.add_range(Transition {\n///     start: b'a', end: b'z', next: StateID::ZERO,\n/// })?;\n/// let foo_end0 = builder.add_capture_end(StateID::ZERO, 1)?;\n/// let end0 = builder.add_capture_end(StateID::ZERO, 0)?;\n/// let match0 = builder.add_match()?;\n/// builder.patch(start0, foo_start0)?;\n/// builder.patch(foo_start0, lowercase)?;\n/// builder.patch(lowercase, foo_end0)?;\n/// builder.patch(foo_end0, end0)?;\n/// builder.patch(end0, match0)?;\n/// builder.finish_pattern(start0)?;\n///\n/// // Compile '(?P<foo>[A-Z]+)'.\n/// builder.start_pattern()?;\n/// let start1 = builder.add_capture_start(StateID::ZERO, 0, None)?;\n/// // N.B. 0th capture group must always be unnamed.\n/// let foo_start1 = builder.add_capture_start(\n///     StateID::ZERO, 1, Some(Arc::from(\"foo\")),\n/// )?;\n/// let uppercase = builder.add_range(Transition {\n///     start: b'A', end: b'Z', next: StateID::ZERO,\n/// })?;\n/// let foo_end1 = builder.add_capture_end(StateID::ZERO, 1)?;\n/// let end1 = builder.add_capture_end(StateID::ZERO, 0)?;\n/// let match1 = builder.add_match()?;\n/// builder.patch(start1, foo_start1)?;\n/// builder.patch(foo_start1, uppercase)?;\n/// builder.patch(uppercase, foo_end1)?;\n/// builder.patch(foo_end1, end1)?;\n/// builder.patch(end1, match1)?;\n/// builder.finish_pattern(start1)?;\n///\n/// // Now add the patterns to our alternation that we started above.\n/// builder.patch(alt, start0)?;\n/// builder.patch(alt, start1)?;\n///\n/// // Finally build the NFA. The first argument is the anchored starting\n/// // state (the pattern alternation) where as the second is the\n/// // unanchored starting state (the unanchored prefix).\n/// let nfa = builder.build(alt, unanchored_prefix)?;\n///\n/// // Now build a Pike VM from our NFA and access the 'foo' capture\n/// // group regardless of which pattern matched, since it is defined\n/// // for both patterns.\n/// let vm = PikeVM::new_from_nfa(nfa)?;\n/// let mut cache = vm.create_cache();\n/// let caps: Vec<Captures> =\n///     vm.captures_iter(&mut cache, \"0123aAaAA\").collect();\n/// assert_eq!(5, caps.len());\n///\n/// assert_eq!(Some(PatternID::must(0)), caps[0].pattern());\n/// assert_eq!(Some(Span::from(4..5)), caps[0].get_group_by_name(\"foo\"));\n///\n/// assert_eq!(Some(PatternID::must(1)), caps[1].pattern());\n/// assert_eq!(Some(Span::from(5..6)), caps[1].get_group_by_name(\"foo\"));\n///\n/// assert_eq!(Some(PatternID::must(0)), caps[2].pattern());\n/// assert_eq!(Some(Span::from(6..7)), caps[2].get_group_by_name(\"foo\"));\n///\n/// assert_eq!(Some(PatternID::must(1)), caps[3].pattern());\n/// assert_eq!(Some(Span::from(7..8)), caps[3].get_group_by_name(\"foo\"));\n///\n/// assert_eq!(Some(PatternID::must(1)), caps[4].pattern());\n/// assert_eq!(Some(Span::from(8..9)), caps[4].get_group_by_name(\"foo\"));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n 991 pub fn add_capture_start(\n 992     &mut self,\n 993     next: StateID,\n 994     group_index: u32,\n 995     name: Option<Arc<str>>,\n 996 ) -> Result<StateID, BuildError> {\n 997     let pid = self.current_pattern_id();\n 998     let group_index = match SmallIndex::try_from(group_index) {\n 999         Err(_) => {\n1000             return Err(BuildError::invalid_capture_index(group_index))\n1001         }\n1002         Ok(group_index) => group_index,\n1003     };\n1004     // Make sure we have space to insert our (pid,index)|-->name mapping.\n1005     if pid.as_usize() >= self.captures.len() {\n1006         for _ in 0..=(pid.as_usize() - self.captures.len()) {\n1007             self.captures.push(vec![]);\n1008         }\n1009     }\n1010     // In the case where 'group_index < self.captures[pid].len()', it means\n1011     // that we are adding a duplicate capture group. This is somewhat\n1012     // weird, but permissible because the capture group itself can be\n1013     // repeated in the syntax. For example, '([a-z]){4}' will produce 4\n1014     // capture groups. In practice, only the last will be set at search\n1015     // time when a match occurs. For duplicates, we don't need to push\n1016     // anything other than a CaptureStart NFA state.\n1017     if group_index.as_usize() >= self.captures[pid].len() {\n1018         // For discontiguous indices, push placeholders for earlier capture\n1019         // groups that weren't explicitly added.\n1020         for _ in 0..(group_index.as_usize() - self.captures[pid].len()) {\n1021             self.captures[pid].push(None);\n1022         }\n1023         self.captures[pid].push(name);\n1024     }\n1025     self.add(State::CaptureStart { pattern_id: pid, group_index, next })\n1026 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}