{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/wrappers.rs\n// crate name is regex_automata\nuse alloc::vec::Vec;\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError},\n        regex::RegexInfo,\n    },\n    nfa::thompson::{pikevm, NFA},\n    util::{prefilter::Prefilter, primitives::NonMaxUsize},\n    HalfMatch, Input, Match, MatchKind, PatternID, PatternSet,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa;\n#[cfg(feature = \"dfa-onepass\")]\nuse crate::dfa::onepass;\n#[cfg(feature = \"hybrid\")]\nuse crate::hybrid;\n#[cfg(feature = \"nfa-backtrack\")]\nuse crate::nfa::thompson::backtrack;\n#[derive(Debug)]\npub(crate) struct HybridEngine(\n    #[cfg(feature = \"hybrid\")]\n    hybrid::regex::Regex,\n    #[cfg(not(feature = \"hybrid\"))]\n    (),\n);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug)]\npub struct Builder {\n    config: Config,\n    #[cfg(feature = \"syntax\")]\n    thompson: thompson::Compiler,\n}\n#[derive(Clone, Debug)]\npub(crate) struct RegexInfo(Arc<RegexInfoI>);\n#[derive(Clone, Debug)]\npub struct Builder {\n    dfa: dfa::Builder,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone, Debug)]\npub struct DFA {\n    config: Config,\n    nfa: thompson::NFA,\n    stride2: usize,\n    start_map: StartByteMap,\n    classes: ByteClasses,\n    quitset: ByteSet,\n    cache_capacity: usize,\n}\n#[derive(Debug)]\npub struct Regex {\n    /// The forward lazy DFA. This can only find the end of a match.\n    forward: DFA,\n    /// The reverse lazy DFA. This can only find the start of a match.\n    ///\n    /// This is built with 'all' match semantics (instead of leftmost-first)\n    /// so that it always finds the longest possible match (which corresponds\n    /// to the leftmost starting position). It is also compiled as an anchored\n    /// matcher and has 'starts_for_each_pattern' enabled. Including starting\n    /// states for each pattern is necessary to ensure that we only look for\n    /// matches of a pattern that matched in the forward direction. Otherwise,\n    /// we might wind up finding the \"leftmost\" starting position of a totally\n    /// different pattern!\n    reverse: DFA,\n}\n#[derive(Debug)]\npub struct Regex {\n    /// The actual regex implementation.\n    imp: Arc<RegexI>,\n    /// A thread safe pool of caches.\n    ///\n    /// For the higher level search APIs, a `Cache` is automatically plucked\n    /// from this pool before running a search. The lower level `with` methods\n    /// permit the caller to provide their own cache, thereby bypassing\n    /// accesses to this pool.\n    ///\n    /// Note that we put this outside the `Arc` so that cloning a `Regex`\n    /// results in creating a fresh `CachePool`. This in turn permits callers\n    /// to clone regexes into separate threads where each such regex gets\n    /// the pool's \"thread owner\" optimization. Otherwise, if one shares the\n    /// `Regex` directly, then the pool will go through a slower mutex path for\n    /// all threads except for the \"owner.\"\n    pool: CachePool,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\nimpl HybridEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Option<HybridEngine> {\n        #[cfg(feature = \"hybrid\")]\n        {\n            if !info.config().get_hybrid() {\n                return None;\n            }\n            let dfa_config = hybrid::dfa::Config::new()\n                .match_kind(info.config().get_match_kind())\n                .prefilter(pre.clone())\n                .starts_for_each_pattern(true)\n                .byte_classes(info.config().get_byte_classes())\n                .unicode_word_boundary(true)\n                .specialize_start_states(pre.is_some())\n                .cache_capacity(info.config().get_hybrid_cache_capacity())\n                .skip_cache_capacity_check(false)\n                .minimum_cache_clear_count(Some(3))\n                .minimum_bytes_per_state(Some(10));\n            let result = hybrid::dfa::Builder::new()\n                .configure(dfa_config.clone())\n                .build_from_nfa(nfa.clone());\n            let fwd = match result {\n                Ok(fwd) => fwd,\n                Err(_err) => {\n                    debug!(\"forward lazy DFA failed to build: {}\", _err);\n                    return None;\n                }\n            };\n            let result = hybrid::dfa::Builder::new()\n                .configure(\n                    dfa_config\n                        .clone()\n                        .match_kind(MatchKind::All)\n                        .prefilter(None)\n                        .specialize_start_states(false),\n                )\n                .build_from_nfa(nfarev.clone());\n            let rev = match result {\n                Ok(rev) => rev,\n                Err(_err) => {\n                    debug!(\"reverse lazy DFA failed to build: {}\", _err);\n                    return None;\n                }\n            };\n            let engine = hybrid::regex::Builder::new().build_from_dfas(fwd, rev);\n            debug!(\"lazy DFA built\");\n            Some(HybridEngine(engine))\n        }\n        #[cfg(not(feature = \"hybrid\"))] { None }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<Match>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_fwd_stopat(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn try_search_half_rev_limited(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n    #[inline]\n    pub(crate) fn try_which_overlapping_matches(\n        &self,\n        cache: &mut HybridCache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), RetryFailError> {}\n}\nimpl Config {\n    pub fn new() -> Config {\n        Config::default()\n    }\n    pub fn match_kind(mut self, kind: MatchKind) -> Config {\n        self.match_kind = Some(kind);\n        self\n    }\n    pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {\n        self.pre = Some(pre);\n        if self.specialize_start_states.is_none() {\n            self.specialize_start_states = Some(self.get_prefilter().is_some());\n        }\n        self\n    }\n    pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {\n        self.starts_for_each_pattern = Some(yes);\n        self\n    }\n    pub fn byte_classes(mut self, yes: bool) -> Config {\n        self.byte_classes = Some(yes);\n        self\n    }\n    pub fn unicode_word_boundary(mut self, yes: bool) -> Config {\n        self.unicode_word_boundary = Some(yes);\n        self\n    }\n    pub fn quit(mut self, byte: u8, yes: bool) -> Config {}\n    pub fn specialize_start_states(mut self, yes: bool) -> Config {\n        self.specialize_start_states = Some(yes);\n        self\n    }\n    pub fn cache_capacity(mut self, bytes: usize) -> Config {\n        self.cache_capacity = Some(bytes);\n        self\n    }\n    pub fn skip_cache_capacity_check(mut self, yes: bool) -> Config {\n        self.skip_cache_capacity_check = Some(yes);\n        self\n    }\n    pub fn minimum_cache_clear_count(mut self, min: Option<usize>) -> Config {\n        self.minimum_cache_clear_count = Some(min);\n        self\n    }\n    pub fn minimum_bytes_per_state(mut self, min: Option<usize>) -> Config {\n        self.minimum_bytes_per_state = Some(min);\n        self\n    }\n    pub fn get_match_kind(&self) -> MatchKind {\n        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)\n    }\n    pub fn get_prefilter(&self) -> Option<&Prefilter> {}\n    pub fn get_starts_for_each_pattern(&self) -> bool {}\n    pub fn get_byte_classes(&self) -> bool {\n        self.byte_classes.unwrap_or(true)\n    }\n    pub fn get_unicode_word_boundary(&self) -> bool {}\n    pub fn get_quit(&self, byte: u8) -> bool {}\n    pub fn get_specialize_start_states(&self) -> bool {}\n    pub fn get_cache_capacity(&self) -> usize {}\n    pub fn get_skip_cache_capacity_check(&self) -> bool {}\n    pub fn get_minimum_cache_clear_count(&self) -> Option<usize> {}\n    pub fn get_minimum_bytes_per_state(&self) -> Option<usize> {}\n    pub fn get_minimum_cache_capacity(\n        &self,\n        nfa: &thompson::NFA,\n    ) -> Result<usize, BuildError> {}\n    fn byte_classes_from_nfa(&self, nfa: &thompson::NFA, quit: &ByteSet) -> ByteClasses {}\n    fn quit_set_from_nfa(&self, nfa: &thompson::NFA) -> Result<ByteSet, BuildError> {}\n    fn overwrite(&self, o: Config) -> Config {}\n}\nimpl Builder {\n    pub fn new() -> Builder {\n        Builder {\n            config: Config::default(),\n            #[cfg(feature = \"syntax\")]\n            thompson: thompson::Compiler::new(),\n        }\n    }\n    #[cfg(feature = \"syntax\")]\n    pub fn build(&self, pattern: &str) -> Result<DFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn build_many<P: AsRef<str>>(&self, patterns: &[P]) -> Result<DFA, BuildError> {}\n    pub fn build_from_nfa(&self, nfa: thompson::NFA) -> Result<DFA, BuildError> {\n        let quitset = self.config.quit_set_from_nfa(&nfa)?;\n        let classes = self.config.byte_classes_from_nfa(&nfa, &quitset);\n        let min_cache = minimum_cache_capacity(\n            &nfa,\n            &classes,\n            self.config.get_starts_for_each_pattern(),\n        );\n        let mut cache_capacity = self.config.get_cache_capacity();\n        if cache_capacity < min_cache {\n            if self.config.get_skip_cache_capacity_check() {\n                debug!(\n                    \"given capacity ({}) is too small, \\\n                     since skip_cache_capacity_check is enabled, \\\n                     setting cache capacity to minimum ({})\",\n                    cache_capacity, min_cache,\n                );\n                cache_capacity = min_cache;\n            } else {\n                return Err(\n                    BuildError::insufficient_cache_capacity(min_cache, cache_capacity),\n                );\n            }\n        }\n        if let Err(err) = minimum_lazy_state_id(&classes) {\n            return Err(BuildError::insufficient_state_id_capacity(err));\n        }\n        let stride2 = classes.stride2();\n        let start_map = StartByteMap::new(nfa.look_matcher());\n        Ok(DFA {\n            config: self.config.clone(),\n            nfa,\n            stride2,\n            start_map,\n            classes,\n            quitset,\n            cache_capacity,\n        })\n    }\n    pub fn configure(&mut self, config: Config) -> &mut Builder {\n        self.config = self.config.overwrite(config);\n        self\n    }\n    #[cfg(feature = \"syntax\")]\n    pub fn syntax(&mut self, config: crate::util::syntax::Config) -> &mut Builder {}\n    #[cfg(feature = \"syntax\")]\n    pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {}\n}\nimpl RegexInfo {\n    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {}\n    pub(crate) fn config(&self) -> &Config {\n        &self.0.config\n    }\n    pub(crate) fn props(&self) -> &[hir::Properties] {}\n    pub(crate) fn props_union(&self) -> &hir::Properties {}\n    pub(crate) fn pattern_len(&self) -> usize {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_anchored_start(&self, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_start(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_end(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_impossible(&self, input: &Input<'_>) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n562 pub(crate) fn new(\n563     info: &RegexInfo,\n564     pre: Option<Prefilter>,\n565     nfa: &NFA,\n566     nfarev: &NFA,\n567 ) -> Option<HybridEngine> {\n568     #[cfg(feature = \"hybrid\")]\n569     {\n570         if !info.config().get_hybrid() {\n571             return None;\n572         }\n573         let dfa_config = hybrid::dfa::Config::new()\n574             .match_kind(info.config().get_match_kind())\n575             .prefilter(pre.clone())\n576             // Enabling this is necessary for ensuring we can service any\n577             // kind of 'Input' search without error. For the lazy DFA,\n578             // this is not particularly costly, since the start states are\n579             // generated lazily.\n580             .starts_for_each_pattern(true)\n581             .byte_classes(info.config().get_byte_classes())\n582             .unicode_word_boundary(true)\n583             .specialize_start_states(pre.is_some())\n584             .cache_capacity(info.config().get_hybrid_cache_capacity())\n585             // This makes it possible for building a lazy DFA to\n586             // fail even though the NFA has already been built. Namely,\n587             // if the cache capacity is too small to fit some minimum\n588             // number of states (which is small, like 4 or 5), then the\n589             // DFA will refuse to build.\n590             //\n591             // We shouldn't enable this to make building always work, since\n592             // this could cause the allocation of a cache bigger than the\n593             // provided capacity amount.\n594             //\n595             // This is effectively the only reason why building a lazy DFA\n596             // could fail. If it does, then we simply suppress the error\n597             // and return None.\n598             .skip_cache_capacity_check(false)\n599             // This and enabling heuristic Unicode word boundary support\n600             // above make it so the lazy DFA can quit at match time.\n601             .minimum_cache_clear_count(Some(3))\n602             .minimum_bytes_per_state(Some(10));\n603         let result = hybrid::dfa::Builder::new()\n604             .configure(dfa_config.clone())\n605             .build_from_nfa(nfa.clone());\n606         let fwd = match result {\n607             Ok(fwd) => fwd,\n608             Err(_err) => {\n609                 debug!(\"forward lazy DFA failed to build: {}\", _err);\n610                 return None;\n611             }\n612         };\n613         let result = hybrid::dfa::Builder::new()\n614             .configure(\n615                 dfa_config\n616                     .clone()\n617                     .match_kind(MatchKind::All)\n618                     .prefilter(None)\n619                     .specialize_start_states(false),\n620             )\n621             .build_from_nfa(nfarev.clone());\n622         let rev = match result {\n623             Ok(rev) => rev,\n624             Err(_err) => {\n625                 debug!(\"reverse lazy DFA failed to build: {}\", _err);\n626                 return None;\n627             }\n628         };\n629         let engine =\n630             hybrid::regex::Builder::new().build_from_dfas(fwd, rev);\n631         debug!(\"lazy DFA built\");\n632         Some(HybridEngine(engine))\n633     }\n634     #[cfg(not(feature = \"hybrid\"))]\n635     {\n636         None\n637     }\n638 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}