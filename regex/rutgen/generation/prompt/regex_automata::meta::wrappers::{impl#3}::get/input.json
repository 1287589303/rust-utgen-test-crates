{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/wrappers.rs\n// crate name is regex_automata\nuse alloc::vec::Vec;\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError},\n        regex::RegexInfo,\n    },\n    nfa::thompson::{pikevm, NFA},\n    util::{prefilter::Prefilter, primitives::NonMaxUsize},\n    HalfMatch, Input, Match, MatchKind, PatternID, PatternSet,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa;\n#[cfg(feature = \"dfa-onepass\")]\nuse crate::dfa::onepass;\n#[cfg(feature = \"hybrid\")]\nuse crate::hybrid;\n#[cfg(feature = \"nfa-backtrack\")]\nuse crate::nfa::thompson::backtrack;\n#[derive(Debug)]\npub(crate) struct BoundedBacktracker(Option<BoundedBacktrackerEngine>);\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Span {\n    /// The start offset of the span, inclusive.\n    pub start: usize,\n    /// The end offset of the span, exclusive.\n    pub end: usize,\n}\n#[derive(Debug)]\npub(crate) struct BoundedBacktrackerEngine(\n    #[cfg(feature = \"nfa-backtrack\")]\n    backtrack::BoundedBacktracker,\n    #[cfg(not(feature = \"nfa-backtrack\"))]\n    (),\n);\nimpl BoundedBacktracker {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n    ) -> Result<BoundedBacktracker, BuildError> {}\n    pub(crate) fn create_cache(&self) -> BoundedBacktrackerCache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, input: &Input<'_>) -> Option<&BoundedBacktrackerEngine> {\n        let engine = self.0.as_ref()?;\n        if input.get_earliest() && input.haystack().len() > 128 {\n            return None;\n        }\n        if input.get_span().len() > engine.max_haystack_len() {\n            return None;\n        }\n        Some(engine)\n    }\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {}\n    #[inline]\n    pub fn end(&self) -> usize {}\n    #[inline]\n    pub fn get_span(&self) -> Span {\n        self.span\n    }\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {\n        self.earliest\n    }\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl Span {\n    #[inline]\n    pub fn range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.end.saturating_sub(self.start)\n    }\n    #[inline]\n    pub fn contains(&self, offset: usize) -> bool {}\n    #[inline]\n    pub fn offset(&self, offset: usize) -> Span {}\n}\nimpl BoundedBacktrackerEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n    ) -> Result<Option<BoundedBacktrackerEngine>, BuildError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_match(\n        &self,\n        cache: &mut BoundedBacktrackerCache,\n        input: &Input<'_>,\n    ) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn search_slots(\n        &self,\n        cache: &mut BoundedBacktrackerCache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn max_haystack_len(&self) -> usize {\n        #[cfg(feature = \"nfa-backtrack\")] { self.0.max_haystack_len() }\n        #[cfg(not(feature = \"nfa-backtrack\"))] { unreachable!() }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n162 pub(crate) fn get(\n163     &self,\n164     input: &Input<'_>,\n165 ) -> Option<&BoundedBacktrackerEngine> {\n166     let engine = self.0.as_ref()?;\n167     // It is difficult to make the backtracker give up early if it is\n168     // guaranteed to eventually wind up in a match state. This is because\n169     // of the greedy nature of a backtracker: it just blindly mushes\n170     // forward. Every other regex engine is able to give up more quickly,\n171     // so even if the backtracker might be able to zip through faster than\n172     // (say) the PikeVM, we prefer the theoretical benefit that some other\n173     // engine might be able to scan much less of the haystack than the\n174     // backtracker.\n175     //\n176     // Now, if the haystack is really short already, then we allow the\n177     // backtracker to run. (This hasn't been litigated quantitatively with\n178     // benchmarks. Just a hunch.)\n179     if input.get_earliest() && input.haystack().len() > 128 {\n180         return None;\n181     }\n182     // If the backtracker is just going to return an error because the\n183     // haystack is too long, then obviously do not use it.\n184     if input.get_span().len() > engine.max_haystack_len() {\n185         return None;\n186     }\n187     Some(engine)\n188 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}