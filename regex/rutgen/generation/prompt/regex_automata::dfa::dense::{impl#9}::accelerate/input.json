{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/dense.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\npub(crate) type OwnedDFA = DFA<alloc::vec::Vec<u32>>;\n#[cfg(feature = \"dfa-build\")]\nuse core::cmp;\nuse core::{fmt, iter, mem::size_of, slice};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{\n    collections::{BTreeMap, BTreeSet},\n    vec, vec::Vec,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::{\n    dfa::{accel::Accel, determinize, minimize::Minimizer, remapper::Remapper, sparse},\n    nfa::thompson, util::{look::LookMatcher, search::MatchKind},\n};\nuse crate::{\n    dfa::{\n        accel::Accels, automaton::{fmt_state_indicator, Automaton, StartError},\n        special::Special, start::StartKind, DEAD,\n    },\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        int::{Pointer, Usize},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-dense\";\nconst VERSION: u32 = 2;\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID>;\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\npub(crate) trait U16 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn high_u8(self) -> u8;\n}\npub(crate) trait U32 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn high_u16(self) -> u16;\n}\npub(crate) trait Usize {\n    fn as_u8(self) -> u8;\n    fn as_u16(self) -> u16;\n    fn as_u32(self) -> u32;\n    fn as_u64(self) -> u64;\n}\npub(crate) trait U8 {\n    fn as_usize(self) -> usize;\n}\npub(crate) trait U64 {\n    fn as_usize(self) -> usize;\n    fn low_u8(self) -> u8;\n    fn low_u16(self) -> u16;\n    fn low_u32(self) -> u32;\n    fn high_u32(self) -> u32;\n}\npub(crate) trait I32 {\n    fn as_usize(self) -> usize;\n    fn to_bits(self) -> u32;\n    fn from_bits(n: u32) -> i32;\n}\npub(crate) trait Pointer {\n    fn as_usize(self) -> usize;\n}\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone)]\npub(crate) struct Accel {\n    /// The first byte is the length. Subsequent bytes are the accelerated\n    /// bytes.\n    ///\n    /// Note that we make every accelerator 8 bytes as a slightly wasteful\n    /// way of making sure alignment is always correct for state ID sizes of\n    /// 1, 2, 4 and 8. This should be okay since accelerated states aren't\n    /// particularly common, especially when Unicode is enabled.\n    bytes: [u8; ACCEL_CAP],\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Debug)]\npub(super) struct Remapper {\n    /// A map from the index of a state to its pre-multiplied identifier.\n    ///\n    /// When a state is swapped with another, then their corresponding\n    /// locations in this map are also swapped. Thus, its new position will\n    /// still point to its old pre-multiplied StateID.\n    ///\n    /// While there is a bit more to it, this then allows us to rewrite the\n    /// state IDs in a DFA's transition table in a single pass. This is done\n    /// by iterating over every ID in this map, then iterating over each\n    /// transition for the state at that ID and re-mapping the transition from\n    /// `old_id` to `map[dfa.to_index(old_id)]`. That is, we find the position\n    /// in this map where `old_id` *started*, and set it to where it ended up\n    /// after all swaps have been completed.\n    map: Vec<StateID>,\n    /// A mapper from state index to state ID (and back).\n    idxmap: IndexMapper,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\nimpl OwnedDFA {\n    pub(crate) fn set_start_state(\n        &mut self,\n        anchored: Anchored,\n        start: Start,\n        id: StateID,\n    ) {}\n    pub(crate) fn set_transition(\n        &mut self,\n        from: StateID,\n        byte: alphabet::Unit,\n        to: StateID,\n    ) {}\n    pub(crate) fn add_empty_state(&mut self) -> Result<StateID, BuildError> {}\n    pub(crate) fn swap_states(&mut self, id1: StateID, id2: StateID) {}\n    pub(crate) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {}\n    pub(crate) fn remap_state(&mut self, id: StateID, map: impl Fn(StateID) -> StateID) {}\n    pub(crate) fn truncate_states(&mut self, len: usize) {}\n    pub(crate) fn minimize(&mut self) {}\n    pub(crate) fn set_pattern_map(\n        &mut self,\n        map: &BTreeMap<StateID, Vec<PatternID>>,\n    ) -> Result<(), BuildError> {}\n    pub(crate) fn accelerate(&mut self) {\n        if self.state_len() <= 2 {\n            return;\n        }\n        let mut accels = BTreeMap::new();\n        let (mut cmatch, mut cstart, mut cnormal) = (0, 0, 0);\n        for state in self.states() {\n            if let Some(accel) = state.accelerate(self.byte_classes()) {\n                debug!(\n                    \"accelerating full DFA state {}: {:?}\", state.id().as_usize(), accel,\n                );\n                accels.insert(state.id(), accel);\n                if self.is_match_state(state.id()) {\n                    cmatch += 1;\n                } else if self.is_start_state(state.id()) {\n                    cstart += 1;\n                } else {\n                    assert!(! self.is_dead_state(state.id()));\n                    assert!(! self.is_quit_state(state.id()));\n                    cnormal += 1;\n                }\n            }\n        }\n        if accels.is_empty() {\n            return;\n        }\n        let original_accels_len = accels.len();\n        let mut remapper = Remapper::new(self);\n        let mut new_matches = self.ms.to_map(self);\n        self.special.min_accel = StateID::MAX;\n        self.special.max_accel = StateID::ZERO;\n        let update_special_accel = |special: &mut Special, accel_id: StateID| {\n            special.min_accel = cmp::min(special.min_accel, accel_id);\n            special.max_accel = cmp::max(special.max_accel, accel_id);\n        };\n        if cmatch > 0 && self.special.matches() {\n            let mut next_id = self.special.max_match;\n            let mut cur_id = next_id;\n            while cur_id >= self.special.min_match {\n                if let Some(accel) = accels.remove(&cur_id) {\n                    accels.insert(next_id, accel);\n                    update_special_accel(&mut self.special, next_id);\n                    if cur_id != next_id {\n                        remapper.swap(self, cur_id, next_id);\n                        let cur_pids = new_matches.remove(&cur_id).unwrap();\n                        let next_pids = new_matches.remove(&next_id).unwrap();\n                        new_matches.insert(cur_id, next_pids);\n                        new_matches.insert(next_id, cur_pids);\n                    }\n                    next_id = self.tt.prev_state_id(next_id);\n                }\n                cur_id = self.tt.prev_state_id(cur_id);\n            }\n        }\n        if cnormal > 0 {\n            let mut next_start_id = self.special.min_start;\n            let mut cur_id = self.to_state_id(self.state_len() - 1);\n            let mut next_norm_id = self.tt.next_state_id(self.special.max_start);\n            while cur_id >= next_norm_id {\n                if let Some(accel) = accels.remove(&cur_id) {\n                    remapper.swap(self, next_start_id, cur_id);\n                    remapper.swap(self, next_norm_id, cur_id);\n                    if let Some(accel2) = accels.remove(&next_norm_id) {\n                        accels.insert(cur_id, accel2);\n                    }\n                    if let Some(accel2) = accels.remove(&next_start_id) {\n                        accels.insert(next_norm_id, accel2);\n                    }\n                    accels.insert(next_start_id, accel);\n                    update_special_accel(&mut self.special, next_start_id);\n                    self.special.min_start = self\n                        .tt\n                        .next_state_id(self.special.min_start);\n                    self.special.max_start = self\n                        .tt\n                        .next_state_id(self.special.max_start);\n                    next_start_id = self.tt.next_state_id(next_start_id);\n                    next_norm_id = self.tt.next_state_id(next_norm_id);\n                }\n                if !accels.contains_key(&cur_id) {\n                    cur_id = self.tt.prev_state_id(cur_id);\n                }\n            }\n        }\n        if cstart > 0 {\n            let mut next_id = self.special.min_start;\n            let mut cur_id = next_id;\n            while cur_id <= self.special.max_start {\n                if let Some(accel) = accels.remove(&cur_id) {\n                    remapper.swap(self, cur_id, next_id);\n                    accels.insert(next_id, accel);\n                    update_special_accel(&mut self.special, next_id);\n                    next_id = self.tt.next_state_id(next_id);\n                }\n                cur_id = self.tt.next_state_id(cur_id);\n            }\n        }\n        remapper.remap(self);\n        self.set_pattern_map(&new_matches).unwrap();\n        self.special.set_max();\n        self.special.validate().expect(\"special state ranges should validate\");\n        self.special\n            .validate_state_len(self.state_len(), self.stride2())\n            .expect(\"special state ranges should be consistent with state length\");\n        assert_eq!(\n            self.special.accel_len(self.stride()), original_accels_len,\n            \"mismatch with expected number of accelerated states\",\n        );\n        let mut prev: Option<StateID> = None;\n        for (id, accel) in accels {\n            assert!(prev.map_or(true, | p | self.tt.next_state_id(p) == id));\n            prev = Some(id);\n            self.accels.add(accel);\n        }\n    }\n    pub(crate) fn shuffle(\n        &mut self,\n        mut matches: BTreeMap<StateID, Vec<PatternID>>,\n    ) -> Result<(), BuildError> {}\n    fn set_universal_starts(&mut self) {}\n}\nimpl Special {\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn new() -> Special {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {}\n    pub(crate) fn from_bytes(\n        mut slice: &[u8],\n    ) -> Result<(Special, usize), DeserializeError> {}\n    pub(crate) fn validate(&self) -> Result<(), DeserializeError> {\n        if self.min_match == DEAD && self.max_match != DEAD {\n            err!(\"min_match is DEAD, but max_match is not\");\n        }\n        if self.min_match != DEAD && self.max_match == DEAD {\n            err!(\"max_match is DEAD, but min_match is not\");\n        }\n        if self.min_accel == DEAD && self.max_accel != DEAD {\n            err!(\"min_accel is DEAD, but max_accel is not\");\n        }\n        if self.min_accel != DEAD && self.max_accel == DEAD {\n            err!(\"max_accel is DEAD, but min_accel is not\");\n        }\n        if self.min_start == DEAD && self.max_start != DEAD {\n            err!(\"min_start is DEAD, but max_start is not\");\n        }\n        if self.min_start != DEAD && self.max_start == DEAD {\n            err!(\"max_start is DEAD, but min_start is not\");\n        }\n        if self.min_match > self.max_match {\n            err!(\"min_match should not be greater than max_match\");\n        }\n        if self.min_accel > self.max_accel {\n            err!(\"min_accel should not be greater than max_accel\");\n        }\n        if self.min_start > self.max_start {\n            err!(\"min_start should not be greater than max_start\");\n        }\n        if self.matches() && self.quit_id >= self.min_match {\n            err!(\"quit_id should not be greater than min_match\");\n        }\n        if self.accels() && self.quit_id >= self.min_accel {\n            err!(\"quit_id should not be greater than min_accel\");\n        }\n        if self.starts() && self.quit_id >= self.min_start {\n            err!(\"quit_id should not be greater than min_start\");\n        }\n        if self.matches() && self.accels() && self.min_accel < self.min_match {\n            err!(\"min_match should not be greater than min_accel\");\n        }\n        if self.matches() && self.starts() && self.min_start < self.min_match {\n            err!(\"min_match should not be greater than min_start\");\n        }\n        if self.accels() && self.starts() && self.min_start < self.min_accel {\n            err!(\"min_accel should not be greater than min_start\");\n        }\n        if self.max < self.quit_id {\n            err!(\"quit_id should not be greater than max\");\n        }\n        if self.max < self.max_match {\n            err!(\"max_match should not be greater than max\");\n        }\n        if self.max < self.max_accel {\n            err!(\"max_accel should not be greater than max\");\n        }\n        if self.max < self.max_start {\n            err!(\"max_start should not be greater than max\");\n        }\n        Ok(())\n    }\n    pub(crate) fn validate_state_len(\n        &self,\n        len: usize,\n        stride2: usize,\n    ) -> Result<(), DeserializeError> {\n        if (self.max.as_usize() >> stride2) >= len {\n            err!(\"max should not be greater than or equal to state length\");\n        }\n        Ok(())\n    }\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_max(&mut self) {\n        use core::cmp::max;\n        self.max = max(\n            self.quit_id,\n            max(self.max_match, max(self.max_accel, self.max_start)),\n        );\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_no_special_start_states(&mut self) {}\n    #[inline]\n    pub(crate) fn is_special_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_dead_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_quit_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_match_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_accel_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_start_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn match_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn matches(&self) -> bool {\n        self.min_match != DEAD\n    }\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn accel_len(&self, stride: usize) -> usize {\n        if self.accels() {\n            (self.max_accel.as_usize() - self.min_accel.as_usize() + stride) / stride\n        } else {\n            0\n        }\n    }\n    #[inline]\n    pub(crate) fn accels(&self) -> bool {}\n    #[inline]\n    pub(crate) fn starts(&self) -> bool {}\n}\nimpl<'a> State<'a> {\n    pub(crate) fn transitions(&self) -> StateTransitionIter<'_> {}\n    pub(crate) fn sparse_transitions(&self) -> StateSparseTransitionIter<'_> {}\n    pub(crate) fn id(&self) -> StateID {\n        self.id\n    }\n    #[cfg(feature = \"dfa-build\")]\n    fn accelerate(&self, classes: &ByteClasses) -> Option<Accel> {\n        let mut accel = Accel::new();\n        for (class, id) in self.transitions() {\n            if id == self.id() {\n                continue;\n            }\n            for unit in classes.elements(class) {\n                if let Some(byte) = unit.as_u8() {\n                    if !accel.add(byte) {\n                        return None;\n                    }\n                }\n            }\n        }\n        if accel.is_empty() { None } else { Some(accel) }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Find states that have a small number of non-loop transitions and mark\n/// them as candidates for acceleration during search.\n2580 pub(crate) fn accelerate(&mut self) {\n2581     // dead and quit states can never be accelerated.\n2582     if self.state_len() <= 2 {\n2583         return;\n2584     }\n2585 \n2586     // Go through every state and record their accelerator, if possible.\n2587     let mut accels = BTreeMap::new();\n2588     // Count the number of accelerated match, start and non-match/start\n2589     // states.\n2590     let (mut cmatch, mut cstart, mut cnormal) = (0, 0, 0);\n2591     for state in self.states() {\n2592         if let Some(accel) = state.accelerate(self.byte_classes()) {\n2593             debug!(\n2594                 \"accelerating full DFA state {}: {:?}\",\n2595                 state.id().as_usize(),\n2596                 accel,\n2597             );\n2598             accels.insert(state.id(), accel);\n2599             if self.is_match_state(state.id()) {\n2600                 cmatch += 1;\n2601             } else if self.is_start_state(state.id()) {\n2602                 cstart += 1;\n2603             } else {\n2604                 assert!(!self.is_dead_state(state.id()));\n2605                 assert!(!self.is_quit_state(state.id()));\n2606                 cnormal += 1;\n2607             }\n2608         }\n2609     }\n2610     // If no states were able to be accelerated, then we're done.\n2611     if accels.is_empty() {\n2612         return;\n2613     }\n2614     let original_accels_len = accels.len();\n2615 \n2616     // A remapper keeps track of state ID changes. Once we're done\n2617     // shuffling, the remapper is used to rewrite all transitions in the\n2618     // DFA based on the new positions of states.\n2619     let mut remapper = Remapper::new(self);\n2620 \n2621     // As we swap states, if they are match states, we need to swap their\n2622     // pattern ID lists too (for multi-regexes). We do this by converting\n2623     // the lists to an easily swappable map, and then convert back to\n2624     // MatchStates once we're done.\n2625     let mut new_matches = self.ms.to_map(self);\n2626 \n2627     // There is at least one state that gets accelerated, so these are\n2628     // guaranteed to get set to sensible values below.\n2629     self.special.min_accel = StateID::MAX;\n2630     self.special.max_accel = StateID::ZERO;\n2631     let update_special_accel =\n2632         |special: &mut Special, accel_id: StateID| {\n2633             special.min_accel = cmp::min(special.min_accel, accel_id);\n2634             special.max_accel = cmp::max(special.max_accel, accel_id);\n2635         };\n2636 \n2637     // Start by shuffling match states. Any match states that are\n2638     // accelerated get moved to the end of the match state range.\n2639     if cmatch > 0 && self.special.matches() {\n2640         // N.B. special.{min,max}_match do not need updating, since the\n2641         // range/number of match states does not change. Only the ordering\n2642         // of match states may change.\n2643         let mut next_id = self.special.max_match;\n2644         let mut cur_id = next_id;\n2645         while cur_id >= self.special.min_match {\n2646             if let Some(accel) = accels.remove(&cur_id) {\n2647                 accels.insert(next_id, accel);\n2648                 update_special_accel(&mut self.special, next_id);\n2649 \n2650                 // No need to do any actual swapping for equivalent IDs.\n2651                 if cur_id != next_id {\n2652                     remapper.swap(self, cur_id, next_id);\n2653 \n2654                     // Swap pattern IDs for match states.\n2655                     let cur_pids = new_matches.remove(&cur_id).unwrap();\n2656                     let next_pids = new_matches.remove(&next_id).unwrap();\n2657                     new_matches.insert(cur_id, next_pids);\n2658                     new_matches.insert(next_id, cur_pids);\n2659                 }\n2660                 next_id = self.tt.prev_state_id(next_id);\n2661             }\n2662             cur_id = self.tt.prev_state_id(cur_id);\n2663         }\n2664     }\n2665 \n2666     // This is where it gets tricky. Without acceleration, start states\n2667     // normally come right after match states. But we want accelerated\n2668     // states to be a single contiguous range (to make it very fast\n2669     // to determine whether a state *is* accelerated), while also keeping\n2670     // match and starting states as contiguous ranges for the same reason.\n2671     // So what we do here is shuffle states such that it looks like this:\n2672     //\n2673     //     DQMMMMAAAAASSSSSSNNNNNNN\n2674     //         |         |\n2675     //         |---------|\n2676     //      accelerated states\n2677     //\n2678     // Where:\n2679     //   D - dead state\n2680     //   Q - quit state\n2681     //   M - match state (may be accelerated)\n2682     //   A - normal state that is accelerated\n2683     //   S - start state (may be accelerated)\n2684     //   N - normal state that is NOT accelerated\n2685     //\n2686     // We implement this by shuffling states, which is done by a sequence\n2687     // of pairwise swaps. We start by looking at all normal states to be\n2688     // accelerated. When we find one, we swap it with the earliest starting\n2689     // state, and then swap that with the earliest normal state. This\n2690     // preserves the contiguous property.\n2691     //\n2692     // Once we're done looking for accelerated normal states, now we look\n2693     // for accelerated starting states by moving them to the beginning\n2694     // of the starting state range (just like we moved accelerated match\n2695     // states to the end of the matching state range).\n2696     //\n2697     // For a more detailed/different perspective on this, see the docs\n2698     // in dfa/special.rs.\n2699     if cnormal > 0 {\n2700         // our next available starting and normal states for swapping.\n2701         let mut next_start_id = self.special.min_start;\n2702         let mut cur_id = self.to_state_id(self.state_len() - 1);\n2703         // This is guaranteed to exist since cnormal > 0.\n2704         let mut next_norm_id =\n2705             self.tt.next_state_id(self.special.max_start);\n2706         while cur_id >= next_norm_id {\n2707             if let Some(accel) = accels.remove(&cur_id) {\n2708                 remapper.swap(self, next_start_id, cur_id);\n2709                 remapper.swap(self, next_norm_id, cur_id);\n2710                 // Keep our accelerator map updated with new IDs if the\n2711                 // states we swapped were also accelerated.\n2712                 if let Some(accel2) = accels.remove(&next_norm_id) {\n2713                     accels.insert(cur_id, accel2);\n2714                 }\n2715                 if let Some(accel2) = accels.remove(&next_start_id) {\n2716                     accels.insert(next_norm_id, accel2);\n2717                 }\n2718                 accels.insert(next_start_id, accel);\n2719                 update_special_accel(&mut self.special, next_start_id);\n2720                 // Our start range shifts one to the right now.\n2721                 self.special.min_start =\n2722                     self.tt.next_state_id(self.special.min_start);\n2723                 self.special.max_start =\n2724                     self.tt.next_state_id(self.special.max_start);\n2725                 next_start_id = self.tt.next_state_id(next_start_id);\n2726                 next_norm_id = self.tt.next_state_id(next_norm_id);\n2727             }\n2728             // This is pretty tricky, but if our 'next_norm_id' state also\n2729             // happened to be accelerated, then the result is that it is\n2730             // now in the position of cur_id, so we need to consider it\n2731             // again. This loop is still guaranteed to terminate though,\n2732             // because when accels contains cur_id, we're guaranteed to\n2733             // increment next_norm_id even if cur_id remains unchanged.\n2734             if !accels.contains_key(&cur_id) {\n2735                 cur_id = self.tt.prev_state_id(cur_id);\n2736             }\n2737         }\n2738     }\n2739     // Just like we did for match states, but we want to move accelerated\n2740     // start states to the beginning of the range instead of the end.\n2741     if cstart > 0 {\n2742         // N.B. special.{min,max}_start do not need updating, since the\n2743         // range/number of start states does not change at this point. Only\n2744         // the ordering of start states may change.\n2745         let mut next_id = self.special.min_start;\n2746         let mut cur_id = next_id;\n2747         while cur_id <= self.special.max_start {\n2748             if let Some(accel) = accels.remove(&cur_id) {\n2749                 remapper.swap(self, cur_id, next_id);\n2750                 accels.insert(next_id, accel);\n2751                 update_special_accel(&mut self.special, next_id);\n2752                 next_id = self.tt.next_state_id(next_id);\n2753             }\n2754             cur_id = self.tt.next_state_id(cur_id);\n2755         }\n2756     }\n2757 \n2758     // Remap all transitions in our DFA and assert some things.\n2759     remapper.remap(self);\n2760     // This unwrap is OK because acceleration never changes the number of\n2761     // match states or patterns in those match states. Since acceleration\n2762     // runs after the pattern map has been set at least once, we know that\n2763     // our match states cannot error.\n2764     self.set_pattern_map(&new_matches).unwrap();\n2765     self.special.set_max();\n2766     self.special.validate().expect(\"special state ranges should validate\");\n2767     self.special\n2768         .validate_state_len(self.state_len(), self.stride2())\n2769         .expect(\n2770             \"special state ranges should be consistent with state length\",\n2771         );\n2772     assert_eq!(\n2773         self.special.accel_len(self.stride()),\n2774         // We record the number of accelerated states initially detected\n2775         // since the accels map is itself mutated in the process above.\n2776         // If mutated incorrectly, its size may change, and thus can't be\n2777         // trusted as a source of truth of how many accelerated states we\n2778         // expected there to be.\n2779         original_accels_len,\n2780         \"mismatch with expected number of accelerated states\",\n2781     );\n2782 \n2783     // And finally record our accelerators. We kept our accels map updated\n2784     // as we shuffled states above, so the accelerators should now\n2785     // correspond to a contiguous range in the state ID space. (Which we\n2786     // assert.)\n2787     let mut prev: Option<StateID> = None;\n2788     for (id, accel) in accels {\n2789         assert!(prev.map_or(true, |p| self.tt.next_state_id(p) == id));\n2790         prev = Some(id);\n2791         self.accels.add(accel);\n2792     }\n2793 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}