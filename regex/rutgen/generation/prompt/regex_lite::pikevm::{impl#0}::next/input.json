{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/pikevm.rs\n// crate name is regex_lite\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    int::{NonMaxUsize, U32},\n    nfa::{State, StateID, NFA},\n    pool::CachePoolGuard, utf8,\n};\n#[derive(Clone, Debug)]\npub(crate) struct PikeVM {\n    nfa: NFA,\n}\n#[derive(Clone)]\npub(crate) struct NFA {\n    /// The pattern string this NFA was generated from.\n    ///\n    /// We put it here for lack of a better place to put it. ¯\\_(ツ)_/¯\n    pattern: String,\n    /// The states that make up this NFA.\n    states: Vec<State>,\n    /// The ID of the start state.\n    start: StateID,\n    /// Whether this NFA can only match at the beginning of a haystack.\n    is_start_anchored: bool,\n    /// Whether this NFA can match the empty string.\n    is_match_empty: bool,\n    /// If every match has the same number of matching capture groups, then\n    /// this corresponds to the number of groups.\n    static_explicit_captures_len: Option<usize>,\n    /// A map from capture group name to its corresponding index.\n    cap_name_to_index: CaptureNameMap,\n    /// A map from capture group index to the corresponding name, if one\n    /// exists.\n    cap_index_to_name: Vec<Option<Arc<str>>>,\n    /// Heap memory used indirectly by NFA states and other things (like the\n    /// various capturing group representations above). Since each state\n    /// might use a different amount of heap, we need to keep track of this\n    /// incrementally.\n    memory_extra: usize,\n}\n#[derive(Clone, Debug)]\nstruct SlotTable {\n    /// The actual table of offsets.\n    table: Vec<Option<NonMaxUsize>>,\n    /// The number of slots per state, i.e., the table's stride or the length\n    /// of each row.\n    slots_per_state: usize,\n    /// The number of slots in the caller-provided `Captures` value for the\n    /// current search. Setting this to `slots_per_state` is always correct,\n    /// but may be wasteful.\n    slots_for_captures: usize,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub(crate) struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Debug)]\nstruct ActiveStates {\n    /// The set of active NFA states. This set preserves insertion order, which\n    /// is critical for simulating the match semantics of backtracking regex\n    /// engines.\n    set: SparseSet,\n    /// The slots for every NFA state, where each slot stores a (possibly\n    /// absent) offset. Every capturing group has two slots. One for a start\n    /// offset and one for an end offset.\n    slot_table: SlotTable,\n}\n#[derive(Clone, Eq, PartialEq)]\npub(crate) enum State {\n    Char { target: StateID, ch: char },\n    Ranges { target: StateID, ranges: Vec<(char, char)> },\n    Splits { targets: Vec<StateID>, reverse: bool },\n    Goto { target: StateID, look: Option<hir::Look> },\n    Capture { target: StateID, slot: u32 },\n    Fail,\n    Match,\n}\n#[derive(Clone, Debug)]\nenum FollowEpsilon {\n    /// Explore the epsilon transitions from a state ID.\n    Explore(StateID),\n    /// Reset the given `slot` to the given `offset` (which might be `None`).\n    RestoreCapture { slot: u32, offset: Option<NonMaxUsize> },\n}\nimpl PikeVM {\n    pub(crate) fn new(nfa: NFA) -> PikeVM {}\n    pub(crate) fn nfa(&self) -> &NFA {}\n    pub(crate) fn find_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> FindMatches<'r, 'h> {}\n    pub(crate) fn captures_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> CapturesMatches<'r, 'h> {}\n    pub(crate) fn search(\n        &self,\n        cache: &mut Cache,\n        haystack: &[u8],\n        start: usize,\n        end: usize,\n        earliest: bool,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {}\n    fn nexts(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {}\n    fn next(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slot_table: &mut SlotTable,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        sid: StateID,\n    ) -> bool {\n        match *self.nfa.state(sid) {\n            State::Fail\n            | State::Goto { .. }\n            | State::Splits { .. }\n            | State::Capture { .. } => false,\n            State::Char { target, ch } => {\n                if at_ch == ch && at_len > 0 {\n                    let slots = curr_slot_table.for_state(sid);\n                    let at = at.wrapping_add(at_len);\n                    self.epsilon_closure(stack, slots, next, haystack, at, target);\n                }\n                false\n            }\n            State::Ranges { target, ref ranges } => {\n                for (start, end) in ranges.iter().copied() {\n                    if start > at_ch {\n                        break;\n                    } else if start <= at_ch && at_ch <= end {\n                        if at_len == 0 {\n                            return false;\n                        }\n                        let slots = curr_slot_table.for_state(sid);\n                        let at = at.wrapping_add(at_len);\n                        self.epsilon_closure(stack, slots, next, haystack, at, target);\n                    }\n                }\n                false\n            }\n            State::Match => true,\n        }\n    }\n    fn epsilon_closure(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        sid: StateID,\n    ) {\n        stack.push(FollowEpsilon::Explore(sid));\n        while let Some(frame) = stack.pop() {\n            match frame {\n                FollowEpsilon::RestoreCapture { slot, offset } => {\n                    curr_slots[slot.as_usize()] = offset;\n                }\n                FollowEpsilon::Explore(sid) => {\n                    self.epsilon_closure_explore(\n                        stack,\n                        curr_slots,\n                        next,\n                        haystack,\n                        at,\n                        sid,\n                    );\n                }\n            }\n        }\n    }\n    fn epsilon_closure_explore(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        mut sid: StateID,\n    ) {}\n}\nimpl NFA {\n    pub(crate) fn new(config: Config, pattern: String, hir: &Hir) -> Result<NFA, Error> {}\n    pub(crate) fn pattern(&self) -> &str {}\n    pub(crate) fn state(&self, id: StateID) -> &State {\n        &self.states[id.as_usize()]\n    }\n    pub(crate) fn len(&self) -> usize {}\n    pub(crate) fn start(&self) -> StateID {}\n    pub(crate) fn to_index(&self, name: &str) -> Option<usize> {}\n    pub(crate) fn capture_names(&self) -> CaptureNames<'_> {}\n    pub(crate) fn group_len(&self) -> usize {}\n    pub(crate) fn is_start_anchored(&self) -> bool {}\n    pub(crate) fn static_explicit_captures_len(&self) -> Option<usize> {}\n    fn memory_usage(&self) -> usize {}\n}\nimpl SlotTable {\n    fn new() -> SlotTable {}\n    fn reset(&mut self, re: &PikeVM) {}\n    fn setup_search(&mut self, captures_slot_len: usize) {}\n    fn for_state(&mut self, sid: StateID) -> &mut [Option<NonMaxUsize>] {\n        let i = sid.as_usize() * self.slots_per_state;\n        &mut self.table[i..i + self.slots_for_captures]\n    }\n    fn all_absent(&mut self) -> &mut [Option<NonMaxUsize>] {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Starting from `sid`, if the position `at` in the `haystack` has a\n/// transition defined out of `sid`, then add the state transitioned to and\n/// its epsilon closure to the `next` set of states to explore.\n///\n/// `stack` is used by the epsilon closure computation to perform a depth\n/// first traversal of the NFA.\n///\n/// `curr_slot_table` should be the table of slots for the current set of\n/// states being explored. If there is a transition out of `sid`, then\n/// sid's row in the slot table is used to perform the epsilon closure.\n///\n/// `at_ch` is the Unicode scalar value whose UTF-8 encoding begins at `at`\n/// in `haystack`. The caller provides it so that this routine doesn't\n/// need to re-decode it. (Since it's expected that this routine is called\n/// multiple times for each position.)\n///\n/// `at_len` is the number of bytes consumed by `at_ch`. This is usually\n/// equal to `at_ch.len_utf8()`, but not always. For example, in the case\n/// where `at_ch` is the replacement codepoint that results from decoding\n/// invalid UTF-8. In that case, `at_len` can be 1, 2 or 3.\n241 fn next(\n242     &self,\n243     stack: &mut Vec<FollowEpsilon>,\n244     curr_slot_table: &mut SlotTable,\n245     next: &mut ActiveStates,\n246     haystack: &[u8],\n247     at: usize,\n248     at_ch: char,\n249     at_len: usize,\n250     sid: StateID,\n251 ) -> bool {\n252     match *self.nfa.state(sid) {\n253         State::Fail\n254         | State::Goto { .. }\n255         | State::Splits { .. }\n256         | State::Capture { .. } => false,\n257         State::Char { target, ch } => {\n258             if at_ch == ch && at_len > 0 {\n259                 let slots = curr_slot_table.for_state(sid);\n260                 // OK because `at_len` is always derived from the number\n261                 // of bytes read from `at` that make up `at_ch`. So this\n262                 // will never wrap.\n263                 let at = at.wrapping_add(at_len);\n264                 self.epsilon_closure(\n265                     stack, slots, next, haystack, at, target,\n266                 );\n267             }\n268             false\n269         }\n270         State::Ranges { target, ref ranges } => {\n271             for (start, end) in ranges.iter().copied() {\n272                 if start > at_ch {\n273                     break;\n274                 } else if start <= at_ch && at_ch <= end {\n275                     if at_len == 0 {\n276                         return false;\n277                     }\n278                     let slots = curr_slot_table.for_state(sid);\n279                     // OK because `at_len` is always derived from the\n280                     // number of bytes read from `at` that make up `at_ch`.\n281                     // So this will never wrap.\n282                     let at = at.wrapping_add(at_len);\n283                     self.epsilon_closure(\n284                         stack, slots, next, haystack, at, target,\n285                     );\n286                 }\n287             }\n288             false\n289         }\n290         State::Match => true,\n291     }\n292 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}