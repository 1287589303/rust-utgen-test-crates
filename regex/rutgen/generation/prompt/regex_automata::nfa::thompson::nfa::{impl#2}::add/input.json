{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/nfa.rs\n// crate name is regex_automata\nuse core::{fmt, mem};\nuse alloc::{boxed::Box, format, string::String, sync::Arc, vec, vec::Vec};\n#[cfg(feature = \"syntax\")]\nuse crate::nfa::thompson::{\n    compiler::{Compiler, Config},\n    error::BuildError,\n};\nuse crate::{\n    nfa::thompson::builder::Builder,\n    util::{\n        alphabet::{self, ByteClassSet, ByteClasses},\n        captures::{GroupInfo, GroupInfoError},\n        look::{Look, LookMatcher, LookSet},\n        primitives::{IteratorIndexExt, PatternID, PatternIDIter, SmallIndex, StateID},\n        sparse_set::SparseSet,\n    },\n};\n#[derive(Default)]\npub(super) struct Inner {\n    /// The state sequence. This sequence is guaranteed to be indexable by all\n    /// starting state IDs, and it is also guaranteed to contain at most one\n    /// `Match` state for each pattern compiled into this NFA. (A pattern may\n    /// not have a corresponding `Match` state if a `Match` state is impossible\n    /// to reach.)\n    states: Vec<State>,\n    /// The anchored starting state of this NFA.\n    start_anchored: StateID,\n    /// The unanchored starting state of this NFA.\n    start_unanchored: StateID,\n    /// The starting states for each individual pattern. Starting at any\n    /// of these states will result in only an anchored search for the\n    /// corresponding pattern. The vec is indexed by pattern ID. When the NFA\n    /// contains a single regex, then `start_pattern[0]` and `start_anchored`\n    /// are always equivalent.\n    start_pattern: Vec<StateID>,\n    /// Info about the capturing groups in this NFA. This is responsible for\n    /// mapping groups to slots, mapping groups to names and names to groups.\n    group_info: GroupInfo,\n    /// A representation of equivalence classes over the transitions in this\n    /// NFA. Two bytes in the same equivalence class must not discriminate\n    /// between a match or a non-match. This map can be used to shrink the\n    /// total size of a DFA's transition table with a small match-time cost.\n    ///\n    /// Note that the NFA's transitions are *not* defined in terms of these\n    /// equivalence classes. The NFA's transitions are defined on the original\n    /// byte values. For the most part, this is because they wouldn't really\n    /// help the NFA much since the NFA already uses a sparse representation\n    /// to represent transitions. Byte classes are most effective in a dense\n    /// representation.\n    byte_class_set: ByteClassSet,\n    /// This is generated from `byte_class_set`, and essentially represents the\n    /// same thing but supports different access patterns. Namely, this permits\n    /// looking up the equivalence class of a byte very cheaply.\n    ///\n    /// Ideally we would just store this, but because of annoying code\n    /// structure reasons, we keep both this and `byte_class_set` around for\n    /// now. I think I would prefer that `byte_class_set` were computed in the\n    /// `Builder`, but right now, we compute it as states are added to the\n    /// `NFA`.\n    byte_classes: ByteClasses,\n    /// Whether this NFA has a `Capture` state anywhere.\n    has_capture: bool,\n    /// When the empty string is in the language matched by this NFA.\n    has_empty: bool,\n    /// Whether UTF-8 mode is enabled for this NFA. Briefly, this means that\n    /// all non-empty matches produced by this NFA correspond to spans of valid\n    /// UTF-8, and any empty matches produced by this NFA that split a UTF-8\n    /// encoded codepoint should be filtered out by the corresponding regex\n    /// engine.\n    utf8: bool,\n    /// Whether this NFA is meant to be matched in reverse or not.\n    reverse: bool,\n    /// The matcher to be used for look-around assertions.\n    look_matcher: LookMatcher,\n    /// The union of all look-around assertions that occur anywhere within\n    /// this NFA. If this set is empty, then it means there are precisely zero\n    /// conditional epsilon transitions in the NFA.\n    look_set_any: LookSet,\n    /// The union of all look-around assertions that occur as a zero-length\n    /// prefix for any of the patterns in this NFA.\n    look_set_prefix_any: LookSet,\n    /// Heap memory used indirectly by NFA states and other things (like the\n    /// various capturing group representations above). Since each state\n    /// might use a different amount of heap, we need to keep track of this\n    /// incrementally.\n    memory_extra: usize,\n}\n#[cfg(feature = \"alloc\")]\n#[derive(Clone, Debug)]\npub(crate) struct ByteClassSet(ByteSet);\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq)]\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where\n    /// `i = Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u32,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct SparseTransitions {\n    /// The sorted sequence of non-overlapping transitions.\n    pub transitions: Box<[Transition]>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Transition {\n    /// The inclusive start of the byte range.\n    pub start: u8,\n    /// The inclusive end of the byte range.\n    pub end: u8,\n    /// The identifier of the state to transition to.\n    pub next: StateID,\n}\n#[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub(crate) struct State(Arc<[u8]>);\n#[derive(Clone)]\nstruct State {\n    /// A sorted sequence of non-overlapping transitions to other states. Each\n    /// transition corresponds to a single range of bytes.\n    transitions: Vec<Transition>,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Default)]\nstruct State {\n    transitions: Vec<Transition>,\n    chunks: Vec<(usize, usize)>,\n}\npub(crate) struct State<'a> {\n    id: StateID,\n    stride2: usize,\n    transitions: &'a [StateID],\n}\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Look {\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    Start = 1 << 0,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    End = 1 << 1,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLF = 1 << 2,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\n` character.\n    EndLF = 1 << 3,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following either a `\\r` or `\\n` character, but never after\n    /// a `\\r` when a `\\n` follows.\n    StartCRLF = 1 << 4,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\r` or `\\n` character, but never before a `\\n` when a `\\r`\n    /// precedes it.\n    EndCRLF = 1 << 5,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordAscii = 1 << 6,\n    /// Match an ASCII-only negation of a word boundary.\n    WordAsciiNegate = 1 << 7,\n    /// Match a Unicode-aware word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordUnicode = 1 << 8,\n    /// Match a Unicode-aware negation of a word boundary.\n    WordUnicodeNegate = 1 << 9,\n    /// Match the start of an ASCII-only word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStartAscii = 1 << 10,\n    /// Match the end of an ASCII-only word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEndAscii = 1 << 11,\n    /// Match the start of a Unicode word boundary. That is, this matches a\n    /// position at either the beginning of the haystack or where the previous\n    /// character is not a word character and the following character is a word\n    /// character.\n    WordStartUnicode = 1 << 12,\n    /// Match the end of a Unicode word boundary. That is, this matches a\n    /// position at either the end of the haystack or where the previous\n    /// character is a word character and the following character is not a word\n    /// character.\n    WordEndUnicode = 1 << 13,\n    /// Match the start half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalfAscii = 1 << 14,\n    /// Match the end half of an ASCII-only word boundary. That is, this\n    /// matches a position at either the end of the haystack or where the\n    /// following character is not a word character.\n    WordEndHalfAscii = 1 << 15,\n    /// Match the start half of a Unicode word boundary. That is, this matches\n    /// a position at either the beginning of the haystack or where the\n    /// previous character is not a word character.\n    WordStartHalfUnicode = 1 << 16,\n    /// Match the end half of a Unicode word boundary. That is, this matches\n    /// a position at either the end of the haystack or where the following\n    /// character is not a word character.\n    WordEndHalfUnicode = 1 << 17,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum State {\n    /// An empty state whose only purpose is to forward the automaton to\n    /// another state via an unconditional epsilon transition.\n    ///\n    /// Unconditional epsilon transitions are quite useful during the\n    /// construction of an NFA, as they permit the insertion of no-op\n    /// placeholders that make it easier to compose NFA sub-graphs. When\n    /// the Thompson NFA builder produces a final NFA, all unconditional\n    /// epsilon transitions are removed, and state identifiers are remapped\n    /// accordingly.\n    Empty {\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// A state that only transitions to another state if the current input\n    /// byte is in a particular range of bytes.\n    ByteRange { trans: Transition },\n    /// A state with possibly many transitions, represented in a sparse\n    /// fashion. Transitions must be ordered lexicographically by input range\n    /// and be non-overlapping. As such, this may only be used when every\n    /// transition has equal priority. (In practice, this is only used for\n    /// encoding large UTF-8 automata.) In contrast, a `Union` state has each\n    /// alternate in order of priority. Priority is used to implement greedy\n    /// matching and also alternations themselves, e.g., `abc|a` where `abc`\n    /// has priority over `a`.\n    ///\n    /// To clarify, it is possible to remove `Sparse` and represent all things\n    /// that `Sparse` is used for via `Union`. But this creates a more bloated\n    /// NFA with more epsilon transitions than is necessary in the special case\n    /// of character classes.\n    Sparse { transitions: Vec<Transition> },\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around.\n    Look { look: Look, next: StateID },\n    /// An empty state that records the start of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureStart {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An empty state that records the end of a capture location. This is an\n    /// unconditional epsilon transition like `Empty`, except it can be used to\n    /// record position information for a capture group when using the NFA for\n    /// search.\n    CaptureEnd {\n        /// The ID of the pattern that this capture was defined.\n        pattern_id: PatternID,\n        /// The capture group index that this capture state corresponds to.\n        /// The capture group index is always relative to its corresponding\n        /// pattern. Therefore, in the presence of multiple patterns, both the\n        /// pattern ID and the capture group index are required to uniquely\n        /// identify a capturing group.\n        group_index: SmallIndex,\n        /// The next state that this state should transition to.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union { alternates: Vec<StateID> },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via later transitions are\n    /// preferred over earlier transitions.\n    ///\n    /// This \"reverse\" state exists for convenience during compilation that\n    /// permits easy construction of non-greedy combinations of NFA states. At\n    /// the end of compilation, Union and UnionReverse states are merged into\n    /// one Union type of state, where the latter has its epsilon transitions\n    /// reversed to reflect the priority inversion.\n    ///\n    /// The \"convenience\" here arises from the fact that as new states are\n    /// added to the list of `alternates`, we would like that add operation\n    /// to be amortized constant time. But if we used a `Union`, we'd need to\n    /// prepend the state, which takes O(n) time. There are other approaches we\n    /// could use to solve this, but this seems simple enough.\n    UnionReverse { alternates: Vec<StateID> },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose a\n    /// `Fail` state to represent it.\n    Fail,\n    /// A match state. There is at most one such occurrence of this state in\n    /// an NFA for each pattern compiled into the NFA. At time of writing, a\n    /// match state is always produced for every pattern given, but in theory,\n    /// if a pattern can never lead to a match, then the match state could be\n    /// omitted.\n    ///\n    /// `pattern_id` refers to the ID of the pattern itself, which corresponds\n    /// to the pattern's index (starting at 0).\n    Match { pattern_id: PatternID },\n}\nimpl Inner {\n    pub(super) fn into_nfa(mut self) -> NFA {}\n    pub(super) fn group_info(&self) -> &GroupInfo {}\n    pub(super) fn add(&mut self, state: State) -> StateID {\n        match state {\n            State::ByteRange { ref trans } => {\n                self.byte_class_set.set_range(trans.start, trans.end);\n            }\n            State::Sparse(ref sparse) => {\n                for trans in sparse.transitions.iter() {\n                    self.byte_class_set.set_range(trans.start, trans.end);\n                }\n            }\n            State::Dense { .. } => unreachable!(),\n            State::Look { look, .. } => {\n                self.look_matcher.add_to_byteset(look, &mut self.byte_class_set);\n                self.look_set_any = self.look_set_any.insert(look);\n            }\n            State::Capture { .. } => {\n                self.has_capture = true;\n            }\n            State::Union { .. }\n            | State::BinaryUnion { .. }\n            | State::Fail\n            | State::Match { .. } => {}\n        }\n        let id = StateID::new(self.states.len()).unwrap();\n        self.memory_extra += state.memory_usage();\n        self.states.push(state);\n        id\n    }\n    pub(super) fn set_starts(\n        &mut self,\n        start_anchored: StateID,\n        start_unanchored: StateID,\n        start_pattern: &[StateID],\n    ) {}\n    pub(super) fn set_utf8(&mut self, yes: bool) {}\n    pub(super) fn set_reverse(&mut self, yes: bool) {}\n    pub(super) fn set_look_matcher(&mut self, m: LookMatcher) {}\n    pub(super) fn set_captures(\n        &mut self,\n        captures: &[Vec<Option<Arc<str>>>],\n    ) -> Result<(), GroupInfoError> {}\n    pub(super) fn remap(&mut self, old_to_new: &[StateID]) {}\n}\n#[cfg(feature = \"alloc\")]\nimpl ByteClassSet {\n    pub(crate) fn empty() -> Self {\n        ByteClassSet(ByteSet::empty())\n    }\n    pub(crate) fn set_range(&mut self, start: u8, end: u8) {\n        debug_assert!(start <= end);\n        if start > 0 {\n            self.0.add(start - 1);\n        }\n        self.0.add(end);\n    }\n    pub(crate) fn add_set(&mut self, set: &ByteSet) {}\n    pub(crate) fn byte_classes(&self) -> ByteClasses {}\n}\nimpl State {\n    #[inline]\n    pub fn is_epsilon(&self) -> bool {}\n    fn memory_usage(&self) -> usize {\n        match *self {\n            State::ByteRange { .. }\n            | State::Look { .. }\n            | State::BinaryUnion { .. }\n            | State::Capture { .. }\n            | State::Match { .. }\n            | State::Fail => 0,\n            State::Sparse(SparseTransitions { ref transitions }) => {\n                transitions.len() * mem::size_of::<Transition>()\n            }\n            State::Dense { .. } => 256 * mem::size_of::<StateID>(),\n            State::Union { ref alternates } => {\n                alternates.len() * mem::size_of::<StateID>()\n            }\n        }\n    }\n    fn remap(&mut self, remap: &[StateID]) {}\n}\nimpl LookMatcher {\n    pub fn new() -> LookMatcher {}\n    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {}\n    pub fn get_line_terminator(&self) -> u8 {}\n    #[inline]\n    pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_inline(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn matches_set(&self, set: LookSet, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_set_inline(\n        &self,\n        set: LookSet,\n        haystack: &[u8],\n        at: usize,\n    ) -> bool {}\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn add_to_byteset(\n        &self,\n        look: Look,\n        set: &mut crate::util::alphabet::ByteClassSet,\n    ) {\n        match look {\n            Look::Start | Look::End => {}\n            Look::StartLF | Look::EndLF => {\n                set.set_range(self.lineterm.0, self.lineterm.0);\n            }\n            Look::StartCRLF | Look::EndCRLF => {\n                set.set_range(b'\\r', b'\\r');\n                set.set_range(b'\\n', b'\\n');\n            }\n            Look::WordAscii\n            | Look::WordAsciiNegate\n            | Look::WordUnicode\n            | Look::WordUnicodeNegate\n            | Look::WordStartAscii\n            | Look::WordEndAscii\n            | Look::WordStartUnicode\n            | Look::WordEndUnicode\n            | Look::WordStartHalfAscii\n            | Look::WordEndHalfAscii\n            | Look::WordStartHalfUnicode\n            | Look::WordEndHalfUnicode => {\n                let iswb = utf8::is_word_byte;\n                let asu8 = |b: u16| u8::try_from(b).unwrap();\n                let mut b1: u16 = 0;\n                let mut b2: u16;\n                while b1 <= 255 {\n                    b2 = b1 + 1;\n                    while b2 <= 255 && iswb(asu8(b1)) == iswb(asu8(b2)) {\n                        b2 += 1;\n                    }\n                    assert!(b2 <= 256);\n                    set.set_range(asu8(b1), asu8(b2.checked_sub(1).unwrap()));\n                    b1 = b2;\n                }\n            }\n        }\n    }\n    #[inline]\n    pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_unicode_negate(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n}\nimpl LookSet {\n    #[inline]\n    pub fn empty() -> LookSet {}\n    #[inline]\n    pub fn full() -> LookSet {}\n    #[inline]\n    pub fn singleton(look: Look) -> LookSet {}\n    #[inline]\n    pub fn len(self) -> usize {}\n    #[inline]\n    pub fn is_empty(self) -> bool {}\n    #[inline]\n    pub fn contains(self, look: Look) -> bool {}\n    #[inline]\n    pub fn contains_anchor(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_haystack(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_line(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_lf(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_crlf(&self) -> bool {}\n    #[inline]\n    pub fn contains_word(self) -> bool {}\n    #[inline]\n    pub fn contains_word_unicode(self) -> bool {}\n    #[inline]\n    pub fn contains_word_ascii(self) -> bool {}\n    #[inline]\n    pub fn iter(self) -> LookSetIter {}\n    #[inline]\n    pub fn insert(self, look: Look) -> LookSet {\n        LookSet {\n            bits: self.bits | look.as_repr(),\n        }\n    }\n    #[inline]\n    pub fn set_insert(&mut self, look: Look) {}\n    #[inline]\n    pub fn remove(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_remove(&mut self, look: Look) {}\n    #[inline]\n    pub fn subtract(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_subtract(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn union(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_union(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn intersect(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_intersect(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn read_repr(slice: &[u8]) -> LookSet {}\n    #[inline]\n    pub fn write_repr(self, slice: &mut [u8]) {}\n    pub fn available(self) -> Result<(), UnicodeWordBoundaryError> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Add the given state to this NFA after allocating a fresh identifier for\n/// it.\n///\n/// This panics if too many states are added such that a fresh identifier\n/// could not be created. (Currently, the only caller of this routine is\n/// a `Builder`, and it upholds this invariant.)\n1355 pub(super) fn add(&mut self, state: State) -> StateID {\n1356     match state {\n1357         State::ByteRange { ref trans } => {\n1358             self.byte_class_set.set_range(trans.start, trans.end);\n1359         }\n1360         State::Sparse(ref sparse) => {\n1361             for trans in sparse.transitions.iter() {\n1362                 self.byte_class_set.set_range(trans.start, trans.end);\n1363             }\n1364         }\n1365         State::Dense { .. } => unreachable!(),\n1366         State::Look { look, .. } => {\n1367             self.look_matcher\n1368                 .add_to_byteset(look, &mut self.byte_class_set);\n1369             self.look_set_any = self.look_set_any.insert(look);\n1370         }\n1371         State::Capture { .. } => {\n1372             self.has_capture = true;\n1373         }\n1374         State::Union { .. }\n1375         | State::BinaryUnion { .. }\n1376         | State::Fail\n1377         | State::Match { .. } => {}\n1378     }\n1379 \n1380     let id = StateID::new(self.states.len()).unwrap();\n1381     self.memory_extra += state.memory_usage();\n1382     self.states.push(state);\n1383     id\n1384 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}