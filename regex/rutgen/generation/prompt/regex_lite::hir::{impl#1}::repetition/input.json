{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/hir/mod.rs\n// crate name is regex_lite\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\nuse crate::{error::Error, utf8};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) struct Hir {\n    kind: HirKind,\n    is_start_anchored: bool,\n    is_match_empty: bool,\n    static_explicit_captures_len: Option<usize>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) struct Repetition {\n    /// The minimum range of the repetition.\n    ///\n    /// Note that special cases like `?`, `+` and `*` all get translated into\n    /// the ranges `{0,1}`, `{1,}` and `{0,}`, respectively.\n    ///\n    /// When `min` is zero, this expression can match the empty string\n    /// regardless of what its sub-expression is.\n    pub(crate) min: u32,\n    /// The maximum range of the repetition.\n    ///\n    /// Note that when `max` is `None`, `min` acts as a lower bound but where\n    /// there is no upper bound. For something like `x{5}` where the min and\n    /// max are equivalent, `min` will be set to `5` and `max` will be set to\n    /// `Some(5)`.\n    pub(crate) max: Option<u32>,\n    /// Whether this repetition operator is greedy or not. A greedy operator\n    /// will match as much as it can. A non-greedy operator will match as\n    /// little as it can.\n    ///\n    /// Typically, operators are greedy by default and are only non-greedy when\n    /// a `?` suffix is used, e.g., `(expr)*` is greedy while `(expr)*?` is\n    /// not. However, this can be inverted via the `U` \"ungreedy\" flag.\n    pub(crate) greedy: bool,\n    /// The expression being repeated.\n    pub(crate) sub: Box<Hir>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) enum HirKind {\n    Empty,\n    Char(char),\n    Class(Class),\n    Look(Look),\n    Repetition(Repetition),\n    Capture(Capture),\n    Concat(Vec<Hir>),\n    Alternation(Vec<Hir>),\n}\nimpl Hir {\n    pub(crate) fn parse(config: Config, pattern: &str) -> Result<Hir, Error> {}\n    pub(crate) fn kind(&self) -> &HirKind {}\n    pub(crate) fn is_start_anchored(&self) -> bool {}\n    pub(crate) fn is_match_empty(&self) -> bool {}\n    pub(crate) fn static_explicit_captures_len(&self) -> Option<usize> {}\n    fn fail() -> Hir {}\n    fn empty() -> Hir {\n        let kind = HirKind::Empty;\n        Hir {\n            kind,\n            is_start_anchored: false,\n            is_match_empty: true,\n            static_explicit_captures_len: Some(0),\n        }\n    }\n    fn char(ch: char) -> Hir {}\n    fn class(class: Class) -> Hir {}\n    fn look(look: Look) -> Hir {}\n    fn repetition(rep: Repetition) -> Hir {\n        if rep.min == 0 && rep.max == Some(0) {\n            return Hir::empty();\n        } else if rep.min == 1 && rep.max == Some(1) {\n            return *rep.sub;\n        }\n        let is_start_anchored = rep.min > 0 && rep.sub.is_start_anchored;\n        let is_match_empty = rep.min == 0 || rep.sub.is_match_empty;\n        let mut static_explicit_captures_len = rep.sub.static_explicit_captures_len;\n        if rep.min == 0 && static_explicit_captures_len.map_or(false, |len| len > 0) {\n            if rep.max == Some(0) {\n                static_explicit_captures_len = Some(0);\n            } else {\n                static_explicit_captures_len = None;\n            }\n        }\n        Hir {\n            kind: HirKind::Repetition(rep),\n            is_start_anchored,\n            is_match_empty,\n            static_explicit_captures_len,\n        }\n    }\n    fn capture(cap: Capture) -> Hir {}\n    fn concat(mut subs: Vec<Hir>) -> Hir {}\n    fn alternation(mut subs: Vec<Hir>) -> Hir {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n260 fn repetition(rep: Repetition) -> Hir {\n261     if rep.min == 0 && rep.max == Some(0) {\n262         return Hir::empty();\n263     } else if rep.min == 1 && rep.max == Some(1) {\n264         return *rep.sub;\n265     }\n266     let is_start_anchored = rep.min > 0 && rep.sub.is_start_anchored;\n267     let is_match_empty = rep.min == 0 || rep.sub.is_match_empty;\n268     let mut static_explicit_captures_len =\n269         rep.sub.static_explicit_captures_len;\n270     // If the static captures len of the sub-expression is not known or\n271     // is greater than zero, then it automatically propagates to the\n272     // repetition, regardless of the repetition. Otherwise, it might\n273     // change, but only when the repetition can match 0 times.\n274     if rep.min == 0\n275         && static_explicit_captures_len.map_or(false, |len| len > 0)\n276     {\n277         // If we require a match 0 times, then our captures len is\n278         // guaranteed to be zero. Otherwise, if we *can* match the empty\n279         // string, then it's impossible to know how many captures will be\n280         // in the resulting match.\n281         if rep.max == Some(0) {\n282             static_explicit_captures_len = Some(0);\n283         } else {\n284             static_explicit_captures_len = None;\n285         }\n286     }\n287     Hir {\n288         kind: HirKind::Repetition(rep),\n289         is_start_anchored,\n290         is_match_empty,\n291         static_explicit_captures_len,\n292     }\n293 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}