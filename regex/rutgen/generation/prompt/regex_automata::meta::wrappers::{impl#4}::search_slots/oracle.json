{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/wrappers.rs\n// crate name is regex_automata\nuse alloc::vec::Vec;\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError},\n        regex::RegexInfo,\n    },\n    nfa::thompson::{pikevm, NFA},\n    util::{prefilter::Prefilter, primitives::NonMaxUsize},\n    HalfMatch, Input, Match, MatchKind, PatternID, PatternSet,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa;\n#[cfg(feature = \"dfa-onepass\")]\nuse crate::dfa::onepass;\n#[cfg(feature = \"hybrid\")]\nuse crate::hybrid;\n#[cfg(feature = \"nfa-backtrack\")]\nuse crate::nfa::thompson::backtrack;\n#[derive(Debug)]\npub(crate) struct BoundedBacktrackerEngine(\n    #[cfg(feature = \"nfa-backtrack\")]\n    backtrack::BoundedBacktracker,\n    #[cfg(not(feature = \"nfa-backtrack\"))]\n    (),\n);\n#[derive(Clone, Debug)]\npub struct BoundedBacktracker {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used on the heap for doing backtracking instead of the\n    /// traditional recursive approach. We don't want recursion because then\n    /// we're likely to hit a stack overflow for bigger regexes.\n    stack: Vec<Frame>,\n    /// The set of (StateID, HaystackOffset) pairs that have been visited\n    /// by the backtracker within a single search. If such a pair has been\n    /// visited, then we avoid doing the work for that pair again. This is\n    /// what \"bounds\" the backtracking and prevents it from having worst case\n    /// exponential time.\n    visited: Visited,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Debug)]\npub(crate) struct BoundedBacktracker(Option<BoundedBacktrackerEngine>);\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Debug)]\npub(crate) struct BoundedBacktrackerCache(\n    #[cfg(feature = \"nfa-backtrack\")]\n    Option<backtrack::Cache>,\n    #[cfg(not(feature = \"nfa-backtrack\"))]\n    (),\n);\nimpl BoundedBacktrackerEngine {\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n    ) -> Result<Option<BoundedBacktrackerEngine>, BuildError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_match(\n        &self,\n        cache: &mut BoundedBacktrackerCache,\n        input: &Input<'_>,\n    ) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn search_slots(\n        &self,\n        cache: &mut BoundedBacktrackerCache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {\n        #[cfg(feature = \"nfa-backtrack\")]\n        { self.0.try_search_slots(cache.0.as_mut().unwrap(), input, slots).unwrap() }\n        #[cfg(not(feature = \"nfa-backtrack\"))] { unreachable!() }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn max_haystack_len(&self) -> usize {}\n}\nimpl BoundedBacktracker {\n    #[inline]\n    pub fn try_search(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        caps: &mut Captures,\n    ) -> Result<(), MatchError> {}\n    #[inline]\n    pub fn try_search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<PatternID>, MatchError> {\n        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();\n        if !utf8empty {\n            let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;\n            return Ok(maybe_hm.map(|hm| hm.pattern()));\n        }\n        let min = self.get_nfa().group_info().implicit_slot_len();\n        if slots.len() >= min {\n            let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;\n            return Ok(maybe_hm.map(|hm| hm.pattern()));\n        }\n        if self.get_nfa().pattern_len() == 1 {\n            let mut enough = [None, None];\n            let got = self.try_search_slots_imp(cache, input, &mut enough)?;\n            slots.copy_from_slice(&enough[..slots.len()]);\n            return Ok(got.map(|hm| hm.pattern()));\n        }\n        let mut enough = vec![None; min];\n        let got = self.try_search_slots_imp(cache, input, &mut enough)?;\n        slots.copy_from_slice(&enough[..slots.len()]);\n        Ok(got.map(|hm| hm.pattern()))\n    }\n    #[inline(never)]\n    fn try_search_slots_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    fn search_imp(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Result<Option<HalfMatch>, MatchError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn backtrack(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        at: usize,\n        start_id: StateID,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn step(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        mut sid: StateID,\n        mut at: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<HalfMatch> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n251 pub(crate) fn search_slots(\n252     &self,\n253     cache: &mut BoundedBacktrackerCache,\n254     input: &Input<'_>,\n255     slots: &mut [Option<NonMaxUsize>],\n256 ) -> Option<PatternID> {\n257     #[cfg(feature = \"nfa-backtrack\")]\n258     {\n259         // OK because we only permit access to this engine when we know\n260         // the haystack is short enough for the backtracker to run without\n261         // reporting an error.\n262         self.0\n263             .try_search_slots(cache.0.as_mut().unwrap(), input, slots)\n264             .unwrap()\n265     }\n266     #[cfg(not(feature = \"nfa-backtrack\"))]\n267     {\n268         // Impossible to reach because this engine is never constructed\n269         // if the requisite features aren't enabled.\n270         unreachable!()\n271     }\n272 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}