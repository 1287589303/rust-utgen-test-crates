{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum HirKind {\n    /// The empty regular expression, which matches everything, including the\n    /// empty string.\n    Empty,\n    /// A literalstring that matches exactly these bytes.\n    Literal(Literal),\n    /// A single character class that matches any of the characters in the\n    /// class. A class can either consist of Unicode scalar values as\n    /// characters, or it can use bytes.\n    ///\n    /// A class may be empty. In which case, it matches nothing.\n    Class(Class),\n    /// A look-around assertion. A look-around match always has zero length.\n    Look(Look),\n    /// A repetition operation applied to a sub-expression.\n    Repetition(Repetition),\n    /// A capturing group, which contains a sub-expression.\n    Capture(Capture),\n    /// A concatenation of expressions.\n    ///\n    /// A concatenation matches only if each of its sub-expressions match one\n    /// after the other.\n    ///\n    /// Concatenations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Concat(Vec<Hir>),\n    /// An alternation of expressions.\n    ///\n    /// An alternation matches only if at least one of its sub-expressions\n    /// match. If multiple sub-expressions match, then the leftmost is\n    /// preferred.\n    ///\n    /// Alternations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Alternation(Vec<Hir>),\n}\nimpl Hir {\n    pub fn kind(&self) -> &HirKind {\n        &self.kind\n    }\n    pub fn into_kind(mut self) -> HirKind {}\n    pub fn properties(&self) -> &Properties {}\n    fn into_parts(mut self) -> (HirKind, Properties) {}\n}\nfn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>> {\n    let mut singletons = vec![];\n    for hir in hirs.iter() {\n        let literal = match *hir.kind() {\n            HirKind::Literal(Literal(ref bytes)) => bytes,\n            _ => return None,\n        };\n        let ch = match crate::debug::utf8_decode(literal) {\n            None => return None,\n            Some(Err(_)) => return None,\n            Some(Ok(ch)) => ch,\n        };\n        if literal.len() != ch.len_utf8() {\n            return None;\n        }\n        singletons.push(ch);\n    }\n    Some(singletons)\n}\npub(crate) fn utf8_decode(bytes: &[u8]) -> Option<Result<char, u8>> {\n    fn len(byte: u8) -> Option<usize> {\n        if byte <= 0x7F {\n            return Some(1);\n        } else if byte & 0b1100_0000 == 0b1000_0000 {\n            return None;\n        } else if byte <= 0b1101_1111 {\n            Some(2)\n        } else if byte <= 0b1110_1111 {\n            Some(3)\n        } else if byte <= 0b1111_0111 {\n            Some(4)\n        } else {\n            None\n        }\n    }\n    if bytes.is_empty() {\n        return None;\n    }\n    let len = match len(bytes[0]) {\n        None => return Some(Err(bytes[0])),\n        Some(len) if len > bytes.len() => return Some(Err(bytes[0])),\n        Some(1) => return Some(Ok(char::from(bytes[0]))),\n        Some(len) => len,\n    };\n    match core::str::from_utf8(&bytes[..len]) {\n        Ok(s) => Some(Ok(s.chars().next().unwrap())),\n        Err(_) => Some(Err(bytes[0])),\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Given a sequence of HIR values where each value corresponds to a literal\n/// that is a single `char`, return that sequence of `char`s. Otherwise return\n/// None. No deduplication is done.\n2978 fn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>> {\n2979     let mut singletons = vec![];\n2980     for hir in hirs.iter() {\n2981         let literal = match *hir.kind() {\n2982             HirKind::Literal(Literal(ref bytes)) => bytes,\n2983             _ => return None,\n2984         };\n2985         let ch = match crate::debug::utf8_decode(literal) {\n2986             None => return None,\n2987             Some(Err(_)) => return None,\n2988             Some(Ok(ch)) => ch,\n2989         };\n2990         if literal.len() != ch.len_utf8() {\n2991             return None;\n2992         }\n2993         singletons.push(ch);\n2994     }\n2995     Some(singletons)\n2996 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}