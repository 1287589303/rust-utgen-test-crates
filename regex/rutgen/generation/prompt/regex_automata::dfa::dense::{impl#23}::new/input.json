{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/dense.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\npub(crate) type OwnedDFA = DFA<alloc::vec::Vec<u32>>;\n#[cfg(feature = \"dfa-build\")]\nuse core::cmp;\nuse core::{fmt, iter, mem::size_of, slice};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{\n    collections::{BTreeMap, BTreeSet},\n    vec, vec::Vec,\n};\n#[cfg(feature = \"dfa-build\")]\nuse crate::{\n    dfa::{accel::Accel, determinize, minimize::Minimizer, remapper::Remapper, sparse},\n    nfa::thompson, util::{look::LookMatcher, search::MatchKind},\n};\nuse crate::{\n    dfa::{\n        accel::Accels, automaton::{fmt_state_indicator, Automaton, StartError},\n        special::Special, start::StartKind, DEAD,\n    },\n    util::{\n        alphabet::{self, ByteClasses, ByteSet},\n        int::{Pointer, Usize},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-dense\";\nconst VERSION: u32 = 2;\n#[derive(Clone, Debug)]\nstruct MatchStates<T> {\n    /// Slices is a flattened sequence of pairs, where each pair points to a\n    /// sub-slice of pattern_ids. The first element of the pair is an offset\n    /// into pattern_ids and the second element of the pair is the number\n    /// of 32-bit pattern IDs starting at that position. That is, each pair\n    /// corresponds to a single DFA match state and its corresponding match\n    /// IDs. The number of pairs always corresponds to the number of distinct\n    /// DFA match states.\n    ///\n    /// In practice, T is either Vec<u32> or &[u32].\n    slices: T,\n    /// A flattened sequence of pattern IDs for each DFA match state. The only\n    /// way to correctly read this sequence is indirectly via `slices`.\n    ///\n    /// In practice, T is either Vec<u32> or &[u32].\n    pattern_ids: T,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[cfg(feature = \"dfa-build\")]\nimpl MatchStates<Vec<u32>> {\n    fn empty(pattern_len: usize) -> MatchStates<Vec<u32>> {}\n    fn new(\n        matches: &BTreeMap<StateID, Vec<PatternID>>,\n        pattern_len: usize,\n    ) -> Result<MatchStates<Vec<u32>>, BuildError> {\n        let mut m = MatchStates::empty(pattern_len);\n        for (_, pids) in matches.iter() {\n            let start = PatternID::new(m.pattern_ids.len())\n                .map_err(|_| BuildError::too_many_match_pattern_ids())?;\n            m.slices.push(start.as_u32());\n            m.slices.push(u32::try_from(pids.len()).unwrap());\n            for &pid in pids {\n                m.pattern_ids.push(pid.as_u32());\n            }\n        }\n        m.pattern_len = pattern_len;\n        Ok(m)\n    }\n    fn new_with_map(\n        &self,\n        matches: &BTreeMap<StateID, Vec<PatternID>>,\n    ) -> Result<MatchStates<Vec<u32>>, BuildError> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n4431 fn new(\n4432     matches: &BTreeMap<StateID, Vec<PatternID>>,\n4433     pattern_len: usize,\n4434 ) -> Result<MatchStates<Vec<u32>>, BuildError> {\n4435     let mut m = MatchStates::empty(pattern_len);\n4436     for (_, pids) in matches.iter() {\n4437         let start = PatternID::new(m.pattern_ids.len())\n4438             .map_err(|_| BuildError::too_many_match_pattern_ids())?;\n4439         m.slices.push(start.as_u32());\n4440         // This is always correct since the number of patterns in a single\n4441         // match state can never exceed maximum number of allowable\n4442         // patterns. Why? Because a pattern can only appear once in a\n4443         // particular match state, by construction. (And since our pattern\n4444         // ID limit is one less than u32::MAX, we're guaranteed that the\n4445         // length fits in a u32.)\n4446         m.slices.push(u32::try_from(pids.len()).unwrap());\n4447         for &pid in pids {\n4448             m.pattern_ids.push(pid.as_u32());\n4449         }\n4450     }\n4451     m.pattern_len = pattern_len;\n4452     Ok(m)\n4453 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}