{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/utf8.rs\n// crate name is regex_lite\nconst ACCEPT: usize = 12;\nconst REJECT: usize = 0;\npub(crate) fn decode<B: AsRef<[u8]>>(slice: B) -> (Option<char>, usize) {\n    let slice = slice.as_ref();\n    match slice.get(0) {\n        None => return (None, 0),\n        Some(&b) if b <= 0x7F => return (Some(b as char), 1),\n        _ => {}\n    }\n    let (mut state, mut cp, mut i) = (ACCEPT, 0, 0);\n    while i < slice.len() {\n        decode_step(&mut state, &mut cp, slice[i]);\n        i += 1;\n        if state == ACCEPT {\n            let ch = char::from_u32(cp).unwrap();\n            return (Some(ch), i);\n        } else if state == REJECT {\n            return (None, core::cmp::max(1, i.saturating_sub(1)));\n        }\n    }\n    (None, i)\n}\nfn decode_step(state: &mut usize, cp: &mut u32, b: u8) {\n    #[rustfmt::skip]\n    const CLASSES: [u8; 256] = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        8,\n        8,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        10,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        4,\n        3,\n        3,\n        11,\n        6,\n        6,\n        6,\n        5,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n    ];\n    #[rustfmt::skip]\n    const STATES_FORWARD: &'static [u8] = &[\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        12,\n        0,\n        24,\n        36,\n        60,\n        96,\n        84,\n        0,\n        0,\n        0,\n        48,\n        72,\n        0,\n        12,\n        0,\n        0,\n        0,\n        0,\n        0,\n        12,\n        0,\n        12,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        24,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        36,\n        0,\n        36,\n        0,\n        0,\n        0,\n        36,\n        0,\n        0,\n        0,\n        0,\n        0,\n        36,\n        0,\n        36,\n        0,\n        0,\n        0,\n        36,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    let class = CLASSES[usize::from(b)];\n    if *state == ACCEPT {\n        *cp = (0xFF >> class) & (b as u32);\n    } else {\n        *cp = (b as u32 & 0b111111) | (*cp << 6);\n    }\n    *state = usize::from(STATES_FORWARD[*state + usize::from(class)]);\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// UTF-8 decode a single Unicode scalar value from the beginning of a slice.\n///\n/// When successful, the corresponding Unicode scalar value is returned along\n/// with the number of bytes it was encoded with. The number of bytes consumed\n/// for a successful decode is always between 1 and 4, inclusive.\n///\n/// When unsuccessful, `None` is returned along with the number of bytes that\n/// make up a maximal prefix of a valid UTF-8 code unit sequence. In this case,\n/// the number of bytes consumed is always between 0 and 3, inclusive, where\n/// 0 is only returned when `slice` is empty.\n56 pub(crate) fn decode<B: AsRef<[u8]>>(slice: B) -> (Option<char>, usize) {\n57     let slice = slice.as_ref();\n58     match slice.get(0) {\n59         None => return (None, 0),\n60         Some(&b) if b <= 0x7F => return (Some(b as char), 1),\n61         _ => {}\n62     }\n63 \n64     let (mut state, mut cp, mut i) = (ACCEPT, 0, 0);\n65     while i < slice.len() {\n66         decode_step(&mut state, &mut cp, slice[i]);\n67         i += 1;\n68 \n69         if state == ACCEPT {\n70             // OK since `decode_step` guarantees that `cp` is a valid Unicode\n71             // scalar value in an ACCEPT state.\n72             //\n73             // We don't have to use safe code here, but do so because perf\n74             // isn't our primary objective in regex-lite.\n75             let ch = char::from_u32(cp).unwrap();\n76             return (Some(ch), i);\n77         } else if state == REJECT {\n78             // At this point, we always want to advance at least one byte.\n79             return (None, core::cmp::max(1, i.saturating_sub(1)));\n80         }\n81     }\n82     (None, i)\n83 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}