{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/captures.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype CaptureNameMap = std::collections::HashMap<Arc<str>, SmallIndex>;\n#[cfg(not(feature = \"std\"))]\ntype CaptureNameMap = alloc::collections::BTreeMap<Arc<str>, SmallIndex>;\nuse alloc::{string::String, sync::Arc, vec, vec::Vec};\nuse crate::util::{\n    interpolate,\n    primitives::{NonMaxUsize, PatternID, PatternIDError, PatternIDIter, SmallIndex},\n    search::{Match, Span},\n};\n#[derive(Debug)]\npub struct GroupInfoAllNames<'a> {\n    group_info: &'a GroupInfo,\n    pids: PatternIDIter,\n    current_pid: Option<PatternID>,\n    names: Option<core::iter::Enumerate<GroupInfoPatternNames<'a>>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Debug, Default)]\nstruct GroupInfoInner {\n    slot_ranges: Vec<(SmallIndex, SmallIndex)>,\n    name_to_index: Vec<CaptureNameMap>,\n    index_to_name: Vec<Vec<Option<Arc<str>>>>,\n    memory_extra: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug)]\npub struct GroupInfoPatternNames<'a> {\n    it: core::slice::Iter<'a, Option<Arc<str>>>,\n}\nimpl<'a> Iterator for GroupInfoAllNames<'a> {\n    type Item = (PatternID, usize, Option<&'a str>);\n    fn next(&mut self) -> Option<(PatternID, usize, Option<&'a str>)> {\n        if self.group_info.0.index_to_name.is_empty() {\n            return None;\n        }\n        if self.current_pid.is_none() {\n            self.current_pid = Some(self.pids.next()?);\n        }\n        let pid = self.current_pid.unwrap();\n        if self.names.is_none() {\n            self.names = Some(self.group_info.pattern_names(pid).enumerate());\n        }\n        let (group_index, name) = match self.names.as_mut().unwrap().next() {\n            Some((group_index, name)) => (group_index, name),\n            None => {\n                self.current_pid = None;\n                self.names = None;\n                return self.next();\n            }\n        };\n        Some((pid, group_index, name))\n    }\n}\nimpl GroupInfo {\n    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>\n    where\n        P: IntoIterator<Item = G>,\n        G: IntoIterator<Item = Option<N>>,\n        N: AsRef<str>,\n    {}\n    pub fn empty() -> GroupInfo {}\n    #[inline]\n    pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {}\n    #[inline]\n    pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {}\n    #[inline]\n    pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {\n        GroupInfoPatternNames {\n            it: self\n                .0\n                .index_to_name\n                .get(pid.as_usize())\n                .map(|indices| indices.iter())\n                .unwrap_or([].iter()),\n        }\n    }\n    #[inline]\n    pub fn all_names(&self) -> GroupInfoAllNames<'_> {}\n    #[inline]\n    pub fn slots(&self, pid: PatternID, group_index: usize) -> Option<(usize, usize)> {}\n    #[inline]\n    pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn group_len(&self, pid: PatternID) -> usize {}\n    #[inline]\n    pub fn all_group_len(&self) -> usize {}\n    #[inline]\n    pub fn slot_len(&self) -> usize {}\n    #[inline]\n    pub fn implicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn explicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n2523 fn next(&mut self) -> Option<(PatternID, usize, Option<&'a str>)> {\n2524     // If the group info has no captures, then we never have anything\n2525     // to yield. We need to consider this case explicitly (at time of\n2526     // writing) because 'pattern_capture_names' will panic if captures\n2527     // aren't enabled.\n2528     if self.group_info.0.index_to_name.is_empty() {\n2529         return None;\n2530     }\n2531     if self.current_pid.is_none() {\n2532         self.current_pid = Some(self.pids.next()?);\n2533     }\n2534     let pid = self.current_pid.unwrap();\n2535     if self.names.is_none() {\n2536         self.names = Some(self.group_info.pattern_names(pid).enumerate());\n2537     }\n2538     let (group_index, name) = match self.names.as_mut().unwrap().next() {\n2539         Some((group_index, name)) => (group_index, name),\n2540         None => {\n2541             self.current_pid = None;\n2542             self.names = None;\n2543             return self.next();\n2544         }\n2545     };\n2546     Some((pid, group_index, name))\n2547 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}