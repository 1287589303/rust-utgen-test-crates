{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\nstruct Transitions<T> {\n    /// The raw encoding of each state in this DFA.\n    ///\n    /// Each state has the following information:\n    ///\n    /// * A set of transitions to subsequent states. Transitions to the dead\n    ///   state are omitted.\n    /// * If the state can be accelerated, then any additional accelerator\n    ///   information.\n    /// * If the state is a match state, then the state contains all pattern\n    ///   IDs that match when in that state.\n    ///\n    /// To decode a state, use Transitions::state.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8].\n    sparse: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride and is documented above.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is\n    /// if the DFA's kind uses byte classes which is the default. Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    ///\n    /// N.B. Equivalence classes aren't particularly useful in a sparse DFA\n    /// in the current implementation, since equivalence classes generally tend\n    /// to correspond to continuous ranges of bytes that map to the same\n    /// transition. So in a sparse DFA, equivalence classes don't really lead\n    /// to a space savings. In the future, it would be good to try and remove\n    /// them from sparse DFAs entirely, but requires a bit of work since sparse\n    /// DFAs are built from dense DFAs, which are in turn built on top of\n    /// equivalence classes.\n    classes: ByteClasses,\n    /// The total number of states in this DFA. Note that a DFA always has at\n    /// least one state---the dead state---even the empty DFA. In particular,\n    /// the dead state always has ID 0 and is correspondingly always the first\n    /// state. The dead state is never a match state.\n    state_len: usize,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\nimpl<'a> Transitions<&'a [u8]> {\n    unsafe fn from_bytes_unchecked(\n        mut slice: &'a [u8],\n    ) -> Result<(Transitions<&'a [u8]>, usize), DeserializeError> {\n        let slice_start = slice.as_ptr().as_usize();\n        let (state_len, nr) = wire::try_read_u32_as_usize(&slice, \"state length\")?;\n        slice = &slice[nr..];\n        let (pattern_len, nr) = wire::try_read_u32_as_usize(&slice, \"pattern length\")?;\n        slice = &slice[nr..];\n        let (classes, nr) = ByteClasses::from_bytes(&slice)?;\n        slice = &slice[nr..];\n        let (len, nr) = wire::try_read_u32_as_usize(\n            &slice,\n            \"sparse transitions length\",\n        )?;\n        slice = &slice[nr..];\n        wire::check_slice_len(slice, len, \"sparse states byte length\")?;\n        let sparse = &slice[..len];\n        slice = &slice[len..];\n        let trans = Transitions {\n            sparse,\n            classes,\n            state_len,\n            pattern_len,\n        };\n        Ok((trans, slice.as_ptr().as_usize() - slice_start))\n    }\n}\nimpl ByteClasses {\n    #[inline]\n    pub fn empty() -> ByteClasses {}\n    #[inline]\n    pub fn singletons() -> ByteClasses {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteClasses, usize), DeserializeError> {\n        wire::check_slice_len(slice, 256, \"byte class map\")?;\n        let mut classes = ByteClasses::empty();\n        for (b, &class) in slice[..256].iter().enumerate() {\n            classes.set(u8::try_from(b).unwrap(), class);\n        }\n        for &b in classes.0.iter() {\n            if usize::from(b) >= classes.alphabet_len() {\n                return Err(\n                    DeserializeError::generic(\n                        \"found equivalence class greater than alphabet len\",\n                    ),\n                );\n            }\n        }\n        Ok((classes, 256))\n    }\n    pub(crate) fn write_to(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[inline]\n    pub fn set(&mut self, byte: u8, class: u8) {}\n    #[inline]\n    pub fn get(&self, byte: u8) -> u8 {}\n    #[inline]\n    pub fn get_by_unit(&self, unit: Unit) -> usize {}\n    #[inline]\n    pub fn eoi(&self) -> Unit {}\n    #[inline]\n    pub fn alphabet_len(&self) -> usize {}\n    #[inline]\n    pub fn stride2(&self) -> usize {}\n    #[inline]\n    pub fn is_singleton(&self) -> bool {}\n    #[inline]\n    pub fn iter(&self) -> ByteClassIter<'_> {}\n    pub fn representatives<R: core::ops::RangeBounds<u8>>(\n        &self,\n        range: R,\n    ) -> ByteClassRepresentatives<'_> {}\n    #[inline]\n    pub fn elements(&self, class: Unit) -> ByteClassElements {}\n    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges {}\n}\npub(crate) fn try_read_u32_as_usize(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(usize, usize), DeserializeError> {\n    try_read_u32(slice, what)\n        .and_then(|(n, nr)| {\n            usize::try_from(n)\n                .map(|n| (n, nr))\n                .map_err(|_| DeserializeError::invalid_usize(what))\n        })\n}\npub(crate) fn check_slice_len<T>(\n    slice: &[T],\n    at_least_len: usize,\n    what: &'static str,\n) -> Result<(), DeserializeError> {\n    if slice.len() < at_least_len {\n        return Err(DeserializeError::buffer_too_small(what));\n    }\n    Ok(())\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1300 unsafe fn from_bytes_unchecked(\n1301     mut slice: &'a [u8],\n1302 ) -> Result<(Transitions<&'a [u8]>, usize), DeserializeError> {\n1303     let slice_start = slice.as_ptr().as_usize();\n1304 \n1305     let (state_len, nr) =\n1306         wire::try_read_u32_as_usize(&slice, \"state length\")?;\n1307     slice = &slice[nr..];\n1308 \n1309     let (pattern_len, nr) =\n1310         wire::try_read_u32_as_usize(&slice, \"pattern length\")?;\n1311     slice = &slice[nr..];\n1312 \n1313     let (classes, nr) = ByteClasses::from_bytes(&slice)?;\n1314     slice = &slice[nr..];\n1315 \n1316     let (len, nr) =\n1317         wire::try_read_u32_as_usize(&slice, \"sparse transitions length\")?;\n1318     slice = &slice[nr..];\n1319 \n1320     wire::check_slice_len(slice, len, \"sparse states byte length\")?;\n1321     let sparse = &slice[..len];\n1322     slice = &slice[len..];\n1323 \n1324     let trans = Transitions { sparse, classes, state_len, pattern_len };\n1325     Ok((trans, slice.as_ptr().as_usize() - slice_start))\n1326 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}