{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/alphabet.rs\n// crate name is regex_automata\nuse crate::util::{escape::DebugByte, wire::{self, DeserializeError, SerializeError}};\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]\npub struct Unit(UnitKind);\n#[derive(Debug)]\npub struct ByteClassElements<'a> {\n    classes: &'a ByteClasses,\n    class: Unit,\n    byte: usize,\n}\nimpl ByteClasses {\n    #[inline]\n    pub fn empty() -> ByteClasses {}\n    #[inline]\n    pub fn singletons() -> ByteClasses {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteClasses, usize), DeserializeError> {}\n    pub(crate) fn write_to(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[inline]\n    pub fn set(&mut self, byte: u8, class: u8) {}\n    #[inline]\n    pub fn get(&self, byte: u8) -> u8 {}\n    #[inline]\n    pub fn get_by_unit(&self, unit: Unit) -> usize {}\n    #[inline]\n    pub fn eoi(&self) -> Unit {}\n    #[inline]\n    pub fn alphabet_len(&self) -> usize {}\n    #[inline]\n    pub fn stride2(&self) -> usize {}\n    #[inline]\n    pub fn is_singleton(&self) -> bool {}\n    #[inline]\n    pub fn iter(&self) -> ByteClassIter<'_> {}\n    pub fn representatives<R: core::ops::RangeBounds<u8>>(\n        &self,\n        range: R,\n    ) -> ByteClassRepresentatives<'_> {}\n    #[inline]\n    pub fn elements(&self, class: Unit) -> ByteClassElements {\n        ByteClassElements {\n            classes: self,\n            class,\n            byte: 0,\n        }\n    }\n    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns an iterator of the bytes in the given equivalence class.\n///\n/// This is useful when one needs to know the actual bytes that belong to\n/// an equivalence class. For example, conceptually speaking, accelerating\n/// a DFA state occurs when a state only has a few outgoing transitions.\n/// But in reality, what is required is that there are only a small\n/// number of distinct bytes that can lead to an outgoing transition. The\n/// difference is that any one transition can correspond to an equivalence\n/// class which may contains many bytes. Therefore, DFA state acceleration\n/// considers the actual elements in each equivalence class of each\n/// outgoing transition.\n///\n/// # Example\n///\n/// This shows an example of how to get all of the elements in an\n/// equivalence class.\n///\n/// ```\n/// use regex_automata::{nfa::thompson::NFA, util::alphabet::Unit};\n///\n/// let nfa = NFA::new(\"[a-z]+\")?;\n/// let classes = nfa.byte_classes();\n/// let elements: Vec<Unit> = classes.elements(Unit::u8(1)).collect();\n/// let expected: Vec<Unit> = (b'a'..=b'z').map(Unit::u8).collect();\n/// assert_eq!(expected, elements);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n472 pub fn elements(&self, class: Unit) -> ByteClassElements {\n473     ByteClassElements { classes: self, class, byte: 0 }\n474 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}