{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/alphabet.rs\n// crate name is regex_automata\nuse crate::util::{escape::DebugByte, wire::{self, DeserializeError, SerializeError}};\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\n#[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]\npub struct Unit(UnitKind);\n#[derive(Debug)]\npub struct ByteClassElements<'a> {\n    classes: &'a ByteClasses,\n    class: Unit,\n    byte: usize,\n}\nimpl ByteClasses {\n    #[inline]\n    pub fn empty() -> ByteClasses {}\n    #[inline]\n    pub fn singletons() -> ByteClasses {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(ByteClasses, usize), DeserializeError> {}\n    pub(crate) fn write_to(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[inline]\n    pub fn set(&mut self, byte: u8, class: u8) {}\n    #[inline]\n    pub fn get(&self, byte: u8) -> u8 {}\n    #[inline]\n    pub fn get_by_unit(&self, unit: Unit) -> usize {}\n    #[inline]\n    pub fn eoi(&self) -> Unit {}\n    #[inline]\n    pub fn alphabet_len(&self) -> usize {}\n    #[inline]\n    pub fn stride2(&self) -> usize {}\n    #[inline]\n    pub fn is_singleton(&self) -> bool {}\n    #[inline]\n    pub fn iter(&self) -> ByteClassIter<'_> {}\n    pub fn representatives<R: core::ops::RangeBounds<u8>>(\n        &self,\n        range: R,\n    ) -> ByteClassRepresentatives<'_> {}\n    #[inline]\n    pub fn elements(&self, class: Unit) -> ByteClassElements {\n        ByteClassElements {\n            classes: self,\n            class,\n            byte: 0,\n        }\n    }\n    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns an iterator of the bytes in the given equivalence class.\n///\n/// This is useful when one needs to know the actual bytes that belong to\n/// an equivalence class. For example, conceptually speaking, accelerating\n/// a DFA state occurs when a state only has a few outgoing transitions.\n/// But in reality, what is required is that there are only a small\n/// number of distinct bytes that can lead to an outgoing transition. The\n/// difference is that any one transition can correspond to an equivalence\n/// class which may contains many bytes. Therefore, DFA state acceleration\n/// considers the actual elements in each equivalence class of each\n/// outgoing transition.\n///\n/// # Example\n///\n/// This shows an example of how to get all of the elements in an\n/// equivalence class.\n///\n/// ```\n/// use regex_automata::{nfa::thompson::NFA, util::alphabet::Unit};\n///\n/// let nfa = NFA::new(\"[a-z]+\")?;\n/// let classes = nfa.byte_classes();\n/// let elements: Vec<Unit> = classes.elements(Unit::u8(1)).collect();\n/// let expected: Vec<Unit> = (b'a'..=b'z').map(Unit::u8).collect();\n/// assert_eq!(expected, elements);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n472 pub fn elements(&self, class: Unit) -> ByteClassElements {\n473     ByteClassElements { classes: self, class, byte: 0 }\n474 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}