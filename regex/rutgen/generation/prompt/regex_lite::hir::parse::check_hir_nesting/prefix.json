{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/hir/parse.rs\n// crate name is regex_lite\nuse core::cell::{Cell, RefCell};\nuse alloc::{\n    boxed::Box, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{error::Error, hir::{self, Config, Flags, Hir, HirKind}};\nconst ERR_TOO_MUCH_NESTING: &str = \"pattern has too much nesting\";\nconst ERR_TOO_MANY_CAPTURES: &str = \"too many capture groups\";\nconst ERR_DUPLICATE_CAPTURE_NAME: &str = \"duplicate capture group name\";\nconst ERR_UNCLOSED_GROUP: &str = \"found open group without closing ')'\";\nconst ERR_UNCLOSED_GROUP_QUESTION: &str = \"expected closing ')', but got end of pattern\";\nconst ERR_UNOPENED_GROUP: &str = \"found closing ')' without matching '('\";\nconst ERR_LOOK_UNSUPPORTED: &str = \"look-around is not supported\";\nconst ERR_EMPTY_FLAGS: &str = \"empty flag directive '(?)' is not allowed\";\nconst ERR_MISSING_GROUP_NAME: &str = \"expected capture group name, but got end of pattern\";\nconst ERR_INVALID_GROUP_NAME: &str = \"invalid group name\";\nconst ERR_UNCLOSED_GROUP_NAME: &str = \"expected end of capture group name, but got end of pattern\";\nconst ERR_EMPTY_GROUP_NAME: &str = \"empty capture group names are not allowed\";\nconst ERR_FLAG_UNRECOGNIZED: &str = \"unrecognized inline flag\";\nconst ERR_FLAG_REPEATED_NEGATION: &str = \"inline flag negation cannot be repeated\";\nconst ERR_FLAG_DUPLICATE: &str = \"duplicate inline flag is not allowed\";\nconst ERR_FLAG_UNEXPECTED_EOF: &str = \"expected ':' or ')' to end inline flags, but got end of pattern\";\nconst ERR_FLAG_DANGLING_NEGATION: &str = \"inline flags cannot end with negation directive\";\nconst ERR_DECIMAL_NO_DIGITS: &str = \"expected decimal number, but found no digits\";\nconst ERR_DECIMAL_INVALID: &str = \"got invalid decimal number\";\nconst ERR_HEX_BRACE_INVALID_DIGIT: &str = \"expected hexadecimal number in braces, but got non-hex digit\";\nconst ERR_HEX_BRACE_UNEXPECTED_EOF: &str = \"expected hexadecimal number, but saw end of pattern before closing brace\";\nconst ERR_HEX_BRACE_EMPTY: &str = \"expected hexadecimal number in braces, but got no digits\";\nconst ERR_HEX_BRACE_INVALID: &str = \"got invalid hexadecimal number in braces\";\nconst ERR_HEX_FIXED_UNEXPECTED_EOF: &str = \"expected fixed length hexadecimal number, but saw end of pattern first\";\nconst ERR_HEX_FIXED_INVALID_DIGIT: &str = \"expected fixed length hexadecimal number, but got non-hex digit\";\nconst ERR_HEX_FIXED_INVALID: &str = \"got invalid fixed length hexadecimal number\";\nconst ERR_HEX_UNEXPECTED_EOF: &str = \"expected hexadecimal number, but saw end of pattern first\";\nconst ERR_ESCAPE_UNEXPECTED_EOF: &str = \"saw start of escape sequence, but saw end of pattern before it finished\";\nconst ERR_BACKREF_UNSUPPORTED: &str = \"backreferences are not supported\";\nconst ERR_UNICODE_CLASS_UNSUPPORTED: &str = \"Unicode character classes are not supported\";\nconst ERR_ESCAPE_UNRECOGNIZED: &str = \"unrecognized escape sequence\";\nconst ERR_POSIX_CLASS_UNRECOGNIZED: &str = \"unrecognized POSIX character class\";\nconst ERR_UNCOUNTED_REP_SUB_MISSING: &str = \"uncounted repetition operator must be applied to a sub-expression\";\nconst ERR_COUNTED_REP_SUB_MISSING: &str = \"counted repetition operator must be applied to a sub-expression\";\nconst ERR_COUNTED_REP_UNCLOSED: &str = \"found unclosed counted repetition operator\";\nconst ERR_COUNTED_REP_MIN_UNCLOSED: &str = \"found incomplete and unclosed counted repetition operator\";\nconst ERR_COUNTED_REP_COMMA_UNCLOSED: &str = \"found counted repetition operator with a comma that is unclosed\";\nconst ERR_COUNTED_REP_MIN_MAX_UNCLOSED: &str = \"found counted repetition with min and max that is unclosed\";\nconst ERR_COUNTED_REP_INVALID: &str = \"expected closing brace for counted repetition, but got something else\";\nconst ERR_COUNTED_REP_INVALID_RANGE: &str = \"found counted repetition with a min bigger than its max\";\nconst ERR_CLASS_UNCLOSED_AFTER_ITEM: &str = \"non-empty character class has no closing bracket\";\nconst ERR_CLASS_INVALID_RANGE_ITEM: &str = \"character class ranges must start and end with a single character\";\nconst ERR_CLASS_INVALID_ITEM: &str = \"invalid escape sequence in character class\";\nconst ERR_CLASS_UNCLOSED_AFTER_DASH: &str = \"non-empty character class has no closing bracket after dash\";\nconst ERR_CLASS_UNCLOSED_AFTER_NEGATION: &str = \"negated character class has no closing bracket\";\nconst ERR_CLASS_UNCLOSED_AFTER_CLOSING: &str = \"character class begins with literal ']' but has no closing bracket\";\nconst ERR_CLASS_INVALID_RANGE: &str = \"invalid range in character class\";\nconst ERR_CLASS_UNCLOSED: &str = \"found unclosed character class\";\nconst ERR_CLASS_NEST_UNSUPPORTED: &str = \"nested character classes are not supported\";\nconst ERR_CLASS_INTERSECTION_UNSUPPORTED: &str = \"character class intersection is not supported\";\nconst ERR_CLASS_DIFFERENCE_UNSUPPORTED: &str = \"character class difference is not supported\";\nconst ERR_CLASS_SYMDIFFERENCE_UNSUPPORTED: &str = \"character class symmetric difference is not supported\";\nconst ERR_SPECIAL_WORD_BOUNDARY_UNCLOSED: &str = \"special word boundary assertion is unclosed or has an invalid character\";\nconst ERR_SPECIAL_WORD_BOUNDARY_UNRECOGNIZED: &str = \"special word boundary assertion is unrecognized\";\nconst ERR_SPECIAL_WORD_OR_REP_UNEXPECTED_EOF: &str = \"found start of special word boundary or repetition without an end\";\n#[derive(Clone, Debug, Eq, PartialEq)]\npub(crate) struct Hir {\n    kind: HirKind,\n    is_start_anchored: bool,\n    is_match_empty: bool,\n    static_explicit_captures_len: Option<usize>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    msg: &'static str,\n}\nfn check_hir_nesting(hir: &Hir, limit: u32) -> Result<(), Error> {\n    fn recurse(hir: &Hir, limit: u32, depth: u32) -> Result<(), Error> {\n        if depth > limit {\n            return Err(Error::new(ERR_TOO_MUCH_NESTING));\n        }\n        let Some(next_depth) = depth.checked_add(1) else {\n            return Err(Error::new(ERR_TOO_MUCH_NESTING));\n        };\n        match *hir.kind() {\n            HirKind::Empty | HirKind::Char(_) | HirKind::Class(_) | HirKind::Look(_) => {\n                Ok(())\n            }\n            HirKind::Repetition(hir::Repetition { ref sub, .. }) => {\n                recurse(sub, limit, next_depth)\n            }\n            HirKind::Capture(hir::Capture { ref sub, .. }) => {\n                recurse(sub, limit, next_depth)\n            }\n            HirKind::Concat(ref subs) | HirKind::Alternation(ref subs) => {\n                for sub in subs.iter() {\n                    recurse(sub, limit, next_depth)?;\n                }\n                Ok(())\n            }\n        }\n    }\n    recurse(hir, limit, 0)\n}\nfn recurse(hir: &Hir, limit: u32, depth: u32) -> Result<(), Error> {\n    if depth > limit {\n        return Err(Error::new(ERR_TOO_MUCH_NESTING));\n    }\n    let Some(next_depth) = depth.checked_add(1) else {\n        return Err(Error::new(ERR_TOO_MUCH_NESTING));\n    };\n    match *hir.kind() {\n        HirKind::Empty | HirKind::Char(_) | HirKind::Class(_) | HirKind::Look(_) => {\n            Ok(())\n        }\n        HirKind::Repetition(hir::Repetition { ref sub, .. }) => {\n            recurse(sub, limit, next_depth)\n        }\n        HirKind::Capture(hir::Capture { ref sub, .. }) => recurse(sub, limit, next_depth),\n        HirKind::Concat(ref subs) | HirKind::Alternation(ref subs) => {\n            for sub in subs.iter() {\n                recurse(sub, limit, next_depth)?;\n            }\n            Ok(())\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// This checks the depth of the given `Hir` value, and if it exceeds the given\n/// limit, then an error is returned.\n1286 fn check_hir_nesting(hir: &Hir, limit: u32) -> Result<(), Error> {\n1287     fn recurse(hir: &Hir, limit: u32, depth: u32) -> Result<(), Error> {\n1288         if depth > limit {\n1289             return Err(Error::new(ERR_TOO_MUCH_NESTING));\n1290         }\n1291         let Some(next_depth) = depth.checked_add(1) else {\n1292             return Err(Error::new(ERR_TOO_MUCH_NESTING));\n1293         };\n1294         match *hir.kind() {\n1295             HirKind::Empty\n1296             | HirKind::Char(_)\n1297             | HirKind::Class(_)\n1298             | HirKind::Look(_) => Ok(()),\n1299             HirKind::Repetition(hir::Repetition { ref sub, .. }) => {\n1300                 recurse(sub, limit, next_depth)\n1301             }\n1302             HirKind::Capture(hir::Capture { ref sub, .. }) => {\n1303                 recurse(sub, limit, next_depth)\n1304             }\n1305             HirKind::Concat(ref subs) | HirKind::Alternation(ref subs) => {\n1306                 for sub in subs.iter() {\n1307                     recurse(sub, limit, next_depth)?;\n1308                 }\n1309                 Ok(())\n1310             }\n1311         }\n1312     }\n1313     recurse(hir, limit, 0)\n1314 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}