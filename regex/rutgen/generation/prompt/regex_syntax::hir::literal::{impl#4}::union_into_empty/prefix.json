{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/literal.rs\n// crate name is regex_syntax\nuse core::{cmp, mem, num::NonZeroUsize};\nuse alloc::{vec, vec::Vec};\nuse crate::hir::{self, Hir};\n#[derive(Clone, Eq, PartialEq)]\npub struct Seq {\n    /// The members of this seq.\n    ///\n    /// When `None`, the seq represents all possible literals. That is, it\n    /// prevents one from making assumptions about specific literals in the\n    /// seq, and forces one to treat it as if any literal might be in the seq.\n    ///\n    /// Note that `Some(vec![])` is valid and corresponds to the empty seq of\n    /// literals, i.e., a regex that can never match. For example, `[a&&b]`.\n    /// It is distinct from `Some(vec![\"\"])`, which corresponds to the seq\n    /// containing an empty string, which matches at every position.\n    literals: Option<Vec<Literal>>,\n}\n#[derive(Clone, Eq, PartialEq, PartialOrd, Ord)]\npub struct Literal {\n    bytes: Vec<u8>,\n    exact: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n#[derive(Clone, Eq, PartialEq)]\npub struct Literal(pub Box<[u8]>);\nimpl Seq {\n    #[inline]\n    pub fn empty() -> Seq {}\n    #[inline]\n    pub fn infinite() -> Seq {}\n    #[inline]\n    pub fn singleton(lit: Literal) -> Seq {}\n    #[inline]\n    pub fn new<I, B>(it: I) -> Seq\n    where\n        I: IntoIterator<Item = B>,\n        B: AsRef<[u8]>,\n    {}\n    #[inline]\n    pub fn literals(&self) -> Option<&[Literal]> {}\n    #[inline]\n    pub fn push(&mut self, lit: Literal) {}\n    #[inline]\n    pub fn make_inexact(&mut self) {}\n    #[inline]\n    pub fn make_infinite(&mut self) {}\n    #[inline]\n    pub fn cross_forward(&mut self, other: &mut Seq) {}\n    #[inline]\n    pub fn cross_reverse(&mut self, other: &mut Seq) {}\n    fn cross_preamble<'a>(\n        &'a mut self,\n        other: &'a mut Seq,\n    ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)> {}\n    #[inline]\n    pub fn union(&mut self, other: &mut Seq) {}\n    #[inline]\n    pub fn union_into_empty(&mut self, other: &mut Seq) {\n        let lits2 = other.literals.as_mut().map(|lits| lits.drain(..));\n        let lits1 = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        let first_empty = match lits1.iter().position(|m| m.is_empty()) {\n            None => return,\n            Some(i) => i,\n        };\n        let lits2 = match lits2 {\n            None => {\n                self.literals = None;\n                return;\n            }\n            Some(lits) => lits,\n        };\n        lits1.retain(|m| !m.is_empty());\n        lits1.splice(first_empty..first_empty, lits2);\n        self.dedup();\n    }\n    #[inline]\n    pub fn dedup(&mut self) {\n        if let Some(ref mut lits) = self.literals {\n            lits.dedup_by(|lit1, lit2| {\n                if lit1.as_bytes() != lit2.as_bytes() {\n                    return false;\n                }\n                if lit1.is_exact() != lit2.is_exact() {\n                    lit1.make_inexact();\n                    lit2.make_inexact();\n                }\n                true\n            });\n        }\n    }\n    #[inline]\n    pub fn sort(&mut self) {}\n    #[inline]\n    pub fn reverse_literals(&mut self) {}\n    #[inline]\n    pub fn minimize_by_preference(&mut self) {}\n    #[inline]\n    pub fn keep_first_bytes(&mut self, len: usize) {}\n    #[inline]\n    pub fn keep_last_bytes(&mut self, len: usize) {}\n    #[inline]\n    pub fn is_finite(&self) -> bool {}\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    pub fn len(&self) -> Option<usize> {}\n    #[inline]\n    pub fn is_exact(&self) -> bool {}\n    #[inline]\n    pub fn is_inexact(&self) -> bool {}\n    #[inline]\n    pub fn max_union_len(&self, other: &Seq) -> Option<usize> {}\n    #[inline]\n    pub fn max_cross_len(&self, other: &Seq) -> Option<usize> {}\n    #[inline]\n    pub fn min_literal_len(&self) -> Option<usize> {}\n    #[inline]\n    pub fn max_literal_len(&self) -> Option<usize> {}\n    #[inline]\n    pub fn longest_common_prefix(&self) -> Option<&[u8]> {}\n    #[inline]\n    pub fn longest_common_suffix(&self) -> Option<&[u8]> {}\n    #[inline]\n    pub fn optimize_for_prefix_by_preference(&mut self) {}\n    #[inline]\n    pub fn optimize_for_suffix_by_preference(&mut self) {}\n    fn optimize_by_preference(&mut self, prefix: bool) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Unions the `other` sequence into this one by splice the `other`\n/// sequence at the position of the first zero-length literal.\n///\n/// This is useful for preserving preference order semantics when combining\n/// two literal sequences. For example, in the regex `(a||f)+foo`, the\n/// correct preference order prefix sequence is `[a, foo, f]`.\n///\n/// The literals are always drained out of the given `other` sequence,\n/// even if they are being unioned into an infinite sequence. This permits\n/// the caller to reuse the `other` sequence in another context. Note that\n/// the literals are drained even if no union is performed as well, i.e.,\n/// when this sequence does not contain a zero-length literal.\n///\n/// Some literal deduping may be performed. If any deduping happens,\n/// any leftmost-first or \"preference\" order match semantics will be\n/// preserved.\n///\n/// # Example\n///\n/// This example shows basic usage.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq1 = Seq::new(&[\"a\", \"\", \"f\", \"\"]);\n/// let mut seq2 = Seq::new(&[\"foo\"]);\n/// seq1.union_into_empty(&mut seq2);\n///\n/// // The literals are pulled out of seq2.\n/// assert_eq!(Some(0), seq2.len());\n/// // 'foo' gets spliced into seq1 where the first empty string occurs.\n/// assert_eq!(Seq::new(&[\"a\", \"foo\", \"f\"]), seq1);\n/// ```\n///\n/// This example shows that literals are drained from `other` even when\n/// they aren't necessarily used.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq1 = Seq::new(&[\"foo\", \"bar\"]);\n/// let mut seq2 = Seq::new(&[\"bar\", \"quux\", \"foo\"]);\n/// seq1.union_into_empty(&mut seq2);\n///\n/// // seq1 has no zero length literals, so no splicing happens.\n/// assert_eq!(Seq::new(&[\"foo\", \"bar\"]), seq1);\n/// // Even though no splicing happens, seq2 is still drained.\n/// assert_eq!(Some(0), seq2.len());\n/// ```\n1287 pub fn union_into_empty(&mut self, other: &mut Seq) {\n1288     let lits2 = other.literals.as_mut().map(|lits| lits.drain(..));\n1289     let lits1 = match self.literals {\n1290         None => return,\n1291         Some(ref mut lits) => lits,\n1292     };\n1293     let first_empty = match lits1.iter().position(|m| m.is_empty()) {\n1294         None => return,\n1295         Some(i) => i,\n1296     };\n1297     let lits2 = match lits2 {\n1298         None => {\n1299             // Note that we are only here if we've found an empty literal,\n1300             // which implies that an infinite sequence infects this seq and\n1301             // also turns it into an infinite sequence.\n1302             self.literals = None;\n1303             return;\n1304         }\n1305         Some(lits) => lits,\n1306     };\n1307     // Clearing out the empties needs to come before the splice because\n1308     // the splice might add more empties that we don't want to get rid\n1309     // of. Since we're splicing into the position of the first empty, the\n1310     // 'first_empty' position computed above is still correct.\n1311     lits1.retain(|m| !m.is_empty());\n1312     lits1.splice(first_empty..first_empty, lits2);\n1313     self.dedup();\n1314 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}