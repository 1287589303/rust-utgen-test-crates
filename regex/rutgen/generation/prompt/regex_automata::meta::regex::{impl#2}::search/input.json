{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/regex.rs\n// crate name is regex_automata\ntype CachePool = Pool<Cache, CachePoolFn>;\ntype CachePoolGuard<'a> = PoolGuard<'a, Cache, CachePoolFn>;\ntype CachePoolFn = Box<dyn Fn() -> Cache + Send + Sync + UnwindSafe + RefUnwindSafe>;\nuse core::{borrow::Borrow, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::{boxed::Box, sync::Arc, vec, vec::Vec};\nuse regex_syntax::{ast, hir::{self, Hir}};\nuse crate::{\n    meta::{\n        error::BuildError, strategy::{self, Strategy},\n        wrappers,\n    },\n    nfa::thompson::WhichCaptures,\n    util::{\n        captures::{Captures, GroupInfo},\n        iter, pool::{Pool, PoolGuard},\n        prefilter::Prefilter, primitives::{NonMaxUsize, PatternID},\n        search::{HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n    },\n};\n#[derive(Debug)]\npub struct Regex {\n    /// The actual regex implementation.\n    imp: Arc<RegexI>,\n    /// A thread safe pool of caches.\n    ///\n    /// For the higher level search APIs, a `Cache` is automatically plucked\n    /// from this pool before running a search. The lower level `with` methods\n    /// permit the caller to provide their own cache, thereby bypassing\n    /// accesses to this pool.\n    ///\n    /// Note that we put this outside the `Arc` so that cloning a `Regex`\n    /// results in creating a fresh `CachePool`. This in turn permits callers\n    /// to clone regexes into separate threads where each such regex gets\n    /// the pool's \"thread owner\" optimization. Otherwise, if one shares the\n    /// `Regex` directly, then the pool will go through a slower mutex path for\n    /// all threads except for the \"owner.\"\n    pool: CachePool,\n}\n#[derive(Clone, Debug)]\npub(crate) struct RegexInfo(Arc<RegexInfoI>);\n#[derive(Debug)]\nstruct RegexI {\n    /// The core matching engine.\n    ///\n    /// Why is this reference counted when RegexI is already wrapped in an Arc?\n    /// Well, we need to capture this in a closure to our `Pool` below in order\n    /// to create new `Cache` values when needed. So since it needs to be in\n    /// two places, we make it reference counted.\n    ///\n    /// We make `RegexI` itself reference counted too so that `Regex` itself\n    /// stays extremely small and very cheap to clone.\n    strat: Arc<dyn Strategy>,\n    /// Metadata about the regexes driving the strategy. The metadata is also\n    /// usually stored inside the strategy too, but we put it here as well\n    /// so that we can get quick access to it (without virtual calls) before\n    /// executing the regex engine. For example, we use this metadata to\n    /// detect a subset of cases where we know a match is impossible, and can\n    /// thus avoid calling into the strategy at all.\n    ///\n    /// Since `RegexInfo` is stored in multiple places, it is also reference\n    /// counted.\n    info: RegexInfo,\n}\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct Match {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The underlying match span.\n    span: Span,\n}\nimpl Regex {\n    #[inline]\n    pub fn search(&self, input: &Input<'_>) -> Option<Match> {\n        if self.imp.info.is_impossible(input) {\n            return None;\n        }\n        let mut guard = self.pool.get();\n        let result = self.imp.strat.search(&mut guard, input);\n        PoolGuard::put(guard);\n        result\n    }\n    #[inline]\n    pub fn search_half(&self, input: &Input<'_>) -> Option<HalfMatch> {}\n    #[inline]\n    pub fn search_captures(&self, input: &Input<'_>, caps: &mut Captures) {}\n    #[inline]\n    pub fn search_slots(\n        &self,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    #[inline]\n    pub fn which_overlapping_matches(&self, input: &Input<'_>, patset: &mut PatternSet) {}\n}\nimpl RegexInfo {\n    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {}\n    pub(crate) fn config(&self) -> &Config {}\n    pub(crate) fn props(&self) -> &[hir::Properties] {}\n    pub(crate) fn props_union(&self) -> &hir::Properties {}\n    pub(crate) fn pattern_len(&self) -> usize {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_anchored_start(&self, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_start(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_end(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_impossible(&self, input: &Input<'_>) -> bool {\n        if input.start() > 0 && self.is_always_anchored_start() {\n            return true;\n        }\n        if input.end() < input.haystack().len() && self.is_always_anchored_end() {\n            return true;\n        }\n        let minlen = match self.props_union().minimum_len() {\n            None => return false,\n            Some(minlen) => minlen,\n        };\n        if input.get_span().len() < minlen {\n            return true;\n        }\n        if self.is_anchored_start(input) && self.is_always_anchored_end() {\n            let maxlen = match self.props_union().maximum_len() {\n                None => return false,\n                Some(maxlen) => maxlen,\n            };\n            if input.get_span().len() > maxlen {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the start and end offset of the leftmost match. If no match\n/// exists, then `None` is returned.\n///\n/// This is like [`Regex::find`] but, but it accepts a concrete `&Input`\n/// instead of an `Into<Input>`.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{meta::Regex, Input, Match};\n///\n/// let re = Regex::new(r\"Samwise|Sam\")?;\n/// let input = Input::new(\n///     \"one of the chief characters, Samwise the Brave\",\n/// );\n/// assert_eq!(Some(Match::must(0, 29..36)), re.search(&input));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n919 pub fn search(&self, input: &Input<'_>) -> Option<Match> {\n920     if self.imp.info.is_impossible(input) {\n921         return None;\n922     }\n923     let mut guard = self.pool.get();\n924     let result = self.imp.strat.search(&mut guard, input);\n925     // We do this dance with the guard and explicitly put it back in the\n926     // pool because it seems to result in better codegen. If we let the\n927     // guard's Drop impl put it back in the pool, then functions like\n928     // ptr::drop_in_place get called and they *don't* get inlined. This\n929     // isn't usually a big deal, but in latency sensitive benchmarks the\n930     // extra function call can matter.\n931     //\n932     // I used `rebar measure -f '^grep/every-line$' -e meta` to measure\n933     // the effects here.\n934     //\n935     // Note that this doesn't eliminate the latency effects of using the\n936     // pool. There is still some (minor) cost for the \"thread owner\" of the\n937     // pool. (i.e., The thread that first calls a regex search routine.)\n938     // However, for other threads using the regex, the pool access can be\n939     // quite expensive as it goes through a mutex. Callers can avoid this\n940     // by either cloning the Regex (which creates a distinct copy of the\n941     // pool), or callers can use the lower level APIs that accept a 'Cache'\n942     // directly and do their own handling.\n943     PoolGuard::put(guard);\n944     result\n945 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}