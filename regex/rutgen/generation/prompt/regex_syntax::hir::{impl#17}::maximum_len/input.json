{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Debug)]\npub struct IntervalSet<I> {\n    /// A sorted set of non-overlapping ranges.\n    ranges: Vec<I>,\n    /// While not required at all for correctness, we keep track of whether an\n    /// interval set has been case folded or not. This helps us avoid doing\n    /// redundant work if, for example, a set has already been cased folded.\n    /// And note that whether a set is folded or not is preserved through\n    /// all of the pairwise set operations. That is, if both interval sets\n    /// have been case folded, then any of difference, union, intersection or\n    /// symmetric difference all produce a case folded set.\n    ///\n    /// Note that when this is true, it *must* be the case that the set is case\n    /// folded. But when it's false, the set *may* be case folded. In other\n    /// words, we only set this to true when we know it to be case, but we're\n    /// okay with it being false if it would otherwise be costly to determine\n    /// whether it should be true. This means code cannot assume that a false\n    /// value necessarily indicates that the set is not case folded.\n    ///\n    /// Bottom line: this is a performance optimization.\n    folded: bool,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}\nimpl ClassBytes {\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {}\n    pub fn empty() -> ClassBytes {}\n    pub fn push(&mut self, range: ClassBytesRange) {}\n    pub fn iter(&self) -> ClassBytesIter<'_> {}\n    pub fn ranges(&self) -> &[ClassBytesRange] {\n        self.set.intervals()\n    }\n    pub fn case_fold_simple(&mut self) {}\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassBytes) {}\n    pub fn intersect(&mut self, other: &ClassBytes) {}\n    pub fn difference(&mut self, other: &ClassBytes) {}\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {\n        if self.ranges().is_empty() { None } else { Some(1) }\n    }\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_unicode_class(&self) -> Option<ClassUnicode> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the length, in bytes, of the longest string matched by this\n/// character class.\n///\n/// Returns `None` when the class is empty.\n1460 pub fn maximum_len(&self) -> Option<usize> {\n1461     if self.ranges().is_empty() {\n1462         None\n1463     } else {\n1464         Some(1)\n1465     }\n1466 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}