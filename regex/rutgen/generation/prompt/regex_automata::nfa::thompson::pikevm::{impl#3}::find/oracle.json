{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/pikevm.rs\n// crate name is regex_automata\n#[cfg(feature = \"internal-instrument-pikevm\")]\nuse core::cell::RefCell;\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet, Span},\n        sparse_set::SparseSet,\n    },\n};\n#[derive(Clone, Debug)]\npub struct PikeVM {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct Match {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The underlying match span.\n    span: Span,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Debug, Default)]\npub struct GroupInfo(Arc<GroupInfoInner>);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug)]\npub struct Cache {\n    /// Stack used while computing epsilon closure. This effectively lets us\n    /// move what is more naturally expressed through recursion to a stack\n    /// on the heap.\n    stack: Vec<FollowEpsilon>,\n    /// The current active states being explored for the current byte in the\n    /// haystack.\n    curr: ActiveStates,\n    /// The next set of states we're building that will be explored for the\n    /// next byte in the haystack.\n    next: ActiveStates,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Span {\n    /// The start offset of the span, inclusive.\n    pub start: usize,\n    /// The end offset of the span, exclusive.\n    pub end: usize,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\nimpl PikeVM {\n    #[inline]\n    pub fn is_match<'h, I: Into<Input<'h>>>(&self, cache: &mut Cache, input: I) -> bool {}\n    #[inline]\n    pub fn find<'h, I: Into<Input<'h>>>(\n        &self,\n        cache: &mut Cache,\n        input: I,\n    ) -> Option<Match> {\n        let input = input.into();\n        if self.get_nfa().pattern_len() == 1 {\n            let mut slots = [None, None];\n            let pid = self.search_slots(cache, &input, &mut slots)?;\n            let start = slots[0]?.get();\n            let end = slots[1]?.get();\n            return Some(Match::new(pid, Span { start, end }));\n        }\n        let ginfo = self.get_nfa().group_info();\n        let slots_len = ginfo.implicit_slot_len();\n        let mut slots = vec![None; slots_len];\n        let pid = self.search_slots(cache, &input, &mut slots)?;\n        let start = slots[pid.as_usize() * 2]?.get();\n        let end = slots[pid.as_usize() * 2 + 1]?.get();\n        Some(Match::new(pid, Span { start, end }))\n    }\n    #[inline]\n    pub fn captures<'h, I: Into<Input<'h>>>(\n        &self,\n        cache: &mut Cache,\n        input: I,\n        caps: &mut Captures,\n    ) {}\n    #[inline]\n    pub fn find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(\n        &'r self,\n        cache: &'c mut Cache,\n        input: I,\n    ) -> FindMatches<'r, 'c, 'h> {}\n    #[inline]\n    pub fn captures_iter<'r, 'c, 'h, I: Into<Input<'h>>>(\n        &'r self,\n        cache: &'c mut Cache,\n        input: I,\n    ) -> CapturesMatches<'r, 'c, 'h> {}\n}\nimpl Match {\n    #[inline]\n    pub fn new<S: Into<Span>>(pattern: PatternID, span: S) -> Match {\n        let span: Span = span.into();\n        assert!(span.start <= span.end, \"invalid match span\");\n        Match { pattern, span }\n    }\n    #[inline]\n    pub fn must<S: Into<Span>>(pattern: usize, span: S) -> Match {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn start(&self) -> usize {}\n    #[inline]\n    pub fn end(&self) -> usize {}\n    #[inline]\n    pub fn range(&self) -> core::ops::Range<usize> {}\n    #[inline]\n    pub fn span(&self) -> Span {}\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    pub fn len(&self) -> usize {}\n}\nimpl NonMaxUsize {\n    #[inline]\n    pub fn new(value: usize) -> Option<NonMaxUsize> {}\n    #[inline]\n    pub fn get(self) -> usize {\n        self.0.get().wrapping_sub(1)\n    }\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {\n        self.0.start_pattern.len()\n    }\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {}\n    #[inline]\n    pub fn states(&self) -> &[State] {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {\n        &self.0.group_info()\n    }\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {}\n    #[inline]\n    pub fn is_utf8(&self) -> bool {}\n    #[inline]\n    pub fn is_reverse(&self) -> bool {}\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {}\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {}\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl GroupInfo {\n    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>\n    where\n        P: IntoIterator<Item = G>,\n        G: IntoIterator<Item = Option<N>>,\n        N: AsRef<str>,\n    {}\n    pub fn empty() -> GroupInfo {}\n    #[inline]\n    pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {}\n    #[inline]\n    pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {}\n    #[inline]\n    pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {}\n    #[inline]\n    pub fn all_names(&self) -> GroupInfoAllNames<'_> {}\n    #[inline]\n    pub fn slots(&self, pid: PatternID, group_index: usize) -> Option<(usize, usize)> {}\n    #[inline]\n    pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn group_len(&self, pid: PatternID) -> usize {}\n    #[inline]\n    pub fn all_group_len(&self) -> usize {}\n    #[inline]\n    pub fn slot_len(&self) -> usize {}\n    #[inline]\n    pub fn implicit_slot_len(&self) -> usize {\n        self.pattern_len() * 2\n    }\n    #[inline]\n    pub fn explicit_slot_len(&self) -> usize {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Executes a leftmost forward search and returns a `Match` if one exists.\n///\n/// This routine only includes the overall match span. To get access to the\n/// individual spans of each capturing group, use [`PikeVM::captures`].\n///\n/// # Example\n///\n/// Leftmost first match semantics corresponds to the match with the\n/// smallest starting offset, but where the end offset is determined by\n/// preferring earlier branches in the original regular expression. For\n/// example, `Sam|Samwise` will match `Sam` in `Samwise`, but `Samwise|Sam`\n/// will match `Samwise` in `Samwise`.\n///\n/// Generally speaking, the \"leftmost first\" match is how most backtracking\n/// regular expressions tend to work. This is in contrast to POSIX-style\n/// regular expressions that yield \"leftmost longest\" matches. Namely,\n/// both `Sam|Samwise` and `Samwise|Sam` match `Samwise` when using\n/// leftmost longest semantics. (This crate does not currently support\n/// leftmost longest semantics.)\n///\n/// ```\n/// use regex_automata::{nfa::thompson::pikevm::PikeVM, Match};\n///\n/// let re = PikeVM::new(\"foo[0-9]+\")?;\n/// let mut cache = re.create_cache();\n/// let expected = Match::must(0, 0..8);\n/// assert_eq!(Some(expected), re.find(&mut cache, \"foo12345\"));\n///\n/// // Even though a match is found after reading the first byte (`a`),\n/// // the leftmost first match semantics demand that we find the earliest\n/// // match that prefers earlier parts of the pattern over later parts.\n/// let re = PikeVM::new(\"abc|a\")?;\n/// let mut cache = re.create_cache();\n/// let expected = Match::must(0, 0..3);\n/// assert_eq!(Some(expected), re.find(&mut cache, \"abc\"));\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n815 pub fn find<'h, I: Into<Input<'h>>>(\n816     &self,\n817     cache: &mut Cache,\n818     input: I,\n819 ) -> Option<Match> {\n820     let input = input.into();\n821     if self.get_nfa().pattern_len() == 1 {\n822         let mut slots = [None, None];\n823         let pid = self.search_slots(cache, &input, &mut slots)?;\n824         let start = slots[0]?.get();\n825         let end = slots[1]?.get();\n826         return Some(Match::new(pid, Span { start, end }));\n827     }\n828     let ginfo = self.get_nfa().group_info();\n829     let slots_len = ginfo.implicit_slot_len();\n830     let mut slots = vec![None; slots_len];\n831     let pid = self.search_slots(cache, &input, &mut slots)?;\n832     let start = slots[pid.as_usize() * 2]?.get();\n833     let end = slots[pid.as_usize() * 2 + 1]?.get();\n834     Some(Match::new(pid, Span { start, end }))\n835 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}