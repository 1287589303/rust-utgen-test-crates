{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/string.rs\n// crate name is regex_lite\nuse alloc::{\n    borrow::Cow, boxed::Box, string::String, string::ToString, sync::Arc, vec, vec::Vec,\n};\nuse crate::{\n    error::Error, hir::{self, Hir},\n    int::NonMaxUsize, interpolate, nfa::{self, NFA},\n    pikevm::{self, Cache, PikeVM},\n    pool::CachePool,\n};\npub struct Regex {\n    pikevm: Arc<PikeVM>,\n    pool: CachePool,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub(crate) struct NonMaxUsize(NonZeroUsize);\n#[derive(Clone, Debug)]\npub(crate) struct PikeVM {\n    nfa: NFA,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Cache {\n    /// Stack used while computing epsilon closure. This effectively lets us\n    /// move what is more naturally expressed through recursion to a stack\n    /// on the heap.\n    stack: Vec<FollowEpsilon>,\n    /// The current active states being explored for the current byte in the\n    /// haystack.\n    curr: ActiveStates,\n    /// The next set of states we're building that will be explored for the\n    /// next byte in the haystack.\n    next: ActiveStates,\n}\nimpl Regex {\n    #[inline]\n    pub fn shortest_match(&self, haystack: &str) -> Option<usize> {}\n    #[inline]\n    pub fn shortest_match_at(&self, haystack: &str, start: usize) -> Option<usize> {\n        let mut cache = self.pool.get();\n        let mut slots = [None, None];\n        let matched = self\n            .pikevm\n            .search(\n                &mut cache,\n                haystack.as_bytes(),\n                start,\n                haystack.len(),\n                true,\n                &mut slots,\n            );\n        if !matched {\n            return None;\n        }\n        Some(slots[1].unwrap().get())\n    }\n    #[inline]\n    pub fn is_match_at(&self, haystack: &str, start: usize) -> bool {}\n    #[inline]\n    pub fn find_at<'h>(&self, haystack: &'h str, start: usize) -> Option<Match<'h>> {}\n    #[inline]\n    pub fn captures_at<'h>(\n        &self,\n        haystack: &'h str,\n        start: usize,\n    ) -> Option<Captures<'h>> {}\n    #[inline]\n    pub fn captures_read<'h>(\n        &self,\n        locs: &mut CaptureLocations,\n        haystack: &'h str,\n    ) -> Option<Match<'h>> {}\n    #[inline]\n    pub fn captures_read_at<'h>(\n        &self,\n        locs: &mut CaptureLocations,\n        haystack: &'h str,\n        start: usize,\n    ) -> Option<Match<'h>> {}\n}\nimpl NonMaxUsize {\n    pub(crate) fn new(value: usize) -> Option<NonMaxUsize> {}\n    pub(crate) fn get(self) -> usize {\n        self.0.get().wrapping_sub(1)\n    }\n}\nimpl PikeVM {\n    pub(crate) fn new(nfa: NFA) -> PikeVM {}\n    pub(crate) fn nfa(&self) -> &NFA {}\n    pub(crate) fn find_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> FindMatches<'r, 'h> {}\n    pub(crate) fn captures_iter<'r, 'h>(\n        &'r self,\n        cache: CachePoolGuard<'r>,\n        haystack: &'h [u8],\n    ) -> CapturesMatches<'r, 'h> {}\n    pub(crate) fn search(\n        &self,\n        cache: &mut Cache,\n        haystack: &[u8],\n        start: usize,\n        end: usize,\n        earliest: bool,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {\n        cache.setup_search(slots.len());\n        if start > end {\n            return false;\n        }\n        assert!(\n            haystack.len() < core::usize::MAX,\n            \"byte slice lengths must be less than usize MAX\",\n        );\n        let Cache { ref mut stack, ref mut curr, ref mut next } = cache;\n        let start_id = self.nfa().start();\n        let anchored = self.nfa().is_start_anchored();\n        let mut matched = false;\n        let mut at = start;\n        while at <= end {\n            if curr.set.is_empty() {\n                if matched {\n                    break;\n                }\n                if anchored && at > start {\n                    break;\n                }\n            }\n            if !matched {\n                let slots = next.slot_table.all_absent();\n                self.epsilon_closure(stack, slots, curr, haystack, at, start_id);\n            }\n            let (ch, len) = utf8::decode_lossy(&haystack[at..]);\n            if self.nexts(stack, curr, next, haystack, at, ch, len, slots) {\n                matched = true;\n            }\n            if (earliest && matched) || len == 0 {\n                break;\n            }\n            core::mem::swap(curr, next);\n            next.set.clear();\n            at += len;\n        }\n        matched\n    }\n    fn nexts(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr: &mut ActiveStates,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> bool {}\n    fn next(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slot_table: &mut SlotTable,\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        at_ch: char,\n        at_len: usize,\n        sid: StateID,\n    ) -> bool {}\n    fn epsilon_closure(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        sid: StateID,\n    ) {}\n    fn epsilon_closure_explore(\n        &self,\n        stack: &mut Vec<FollowEpsilon>,\n        curr_slots: &mut [Option<NonMaxUsize>],\n        next: &mut ActiveStates,\n        haystack: &[u8],\n        at: usize,\n        mut sid: StateID,\n    ) {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns the same as [`Regex::shortest_match`], but starts the search at\n/// the given offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only match\n/// when `start == 0`.\n///\n/// If a match is found, the offset returned is relative to the beginning\n/// of the haystack, not the beginning of the search.\n///\n/// # Panics\n///\n/// This panics when `start >= haystack.len() + 1`.\n///\n/// # Example\n///\n/// This example shows the significance of `start` by demonstrating how it\n/// can be used to permit look-around assertions in a regex to take the\n/// surrounding context into account.\n///\n/// ```\n/// use regex_lite::Regex;\n///\n/// let re = Regex::new(r\"\\bchew\\b\").unwrap();\n/// let hay = \"eschew\";\n/// // We get a match here, but it's probably not intended.\n/// assert_eq!(re.shortest_match(&hay[2..]), Some(4));\n/// // No match because the  assertions take the context into account.\n/// assert_eq!(re.shortest_match_at(hay, 2), None);\n/// ```\n1012 pub fn shortest_match_at(\n1013     &self,\n1014     haystack: &str,\n1015     start: usize,\n1016 ) -> Option<usize> {\n1017     let mut cache = self.pool.get();\n1018     let mut slots = [None, None];\n1019     let matched = self.pikevm.search(\n1020         &mut cache,\n1021         haystack.as_bytes(),\n1022         start,\n1023         haystack.len(),\n1024         true,\n1025         &mut slots,\n1026     );\n1027     if !matched {\n1028         return None;\n1029     }\n1030     Some(slots[1].unwrap().get())\n1031 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}