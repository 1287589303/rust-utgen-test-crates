{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/start.rs\n// crate name is regex_automata\nuse crate::util::{\n    look::LookMatcher, search::{Anchored, Input},\n    wire::{self, DeserializeError, SerializeError},\n};\n#[derive(Clone)]\npub(crate) struct StartByteMap {\n    map: [Start; 256],\n}\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Start {\n    /// This occurs when the starting position is not any of the ones below.\n    NonWordByte = 0,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is an ASCII word byte.\n    WordByte = 1,\n    /// This occurs when the starting position of the search corresponds to the\n    /// beginning of the haystack.\n    Text = 2,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\n`.\n    LineLF = 3,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\r`.\n    LineCR = 4,\n    /// This occurs when a custom line terminator has been set via a\n    /// `LookMatcher`, and when that line terminator is neither a `\\r` or a\n    /// `\\n`.\n    ///\n    /// If the custom line terminator is a word byte, then this start\n    /// configuration is still selected. DFAs that implement word boundary\n    /// assertions will likely need to check whether the custom line terminator\n    /// is a word byte, in which case, it should behave as if the byte\n    /// satisfies `\\b` in addition to multi-line anchors.\n    CustomLineTerminator = 5,\n}\nimpl StartByteMap {\n    pub(crate) fn new(lookm: &LookMatcher) -> StartByteMap {\n        let mut map = [Start::NonWordByte; 256];\n        map[usize::from(b'\\n')] = Start::LineLF;\n        map[usize::from(b'\\r')] = Start::LineCR;\n        map[usize::from(b'_')] = Start::WordByte;\n        let mut byte = b'0';\n        while byte <= b'9' {\n            map[usize::from(byte)] = Start::WordByte;\n            byte += 1;\n        }\n        byte = b'A';\n        while byte <= b'Z' {\n            map[usize::from(byte)] = Start::WordByte;\n            byte += 1;\n        }\n        byte = b'a';\n        while byte <= b'z' {\n            map[usize::from(byte)] = Start::WordByte;\n            byte += 1;\n        }\n        let lineterm = lookm.get_line_terminator();\n        if lineterm != b'\\r' && lineterm != b'\\n' {\n            map[usize::from(lineterm)] = Start::CustomLineTerminator;\n        }\n        StartByteMap { map }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, byte: u8) -> Start {}\n    pub(crate) fn from_bytes(\n        slice: &[u8],\n    ) -> Result<(StartByteMap, usize), DeserializeError> {}\n    pub(crate) fn write_to(&self, dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n}\nimpl LookMatcher {\n    pub fn new() -> LookMatcher {}\n    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {}\n    pub fn get_line_terminator(&self) -> u8 {\n        self.lineterm.0\n    }\n    #[inline]\n    pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_inline(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn matches_set(&self, set: LookSet, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_set_inline(\n        &self,\n        set: LookSet,\n        haystack: &[u8],\n        at: usize,\n    ) -> bool {}\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn add_to_byteset(\n        &self,\n        look: Look,\n        set: &mut crate::util::alphabet::ByteClassSet,\n    ) {}\n    #[inline]\n    pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_unicode_negate(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Create a new map from byte values to their corresponding starting\n/// configurations. The map is determined, in part, by how look-around\n/// assertions are matched via the matcher given.\n216 pub(crate) fn new(lookm: &LookMatcher) -> StartByteMap {\n217     let mut map = [Start::NonWordByte; 256];\n218     map[usize::from(b'\\n')] = Start::LineLF;\n219     map[usize::from(b'\\r')] = Start::LineCR;\n220     map[usize::from(b'_')] = Start::WordByte;\n221 \n222     let mut byte = b'0';\n223     while byte <= b'9' {\n224         map[usize::from(byte)] = Start::WordByte;\n225         byte += 1;\n226     }\n227     byte = b'A';\n228     while byte <= b'Z' {\n229         map[usize::from(byte)] = Start::WordByte;\n230         byte += 1;\n231     }\n232     byte = b'a';\n233     while byte <= b'z' {\n234         map[usize::from(byte)] = Start::WordByte;\n235         byte += 1;\n236     }\n237 \n238     let lineterm = lookm.get_line_terminator();\n239     // If our line terminator is normal, then it is already handled by\n240     // the LineLF and LineCR configurations. But if it's weird, then we\n241     // overwrite whatever was there before for that terminator with a\n242     // special configuration. The trick here is that if the terminator\n243     // is, say, a word byte like `a`, then callers seeing this start\n244     // configuration need to account for that and build their DFA state as\n245     // if it *also* came from a word byte.\n246     if lineterm != b'\\r' && lineterm != b'\\n' {\n247         map[usize::from(lineterm)] = Start::CustomLineTerminator;\n248     }\n249     StartByteMap { map }\n250 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}