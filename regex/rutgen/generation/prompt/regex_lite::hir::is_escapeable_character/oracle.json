{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/hir/mod.rs\n// crate name is regex_lite\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\nuse crate::{error::Error, utf8};\nfn is_escapeable_character(c: char) -> bool {\n    if is_meta_character(c) {\n        return true;\n    }\n    if !c.is_ascii() {\n        return false;\n    }\n    match c {\n        '0'..='9' | 'A'..='Z' | 'a'..='z' => false,\n        '<' | '>' => false,\n        _ => true,\n    }\n}\nfn is_meta_character(c: char) -> bool {\n    match c {\n        '\\\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{' | '}' | '^'\n        | '$' | '#' | '&' | '-' | '~' => true,\n        _ => false,\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns true if the given character can be escaped in a regex.\n///\n/// This returns true in all cases that `is_meta_character` returns true, but\n/// also returns true in some cases where `is_meta_character` returns false.\n/// For example, `%` is not a meta character, but it is escapeable. That is,\n/// `%` and `\\%` both match a literal `%` in all contexts.\n///\n/// The purpose of this routine is to provide knowledge about what characters\n/// may be escaped. Namely, most regex engines permit \"superfluous\" escapes\n/// where characters without any special significance may be escaped even\n/// though there is no actual _need_ to do so.\n///\n/// This will return false for some characters. For example, `e` is not\n/// escapeable. Therefore, `\\e` will either result in a parse error (which is\n/// true today), or it could backwards compatibly evolve into a new construct\n/// with its own meaning. Indeed, that is the purpose of banning _some_\n/// superfluous escapes: it provides a way to evolve the syntax in a compatible\n/// manner.\n71 fn is_escapeable_character(c: char) -> bool {\n72     // Certainly escapeable if it's a meta character.\n73     if is_meta_character(c) {\n74         return true;\n75     }\n76     // Any character that isn't ASCII is definitely not escapeable. There's\n77     // no real need to allow things like \\â˜ƒ right?\n78     if !c.is_ascii() {\n79         return false;\n80     }\n81     // Otherwise, we basically say that everything is escapeable unless it's a\n82     // letter or digit. Things like \\3 are either octal (when enabled) or an\n83     // error, and we should keep it that way. Otherwise, letters are reserved\n84     // for adding new syntax in a backwards compatible way.\n85     match c {\n86         '0'..='9' | 'A'..='Z' | 'a'..='z' => false,\n87         // While not currently supported, we keep these as not escapeable to\n88         // give us some flexibility with respect to supporting the \\< and\n89         // \\> word boundary assertions in the future. By rejecting them as\n90         // escapeable, \\< and \\> will result in a parse error. Thus, we can\n91         // turn them into something else in the future without it being a\n92         // backwards incompatible change.\n93         '<' | '>' => false,\n94         _ => true,\n95     }\n96 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}