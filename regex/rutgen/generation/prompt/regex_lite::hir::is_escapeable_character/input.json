{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-lite/src/hir/mod.rs\n// crate name is regex_lite\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\nuse crate::{error::Error, utf8};\nfn is_escapeable_character(c: char) -> bool {\n    if is_meta_character(c) {\n        return true;\n    }\n    if !c.is_ascii() {\n        return false;\n    }\n    match c {\n        '0'..='9' | 'A'..='Z' | 'a'..='z' => false,\n        '<' | '>' => false,\n        _ => true,\n    }\n}\nfn is_meta_character(c: char) -> bool {\n    match c {\n        '\\\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{' | '}' | '^'\n        | '$' | '#' | '&' | '-' | '~' => true,\n        _ => false,\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns true if the given character can be escaped in a regex.\n///\n/// This returns true in all cases that `is_meta_character` returns true, but\n/// also returns true in some cases where `is_meta_character` returns false.\n/// For example, `%` is not a meta character, but it is escapeable. That is,\n/// `%` and `\\%` both match a literal `%` in all contexts.\n///\n/// The purpose of this routine is to provide knowledge about what characters\n/// may be escaped. Namely, most regex engines permit \"superfluous\" escapes\n/// where characters without any special significance may be escaped even\n/// though there is no actual _need_ to do so.\n///\n/// This will return false for some characters. For example, `e` is not\n/// escapeable. Therefore, `\\e` will either result in a parse error (which is\n/// true today), or it could backwards compatibly evolve into a new construct\n/// with its own meaning. Indeed, that is the purpose of banning _some_\n/// superfluous escapes: it provides a way to evolve the syntax in a compatible\n/// manner.\n71 fn is_escapeable_character(c: char) -> bool {\n72     // Certainly escapeable if it's a meta character.\n73     if is_meta_character(c) {\n74         return true;\n75     }\n76     // Any character that isn't ASCII is definitely not escapeable. There's\n77     // no real need to allow things like \\â˜ƒ right?\n78     if !c.is_ascii() {\n79         return false;\n80     }\n81     // Otherwise, we basically say that everything is escapeable unless it's a\n82     // letter or digit. Things like \\3 are either octal (when enabled) or an\n83     // error, and we should keep it that way. Otherwise, letters are reserved\n84     // for adding new syntax in a backwards compatible way.\n85     match c {\n86         '0'..='9' | 'A'..='Z' | 'a'..='z' => false,\n87         // While not currently supported, we keep these as not escapeable to\n88         // give us some flexibility with respect to supporting the \\< and\n89         // \\> word boundary assertions in the future. By rejecting them as\n90         // escapeable, \\< and \\> will result in a parse error. Thus, we can\n91         // turn them into something else in the future without it being a\n92         // backwards incompatible change.\n93         '<' | '>' => false,\n94         _ => true,\n95     }\n96 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}