{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/automaton.rs\n// crate name is regex_automata\n#[cfg(feature = \"alloc\")]\nuse crate::util::search::PatternSet;\nuse crate::{\n    dfa::search,\n    util::{\n        empty, prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::{Anchored, HalfMatch, Input, MatchError},\n        start,\n    },\n};\npub unsafe trait Automaton {\n    fn next_state(&self, current: StateID, input: u8) -> StateID;\n    unsafe fn next_state_unchecked(&self, current: StateID, input: u8) -> StateID;\n    fn next_eoi_state(&self, current: StateID) -> StateID;\n    fn start_state(&self, config: &start::Config) -> Result<StateID, StartError>;\n    fn start_state_forward(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    fn start_state_reverse(&self, input: &Input<'_>) -> Result<StateID, MatchError>;\n    #[inline]\n    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID> {\n        None\n    }\n    fn is_special_state(&self, id: StateID) -> bool;\n    fn is_dead_state(&self, id: StateID) -> bool;\n    fn is_quit_state(&self, id: StateID) -> bool;\n    fn is_match_state(&self, id: StateID) -> bool;\n    fn is_start_state(&self, id: StateID) -> bool;\n    fn is_accel_state(&self, id: StateID) -> bool;\n    fn pattern_len(&self) -> usize;\n    fn match_len(&self, id: StateID) -> usize;\n    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;\n    fn has_empty(&self) -> bool;\n    fn is_utf8(&self) -> bool;\n    fn is_always_start_anchored(&self) -> bool;\n    #[inline]\n    fn accelerator(&self, _id: StateID) -> &[u8];\n    #[inline]\n    fn get_prefilter(&self) -> Option<&Prefilter>;\n    #[inline]\n    fn try_search_fwd(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_rev(&self, input: &Input<'_>) -> Result<Option<HalfMatch>, MatchError>;\n    #[inline]\n    fn try_search_overlapping_fwd(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[inline]\n    fn try_search_overlapping_rev(\n        &self,\n        input: &Input<'_>,\n        state: &mut OverlappingState,\n    ) -> Result<(), MatchError>;\n    #[cfg(feature = \"alloc\")]\n    #[inline]\n    fn try_which_overlapping_matches(\n        &self,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) -> Result<(), MatchError>;\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// If this DFA has a universal starting state for the given anchor mode\n/// and the DFA supports universal starting states, then this returns that\n/// state's identifier.\n///\n/// A DFA is said to have a universal starting state when the starting\n/// state is invariant with respect to the haystack. Usually, the starting\n/// state is chosen depending on the bytes immediately surrounding the\n/// starting position of a search. However, the starting state only differs\n/// when one or more of the patterns in the DFA have look-around assertions\n/// in its prefix.\n///\n/// Stated differently, if none of the patterns in a DFA have look-around\n/// assertions in their prefix, then the DFA has a universal starting state\n/// and _may_ be returned by this method.\n///\n/// It is always correct for implementations to return `None`, and indeed,\n/// this is what the default implementation does. When this returns `None`,\n/// callers must use either `start_state_forward` or `start_state_reverse`\n/// to get the starting state.\n///\n/// # Use case\n///\n/// There are a few reasons why one might want to use this:\n///\n/// * If you know your regex patterns have no look-around assertions in\n/// their prefix, then calling this routine is likely cheaper and perhaps\n/// more semantically meaningful.\n/// * When implementing prefilter support in a DFA regex implementation,\n/// it is necessary to re-compute the start state after a candidate\n/// is returned from the prefilter. However, this is only needed when\n/// there isn't a universal start state. When one exists, one can avoid\n/// re-computing the start state.\n///\n/// # Example\n///\n/// ```\n/// use regex_automata::{\n///     dfa::{Automaton, dense::DFA},\n///     Anchored,\n/// };\n///\n/// // There are no look-around assertions in the prefixes of any of the\n/// // patterns, so we get a universal start state.\n/// let dfa = DFA::new_many(&[\"[0-9]+\", \"[a-z]+$\", \"[A-Z]+\"])?;\n/// assert!(dfa.universal_start_state(Anchored::No).is_some());\n/// assert!(dfa.universal_start_state(Anchored::Yes).is_some());\n///\n/// // One of the patterns has a look-around assertion in its prefix,\n/// // so this means there is no longer a universal start state.\n/// let dfa = DFA::new_many(&[\"[0-9]+\", \"^[a-z]+$\", \"[A-Z]+\"])?;\n/// assert!(!dfa.universal_start_state(Anchored::No).is_some());\n/// assert!(!dfa.universal_start_state(Anchored::Yes).is_some());\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n386 fn universal_start_state(&self, _mode: Anchored) -> Option<StateID> {\n387     None\n388 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}