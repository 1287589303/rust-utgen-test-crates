{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/print.rs\n// crate name is regex_syntax\nuse core::fmt;\nuse crate::ast::{\n    self, visitor::{self, Visitor},\n    Ast,\n};\npub trait Visitor {\n    type Output;\n    type Err;\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n    fn start(&mut self);\n    fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_concat_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}\n#[derive(Debug)]\nstruct Writer<W> {\n    wtr: W,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassAscii {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of ASCII class.\n    pub kind: ClassAsciiKind,\n    /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated\n    /// but `[[:^alpha:]]` is.\n    pub negated: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum ClassAsciiKind {\n    /// `[0-9A-Za-z]`\n    Alnum,\n    /// `[A-Za-z]`\n    Alpha,\n    /// `[\\x00-\\x7F]`\n    Ascii,\n    /// `[ \\t]`\n    Blank,\n    /// `[\\x00-\\x1F\\x7F]`\n    Cntrl,\n    /// `[0-9]`\n    Digit,\n    /// `[!-~]`\n    Graph,\n    /// `[a-z]`\n    Lower,\n    /// `[ -~]`\n    Print,\n    /// `[!-/:-@\\[-`{-~]`\n    Punct,\n    /// `[\\t\\n\\v\\f\\r ]`\n    Space,\n    /// `[A-Z]`\n    Upper,\n    /// `[0-9A-Za-z_]`\n    Word,\n    /// `[0-9A-Fa-f]`\n    Xdigit,\n}\nimpl<W: fmt::Write> Writer<W> {\n    fn fmt_group_pre(&mut self, ast: &ast::Group) -> fmt::Result {}\n    fn fmt_group_post(&mut self, _ast: &ast::Group) -> fmt::Result {}\n    fn fmt_repetition(&mut self, ast: &ast::Repetition) -> fmt::Result {}\n    fn fmt_repetition_range(&mut self, ast: &ast::RepetitionRange) -> fmt::Result {}\n    fn fmt_literal(&mut self, ast: &ast::Literal) -> fmt::Result {}\n    fn fmt_assertion(&mut self, ast: &ast::Assertion) -> fmt::Result {}\n    fn fmt_set_flags(&mut self, ast: &ast::SetFlags) -> fmt::Result {}\n    fn fmt_flags(&mut self, ast: &ast::Flags) -> fmt::Result {}\n    fn fmt_class_bracketed_pre(&mut self, ast: &ast::ClassBracketed) -> fmt::Result {}\n    fn fmt_class_bracketed_post(&mut self, _ast: &ast::ClassBracketed) -> fmt::Result {}\n    fn fmt_class_set_binary_op_kind(\n        &mut self,\n        ast: &ast::ClassSetBinaryOpKind,\n    ) -> fmt::Result {}\n    fn fmt_class_perl(&mut self, ast: &ast::ClassPerl) -> fmt::Result {}\n    fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result {\n        use crate::ast::ClassAsciiKind::*;\n        match ast.kind {\n            Alnum if ast.negated => self.wtr.write_str(\"[:^alnum:]\"),\n            Alnum => self.wtr.write_str(\"[:alnum:]\"),\n            Alpha if ast.negated => self.wtr.write_str(\"[:^alpha:]\"),\n            Alpha => self.wtr.write_str(\"[:alpha:]\"),\n            Ascii if ast.negated => self.wtr.write_str(\"[:^ascii:]\"),\n            Ascii => self.wtr.write_str(\"[:ascii:]\"),\n            Blank if ast.negated => self.wtr.write_str(\"[:^blank:]\"),\n            Blank => self.wtr.write_str(\"[:blank:]\"),\n            Cntrl if ast.negated => self.wtr.write_str(\"[:^cntrl:]\"),\n            Cntrl => self.wtr.write_str(\"[:cntrl:]\"),\n            Digit if ast.negated => self.wtr.write_str(\"[:^digit:]\"),\n            Digit => self.wtr.write_str(\"[:digit:]\"),\n            Graph if ast.negated => self.wtr.write_str(\"[:^graph:]\"),\n            Graph => self.wtr.write_str(\"[:graph:]\"),\n            Lower if ast.negated => self.wtr.write_str(\"[:^lower:]\"),\n            Lower => self.wtr.write_str(\"[:lower:]\"),\n            Print if ast.negated => self.wtr.write_str(\"[:^print:]\"),\n            Print => self.wtr.write_str(\"[:print:]\"),\n            Punct if ast.negated => self.wtr.write_str(\"[:^punct:]\"),\n            Punct => self.wtr.write_str(\"[:punct:]\"),\n            Space if ast.negated => self.wtr.write_str(\"[:^space:]\"),\n            Space => self.wtr.write_str(\"[:space:]\"),\n            Upper if ast.negated => self.wtr.write_str(\"[:^upper:]\"),\n            Upper => self.wtr.write_str(\"[:upper:]\"),\n            Word if ast.negated => self.wtr.write_str(\"[:^word:]\"),\n            Word => self.wtr.write_str(\"[:word:]\"),\n            Xdigit if ast.negated => self.wtr.write_str(\"[:^xdigit:]\"),\n            Xdigit => self.wtr.write_str(\"[:xdigit:]\"),\n        }\n    }\n    fn fmt_class_unicode(&mut self, ast: &ast::ClassUnicode) -> fmt::Result {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n342 fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result {\n343     use crate::ast::ClassAsciiKind::*;\n344     match ast.kind {\n345         Alnum if ast.negated => self.wtr.write_str(\"[:^alnum:]\"),\n346         Alnum => self.wtr.write_str(\"[:alnum:]\"),\n347         Alpha if ast.negated => self.wtr.write_str(\"[:^alpha:]\"),\n348         Alpha => self.wtr.write_str(\"[:alpha:]\"),\n349         Ascii if ast.negated => self.wtr.write_str(\"[:^ascii:]\"),\n350         Ascii => self.wtr.write_str(\"[:ascii:]\"),\n351         Blank if ast.negated => self.wtr.write_str(\"[:^blank:]\"),\n352         Blank => self.wtr.write_str(\"[:blank:]\"),\n353         Cntrl if ast.negated => self.wtr.write_str(\"[:^cntrl:]\"),\n354         Cntrl => self.wtr.write_str(\"[:cntrl:]\"),\n355         Digit if ast.negated => self.wtr.write_str(\"[:^digit:]\"),\n356         Digit => self.wtr.write_str(\"[:digit:]\"),\n357         Graph if ast.negated => self.wtr.write_str(\"[:^graph:]\"),\n358         Graph => self.wtr.write_str(\"[:graph:]\"),\n359         Lower if ast.negated => self.wtr.write_str(\"[:^lower:]\"),\n360         Lower => self.wtr.write_str(\"[:lower:]\"),\n361         Print if ast.negated => self.wtr.write_str(\"[:^print:]\"),\n362         Print => self.wtr.write_str(\"[:print:]\"),\n363         Punct if ast.negated => self.wtr.write_str(\"[:^punct:]\"),\n364         Punct => self.wtr.write_str(\"[:punct:]\"),\n365         Space if ast.negated => self.wtr.write_str(\"[:^space:]\"),\n366         Space => self.wtr.write_str(\"[:space:]\"),\n367         Upper if ast.negated => self.wtr.write_str(\"[:^upper:]\"),\n368         Upper => self.wtr.write_str(\"[:upper:]\"),\n369         Word if ast.negated => self.wtr.write_str(\"[:^word:]\"),\n370         Word => self.wtr.write_str(\"[:word:]\"),\n371         Xdigit if ast.negated => self.wtr.write_str(\"[:^xdigit:]\"),\n372         Xdigit => self.wtr.write_str(\"[:xdigit:]\"),\n373     }\n374 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}