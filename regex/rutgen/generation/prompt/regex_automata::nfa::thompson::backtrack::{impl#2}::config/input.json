{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/nfa/thompson/backtrack.rs\n// crate name is regex_automata\nuse alloc::{vec, vec::Vec};\nuse crate::{\n    nfa::thompson::{self, BuildError, State, NFA},\n    util::{\n        captures::Captures, empty, iter, prefilter::Prefilter,\n        primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},\n        search::{Anchored, HalfMatch, Input, Match, MatchError, Span},\n    },\n};\n#[derive(Clone, Debug)]\npub struct BoundedBacktracker {\n    config: Config,\n    nfa: NFA,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    pre: Option<Option<Prefilter>>,\n    visited_capacity: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    utf8: Option<bool>,\n    reverse: Option<bool>,\n    nfa_size_limit: Option<Option<usize>>,\n    shrink: Option<bool>,\n    which_captures: Option<WhichCaptures>,\n    look_matcher: Option<LookMatcher>,\n    #[cfg(test)]\n    unanchored_prefix: Option<bool>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    size_limit: Option<Option<usize>>,\n}\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    accelerate: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    minimize: Option<bool>,\n    match_kind: Option<MatchKind>,\n    start_kind: Option<StartKind>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    determinize_size_limit: Option<Option<usize>>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    pre: Option<Option<Prefilter>>,\n    starts_for_each_pattern: Option<bool>,\n    byte_classes: Option<bool>,\n    unicode_word_boundary: Option<bool>,\n    quitset: Option<ByteSet>,\n    specialize_start_states: Option<bool>,\n    cache_capacity: Option<usize>,\n    skip_cache_capacity_check: Option<bool>,\n    minimum_cache_clear_count: Option<Option<usize>>,\n    minimum_bytes_per_state: Option<Option<usize>>,\n}\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    case_insensitive: bool,\n    multi_line: bool,\n    dot_matches_new_line: bool,\n    crlf: bool,\n    line_terminator: u8,\n    swap_greed: bool,\n    ignore_whitespace: bool,\n    unicode: bool,\n    utf8: bool,\n    nest_limit: u32,\n    octal: bool,\n}\n#[derive(Clone, Debug)]\npub struct Config {\n    look_behind: Option<u8>,\n    anchored: Anchored,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\nimpl BoundedBacktracker {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<BoundedBacktracker, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(\n        patterns: &[P],\n    ) -> Result<BoundedBacktracker, BuildError> {}\n    pub fn new_from_nfa(nfa: NFA) -> Result<BoundedBacktracker, BuildError> {}\n    pub fn always_match() -> Result<BoundedBacktracker, BuildError> {}\n    pub fn never_match() -> Result<BoundedBacktracker, BuildError> {}\n    pub fn config() -> Config {\n        Config::new()\n    }\n    pub fn builder() -> Builder {}\n    pub fn create_cache(&self) -> Cache {}\n    pub fn create_captures(&self) -> Captures {}\n    pub fn reset_cache(&self, cache: &mut Cache) {}\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn get_config(&self) -> &Config {}\n    #[inline]\n    pub fn get_nfa(&self) -> &NFA {}\n    #[inline]\n    pub fn max_haystack_len(&self) -> usize {}\n}\nimpl Config {\n    pub fn new() -> Config {\n        Config::default()\n    }\n    pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {}\n    pub fn visited_capacity(mut self, capacity: usize) -> Config {}\n    pub fn get_prefilter(&self) -> Option<&Prefilter> {}\n    pub fn get_visited_capacity(&self) -> usize {}\n    pub(crate) fn overwrite(&self, o: Config) -> Config {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Return a default configuration for a `BoundedBacktracker`.\n///\n/// This is a convenience routine to avoid needing to import the `Config`\n/// type when customizing the construction of a `BoundedBacktracker`.\n///\n/// # Example\n///\n/// This example shows how to disable UTF-8 mode. When UTF-8 mode is\n/// disabled, zero-width matches that split a codepoint are allowed.\n/// Otherwise they are never reported.\n///\n/// In the code below, notice that `\"\"` is permitted to match positions\n/// that split the encoding of a codepoint.\n///\n/// ```\n/// use regex_automata::{\n///     nfa::thompson::{self, backtrack::BoundedBacktracker},\n///     Match,\n/// };\n///\n/// let re = BoundedBacktracker::builder()\n///     .thompson(thompson::Config::new().utf8(false))\n///     .build(r\"\")?;\n/// let mut cache = re.create_cache();\n///\n/// let haystack = \"aâ˜ƒz\";\n/// let mut it = re.try_find_iter(&mut cache, haystack);\n/// assert_eq!(Some(Ok(Match::must(0, 0..0))), it.next());\n/// assert_eq!(Some(Ok(Match::must(0, 1..1))), it.next());\n/// assert_eq!(Some(Ok(Match::must(0, 2..2))), it.next());\n/// assert_eq!(Some(Ok(Match::must(0, 3..3))), it.next());\n/// assert_eq!(Some(Ok(Match::must(0, 4..4))), it.next());\n/// assert_eq!(Some(Ok(Match::must(0, 5..5))), it.next());\n/// assert_eq!(None, it.next());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n604 pub fn config() -> Config {\n605     Config::new()\n606 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}