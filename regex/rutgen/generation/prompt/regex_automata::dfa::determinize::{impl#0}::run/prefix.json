{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/determinize.rs\n// crate name is regex_automata\n#[cfg(feature = \"std\")]\ntype StateMap = std::collections::HashMap<State, StateID>;\n#[cfg(not(feature = \"std\"))]\ntype StateMap = BTreeMap<State, StateID>;\nuse alloc::{collections::BTreeMap, vec::Vec};\nuse crate::{\n    dfa::{\n        dense::{self, BuildError},\n        DEAD,\n    },\n    nfa::thompson,\n    util::{\n        self, alphabet::{self, ByteSet},\n        determinize::{State, StateBuilderEmpty, StateBuilderNFA},\n        primitives::{PatternID, StateID},\n        search::{Anchored, MatchKind},\n        sparse_set::SparseSets, start::Start,\n    },\n};\n#[derive(Clone, Debug)]\npub(crate) struct Config {\n    match_kind: MatchKind,\n    quit: ByteSet,\n    dfa_size_limit: Option<usize>,\n    determinize_size_limit: Option<usize>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct StateBuilderEmpty(Vec<u8>);\n#[derive(Debug)]\nstruct Runner<'a> {\n    /// The configuration used to initialize determinization.\n    config: Config,\n    /// The NFA we're converting into a DFA.\n    nfa: &'a thompson::NFA,\n    /// The DFA we're building.\n    dfa: &'a mut dense::OwnedDFA,\n    /// Each DFA state being built is defined as an *ordered* set of NFA\n    /// states, along with some meta facts about the ordered set of NFA states.\n    ///\n    /// This is never empty. The first state is always a dummy state such that\n    /// a state id == 0 corresponds to a dead state. The second state is always\n    /// the quit state.\n    ///\n    /// Why do we have states in both a `Vec` and in a cache map below?\n    /// Well, they serve two different roles based on access patterns.\n    /// `builder_states` is the canonical home of each state, and provides\n    /// constant random access by a DFA state's ID. The cache map below, on\n    /// the other hand, provides a quick way of searching for identical DFA\n    /// states by using the DFA state as a key in the map. Of course, we use\n    /// reference counting to avoid actually duplicating the state's data\n    /// itself. (Although this has never been benchmarked.) Note that the cache\n    /// map does not give us full minimization; it just lets us avoid some very\n    /// obvious redundant states.\n    ///\n    /// Note that the index into this Vec isn't quite the DFA's state ID.\n    /// Rather, it's just an index. To get the state ID, you have to multiply\n    /// it by the DFA's stride. That's done by self.dfa.from_index. And the\n    /// inverse is self.dfa.to_index.\n    ///\n    /// Moreover, DFA states don't usually retain the IDs assigned to them\n    /// by their position in this Vec. After determinization completes,\n    /// states are shuffled around to support other optimizations. See the\n    /// sibling 'special' module for more details on that. (The reason for\n    /// mentioning this is that if you print out the DFA for debugging during\n    /// determinization, and then print out the final DFA after it is fully\n    /// built, then the state IDs likely won't match up.)\n    builder_states: Vec<State>,\n    /// A cache of DFA states that already exist and can be easily looked up\n    /// via ordered sets of NFA states.\n    ///\n    /// See `builder_states` docs for why we store states in two different\n    /// ways.\n    cache: StateMap,\n    /// The memory usage, in bytes, used by builder_states and cache. We track\n    /// this as new states are added since states use a variable amount of\n    /// heap. Tracking this as we add states makes it possible to compute the\n    /// total amount of memory used by the determinizer in constant time.\n    memory_usage_state: usize,\n    /// A pair of sparse sets for tracking ordered sets of NFA state IDs.\n    /// These are reused throughout determinization. A bounded sparse set\n    /// gives us constant time insertion, membership testing and clearing.\n    sparses: SparseSets,\n    /// Scratch space for a stack of NFA states to visit, for depth first\n    /// visiting without recursion.\n    stack: Vec<StateID>,\n    /// Scratch space for storing an ordered sequence of NFA states, for\n    /// amortizing allocation. This is principally useful for when we avoid\n    /// adding a new DFA state since it already exists. In order to detect this\n    /// case though, we still need an ordered set of NFA state IDs. So we use\n    /// this space to stage that ordered set before we know whether we need to\n    /// create a new DFA state or not.\n    scratch_state_builder: StateBuilderEmpty,\n}\n#[derive(Clone, Debug)]\npub(crate) struct SparseSets {\n    pub(crate) set1: SparseSet,\n    pub(crate) set2: SparseSet,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub(crate) struct State(Arc<[u8]>);\n#[cfg(feature = \"dfa-build\")]\n#[derive(Clone, Debug)]\npub struct BuildError {\n    kind: BuildErrorKind,\n}\n#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]\npub(crate) struct ByteSet {\n    bits: BitSet,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Debug)]\npub(crate) struct ByteSet([bool; 256]);\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\n#[derive(Clone, Eq, PartialEq)]\npub enum State {\n    /// A state with a single transition that can only be taken if the current\n    /// input symbol is in a particular range of bytes.\n    ByteRange {\n        /// The transition from this state to the next.\n        trans: Transition,\n    },\n    /// A state with possibly many transitions represented in a sparse fashion.\n    /// Transitions are non-overlapping and ordered lexicographically by input\n    /// range.\n    ///\n    /// In practice, this is used for encoding UTF-8 automata. Its presence is\n    /// primarily an optimization that avoids many additional unconditional\n    /// epsilon transitions (via [`Union`](State::Union) states), and thus\n    /// decreases the overhead of traversing the NFA. This can improve both\n    /// matching time and DFA construction time.\n    Sparse(SparseTransitions),\n    /// A dense representation of a state with multiple transitions.\n    Dense(DenseTransitions),\n    /// A conditional epsilon transition satisfied via some sort of\n    /// look-around. Look-around is limited to anchor and word boundary\n    /// assertions.\n    ///\n    /// Look-around states are meant to be evaluated while performing epsilon\n    /// closure (computing the set of states reachable from a particular state\n    /// via only epsilon transitions). If the current position in the haystack\n    /// satisfies the look-around assertion, then you're permitted to follow\n    /// that epsilon transition.\n    Look {\n        /// The look-around assertion that must be satisfied before moving\n        /// to `next`.\n        look: Look,\n        /// The state to transition to if the look-around assertion is\n        /// satisfied.\n        next: StateID,\n    },\n    /// An alternation such that there exists an epsilon transition to all\n    /// states in `alternates`, where matches found via earlier transitions\n    /// are preferred over later transitions.\n    Union {\n        /// An ordered sequence of unconditional epsilon transitions to other\n        /// states. Transitions earlier in the sequence are preferred over\n        /// transitions later in the sequence.\n        alternates: Box<[StateID]>,\n    },\n    /// An alternation such that there exists precisely two unconditional\n    /// epsilon transitions, where matches found via `alt1` are preferred over\n    /// matches found via `alt2`.\n    ///\n    /// This state exists as a common special case of Union where there are\n    /// only two alternates. In this case, we don't need any allocations to\n    /// represent the state. This saves a bit of memory and also saves an\n    /// additional memory access when traversing the NFA.\n    BinaryUnion {\n        /// An unconditional epsilon transition to another NFA state. This\n        /// is preferred over `alt2`.\n        alt1: StateID,\n        /// An unconditional epsilon transition to another NFA state. Matches\n        /// reported via this transition should only be reported if no matches\n        /// were found by following `alt1`.\n        alt2: StateID,\n    },\n    /// An empty state that records a capture location.\n    ///\n    /// From the perspective of finite automata, this is precisely equivalent\n    /// to an unconditional epsilon transition, but serves the purpose of\n    /// instructing NFA simulations to record additional state when the finite\n    /// state machine passes through this epsilon transition.\n    ///\n    /// `slot` in this context refers to the specific capture group slot\n    /// offset that is being recorded. Each capturing group has two slots\n    /// corresponding to the start and end of the matching portion of that\n    /// group.\n    ///\n    /// The pattern ID and capture group index are also included in this state\n    /// in case they are useful. But mostly, all you'll need is `next` and\n    /// `slot`.\n    Capture {\n        /// The state to transition to, unconditionally.\n        next: StateID,\n        /// The pattern ID that this capture belongs to.\n        pattern_id: PatternID,\n        /// The capture group index that this capture belongs to. Capture group\n        /// indices are local to each pattern. For example, when capturing\n        /// groups are enabled, every pattern has a capture group at index\n        /// `0`.\n        group_index: SmallIndex,\n        /// The slot index for this capture. Every capturing group has two\n        /// slots: one for the start haystack offset and one for the end\n        /// haystack offset. Unlike capture group indices, slot indices are\n        /// global across all patterns in this NFA. That is, each slot belongs\n        /// to a single pattern, but there is only one slot at index `i`.\n        slot: SmallIndex,\n    },\n    /// A state that cannot be transitioned out of. This is useful for cases\n    /// where you want to prevent matching from occurring. For example, if your\n    /// regex parser permits empty character classes, then one could choose\n    /// a `Fail` state to represent them. (An empty character class can be\n    /// thought of as an empty set. Since nothing is in an empty set, they can\n    /// never match anything.)\n    Fail,\n    /// A match state. There is at least one such occurrence of this state for\n    /// each regex that can match that is in this NFA.\n    Match {\n        /// The matching pattern ID.\n        pattern_id: PatternID,\n    },\n}\nimpl Config {\n    pub fn new() -> Config {}\n    pub fn run(\n        &self,\n        nfa: &thompson::NFA,\n        dfa: &mut dense::OwnedDFA,\n    ) -> Result<(), BuildError> {\n        let dead = State::dead();\n        let quit = State::dead();\n        let mut cache = StateMap::default();\n        cache.insert(dead.clone(), DEAD);\n        let runner = Runner {\n            config: self.clone(),\n            nfa,\n            dfa,\n            builder_states: alloc::vec![dead, quit],\n            cache,\n            memory_usage_state: 0,\n            sparses: SparseSets::new(nfa.states().len()),\n            stack: alloc::vec![],\n            scratch_state_builder: StateBuilderEmpty::new(),\n        };\n        runner.run()\n    }\n    pub fn match_kind(&mut self, kind: MatchKind) -> &mut Config {}\n    pub fn quit(&mut self, set: ByteSet) -> &mut Config {}\n    pub fn dfa_size_limit(&mut self, bytes: Option<usize>) -> &mut Config {}\n    pub fn determinize_size_limit(&mut self, bytes: Option<usize>) -> &mut Config {}\n}\nimpl StateBuilderEmpty {\n    pub(crate) fn new() -> StateBuilderEmpty {\n        StateBuilderEmpty(alloc::vec![])\n    }\n    pub(crate) fn into_matches(mut self) -> StateBuilderMatches {}\n    fn clear(&mut self) {}\n    pub(crate) fn capacity(&self) -> usize {}\n}\nimpl<'a> Runner<'a> {\n    fn run(mut self) -> Result<(), BuildError> {\n        if self.nfa.look_set_any().contains_word_unicode()\n            && !self.config.quit.contains_range(0x80, 0xFF)\n        {\n            return Err(BuildError::unsupported_dfa_word_boundary_unicode());\n        }\n        let representatives: Vec<alphabet::Unit> = self\n            .dfa\n            .byte_classes()\n            .representatives(..)\n            .collect();\n        let mut uncompiled = alloc::vec![];\n        self.add_all_starts(&mut uncompiled)?;\n        while let Some(dfa_id) = uncompiled.pop() {\n            for &unit in &representatives {\n                if unit.as_u8().map_or(false, |b| self.config.quit.contains(b)) {\n                    continue;\n                }\n                let (next_dfa_id, is_new) = self.cached_state(dfa_id, unit)?;\n                self.dfa.set_transition(dfa_id, unit, next_dfa_id);\n                if is_new {\n                    uncompiled.push(next_dfa_id);\n                }\n            }\n        }\n        debug!(\n            \"determinization complete, memory usage: {}, \\\n             dense DFA size: {}, \\\n             is reverse? {}\",\n            self.memory_usage(), self.dfa.memory_usage(), self.nfa.is_reverse(),\n        );\n        let mut matches: BTreeMap<StateID, Vec<PatternID>> = BTreeMap::new();\n        self.cache.clear();\n        #[cfg(feature = \"logging\")]\n        let mut total_pat_len = 0;\n        for (i, state) in self.builder_states.into_iter().enumerate() {\n            if let Some(pat_ids) = state.match_pattern_ids() {\n                let id = self.dfa.to_state_id(i);\n                log! {\n                    total_pat_len += pat_ids.len();\n                }\n                matches.insert(id, pat_ids);\n            }\n        }\n        log! {\n            use core::mem::size_of; let per_elem = size_of::< StateID > () + size_of::<\n            Vec < PatternID >> (); let pats = total_pat_len * size_of::< PatternID > ();\n            let mem = (matches.len() * per_elem) + pats;\n            log::debug!(\"matches map built, memory usage: {}\", mem);\n        }\n        self.dfa.shuffle(matches)?;\n        Ok(())\n    }\n    fn cached_state(\n        &mut self,\n        dfa_id: StateID,\n        unit: alphabet::Unit,\n    ) -> Result<(StateID, bool), BuildError> {}\n    fn add_all_starts(\n        &mut self,\n        dfa_state_ids: &mut Vec<StateID>,\n    ) -> Result<(), BuildError> {}\n    fn add_start_group(\n        &mut self,\n        anchored: Anchored,\n        dfa_state_ids: &mut Vec<StateID>,\n    ) -> Result<(), BuildError> {}\n    fn add_one_start(\n        &mut self,\n        nfa_start: StateID,\n        start: Start,\n    ) -> Result<(StateID, bool), BuildError> {}\n    fn maybe_add_state(\n        &mut self,\n        builder: StateBuilderNFA,\n    ) -> Result<(StateID, bool), BuildError> {}\n    fn add_state(&mut self, builder: StateBuilderNFA) -> Result<StateID, BuildError> {}\n    fn get_state_builder(&mut self) -> StateBuilderEmpty {}\n    fn put_state_builder(&mut self, builder: StateBuilderNFA) {}\n    fn memory_usage(&self) -> usize {}\n}\nimpl SparseSets {\n    pub(crate) fn new(capacity: usize) -> SparseSets {\n        SparseSets {\n            set1: SparseSet::new(capacity),\n            set2: SparseSet::new(capacity),\n        }\n    }\n    #[inline]\n    pub(crate) fn resize(&mut self, new_capacity: usize) {}\n    pub(crate) fn clear(&mut self) {}\n    pub(crate) fn swap(&mut self) {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {}\n    #[inline]\n    pub fn states(&self) -> &[State] {\n        &self.0.states\n    }\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {}\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {}\n    #[inline]\n    pub fn is_utf8(&self) -> bool {}\n    #[inline]\n    pub fn is_reverse(&self) -> bool {}\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {}\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {}\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl State {\n    pub(crate) fn dead() -> State {\n        StateBuilderEmpty::new().into_matches().into_nfa().to_state()\n    }\n    pub(crate) fn is_match(&self) -> bool {}\n    pub(crate) fn is_from_word(&self) -> bool {}\n    pub(crate) fn is_half_crlf(&self) -> bool {}\n    pub(crate) fn look_have(&self) -> LookSet {}\n    pub(crate) fn look_need(&self) -> LookSet {}\n    pub(crate) fn match_len(&self) -> usize {}\n    pub(crate) fn match_pattern(&self, index: usize) -> PatternID {}\n    pub(crate) fn match_pattern_ids(&self) -> Option<Vec<PatternID>> {}\n    #[cfg(all(test, not(miri)))]\n    pub(crate) fn iter_match_pattern_ids<F: FnMut(PatternID)>(&self, f: F) {}\n    pub(crate) fn iter_nfa_state_ids<F: FnMut(StateID)>(&self, f: F) {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n    fn repr(&self) -> Repr<'_> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Run determinization on the given NFA and write the resulting DFA into\n/// the one given. The DFA given should be initialized but otherwise empty.\n/// \"Initialized\" means that it is setup to handle the NFA's byte classes,\n/// number of patterns and whether to build start states for each pattern.\n45 pub fn run(\n46     &self,\n47     nfa: &thompson::NFA,\n48     dfa: &mut dense::OwnedDFA,\n49 ) -> Result<(), BuildError> {\n50     let dead = State::dead();\n51     let quit = State::dead();\n52     let mut cache = StateMap::default();\n53     // We only insert the dead state here since its representation is\n54     // identical to the quit state. And we never want anything pointing\n55     // to the quit state other than specific transitions derived from the\n56     // determinizer's configured \"quit\" bytes.\n57     //\n58     // We do put the quit state into 'builder_states' below. This ensures\n59     // that a proper DFA state ID is allocated for it, and that no other\n60     // DFA state uses the \"location after the DEAD state.\" That is, it\n61     // is assumed that the quit state is always the state immediately\n62     // following the DEAD state.\n63     cache.insert(dead.clone(), DEAD);\n64 \n65     let runner = Runner {\n66         config: self.clone(),\n67         nfa,\n68         dfa,\n69         builder_states: alloc::vec![dead, quit],\n70         cache,\n71         memory_usage_state: 0,\n72         sparses: SparseSets::new(nfa.states().len()),\n73         stack: alloc::vec![],\n74         scratch_state_builder: StateBuilderEmpty::new(),\n75     };\n76     runner.run()\n77 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}