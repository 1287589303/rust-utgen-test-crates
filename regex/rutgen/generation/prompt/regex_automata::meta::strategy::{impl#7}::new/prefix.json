{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseSuffix {\n    core: Core,\n    pre: Prefilter,\n}\n#[derive(Debug)]\npub(crate) struct DFA(Option<DFAEngine>);\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Debug, Default)]\npub struct Config {\n    match_kind: Option<MatchKind>,\n    utf8_empty: Option<bool>,\n    autopre: Option<bool>,\n    pre: Option<Option<Prefilter>>,\n    which_captures: Option<WhichCaptures>,\n    nfa_size_limit: Option<Option<usize>>,\n    onepass_size_limit: Option<Option<usize>>,\n    hybrid_cache_capacity: Option<usize>,\n    hybrid: Option<bool>,\n    dfa: Option<bool>,\n    dfa_size_limit: Option<Option<usize>>,\n    dfa_state_limit: Option<Option<usize>>,\n    onepass: Option<bool>,\n    backtrack: Option<bool>,\n    byte_classes: Option<bool>,\n    line_terminator: Option<u8>,\n}\n#[derive(Clone, Debug)]\npub(crate) struct RegexInfo(Arc<RegexInfoI>);\n#[derive(Debug)]\npub(crate) struct Hybrid(Option<HybridEngine>);\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\nimpl ReverseSuffix {\n    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {\n        if !core.info.config().get_auto_prefilter() {\n            debug!(\n                \"skipping reverse suffix optimization because \\\n                 automatic prefilters are disabled\"\n            );\n            return Err(core);\n        }\n        if core.info.is_always_anchored_start() {\n            debug!(\n                \"skipping reverse suffix optimization because \\\n\t\t\t\t the regex is always anchored at the start\",\n            );\n            return Err(core);\n        }\n        if !core.hybrid.is_some() && !core.dfa.is_some() {\n            debug!(\n                \"skipping reverse suffix optimization because \\\n\t\t\t\t we don't have a lazy DFA or a full DFA\"\n            );\n            return Err(core);\n        }\n        if core.pre.as_ref().map_or(false, |p| p.is_fast()) {\n            debug!(\n                \"skipping reverse suffix optimization because \\\n\t\t\t\t we already have a prefilter that we think is fast\"\n            );\n            return Err(core);\n        }\n        let kind = core.info.config().get_match_kind();\n        let suffixes = crate::util::prefilter::suffixes(kind, hirs);\n        let lcs = match suffixes.longest_common_suffix() {\n            None => {\n                debug!(\n                    \"skipping reverse suffix optimization because \\\n                     a longest common suffix could not be found\",\n                );\n                return Err(core);\n            }\n            Some(lcs) if lcs.is_empty() => {\n                debug!(\n                    \"skipping reverse suffix optimization because \\\n                     the longest common suffix is the empty string\",\n                );\n                return Err(core);\n            }\n            Some(lcs) => lcs,\n        };\n        let pre = match Prefilter::new(kind, &[lcs]) {\n            Some(pre) => pre,\n            None => {\n                debug!(\n                    \"skipping reverse suffix optimization because \\\n                     a prefilter could not be constructed from the \\\n                     longest common suffix\",\n                );\n                return Err(core);\n            }\n        };\n        if !pre.is_fast() {\n            debug!(\n                \"skipping reverse suffix optimization because \\\n\t\t\t\t while we have a suffix prefilter, it is not \\\n\t\t\t\t believed to be 'fast'\"\n            );\n            return Err(core);\n        }\n        Ok(ReverseSuffix { core, pre })\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_start(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_fwd(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_rev_limited(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n}\nimpl DFA {\n    pub(crate) fn none() -> DFA {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> DFA {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&DFAEngine> {}\n    pub(crate) fn is_some(&self) -> bool {\n        self.0.is_some()\n    }\n    pub(crate) fn memory_usage(&self) -> usize {}\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {\n        Choice::new(kind, needles)\n            .and_then(|choice| {\n                let max_needle_len = needles\n                    .iter()\n                    .map(|b| b.as_ref().len())\n                    .max()\n                    .unwrap_or(0);\n                Prefilter::from_choice(choice, max_needle_len)\n            })\n    }\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {\n        #[cfg(not(feature = \"alloc\"))] { unreachable!() }\n        #[cfg(feature = \"alloc\")] { self.is_fast }\n    }\n}\nimpl Config {\n    pub fn new() -> Config {}\n    pub fn match_kind(self, kind: MatchKind) -> Config {}\n    pub fn utf8_empty(self, yes: bool) -> Config {}\n    pub fn auto_prefilter(self, yes: bool) -> Config {}\n    pub fn prefilter(self, pre: Option<Prefilter>) -> Config {}\n    pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {}\n    pub fn nfa_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn onepass_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn hybrid_cache_capacity(self, limit: usize) -> Config {}\n    pub fn dfa_size_limit(self, limit: Option<usize>) -> Config {}\n    pub fn dfa_state_limit(self, limit: Option<usize>) -> Config {}\n    pub fn byte_classes(self, yes: bool) -> Config {}\n    pub fn line_terminator(self, byte: u8) -> Config {}\n    pub fn hybrid(self, yes: bool) -> Config {}\n    pub fn dfa(self, yes: bool) -> Config {}\n    pub fn onepass(self, yes: bool) -> Config {}\n    pub fn backtrack(self, yes: bool) -> Config {}\n    pub fn get_match_kind(&self) -> MatchKind {\n        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)\n    }\n    pub fn get_utf8_empty(&self) -> bool {}\n    pub fn get_auto_prefilter(&self) -> bool {\n        self.autopre.unwrap_or(true)\n    }\n    pub fn get_prefilter(&self) -> Option<&Prefilter> {}\n    pub fn get_which_captures(&self) -> WhichCaptures {}\n    pub fn get_nfa_size_limit(&self) -> Option<usize> {}\n    pub fn get_onepass_size_limit(&self) -> Option<usize> {}\n    pub fn get_hybrid_cache_capacity(&self) -> usize {}\n    pub fn get_dfa_size_limit(&self) -> Option<usize> {}\n    pub fn get_dfa_state_limit(&self) -> Option<usize> {}\n    pub fn get_byte_classes(&self) -> bool {}\n    pub fn get_line_terminator(&self) -> u8 {}\n    pub fn get_hybrid(&self) -> bool {}\n    pub fn get_dfa(&self) -> bool {}\n    pub fn get_onepass(&self) -> bool {}\n    pub fn get_backtrack(&self) -> bool {}\n    pub(crate) fn overwrite(&self, o: Config) -> Config {}\n}\nimpl RegexInfo {\n    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {}\n    pub(crate) fn config(&self) -> &Config {\n        &self.0.config\n    }\n    pub(crate) fn props(&self) -> &[hir::Properties] {}\n    pub(crate) fn props_union(&self) -> &hir::Properties {}\n    pub(crate) fn pattern_len(&self) -> usize {}\n    pub(crate) fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_anchored_start(&self, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_start(&self) -> bool {\n        use regex_syntax::hir::Look;\n        self.props_union().look_set_prefix().contains(Look::Start)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn is_always_anchored_end(&self) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_impossible(&self, input: &Input<'_>) -> bool {}\n}\nimpl Hybrid {\n    pub(crate) fn none() -> Hybrid {}\n    pub(crate) fn new(\n        info: &RegexInfo,\n        pre: Option<Prefilter>,\n        nfa: &NFA,\n        nfarev: &NFA,\n    ) -> Hybrid {}\n    pub(crate) fn create_cache(&self) -> HybridCache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn get(&self, _input: &Input<'_>) -> Option<&HybridEngine> {}\n    pub(crate) fn is_some(&self) -> bool {\n        self.0.is_some()\n    }\n}\n#[cfg(feature = \"syntax\")]\npub(crate) fn suffixes<H>(kind: MatchKind, hirs: &[H]) -> literal::Seq\nwhere\n    H: core::borrow::Borrow<Hir>,\n{\n    let mut extractor = literal::Extractor::new();\n    extractor.kind(literal::ExtractKind::Suffix);\n    let mut suffixes = literal::Seq::empty();\n    for hir in hirs {\n        suffixes.union(&mut extractor.extract(hir.borrow()));\n    }\n    debug!(\n        \"suffixes (len={:?}, exact={:?}) extracted before optimization: {:?}\", suffixes\n        .len(), suffixes.is_exact(), suffixes\n    );\n    match kind {\n        MatchKind::All => {\n            suffixes.sort();\n            suffixes.dedup();\n        }\n        MatchKind::LeftmostFirst => {\n            suffixes.optimize_for_suffix_by_preference();\n        }\n    }\n    debug!(\n        \"suffixes (len={:?}, exact={:?}) extracted after optimization: {:?}\", suffixes\n        .len(), suffixes.is_exact(), suffixes\n    );\n    suffixes\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1122 fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {\n1123     if !core.info.config().get_auto_prefilter() {\n1124         debug!(\n1125             \"skipping reverse suffix optimization because \\\n1126              automatic prefilters are disabled\"\n1127         );\n1128         return Err(core);\n1129     }\n1130     // Like the reverse inner optimization, we don't do this for regexes\n1131     // that are always anchored. It could lead to scanning too much, but\n1132     // could say \"no match\" much more quickly than running the regex\n1133     // engine if the initial literal scan doesn't match. With that said,\n1134     // the reverse suffix optimization has lower overhead, since it only\n1135     // requires a reverse scan after a literal match to confirm or reject\n1136     // the match. (Although, in the case of confirmation, it then needs to\n1137     // do another forward scan to find the end position.)\n1138     //\n1139     // Note that the caller can still request an anchored search even\n1140     // when the regex isn't anchored. We detect that case in the search\n1141     // routines below and just fallback to the core engine. Currently this\n1142     // optimization assumes all searches are unanchored, so if we do want\n1143     // to enable this optimization for anchored searches, it will need a\n1144     // little work to support it.\n1145     if core.info.is_always_anchored_start() {\n1146         debug!(\n1147             \"skipping reverse suffix optimization because \\\n1148  the regex is always anchored at the start\",\n1149         );\n1150         return Err(core);\n1151     }\n1152     // Only DFAs can do reverse searches (currently), so we need one of\n1153     // them in order to do this optimization. It's possible (although\n1154     // pretty unlikely) that we have neither and need to give up.\n1155     if !core.hybrid.is_some() && !core.dfa.is_some() {\n1156         debug!(\n1157             \"skipping reverse suffix optimization because \\\n1158  we don't have a lazy DFA or a full DFA\"\n1159         );\n1160         return Err(core);\n1161     }\n1162     if core.pre.as_ref().map_or(false, |p| p.is_fast()) {\n1163         debug!(\n1164             \"skipping reverse suffix optimization because \\\n1165  we already have a prefilter that we think is fast\"\n1166         );\n1167         return Err(core);\n1168     }\n1169     let kind = core.info.config().get_match_kind();\n1170     let suffixes = crate::util::prefilter::suffixes(kind, hirs);\n1171     let lcs = match suffixes.longest_common_suffix() {\n1172         None => {\n1173             debug!(\n1174                 \"skipping reverse suffix optimization because \\\n1175                  a longest common suffix could not be found\",\n1176             );\n1177             return Err(core);\n1178         }\n1179         Some(lcs) if lcs.is_empty() => {\n1180             debug!(\n1181                 \"skipping reverse suffix optimization because \\\n1182                  the longest common suffix is the empty string\",\n1183             );\n1184             return Err(core);\n1185         }\n1186         Some(lcs) => lcs,\n1187     };\n1188     let pre = match Prefilter::new(kind, &[lcs]) {\n1189         Some(pre) => pre,\n1190         None => {\n1191             debug!(\n1192                 \"skipping reverse suffix optimization because \\\n1193                  a prefilter could not be constructed from the \\\n1194                  longest common suffix\",\n1195             );\n1196             return Err(core);\n1197         }\n1198     };\n1199     if !pre.is_fast() {\n1200         debug!(\n1201             \"skipping reverse suffix optimization because \\\n1202  while we have a suffix prefilter, it is not \\\n1203  believed to be 'fast'\"\n1204         );\n1205         return Err(core);\n1206     }\n1207     Ok(ReverseSuffix { core, pre })\n1208 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}