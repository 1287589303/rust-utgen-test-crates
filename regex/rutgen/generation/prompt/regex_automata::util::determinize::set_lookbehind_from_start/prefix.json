{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/determinize/mod.rs\n// crate name is regex_automata\nuse alloc::vec::Vec;\npub(crate) use self::state::{\n    State, StateBuilderEmpty, StateBuilderMatches, StateBuilderNFA,\n};\nuse crate::{\n    nfa::thompson,\n    util::{\n        alphabet, look::{Look, LookSet},\n        primitives::StateID, search::MatchKind, sparse_set::{SparseSet, SparseSets},\n        start::Start, utf8,\n    },\n};\n#[derive(Clone, Debug)]\npub struct LookMatcher {\n    lineterm: DebugByte,\n}\n#[derive(Clone)]\npub struct NFA(Arc<Inner>);\n#[derive(Clone)]\npub(crate) struct StateBuilderMatches(Vec<u8>);\n#[derive(Clone, Copy, Default, Eq, PartialEq)]\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where\n    /// `i = Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u32,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub(crate) enum Start {\n    /// This occurs when the starting position is not any of the ones below.\n    NonWordByte = 0,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is an ASCII word byte.\n    WordByte = 1,\n    /// This occurs when the starting position of the search corresponds to the\n    /// beginning of the haystack.\n    Text = 2,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\n`.\n    LineLF = 3,\n    /// This occurs when the byte immediately preceding the start of the search\n    /// is a line terminator. Specifically, `\\r`.\n    LineCR = 4,\n    /// This occurs when a custom line terminator has been set via a\n    /// `LookMatcher`, and when that line terminator is neither a `\\r` or a\n    /// `\\n`.\n    ///\n    /// If the custom line terminator is a word byte, then this start\n    /// configuration is still selected. DFAs that implement word boundary\n    /// assertions will likely need to check whether the custom line terminator\n    /// is a word byte, in which case, it should behave as if the byte\n    /// satisfies `\\b` in addition to multi-line anchors.\n    CustomLineTerminator = 5,\n}\nimpl LookMatcher {\n    pub fn new() -> LookMatcher {}\n    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {}\n    pub fn get_line_terminator(&self) -> u8 {\n        self.lineterm.0\n    }\n    #[inline]\n    pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_inline(&self, look: Look, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn matches_set(&self, set: LookSet, haystack: &[u8], at: usize) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub(crate) fn matches_set_inline(\n        &self,\n        set: LookSet,\n        haystack: &[u8],\n        at: usize,\n    ) -> bool {}\n    #[cfg(feature = \"alloc\")]\n    pub(crate) fn add_to_byteset(\n        &self,\n        look: Look,\n        set: &mut crate::util::alphabet::ByteClassSet,\n    ) {}\n    #[inline]\n    pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_unicode_negate(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_start_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {}\n    #[inline]\n    pub fn is_word_start_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n    #[inline]\n    pub fn is_word_end_half_unicode(\n        &self,\n        haystack: &[u8],\n        at: usize,\n    ) -> Result<bool, UnicodeWordBoundaryError> {}\n}\nimpl NFA {\n    #[cfg(feature = \"syntax\")]\n    pub fn new(pattern: &str) -> Result<NFA, BuildError> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {}\n    pub fn always_match() -> NFA {}\n    pub fn never_match() -> NFA {}\n    #[cfg(feature = \"syntax\")]\n    pub fn config() -> Config {}\n    #[cfg(feature = \"syntax\")]\n    pub fn compiler() -> Compiler {}\n    pub fn patterns(&self) -> PatternIter<'_> {}\n    #[inline]\n    pub fn pattern_len(&self) -> usize {}\n    #[inline]\n    pub fn start_anchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_unanchored(&self) -> StateID {}\n    #[inline]\n    pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {}\n    #[inline]\n    pub(crate) fn byte_class_set(&self) -> &ByteClassSet {}\n    #[inline]\n    pub fn byte_classes(&self) -> &ByteClasses {}\n    #[inline]\n    pub fn state(&self, id: StateID) -> &State {}\n    #[inline]\n    pub fn states(&self) -> &[State] {}\n    #[inline]\n    pub fn group_info(&self) -> &GroupInfo {}\n    #[inline]\n    pub fn has_capture(&self) -> bool {}\n    #[inline]\n    pub fn has_empty(&self) -> bool {}\n    #[inline]\n    pub fn is_utf8(&self) -> bool {}\n    #[inline]\n    pub fn is_reverse(&self) -> bool {\n        self.0.reverse\n    }\n    #[inline]\n    pub fn is_always_start_anchored(&self) -> bool {}\n    #[inline]\n    pub fn look_matcher(&self) -> &LookMatcher {\n        &self.0.look_matcher\n    }\n    #[inline]\n    pub fn look_set_any(&self) -> LookSet {\n        self.0.look_set_any\n    }\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n}\nimpl StateBuilderMatches {\n    pub(crate) fn into_nfa(mut self) -> StateBuilderNFA {}\n    pub(crate) fn set_is_from_word(&mut self) {\n        self.repr_vec().set_is_from_word()\n    }\n    pub(crate) fn set_is_half_crlf(&mut self) {\n        self.repr_vec().set_is_half_crlf()\n    }\n    pub(crate) fn look_have(&self) -> LookSet {}\n    pub(crate) fn set_look_have(&mut self, set: impl FnMut(LookSet) -> LookSet) {\n        self.repr_vec().set_look_have(set)\n    }\n    pub(crate) fn add_match_pattern_id(&mut self, pid: PatternID) {}\n    fn repr(&self) -> Repr<'_> {}\n    fn repr_vec(&mut self) -> ReprVec<'_> {}\n}\nimpl LookSet {\n    #[inline]\n    pub fn empty() -> LookSet {}\n    #[inline]\n    pub fn full() -> LookSet {}\n    #[inline]\n    pub fn singleton(look: Look) -> LookSet {}\n    #[inline]\n    pub fn len(self) -> usize {}\n    #[inline]\n    pub fn is_empty(self) -> bool {}\n    #[inline]\n    pub fn contains(self, look: Look) -> bool {}\n    #[inline]\n    pub fn contains_anchor(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_haystack(&self) -> bool {\n        self.contains(Look::Start) || self.contains(Look::End)\n    }\n    #[inline]\n    pub fn contains_anchor_line(&self) -> bool {\n        self.contains(Look::StartLF) || self.contains(Look::EndLF)\n            || self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)\n    }\n    #[inline]\n    pub fn contains_anchor_lf(&self) -> bool {}\n    #[inline]\n    pub fn contains_anchor_crlf(&self) -> bool {\n        self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)\n    }\n    #[inline]\n    pub fn contains_word(self) -> bool {\n        self.contains_word_unicode() || self.contains_word_ascii()\n    }\n    #[inline]\n    pub fn contains_word_unicode(self) -> bool {}\n    #[inline]\n    pub fn contains_word_ascii(self) -> bool {}\n    #[inline]\n    pub fn iter(self) -> LookSetIter {}\n    #[inline]\n    pub fn insert(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_insert(&mut self, look: Look) {}\n    #[inline]\n    pub fn remove(self, look: Look) -> LookSet {}\n    #[inline]\n    pub fn set_remove(&mut self, look: Look) {}\n    #[inline]\n    pub fn subtract(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_subtract(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn union(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_union(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn intersect(self, other: LookSet) -> LookSet {}\n    #[inline]\n    pub fn set_intersect(&mut self, other: LookSet) {}\n    #[inline]\n    pub fn read_repr(slice: &[u8]) -> LookSet {}\n    #[inline]\n    pub fn write_repr(self, slice: &mut [u8]) {}\n    pub fn available(self) -> Result<(), UnicodeWordBoundaryError> {}\n}\npub(crate) fn set_lookbehind_from_start(\n    nfa: &thompson::NFA,\n    start: &Start,\n    builder: &mut StateBuilderMatches,\n) {\n    let rev = nfa.is_reverse();\n    let lineterm = nfa.look_matcher().get_line_terminator();\n    let lookset = nfa.look_set_any();\n    match *start {\n        Start::NonWordByte => {\n            if lookset.contains_word() {\n                builder\n                    .set_look_have(|have| {\n                        have.insert(Look::WordStartHalfAscii)\n                            .insert(Look::WordStartHalfUnicode)\n                    });\n            }\n        }\n        Start::WordByte => {\n            if lookset.contains_word() {\n                builder.set_is_from_word();\n            }\n        }\n        Start::Text => {\n            if lookset.contains_anchor_haystack() {\n                builder.set_look_have(|have| have.insert(Look::Start));\n            }\n            if lookset.contains_anchor_line() {\n                builder\n                    .set_look_have(|have| {\n                        have.insert(Look::StartLF).insert(Look::StartCRLF)\n                    });\n            }\n            if lookset.contains_word() {\n                builder\n                    .set_look_have(|have| {\n                        have.insert(Look::WordStartHalfAscii)\n                            .insert(Look::WordStartHalfUnicode)\n                    });\n            }\n        }\n        Start::LineLF => {\n            if rev {\n                if lookset.contains_anchor_crlf() {\n                    builder.set_is_half_crlf();\n                }\n                if lookset.contains_anchor_line() {\n                    builder.set_look_have(|have| have.insert(Look::StartLF));\n                }\n            } else {\n                if lookset.contains_anchor_line() {\n                    builder.set_look_have(|have| have.insert(Look::StartCRLF));\n                }\n            }\n            if lookset.contains_anchor_line() && lineterm == b'\\n' {\n                builder.set_look_have(|have| have.insert(Look::StartLF));\n            }\n            if lookset.contains_word() {\n                builder\n                    .set_look_have(|have| {\n                        have.insert(Look::WordStartHalfAscii)\n                            .insert(Look::WordStartHalfUnicode)\n                    });\n            }\n        }\n        Start::LineCR => {\n            if lookset.contains_anchor_crlf() {\n                if rev {\n                    builder.set_look_have(|have| have.insert(Look::StartCRLF));\n                } else {\n                    builder.set_is_half_crlf();\n                }\n            }\n            if lookset.contains_anchor_line() && lineterm == b'\\r' {\n                builder.set_look_have(|have| have.insert(Look::StartLF));\n            }\n            if lookset.contains_word() {\n                builder\n                    .set_look_have(|have| {\n                        have.insert(Look::WordStartHalfAscii)\n                            .insert(Look::WordStartHalfUnicode)\n                    });\n            }\n        }\n        Start::CustomLineTerminator => {\n            if lookset.contains_anchor_line() {\n                builder.set_look_have(|have| have.insert(Look::StartLF));\n            }\n            if lookset.contains_word() {\n                if utf8::is_word_byte(lineterm) {\n                    builder.set_is_from_word();\n                } else {\n                    builder\n                        .set_look_have(|have| {\n                            have.insert(Look::WordStartHalfAscii)\n                                .insert(Look::WordStartHalfUnicode)\n                        });\n                }\n            }\n        }\n    }\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\npub(crate) fn is_word_byte(b: u8) -> bool {\n    const fn mkwordset() -> [bool; 256] {\n        let mut set = [false; 256];\n        set[b'_' as usize] = true;\n        let mut byte = b'0';\n        while byte <= b'9' {\n            set[byte as usize] = true;\n            byte += 1;\n        }\n        byte = b'A';\n        while byte <= b'Z' {\n            set[byte as usize] = true;\n            byte += 1;\n        }\n        byte = b'a';\n        while byte <= b'z' {\n            set[byte as usize] = true;\n            byte += 1;\n        }\n        set\n    }\n    const WORD: [bool; 256] = mkwordset();\n    WORD[b as usize]\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Sets the appropriate look-behind assertions on the given state based on\n/// this starting configuration.\n583 pub(crate) fn set_lookbehind_from_start(\n584     nfa: &thompson::NFA,\n585     start: &Start,\n586     builder: &mut StateBuilderMatches,\n587 ) {\n588     let rev = nfa.is_reverse();\n589     let lineterm = nfa.look_matcher().get_line_terminator();\n590     let lookset = nfa.look_set_any();\n591     match *start {\n592         Start::NonWordByte => {\n593             if lookset.contains_word() {\n594                 builder.set_look_have(|have| {\n595                     have.insert(Look::WordStartHalfAscii)\n596                         .insert(Look::WordStartHalfUnicode)\n597                 });\n598             }\n599         }\n600         Start::WordByte => {\n601             if lookset.contains_word() {\n602                 builder.set_is_from_word();\n603             }\n604         }\n605         Start::Text => {\n606             if lookset.contains_anchor_haystack() {\n607                 builder.set_look_have(|have| have.insert(Look::Start));\n608             }\n609             if lookset.contains_anchor_line() {\n610                 builder.set_look_have(|have| {\n611                     have.insert(Look::StartLF).insert(Look::StartCRLF)\n612                 });\n613             }\n614             if lookset.contains_word() {\n615                 builder.set_look_have(|have| {\n616                     have.insert(Look::WordStartHalfAscii)\n617                         .insert(Look::WordStartHalfUnicode)\n618                 });\n619             }\n620         }\n621         Start::LineLF => {\n622             if rev {\n623                 if lookset.contains_anchor_crlf() {\n624                     builder.set_is_half_crlf();\n625                 }\n626                 if lookset.contains_anchor_line() {\n627                     builder.set_look_have(|have| have.insert(Look::StartLF));\n628                 }\n629             } else {\n630                 if lookset.contains_anchor_line() {\n631                     builder.set_look_have(|have| have.insert(Look::StartCRLF));\n632                 }\n633             }\n634             if lookset.contains_anchor_line() && lineterm == b'\\n' {\n635                 builder.set_look_have(|have| have.insert(Look::StartLF));\n636             }\n637             if lookset.contains_word() {\n638                 builder.set_look_have(|have| {\n639                     have.insert(Look::WordStartHalfAscii)\n640                         .insert(Look::WordStartHalfUnicode)\n641                 });\n642             }\n643         }\n644         Start::LineCR => {\n645             if lookset.contains_anchor_crlf() {\n646                 if rev {\n647                     builder.set_look_have(|have| have.insert(Look::StartCRLF));\n648                 } else {\n649                     builder.set_is_half_crlf();\n650                 }\n651             }\n652             if lookset.contains_anchor_line() && lineterm == b'\\r' {\n653                 builder.set_look_have(|have| have.insert(Look::StartLF));\n654             }\n655             if lookset.contains_word() {\n656                 builder.set_look_have(|have| {\n657                     have.insert(Look::WordStartHalfAscii)\n658                         .insert(Look::WordStartHalfUnicode)\n659                 });\n660             }\n661         }\n662         Start::CustomLineTerminator => {\n663             if lookset.contains_anchor_line() {\n664                 builder.set_look_have(|have| have.insert(Look::StartLF));\n665             }\n666             // This is a bit of a tricky case, but if the line terminator was\n667             // set to a word byte, then we also need to behave as if the start\n668             // configuration is Start::WordByte. That is, we need to mark our\n669             // state as having come from a word byte.\n670             if lookset.contains_word() {\n671                 if utf8::is_word_byte(lineterm) {\n672                     builder.set_is_from_word();\n673                 } else {\n674                     builder.set_look_have(|have| {\n675                         have.insert(Look::WordStartHalfAscii)\n676                             .insert(Look::WordStartHalfUnicode)\n677                     });\n678                 }\n679             }\n680         }\n681     }\n682 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}