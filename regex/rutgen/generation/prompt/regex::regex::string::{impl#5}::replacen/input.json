{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/regex/string.rs\n// crate name is regex\npub type Locations = CaptureLocations;\nuse alloc::{borrow::Cow, string::String, sync::Arc};\nuse regex_automata::{meta, util::captures, Input, PatternID};\nuse crate::{error::Error, RegexBuilder};\n#[derive(Clone)]\npub struct Regex {\n    pub(crate) meta: meta::Regex,\n    pub(crate) pattern: Arc<str>,\n}\npub struct Captures<'h> {\n    haystack: &'h str,\n    caps: captures::Captures,\n    static_captures_len: Option<usize>,\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\npub struct Match<'h> {\n    haystack: &'h str,\n    start: usize,\n    end: usize,\n}\n#[derive(Debug)]\npub struct Matches<'r, 'h> {\n    haystack: &'h str,\n    it: meta::FindMatches<'r, 'h>,\n}\n#[derive(Debug)]\npub struct CaptureMatches<'r, 'h> {\n    haystack: &'h str,\n    it: meta::CapturesMatches<'r, 'h>,\n}\n#[derive(Clone)]\npub struct Regex {\n    pub(crate) meta: meta::Regex,\n    pub(crate) pattern: Arc<str>,\n}\nimpl Regex {\n    pub fn new(re: &str) -> Result<Regex, Error> {}\n    #[inline]\n    pub fn is_match(&self, haystack: &str) -> bool {}\n    #[inline]\n    pub fn find<'h>(&self, haystack: &'h str) -> Option<Match<'h>> {}\n    #[inline]\n    pub fn find_iter<'r, 'h>(&'r self, haystack: &'h str) -> Matches<'r, 'h> {\n        Matches {\n            haystack,\n            it: self.meta.find_iter(haystack),\n        }\n    }\n    #[inline]\n    pub fn captures<'h>(&self, haystack: &'h str) -> Option<Captures<'h>> {}\n    #[inline]\n    pub fn captures_iter<'r, 'h>(&'r self, haystack: &'h str) -> CaptureMatches<'r, 'h> {\n        CaptureMatches {\n            haystack,\n            it: self.meta.captures_iter(haystack),\n        }\n    }\n    #[inline]\n    pub fn split<'r, 'h>(&'r self, haystack: &'h str) -> Split<'r, 'h> {}\n    #[inline]\n    pub fn splitn<'r, 'h>(&'r self, haystack: &'h str, limit: usize) -> SplitN<'r, 'h> {}\n    #[inline]\n    pub fn replace<'h, R: Replacer>(&self, haystack: &'h str, rep: R) -> Cow<'h, str> {}\n    #[inline]\n    pub fn replace_all<'h, R: Replacer>(\n        &self,\n        haystack: &'h str,\n        rep: R,\n    ) -> Cow<'h, str> {}\n    #[inline]\n    pub fn replacen<'h, R: Replacer>(\n        &self,\n        haystack: &'h str,\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'h, str> {\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(haystack).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(haystack);\n            }\n            let mut new = String::with_capacity(haystack.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                new.push_str(&haystack[last_match..m.start()]);\n                new.push_str(&rep);\n                last_match = m.end();\n                if limit > 0 && i >= limit - 1 {\n                    break;\n                }\n            }\n            new.push_str(&haystack[last_match..]);\n            return Cow::Owned(new);\n        }\n        let mut it = self.captures_iter(haystack).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(haystack);\n        }\n        let mut new = String::with_capacity(haystack.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            let m = cap.get(0).unwrap();\n            new.push_str(&haystack[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n            if limit > 0 && i >= limit - 1 {\n                break;\n            }\n        }\n        new.push_str(&haystack[last_match..]);\n        Cow::Owned(new)\n    }\n}\nimpl<'h> Captures<'h> {\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<Match<'h>> {\n        self.caps.get_group(i).map(|sp| Match::new(self.haystack, sp.start, sp.end))\n    }\n    #[inline]\n    pub fn name(&self, name: &str) -> Option<Match<'h>> {}\n    pub fn extract<const N: usize>(&self) -> (&'h str, [&'h str; N]) {}\n    #[inline]\n    pub fn expand(&self, replacement: &str, dst: &mut String) {}\n    #[inline]\n    pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> {}\n    #[inline]\n    pub fn len(&self) -> usize {}\n}\nimpl<'h> Match<'h> {\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.end\n    }\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    pub fn len(&self) -> usize {}\n    #[inline]\n    pub fn range(&self) -> core::ops::Range<usize> {}\n    #[inline]\n    pub fn as_str(&self) -> &'h str {}\n    #[inline]\n    fn new(haystack: &'h str, start: usize, end: usize) -> Match<'h> {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Replaces at most `limit` non-overlapping matches in the haystack with\n/// the replacement provided. If `limit` is `0`, then all non-overlapping\n/// matches are replaced. That is, `Regex::replace_all(hay, rep)` is\n/// equivalent to `Regex::replacen(hay, 0, rep)`.\n///\n/// If no match is found, then the haystack is returned unchanged. In that\n/// case, this implementation will likely return a `Cow::Borrowed` value\n/// such that no allocation is performed.\n///\n/// When a `Cow::Borrowed` is returned, the value returned is guaranteed\n/// to be equivalent to the `haystack` given.\n///\n/// The documentation for [`Regex::replace`] goes into more detail about\n/// what kinds of replacement strings are supported.\n///\n/// # Time complexity\n///\n/// Since iterators over all matches requires running potentially many\n/// searches on the haystack, and since each search has worst case\n/// `O(m * n)` time complexity, the overall worst case time complexity for\n/// this routine is `O(m * n^2)`.\n///\n/// Although note that the worst case time here has an upper bound given\n/// by the `limit` parameter.\n///\n/// # Fallibility\n///\n/// See the corresponding section in the docs for [`Regex::replace_all`]\n/// for tips on how to deal with a replacement routine that can fail.\n///\n/// # Example\n///\n/// This example shows how to flip the order of whitespace (excluding line\n/// terminators) delimited fields, and normalizes the whitespace that\n/// delimits the fields. But we only do it for the first two matches.\n///\n/// ```\n/// use regex::Regex;\n///\n/// let re = Regex::new(r\"(?m)^(\\S+)[\\s--\\r\\n]+(\\S+)$\").unwrap();\n/// let hay = \"\n/// Greetings  1973\n/// Wild\\t1973\n/// BornToRun\\t\\t\\t\\t1975\n/// Darkness                    1978\n/// TheRiver 1980\n/// \";\n/// let new = re.replacen(hay, 2, \"$2 $1\");\n/// assert_eq!(new, \"\n/// 1973 Greetings\n/// 1973 Wild\n/// BornToRun\\t\\t\\t\\t1975\n/// Darkness                    1978\n/// TheRiver 1980\n/// \");\n/// ```\n907 pub fn replacen<'h, R: Replacer>(\n908     &self,\n909     haystack: &'h str,\n910     limit: usize,\n911     mut rep: R,\n912 ) -> Cow<'h, str> {\n913     // If we know that the replacement doesn't have any capture expansions,\n914     // then we can use the fast path. The fast path can make a tremendous\n915     // difference:\n916     //\n917     //   1) We use `find_iter` instead of `captures_iter`. Not asking for\n918     //      captures generally makes the regex engines faster.\n919     //   2) We don't need to look up all of the capture groups and do\n920     //      replacements inside the replacement string. We just push it\n921     //      at each match and be done with it.\n922     if let Some(rep) = rep.no_expansion() {\n923         let mut it = self.find_iter(haystack).enumerate().peekable();\n924         if it.peek().is_none() {\n925             return Cow::Borrowed(haystack);\n926         }\n927         let mut new = String::with_capacity(haystack.len());\n928         let mut last_match = 0;\n929         for (i, m) in it {\n930             new.push_str(&haystack[last_match..m.start()]);\n931             new.push_str(&rep);\n932             last_match = m.end();\n933             if limit > 0 && i >= limit - 1 {\n934                 break;\n935             }\n936         }\n937         new.push_str(&haystack[last_match..]);\n938         return Cow::Owned(new);\n939     }\n940 \n941     // The slower path, which we use if the replacement may need access to\n942     // capture groups.\n943     let mut it = self.captures_iter(haystack).enumerate().peekable();\n944     if it.peek().is_none() {\n945         return Cow::Borrowed(haystack);\n946     }\n947     let mut new = String::with_capacity(haystack.len());\n948     let mut last_match = 0;\n949     for (i, cap) in it {\n950         // unwrap on 0 is OK because captures only reports matches\n951         let m = cap.get(0).unwrap();\n952         new.push_str(&haystack[last_match..m.start()]);\n953         rep.replace_append(&cap, &mut new);\n954         last_match = m.end();\n955         if limit > 0 && i >= limit - 1 {\n956             break;\n957         }\n958     }\n959     new.push_str(&haystack[last_match..]);\n960     Cow::Owned(new)\n961 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}