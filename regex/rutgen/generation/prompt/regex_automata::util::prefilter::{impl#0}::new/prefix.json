{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines, focusing solely on constructing test inputs and calling the functions under test:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions, and reference the inferred test input conditions or ranges.\n7. Ensure the test inputs are designed to cover the inferred test input conditions or ranges as comprehensively as possible, with particular emphasis on boundary cases.\n8. Focus on crafting test inputs that effectively reveal potential bugs while meeting the specified requirements.\n9. Omit test oracles and assertions; concentrate on generating test inputs and function calls.\n10. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/util/prefilter/mod.rs\n// crate name is regex_automata\nuse core::{borrow::Borrow, fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\n#[cfg(feature = \"alloc\")]\nuse alloc::sync::Arc;\n#[cfg(feature = \"syntax\")]\nuse regex_syntax::hir::{literal, Hir};\nuse crate::util::search::{MatchKind, Span};\npub(crate) use crate::util::prefilter::{\n    aho_corasick::AhoCorasick, byteset::ByteSet, memchr::{Memchr, Memchr2, Memchr3},\n    memmem::Memmem, teddy::Teddy,\n};\npub(crate) trait PrefilterI: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn find(&self, haystack: &[u8], span: Span) -> Option<Span>;\n    fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span>;\n    fn memory_usage(&self) -> usize;\n    fn is_fast(&self) -> bool;\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Debug)]\npub(crate) enum Choice {\n    Memchr(Memchr),\n    Memchr2(Memchr2),\n    Memchr3(Memchr3),\n    Memmem(Memmem),\n    Teddy(Teddy),\n    ByteSet(ByteSet),\n    AhoCorasick(AhoCorasick),\n}\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum MatchKind {\n    /// Report all possible matches.\n    All,\n    /// Report only the leftmost matches. When multiple leftmost matches exist,\n    /// report the match corresponding to the part of the regex that appears\n    /// first in the syntax.\n    LeftmostFirst,\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {\n        Choice::new(kind, needles)\n            .and_then(|choice| {\n                let max_needle_len = needles\n                    .iter()\n                    .map(|b| b.as_ref().len())\n                    .max()\n                    .unwrap_or(0);\n                Prefilter::from_choice(choice, max_needle_len)\n            })\n    }\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {}\n}\nimpl Choice {\n    pub(crate) fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Choice> {\n        if needles.len() == 0 {\n            debug!(\"prefilter building failed: found empty set of literals\");\n            return None;\n        }\n        if needles.iter().any(|n| n.as_ref().is_empty()) {\n            debug!(\"prefilter building failed: literals match empty string\");\n            return None;\n        }\n        if let Some(pre) = Memchr::new(kind, needles) {\n            debug!(\"prefilter built: memchr\");\n            return Some(Choice::Memchr(pre));\n        }\n        if let Some(pre) = Memchr2::new(kind, needles) {\n            debug!(\"prefilter built: memchr2\");\n            return Some(Choice::Memchr2(pre));\n        }\n        if let Some(pre) = Memchr3::new(kind, needles) {\n            debug!(\"prefilter built: memchr3\");\n            return Some(Choice::Memchr3(pre));\n        }\n        if let Some(pre) = Memmem::new(kind, needles) {\n            debug!(\"prefilter built: memmem\");\n            return Some(Choice::Memmem(pre));\n        }\n        if let Some(pre) = Teddy::new(kind, needles) {\n            debug!(\"prefilter built: teddy\");\n            return Some(Choice::Teddy(pre));\n        }\n        if let Some(pre) = ByteSet::new(kind, needles) {\n            debug!(\"prefilter built: byteset\");\n            return Some(Choice::ByteSet(pre));\n        }\n        if let Some(pre) = AhoCorasick::new(kind, needles) {\n            debug!(\"prefilter built: aho-corasick\");\n            return Some(Choice::AhoCorasick(pre));\n        }\n        debug!(\"prefilter building failed: no strategy could be found\");\n        None\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Create a new prefilter from a sequence of needles and a corresponding\n/// match semantics.\n///\n/// This may return `None` for a variety of reasons, for example, if\n/// a suitable prefilter could not be constructed. That might occur\n/// if they are unavailable (e.g., the `perf-literal-substring` and\n/// `perf-literal-multisubstring` features aren't enabled), or it might\n/// occur because of heuristics or other artifacts of how the prefilter\n/// works.\n///\n/// Note that if you have an [`Hir`] expression, it may be more convenient\n/// to use [`Prefilter::from_hir_prefix`]. It will automatically handle the\n/// task of extracting prefix literals for you.\n///\n/// # Example\n///\n/// This example shows how match semantics can impact the matching\n/// algorithm used by the prefilter. For this reason, it is important to\n/// ensure that the match semantics given here are consistent with the\n/// match semantics intended for the regular expression that the literals\n/// were extracted from.\n///\n/// ```\n/// use regex_automata::{\n///     util::{prefilter::Prefilter, syntax},\n///     MatchKind, Span,\n/// };\n///\n/// let hay = \"Hello samwise\";\n///\n/// // With leftmost-first, we find 'samwise' here because it comes\n/// // before 'sam' in the sequence we give it..\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"samwise\", \"sam\"])\n///     .expect(\"a prefilter\");\n/// assert_eq!(\n///     Some(Span::from(6..13)),\n///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),\n/// );\n/// // Still with leftmost-first but with the literals reverse, now 'sam'\n/// // will match instead!\n/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &[\"sam\", \"samwise\"])\n///     .expect(\"a prefilter\");\n/// assert_eq!(\n///     Some(Span::from(6..9)),\n///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),\n/// );\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n203 pub fn new<B: AsRef<[u8]>>(\n204     kind: MatchKind,\n205     needles: &[B],\n206 ) -> Option<Prefilter> {\n207     Choice::new(kind, needles).and_then(|choice| {\n208         let max_needle_len =\n209             needles.iter().map(|b| b.as_ref().len()).max().unwrap_or(0);\n210         Prefilter::from_choice(choice, max_needle_len)\n211     })\n212 }\n\nGenerate each test function in such a manner that it concurrently satisfies all the following preconditions:\n",
  "depend_pt": ""
}