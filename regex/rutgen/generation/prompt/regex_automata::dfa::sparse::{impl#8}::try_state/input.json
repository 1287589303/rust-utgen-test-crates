{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/sparse.rs\n// crate name is regex_automata\n#[cfg(feature = \"dfa-build\")]\nuse core::iter;\nuse core::{fmt, mem::size_of};\n#[cfg(feature = \"dfa-build\")]\nuse alloc::{vec, vec::Vec};\n#[cfg(feature = \"dfa-build\")]\nuse crate::dfa::dense::{self, BuildError};\nuse crate::{\n    dfa::{\n        automaton::{fmt_state_indicator, Automaton, StartError},\n        dense::Flags, special::Special, StartKind, DEAD,\n    },\n    util::{\n        alphabet::{ByteClasses, ByteSet},\n        escape::DebugByte, int::{Pointer, Usize, U16, U32},\n        prefilter::Prefilter, primitives::{PatternID, StateID},\n        search::Anchored, start::{self, Start, StartByteMap},\n        wire::{self, DeserializeError, Endian, SerializeError},\n    },\n};\nconst LABEL: &str = \"rust-regex-automata-dfa-sparse\";\nconst VERSION: u32 = 2;\n#[derive(Clone)]\nstruct Transitions<T> {\n    /// The raw encoding of each state in this DFA.\n    ///\n    /// Each state has the following information:\n    ///\n    /// * A set of transitions to subsequent states. Transitions to the dead\n    ///   state are omitted.\n    /// * If the state can be accelerated, then any additional accelerator\n    ///   information.\n    /// * If the state is a match state, then the state contains all pattern\n    ///   IDs that match when in that state.\n    ///\n    /// To decode a state, use Transitions::state.\n    ///\n    /// In practice, T is either Vec<u8> or &[u8].\n    sparse: T,\n    /// A set of equivalence classes, where a single equivalence class\n    /// represents a set of bytes that never discriminate between a match\n    /// and a non-match in the DFA. Each equivalence class corresponds to a\n    /// single character in this DFA's alphabet, where the maximum number of\n    /// characters is 257 (each possible value of a byte plus the special\n    /// EOI transition). Consequently, the number of equivalence classes\n    /// corresponds to the number of transitions for each DFA state. Note\n    /// though that the *space* used by each DFA state in the transition table\n    /// may be larger. The total space used by each DFA state is known as the\n    /// stride and is documented above.\n    ///\n    /// The only time the number of equivalence classes is fewer than 257 is\n    /// if the DFA's kind uses byte classes which is the default. Equivalence\n    /// classes should generally only be disabled when debugging, so that\n    /// the transitions themselves aren't obscured. Disabling them has no\n    /// other benefit, since the equivalence class map is always used while\n    /// searching. In the vast majority of cases, the number of equivalence\n    /// classes is substantially smaller than 257, particularly when large\n    /// Unicode classes aren't used.\n    ///\n    /// N.B. Equivalence classes aren't particularly useful in a sparse DFA\n    /// in the current implementation, since equivalence classes generally tend\n    /// to correspond to continuous ranges of bytes that map to the same\n    /// transition. So in a sparse DFA, equivalence classes don't really lead\n    /// to a space savings. In the future, it would be good to try and remove\n    /// them from sparse DFAs entirely, but requires a bit of work since sparse\n    /// DFAs are built from dense DFAs, which are in turn built on top of\n    /// equivalence classes.\n    classes: ByteClasses,\n    /// The total number of states in this DFA. Note that a DFA always has at\n    /// least one state---the dead state---even the empty DFA. In particular,\n    /// the dead state always has ID 0 and is correspondingly always the first\n    /// state. The dead state is never a match state.\n    state_len: usize,\n    /// The total number of unique patterns represented by these match states.\n    pattern_len: usize,\n}\n#[derive(Clone)]\nstruct State<'a> {\n    /// The identifier of this state.\n    id: StateID,\n    /// Whether this is a match state or not.\n    is_match: bool,\n    /// The number of transitions in this state.\n    ntrans: usize,\n    /// Pairs of input ranges, where there is one pair for each transition.\n    /// Each pair specifies an inclusive start and end byte range for the\n    /// corresponding transition.\n    input_ranges: &'a [u8],\n    /// Transitions to the next state. This slice contains native endian\n    /// encoded state identifiers, with `S` as the representation. Thus, there\n    /// are `ntrans * size_of::<S>()` bytes in this slice.\n    next: &'a [u8],\n    /// If this is a match state, then this contains the pattern IDs that match\n    /// when the DFA is in this state.\n    ///\n    /// This is a contiguous sequence of 32-bit native endian encoded integers.\n    pattern_ids: &'a [u8],\n    /// An accelerator for this state, if present. If this state has no\n    /// accelerator, then this is an empty slice. When non-empty, this slice\n    /// has length at most 3 and corresponds to the exhaustive set of bytes\n    /// that must be seen in order to transition out of this state.\n    accel: &'a [u8],\n}\n#[derive(Debug)]\npub struct DeserializeError(DeserializeErrorKind);\n#[derive(Clone, Copy, Debug)]\npub(crate) struct Special {\n    /// The identifier of the last special state in a DFA. A state is special\n    /// if and only if its identifier is less than or equal to `max`.\n    pub(crate) max: StateID,\n    /// The identifier of the quit state in a DFA. (There is no analogous field\n    /// for the dead state since the dead state's ID is always zero, regardless\n    /// of state ID size.)\n    pub(crate) quit_id: StateID,\n    /// The identifier of the first match state.\n    pub(crate) min_match: StateID,\n    /// The identifier of the last match state.\n    pub(crate) max_match: StateID,\n    /// The identifier of the first accelerated state.\n    pub(crate) min_accel: StateID,\n    /// The identifier of the last accelerated state.\n    pub(crate) max_accel: StateID,\n    /// The identifier of the first start state.\n    pub(crate) min_start: StateID,\n    /// The identifier of the last start state.\n    pub(crate) max_start: StateID,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy)]\npub struct ByteClasses([u8; 256]);\nimpl<T: AsRef<[u8]>> Transitions<T> {\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n    fn validate(&self, sp: &Special) -> Result<Seen, DeserializeError> {}\n    fn as_ref(&self) -> Transitions<&'_ [u8]> {}\n    #[cfg(feature = \"alloc\")]\n    fn to_owned(&self) -> Transitions<alloc::vec::Vec<u8>> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn state(&self, id: StateID) -> State<'_> {}\n    fn try_state(\n        &self,\n        sp: &Special,\n        id: StateID,\n    ) -> Result<State<'_>, DeserializeError> {\n        if id.as_usize() > self.sparse().len() {\n            return Err(\n                DeserializeError::generic(\"invalid caller provided sparse state ID\"),\n            );\n        }\n        let mut state = &self.sparse()[id.as_usize()..];\n        let (mut ntrans, _) = wire::try_read_u16_as_usize(\n            state,\n            \"state transition length\",\n        )?;\n        let is_match = ((1 << 15) & ntrans) != 0;\n        ntrans &= !(1 << 15);\n        state = &state[2..];\n        if ntrans > 257 || ntrans == 0 {\n            return Err(DeserializeError::generic(\"invalid transition length\"));\n        }\n        if is_match && !sp.is_match_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"state marked as match but not in match ID range\",\n                ),\n            );\n        } else if !is_match && sp.is_match_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"state in match ID range but not marked as match state\",\n                ),\n            );\n        }\n        let input_ranges_len = ntrans.checked_mul(2).unwrap();\n        wire::check_slice_len(state, input_ranges_len, \"sparse byte pairs\")?;\n        let (input_ranges, state) = state.split_at(input_ranges_len);\n        for pair in input_ranges.chunks(2) {\n            let (start, end) = (pair[0], pair[1]);\n            if start > end {\n                return Err(DeserializeError::generic(\"invalid input range\"));\n            }\n        }\n        let next_len = ntrans\n            .checked_mul(self.id_len())\n            .expect(\"state size * #trans should always fit in a usize\");\n        wire::check_slice_len(state, next_len, \"sparse trans state IDs\")?;\n        let (next, state) = state.split_at(next_len);\n        for idbytes in next.chunks(self.id_len()) {\n            let (id, _) = wire::read_state_id(idbytes, \"sparse state ID in try_state\")?;\n            wire::check_slice_len(\n                self.sparse(),\n                id.as_usize(),\n                \"invalid sparse state ID\",\n            )?;\n        }\n        let (pattern_ids, state) = if is_match {\n            let (npats, nr) = wire::try_read_u32_as_usize(state, \"pattern ID length\")?;\n            let state = &state[nr..];\n            if npats == 0 {\n                return Err(\n                    DeserializeError::generic(\n                        \"state marked as a match, but pattern length is zero\",\n                    ),\n                );\n            }\n            let pattern_ids_len = wire::mul(npats, 4, \"sparse pattern ID byte length\")?;\n            wire::check_slice_len(state, pattern_ids_len, \"sparse pattern IDs\")?;\n            let (pattern_ids, state) = state.split_at(pattern_ids_len);\n            for patbytes in pattern_ids.chunks(PatternID::SIZE) {\n                wire::read_pattern_id(patbytes, \"sparse pattern ID in try_state\")?;\n            }\n            (pattern_ids, state)\n        } else {\n            (&[][..], state)\n        };\n        if is_match && pattern_ids.is_empty() {\n            return Err(\n                DeserializeError::generic(\n                    \"state marked as a match, but has no pattern IDs\",\n                ),\n            );\n        }\n        if sp.is_match_state(id) && pattern_ids.is_empty() {\n            return Err(\n                DeserializeError::generic(\n                    \"state marked special as a match, but has no pattern IDs\",\n                ),\n            );\n        }\n        if sp.is_match_state(id) != is_match {\n            return Err(\n                DeserializeError::generic(\n                    \"whether state is a match or not is inconsistent\",\n                ),\n            );\n        }\n        if state.is_empty() {\n            return Err(DeserializeError::generic(\"no accelerator length\"));\n        }\n        let (accel_len, state) = (usize::from(state[0]), &state[1..]);\n        if accel_len > 3 {\n            return Err(DeserializeError::generic(\"sparse invalid accelerator length\"));\n        } else if accel_len == 0 && sp.is_accel_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"got no accelerators in state, but in accelerator ID range\",\n                ),\n            );\n        } else if accel_len > 0 && !sp.is_accel_state(id) {\n            return Err(\n                DeserializeError::generic(\n                    \"state in accelerator ID range, but has no accelerators\",\n                ),\n            );\n        }\n        wire::check_slice_len(state, accel_len, \"sparse corrupt accelerator length\")?;\n        let (accel, _) = (&state[..accel_len], &state[accel_len..]);\n        let state = State {\n            id,\n            is_match,\n            ntrans,\n            input_ranges,\n            next,\n            pattern_ids,\n            accel,\n        };\n        if sp.is_quit_state(state.next_at(state.ntrans - 1)) {\n            return Err(\n                DeserializeError::generic(\n                    \"state with EOI transition to quit state is illegal\",\n                ),\n            );\n        }\n        Ok(state)\n    }\n    fn states(&self) -> StateIter<'_, T> {}\n    fn sparse(&self) -> &[u8] {\n        self.sparse.as_ref()\n    }\n    fn id_len(&self) -> usize {\n        StateID::SIZE\n    }\n    fn memory_usage(&self) -> usize {}\n}\nimpl<'a> State<'a> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn next(&self, input: u8) -> StateID {}\n    fn next_eoi(&self) -> StateID {}\n    fn id(&self) -> StateID {}\n    fn range(&self, i: usize) -> (u8, u8) {}\n    fn next_at(&self, i: usize) -> StateID {\n        let start = i * StateID::SIZE;\n        let end = start + StateID::SIZE;\n        let bytes = self.next[start..end].try_into().unwrap();\n        StateID::from_ne_bytes_unchecked(bytes)\n    }\n    fn pattern_id(&self, match_index: usize) -> PatternID {}\n    fn pattern_len(&self) -> usize {}\n    fn accelerator(&self) -> &'a [u8] {}\n    fn write_to<E: Endian>(&self, mut dst: &mut [u8]) -> Result<usize, SerializeError> {}\n    fn write_to_len(&self) -> usize {}\n}\nimpl DeserializeError {\n    pub(crate) fn generic(msg: &'static str) -> DeserializeError {\n        DeserializeError(DeserializeErrorKind::Generic {\n            msg,\n        })\n    }\n    pub(crate) fn buffer_too_small(what: &'static str) -> DeserializeError {}\n    fn invalid_usize(what: &'static str) -> DeserializeError {}\n    fn version_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn endian_mismatch(expected: u32, found: u32) -> DeserializeError {}\n    fn alignment_mismatch(alignment: usize, address: usize) -> DeserializeError {}\n    fn label_mismatch(expected: &'static str) -> DeserializeError {}\n    fn arithmetic_overflow(what: &'static str) -> DeserializeError {}\n    fn pattern_id_error(err: PatternIDError, what: &'static str) -> DeserializeError {}\n    pub(crate) fn state_id_error(\n        err: StateIDError,\n        what: &'static str,\n    ) -> DeserializeError {}\n}\nimpl Special {\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn new() -> Special {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {}\n    pub(crate) fn from_bytes(\n        mut slice: &[u8],\n    ) -> Result<(Special, usize), DeserializeError> {}\n    pub(crate) fn validate(&self) -> Result<(), DeserializeError> {}\n    pub(crate) fn validate_state_len(\n        &self,\n        len: usize,\n        stride2: usize,\n    ) -> Result<(), DeserializeError> {}\n    pub(crate) fn write_to<E: Endian>(\n        &self,\n        dst: &mut [u8],\n    ) -> Result<usize, SerializeError> {}\n    pub(crate) fn write_to_len(&self) -> usize {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_max(&mut self) {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn set_no_special_start_states(&mut self) {}\n    #[inline]\n    pub(crate) fn is_special_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_dead_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn is_quit_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.quit_id == id\n    }\n    #[inline]\n    pub(crate) fn is_match_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_match <= id && id <= self.max_match\n    }\n    #[inline]\n    pub(crate) fn is_accel_state(&self, id: StateID) -> bool {\n        !self.is_dead_state(id) && self.min_accel <= id && id <= self.max_accel\n    }\n    #[inline]\n    pub(crate) fn is_start_state(&self, id: StateID) -> bool {}\n    #[inline]\n    pub(crate) fn match_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn matches(&self) -> bool {}\n    #[cfg(feature = \"dfa-build\")]\n    pub(crate) fn accel_len(&self, stride: usize) -> usize {}\n    #[inline]\n    pub(crate) fn accels(&self) -> bool {}\n    #[inline]\n    pub(crate) fn starts(&self) -> bool {}\n}\npub(crate) fn check_slice_len<T>(\n    slice: &[T],\n    at_least_len: usize,\n    what: &'static str,\n) -> Result<(), DeserializeError> {\n    if slice.len() < at_least_len {\n        return Err(DeserializeError::buffer_too_small(what));\n    }\n    Ok(())\n}\npub(crate) fn try_read_u16_as_usize(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(usize, usize), DeserializeError> {\n    try_read_u16(slice, what)\n        .and_then(|(n, nr)| {\n            usize::try_from(n)\n                .map(|n| (n, nr))\n                .map_err(|_| DeserializeError::invalid_usize(what))\n        })\n}\npub(crate) fn try_read_u32_as_usize(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(usize, usize), DeserializeError> {\n    try_read_u32(slice, what)\n        .and_then(|(n, nr)| {\n            usize::try_from(n)\n                .map(|n| (n, nr))\n                .map_err(|_| DeserializeError::invalid_usize(what))\n        })\n}\npub(crate) fn mul(\n    a: usize,\n    b: usize,\n    what: &'static str,\n) -> Result<usize, DeserializeError> {\n    match a.checked_mul(b) {\n        Some(c) => Ok(c),\n        None => Err(DeserializeError::arithmetic_overflow(what)),\n    }\n}\npub(crate) fn read_pattern_id(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(PatternID, usize), DeserializeError> {\n    let bytes: [u8; PatternID::SIZE] = slice[..PatternID::SIZE].try_into().unwrap();\n    let pid = PatternID::from_ne_bytes(bytes)\n        .map_err(|err| DeserializeError::pattern_id_error(err, what))?;\n    Ok((pid, PatternID::SIZE))\n}\npub(crate) fn read_state_id(\n    slice: &[u8],\n    what: &'static str,\n) -> Result<(StateID, usize), DeserializeError> {\n    let bytes: [u8; StateID::SIZE] = slice[..StateID::SIZE].try_into().unwrap();\n    let sid = StateID::from_ne_bytes(bytes)\n        .map_err(|err| DeserializeError::state_id_error(err, what))?;\n    Ok((sid, StateID::SIZE))\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Like `state`, but will return an error if the state encoding is\n/// invalid. This is useful for verifying states after deserialization,\n/// which is required for a safe deserialization API.\n///\n/// Note that this only verifies that this state is decodable and that\n/// all of its data is consistent. It does not verify that its state ID\n/// transitions point to valid states themselves, nor does it verify that\n/// every pattern ID is valid.\n1528 fn try_state(\n1529     &self,\n1530     sp: &Special,\n1531     id: StateID,\n1532 ) -> Result<State<'_>, DeserializeError> {\n1533     if id.as_usize() > self.sparse().len() {\n1534         return Err(DeserializeError::generic(\n1535             \"invalid caller provided sparse state ID\",\n1536         ));\n1537     }\n1538     let mut state = &self.sparse()[id.as_usize()..];\n1539     // Encoding format starts with a u16 that stores the total number of\n1540     // transitions in this state.\n1541     let (mut ntrans, _) =\n1542         wire::try_read_u16_as_usize(state, \"state transition length\")?;\n1543     let is_match = ((1 << 15) & ntrans) != 0;\n1544     ntrans &= !(1 << 15);\n1545     state = &state[2..];\n1546     if ntrans > 257 || ntrans == 0 {\n1547         return Err(DeserializeError::generic(\n1548             \"invalid transition length\",\n1549         ));\n1550     }\n1551     if is_match && !sp.is_match_state(id) {\n1552         return Err(DeserializeError::generic(\n1553             \"state marked as match but not in match ID range\",\n1554         ));\n1555     } else if !is_match && sp.is_match_state(id) {\n1556         return Err(DeserializeError::generic(\n1557             \"state in match ID range but not marked as match state\",\n1558         ));\n1559     }\n1560 \n1561     // Each transition has two pieces: an inclusive range of bytes on which\n1562     // it is defined, and the state ID that those bytes transition to. The\n1563     // pairs come first, followed by a corresponding sequence of state IDs.\n1564     let input_ranges_len = ntrans.checked_mul(2).unwrap();\n1565     wire::check_slice_len(state, input_ranges_len, \"sparse byte pairs\")?;\n1566     let (input_ranges, state) = state.split_at(input_ranges_len);\n1567     // Every range should be of the form A-B, where A<=B.\n1568     for pair in input_ranges.chunks(2) {\n1569         let (start, end) = (pair[0], pair[1]);\n1570         if start > end {\n1571             return Err(DeserializeError::generic(\"invalid input range\"));\n1572         }\n1573     }\n1574 \n1575     // And now extract the corresponding sequence of state IDs. We leave\n1576     // this sequence as a &[u8] instead of a &[S] because sparse DFAs do\n1577     // not have any alignment requirements.\n1578     let next_len = ntrans\n1579         .checked_mul(self.id_len())\n1580         .expect(\"state size * #trans should always fit in a usize\");\n1581     wire::check_slice_len(state, next_len, \"sparse trans state IDs\")?;\n1582     let (next, state) = state.split_at(next_len);\n1583     // We can at least verify that every state ID is in bounds.\n1584     for idbytes in next.chunks(self.id_len()) {\n1585         let (id, _) =\n1586             wire::read_state_id(idbytes, \"sparse state ID in try_state\")?;\n1587         wire::check_slice_len(\n1588             self.sparse(),\n1589             id.as_usize(),\n1590             \"invalid sparse state ID\",\n1591         )?;\n1592     }\n1593 \n1594     // If this is a match state, then read the pattern IDs for this state.\n1595     // Pattern IDs is a u32-length prefixed sequence of native endian\n1596     // encoded 32-bit integers.\n1597     let (pattern_ids, state) = if is_match {\n1598         let (npats, nr) =\n1599             wire::try_read_u32_as_usize(state, \"pattern ID length\")?;\n1600         let state = &state[nr..];\n1601         if npats == 0 {\n1602             return Err(DeserializeError::generic(\n1603                 \"state marked as a match, but pattern length is zero\",\n1604             ));\n1605         }\n1606 \n1607         let pattern_ids_len =\n1608             wire::mul(npats, 4, \"sparse pattern ID byte length\")?;\n1609         wire::check_slice_len(\n1610             state,\n1611             pattern_ids_len,\n1612             \"sparse pattern IDs\",\n1613         )?;\n1614         let (pattern_ids, state) = state.split_at(pattern_ids_len);\n1615         for patbytes in pattern_ids.chunks(PatternID::SIZE) {\n1616             wire::read_pattern_id(\n1617                 patbytes,\n1618                 \"sparse pattern ID in try_state\",\n1619             )?;\n1620         }\n1621         (pattern_ids, state)\n1622     } else {\n1623         (&[][..], state)\n1624     };\n1625     if is_match && pattern_ids.is_empty() {\n1626         return Err(DeserializeError::generic(\n1627             \"state marked as a match, but has no pattern IDs\",\n1628         ));\n1629     }\n1630     if sp.is_match_state(id) && pattern_ids.is_empty() {\n1631         return Err(DeserializeError::generic(\n1632             \"state marked special as a match, but has no pattern IDs\",\n1633         ));\n1634     }\n1635     if sp.is_match_state(id) != is_match {\n1636         return Err(DeserializeError::generic(\n1637             \"whether state is a match or not is inconsistent\",\n1638         ));\n1639     }\n1640 \n1641     // Now read this state's accelerator info. The first byte is the length\n1642     // of the accelerator, which is typically 0 (for no acceleration) but\n1643     // is no bigger than 3. The length indicates the number of bytes that\n1644     // follow, where each byte corresponds to a transition out of this\n1645     // state.\n1646     if state.is_empty() {\n1647         return Err(DeserializeError::generic(\"no accelerator length\"));\n1648     }\n1649     let (accel_len, state) = (usize::from(state[0]), &state[1..]);\n1650 \n1651     if accel_len > 3 {\n1652         return Err(DeserializeError::generic(\n1653             \"sparse invalid accelerator length\",\n1654         ));\n1655     } else if accel_len == 0 && sp.is_accel_state(id) {\n1656         return Err(DeserializeError::generic(\n1657             \"got no accelerators in state, but in accelerator ID range\",\n1658         ));\n1659     } else if accel_len > 0 && !sp.is_accel_state(id) {\n1660         return Err(DeserializeError::generic(\n1661             \"state in accelerator ID range, but has no accelerators\",\n1662         ));\n1663     }\n1664 \n1665     wire::check_slice_len(\n1666         state,\n1667         accel_len,\n1668         \"sparse corrupt accelerator length\",\n1669     )?;\n1670     let (accel, _) = (&state[..accel_len], &state[accel_len..]);\n1671 \n1672     let state = State {\n1673         id,\n1674         is_match,\n1675         ntrans,\n1676         input_ranges,\n1677         next,\n1678         pattern_ids,\n1679         accel,\n1680     };\n1681     if sp.is_quit_state(state.next_at(state.ntrans - 1)) {\n1682         return Err(DeserializeError::generic(\n1683             \"state with EOI transition to quit state is illegal\",\n1684         ));\n1685     }\n1686     Ok(state)\n1687 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}