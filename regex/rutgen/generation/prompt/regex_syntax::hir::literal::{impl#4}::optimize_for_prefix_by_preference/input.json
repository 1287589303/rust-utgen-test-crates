{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/literal.rs\n// crate name is regex_syntax\nuse core::{cmp, mem, num::NonZeroUsize};\nuse alloc::{vec, vec::Vec};\nuse crate::hir::{self, Hir};\n#[derive(Clone, Eq, PartialEq)]\npub struct Seq {\n    /// The members of this seq.\n    ///\n    /// When `None`, the seq represents all possible literals. That is, it\n    /// prevents one from making assumptions about specific literals in the\n    /// seq, and forces one to treat it as if any literal might be in the seq.\n    ///\n    /// Note that `Some(vec![])` is valid and corresponds to the empty seq of\n    /// literals, i.e., a regex that can never match. For example, `[a&&b]`.\n    /// It is distinct from `Some(vec![\"\"])`, which corresponds to the seq\n    /// containing an empty string, which matches at every position.\n    literals: Option<Vec<Literal>>,\n}\n#[derive(Clone, Eq, PartialEq, PartialOrd, Ord)]\npub struct Literal {\n    bytes: Vec<u8>,\n    exact: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n#[derive(Clone, Eq, PartialEq)]\npub struct Literal(pub Box<[u8]>);\nimpl Seq {\n    #[inline]\n    pub fn empty() -> Seq {}\n    #[inline]\n    pub fn infinite() -> Seq {}\n    #[inline]\n    pub fn singleton(lit: Literal) -> Seq {}\n    #[inline]\n    pub fn new<I, B>(it: I) -> Seq\n    where\n        I: IntoIterator<Item = B>,\n        B: AsRef<[u8]>,\n    {}\n    #[inline]\n    pub fn literals(&self) -> Option<&[Literal]> {}\n    #[inline]\n    pub fn push(&mut self, lit: Literal) {}\n    #[inline]\n    pub fn make_inexact(&mut self) {}\n    #[inline]\n    pub fn make_infinite(&mut self) {}\n    #[inline]\n    pub fn cross_forward(&mut self, other: &mut Seq) {}\n    #[inline]\n    pub fn cross_reverse(&mut self, other: &mut Seq) {}\n    fn cross_preamble<'a>(\n        &'a mut self,\n        other: &'a mut Seq,\n    ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)> {}\n    #[inline]\n    pub fn union(&mut self, other: &mut Seq) {}\n    #[inline]\n    pub fn union_into_empty(&mut self, other: &mut Seq) {}\n    #[inline]\n    pub fn dedup(&mut self) {}\n    #[inline]\n    pub fn sort(&mut self) {}\n    #[inline]\n    pub fn reverse_literals(&mut self) {}\n    #[inline]\n    pub fn minimize_by_preference(&mut self) {}\n    #[inline]\n    pub fn keep_first_bytes(&mut self, len: usize) {}\n    #[inline]\n    pub fn keep_last_bytes(&mut self, len: usize) {}\n    #[inline]\n    pub fn is_finite(&self) -> bool {}\n    #[inline]\n    pub fn is_empty(&self) -> bool {}\n    #[inline]\n    pub fn len(&self) -> Option<usize> {}\n    #[inline]\n    pub fn is_exact(&self) -> bool {}\n    #[inline]\n    pub fn is_inexact(&self) -> bool {}\n    #[inline]\n    pub fn max_union_len(&self, other: &Seq) -> Option<usize> {}\n    #[inline]\n    pub fn max_cross_len(&self, other: &Seq) -> Option<usize> {}\n    #[inline]\n    pub fn min_literal_len(&self) -> Option<usize> {}\n    #[inline]\n    pub fn max_literal_len(&self) -> Option<usize> {}\n    #[inline]\n    pub fn longest_common_prefix(&self) -> Option<&[u8]> {}\n    #[inline]\n    pub fn longest_common_suffix(&self) -> Option<&[u8]> {}\n    #[inline]\n    pub fn optimize_for_prefix_by_preference(&mut self) {\n        self.optimize_by_preference(true);\n    }\n    #[inline]\n    pub fn optimize_for_suffix_by_preference(&mut self) {}\n    fn optimize_by_preference(&mut self, prefix: bool) {\n        let origlen = match self.len() {\n            None => return,\n            Some(len) => len,\n        };\n        if self.min_literal_len().map_or(false, |len| len == 0) {\n            self.make_infinite();\n            return;\n        }\n        if prefix {\n            if let Some(ref mut lits) = self.literals {\n                PreferenceTrie::minimize(lits, true);\n            }\n        }\n        let fix = if prefix {\n            self.longest_common_prefix()\n        } else {\n            self.longest_common_suffix()\n        };\n        if let Some(fix) = fix {\n            if prefix && origlen > 1 && fix.len() >= 1 && fix.len() <= 3\n                && rank(fix[0]) < 200\n            {\n                self.keep_first_bytes(1);\n                self.dedup();\n                return;\n            }\n            let isfast = self.is_exact() && self.len().map_or(false, |len| len <= 16);\n            let usefix = fix.len() > 4 || (fix.len() > 1 && !isfast);\n            if usefix {\n                if prefix {\n                    self.keep_first_bytes(fix.len());\n                } else {\n                    self.keep_last_bytes(fix.len());\n                }\n                self.dedup();\n                assert_eq!(Some(1), self.len());\n            }\n        }\n        let exact: Option<Seq> = if self.is_exact() { Some(self.clone()) } else { None };\n        const ATTEMPTS: [(usize, usize); 5] = [\n            (5, 10),\n            (4, 10),\n            (3, 64),\n            (2, 64),\n            (1, 10),\n        ];\n        for (keep, limit) in ATTEMPTS {\n            let len = match self.len() {\n                None => break,\n                Some(len) => len,\n            };\n            if len <= limit {\n                break;\n            }\n            if prefix {\n                self.keep_first_bytes(keep);\n            } else {\n                self.keep_last_bytes(keep);\n            }\n            if prefix {\n                if let Some(ref mut lits) = self.literals {\n                    PreferenceTrie::minimize(lits, true);\n                }\n            }\n        }\n        if let Some(lits) = self.literals() {\n            if lits.iter().any(|lit| lit.is_poisonous()) {\n                self.make_infinite();\n            }\n        }\n        if let Some(exact) = exact {\n            if !self.is_finite() {\n                *self = exact;\n                return;\n            }\n            if self.min_literal_len().map_or(true, |len| len <= 2) {\n                *self = exact;\n                return;\n            }\n            if self.len().map_or(true, |len| len > 64) {\n                *self = exact;\n                return;\n            }\n        }\n    }\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Optimizes this seq while treating its literals as prefixes and\n/// respecting the preference order of its literals.\n///\n/// The specific way \"optimization\" works is meant to be an implementation\n/// detail, as it essentially represents a set of heuristics. The goal\n/// that optimization tries to accomplish is to make the literals in this\n/// set reflect inputs that will result in a more effective prefilter.\n/// Principally by reducing the false positive rate of candidates found by\n/// the literals in this sequence. That is, when a match of a literal is\n/// found, we would like it to be a strong predictor of the overall match\n/// of the regex. If it isn't, then much time will be spent starting and\n/// stopping the prefilter search and attempting to confirm the match only\n/// to have it fail.\n///\n/// Some of those heuristics might be:\n///\n/// * Identifying a common prefix from a larger sequence of literals, and\n/// shrinking the sequence down to that single common prefix.\n/// * Rejecting the sequence entirely if it is believed to result in very\n/// high false positive rate. When this happens, the sequence is made\n/// infinite.\n/// * Shrinking the sequence to a smaller number of literals representing\n/// prefixes, but not shrinking it so much as to make literals too short.\n/// (A sequence with very short literals, of 1 or 2 bytes, will typically\n/// result in a higher false positive rate.)\n///\n/// Optimization should only be run once extraction is complete. Namely,\n/// optimization may make assumptions that do not compose with other\n/// operations in the middle of extraction. For example, optimization will\n/// reduce `[E(sam), E(samwise)]` to `[E(sam)]`, but such a transformation\n/// is only valid if no other extraction will occur. If other extraction\n/// may occur, then the correct transformation would be to `[I(sam)]`.\n///\n/// The [`Seq::optimize_for_suffix_by_preference`] does the same thing, but\n/// for suffixes.\n///\n/// # Example\n///\n/// This shows how optimization might transform a sequence. Note that\n/// the specific behavior is not a documented guarantee. The heuristics\n/// used are an implementation detail and may change over time in semver\n/// compatible releases.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Seq, Literal};\n///\n/// let mut seq = Seq::new(&[\n///     \"samantha\",\n///     \"sam\",\n///     \"samwise\",\n///     \"frodo\",\n/// ]);\n/// seq.optimize_for_prefix_by_preference();\n/// assert_eq!(Seq::from_iter([\n///     Literal::exact(\"samantha\"),\n///     // Kept exact even though 'samwise' got pruned\n///     // because optimization assumes literal extraction\n///     // has finished.\n///     Literal::exact(\"sam\"),\n///     Literal::exact(\"frodo\"),\n/// ]), seq);\n/// ```\n///\n/// # Example: optimization may make the sequence infinite\n///\n/// If the heuristics deem that the sequence could cause a very high false\n/// positive rate, then it may make the sequence infinite, effectively\n/// disabling its use as a prefilter.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Seq, Literal};\n///\n/// let mut seq = Seq::new(&[\n///     \"samantha\",\n///     // An empty string matches at every position,\n///     // thus rendering the prefilter completely\n///     // ineffective.\n///     \"\",\n///     \"sam\",\n///     \"samwise\",\n///     \"frodo\",\n/// ]);\n/// seq.optimize_for_prefix_by_preference();\n/// assert!(!seq.is_finite());\n/// ```\n///\n/// Do note that just because there is a `\" \"` in the sequence, that\n/// doesn't mean the sequence will always be made infinite after it is\n/// optimized. Namely, if the sequence is considered exact (any match\n/// corresponds to an overall match of the original regex), then any match\n/// is an overall match, and so the false positive rate is always `0`.\n///\n/// To demonstrate this, we remove `samwise` from our sequence. This\n/// results in no optimization happening and all literals remain exact.\n/// Thus the entire sequence is exact, and it is kept as-is, even though\n/// one is an ASCII space:\n///\n/// ```\n/// use regex_syntax::hir::literal::{Seq, Literal};\n///\n/// let mut seq = Seq::new(&[\n///     \"samantha\",\n///     \" \",\n///     \"sam\",\n///     \"frodo\",\n/// ]);\n/// seq.optimize_for_prefix_by_preference();\n/// assert!(seq.is_finite());\n/// ```\n1819 pub fn optimize_for_prefix_by_preference(&mut self) {\n1820     self.optimize_by_preference(true);\n1821 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}