{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/translate.rs\n// crate name is regex_syntax\ntype Result<T> = core::result::Result<T, Error>;\nuse core::cell::{Cell, RefCell};\nuse alloc::{boxed::Box, string::ToString, vec, vec::Vec};\nuse crate::{\n    ast::{self, Ast, Span, Visitor},\n    either::Either, hir::{self, Error, ErrorKind, Hir, HirKind},\n    unicode::{self, ClassQuery},\n};\npub trait Visitor {\n    type Output;\n    type Err;\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n    fn start(&mut self) {}\n    fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_concat_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}\n#[derive(Clone, Debug)]\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassUnicodeRange {\n    start: char,\n    end: char,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}\n#[derive(Clone, Copy, Debug, Default)]\nstruct Flags {\n    case_insensitive: Option<bool>,\n    multi_line: Option<bool>,\n    dot_matches_new_line: Option<bool>,\n    swap_greed: Option<bool>,\n    unicode: Option<bool>,\n    crlf: Option<bool>,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n#[derive(Clone, Debug)]\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    utf8: bool,\n    /// The line terminator to use for `.`.\n    line_terminator: u8,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassBracketed {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not. e.g., `[a]` is not negated but\n    /// `[^a]` is.\n    pub negated: bool,\n    /// The type of this set. A set is either a normal union of things, e.g.,\n    /// `[abc]` or a result of applying set operations, e.g., `[\\pL--c]`.\n    pub kind: ClassSet,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassPerl {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of Perl class.\n    pub kind: ClassPerlKind,\n    /// Whether the class is negated or not. e.g., `\\d` is not negated but\n    /// `\\D` is.\n    pub negated: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassAscii {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of ASCII class.\n    pub kind: ClassAsciiKind,\n    /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated\n    /// but `[[:^alpha:]]` is.\n    pub negated: bool,\n}\n#[derive(Clone, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassUnicode {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not.\n    ///\n    /// Note: be careful when using this attribute. This specifically refers\n    /// to whether the class is written as `\\p` or `\\P`, where the latter\n    /// is `negated = true`. However, it also possible to write something like\n    /// `\\P{scx!=Katakana}` which is actually equivalent to\n    /// `\\p{scx=Katakana}` and is therefore not actually negated even though\n    /// `negated = true` here. To test whether this class is truly negated\n    /// or not, use the `is_negated` method.\n    pub negated: bool,\n    /// The kind of Unicode class.\n    pub kind: ClassUnicodeKind,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassSetRange {\n    /// The span of this range.\n    pub span: Span,\n    /// The start of this range.\n    pub start: Literal,\n    /// The end of this range.\n    pub end: Literal,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the translator's Ast was parsed from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error, derived from the Ast given to the translator.\n    span: Span,\n}\n#[derive(Clone, Debug)]\nenum HirFrame {\n    /// An arbitrary HIR expression. These get pushed whenever we hit a base\n    /// case in the Ast. They get popped after an inductive (i.e., recursive)\n    /// step is complete.\n    Expr(Hir),\n    /// A literal that is being constructed, character by character, from the\n    /// AST. We need this because the AST gives each individual character its\n    /// own node. So as we see characters, we peek at the top-most HirFrame.\n    /// If it's a literal, then we add to it. Otherwise, we push a new literal.\n    /// When it comes time to pop it, we convert it to an Hir via Hir::literal.\n    Literal(Vec<u8>),\n    /// A Unicode character class. This frame is mutated as we descend into\n    /// the Ast of a character class (which is itself its own mini recursive\n    /// structure).\n    ClassUnicode(hir::ClassUnicode),\n    /// A byte-oriented character class. This frame is mutated as we descend\n    /// into the Ast of a character class (which is itself its own mini\n    /// recursive structure).\n    ///\n    /// Byte character classes are created when Unicode mode (`u`) is disabled.\n    /// If `utf8` is enabled (the default), then a byte character is only\n    /// permitted to match ASCII text.\n    ClassBytes(hir::ClassBytes),\n    /// This is pushed whenever a repetition is observed. After visiting every\n    /// sub-expression in the repetition, the translator's stack is expected to\n    /// have this sentinel at the top.\n    ///\n    /// This sentinel only exists to stop other things (like flattening\n    /// literals) from reaching across repetition operators.\n    Repetition,\n    /// This is pushed on to the stack upon first seeing any kind of capture,\n    /// indicated by parentheses (including non-capturing groups). It is popped\n    /// upon leaving a group.\n    Group {\n        /// The old active flags when this group was opened.\n        ///\n        /// If this group sets flags, then the new active flags are set to the\n        /// result of merging the old flags with the flags introduced by this\n        /// group. If the group doesn't set any flags, then this is simply\n        /// equivalent to whatever flags were set when the group was opened.\n        ///\n        /// When this group is popped, the active flags should be restored to\n        /// the flags set here.\n        ///\n        /// The \"active\" flags correspond to whatever flags are set in the\n        /// Translator.\n        old_flags: Flags,\n    },\n    /// This is pushed whenever a concatenation is observed. After visiting\n    /// every sub-expression in the concatenation, the translator's stack is\n    /// popped until it sees a Concat frame.\n    Concat,\n    /// This is pushed whenever an alternation is observed. After visiting\n    /// every sub-expression in the alternation, the translator's stack is\n    /// popped until it sees an Alternation frame.\n    Alternation,\n    /// This is pushed immediately before each sub-expression in an\n    /// alternation. This separates the branches of an alternation on the\n    /// stack and prevents literal flattening from reaching across alternation\n    /// branches.\n    ///\n    /// It is popped after each expression in a branch until an 'Alternation'\n    /// frame is observed when doing a post visit on an alternation.\n    AlternationBranch,\n}\n#[non_exhaustive]\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Error {\n    /// An error that occurred while translating concrete syntax into abstract\n    /// syntax (AST).\n    Parse(ast::Error),\n    /// An error that occurred while translating abstract syntax into a high\n    /// level intermediate representation (HIR).\n    Translate(hir::Error),\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum ClassSetItem {\n    /// An empty item.\n    ///\n    /// Note that a bracketed character class cannot contain a single empty\n    /// item. Empty items can appear when using one of the binary operators.\n    /// For example, `[&&]` is the intersection of two empty classes.\n    Empty(Span),\n    /// A single literal.\n    Literal(Literal),\n    /// A range between two literals.\n    Range(ClassSetRange),\n    /// An ASCII character class, e.g., `[:alnum:]` or `[:punct:]`.\n    Ascii(ClassAscii),\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(Box<ClassBracketed>),\n    /// A union of items.\n    Union(ClassSetUnion),\n}\n#[derive(Debug)]\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n    #[allow(dead_code)]\n    PerlClassNotFound,\n}\nimpl<'t, 'p> Visitor for TranslatorI<'t, 'p> {\n    type Output = Hir;\n    type Err = Error;\n    fn finish(self) -> Result<Hir> {}\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {}\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {}\n    fn visit_alternation_in(&mut self) -> Result<()> {}\n    fn visit_class_set_item_pre(&mut self, ast: &ast::ClassSetItem) -> Result<()> {}\n    fn visit_class_set_item_post(&mut self, ast: &ast::ClassSetItem) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Empty(_) => {}\n            ast::ClassSetItem::Literal(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let byte = self.class_literal_byte(x)?;\n                    cls.push(hir::ClassBytesRange::new(byte, byte));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Range(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let start = self.class_literal_byte(&x.start)?;\n                    let end = self.class_literal_byte(&x.end)?;\n                    cls.push(hir::ClassBytesRange::new(start, end));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Ascii(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_ascii_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_ascii_byte_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Unicode(ref x) => {\n                let xcls = self.hir_unicode_class(x)?;\n                let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                cls.union(&xcls);\n                self.push(HirFrame::ClassUnicode(cls));\n            }\n            ast::ClassSetItem::Perl(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_perl_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_perl_byte_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Bracketed(ref ast) => {\n                if self.flags().unicode() {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls1)?;\n                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassUnicode(cls2));\n                } else {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls1)?;\n                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassBytes(cls2));\n                }\n            }\n            ast::ClassSetItem::Union(_) => {}\n        }\n        Ok(())\n    }\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {}\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {}\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {}\n}\nimpl ClassBytes {\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {}\n    pub fn empty() -> ClassBytes {}\n    pub fn push(&mut self, range: ClassBytesRange) {\n        self.set.push(range);\n    }\n    pub fn iter(&self) -> ClassBytesIter<'_> {}\n    pub fn ranges(&self) -> &[ClassBytesRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassBytes) {\n        self.set.union(&other.set);\n    }\n    pub fn intersect(&mut self, other: &ClassBytes) {}\n    pub fn difference(&mut self, other: &ClassBytes) {}\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_unicode_class(&self) -> Option<ClassUnicode> {}\n}\nimpl HirFrame {\n    fn unwrap_expr(self) -> Hir {}\n    fn unwrap_class_unicode(self) -> hir::ClassUnicode {\n        match self {\n            HirFrame::ClassUnicode(cls) => cls,\n            _ => {\n                panic!(\n                    \"tried to unwrap Unicode class \\\n                 from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }\n    fn unwrap_class_bytes(self) -> hir::ClassBytes {\n        match self {\n            HirFrame::ClassBytes(cls) => cls,\n            _ => {\n                panic!(\n                    \"tried to unwrap byte class \\\n                 from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }\n    fn unwrap_repetition(self) {}\n    fn unwrap_group(self) -> Flags {}\n    fn unwrap_alternation_pipe(self) {}\n}\nimpl ClassUnicodeRange {\n    pub fn new(start: char, end: char) -> ClassUnicodeRange {\n        ClassUnicodeRange::create(start, end)\n    }\n    pub fn start(&self) -> char {}\n    pub fn end(&self) -> char {}\n    pub fn len(&self) -> usize {}\n}\nimpl<'t, 'p> TranslatorI<'t, 'p> {\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {}\n    fn trans(&self) -> &Translator {}\n    fn push(&self, frame: HirFrame) {\n        self.trans().stack.borrow_mut().push(frame);\n    }\n    fn push_char(&self, ch: char) {}\n    fn push_byte(&self, byte: u8) {}\n    fn pop(&self) -> Option<HirFrame> {\n        self.trans().stack.borrow_mut().pop()\n    }\n    fn pop_concat_expr(&self) -> Option<Hir> {}\n    fn pop_alt_expr(&self) -> Option<Hir> {}\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {}\n    fn flags(&self) -> Flags {\n        self.trans().flags.get()\n    }\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {}\n    fn ast_literal_to_scalar(&self, lit: &ast::Literal) -> Result<Either<char, u8>> {}\n    fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>> {}\n    fn hir_dot(&self, span: Span) -> Result<Hir> {}\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {}\n    fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir {}\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {}\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {\n        use crate::ast::ClassUnicodeKind::*;\n        if !self.flags().unicode() {\n            return Err(self.error(ast_class.span, ErrorKind::UnicodeNotAllowed));\n        }\n        let query = match ast_class.kind {\n            OneLetter(name) => ClassQuery::OneLetter(name),\n            Named(ref name) => ClassQuery::Binary(name),\n            NamedValue { ref name, ref value, .. } => {\n                ClassQuery::ByValue {\n                    property_name: name,\n                    property_value: value,\n                }\n            }\n        };\n        let mut result = self\n            .convert_unicode_class_error(&ast_class.span, unicode::class(query));\n        if let Ok(ref mut class) = result {\n            self.unicode_fold_and_negate(&ast_class.span, ast_class.negated, class)?;\n        }\n        result\n    }\n    fn hir_ascii_unicode_class(\n        &self,\n        ast: &ast::ClassAscii,\n    ) -> Result<hir::ClassUnicode> {\n        let mut cls = hir::ClassUnicode::new(\n            ascii_class_as_chars(&ast.kind)\n                .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),\n        );\n        self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n        Ok(cls)\n    }\n    fn hir_ascii_byte_class(&self, ast: &ast::ClassAscii) -> Result<hir::ClassBytes> {\n        let mut cls = hir::ClassBytes::new(\n            ascii_class(&ast.kind).map(|(s, e)| hir::ClassBytesRange::new(s, e)),\n        );\n        self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n        Ok(cls)\n    }\n    fn hir_perl_unicode_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassUnicode> {\n        use crate::ast::ClassPerlKind::*;\n        assert!(self.flags().unicode());\n        let result = match ast_class.kind {\n            Digit => unicode::perl_digit(),\n            Space => unicode::perl_space(),\n            Word => unicode::perl_word(),\n        };\n        let mut class = self.convert_unicode_class_error(&ast_class.span, result)?;\n        if ast_class.negated {\n            class.negate();\n        }\n        Ok(class)\n    }\n    fn hir_perl_byte_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassBytes> {\n        use crate::ast::ClassPerlKind::*;\n        assert!(! self.flags().unicode());\n        let mut class = match ast_class.kind {\n            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),\n            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),\n            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),\n        };\n        if ast_class.negated {\n            class.negate();\n        }\n        if self.trans().utf8 && !class.is_ascii() {\n            return Err(self.error(ast_class.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(class)\n    }\n    fn convert_unicode_class_error(\n        &self,\n        span: &Span,\n        result: core::result::Result<hir::ClassUnicode, unicode::Error>,\n    ) -> Result<hir::ClassUnicode> {}\n    fn unicode_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassUnicode,\n    ) -> Result<()> {\n        if self.flags().case_insensitive() {\n            class\n                .try_case_fold_simple()\n                .map_err(|_| {\n                    self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)\n                })?;\n        }\n        if negated {\n            class.negate();\n        }\n        Ok(())\n    }\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {\n        if self.flags().case_insensitive() {\n            class.case_fold_simple();\n        }\n        if negated {\n            class.negate();\n        }\n        if self.trans().utf8 && !class.is_ascii() {\n            return Err(self.error(span.clone(), ErrorKind::InvalidUtf8));\n        }\n        Ok(())\n    }\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {\n        match self.ast_literal_to_scalar(ast)? {\n            Either::Right(byte) => Ok(byte),\n            Either::Left(ch) => {\n                if ch.is_ascii() {\n                    Ok(u8::try_from(ch).unwrap())\n                } else {\n                    Err(self.error(ast.span, ErrorKind::UnicodeNotAllowed))\n                }\n            }\n        }\n    }\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {}\n    pub fn empty() -> ClassUnicode {}\n    pub fn push(&mut self, range: ClassUnicodeRange) {\n        self.set.push(range);\n    }\n    pub fn iter(&self) -> ClassUnicodeIter<'_> {}\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn try_case_fold_simple(&mut self) -> core::result::Result<(), CaseFoldError> {}\n    pub fn negate(&mut self) {}\n    pub fn union(&mut self, other: &ClassUnicode) {\n        self.set.union(&other.set);\n    }\n    pub fn intersect(&mut self, other: &ClassUnicode) {}\n    pub fn difference(&mut self, other: &ClassUnicode) {}\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_byte_class(&self) -> Option<ClassBytes> {}\n}\nimpl ClassBytesRange {\n    pub fn new(start: u8, end: u8) -> ClassBytesRange {\n        ClassBytesRange::create(start, end)\n    }\n    pub fn start(&self) -> u8 {}\n    pub fn end(&self) -> u8 {}\n    pub fn len(&self) -> usize {}\n}\nimpl Flags {\n    fn from_ast(ast: &ast::Flags) -> Flags {}\n    fn merge(&mut self, previous: &Flags) {}\n    fn case_insensitive(&self) -> bool {}\n    fn multi_line(&self) -> bool {}\n    fn dot_matches_new_line(&self) -> bool {}\n    fn swap_greed(&self) -> bool {}\n    fn unicode(&self) -> bool {\n        self.unicode.unwrap_or(true)\n    }\n    fn crlf(&self) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n498 fn visit_class_set_item_post(\n499     &mut self,\n500     ast: &ast::ClassSetItem,\n501 ) -> Result<()> {\n502     match *ast {\n503         ast::ClassSetItem::Empty(_) => {}\n504         ast::ClassSetItem::Literal(ref x) => {\n505             if self.flags().unicode() {\n506                 let mut cls = self.pop().unwrap().unwrap_class_unicode();\n507                 cls.push(hir::ClassUnicodeRange::new(x.c, x.c));\n508                 self.push(HirFrame::ClassUnicode(cls));\n509             } else {\n510                 let mut cls = self.pop().unwrap().unwrap_class_bytes();\n511                 let byte = self.class_literal_byte(x)?;\n512                 cls.push(hir::ClassBytesRange::new(byte, byte));\n513                 self.push(HirFrame::ClassBytes(cls));\n514             }\n515         }\n516         ast::ClassSetItem::Range(ref x) => {\n517             if self.flags().unicode() {\n518                 let mut cls = self.pop().unwrap().unwrap_class_unicode();\n519                 cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));\n520                 self.push(HirFrame::ClassUnicode(cls));\n521             } else {\n522                 let mut cls = self.pop().unwrap().unwrap_class_bytes();\n523                 let start = self.class_literal_byte(&x.start)?;\n524                 let end = self.class_literal_byte(&x.end)?;\n525                 cls.push(hir::ClassBytesRange::new(start, end));\n526                 self.push(HirFrame::ClassBytes(cls));\n527             }\n528         }\n529         ast::ClassSetItem::Ascii(ref x) => {\n530             if self.flags().unicode() {\n531                 let xcls = self.hir_ascii_unicode_class(x)?;\n532                 let mut cls = self.pop().unwrap().unwrap_class_unicode();\n533                 cls.union(&xcls);\n534                 self.push(HirFrame::ClassUnicode(cls));\n535             } else {\n536                 let xcls = self.hir_ascii_byte_class(x)?;\n537                 let mut cls = self.pop().unwrap().unwrap_class_bytes();\n538                 cls.union(&xcls);\n539                 self.push(HirFrame::ClassBytes(cls));\n540             }\n541         }\n542         ast::ClassSetItem::Unicode(ref x) => {\n543             let xcls = self.hir_unicode_class(x)?;\n544             let mut cls = self.pop().unwrap().unwrap_class_unicode();\n545             cls.union(&xcls);\n546             self.push(HirFrame::ClassUnicode(cls));\n547         }\n548         ast::ClassSetItem::Perl(ref x) => {\n549             if self.flags().unicode() {\n550                 let xcls = self.hir_perl_unicode_class(x)?;\n551                 let mut cls = self.pop().unwrap().unwrap_class_unicode();\n552                 cls.union(&xcls);\n553                 self.push(HirFrame::ClassUnicode(cls));\n554             } else {\n555                 let xcls = self.hir_perl_byte_class(x)?;\n556                 let mut cls = self.pop().unwrap().unwrap_class_bytes();\n557                 cls.union(&xcls);\n558                 self.push(HirFrame::ClassBytes(cls));\n559             }\n560         }\n561         ast::ClassSetItem::Bracketed(ref ast) => {\n562             if self.flags().unicode() {\n563                 let mut cls1 = self.pop().unwrap().unwrap_class_unicode();\n564                 self.unicode_fold_and_negate(\n565                     &ast.span,\n566                     ast.negated,\n567                     &mut cls1,\n568                 )?;\n569 \n570                 let mut cls2 = self.pop().unwrap().unwrap_class_unicode();\n571                 cls2.union(&cls1);\n572                 self.push(HirFrame::ClassUnicode(cls2));\n573             } else {\n574                 let mut cls1 = self.pop().unwrap().unwrap_class_bytes();\n575                 self.bytes_fold_and_negate(\n576                     &ast.span,\n577                     ast.negated,\n578                     &mut cls1,\n579                 )?;\n580 \n581                 let mut cls2 = self.pop().unwrap().unwrap_class_bytes();\n582                 cls2.union(&cls1);\n583                 self.push(HirFrame::ClassBytes(cls2));\n584             }\n585         }\n586         // This is handled automatically by the visitor.\n587         ast::ClassSetItem::Union(_) => {}\n588     }\n589     Ok(())\n590 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}