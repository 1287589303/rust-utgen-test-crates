{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/parse.rs\n// crate name is regex_syntax\ntype Result<T> = core::result::Result<T, ast::Error>;\nuse core::{\n    borrow::Borrow, cell::{Cell, RefCell},\n    mem,\n};\nuse alloc::{\n    boxed::Box, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::{self, Ast, Position, Span},\n    either::Either, is_escapeable_character, is_meta_character,\n};\n#[derive(Clone, Debug)]\nstruct ParserI<'s, P> {\n    /// The parser state/configuration.\n    parser: P,\n    /// The full regular expression provided by the user.\n    pattern: &'s str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassSetUnion {\n    /// The span of the items in this operation. e.g., the `a-z0-9` in\n    /// `[^a-z0-9]`\n    pub span: Span,\n    /// The sequence of items that make up this union.\n    pub items: Vec<ClassSetItem>,\n}\n#[derive(Clone, Debug)]\npub struct Parser {\n    ast: ast::parse::Parser,\n    hir: hir::translate::Translator,\n}\n#[derive(Clone, Debug)]\npub struct Parser {\n    /// The current position of the parser.\n    pos: Cell<Position>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The maximum number of open parens/brackets allowed. If the parser\n    /// exceeds this number, then an error is returned.\n    nest_limit: u32,\n    /// Whether to support octal syntax or not. When `false`, the parser will\n    /// return an error helpfully pointing out that backreferences are not\n    /// supported.\n    octal: bool,\n    /// The initial setting for `ignore_whitespace` as provided by\n    /// `ParserBuilder`. It is used when resetting the parser's state.\n    initial_ignore_whitespace: bool,\n    /// Whether the parser supports `{,n}` repetitions as an equivalent to\n    /// `{0,n}.`\n    empty_min_range: bool,\n    /// Whether whitespace should be ignored. When enabled, comments are\n    /// also permitted.\n    ignore_whitespace: Cell<bool>,\n    /// A list of comments, in order of appearance.\n    comments: RefCell<Vec<ast::Comment>>,\n    /// A stack of grouped sub-expressions, including alternations.\n    stack_group: RefCell<Vec<GroupState>>,\n    /// A stack of nested character classes. This is only non-empty when\n    /// parsing a class.\n    stack_class: RefCell<Vec<ClassState>>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<ast::CaptureName>>,\n    /// A scratch buffer used in various places. Mostly this is used to\n    /// accumulate relevant characters from parts of a pattern.\n    scratch: RefCell<String>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassAscii {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of ASCII class.\n    pub kind: ClassAsciiKind,\n    /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated\n    /// but `[[:^alpha:]]` is.\n    pub negated: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub struct ClassBracketed {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not. e.g., `[a]` is not negated but\n    /// `[^a]` is.\n    pub negated: bool,\n    /// The type of this set. A set is either a normal union of things, e.g.,\n    /// `[abc]` or a result of applying set operations, e.g., `[\\pL--c]`.\n    pub kind: ClassSet,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum Either<Left, Right> {\n    Left(Left),\n    Right(Right),\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum ClassSetBinaryOpKind {\n    /// The intersection of two sets, e.g., `\\pN&&[a-z]`.\n    Intersection,\n    /// The difference of two sets, e.g., `\\pN--[0-9]`.\n    Difference,\n    /// The symmetric difference of two sets. The symmetric difference is the\n    /// set of elements belonging to one but not both sets.\n    /// e.g., `[\\pL~~[:ascii:]]`.\n    SymmetricDifference,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[cfg_attr(feature = \"arbitrary\", derive(arbitrary::Arbitrary))]\npub enum ClassSetItem {\n    /// An empty item.\n    ///\n    /// Note that a bracketed character class cannot contain a single empty\n    /// item. Empty items can appear when using one of the binary operators.\n    /// For example, `[&&]` is the intersection of two empty classes.\n    Empty(Span),\n    /// A single literal.\n    Literal(Literal),\n    /// A range between two literals.\n    Range(ClassSetRange),\n    /// An ASCII character class, e.g., `[:alnum:]` or `[:punct:]`.\n    Ascii(ClassAscii),\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(Box<ClassBracketed>),\n    /// A union of items.\n    Union(ClassSetUnion),\n}\n#[derive(Clone, Debug)]\nenum ClassState {\n    /// This state is pushed whenever an opening bracket is found.\n    Open {\n        /// The union of class items immediately preceding this class.\n        union: ast::ClassSetUnion,\n        /// The class that has been opened. Typically this just corresponds\n        /// to the `[`, but it can also include `[^` since `^` indicates\n        /// negation of the class.\n        set: ast::ClassBracketed,\n    },\n    /// This state is pushed when a operator is seen. When popped, the stored\n    /// set becomes the left hand side of the operator.\n    Op {\n        /// The type of the operation, i.e., &&, -- or ~~.\n        kind: ast::ClassSetBinaryOpKind,\n        /// The left-hand side of the operator.\n        lhs: ast::ClassSet,\n    },\n}\nimpl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    fn parse(&self) -> Result<Ast> {}\n    fn parse_with_comments(&self) -> Result<ast::WithComments> {}\n    #[inline(never)]\n    fn parse_uncounted_repetition(\n        &self,\n        mut concat: ast::Concat,\n        kind: ast::RepetitionKind,\n    ) -> Result<ast::Concat> {}\n    #[inline(never)]\n    fn parse_counted_repetition(&self, mut concat: ast::Concat) -> Result<ast::Concat> {}\n    #[inline(never)]\n    fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {}\n    #[inline(never)]\n    fn parse_capture_name(&self, capture_index: u32) -> Result<ast::CaptureName> {}\n    #[inline(never)]\n    fn parse_flags(&self) -> Result<ast::Flags> {}\n    #[inline(never)]\n    fn parse_flag(&self) -> Result<ast::Flag> {}\n    fn parse_primitive(&self) -> Result<Primitive> {}\n    #[inline(never)]\n    fn parse_escape(&self) -> Result<Primitive> {}\n    fn maybe_parse_special_word_boundary(\n        &self,\n        wb_start: Position,\n    ) -> Result<Option<ast::AssertionKind>> {}\n    #[inline(never)]\n    fn parse_octal(&self) -> ast::Literal {}\n    #[inline(never)]\n    fn parse_hex(&self) -> Result<ast::Literal> {}\n    #[inline(never)]\n    fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {}\n    #[inline(never)]\n    fn parse_hex_brace(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {}\n    fn parse_decimal(&self) -> Result<u32> {}\n    #[inline(never)]\n    fn parse_set_class(&self) -> Result<ast::ClassBracketed> {\n        assert_eq!(self.char(), '[');\n        let mut union = ast::ClassSetUnion {\n            span: self.span(),\n            items: vec![],\n        };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                return Err(self.unclosed_class_error());\n            }\n            match self.char() {\n                '[' => {\n                    if !self.parser().stack_class.borrow().is_empty() {\n                        if let Some(cls) = self.maybe_parse_ascii_class() {\n                            union.push(ast::ClassSetItem::Ascii(cls));\n                            continue;\n                        }\n                    }\n                    union = self.push_class_open(union)?;\n                }\n                ']' => {\n                    match self.pop_class(union)? {\n                        Either::Left(nested_union) => {\n                            union = nested_union;\n                        }\n                        Either::Right(class) => return Ok(class),\n                    }\n                }\n                '&' if self.peek() == Some('&') => {\n                    assert!(self.bump_if(\"&&\"));\n                    union = self\n                        .push_class_op(ast::ClassSetBinaryOpKind::Intersection, union);\n                }\n                '-' if self.peek() == Some('-') => {\n                    assert!(self.bump_if(\"--\"));\n                    union = self\n                        .push_class_op(ast::ClassSetBinaryOpKind::Difference, union);\n                }\n                '~' if self.peek() == Some('~') => {\n                    assert!(self.bump_if(\"~~\"));\n                    union = self\n                        .push_class_op(\n                            ast::ClassSetBinaryOpKind::SymmetricDifference,\n                            union,\n                        );\n                }\n                _ => {\n                    union.push(self.parse_set_class_range()?);\n                }\n            }\n        }\n    }\n    #[inline(never)]\n    fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {\n        let prim1 = self.parse_set_class_item()?;\n        self.bump_space();\n        if self.is_eof() {\n            return Err(self.unclosed_class_error());\n        }\n        if self.char() != '-' || self.peek_space() == Some(']')\n            || self.peek_space() == Some('-')\n        {\n            return prim1.into_class_set_item(self);\n        }\n        if !self.bump_and_bump_space() {\n            return Err(self.unclosed_class_error());\n        }\n        let prim2 = self.parse_set_class_item()?;\n        let range = ast::ClassSetRange {\n            span: Span::new(prim1.span().start, prim2.span().end),\n            start: prim1.into_class_literal(self)?,\n            end: prim2.into_class_literal(self)?,\n        };\n        if !range.is_valid() {\n            return Err(self.error(range.span, ast::ErrorKind::ClassRangeInvalid));\n        }\n        Ok(ast::ClassSetItem::Range(range))\n    }\n    #[inline(never)]\n    fn parse_set_class_item(&self) -> Result<Primitive> {}\n    #[inline(never)]\n    fn parse_set_class_open(&self) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {}\n    #[inline(never)]\n    fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {\n        assert_eq!(self.char(), '[');\n        let start = self.pos();\n        let mut negated = false;\n        if !self.bump() || self.char() != ':' {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if !self.bump() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if self.char() == '^' {\n            negated = true;\n            if !self.bump() {\n                self.parser().pos.set(start);\n                return None;\n            }\n        }\n        let name_start = self.offset();\n        while self.char() != ':' && self.bump() {}\n        if self.is_eof() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let name = &self.pattern()[name_start..self.offset()];\n        if !self.bump_if(\":]\") {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let kind = match ast::ClassAsciiKind::from_name(name) {\n            Some(kind) => kind,\n            None => {\n                self.parser().pos.set(start);\n                return None;\n            }\n        };\n        Some(ast::ClassAscii {\n            span: Span::new(start, self.pos()),\n            kind,\n            negated,\n        })\n    }\n    #[inline(never)]\n    fn parse_unicode_class(&self) -> Result<ast::ClassUnicode> {}\n    #[inline(never)]\n    fn parse_perl_class(&self) -> ast::ClassPerl {}\n}\nimpl ClassSetUnion {\n    pub fn push(&mut self, item: ClassSetItem) {\n        if self.items.is_empty() {\n            self.span.start = item.span().start;\n        }\n        self.span.end = item.span().end;\n        self.items.push(item);\n    }\n    pub fn into_item(mut self) -> ClassSetItem {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Parse a standard character class consisting primarily of characters or\n/// character ranges, but can also contain nested character classes of\n/// any type (sans `.`).\n///\n/// This assumes the parser is positioned at the opening `[`. If parsing\n/// is successful, then the parser is advanced to the position immediately\n/// following the closing `]`.\n1877 fn parse_set_class(&self) -> Result<ast::ClassBracketed> {\n1878     assert_eq!(self.char(), '[');\n1879 \n1880     let mut union =\n1881         ast::ClassSetUnion { span: self.span(), items: vec![] };\n1882     loop {\n1883         self.bump_space();\n1884         if self.is_eof() {\n1885             return Err(self.unclosed_class_error());\n1886         }\n1887         match self.char() {\n1888             '[' => {\n1889                 // If we've already parsed the opening bracket, then\n1890                 // attempt to treat this as the beginning of an ASCII\n1891                 // class. If ASCII class parsing fails, then the parser\n1892                 // backs up to `[`.\n1893                 if !self.parser().stack_class.borrow().is_empty() {\n1894                     if let Some(cls) = self.maybe_parse_ascii_class() {\n1895                         union.push(ast::ClassSetItem::Ascii(cls));\n1896                         continue;\n1897                     }\n1898                 }\n1899                 union = self.push_class_open(union)?;\n1900             }\n1901             ']' => match self.pop_class(union)? {\n1902                 Either::Left(nested_union) => {\n1903                     union = nested_union;\n1904                 }\n1905                 Either::Right(class) => return Ok(class),\n1906             },\n1907             '&' if self.peek() == Some('&') => {\n1908                 assert!(self.bump_if(\"&&\"));\n1909                 union = self.push_class_op(\n1910                     ast::ClassSetBinaryOpKind::Intersection,\n1911                     union,\n1912                 );\n1913             }\n1914             '-' if self.peek() == Some('-') => {\n1915                 assert!(self.bump_if(\"--\"));\n1916                 union = self.push_class_op(\n1917                     ast::ClassSetBinaryOpKind::Difference,\n1918                     union,\n1919                 );\n1920             }\n1921             '~' if self.peek() == Some('~') => {\n1922                 assert!(self.bump_if(\"~~\"));\n1923                 union = self.push_class_op(\n1924                     ast::ClassSetBinaryOpKind::SymmetricDifference,\n1925                     union,\n1926                 );\n1927             }\n1928             _ => {\n1929                 union.push(self.parse_set_class_range()?);\n1930             }\n1931         }\n1932     }\n1933 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}