{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, avoid additional explanations, and do not use Markdown.\n2. Combine the given function under test, context, relevant documentation, preconditions, expected return values or types, test input conditions or ranges, and existing test function prefixes to infer and generate corresponding test oracles code.\n3. Only generate necessary test oracles to ensure comprehensive validation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/meta/strategy.rs\n// crate name is regex_automata\nuse core::{fmt::Debug, panic::{RefUnwindSafe, UnwindSafe}};\nuse alloc::sync::Arc;\nuse regex_syntax::hir::{literal, Hir};\nuse crate::{\n    meta::{\n        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},\n        regex::{Cache, RegexInfo},\n        reverse_inner, wrappers,\n    },\n    nfa::thompson::{self, WhichCaptures, NFA},\n    util::{\n        captures::{Captures, GroupInfo},\n        look::LookMatcher, prefilter::{self, Prefilter, PrefilterI},\n        primitives::{NonMaxUsize, PatternID},\n        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},\n    },\n};\npub(super) trait Strategy: Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static {\n    fn group_info(&self) -> &GroupInfo;\n    fn create_cache(&self) -> Cache;\n    fn reset_cache(&self, cache: &mut Cache);\n    fn is_accelerated(&self) -> bool;\n    fn memory_usage(&self) -> usize;\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch>;\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID>;\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    );\n}\n#[derive(Debug)]\nstruct ReverseSuffix {\n    core: Core,\n    pre: Prefilter,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Debug)]\nstruct Core {\n    info: RegexInfo,\n    pre: Option<Prefilter>,\n    nfa: NFA,\n    nfarev: Option<NFA>,\n    pikevm: wrappers::PikeVM,\n    backtrack: wrappers::BoundedBacktracker,\n    onepass: wrappers::OnePass,\n    hybrid: wrappers::Hybrid,\n    dfa: wrappers::DFA,\n}\n#[derive(Debug)]\npub(crate) struct RetryFailError {\n    offset: usize,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Debug)]\npub(crate) struct RetryQuadraticError(());\n#[derive(Debug, Clone)]\npub struct Cache {\n    pub(crate) capmatches: Captures,\n    pub(crate) pikevm: wrappers::PikeVMCache,\n    pub(crate) backtrack: wrappers::BoundedBacktrackerCache,\n    pub(crate) onepass: wrappers::OnePassCache,\n    pub(crate) hybrid: wrappers::HybridCache,\n    pub(crate) revhybrid: wrappers::ReverseHybridCache,\n}\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct Match {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The underlying match span.\n    span: Span,\n}\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\n#[derive(Debug)]\npub(crate) enum RetryError {\n    Quadratic(RetryQuadraticError),\n    Fail(RetryFailError),\n}\nimpl Strategy for ReverseSuffix {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn group_info(&self) -> &GroupInfo {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn create_cache(&self) -> Cache {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn reset_cache(&self, cache: &mut Cache) {}\n    fn is_accelerated(&self) -> bool {}\n    fn memory_usage(&self) -> usize {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {\n        if input.get_anchored().is_anchored() {\n            return self.core.search(cache, input);\n        }\n        match self.try_search_half_start(cache, input) {\n            Err(RetryError::Quadratic(_err)) => {\n                trace!(\"reverse suffix optimization failed: {}\", _err);\n                self.core.search(cache, input)\n            }\n            Err(RetryError::Fail(_err)) => {\n                trace!(\"reverse suffix reverse fast search failed: {}\", _err);\n                self.core.search_nofail(cache, input)\n            }\n            Ok(None) => None,\n            Ok(Some(hm_start)) => {\n                let fwdinput = input\n                    .clone()\n                    .anchored(Anchored::Pattern(hm_start.pattern()))\n                    .span(hm_start.offset()..input.end());\n                match self.try_search_half_fwd(cache, &fwdinput) {\n                    Err(_err) => {\n                        trace!(\"reverse suffix forward fast search failed: {}\", _err);\n                        self.core.search_nofail(cache, input)\n                    }\n                    Ok(None) => {\n                        unreachable!(\n                            \"suffix match plus reverse match implies \\\n\t\t\t\t\t\t     there must be a match\",\n                        )\n                    }\n                    Ok(Some(hm_end)) => {\n                        Some(\n                            Match::new(\n                                hm_start.pattern(),\n                                hm_start.offset()..hm_end.offset(),\n                            ),\n                        )\n                    }\n                }\n            }\n        }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn search_half(&self, cache: &mut Cache, input: &Input<'_>) -> Option<HalfMatch> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn search_slots(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn which_overlapping_matches(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        patset: &mut PatternSet,\n    ) {}\n}\nimpl Anchored {\n    #[inline]\n    pub fn is_anchored(&self) -> bool {\n        matches!(* self, Anchored::Yes | Anchored::Pattern(_))\n    }\n    #[inline]\n    pub fn pattern(&self) -> Option<PatternID> {}\n}\nimpl ReverseSuffix {\n    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_start(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryError> {\n        let mut span = input.get_span();\n        let mut min_start = 0;\n        loop {\n            let litmatch = match self.pre.find(input.haystack(), span) {\n                None => return Ok(None),\n                Some(span) => span,\n            };\n            trace!(\"reverse suffix scan found suffix match at {:?}\", litmatch);\n            let revinput = input\n                .clone()\n                .anchored(Anchored::Yes)\n                .span(input.start()..litmatch.end);\n            match self.try_search_half_rev_limited(cache, &revinput, min_start)? {\n                None => {\n                    if span.start >= span.end {\n                        break;\n                    }\n                    span.start = litmatch.start.checked_add(1).unwrap();\n                }\n                Some(hm) => return Ok(Some(hm)),\n            }\n            min_start = litmatch.end;\n        }\n        Ok(None)\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_fwd(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Result<Option<HalfMatch>, RetryFailError> {\n        if let Some(e) = self.core.dfa.get(&input) {\n            trace!(\n                \"using full DFA for forward reverse suffix search at {:?}\", input\n                .get_span()\n            );\n            e.try_search_half_fwd(&input)\n        } else if let Some(e) = self.core.hybrid.get(&input) {\n            trace!(\n                \"using lazy DFA for forward reverse suffix search at {:?}\", input\n                .get_span()\n            );\n            e.try_search_half_fwd(&mut cache.hybrid, &input)\n        } else {\n            unreachable!(\"ReverseSuffix always has a DFA\")\n        }\n    }\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_half_rev_limited(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        min_start: usize,\n    ) -> Result<Option<HalfMatch>, RetryError> {}\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {\n        self.pattern\n    }\n    #[inline]\n    pub fn offset(&self) -> usize {\n        self.offset\n    }\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {\n        self.set_anchored(mode);\n        self\n    }\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {}\n    #[inline]\n    pub fn start(&self) -> usize {}\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {\n        self.anchored\n    }\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl Core {\n    fn new(\n        info: RegexInfo,\n        pre: Option<Prefilter>,\n        hirs: &[&Hir],\n    ) -> Result<Core, BuildError> {}\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn try_search_mayfail(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Option<Result<Option<Match>, RetryFailError>> {}\n    fn search_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {\n        let caps = &mut cache.capmatches;\n        caps.set_pattern(None);\n        let pid = if let Some(ref e) = self.onepass.get(input) {\n            trace!(\"using OnePass for search at {:?}\", input.get_span());\n            e.search_slots(&mut cache.onepass, input, caps.slots_mut())\n        } else if let Some(ref e) = self.backtrack.get(input) {\n            trace!(\"using BoundedBacktracker for search at {:?}\", input.get_span());\n            e.search_slots(&mut cache.backtrack, input, caps.slots_mut())\n        } else {\n            trace!(\"using PikeVM for search at {:?}\", input.get_span());\n            let e = self.pikevm.get();\n            e.search_slots(&mut cache.pikevm, input, caps.slots_mut())\n        };\n        caps.set_pattern(pid);\n        caps.get_match()\n    }\n    fn search_half_nofail(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n    ) -> Option<HalfMatch> {}\n    fn search_slots_nofail(\n        &self,\n        cache: &mut Cache,\n        input: &Input<'_>,\n        slots: &mut [Option<NonMaxUsize>],\n    ) -> Option<PatternID> {}\n    fn is_match_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> bool {}\n    fn is_capture_search_needed(&self, slots_len: usize) -> bool {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n1321 fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {\n1322     if input.get_anchored().is_anchored() {\n1323         return self.core.search(cache, input);\n1324     }\n1325     match self.try_search_half_start(cache, input) {\n1326         Err(RetryError::Quadratic(_err)) => {\n1327             trace!(\"reverse suffix optimization failed: {}\", _err);\n1328             self.core.search(cache, input)\n1329         }\n1330         Err(RetryError::Fail(_err)) => {\n1331             trace!(\"reverse suffix reverse fast search failed: {}\", _err);\n1332             self.core.search_nofail(cache, input)\n1333         }\n1334         Ok(None) => None,\n1335         Ok(Some(hm_start)) => {\n1336             let fwdinput = input\n1337                 .clone()\n1338                 .anchored(Anchored::Pattern(hm_start.pattern()))\n1339                 .span(hm_start.offset()..input.end());\n1340             match self.try_search_half_fwd(cache, &fwdinput) {\n1341                 Err(_err) => {\n1342                     trace!(\n1343                         \"reverse suffix forward fast search failed: {}\",\n1344                         _err\n1345                     );\n1346                     self.core.search_nofail(cache, input)\n1347                 }\n1348                 Ok(None) => {\n1349                     unreachable!(\n1350                         \"suffix match plus reverse match implies \\\n1351 \t\t     there must be a match\",\n1352                     )\n1353                 }\n1354                 Ok(Some(hm_end)) => Some(Match::new(\n1355                     hm_start.pattern(),\n1356                     hm_start.offset()..hm_end.offset(),\n1357                 )),\n1358             }\n1359         }\n1360     }\n1361 }\n\nThe path conditions that the generated test functions should satisfy are as follows:\n"
}