{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// src/builders.rs\n// crate name is regex\nuse crate::{\n    bytes::{Regex, RegexSet},\n    error::Error,\n};\nuse super::Builder;\n#[derive(Clone, Debug)]\npub struct RegexBuilder {\n    builder: Builder,\n}\n#[derive(Clone, Debug)]\nstruct Builder {\n    pats: Vec<String>,\n    metac: meta::Config,\n    syntaxc: syntax::Config,\n}\nimpl RegexBuilder {\n    pub fn new(pattern: &str) -> RegexBuilder {}\n    pub fn build(&self) -> Result<Regex, Error> {}\n    pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn dot_matches_new_line(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn crlf(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn line_terminator(&mut self, byte: u8) -> &mut RegexBuilder {\n        self.builder.line_terminator(byte);\n        self\n    }\n    pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder {}\n    pub fn size_limit(&mut self, bytes: usize) -> &mut RegexBuilder {}\n    pub fn dfa_size_limit(&mut self, bytes: usize) -> &mut RegexBuilder {}\n    pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder {}\n}\nimpl Builder {\n    fn new<I, S>(patterns: I) -> Builder\n    where\n        S: AsRef<str>,\n        I: IntoIterator<Item = S>,\n    {}\n    fn build_one_string(&self) -> Result<crate::Regex, Error> {}\n    fn build_one_bytes(&self) -> Result<crate::bytes::Regex, Error> {}\n    fn build_many_string(&self) -> Result<crate::RegexSet, Error> {}\n    fn build_many_bytes(&self) -> Result<crate::bytes::RegexSet, Error> {}\n    fn case_insensitive(&mut self, yes: bool) -> &mut Builder {}\n    fn multi_line(&mut self, yes: bool) -> &mut Builder {}\n    fn dot_matches_new_line(&mut self, yes: bool) -> &mut Builder {}\n    fn crlf(&mut self, yes: bool) -> &mut Builder {}\n    fn line_terminator(&mut self, byte: u8) -> &mut Builder {\n        self.metac = self.metac.clone().line_terminator(byte);\n        self.syntaxc = self.syntaxc.line_terminator(byte);\n        self\n    }\n    fn swap_greed(&mut self, yes: bool) -> &mut Builder {}\n    fn ignore_whitespace(&mut self, yes: bool) -> &mut Builder {}\n    fn unicode(&mut self, yes: bool) -> &mut Builder {}\n    fn octal(&mut self, yes: bool) -> &mut Builder {}\n    fn size_limit(&mut self, limit: usize) -> &mut Builder {}\n    fn dfa_size_limit(&mut self, limit: usize) -> &mut Builder {}\n    fn nest_limit(&mut self, limit: u32) -> &mut Builder {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Configures the line terminator to be used by the regex.\n///\n/// The line terminator is relevant in two ways for a particular regex:\n///\n/// * When dot-matches-new-line mode is *not* enabled (the default),\n/// then `.` will match any character except for the configured line\n/// terminator.\n/// * When multi-line mode is enabled (not the default), then `^` and\n/// `$` will match immediately after and before, respectively, a line\n/// terminator.\n///\n/// In both cases, if CRLF mode is enabled in a particular context,\n/// then it takes precedence over any configured line terminator.\n///\n/// This option cannot be configured from within the pattern.\n///\n/// The default line terminator is `\\n`.\n///\n/// # Example\n///\n/// This shows how to treat the NUL byte as a line terminator. This can\n/// be a useful heuristic when searching binary data.\n///\n/// ```\n/// use regex::bytes::RegexBuilder;\n///\n/// let re = RegexBuilder::new(r\"^foo$\")\n///     .multi_line(true)\n///     .line_terminator(b'\\x00')\n///     .build()\n///     .unwrap();\n/// let hay = b\"\\x00foo\\x00\";\n/// assert_eq!(Some(1..4), re.find(hay).map(|m| m.range()));\n/// ```\n///\n/// This example shows that the behavior of `.` is impacted by this\n/// setting as well:\n///\n/// ```\n/// use regex::bytes::RegexBuilder;\n///\n/// let re = RegexBuilder::new(r\".\")\n///     .line_terminator(b'\\x00')\n///     .build()\n///     .unwrap();\n/// assert!(re.is_match(b\"\\n\"));\n/// assert!(!re.is_match(b\"\\x00\"));\n/// ```\n///\n/// This shows that building a regex will work even when the byte\n/// given is not ASCII. This is unlike the top-level `Regex` API where\n/// matching invalid UTF-8 is not allowed.\n///\n/// Note though that you must disable Unicode mode. This is required\n/// because Unicode mode requires matching one codepoint at a time,\n/// and there is no way to match a non-ASCII byte as if it were a\n/// codepoint.\n///\n/// ```\n/// use regex::bytes::RegexBuilder;\n///\n/// assert!(\n///     RegexBuilder::new(r\".\")\n///         .unicode(false)\n///         .line_terminator(0x80)\n///         .build()\n///         .is_ok(),\n/// );\n/// ```\n1694 pub fn line_terminator(&mut self, byte: u8) -> &mut RegexBuilder {\n1695     self.builder.line_terminator(byte);\n1696     self\n1697 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}