{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-automata/src/dfa/search.rs\n// crate name is regex_automata\nuse crate::{\n    dfa::{accel, automaton::{Automaton, OverlappingState}},\n    util::{\n        prefilter::Prefilter, primitives::StateID,\n        search::{Anchored, HalfMatch, Input, Span},\n    },\n    MatchError,\n};\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct HalfMatch {\n    /// The pattern ID.\n    pattern: PatternID,\n    /// The offset of the match.\n    ///\n    /// For forward searches, the offset is exclusive. For reverse searches,\n    /// the offset is inclusive.\n    offset: usize,\n}\n#[derive(Clone)]\npub struct Input<'h> {\n    haystack: &'h [u8],\n    span: Span,\n    anchored: Anchored,\n    earliest: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct MatchError(\n    #[cfg(feature = \"alloc\")]\n    alloc::boxed::Box<MatchErrorKind>,\n    #[cfg(not(feature = \"alloc\"))]\n    MatchErrorKind,\n);\n#[derive(Clone, Debug)]\npub struct Prefilter {\n    #[cfg(not(feature = \"alloc\"))]\n    _unused: (),\n    #[cfg(feature = \"alloc\")]\n    pre: Arc<dyn PrefilterI>,\n    #[cfg(feature = \"alloc\")]\n    is_fast: bool,\n    #[cfg(feature = \"alloc\")]\n    max_needle_len: usize,\n}\n#[derive(Clone, Copy, Eq, Hash, PartialEq)]\npub struct Span {\n    /// The start offset of the span, inclusive.\n    pub start: usize,\n    /// The end offset of the span, exclusive.\n    pub end: usize,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct OverlappingState {\n    /// The match reported by the most recent overlapping search to use this\n    /// state.\n    ///\n    /// If a search does not find any matches, then it is expected to clear\n    /// this value.\n    pub(crate) mat: Option<HalfMatch>,\n    /// The state ID of the state at which the search was in when the call\n    /// terminated. When this is a match state, `last_match` must be set to a\n    /// non-None value.\n    ///\n    /// A `None` value indicates the start state of the corresponding\n    /// automaton. We cannot use the actual ID, since any one automaton may\n    /// have many start states, and which one is in use depends on several\n    /// search-time factors.\n    pub(crate) id: Option<StateID>,\n    /// The position of the search.\n    ///\n    /// When `id` is None (i.e., we are starting a search), this is set to\n    /// the beginning of the search as given by the caller regardless of its\n    /// current value. Subsequent calls to an overlapping search pick up at\n    /// this offset.\n    pub(crate) at: usize,\n    /// The index into the matching patterns of the next match to report if the\n    /// current state is a match state. Note that this may be 1 greater than\n    /// the total number of matches to report for the current match state. (In\n    /// which case, no more matches should be reported at the current position\n    /// and the search should advance to the next position.)\n    pub(crate) next_match_index: Option<usize>,\n    /// This is set to true when a reverse overlapping search has entered its\n    /// EOI transitions.\n    ///\n    /// This isn't used in a forward search because it knows to stop once the\n    /// position exceeds the end of the search range. In a reverse search,\n    /// since we use unsigned offsets, we don't \"know\" once we've gone past\n    /// `0`. So the only way to detect it is with this extra flag. The reverse\n    /// overlapping search knows to terminate specifically after it has\n    /// reported all matches after following the EOI transition.\n    pub(crate) rev_eoi: bool,\n}\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct StateID(SmallIndex);\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n#[repr(transparent)]\npub struct PatternID(SmallIndex);\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Anchored {\n    /// Run an unanchored search. This means a match may occur anywhere at or\n    /// after the start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    No,\n    /// Run an anchored search. This means that a match must begin at the\n    /// start position of the search.\n    ///\n    /// This search can return a match for any pattern in the regex.\n    Yes,\n    /// Run an anchored search for a specific pattern. This means that a match\n    /// must be for the given pattern and must begin at the start position of\n    /// the search.\n    Pattern(PatternID),\n}\nimpl HalfMatch {\n    #[inline]\n    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {\n        HalfMatch { pattern, offset }\n    }\n    #[inline]\n    pub fn must(pattern: usize, offset: usize) -> HalfMatch {}\n    #[inline]\n    pub fn pattern(&self) -> PatternID {}\n    #[inline]\n    pub fn offset(&self) -> usize {}\n}\nimpl<'h> Input<'h> {\n    #[inline]\n    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {}\n    #[inline]\n    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {}\n    #[inline]\n    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {}\n    #[inline]\n    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {}\n    #[inline]\n    pub fn earliest(mut self, yes: bool) -> Input<'h> {}\n    #[inline]\n    pub fn set_span<S: Into<Span>>(&mut self, span: S) {}\n    #[inline]\n    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {}\n    #[inline]\n    pub fn set_start(&mut self, start: usize) {}\n    #[inline]\n    pub fn set_end(&mut self, end: usize) {}\n    #[inline]\n    pub fn set_anchored(&mut self, mode: Anchored) {}\n    #[inline]\n    pub fn set_earliest(&mut self, yes: bool) {}\n    #[inline]\n    pub fn haystack(&self) -> &[u8] {\n        self.haystack\n    }\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.get_span().start\n    }\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.get_span().end\n    }\n    #[inline]\n    pub fn get_span(&self) -> Span {}\n    #[inline]\n    pub fn get_range(&self) -> Range<usize> {}\n    #[inline]\n    pub fn get_anchored(&self) -> Anchored {}\n    #[inline]\n    pub fn get_earliest(&self) -> bool {}\n    #[inline]\n    pub fn is_done(&self) -> bool {}\n    #[inline]\n    pub fn is_char_boundary(&self, offset: usize) -> bool {}\n}\nimpl MatchError {\n    pub fn new(kind: MatchErrorKind) -> MatchError {}\n    pub fn kind(&self) -> &MatchErrorKind {}\n    pub fn quit(byte: u8, offset: usize) -> MatchError {\n        MatchError::new(MatchErrorKind::Quit {\n            byte,\n            offset,\n        })\n    }\n    pub fn gave_up(offset: usize) -> MatchError {}\n    pub fn haystack_too_long(len: usize) -> MatchError {}\n    pub fn unsupported_anchored(mode: Anchored) -> MatchError {}\n}\nimpl Prefilter {\n    pub fn new<B: AsRef<[u8]>>(kind: MatchKind, needles: &[B]) -> Option<Prefilter> {}\n    fn from_choice(choice: Choice, max_needle_len: usize) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {}\n    #[cfg(feature = \"syntax\")]\n    pub fn from_hirs_prefix<H: Borrow<Hir>>(\n        kind: MatchKind,\n        hirs: &[H],\n    ) -> Option<Prefilter> {}\n    #[inline]\n    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {\n        #[cfg(not(feature = \"alloc\"))] { unreachable!() }\n        #[cfg(feature = \"alloc\")] { self.pre.find(haystack, span) }\n    }\n    #[inline]\n    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {}\n    #[inline]\n    pub fn memory_usage(&self) -> usize {}\n    #[inline]\n    pub fn max_needle_len(&self) -> usize {}\n    #[inline]\n    pub fn is_fast(&self) -> bool {}\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn find_overlapping_fwd_imp<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    pre: Option<&'_ Prefilter>,\n    state: &mut OverlappingState,\n) -> Result<(), MatchError> {\n    let universal_start = dfa.universal_start_state(Anchored::No).is_some();\n    let mut sid = match state.id {\n        None => {\n            state.at = input.start();\n            init_fwd(dfa, input)?\n        }\n        Some(sid) => {\n            if let Some(match_index) = state.next_match_index {\n                let match_len = dfa.match_len(sid);\n                if match_index < match_len {\n                    state.next_match_index = Some(match_index + 1);\n                    let pattern = dfa.match_pattern(sid, match_index);\n                    state.mat = Some(HalfMatch::new(pattern, state.at));\n                    return Ok(());\n                }\n            }\n            state.at += 1;\n            if state.at > input.end() {\n                return Ok(());\n            }\n            sid\n        }\n    };\n    while state.at < input.end() {\n        sid = dfa.next_state(sid, input.haystack()[state.at]);\n        if dfa.is_special_state(sid) {\n            state.id = Some(sid);\n            if dfa.is_start_state(sid) {\n                if let Some(ref pre) = pre {\n                    let span = Span::from(state.at..input.end());\n                    match pre.find(input.haystack(), span) {\n                        None => return Ok(()),\n                        Some(ref span) => {\n                            if span.start > state.at {\n                                state.at = span.start;\n                                if !universal_start {\n                                    sid = prefilter_restart(dfa, &input, state.at)?;\n                                }\n                                continue;\n                            }\n                        }\n                    }\n                } else if dfa.is_accel_state(sid) {\n                    let needles = dfa.accelerator(sid);\n                    state.at = accel::find_fwd(needles, input.haystack(), state.at + 1)\n                        .unwrap_or(input.end());\n                    continue;\n                }\n            } else if dfa.is_match_state(sid) {\n                state.next_match_index = Some(1);\n                let pattern = dfa.match_pattern(sid, 0);\n                state.mat = Some(HalfMatch::new(pattern, state.at));\n                return Ok(());\n            } else if dfa.is_accel_state(sid) {\n                let needs = dfa.accelerator(sid);\n                state.at = accel::find_fwd(needs, input.haystack(), state.at + 1)\n                    .unwrap_or(input.end());\n                continue;\n            } else if dfa.is_dead_state(sid) {\n                return Ok(());\n            } else {\n                return Err(MatchError::quit(input.haystack()[state.at], state.at));\n            }\n        }\n        state.at += 1;\n    }\n    let result = eoi_fwd(dfa, input, &mut sid, &mut state.mat);\n    state.id = Some(sid);\n    if state.mat.is_some() {\n        state.next_match_index = Some(1);\n    }\n    result\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn prefilter_restart<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    at: usize,\n) -> Result<StateID, MatchError> {\n    let mut input = input.clone();\n    input.set_start(at);\n    init_fwd(dfa, &input)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn eoi_fwd<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n    sid: &mut StateID,\n    mat: &mut Option<HalfMatch>,\n) -> Result<(), MatchError> {\n    let sp = input.get_span();\n    match input.haystack().get(sp.end) {\n        Some(&b) => {\n            *sid = dfa.next_state(*sid, b);\n            if dfa.is_match_state(*sid) {\n                let pattern = dfa.match_pattern(*sid, 0);\n                *mat = Some(HalfMatch::new(pattern, sp.end));\n            } else if dfa.is_quit_state(*sid) {\n                return Err(MatchError::quit(b, sp.end));\n            }\n        }\n        None => {\n            *sid = dfa.next_eoi_state(*sid);\n            if dfa.is_match_state(*sid) {\n                let pattern = dfa.match_pattern(*sid, 0);\n                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));\n            }\n        }\n    }\n    Ok(())\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\npub(crate) fn find_fwd(needles: &[u8], haystack: &[u8], at: usize) -> Option<usize> {\n    let bs = needles;\n    let i = match needles.len() {\n        1 => memchr::memchr(bs[0], &haystack[at..])?,\n        2 => memchr::memchr2(bs[0], bs[1], &haystack[at..])?,\n        3 => memchr::memchr3(bs[0], bs[1], bs[2], &haystack[at..])?,\n        0 => panic!(\"cannot find with empty needles\"),\n        n => panic!(\"invalid needles length: {}\", n),\n    };\n    Some(at + i)\n}\n#[cfg_attr(feature = \"perf-inline\", inline(always))]\nfn init_fwd<A: Automaton + ?Sized>(\n    dfa: &A,\n    input: &Input<'_>,\n) -> Result<StateID, MatchError> {\n    let sid = dfa.start_state_forward(input)?;\n    debug_assert!(! dfa.is_match_state(sid));\n    Ok(sid)\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n334 fn find_overlapping_fwd_imp<A: Automaton + ?Sized>(\n335     dfa: &A,\n336     input: &Input<'_>,\n337     pre: Option<&'_ Prefilter>,\n338     state: &mut OverlappingState,\n339 ) -> Result<(), MatchError> {\n340     // See 'prefilter_restart' docs for explanation.\n341     let universal_start = dfa.universal_start_state(Anchored::No).is_some();\n342     let mut sid = match state.id {\n343         None => {\n344             state.at = input.start();\n345             init_fwd(dfa, input)?\n346         }\n347         Some(sid) => {\n348             if let Some(match_index) = state.next_match_index {\n349                 let match_len = dfa.match_len(sid);\n350                 if match_index < match_len {\n351                     state.next_match_index = Some(match_index + 1);\n352                     let pattern = dfa.match_pattern(sid, match_index);\n353                     state.mat = Some(HalfMatch::new(pattern, state.at));\n354                     return Ok(());\n355                 }\n356             }\n357             // Once we've reported all matches at a given position, we need to\n358             // advance the search to the next position.\n359             state.at += 1;\n360             if state.at > input.end() {\n361                 return Ok(());\n362             }\n363             sid\n364         }\n365     };\n366 \n367     // NOTE: We don't optimize the crap out of this routine primarily because\n368     // it seems like most find_overlapping searches will have higher match\n369     // counts, and thus, throughput is perhaps not as important. But if you\n370     // have a use case for something faster, feel free to file an issue.\n371     while state.at < input.end() {\n372         sid = dfa.next_state(sid, input.haystack()[state.at]);\n373         if dfa.is_special_state(sid) {\n374             state.id = Some(sid);\n375             if dfa.is_start_state(sid) {\n376                 if let Some(ref pre) = pre {\n377                     let span = Span::from(state.at..input.end());\n378                     match pre.find(input.haystack(), span) {\n379                         None => return Ok(()),\n380                         Some(ref span) => {\n381                             if span.start > state.at {\n382                                 state.at = span.start;\n383                                 if !universal_start {\n384                                     sid = prefilter_restart(\n385                                         dfa, &input, state.at,\n386                                     )?;\n387                                 }\n388                                 continue;\n389                             }\n390                         }\n391                     }\n392                 } else if dfa.is_accel_state(sid) {\n393                     let needles = dfa.accelerator(sid);\n394                     state.at = accel::find_fwd(\n395                         needles,\n396                         input.haystack(),\n397                         state.at + 1,\n398                     )\n399                     .unwrap_or(input.end());\n400                     continue;\n401                 }\n402             } else if dfa.is_match_state(sid) {\n403                 state.next_match_index = Some(1);\n404                 let pattern = dfa.match_pattern(sid, 0);\n405                 state.mat = Some(HalfMatch::new(pattern, state.at));\n406                 return Ok(());\n407             } else if dfa.is_accel_state(sid) {\n408                 let needs = dfa.accelerator(sid);\n409                 // If the accelerator returns nothing, why don't we quit the\n410                 // search? Well, if the accelerator doesn't find anything, that\n411                 // doesn't mean we don't have a match. It just means that we\n412                 // can't leave the current state given one of the 255 possible\n413                 // byte values. However, there might be an EOI transition. So\n414                 // we set 'at' to the end of the haystack, which will cause\n415                 // this loop to stop and fall down into the EOI transition.\n416                 state.at =\n417                     accel::find_fwd(needs, input.haystack(), state.at + 1)\n418                         .unwrap_or(input.end());\n419                 continue;\n420             } else if dfa.is_dead_state(sid) {\n421                 return Ok(());\n422             } else {\n423                 return Err(MatchError::quit(\n424                     input.haystack()[state.at],\n425                     state.at,\n426                 ));\n427             }\n428         }\n429         state.at += 1;\n430     }\n431 \n432     let result = eoi_fwd(dfa, input, &mut sid, &mut state.mat);\n433     state.id = Some(sid);\n434     if state.mat.is_some() {\n435         // '1' is always correct here since if we get to this point, this\n436         // always corresponds to the first (index '0') match discovered at\n437         // this position. So the next match to report at this position (if\n438         // it exists) is at index '1'.\n439         state.next_match_index = Some(1);\n440     }\n441     result\n442 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}