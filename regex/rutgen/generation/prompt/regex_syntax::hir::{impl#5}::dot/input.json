{
  "system_pt": "As a software testing expert, infer the test input conditions or ranges based on the provided information. Follow these guidelines:\n1. Provide test input conditions or ranges in one line in plain text only, without additional explanations or Markdown formatting\n2. Analyze the function under test, context, preconditions, and expected return values or types to determine appropriate test input conditions or ranges\n3. The inferred test input conditions or ranges should comprehensively satisfy all provided preconditions simultaneously.\n4. Ensure the test input conditions or ranges cover boundary cases and edge scenarios\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/mod.rs\n// crate name is regex_syntax\nuse core::{char, cmp};\nuse alloc::{\n    boxed::Box, format, string::{String, ToString},\n    vec, vec::Vec,\n};\nuse crate::{\n    ast::Span, hir::interval::{Interval, IntervalSet, IntervalSetIter},\n    unicode,\n};\npub use crate::{\n    hir::visitor::{visit, Visitor},\n    unicode::CaseFoldError,\n};\n#[derive(Clone, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}\n#[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]\npub struct ClassUnicodeRange {\n    start: char,\n    end: char,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Properties(Box<PropertiesI>);\n#[derive(Clone, Eq, PartialEq)]\npub enum Class {\n    /// A set of characters represented by Unicode scalar values.\n    Unicode(ClassUnicode),\n    /// A set of characters represented by arbitrary bytes (one byte per\n    /// character).\n    Bytes(ClassBytes),\n}\n#[non_exhaustive]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub enum Dot {\n    /// Matches the UTF-8 encoding of any Unicode scalar value.\n    ///\n    /// This is equivalent to `(?su:.)` and also `\\p{any}`.\n    AnyChar,\n    /// Matches any byte value.\n    ///\n    /// This is equivalent to `(?s-u:.)` and also `(?-u:[\\x00-\\xFF])`.\n    AnyByte,\n    /// Matches the UTF-8 encoding of any Unicode scalar value except for the\n    /// `char` given.\n    ///\n    /// This is equivalent to using `(?u-s:.)` with the line terminator set\n    /// to a particular ASCII byte. (Because of peculiarities in the regex\n    /// engines, a line terminator must be a single byte. It follows that when\n    /// UTF-8 mode is enabled, this single byte must also be a Unicode scalar\n    /// value. That is, ti must be ASCII.)\n    ///\n    /// (This and `AnyCharExceptLF` both exist because of legacy reasons.\n    /// `AnyCharExceptLF` will be dropped in the next breaking change release.)\n    AnyCharExcept(char),\n    /// Matches the UTF-8 encoding of any Unicode scalar value except for `\\n`.\n    ///\n    /// This is equivalent to `(?u-s:.)` and also `[\\p{any}--\\n]`.\n    AnyCharExceptLF,\n    /// Matches the UTF-8 encoding of any Unicode scalar value except for `\\r`\n    /// and `\\n`.\n    ///\n    /// This is equivalent to `(?uR-s:.)` and also `[\\p{any}--\\r\\n]`.\n    AnyCharExceptCRLF,\n    /// Matches any byte value except for the `u8` given.\n    ///\n    /// This is equivalent to using `(?-us:.)` with the line terminator set\n    /// to a particular ASCII byte. (Because of peculiarities in the regex\n    /// engines, a line terminator must be a single byte. It follows that when\n    /// UTF-8 mode is enabled, this single byte must also be a Unicode scalar\n    /// value. That is, ti must be ASCII.)\n    ///\n    /// (This and `AnyByteExceptLF` both exist because of legacy reasons.\n    /// `AnyByteExceptLF` will be dropped in the next breaking change release.)\n    AnyByteExcept(u8),\n    /// Matches any byte value except for `\\n`.\n    ///\n    /// This is equivalent to `(?-su:.)` and also `(?-u:[[\\x00-\\xFF]--\\n])`.\n    AnyByteExceptLF,\n    /// Matches any byte value except for `\\r` and `\\n`.\n    ///\n    /// This is equivalent to `(?R-su:.)` and also `(?-u:[[\\x00-\\xFF]--\\r\\n])`.\n    AnyByteExceptCRLF,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum HirKind {\n    /// The empty regular expression, which matches everything, including the\n    /// empty string.\n    Empty,\n    /// A literalstring that matches exactly these bytes.\n    Literal(Literal),\n    /// A single character class that matches any of the characters in the\n    /// class. A class can either consist of Unicode scalar values as\n    /// characters, or it can use bytes.\n    ///\n    /// A class may be empty. In which case, it matches nothing.\n    Class(Class),\n    /// A look-around assertion. A look-around match always has zero length.\n    Look(Look),\n    /// A repetition operation applied to a sub-expression.\n    Repetition(Repetition),\n    /// A capturing group, which contains a sub-expression.\n    Capture(Capture),\n    /// A concatenation of expressions.\n    ///\n    /// A concatenation matches only if each of its sub-expressions match one\n    /// after the other.\n    ///\n    /// Concatenations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Concat(Vec<Hir>),\n    /// An alternation of expressions.\n    ///\n    /// An alternation matches only if at least one of its sub-expressions\n    /// match. If multiple sub-expressions match, then the leftmost is\n    /// preferred.\n    ///\n    /// Alternations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Alternation(Vec<Hir>),\n}\nimpl Hir {\n    #[inline]\n    pub fn empty() -> Hir {}\n    #[inline]\n    pub fn fail() -> Hir {}\n    #[inline]\n    pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir {}\n    #[inline]\n    pub fn class(class: Class) -> Hir {\n        if class.is_empty() {\n            return Hir::fail();\n        } else if let Some(bytes) = class.literal() {\n            return Hir::literal(bytes);\n        }\n        let props = Properties::class(&class);\n        Hir {\n            kind: HirKind::Class(class),\n            props,\n        }\n    }\n    #[inline]\n    pub fn look(look: Look) -> Hir {}\n    #[inline]\n    pub fn repetition(mut rep: Repetition) -> Hir {}\n    #[inline]\n    pub fn capture(capture: Capture) -> Hir {}\n    pub fn concat(subs: Vec<Hir>) -> Hir {}\n    pub fn alternation(subs: Vec<Hir>) -> Hir {}\n    #[inline]\n    pub fn dot(dot: Dot) -> Hir {\n        match dot {\n            Dot::AnyChar => {\n                Hir::class(\n                    Class::Unicode(\n                        ClassUnicode::new([ClassUnicodeRange::new('\\0', '\\u{10FFFF}')]),\n                    ),\n                )\n            }\n            Dot::AnyByte => {\n                Hir::class(\n                    Class::Bytes(ClassBytes::new([ClassBytesRange::new(b'\\0', b'\\xFF')])),\n                )\n            }\n            Dot::AnyCharExcept(ch) => {\n                let mut cls = ClassUnicode::new([ClassUnicodeRange::new(ch, ch)]);\n                cls.negate();\n                Hir::class(Class::Unicode(cls))\n            }\n            Dot::AnyCharExceptLF => {\n                Hir::class(\n                    Class::Unicode(\n                        ClassUnicode::new([\n                            ClassUnicodeRange::new('\\0', '\\x09'),\n                            ClassUnicodeRange::new('\\x0B', '\\u{10FFFF}'),\n                        ]),\n                    ),\n                )\n            }\n            Dot::AnyCharExceptCRLF => {\n                Hir::class(\n                    Class::Unicode(\n                        ClassUnicode::new([\n                            ClassUnicodeRange::new('\\0', '\\x09'),\n                            ClassUnicodeRange::new('\\x0B', '\\x0C'),\n                            ClassUnicodeRange::new('\\x0E', '\\u{10FFFF}'),\n                        ]),\n                    ),\n                )\n            }\n            Dot::AnyByteExcept(byte) => {\n                let mut cls = ClassBytes::new([ClassBytesRange::new(byte, byte)]);\n                cls.negate();\n                Hir::class(Class::Bytes(cls))\n            }\n            Dot::AnyByteExceptLF => {\n                Hir::class(\n                    Class::Bytes(\n                        ClassBytes::new([\n                            ClassBytesRange::new(b'\\0', b'\\x09'),\n                            ClassBytesRange::new(b'\\x0B', b'\\xFF'),\n                        ]),\n                    ),\n                )\n            }\n            Dot::AnyByteExceptCRLF => {\n                Hir::class(\n                    Class::Bytes(\n                        ClassBytes::new([\n                            ClassBytesRange::new(b'\\0', b'\\x09'),\n                            ClassBytesRange::new(b'\\x0B', b'\\x0C'),\n                            ClassBytesRange::new(b'\\x0E', b'\\xFF'),\n                        ]),\n                    ),\n                )\n            }\n        }\n    }\n}\nimpl ClassBytes {\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {\n        ClassBytes {\n            set: IntervalSet::new(ranges),\n        }\n    }\n    pub fn empty() -> ClassBytes {}\n    pub fn push(&mut self, range: ClassBytesRange) {}\n    pub fn iter(&self) -> ClassBytesIter<'_> {}\n    pub fn ranges(&self) -> &[ClassBytesRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n    pub fn union(&mut self, other: &ClassBytes) {}\n    pub fn intersect(&mut self, other: &ClassBytes) {}\n    pub fn difference(&mut self, other: &ClassBytes) {}\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_unicode_class(&self) -> Option<ClassUnicode> {}\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {\n        ClassUnicode {\n            set: IntervalSet::new(ranges),\n        }\n    }\n    pub fn empty() -> ClassUnicode {}\n    pub fn push(&mut self, range: ClassUnicodeRange) {}\n    pub fn iter(&self) -> ClassUnicodeIter<'_> {}\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn try_case_fold_simple(&mut self) -> core::result::Result<(), CaseFoldError> {}\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n    pub fn union(&mut self, other: &ClassUnicode) {}\n    pub fn intersect(&mut self, other: &ClassUnicode) {}\n    pub fn difference(&mut self, other: &ClassUnicode) {}\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {}\n    pub fn is_ascii(&self) -> bool {}\n    pub fn minimum_len(&self) -> Option<usize> {}\n    pub fn maximum_len(&self) -> Option<usize> {}\n    pub fn literal(&self) -> Option<Vec<u8>> {}\n    pub fn to_byte_class(&self) -> Option<ClassBytes> {}\n}\nimpl ClassBytesRange {\n    pub fn new(start: u8, end: u8) -> ClassBytesRange {\n        ClassBytesRange::create(start, end)\n    }\n    pub fn start(&self) -> u8 {}\n    pub fn end(&self) -> u8 {}\n    pub fn len(&self) -> usize {}\n}\nimpl ClassUnicodeRange {\n    pub fn new(start: char, end: char) -> ClassUnicodeRange {\n        ClassUnicodeRange::create(start, end)\n    }\n    pub fn start(&self) -> char {}\n    pub fn end(&self) -> char {}\n    pub fn len(&self) -> usize {}\n}\n\nThe function to be tested is presented with each line formatted as 'line number + code':\n/// Returns an HIR expression for `.`.\n///\n/// * [`Dot::AnyChar`] maps to `(?su-R:.)`.\n/// * [`Dot::AnyByte`] maps to `(?s-Ru:.)`.\n/// * [`Dot::AnyCharExceptLF`] maps to `(?u-Rs:.)`.\n/// * [`Dot::AnyCharExceptCRLF`] maps to `(?Ru-s:.)`.\n/// * [`Dot::AnyByteExceptLF`] maps to `(?-Rsu:.)`.\n/// * [`Dot::AnyByteExceptCRLF`] maps to `(?R-su:.)`.\n///\n/// # Example\n///\n/// Note that this is a convenience routine for constructing the correct\n/// character class based on the value of `Dot`. There is no explicit \"dot\"\n/// HIR value. It is just an abbreviation for a common character class.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, Dot, Class, ClassBytes, ClassBytesRange};\n///\n/// let hir = Hir::dot(Dot::AnyByte);\n/// let expected = Hir::class(Class::Bytes(ClassBytes::new([\n///     ClassBytesRange::new(0x00, 0xFF),\n/// ])));\n/// assert_eq!(expected, hir);\n/// ```\n659 pub fn dot(dot: Dot) -> Hir {\n660     match dot {\n661         Dot::AnyChar => Hir::class(Class::Unicode(ClassUnicode::new([\n662             ClassUnicodeRange::new('\\0', '\\u{10FFFF}'),\n663         ]))),\n664         Dot::AnyByte => Hir::class(Class::Bytes(ClassBytes::new([\n665             ClassBytesRange::new(b'\\0', b'\\xFF'),\n666         ]))),\n667         Dot::AnyCharExcept(ch) => {\n668             let mut cls =\n669                 ClassUnicode::new([ClassUnicodeRange::new(ch, ch)]);\n670             cls.negate();\n671             Hir::class(Class::Unicode(cls))\n672         }\n673         Dot::AnyCharExceptLF => {\n674             Hir::class(Class::Unicode(ClassUnicode::new([\n675                 ClassUnicodeRange::new('\\0', '\\x09'),\n676                 ClassUnicodeRange::new('\\x0B', '\\u{10FFFF}'),\n677             ])))\n678         }\n679         Dot::AnyCharExceptCRLF => {\n680             Hir::class(Class::Unicode(ClassUnicode::new([\n681                 ClassUnicodeRange::new('\\0', '\\x09'),\n682                 ClassUnicodeRange::new('\\x0B', '\\x0C'),\n683                 ClassUnicodeRange::new('\\x0E', '\\u{10FFFF}'),\n684             ])))\n685         }\n686         Dot::AnyByteExcept(byte) => {\n687             let mut cls =\n688                 ClassBytes::new([ClassBytesRange::new(byte, byte)]);\n689             cls.negate();\n690             Hir::class(Class::Bytes(cls))\n691         }\n692         Dot::AnyByteExceptLF => {\n693             Hir::class(Class::Bytes(ClassBytes::new([\n694                 ClassBytesRange::new(b'\\0', b'\\x09'),\n695                 ClassBytesRange::new(b'\\x0B', b'\\xFF'),\n696             ])))\n697         }\n698         Dot::AnyByteExceptCRLF => {\n699             Hir::class(Class::Bytes(ClassBytes::new([\n700                 ClassBytesRange::new(b'\\0', b'\\x09'),\n701                 ClassBytesRange::new(b'\\x0B', b'\\x0C'),\n702                 ClassBytesRange::new(b'\\x0E', b'\\xFF'),\n703             ])))\n704         }\n705     }\n706 }\n\nWhen inferring test input conditions or ranges, consider the following preconditions and expected return values or types:\n"
}