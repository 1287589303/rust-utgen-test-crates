{
  "name": "regex_automata::util::utf8::is_boundary",
  "mod_info": {
    "name": "util::utf8",
    "loc": "regex-automata/src/util/mod.rs:57:1:57:21"
  },
  "visible": true,
  "loc": "regex-automata/src/util/utf8.rs:123:1:137:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: bytes.get(i) matches Some(&b) at line 124 is true\n",
        "precondition: b <= 0b0111_1111 at line 135 is true, with bound b == 0b0111_1111\n",
        "expected return value/type: b <= 0b0111_1111 || b >= 0b1100_0000\n"
      ],
      "input_infer": "bytes: [0x00, 0x7F, 0xC0, 0xC1, 0xFF], i: 0 to 4\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0x00, 0x7F];",
                "    let i = 0;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);  // Testing for boundary at i=0 with b == 0x00 (ASCII)",
                "    let i = 1;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    assert_eq!(result, true);  // Testing for boundary at i=1 with b == 0x7F (ASCII)",
                "    let i = 2;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    assert_eq!(result, false); // Testing for out-of-bounds index i=2"
              ],
              "code": [
                "{",
                "    let bytes = [0x00, 0x7F];",
                "    let i = 0;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    assert_eq!(result, true);  // Testing for boundary at i=0 with b == 0x00 (ASCII)",
                "    let i = 1;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    assert_eq!(result, true);  // Testing for boundary at i=1 with b == 0x7F (ASCII)",
                "    let i = 2;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    assert_eq!(result, false); // Testing for out-of-bounds index i=2",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0x00, 0x7F];",
                "    let i = 1;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let bytes = [0x00, 0x7F];",
                "    let i = 1;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0xC0, 0xC1, 0xFF];",
                "    let i = 0;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    let bytes = [0x7F]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), false);",
                "    let bytes = [0x7F, 0xC0]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0xC0, 0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), false);",
                "    let bytes = [0xFF]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), false);"
              ],
              "code": [
                "{",
                "    let bytes = [0xC0, 0xC1, 0xFF];",
                "    let i = 0;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    let bytes = [0x7F]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), false);",
                "    let bytes = [0x7F, 0xC0]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0xC0, 0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), false);",
                "    let bytes = [0xFF]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0xC0, 0xC1, 0xFF];",
                "    let i = 1;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    let bytes = [0x7F]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x7F, 0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x7F, 0x80]; let i = 1; assert_eq!(regex_automata::is_boundary(&bytes, i), false);"
              ],
              "code": [
                "{",
                "    let bytes = [0xC0, 0xC1, 0xFF];",
                "    let i = 1;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    let bytes = [0x7F]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x7F, 0x80]; let i = 0; assert_eq!(regex_automata::is_boundary(&bytes, i), true);",
                "    let bytes = [0x7F, 0x80]; let i = 1; assert_eq!(regex_automata::is_boundary(&bytes, i), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0xC0, 0xC1, 0xFF];",
                "    let i = 2;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let bytes = [0xC0, 0xC1, 0xFF];",
                "    let i = 2;",
                "    let result = regex_automata::is_boundary(&bytes, i);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: bytes.get(i) matches Some(&b) at line 124 is true\n",
        "precondition: b <= 0b0111_1111 at line 135 is false\n",
        "expected return value/type: b >= 0b1100_0000\n"
      ],
      "input_infer": "bytes: [0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], i: 0 to 3 (inclusive)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0b1000_0000];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    let bytes = [0b1000_0000]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1100_0000]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1111_1111]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1000_0001]; let i = 0; assert_eq!(is_boundary(&bytes, i), false);",
                "    let bytes = [0b1000_0000, 0b1010_0000]; let i = 1; assert_eq!(is_boundary(&bytes, i), false);",
                "    let bytes = [0b1100_0001]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1110_0000]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1100_0000, 0b1010_0000]; let i = 1; assert_eq!(is_boundary(&bytes, i), false);",
                "    let bytes = [0b1111_1110]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b0111_1111]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);"
              ],
              "code": [
                "{",
                "    let bytes = [0b1000_0000];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "    let bytes = [0b1000_0000]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1100_0000]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1111_1111]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1000_0001]; let i = 0; assert_eq!(is_boundary(&bytes, i), false);",
                "    let bytes = [0b1000_0000, 0b1010_0000]; let i = 1; assert_eq!(is_boundary(&bytes, i), false);",
                "    let bytes = [0b1100_0001]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1110_0000]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b1100_0000, 0b1010_0000]; let i = 1; assert_eq!(is_boundary(&bytes, i), false);",
                "    let bytes = [0b1111_1110]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "    let bytes = [0b0111_1111]; let i = 0; assert_eq!(is_boundary(&bytes, i), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0b1100_0001];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(is_boundary(&[0b1100_0001], 0), true);"
              ],
              "code": [
                "{",
                "    let bytes = [0b1100_0001];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "    assert_eq!(is_boundary(&[0b1100_0001], 0), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0b1100_0000];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(is_boundary(&[0b1100_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0001], 0), true);",
                "    assert_eq!(is_boundary(&[0b1111_1111], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0000, 0b0010_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0001, 0b0010_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1111_1111, 0b0000_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0000, 0b1100_0010], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0001, 0b1100_0010], 0), true);",
                "    assert_eq!(is_boundary(&[0b1111_1111, 0b1100_0010], 0), true);"
              ],
              "code": [
                "{",
                "    let bytes = [0b1100_0000];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "    assert_eq!(is_boundary(&[0b1100_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0001], 0), true);",
                "    assert_eq!(is_boundary(&[0b1111_1111], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0000, 0b0010_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0001, 0b0010_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1111_1111, 0b0000_0000], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0000, 0b1100_0010], 0), true);",
                "    assert_eq!(is_boundary(&[0b1100_0001, 0b1100_0010], 0), true);",
                "    assert_eq!(is_boundary(&[0b1111_1111, 0b1100_0010], 0), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0b1111_1111];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(is_boundary(&[0b1111_1111], 0), true);"
              ],
              "code": [
                "{",
                "    let bytes = [0b1111_1111];",
                "    let i = 0;",
                "    let _ = is_boundary(&bytes, i);",
                "    assert_eq!(is_boundary(&[0b1111_1111], 0), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111];",
                "    let i = 1;",
                "    let _ = is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 1), true);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0000, 0b1111_1111], 1), false);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0011], 1), false);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1101_0001], 1), true);",
                "    assert_eq!(is_boundary(&[0b1100_0000, 0b1111_1111], 0), false);"
              ],
              "code": [
                "{",
                "    let bytes = [0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111];",
                "    let i = 1;",
                "    let _ = is_boundary(&bytes, i);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 1), true);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0000, 0b1111_1111], 1), false);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0011], 1), false);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1101_0001], 1), true);",
                "    assert_eq!(is_boundary(&[0b1100_0000, 0b1111_1111], 0), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111];",
                "    let i = 2;",
                "    let _ = is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 2), true);"
              ],
              "code": [
                "{",
                "    let bytes = [0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111];",
                "    let i = 2;",
                "    let _ = is_boundary(&bytes, i);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 2), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes = [0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111];",
                "    let i = 3;",
                "    let _ = is_boundary(&bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 0), false);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 1), true);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 2), true);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 3), true);"
              ],
              "code": [
                "{",
                "    let bytes = [0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111];",
                "    let i = 3;",
                "    let _ = is_boundary(&bytes, i);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 0), false);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 1), true);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 2), true);",
                "    assert_eq!(is_boundary(&[0b1000_0000, 0b1100_0001, 0b1100_0000, 0b1111_1111], 3), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: bytes.get(i) matches None at line 124 is true\n",
        "precondition: bytes.get(i) matches None at line 124 is true\n",
        "expected return value/type: i == bytes.len()\n"
      ],
      "input_infer": "bytes: &[u8] with length 0 to at least match `None`, i: usize in the range [0, bytes.len()] inclusive where bytes.len() >= 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes: &[u8] = &[];",
                "    let i = 0;",
                "    let result = is_boundary(bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let bytes: &[u8] = &[];",
                "    let i = 0;",
                "    let result = is_boundary(bytes, i);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes: &[u8] = &[b'a', b'b', b'c'];",
                "    let i = bytes.len();",
                "    let result = is_boundary(bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let bytes: &[u8] = &[b'a', b'b', b'c'];",
                "    let i = bytes.len();",
                "    let result = is_boundary(bytes, i);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes: &[u8] = &[b'a', b'b', b'c'];",
                "    let i = bytes.len() + 1;",
                "    let result = is_boundary(bytes, i);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, true);"
              ],
              "code": [
                "{",
                "    let bytes: &[u8] = &[b'a', b'b', b'c'];",
                "    let i = bytes.len() + 1;",
                "    let result = is_boundary(bytes, i);",
                "    assert_eq!(result, true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}