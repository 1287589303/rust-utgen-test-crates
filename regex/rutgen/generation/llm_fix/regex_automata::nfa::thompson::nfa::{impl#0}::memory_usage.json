{
  "name": "regex_automata::nfa::thompson::nfa::{impl#0}::memory_usage",
  "mod_info": {
    "name": "nfa::thompson::nfa",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:66:1:66:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/nfa.rs:1169:5:1177:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: size_of::<Inner>() // allocated on the heap via Arc\n            + self.0.states.len() * size_of::<State>()\n            + self.0.start_pattern.len() * size_of::<StateID>()\n            + self.0.group_info.memory_usage()\n            + self.0.memory_extra\n"
      ],
      "input_infer": "Test input conditions or ranges: Test NFA instances with varying numbers of states (0, 1, and large counts), different patterns (including empty, single, and complex patterns), group info with varying numbers of groups (0 and multiple), and toggle UTF-8 and capture settings to assess memory usage impact.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::never_match();",
                "    let _ = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 0 * size_of::<State>() + 0 * size_of::<StateID>() + nfa.group_info().memory_usage() + 0);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::never_match();",
                "    let _ = nfa.memory_usage();",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 0 * size_of::<State>() + 0 * size_of::<StateID>() + nfa.group_info().memory_usage() + 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::always_match();",
                "    let _ = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 0 * size_of::<State>() + 0 * size_of::<StateID>() + nfa.group_info().memory_usage() + 0);",
                "    let nfa_large = NFA::new(r\"\\w\").unwrap();",
                "    let nfa_small = NFA::new(r\"(?-u:\\w)\").unwrap();",
                "    assert!(10 * nfa_small.memory_usage() < nfa_large.memory_usage());",
                "    assert!(nfa.memory_usage() > 0);",
                "    let nfa_empty = NFA::never_match();",
                "    assert_eq!(nfa_empty.memory_usage(), size_of::<Inner>() + 0 * size_of::<State>() + 0 * size_of::<StateID>() + nfa_empty.group_info().memory_usage() + 0);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::always_match();",
                "    let _ = nfa.memory_usage();",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 0 * size_of::<State>() + 0 * size_of::<StateID>() + nfa.group_info().memory_usage() + 0);",
                "    let nfa_large = NFA::new(r\"\\w\").unwrap();",
                "    let nfa_small = NFA::new(r\"(?-u:\\w)\").unwrap();",
                "    assert!(10 * nfa_small.memory_usage() < nfa_large.memory_usage());",
                "    assert!(nfa.memory_usage() > 0);",
                "    let nfa_empty = NFA::never_match();",
                "    assert_eq!(nfa_empty.memory_usage(), size_of::<Inner>() + 0 * size_of::<State>() + 0 * size_of::<StateID>() + nfa_empty.group_info().memory_usage() + 0);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(\"a\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 1 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + 0);",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 1 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "    assert!(nfa.memory_usage() >= size_of::<Inner>());",
                "    assert!(nfa.memory_usage() >= nfa.start_pattern.len() * size_of::<StateID>());",
                "    assert!(nfa.memory_usage() >= nfa.group_info.memory_usage());"
              ],
              "code": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(\"a\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 1 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + 0);",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 1 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "    assert!(nfa.memory_usage() >= size_of::<Inner>());",
                "    assert!(nfa.memory_usage() >= nfa.start_pattern.len() * size_of::<StateID>());",
                "    assert!(nfa.memory_usage() >= nfa.group_info.memory_usage());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"(a|b|c)+\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);"
              ],
              "code": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"(a|b|c)+\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    for _ in 0..1000 {",
                "        builder.add_state(State::Match { pattern_id: PatternID::default() });",
                "    }",
                "    let nfa = builder.build().unwrap();",
                "    let _ = nfa.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert!(nfa.memory_usage() >= size_of::<Inner>());",
                "    assert!(nfa.memory_usage() >= nfa.states().len() * size_of::<State>());",
                "    assert!(nfa.memory_usage() >= nfa.start_pattern().len() * size_of::<StateID>());",
                "    assert!(nfa.memory_usage() >= nfa.group_info().memory_usage());",
                "    assert!(nfa.memory_usage() >= nfa.memory_extra);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    for _ in 0..1000 {",
                "        builder.add_state(State::Match { pattern_id: PatternID::default() });",
                "    }",
                "    let nfa = builder.build().unwrap();",
                "    let _ = nfa.memory_usage();",
                "    assert!(nfa.memory_usage() >= size_of::<Inner>());",
                "    assert!(nfa.memory_usage() >= nfa.states().len() * size_of::<State>());",
                "    assert!(nfa.memory_usage() >= nfa.start_pattern().len() * size_of::<StateID>());",
                "    assert!(nfa.memory_usage() >= nfa.group_info().memory_usage());",
                "    assert!(nfa.memory_usage() >= nfa.memory_extra);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"(a)(b)\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 2 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.0.memory_extra);"
              ],
              "code": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"(a)(b)\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 2 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.0.memory_extra);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"\\w\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "    assert!(nfa.memory_usage() > 0);",
                "    assert!(nfa.memory_usage() >= size_of::<Inner>());",
                "    assert_eq!(nfa.memory_usage(), nfa.memory_usage());",
                "    assert_ne!(nfa.memory_usage(), 0);",
                "    assert!(nfa.memory_usage() > size_of::<State>() * nfa.states().len());"
              ],
              "code": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"\\w\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "    assert!(nfa.memory_usage() > 0);",
                "    assert!(nfa.memory_usage() >= size_of::<Inner>());",
                "    assert_eq!(nfa.memory_usage(), nfa.memory_usage());",
                "    assert_ne!(nfa.memory_usage(), 0);",
                "    assert!(nfa.memory_usage() > size_of::<State>() * nfa.states().len());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"(?P<name>a)\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "}"
              ],
              "oracle": [
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 1 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + 0);",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);"
              ],
              "code": [
                "{",
                "    #[cfg(feature = \"syntax\")]",
                "    {",
                "        let nfa = NFA::new(r\"(?P<name>a)\").unwrap();",
                "        let _ = nfa.memory_usage();",
                "    }",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + 1 * size_of::<State>() + 1 * size_of::<StateID>() + nfa.group_info.memory_usage() + 0);",
                "    assert_eq!(nfa.memory_usage(), size_of::<Inner>() + nfa.states().len() * size_of::<State>() + nfa.start_pattern.len() * size_of::<StateID>() + nfa.group_info.memory_usage() + nfa.memory_extra);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}