{
  "name": "regex_automata::hybrid::dfa::{impl#8}::overwrite",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": false,
  "loc": "regex-automata/src/hybrid/dfa.rs:3879:5:3905:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Config {\n            match_kind: o.match_kind.or(self.match_kind),\n            pre: o.pre.or_else(|| self.pre.clone()),\n            starts_for_each_pattern: o\n                .starts_for_each_pattern\n                .or(self.starts_for_each_pattern),\n            byte_classes: o.byte_classes.or(self.byte_classes),\n            unicode_word_boundary: o\n                .unicode_word_boundary\n                .or(self.unicode_word_boundary),\n            quitset: o.quitset.or(self.quitset),\n            specialize_start_states: o\n                .specialize_start_states\n                .or(self.specialize_start_states),\n            cache_capacity: o.cache_capacity.or(self.cache_capacity),\n            skip_cache_capacity_check: o\n                .skip_cache_capacity_check\n                .or(self.skip_cache_capacity_check),\n            minimum_cache_clear_count: o\n                .minimum_cache_clear_count\n                .or(self.minimum_cache_clear_count),\n            minimum_bytes_per_state: o\n                .minimum_bytes_per_state\n                .or(self.minimum_bytes_per_state),\n        }\n"
      ],
      "input_infer": "Config with all options set (match_kind: MatchKind::All/LeftmostFirst, pre: Some(Prefilter), starts_for_each_pattern: true/false, byte_classes: true/false, unicode_word_boundary: true/false, quitset: Some(ByteSet), specialize_start_states: true/false, cache_capacity: 0, skip_cache_capacity_check: true/false, minimum_cache_clear_count: Some(0), minimum_bytes_per_state: Some(0)) and a Config with all options unset to test all branches of the overwrite function.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let default_config = Config::new()",
                "        .match_kind(MatchKind::All)",
                "        .prefilter(Some(Prefilter {",
                "            pre: Arc::new(DummyPrefilter {}),",
                "            is_fast: true,",
                "            max_needle_len: 10,",
                "        }))",
                "        .starts_for_each_pattern(true)",
                "        .byte_classes(true)",
                "        .unicode_word_boundary(true)",
                "        .quit(1, true)",
                "        .specialize_start_states(true)",
                "        .cache_capacity(1024)",
                "        .skip_cache_capacity_check(true)",
                "        .minimum_cache_clear_count(Some(0))",
                "        .minimum_bytes_per_state(Some(0));",
                "        ",
                "    let new_config = Config::new()",
                "        .match_kind(MatchKind::LeftmostFirst)",
                "        .prefilter(Some(Prefilter {",
                "            pre: Arc::new(DummyPrefilter {}),",
                "            is_fast: false,",
                "            max_needle_len: 5,",
                "        }))",
                "        .starts_for_each_pattern(false)",
                "        .byte_classes(false)",
                "        .unicode_word_boundary(false)",
                "        .quit(2, false)",
                "        .specialize_start_states(false)",
                "        .cache_capacity(512)",
                "        .skip_cache_capacity_check(false)",
                "        .minimum_cache_clear_count(Some(1))",
                "        .minimum_bytes_per_state(Some(1));",
                "",
                "    let result = default_config.overwrite(new_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.match_kind, MatchKind::LeftmostFirst);",
                "    assert_eq!(result.pre.as_ref().unwrap().is_fast, false);",
                "    assert_eq!(result.pre.as_ref().unwrap().max_needle_len, 5);",
                "    assert_eq!(result.starts_for_each_pattern, false);",
                "    assert_eq!(result.byte_classes, false);",
                "    assert_eq!(result.unicode_word_boundary, false);",
                "    assert_eq!(result.quitset, None);",
                "    assert_eq!(result.specialize_start_states, false);",
                "    assert_eq!(result.cache_capacity, 512);",
                "    assert_eq!(result.skip_cache_capacity_check, false);",
                "    assert_eq!(result.minimum_cache_clear_count, Some(1));",
                "    assert_eq!(result.minimum_bytes_per_state, Some(1));"
              ],
              "code": [
                "{",
                "struct DummyPrefilter;",
                "",
                "impl PrefilterI for DummyPrefilter {}",
                "    let default_config = Config::new()",
                "        .match_kind(MatchKind::All)",
                "        .prefilter(Some(Prefilter {",
                "            pre: Arc::new(DummyPrefilter {}),",
                "            is_fast: true,",
                "            max_needle_len: 10,",
                "        }))",
                "        .starts_for_each_pattern(true)",
                "        .byte_classes(true)",
                "        .unicode_word_boundary(true)",
                "        .quit(1, true)",
                "        .specialize_start_states(true)",
                "        .cache_capacity(1024)",
                "        .skip_cache_capacity_check(true)",
                "        .minimum_cache_clear_count(Some(0))",
                "        .minimum_bytes_per_state(Some(0));",
                "        ",
                "    let new_config = Config::new()",
                "        .match_kind(MatchKind::LeftmostFirst)",
                "        .prefilter(Some(Prefilter {",
                "            pre: Arc::new(DummyPrefilter {}),",
                "            is_fast: false,",
                "            max_needle_len: 5,",
                "        }))",
                "        .starts_for_each_pattern(false)",
                "        .byte_classes(false)",
                "        .unicode_word_boundary(false)",
                "        .quit(2, false)",
                "        .specialize_start_states(false)",
                "        .cache_capacity(512)",
                "        .skip_cache_capacity_check(false)",
                "        .minimum_cache_clear_count(Some(1))",
                "        .minimum_bytes_per_state(Some(1));",
                "",
                "    let result = default_config.overwrite(new_config);",
                "    assert_eq!(result.match_kind, MatchKind::LeftmostFirst);",
                "    assert_eq!(result.pre.as_ref().unwrap().is_fast, false);",
                "    assert_eq!(result.pre.as_ref().unwrap().max_needle_len, 5);",
                "    assert_eq!(result.starts_for_each_pattern, false);",
                "    assert_eq!(result.byte_classes, false);",
                "    assert_eq!(result.unicode_word_boundary, false);",
                "    assert_eq!(result.quitset, None);",
                "    assert_eq!(result.specialize_start_states, false);",
                "    assert_eq!(result.cache_capacity, 512);",
                "    assert_eq!(result.skip_cache_capacity_check, false);",
                "    assert_eq!(result.minimum_cache_clear_count, Some(1));",
                "    assert_eq!(result.minimum_bytes_per_state, Some(1));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let default_config = Config::new();",
                "    ",
                "    let new_config = Config::new();",
                "",
                "    let result = default_config.overwrite(new_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.match_kind, default_config.match_kind);",
                "    assert_eq!(result.pre, default_config.pre);",
                "    assert_eq!(result.starts_for_each_pattern, default_config.starts_for_each_pattern);",
                "    assert_eq!(result.byte_classes, default_config.byte_classes);",
                "    assert_eq!(result.unicode_word_boundary, default_config.unicode_word_boundary);",
                "    assert_eq!(result.quitset, default_config.quitset);",
                "    assert_eq!(result.specialize_start_states, default_config.specialize_start_states);",
                "    assert_eq!(result.cache_capacity, default_config.cache_capacity);",
                "    assert_eq!(result.skip_cache_capacity_check, default_config.skip_cache_capacity_check);",
                "    assert_eq!(result.minimum_cache_clear_count, default_config.minimum_cache_clear_count);",
                "    assert_eq!(result.minimum_bytes_per_state, default_config.minimum_bytes_per_state);"
              ],
              "code": [
                "{",
                "struct DummyPrefilter;",
                "",
                "impl PrefilterI for DummyPrefilter {}",
                "    let default_config = Config::new();",
                "    ",
                "    let new_config = Config::new();",
                "",
                "    let result = default_config.overwrite(new_config);",
                "    assert_eq!(result.match_kind, default_config.match_kind);",
                "    assert_eq!(result.pre, default_config.pre);",
                "    assert_eq!(result.starts_for_each_pattern, default_config.starts_for_each_pattern);",
                "    assert_eq!(result.byte_classes, default_config.byte_classes);",
                "    assert_eq!(result.unicode_word_boundary, default_config.unicode_word_boundary);",
                "    assert_eq!(result.quitset, default_config.quitset);",
                "    assert_eq!(result.specialize_start_states, default_config.specialize_start_states);",
                "    assert_eq!(result.cache_capacity, default_config.cache_capacity);",
                "    assert_eq!(result.skip_cache_capacity_check, default_config.skip_cache_capacity_check);",
                "    assert_eq!(result.minimum_cache_clear_count, default_config.minimum_cache_clear_count);",
                "    assert_eq!(result.minimum_bytes_per_state, default_config.minimum_bytes_per_state);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let default_config = Config::new()",
                "        .match_kind(MatchKind::All)",
                "        .prefilter(None)",
                "        .starts_for_each_pattern(true)",
                "        .byte_classes(false)",
                "        .unicode_word_boundary(false);",
                "        ",
                "    let new_config = Config::new()",
                "        .match_kind(MatchKind::LeftmostFirst)",
                "        .prefilter(Some(Prefilter {",
                "            pre: Arc::new(DummyPrefilter {}),",
                "            is_fast: true,",
                "            max_needle_len: 3,",
                "        }))",
                "        .starts_for_each_pattern(false)",
                "        .cache_capacity(256);",
                "",
                "    let result = default_config.overwrite(new_config);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
                "    assert_eq!(result.pre, Some(Some(Prefilter {",
                "    pre: Arc::new(DummyPrefilter {}),",
                "    is_fast: true,",
                "    max_needle_len: 3,",
                "    })));",
                "    assert_eq!(result.starts_for_each_pattern, true);",
                "    assert_eq!(result.byte_classes, false);",
                "    assert_eq!(result.unicode_word_boundary, false);",
                "    assert_eq!(result.cache_capacity, Some(256));",
                "    assert_eq!(result.quitset, None);",
                "    assert_eq!(result.specialize_start_states, None);",
                "    assert_eq!(result.skip_cache_capacity_check, None);",
                "    assert_eq!(result.minimum_cache_clear_count, None);",
                "    assert_eq!(result.minimum_bytes_per_state, None);"
              ],
              "code": [
                "{",
                "struct DummyPrefilter;",
                "",
                "impl PrefilterI for DummyPrefilter {}",
                "    let default_config = Config::new()",
                "        .match_kind(MatchKind::All)",
                "        .prefilter(None)",
                "        .starts_for_each_pattern(true)",
                "        .byte_classes(false)",
                "        .unicode_word_boundary(false);",
                "        ",
                "    let new_config = Config::new()",
                "        .match_kind(MatchKind::LeftmostFirst)",
                "        .prefilter(Some(Prefilter {",
                "            pre: Arc::new(DummyPrefilter {}),",
                "            is_fast: true,",
                "            max_needle_len: 3,",
                "        }))",
                "        .starts_for_each_pattern(false)",
                "        .cache_capacity(256);",
                "",
                "    let result = default_config.overwrite(new_config);",
                "    assert_eq!(result.match_kind, Some(MatchKind::LeftmostFirst));",
                "    assert_eq!(result.pre, Some(Some(Prefilter {",
                "    pre: Arc::new(DummyPrefilter {}),",
                "    is_fast: true,",
                "    max_needle_len: 3,",
                "    })));",
                "    assert_eq!(result.starts_for_each_pattern, true);",
                "    assert_eq!(result.byte_classes, false);",
                "    assert_eq!(result.unicode_word_boundary, false);",
                "    assert_eq!(result.cache_capacity, Some(256));",
                "    assert_eq!(result.quitset, None);",
                "    assert_eq!(result.specialize_start_states, None);",
                "    assert_eq!(result.skip_cache_capacity_check, None);",
                "    assert_eq!(result.minimum_cache_clear_count, None);",
                "    assert_eq!(result.minimum_bytes_per_state, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}