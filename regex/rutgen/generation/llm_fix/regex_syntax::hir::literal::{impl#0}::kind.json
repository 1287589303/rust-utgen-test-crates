{
  "name": "regex_syntax::hir::literal::{impl#0}::kind",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:42:1:42:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal.rs:220:5:223:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: self\n"
      ],
      "input_infer": "Test input conditions: ExtractKind values (Prefix, Suffix), valid limit class values (0 to NonZeroUsize::MAX), valid limit repeat values (0 to NonZeroUsize::MAX), valid limit literal length values (0 to NonZeroUsize::MAX), valid limit total values (0 to NonZeroUsize::MAX).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix);",
                "}"
              ],
              "oracle": [
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert_eq!(extractor.kind, ExtractKind::Prefix);",
                "    extractor.kind(ExtractKind::Suffix);",
                "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert!(!std::ptr::eq(&extractor.kind(ExtractKind::Prefix), &extractor.kind(ExtractKind::Suffix)));",
                "    extractor.kind(ExtractKind::Suffix);",
                "    assert_ne!(extractor.kind(ExtractKind::Prefix), extractor.kind(ExtractKind::Suffix));",
                "    let extractor2 = extractor.kind(ExtractKind::Suffix);",
                "    assert_eq!(extractor2 as *const _, extractor as *const _);"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix);",
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert_eq!(extractor.kind, ExtractKind::Prefix);",
                "    extractor.kind(ExtractKind::Suffix);",
                "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert!(!std::ptr::eq(&extractor.kind(ExtractKind::Prefix), &extractor.kind(ExtractKind::Suffix)));",
                "    extractor.kind(ExtractKind::Suffix);",
                "    assert_ne!(extractor.kind(ExtractKind::Prefix), extractor.kind(ExtractKind::Suffix));",
                "    let extractor2 = extractor.kind(ExtractKind::Suffix);",
                "    assert_eq!(extractor2 as *const _, extractor as *const _);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Suffix);",
                "}"
              ],
              "oracle": [
                "    let mut extractor = Extractor::new();",
                "    assert_eq!(extractor.kind(ExtractKind::Suffix).kind, ExtractKind::Suffix);",
                "    assert_eq!(extractor.kind(ExtractKind::Prefix).kind, ExtractKind::Prefix);",
                "    assert!(extractor.kind(ExtractKind::Suffix) as *const _ != extractor.kind(ExtractKind::Prefix) as *const _);",
                "    assert!(extractor.kind(ExtractKind::Prefix) as *const _ == extractor.kind(ExtractKind::Prefix) as *const _);",
                "    assert!(extractor.kind(ExtractKind::Suffix) as *const _ != extractor.kind(ExtractKind::Suffix) as *const _);"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Suffix);",
                "    let mut extractor = Extractor::new();",
                "    assert_eq!(extractor.kind(ExtractKind::Suffix).kind, ExtractKind::Suffix);",
                "    assert_eq!(extractor.kind(ExtractKind::Prefix).kind, ExtractKind::Prefix);",
                "    assert!(extractor.kind(ExtractKind::Suffix) as *const _ != extractor.kind(ExtractKind::Prefix) as *const _);",
                "    assert!(extractor.kind(ExtractKind::Prefix) as *const _ == extractor.kind(ExtractKind::Prefix) as *const _);",
                "    assert!(extractor.kind(ExtractKind::Suffix) as *const _ != extractor.kind(ExtractKind::Suffix) as *const _);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix)",
                "             .limit_class(1)",
                "             .limit_repeat(1)",
                "             .limit_literal_len(1)",
                "             .limit_total(1);",
                "}"
              ],
              "oracle": [
                "    extractor.kind(ExtractKind::Prefix) == &mut extractor",
                "    extractor.kind(ExtractKind::Suffix) == &mut extractor",
                "    extractor.kind(ExtractKind::Prefix).limit_class(1) == &mut extractor",
                "    extractor.kind(ExtractKind::Suffix).limit_repeat(2) == &mut extractor",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(3) == &mut extractor",
                "    extractor.kind(ExtractKind::Suffix).limit_total(5) == &mut extractor"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Prefix)",
                "             .limit_class(1)",
                "             .limit_repeat(1)",
                "             .limit_literal_len(1)",
                "             .limit_total(1);",
                "    extractor.kind(ExtractKind::Prefix) == &mut extractor",
                "    extractor.kind(ExtractKind::Suffix) == &mut extractor",
                "    extractor.kind(ExtractKind::Prefix).limit_class(1) == &mut extractor",
                "    extractor.kind(ExtractKind::Suffix).limit_repeat(2) == &mut extractor",
                "    extractor.kind(ExtractKind::Prefix).limit_literal_len(3) == &mut extractor",
                "    extractor.kind(ExtractKind::Suffix).limit_total(5) == &mut extractor",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Suffix)",
                "             .limit_class(0)",
                "             .limit_repeat(0)",
                "             .limit_literal_len(0)",
                "             .limit_total(0);",
                "}"
              ],
              "oracle": [
                "    extractor.kind(ExtractKind::Suffix);",
                "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert_eq!(extractor.kind, ExtractKind::Prefix);"
              ],
              "code": [
                "{",
                "    let mut extractor = Extractor::new();",
                "    extractor.kind(ExtractKind::Suffix)",
                "             .limit_class(0)",
                "             .limit_repeat(0)",
                "             .limit_literal_len(0)",
                "             .limit_total(0);",
                "    extractor.kind(ExtractKind::Suffix);",
                "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
                "    extractor.kind(ExtractKind::Prefix);",
                "    assert_eq!(extractor.kind, ExtractKind::Prefix);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}