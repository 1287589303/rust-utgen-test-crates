{
  "name": "regex_automata::dfa::dense::{impl#25}::write_to",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:4720:5:4741:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: dst.len() < nwrite at line 4733 is true\n",
        "expected return value/type: Err(SerializeError::buffer_too_small(\"flag bitset\"))\n"
      ],
      "input_infer": "dst length < 4 (since nwrite = 4) when has_empty, is_utf8, is_always_start_anchored are true or false in any combination.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: true,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 3]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    flags.write_to::<u32>(&mut dst) // call function with dst smaller than required",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"flag bitset\"))); // check return value"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: true,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 3]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "    flags.write_to::<u32>(&mut dst) // call function with dst smaller than required",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"flag bitset\"))); // check return value",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: true,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 2]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(flags.write_to::<u32>(&mut dst), Err(SerializeError::buffer_too_small(\"flag bitset\")));"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: true,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 2]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "    assert_eq!(flags.write_to::<u32>(&mut dst), Err(SerializeError::buffer_too_small(\"flag bitset\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: false,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 1]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    plaintext",
                "    let flags = Flags { has_empty: true, is_utf8: false, is_always_start_anchored: true };",
                "    let mut dst = [0u8; 1];",
                "    let result = flags.write_to::<u32>(&mut dst);",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"flag bitset\")));"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: false,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 1]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "    plaintext",
                "    let flags = Flags { has_empty: true, is_utf8: false, is_always_start_anchored: true };",
                "    let mut dst = [0u8; 1];",
                "    let result = flags.write_to::<u32>(&mut dst);",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"flag bitset\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: true,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 0]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(flags.write_to::<u32>(&mut dst), Err(SerializeError::buffer_too_small(\"flag bitset\")));"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: true,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 0]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "    assert_eq!(flags.write_to::<u32>(&mut dst), Err(SerializeError::buffer_too_small(\"flag bitset\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: false,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 3]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    let flags = Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false };",
                "    let mut dst = [0u8; 3];",
                "    let result = flags.write_to::<u32>(&mut dst);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().what, \"flag bitset\");"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: false,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 3]; // Length less than 4",
                "    let _ = flags.write_to::<u32>(&mut dst);",
                "    let flags = Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false };",
                "    let mut dst = [0u8; 3];",
                "    let result = flags.write_to::<u32>(&mut dst);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().what, \"flag bitset\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: dst.len() < nwrite at line 4733 is false, with bound dst.len() == nwrite\n",
        "expected return value/type: Ok(nwrite)\n"
      ],
      "input_infer": "dst.len() == 4 for any instance of Flags with has_empty, is_utf8, and is_always_start_anchored as either true or false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: false,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    let flags = Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "    assert_eq!(result, Ok(4));",
                "    assert_eq!(dst, [0, 0, 0, 0]);"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: false,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "    let flags = Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "    assert_eq!(result, Ok(4));",
                "    assert_eq!(dst, [0, 0, 0, 0]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: false,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dst.len(), flags.write_to_len());",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), flags.write_to_len());",
                "    assert_eq!(dst[0], if flags.has_empty { 1 } else { 0 });",
                "    assert_eq!(dst[1], if flags.is_utf8 { 1 } else { 0 });",
                "    assert_eq!(dst[2], if flags.is_always_start_anchored { 1 } else { 0 });",
                "    assert_eq!(dst[3], 0);"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: false,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "    assert_eq!(dst.len(), flags.write_to_len());",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), flags.write_to_len());",
                "    assert_eq!(dst[0], if flags.has_empty { 1 } else { 0 });",
                "    assert_eq!(dst[1], if flags.is_utf8 { 1 } else { 0 });",
                "    assert_eq!(dst[2], if flags.is_always_start_anchored { 1 } else { 0 });",
                "    assert_eq!(dst[3], 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: true,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Ok(4));"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: true,",
                "        is_always_start_anchored: false,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "    assert_eq!(result, Ok(4));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: false,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Ok(4));",
                "    assert_eq!(dst, [0b00000100, 0, 0, 0]);"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: false,",
                "        is_utf8: false,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "    assert_eq!(result, Ok(4));",
                "    assert_eq!(dst, [0b00000100, 0, 0, 0]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: true,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Ok(4));",
                "    assert_eq!(dst, [7, 0, 0, 0]);"
              ],
              "code": [
                "{",
                "    let flags = Flags {",
                "        has_empty: true,",
                "        is_utf8: true,",
                "        is_always_start_anchored: true,",
                "    };",
                "    let mut dst = [0u8; 4];",
                "    let result = flags.write_to::<Endian>(&mut dst);",
                "    assert_eq!(result, Ok(4));",
                "    assert_eq!(dst, [7, 0, 0, 0]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}