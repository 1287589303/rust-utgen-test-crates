{
  "name": "regex_automata::util::wire::try_read_u128",
  "mod_info": {
    "name": "util::wire",
    "loc": "regex-automata/src/util/mod.rs:46:1:46:14"
  },
  "visible": true,
  "loc": "regex-automata/src/util/wire.rs:746:1:752:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: check_slice_len(slice, size_of::<u128>(), what)? at line 750 is Err/None\n"
      ],
      "input_infer": "slice length must be less than 16 (0 to 15 bytes) and what should be a valid noun in singular form.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[];",
                "    let what: &'static str = \"empty_slice\";",
                "    let _ = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeError::buffer_too_small(what));",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, \"empty_slice\");",
                "    assert_eq!(try_read_u128(slice, what).is_ok(), false);",
                "    assert_eq!(try_read_u128(slice, what).err().unwrap().0, DeserializeError::buffer_too_small(what));"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[];",
                "    let what: &'static str = \"empty_slice\";",
                "    let _ = try_read_u128(slice, what);",
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeError::buffer_too_small(what));",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, \"empty_slice\");",
                "    assert_eq!(try_read_u128(slice, what).is_ok(), false);",
                "    assert_eq!(try_read_u128(slice, what).err().unwrap().0, DeserializeError::buffer_too_small(what));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0x01];",
                "    let what: &'static str = \"one_byte\";",
                "    let _ = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeErrorKind::BufferTooSmall);",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0.get_description(), \"Buffer too small for 'one_byte'\");",
                "    assert!(try_read_u128(slice, what).is_err());"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0x01];",
                "    let what: &'static str = \"one_byte\";",
                "    let _ = try_read_u128(slice, what);",
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeErrorKind::BufferTooSmall);",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0.get_description(), \"Buffer too small for 'one_byte'\");",
                "    assert!(try_read_u128(slice, what).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0; 15];",
                "    let what: &'static str = \"fifteen_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, \"buffer_too_small(fifteen_bytes)\");",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().1, DeserializeErrorKind::BufferTooSmall);"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0; 15];",
                "    let what: &'static str = \"fifteen_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, \"buffer_too_small(fifteen_bytes)\");",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().1, DeserializeErrorKind::BufferTooSmall);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0; 7];",
                "    let what: &'static str = \"seven_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(try_read_u128(slice, what), Err(_)));"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0; 7];",
                "    let what: &'static str = \"seven_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "    assert!(matches!(try_read_u128(slice, what), Err(_)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0; 14];",
                "    let what: &'static str = \"fourteen_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeErrorKind::BufferTooSmall);",
                "    assert!(try_read_u128(slice, what).unwrap_err().0.to_string().contains(\"fourteen_bytes\"));"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0; 14];",
                "    let what: &'static str = \"fourteen_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeErrorKind::BufferTooSmall);",
                "    assert!(try_read_u128(slice, what).unwrap_err().0.to_string().contains(\"fourteen_bytes\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0; 2];",
                "    let what: &'static str = \"two_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeErrorKind::BufferTooSmall);",
                "    assert!(matches!(try_read_u128(slice, what).unwrap_err(), DeserializeError(_)));"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0; 2];",
                "    let what: &'static str = \"two_bytes\";",
                "    let _ = try_read_u128(slice, what);",
                "    assert!(try_read_u128(slice, what).is_err());",
                "    assert_eq!(try_read_u128(slice, what).unwrap_err().0, DeserializeErrorKind::BufferTooSmall);",
                "    assert!(matches!(try_read_u128(slice, what).unwrap_err(), DeserializeError(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: check_slice_len(slice, size_of::<u128>(), what)? at line 750 is Ok/Some\n",
        "expected return value/type: Ok((read_u128(slice), size_of::<u128>()))\n"
      ],
      "input_infer": "slice with exactly 16 bytes of data in native endian format and a valid string for what\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[0u8; 16]; // 16 bytes of data",
                "    let what: &'static str = \"test_value\";",
                "    let result = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), (0, 16));"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[0u8; 16]; // 16 bytes of data",
                "    let what: &'static str = \"test_value\";",
                "    let result = try_read_u128(slice, what);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), (0, 16));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]; // 16 bytes of data",
                "    let what: &'static str = \"non_empty_data\";",
                "    let result = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Ok((read_u128(slice), size_of::<u128>()));"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]; // 16 bytes of data",
                "    let what: &'static str = \"non_empty_data\";",
                "    let result = try_read_u128(slice, what);",
                "    assert_eq!(result, Ok((read_u128(slice), size_of::<u128>()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let slice: &[u8] = &[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]; // 16 bytes of data ",
                "    let what: &'static str = \"high_value\";",
                "    let result = try_read_u128(slice, what);",
                "}"
              ],
              "oracle": [
                "    result.is_ok();",
                "    assert_eq!(result, Ok((u128::from_ne_bytes([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), size_of::<u128>())));",
                "    assert_eq!(result.unwrap().1, size_of::<u128>());"
              ],
              "code": [
                "{",
                "    let slice: &[u8] = &[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]; // 16 bytes of data ",
                "    let what: &'static str = \"high_value\";",
                "    let result = try_read_u128(slice, what);",
                "    result.is_ok();",
                "    assert_eq!(result, Ok((u128::from_ne_bytes([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), size_of::<u128>())));",
                "    assert_eq!(result.unwrap().1, size_of::<u128>());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}