{
  "name": "regex_lite::pikevm::{impl#0}::epsilon_closure",
  "mod_info": {
    "name": "pikevm",
    "loc": "regex-lite/src/lib.rs:881:1:881:12"
  },
  "visible": false,
  "loc": "regex-lite/src/pikevm.rs:307:5:329:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: let Some(frame) = stack.pop() at line 317 is true\n",
        "precondition: frame matches FollowEpsilon::RestoreCapture { slot, offset } at line 318 is true\n",
        "precondition: frame matches FollowEpsilon::RestoreCapture { slot, offset } at line 318 is true\n",
        "precondition: let Some(frame) = stack.pop() at line 317 is true\n"
      ],
      "input_infer": "stack must contain at least one FollowEpsilon::RestoreCapture with a valid slot index within the bounds of curr_slots, curr_slots must be an array with at least one element, haystack must be a non-empty byte slice, at must be a valid index within haystack, and sid must be a valid StateID corresponding to an existing state in the NFA.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture {",
                "        slot: 0,",
                "        offset: Some(NonMaxUsize::new(1).unwrap()),",
                "    }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"test haystack\";",
                "    let at = 0;",
                "    let sid = StateID(0); // Assuming this is a valid StateID for the context",
                "    let nfa = NFA {",
                "        pattern: String::from(\"test\"),",
                "        states: vec![],",
                "        start: sid,",
                "        is_start_anchored: true,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "}"
              ],
              "oracle": [
                "    let mut stack = vec![FollowEpsilon::RestoreCapture { slot: 0, offset: Some(NonMaxUsize::new(1).unwrap()) }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates { set: SparseSet::new(), slot_table: SlotTable::new() };",
                "    let haystack = b\"test haystack\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "    let nfa = NFA { pattern: String::from(\"test\"), states: vec![], start: sid, is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: Some(1), cap_name_to_index: CaptureNameMap::new(), cap_index_to_name: vec![None], memory_extra: 0 };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    assert_eq!(curr_slots[0], None);",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    assert_eq!(curr_slots[0], Some(NonMaxUsize::new(1).unwrap()));"
              ],
              "code": [
                "{",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture {",
                "        slot: 0,",
                "        offset: Some(NonMaxUsize::new(1).unwrap()),",
                "    }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"test haystack\";",
                "    let at = 0;",
                "    let sid = StateID(0); // Assuming this is a valid StateID for the context",
                "    let nfa = NFA {",
                "        pattern: String::from(\"test\"),",
                "        states: vec![],",
                "        start: sid,",
                "        is_start_anchored: true,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture { slot: 0, offset: Some(NonMaxUsize::new(1).unwrap()) }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates { set: SparseSet::new(), slot_table: SlotTable::new() };",
                "    let haystack = b\"test haystack\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "    let nfa = NFA { pattern: String::from(\"test\"), states: vec![], start: sid, is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: Some(1), cap_name_to_index: CaptureNameMap::new(), cap_index_to_name: vec![None], memory_extra: 0 };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    assert_eq!(curr_slots[0], None);",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    assert_eq!(curr_slots[0], Some(NonMaxUsize::new(1).unwrap()));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture {",
                "        slot: 0,",
                "        offset: None,",
                "    }];",
                "    let mut curr_slots = vec![Some(NonMaxUsize::new(2).unwrap())].into_boxed_slice();",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"another test\";",
                "    let at = 1; // Valid index",
                "    let sid = StateID(1); // Assuming this is another valid StateID",
                "    let nfa = NFA {",
                "        pattern: String::from(\"another\"),",
                "        states: vec![],",
                "        start: sid,",
                "        is_start_anchored: false,",
                "        is_match_empty: true,",
                "        static_explicit_captures_len: Some(2),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None, None],",
                "        memory_extra: 0,",
                "    };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "}"
              ],
              "oracle": [
                "    STACK_PUSH_FOLLOW_EPSILON_RESTORE_CAPTURE_SLOT_0_OFFSET_NONE",
                "    CURR_SLOTS_SET_SLOT_0_NONE",
                "    NEXT_ACTIVE_STATES_SET_EMPTY",
                "    CURR_SLOTS_RESTORED_SLOT_0_TO_NONE",
                "    CURR_SLOTS_SET_SLOT_0_SOME_2"
              ],
              "code": [
                "{",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture {",
                "        slot: 0,",
                "        offset: None,",
                "    }];",
                "    let mut curr_slots = vec![Some(NonMaxUsize::new(2).unwrap())].into_boxed_slice();",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"another test\";",
                "    let at = 1; // Valid index",
                "    let sid = StateID(1); // Assuming this is another valid StateID",
                "    let nfa = NFA {",
                "        pattern: String::from(\"another\"),",
                "        states: vec![],",
                "        start: sid,",
                "        is_start_anchored: false,",
                "        is_match_empty: true,",
                "        static_explicit_captures_len: Some(2),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None, None],",
                "        memory_extra: 0,",
                "    };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    STACK_PUSH_FOLLOW_EPSILON_RESTORE_CAPTURE_SLOT_0_OFFSET_NONE",
                "    CURR_SLOTS_SET_SLOT_0_NONE",
                "    NEXT_ACTIVE_STATES_SET_EMPTY",
                "    CURR_SLOTS_RESTORED_SLOT_0_TO_NONE",
                "    CURR_SLOTS_SET_SLOT_0_SOME_2",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture {",
                "        slot: 0,",
                "        offset: Some(NonMaxUsize::new(0).unwrap()),",
                "    }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"\"; // Empty haystack",
                "    let at = 0; // Index in empty haystack, likely causing boundary issues",
                "    let sid = StateID(2); // Another valid StateID",
                "    let nfa = NFA {",
                "        pattern: String::from(\"\"),",
                "        states: vec![],",
                "        start: sid,",
                "        is_start_anchored: true,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "}"
              ],
              "oracle": [
                "    let mut stack = vec![FollowEpsilon::RestoreCapture { slot: 0, offset: Some(NonMaxUsize::new(0).unwrap()) }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates { set: SparseSet::new(), slot_table: SlotTable::new() };",
                "    let haystack = b\"\";",
                "    let at = 0;",
                "    let sid = StateID(2);",
                "    let nfa = NFA { pattern: String::from(\"\"), states: vec![], start: sid, is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: Some(1), cap_name_to_index: CaptureNameMap::new(), cap_index_to_name: vec![None], memory_extra: 0 };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    assert_eq!(curr_slots[0], Some(NonMaxUsize::new(0).unwrap()));",
                "    assert!(next.set.contains(&sid));",
                "    assert!(stack.is_empty());",
                "    assert!(curr_slots.len() >= 1);",
                "    assert_eq!(next.slot_table.for_state(sid).len(), curr_slots.len());"
              ],
              "code": [
                "{",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture {",
                "        slot: 0,",
                "        offset: Some(NonMaxUsize::new(0).unwrap()),",
                "    }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"\"; // Empty haystack",
                "    let at = 0; // Index in empty haystack, likely causing boundary issues",
                "    let sid = StateID(2); // Another valid StateID",
                "    let nfa = NFA {",
                "        pattern: String::from(\"\"),",
                "        states: vec![],",
                "        start: sid,",
                "        is_start_anchored: true,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    let mut stack = vec![FollowEpsilon::RestoreCapture { slot: 0, offset: Some(NonMaxUsize::new(0).unwrap()) }];",
                "    let mut curr_slots = vec![None].into_boxed_slice();",
                "    let mut next = ActiveStates { set: SparseSet::new(), slot_table: SlotTable::new() };",
                "    let haystack = b\"\";",
                "    let at = 0;",
                "    let sid = StateID(2);",
                "    let nfa = NFA { pattern: String::from(\"\"), states: vec![], start: sid, is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: Some(1), cap_name_to_index: CaptureNameMap::new(), cap_index_to_name: vec![None], memory_extra: 0 };",
                "    let pike_vm = PikeVM::new(nfa);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    assert_eq!(curr_slots[0], Some(NonMaxUsize::new(0).unwrap()));",
                "    assert!(next.set.contains(&sid));",
                "    assert!(stack.is_empty());",
                "    assert!(curr_slots.len() >= 1);",
                "    assert_eq!(next.slot_table.for_state(sid).len(), curr_slots.len());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: let Some(frame) = stack.pop() at line 317 is true\n",
        "precondition: frame matches FollowEpsilon::Explore(sid) at line 318 is true\n",
        "precondition: let Some(frame) = stack.pop() at line 317 is true\n"
      ],
      "input_infer": "Valid range for stack length: [1, âˆž), valid range for curr_slots size: [1, U32::MAX as usize], valid range for haystack length: [1, U32::MAX as usize], valid range for at: [0, haystack.len() - 1], valid range for sid: [valid_state_id_min, valid_state_id_max]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"a*\"),",
                "        states: vec![State::Char { code: 'a' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    ",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 1];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"aa\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "}"
              ],
              "oracle": [
                "    curr_slots[0] == None",
                "    next.slot_table.for_state(StateID(0)) == curr_slots",
                "    stack.len() == 0",
                "    next.set.contains(StateID(0)) == true",
                "    curr_slots[0].is_some() == true",
                "    stack[0] == FollowEpsilon::Explore(StateID(0))"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"a*\"),",
                "        states: vec![State::Char { code: 'a' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    ",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 1];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"aa\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    curr_slots[0] == None",
                "    next.slot_table.for_state(StateID(0)) == curr_slots",
                "    stack.len() == 0",
                "    next.set.contains(StateID(0)) == true",
                "    curr_slots[0].is_some() == true",
                "    stack[0] == FollowEpsilon::Explore(StateID(0))",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"b*\"),",
                "        states: vec![State::Char { code: 'b' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    ",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 2];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"bbb\";",
                "    let at = 1;",
                "    let sid = StateID(0);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(stack.len(), 1);",
                "    assert!(matches!(stack.last(), Some(FollowEpsilon::Explore(StateID(0)))));",
                "    assert!(curr_slots.iter().all(|&slot| slot.is_none()));",
                "    assert!(next.set.is_empty());",
                "    assert_eq!(next.slot_table.for_state(StateID(0)), curr_slots);",
                "    assert!(curr_slots[0].is_none());",
                "    assert!(curr_slots[1].is_none());",
                "    assert_eq!(haystack[at], b'b');",
                "    assert_eq!(next.set.len(), 1);",
                "    assert!(next.set.contains(StateID(0)));"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"b*\"),",
                "        states: vec![State::Char { code: 'b' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    ",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 2];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"bbb\";",
                "    let at = 1;",
                "    let sid = StateID(0);",
                "    ",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    assert_eq!(stack.len(), 1);",
                "    assert!(matches!(stack.last(), Some(FollowEpsilon::Explore(StateID(0)))));",
                "    assert!(curr_slots.iter().all(|&slot| slot.is_none()));",
                "    assert!(next.set.is_empty());",
                "    assert_eq!(next.slot_table.for_state(StateID(0)), curr_slots);",
                "    assert!(curr_slots[0].is_none());",
                "    assert!(curr_slots[1].is_none());",
                "    assert_eq!(haystack[at], b'b');",
                "    assert_eq!(next.set.len(), 1);",
                "    assert!(next.set.contains(StateID(0)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"c\"),",
                "        states: vec![State::Char { code: 'c' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    ",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 1];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"c\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "}"
              ],
              "oracle": [
                "    stack.push(FollowEpsilon::Explore(StateID(0)));",
                "    let Some(frame) = stack.pop();",
                "    frame matches FollowEpsilon::Explore(StateID(0));",
                "    curr_slots[0] = Some(NonMaxUsize::new(at).unwrap());",
                "    next.slot_table.for_state(StateID(0)).copy_from_slice(&curr_slots);",
                "    next.set.insert(StateID(0));"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"c\"),",
                "        states: vec![State::Char { code: 'c' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "    ",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 1];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"c\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    stack.push(FollowEpsilon::Explore(StateID(0)));",
                "    let Some(frame) = stack.pop();",
                "    frame matches FollowEpsilon::Explore(StateID(0));",
                "    curr_slots[0] = Some(NonMaxUsize::new(at).unwrap());",
                "    next.slot_table.for_state(StateID(0)).copy_from_slice(&curr_slots);",
                "    next.set.insert(StateID(0));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"d\"),",
                "        states: vec![State::Char { code: 'd' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 1];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"d\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "}"
              ],
              "oracle": [
                "    stack.pop().is_some() // Check that stack has elements",
                "    frame == FollowEpsilon::Explore(StateID(0)) // Check that the popped frame is an Explore variant with the expected StateID",
                "    curr_slots[0].is_none() // Check that the initial current slot is None",
                "    next.set.contains(StateID(0)) // Check that the state set in next contains StateID(0)",
                "    curr_slots[0].is_some() // Check that the slot in curr_slots is not None after the exploration",
                "    stack.len() == 0 // Check that the stack is empty after epsilon closure execution",
                "    next.slot_table.for_state(StateID(0)).copy_from_slice(&curr_slots) // Check that slot table in next states is updated correctly"
              ],
              "code": [
                "{",
                "    let nfa = NFA {",
                "        pattern: String::from(\"d\"),",
                "        states: vec![State::Char { code: 'd' }, State::Match],",
                "        start: StateID(0),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: Some(1),",
                "        cap_name_to_index: CaptureNameMap::new(),",
                "        cap_index_to_name: vec![None],",
                "        memory_extra: 0,",
                "    };",
                "",
                "    let pike_vm = PikeVM::new(nfa);",
                "    let mut stack = vec![FollowEpsilon::Explore(StateID(0))];",
                "    let mut curr_slots = vec![None; 1];",
                "    let mut next = ActiveStates {",
                "        set: SparseSet::new(),",
                "        slot_table: SlotTable::new(),",
                "    };",
                "    let haystack = b\"d\";",
                "    let at = 0;",
                "    let sid = StateID(0);",
                "",
                "    pike_vm.epsilon_closure(&mut stack, &mut curr_slots, &mut next, haystack, at, sid);",
                "    stack.pop().is_some() // Check that stack has elements",
                "    frame == FollowEpsilon::Explore(StateID(0)) // Check that the popped frame is an Explore variant with the expected StateID",
                "    curr_slots[0].is_none() // Check that the initial current slot is None",
                "    next.set.contains(StateID(0)) // Check that the state set in next contains StateID(0)",
                "    curr_slots[0].is_some() // Check that the slot in curr_slots is not None after the exploration",
                "    stack.len() == 0 // Check that the stack is empty after epsilon closure execution",
                "    next.slot_table.for_state(StateID(0)).copy_from_slice(&curr_slots) // Check that slot table in next states is updated correctly",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}