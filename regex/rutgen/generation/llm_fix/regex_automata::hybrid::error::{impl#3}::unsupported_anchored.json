{
  "name": "regex_automata::hybrid::error::{impl#3}::unsupported_anchored",
  "mod_info": {
    "name": "hybrid::error",
    "loc": "regex-automata/src/hybrid/mod.rs:141:1:141:11"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/error.rs:148:5:150:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: StartError::UnsupportedAnchored { mode }\n"
      ],
      "input_infer": "Valid test input conditions or ranges for the function: Anchored variants (No, Yes, Pattern(PatternID)), where PatternID can be any valid identifier.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mode = Anchored::No;",
                "    let error = StartError::unsupported_anchored(mode);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(error, StartError::UnsupportedAnchored { mode: Anchored::No });",
                "    let mode = Anchored::Yes;",
                "    let error = StartError::unsupported_anchored(mode);",
                "    assert_eq!(error, StartError::UnsupportedAnchored { mode: Anchored::Yes });",
                "    let mode = Anchored::Pattern(some_pattern_id);",
                "    let error = StartError::unsupported_anchored(mode);",
                "    assert_eq!(error, StartError::UnsupportedAnchored { mode: Anchored::Pattern(some_pattern_id) });"
              ],
              "code": [
                "{",
                "    let mode = Anchored::No;",
                "    let error = StartError::unsupported_anchored(mode);",
                "    assert_eq!(error, StartError::UnsupportedAnchored { mode: Anchored::No });",
                "    let mode = Anchored::Yes;",
                "    let error = StartError::unsupported_anchored(mode);",
                "    assert_eq!(error, StartError::UnsupportedAnchored { mode: Anchored::Yes });",
                "    let mode = Anchored::Pattern(some_pattern_id);",
                "    let error = StartError::unsupported_anchored(mode);",
                "    assert_eq!(error, StartError::UnsupportedAnchored { mode: Anchored::Pattern(some_pattern_id) });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mode = Anchored::Yes;",
                "    let error = StartError::unsupported_anchored(mode);",
                "}"
              ],
              "oracle": [
                "    error == StartError::UnsupportedAnchored { mode: Anchored::Yes }",
                "    mode == Anchored::Yes",
                "    error.is_cache() == false",
                "    error.is_quit() == false",
                "    error.is_unsupported_anchored() == true",
                "    error.anchored_mode() == Anchored::Yes"
              ],
              "code": [
                "{",
                "    let mode = Anchored::Yes;",
                "    let error = StartError::unsupported_anchored(mode);",
                "    error == StartError::UnsupportedAnchored { mode: Anchored::Yes }",
                "    mode == Anchored::Yes",
                "    error.is_cache() == false",
                "    error.is_quit() == false",
                "    error.is_unsupported_anchored() == true",
                "    error.anchored_mode() == Anchored::Yes",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct PatternID;",
                "    let mode = Anchored::Pattern(PatternID);",
                "    let error = StartError::unsupported_anchored(mode);",
                "}"
              ],
              "oracle": [
                "    let mode_no = Anchored::No;",
                "    let result_no = StartError::unsupported_anchored(mode_no);",
                "    assert_eq!(result_no, StartError::UnsupportedAnchored { mode: mode_no });",
                "    ",
                "    let mode_yes = Anchored::Yes;",
                "    let result_yes = StartError::unsupported_anchored(mode_yes);",
                "    assert_eq!(result_yes, StartError::UnsupportedAnchored { mode: mode_yes });",
                "    ",
                "    let mode_pattern = Anchored::Pattern(PatternID);",
                "    let result_pattern = StartError::unsupported_anchored(mode_pattern);",
                "    assert_eq!(result_pattern, StartError::UnsupportedAnchored { mode: mode_pattern });"
              ],
              "code": [
                "{",
                "    struct PatternID;",
                "    let mode = Anchored::Pattern(PatternID);",
                "    let error = StartError::unsupported_anchored(mode);",
                "    let mode_no = Anchored::No;",
                "    let result_no = StartError::unsupported_anchored(mode_no);",
                "    assert_eq!(result_no, StartError::UnsupportedAnchored { mode: mode_no });",
                "    ",
                "    let mode_yes = Anchored::Yes;",
                "    let result_yes = StartError::unsupported_anchored(mode_yes);",
                "    assert_eq!(result_yes, StartError::UnsupportedAnchored { mode: mode_yes });",
                "    ",
                "    let mode_pattern = Anchored::Pattern(PatternID);",
                "    let result_pattern = StartError::unsupported_anchored(mode_pattern);",
                "    assert_eq!(result_pattern, StartError::UnsupportedAnchored { mode: mode_pattern });",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}