{
  "name": "regex_automata::util::utf8::len",
  "mod_info": {
    "name": "util::utf8",
    "loc": "regex-automata/src/util/mod.rs:57:1:57:21"
  },
  "visible": false,
  "loc": "regex-automata/src/util/utf8.rs:101:1:115:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: byte <= 0x7F at line 102 is true, with bound byte == 0x7F\n",
        "expected return value/type: Some(1)\n"
      ],
      "input_infer": "0x00 to 0x7F for valid UTF-8 leading bytes returning Some(1), 0x80 to 0xBF returning None, 0xC0 to 0xDF returning Some(2), 0xE0 to 0xEF returning Some(3), 0xF0 to 0xF7 returning Some(4), and 0xF8 to 0xFF returning None.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0x7F; // upper bound of single-byte UTF-8 character",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Some(1));"
              ],
              "code": [
                "{",
                "    let byte = 0x7F; // upper bound of single-byte UTF-8 character",
                "    let result = len(byte);",
                "    assert_eq!(result, Some(1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0x80; // lower bound of continuation bytes",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let byte = 0x7F; // upper bound of single-byte characters",
                "    let expected = Some(1);",
                "    assert_eq!(len(byte), expected);"
              ],
              "code": [
                "{",
                "    let byte = 0x80; // lower bound of continuation bytes",
                "    let result = len(byte);",
                "    let byte = 0x7F; // upper bound of single-byte characters",
                "    let expected = Some(1);",
                "    assert_eq!(len(byte), expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0xC0; // lower bound of two-byte UTF-8 character",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0xC0; // lower bound of two-byte UTF-8 character",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0xE0; // lower bound of three-byte UTF-8 character",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(len(0x00), Some(1)); // Test with ASCII byte",
                "    assert_eq!(len(0x7F), Some(1)); // Test with maximum ASCII byte",
                "    assert_eq!(len(0xC0), Some(2)); // Test with lower bound of two-byte UTF-8 character",
                "    assert_eq!(len(0xDF), Some(2)); // Test with upper bound of two-byte UTF-8 character",
                "    assert_eq!(len(0xE0), Some(3)); // Test with lower bound of three-byte UTF-8 character",
                "    assert_eq!(len(0xEF), Some(3)); // Test with upper bound of three-byte UTF-8 character",
                "    assert_eq!(len(0xF0), Some(4)); // Test with lower bound of four-byte UTF-8 character",
                "    assert_eq!(len(0xF7), Some(4)); // Test with upper bound of four-byte UTF-8 character",
                "    assert_eq!(len(0x80), None); // Test with invalid continuation byte",
                "    assert_eq!(len(0xF8), None); // Test with invalid leading byte for five-byte character"
              ],
              "code": [
                "{",
                "    let byte = 0xE0; // lower bound of three-byte UTF-8 character",
                "    let result = len(byte);",
                "    assert_eq!(len(0x00), Some(1)); // Test with ASCII byte",
                "    assert_eq!(len(0x7F), Some(1)); // Test with maximum ASCII byte",
                "    assert_eq!(len(0xC0), Some(2)); // Test with lower bound of two-byte UTF-8 character",
                "    assert_eq!(len(0xDF), Some(2)); // Test with upper bound of two-byte UTF-8 character",
                "    assert_eq!(len(0xE0), Some(3)); // Test with lower bound of three-byte UTF-8 character",
                "    assert_eq!(len(0xEF), Some(3)); // Test with upper bound of three-byte UTF-8 character",
                "    assert_eq!(len(0xF0), Some(4)); // Test with lower bound of four-byte UTF-8 character",
                "    assert_eq!(len(0xF7), Some(4)); // Test with upper bound of four-byte UTF-8 character",
                "    assert_eq!(len(0x80), None); // Test with invalid continuation byte",
                "    assert_eq!(len(0xF8), None); // Test with invalid leading byte for five-byte character",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0xF0; // lower bound of four-byte UTF-8 character",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let byte = 0x7F;",
                "    let result = len(byte);",
                "    assert_eq!(result, Some(1));"
              ],
              "code": [
                "{",
                "    let byte = 0xF0; // lower bound of four-byte UTF-8 character",
                "    let result = len(byte);",
                "    let byte = 0x7F;",
                "    let result = len(byte);",
                "    assert_eq!(result, Some(1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0xF8; // lower bound of invalid UTF-8 characters",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let byte = 0x7F; // upper bound of valid single-byte UTF-8 character",
                "    let expected = Some(1); // expected return value for valid UTF-8 leading byte",
                "    assert_eq!(len(byte), expected); // validate result against expected output"
              ],
              "code": [
                "{",
                "    let byte = 0xF8; // lower bound of invalid UTF-8 characters",
                "    let result = len(byte);",
                "    let byte = 0x7F; // upper bound of valid single-byte UTF-8 character",
                "    let expected = Some(1); // expected return value for valid UTF-8 leading byte",
                "    assert_eq!(len(byte), expected); // validate result against expected output",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: byte <= 0x7F at line 102 is false\n",
        "precondition: byte & 0b1100_0000 == 0b1000_0000 at line 104 is false\n",
        "expected return value/type: None\n"
      ],
      "input_infer": "Test input conditions or ranges: byte = 0b1100_0000 to 0b1111_1111 (192 to 255)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1100_0000; // 192",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_none());"
              ],
              "code": [
                "{",
                "    let byte = 0b1100_0000; // 192",
                "    let result = len(byte);",
                "    assert!(result.is_none());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1100_0001; // 193",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1100_0001; // 193",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1100_0010; // 194",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1100_0010; // 194",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1100_0011; // 195",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1100_0011; // 195",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1101_1111; // 223",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1101_1111; // 223",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1110_0000; // 224",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1110_0000; // 224",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1111_0111; // 247",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1111_0111; // 247",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1111_1111; // 255",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1111_1111; // 255",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: byte <= 0x7F at line 102 is false\n",
        "precondition: byte & 0b1100_0000 == 0b1000_0000 at line 104 is true\n",
        "precondition: byte <= 0b1101_1111 at line 106 is true, with bound byte == 0b1101_1111\n",
        "expected return value/type: Some(2)\n"
      ],
      "input_infer": "byte = 0b1101_1111\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1101_1111; // This tests the case where byte ≤ 0b1101_1111 and matches the conditions",
                "    len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(len(0b1101_1111), Some(2));"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1101_1111; // This tests the case where byte ≤ 0b1101_1111 and matches the conditions",
                "    len(byte);",
                "    assert_eq!(len(0b1101_1111), Some(2));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1000_0000; // This tests the case where the byte makes byte & 0b1100_0000 == 0b1000_0000 true",
                "    len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(len(0b1000_0000), None);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1000_0000; // This tests the case where the byte makes byte & 0b1100_0000 == 0b1000_0000 true",
                "    len(byte);",
                "    assert_eq!(len(0b1000_0000), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1101_1111; // This tests the highest valid UTF-8 leading byte for two bytes",
                "    len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(len(0b1101_1111), Some(2));"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1101_1111; // This tests the highest valid UTF-8 leading byte for two bytes",
                "    len(byte);",
                "    assert_eq!(len(0b1101_1111), Some(2));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "precondition: byte <= 0x7F at line 102 is false\n",
        "precondition: byte & 0b1100_0000 == 0b1000_0000 at line 104 is true\n",
        "precondition: byte <= 0b1101_1111 at line 106 is false\n",
        "precondition: byte <= 0b1110_1111 at line 108 is true, with bound byte == 0b1110_1111\n",
        "expected return value/type: Some(3)\n"
      ],
      "input_infer": "byte = 0b1110_1111\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1110_1111; // A valid UTF-8 leading byte for 3-byte sequences",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Some(3));"
              ],
              "code": [
                "{",
                "    let byte = 0b1110_1111; // A valid UTF-8 leading byte for 3-byte sequences",
                "    let result = len(byte);",
                "    assert_eq!(result, Some(3));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1000_0000; // An invalid leading byte",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let byte = 0b1110_1111; // Valid leading byte for 3 code units",
                "    let result = len(byte);",
                "    assert_eq!(result, Some(3));"
              ],
              "code": [
                "{",
                "    let byte = 0b1000_0000; // An invalid leading byte",
                "    let result = len(byte);",
                "    let byte = 0b1110_1111; // Valid leading byte for 3 code units",
                "    let result = len(byte);",
                "    assert_eq!(result, Some(3));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1101_1111 + 1; // Beyond the valid range for leading bytes",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let byte = 0b1000_0000; // This triggers condition on line 104, expecting None",
                "    assert_eq!(len(byte), None);",
                "    ",
                "    let byte = 0b1110_1111; // This triggers condition on line 108, expecting Some(3)",
                "    assert_eq!(len(byte), Some(3));",
                "    ",
                "    let byte = 0b1101_1111 + 1; // Beyond the valid range for leading bytes",
                "    assert_eq!(len(byte), None);"
              ],
              "code": [
                "{",
                "    let byte = 0b1101_1111 + 1; // Beyond the valid range for leading bytes",
                "    let result = len(byte);",
                "    let byte = 0b1000_0000; // This triggers condition on line 104, expecting None",
                "    assert_eq!(len(byte), None);",
                "    ",
                "    let byte = 0b1110_1111; // This triggers condition on line 108, expecting Some(3)",
                "    assert_eq!(len(byte), Some(3));",
                "    ",
                "    let byte = 0b1101_1111 + 1; // Beyond the valid range for leading bytes",
                "    assert_eq!(len(byte), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "precondition: byte <= 0x7F at line 102 is false\n",
        "precondition: byte & 0b1100_0000 == 0b1000_0000 at line 104 is true\n",
        "precondition: byte <= 0b1101_1111 at line 106 is false\n",
        "precondition: byte <= 0b1110_1111 at line 108 is false\n",
        "precondition: byte <= 0b1111_0111 at line 110 is true, with bound byte == 0b1111_0111\n",
        "expected return value/type: Some(4)\n"
      ],
      "input_infer": "Test input conditions: byte values from 0b1111_1000 (248) to 0b1111_0111 (247) inclusive.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1111_1000; // 248",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let byte = 0b1111_1000; // 248",
                "    let expected = Some(4);",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let byte = 0b1111_1000; // 248",
                "    let result = len(byte);",
                "    let byte = 0b1111_1000; // 248",
                "    let expected = Some(4);",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte = 0b1111_0111; // 247",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Some(4));"
              ],
              "code": [
                "{",
                "    let byte = 0b1111_0111; // 247",
                "    let result = len(byte);",
                "    assert_eq!(result, Some(4));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "precondition: byte <= 0x7F at line 102 is false\n",
        "precondition: byte & 0b1100_0000 == 0b1000_0000 at line 104 is true\n",
        "precondition: byte <= 0b1101_1111 at line 106 is false\n",
        "precondition: byte <= 0b1110_1111 at line 108 is false\n",
        "precondition: byte <= 0b1111_0111 at line 110 is false\n",
        "expected return value/type: None\n"
      ],
      "input_infer": "byte must be in the range 0b1000_0000 to 0b1111_1111 (128 to 255 in decimal) excluding the range 0b1100_0000 to 0b1101_1111 (192 to 223 in decimal)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1000_0000; // 128",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1000_0000; // 128",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1000_0001; // 129",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1000_0001; // 129",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1000_0010; // 130",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1000_0010; // 130",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1000_1111; // 143",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1000_1111; // 143",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1101_1111; // 223",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1101_1111; // 223",
                "    let result = len(byte);",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1110_0000; // 224",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let expected: Option<usize> = None;",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1110_0000; // 224",
                "    let result = len(byte);",
                "    let expected: Option<usize> = None;",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let byte: u8 = 0b1111_1111; // 255",
                "    let result = len(byte);",
                "}"
              ],
              "oracle": [
                "    let byte: u8 = 0b1111_1111; // 255",
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let byte: u8 = 0b1111_1111; // 255",
                "    let result = len(byte);",
                "    let byte: u8 = 0b1111_1111; // 255",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}