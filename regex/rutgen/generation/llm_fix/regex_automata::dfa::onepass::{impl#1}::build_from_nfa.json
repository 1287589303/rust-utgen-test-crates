{
  "name": "regex_automata::dfa::onepass::{impl#1}::build_from_nfa",
  "mod_info": {
    "name": "dfa::onepass",
    "loc": "regex-automata/src/dfa/mod.rs:339:1:339:17"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/onepass.rs:395:5:414:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid NFA instances constructed with various complexity (e.g. simple, complex, with multiple patterns), NFA having less than the pattern ID limit (200), varying configuration options like byte_classes enabled/disabled, different MatchKind settings, NFA with explicit slots less than 16, and empty state handling (e.g. no states).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"[a-z]+\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.is_valid());",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert_eq!(dfa.starts.len(), 1);",
                "    assert!(dfa.table.len() > 0);",
                "    assert!(dfa.classes.alphabet_len() > 0);",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.pateps_offset > 0);",
                "    assert!(dfa.explicit_slot_start >= 0);",
                "    assert_eq!(dfa.nfa.pattern_len().as_u64(), 1);",
                "    assert!(dfa.nfa.states().len() > 0);",
                "    assert_eq!(dfa.config.match_kind, None);",
                "    assert!(dfa.config.dfa.is_some());",
                "    assert!(dfa.config.nfa_size_limit.is_none());"
              ],
              "code": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"[a-z]+\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert!(dfa.is_valid());",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert_eq!(dfa.starts.len(), 1);",
                "    assert!(dfa.table.len() > 0);",
                "    assert!(dfa.classes.alphabet_len() > 0);",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.pateps_offset > 0);",
                "    assert!(dfa.explicit_slot_start >= 0);",
                "    assert_eq!(dfa.nfa.pattern_len().as_u64(), 1);",
                "    assert!(dfa.nfa.states().len() > 0);",
                "    assert_eq!(dfa.config.match_kind, None);",
                "    assert!(dfa.config.dfa.is_some());",
                "    assert!(dfa.config.nfa_size_limit.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"(abc|def|ghi)+\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.config.match_kind.is_none());",
                "    assert_eq!(dfa.nfa.states().len(), 5);",
                "    assert_eq!(dfa.table.len(), 0);",
                "    assert!(dfa.starts.is_empty());",
                "    assert!(dfa.classes.is_empty());",
                "    assert!(dfa.min_match_id == StateID::MAX);",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert!(dfa.pateps_offset == dfa.alphabet_len);",
                "    assert!(dfa.explicit_slot_start == 10);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"(abc|def|ghi)+\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert!(dfa.config.match_kind.is_none());",
                "    assert_eq!(dfa.nfa.states().len(), 5);",
                "    assert_eq!(dfa.table.len(), 0);",
                "    assert!(dfa.starts.is_empty());",
                "    assert!(dfa.classes.is_empty());",
                "    assert!(dfa.min_match_id == StateID::MAX);",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert!(dfa.pateps_offset == dfa.alphabet_len);",
                "    assert!(dfa.explicit_slot_start == 10);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"(foo|bar|baz)+\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.starts.len() > 0);",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.config.auto_pre, None);",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.classes.alphabet_len() > 0);",
                "    assert!(dfa.pateps_offset > 0);",
                "    assert!(dfa.explicit_slot_start > 0);",
                "    assert!(dfa.nfa.states().len() > 0);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert!(dfa.table.len() <= 512);",
                "    assert!(dfa.starts.iter().all(|&s| s < dfa.table.len()));",
                "    assert_eq!(dfa.config.get_byte_classes(), true);",
                "    assert!(dfa.config.dfa_size_limit.is_none());"
              ],
              "code": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"(foo|bar|baz)+\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert!(dfa.starts.len() > 0);",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.config.auto_pre, None);",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.classes.alphabet_len() > 0);",
                "    assert!(dfa.pateps_offset > 0);",
                "    assert!(dfa.explicit_slot_start > 0);",
                "    assert!(dfa.nfa.states().len() > 0);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert!(dfa.table.len() <= 512);",
                "    assert!(dfa.starts.iter().all(|&s| s < dfa.table.len()));",
                "    assert_eq!(dfa.config.get_byte_classes(), true);",
                "    assert!(dfa.config.dfa_size_limit.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern: String = (0..200).map(|i| format!(\"[a-z]{i}\")).collect::<Vec<String>>().join(\"|\");",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(&pattern)",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.is_ok());",
                "    assert_eq!(dfa.nfa.states().len(), /* expected number of states */);",
                "    assert_eq!(dfa.table.len(), /* expected length of the transition table */);",
                "    assert_eq!(dfa.starts.len(), /* expected number of start states */);",
                "    assert!(dfa.classes.alphabet_len() > 0);",
                "    assert_eq!(dfa.min_match_id, /* expected minimum match ID */);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert_eq!(dfa.alphabet_len, /* expected alphabet length */);",
                "    assert_eq!(dfa.explicit_slot_start, /* expected explicit slot start value */);"
              ],
              "code": [
                "{",
                "    let pattern: String = (0..200).map(|i| format!(\"[a-z]{i}\")).collect::<Vec<String>>().join(\"|\");",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(&pattern)",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert!(dfa.is_ok());",
                "    assert_eq!(dfa.nfa.states().len(), /* expected number of states */);",
                "    assert_eq!(dfa.table.len(), /* expected length of the transition table */);",
                "    assert_eq!(dfa.starts.len(), /* expected number of start states */);",
                "    assert!(dfa.classes.alphabet_len() > 0);",
                "    assert_eq!(dfa.min_match_id, /* expected minimum match ID */);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert_eq!(dfa.alphabet_len, /* expected alphabet length */);",
                "    assert_eq!(dfa.explicit_slot_start, /* expected explicit slot start value */);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"[a-z]+\")",
                "        .unwrap();",
                "    let mut builder = Builder::new();",
                "    builder.configure(Config { byte_classes: Some(false), ..Default::default() });",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.config.byte_classes.is_none());",
                "    assert_eq!(dfa.nfa.pattern_len(), 1);",
                "    assert!(dfa.table.is_empty());",
                "    assert!(dfa.starts.len() > 0);",
                "    assert!(dfa.min_match_id < StateID::MAX);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"[a-z]+\")",
                "        .unwrap();",
                "    let mut builder = Builder::new();",
                "    builder.configure(Config { byte_classes: Some(false), ..Default::default() });",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert!(dfa.config.byte_classes.is_none());",
                "    assert_eq!(dfa.nfa.pattern_len(), 1);",
                "    assert!(dfa.table.is_empty());",
                "    assert!(dfa.starts.len() > 0);",
                "    assert!(dfa.min_match_id < StateID::MAX);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"hello|world\")",
                "        .unwrap();",
                "    let mut builder = Builder::new();",
                "    builder.configure(Config { match_kind: Some(MatchKind::Full), ..Default::default() });",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.starts.len() > 0);",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.classes.alphabet_len(), 256);",
                "    assert!(dfa.config.match_kind.is_some());",
                "    assert!(!dfa.config.dfa_size_limit.is_some());",
                "    assert_eq!(dfa.nfa.states().len(), 3);  // Assuming NFA has 3 states for \"hello|world\"",
                "    assert!(dfa.alphabet_len > 0);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"hello|world\")",
                "        .unwrap();",
                "    let mut builder = Builder::new();",
                "    builder.configure(Config { match_kind: Some(MatchKind::Full), ..Default::default() });",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert!(dfa.starts.len() > 0);",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.classes.alphabet_len(), 256);",
                "    assert!(dfa.config.match_kind.is_some());",
                "    assert!(!dfa.config.dfa_size_limit.is_some());",
                "    assert_eq!(dfa.nfa.states().len(), 3);  // Assuming NFA has 3 states for \"hello|world\"",
                "    assert!(dfa.alphabet_len > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"(\\d{1,3})-(\\d{1,3})\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(builder.config, Config::default());",
                "    assert_eq!(dfa.nfa.pattern_len(), PatternID::from(2));",
                "    assert_eq!(dfa.table.len(), 0);",
                "    assert!(dfa.starts.is_empty());",
                "    assert!(dfa.classes.is_empty());",
                "    assert!(dfa.min_match_id.is_max());",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert_eq!(dfa.pateps_offset, dfa.alphabet_len);",
                "    assert_eq!(dfa.explicit_slot_start, 4);",
                "    assert!(dfa.config.starts_for_each_pattern.is_none());",
                "    assert!(dfa.config.byte_classes.is_none());",
                "    assert!(builder.config.nfa_size_limit.is_none());",
                "    assert!(builder.config.dfa_size_limit.is_none());",
                "    assert!(builder.config.onepass.is_none());",
                "    assert!(builder.config.hybird_cache_capacity.is_none());",
                "    assert!(builder.config.quitset.is_none());"
              ],
              "code": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"(\\d{1,3})-(\\d{1,3})\")",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert_eq!(builder.config, Config::default());",
                "    assert_eq!(dfa.nfa.pattern_len(), PatternID::from(2));",
                "    assert_eq!(dfa.table.len(), 0);",
                "    assert!(dfa.starts.is_empty());",
                "    assert!(dfa.classes.is_empty());",
                "    assert!(dfa.min_match_id.is_max());",
                "    assert!(dfa.alphabet_len > 0);",
                "    assert!(dfa.stride2.is_power_of_two());",
                "    assert_eq!(dfa.pateps_offset, dfa.alphabet_len);",
                "    assert_eq!(dfa.explicit_slot_start, 4);",
                "    assert!(dfa.config.starts_for_each_pattern.is_none());",
                "    assert!(dfa.config.byte_classes.is_none());",
                "    assert!(builder.config.nfa_size_limit.is_none());",
                "    assert!(builder.config.dfa_size_limit.is_none());",
                "    assert!(builder.config.onepass.is_none());",
                "    assert!(builder.config.hybird_cache_capacity.is_none());",
                "    assert!(builder.config.quitset.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"\") // Empty pattern",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.table.is_empty());",
                "    assert!(dfa.starts.is_empty());",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert!(dfa.classes.is_empty());",
                "    assert_eq!(dfa.alphabet_len, 0);",
                "    assert_eq!(dfa.stride2, 1);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::compiler()",
                "        .configure(NFA::config().shrink(true))",
                "        .build(r\"\") // Empty pattern",
                "        .unwrap();",
                "    let builder = Builder::new();",
                "    let dfa = builder.build_from_nfa(nfa).unwrap();",
                "    assert!(dfa.table.is_empty());",
                "    assert!(dfa.starts.is_empty());",
                "    assert_eq!(dfa.min_match_id, StateID::MAX);",
                "    assert!(dfa.classes.is_empty());",
                "    assert_eq!(dfa.alphabet_len, 0);",
                "    assert_eq!(dfa.stride2, 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}