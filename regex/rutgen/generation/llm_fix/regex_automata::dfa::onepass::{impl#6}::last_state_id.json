{
  "name": "regex_automata::dfa::onepass::{impl#6}::last_state_id",
  "mod_info": {
    "name": "dfa::onepass",
    "loc": "regex-automata/src/dfa/mod.rs:339:1:339:17"
  },
  "visible": false,
  "loc": "regex-automata/src/dfa/onepass.rs:2319:5:2327:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "DFA transition table with a length greater than 0, stride2 as a power of 2 ranging from 1 to 9, and StateID as non-negative integers.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 2], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 1,",
                "        stride2: 1, // 2^1 = 2",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.last_state_id() == StateID::new_unchecked(1));",
                "    assert!(dfa.table.len() > 0);",
                "    assert!(dfa.stride2 == 1);",
                "    assert!(dfa.starts.len() == 1);",
                "    assert!(dfa.min_match_id == StateID::default());",
                "    assert!(dfa.alphabet_len == 1);",
                "    assert!(dfa.pateps_offset == 0);",
                "    assert!(dfa.explicit_slot_start == 0);"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 2], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 1,",
                "        stride2: 1, // 2^1 = 2",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert!(dfa.last_state_id() == StateID::new_unchecked(1));",
                "    assert!(dfa.table.len() > 0);",
                "    assert!(dfa.stride2 == 1);",
                "    assert!(dfa.starts.len() == 1);",
                "    assert!(dfa.min_match_id == StateID::default());",
                "    assert!(dfa.alphabet_len == 1);",
                "    assert!(dfa.pateps_offset == 0);",
                "    assert!(dfa.explicit_slot_start == 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 4], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 2,",
                "        stride2: 2, // 2^2 = 4",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(3));",
                "    assert!(dfa.table.len() > 0);",
                "    assert!(dfa.stride2 == 2);",
                "    assert!(dfa.starts.len() > 0);"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 4], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 2,",
                "        stride2: 2, // 2^2 = 4",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(3));",
                "    assert!(dfa.table.len() > 0);",
                "    assert!(dfa.stride2 == 2);",
                "    assert!(dfa.starts.len() > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 8], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 3,",
                "        stride2: 3, // 2^3 = 8",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(7));",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.stride2, 3);",
                "    assert_eq!(dfa.alphabet_len, 3);",
                "    assert_eq!(dfa.starts.len(), 1);",
                "    assert_eq!(dfa.min_match_id, StateID::default());",
                "    assert_eq!(dfa.classes.0, [0; 256]);"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 8], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 3,",
                "        stride2: 3, // 2^3 = 8",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(7));",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.stride2, 3);",
                "    assert_eq!(dfa.alphabet_len, 3);",
                "    assert_eq!(dfa.starts.len(), 1);",
                "    assert_eq!(dfa.min_match_id, StateID::default());",
                "    assert_eq!(dfa.classes.0, [0; 256]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 16], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 4,",
                "        stride2: 4, // 2^4 = 16",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.table.len(), 16);",
                "    assert!(dfa.last_state_id().0 >= 0);",
                "    assert_eq!(dfa.stride2, 4);",
                "    assert_eq!(dfa.last_state_id().0, 3);",
                "    assert!(dfa.last_state_id().0 < (dfa.table.len() >> dfa.stride2()));",
                "    assert!(dfa.last_state_id().0 == (dfa.table.len() >> dfa.stride2()) - 1);",
                "    assert!(dfa.last_state_id().0 >= dfa.min_match_id.0);",
                "    assert!(dfa.start().0 >= 0);"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 16], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 4,",
                "        stride2: 4, // 2^4 = 16",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert_eq!(dfa.table.len(), 16);",
                "    assert!(dfa.last_state_id().0 >= 0);",
                "    assert_eq!(dfa.stride2, 4);",
                "    assert_eq!(dfa.last_state_id().0, 3);",
                "    assert!(dfa.last_state_id().0 < (dfa.table.len() >> dfa.stride2()));",
                "    assert!(dfa.last_state_id().0 == (dfa.table.len() >> dfa.stride2()) - 1);",
                "    assert!(dfa.last_state_id().0 >= dfa.min_match_id.0);",
                "    assert!(dfa.start().0 >= 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 32], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 5,",
                "        stride2: 5, // 2^5 = 32",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(31));"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 32], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 5,",
                "        stride2: 5, // 2^5 = 32",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(31));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 64], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 6,",
                "        stride2: 6, // 2^6 = 64",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(63));",
                "    assert!(!dfa.table.is_empty());",
                "    assert_eq!(dfa.stride2, 6);",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.table.len(), 64);",
                "    assert_eq!(dfa.alphabet_len, 6);",
                "    assert_eq!(dfa.starts.len(), 1);",
                "    assert_eq!(dfa.min_match_id, StateID::default());",
                "    assert_eq!(dfa.classes.0, [0; 256]);"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 64], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 6,",
                "        stride2: 6, // 2^6 = 64",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(63));",
                "    assert!(!dfa.table.is_empty());",
                "    assert_eq!(dfa.stride2, 6);",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.table.len(), 64);",
                "    assert_eq!(dfa.alphabet_len, 6);",
                "    assert_eq!(dfa.starts.len(), 1);",
                "    assert_eq!(dfa.min_match_id, StateID::default());",
                "    assert_eq!(dfa.classes.0, [0; 256]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 128], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 7,",
                "        stride2: 7, // 2^7 = 128",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(127));"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 128], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 7,",
                "        stride2: 7, // 2^7 = 128",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(127));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 256], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 8,",
                "        stride2: 8, // 2^8 = 256",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(255));"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 256], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 8,",
                "        stride2: 8, // 2^8 = 256",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(255));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 512], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 9,",
                "        stride2: 9, // 2^9 = 512",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "}"
              ],
              "oracle": [
                "    assert!(dfa.last_state_id().0 >= 0);",
                "    assert_eq!(dfa.last_state_id().0, (dfa.table.len() >> dfa.stride2()).checked_sub(1).unwrap());",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(511));",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.stride2, 9);",
                "    assert_eq!(dfa.table.len(), 512);"
              ],
              "code": [
                "{",
                "    let dfa = DFA {",
                "        config: Config::default(),",
                "        nfa: NFA::default(),",
                "        table: vec![Transition(0); 512], // Length greater than 0",
                "        starts: vec![StateID::default()],",
                "        min_match_id: StateID::default(),",
                "        classes: ByteClasses([0; 256]),",
                "        alphabet_len: 9,",
                "        stride2: 9, // 2^9 = 512",
                "        pateps_offset: 0,",
                "        explicit_slot_start: 0,",
                "    };",
                "    let _ = dfa.last_state_id();",
                "    assert!(dfa.last_state_id().0 >= 0);",
                "    assert_eq!(dfa.last_state_id().0, (dfa.table.len() >> dfa.stride2()).checked_sub(1).unwrap());",
                "    assert_eq!(dfa.last_state_id(), StateID::new_unchecked(511));",
                "    assert!(dfa.table.len() > 0);",
                "    assert_eq!(dfa.stride2, 9);",
                "    assert_eq!(dfa.table.len(), 512);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}