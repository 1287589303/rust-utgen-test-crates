{
  "name": "regex_automata::nfa::thompson::builder::{impl#0}::goto",
  "mod_info": {
    "name": "nfa::thompson::builder",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:58:1:58:13"
  },
  "visible": false,
  "loc": "regex-automata/src/nfa/thompson/builder.rs:133:5:146:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: *self matches _ at line 144 is true\n",
        "precondition: *self matches State::UnionReverse { ref alternates } at line 139 is false\n",
        "precondition: *self matches State::Empty { next } at line 135 is false\n",
        "precondition: *self matches State::Union { ref alternates } at line 136 is false\n",
        "expected return value/type: None\n"
      ],
      "input_infer": "Self matches any other variant of the State enum that is not Empty, Union, or UnionReverse and does not satisfy the conditions for returning a valid StateID.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::Fail;",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    let state = State::Fail;",
                "    let result = state.goto();",
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let state = State::Fail;",
                "    let _ = state.goto();",
                "    let state = State::Fail;",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::CaptureStart {",
                "        pattern_id: PatternID(SmallIndex(0)),",
                "        group_index: SmallIndex(1),",
                "        next: StateID(SmallIndex(2)),",
                "    };",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    let state = State::CaptureStart {",
                "        pattern_id: PatternID(SmallIndex(0)),",
                "        group_index: SmallIndex(1),",
                "        next: StateID(SmallIndex(2)),",
                "    };",
                "    let _ = state.goto();",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::CaptureEnd {",
                "        pattern_id: PatternID(SmallIndex(1)),",
                "        group_index: SmallIndex(0),",
                "        next: StateID(SmallIndex(3)),",
                "    };",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    let state = State::CaptureEnd {",
                "        pattern_id: PatternID(SmallIndex(1)),",
                "        group_index: SmallIndex(0),",
                "        next: StateID(SmallIndex(3)),",
                "    };",
                "    let _ = state.goto();",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::ByteRange {",
                "        trans: Transition { start: 0, end: 255, next: StateID(SmallIndex(4)) },",
                "    };",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    let state = State::ByteRange { trans: Transition { start: 0, end: 255, next: StateID(SmallIndex(4)) } };",
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    let state = State::ByteRange {",
                "        trans: Transition { start: 0, end: 255, next: StateID(SmallIndex(4)) },",
                "    };",
                "    let _ = state.goto();",
                "    let state = State::ByteRange { trans: Transition { start: 0, end: 255, next: StateID(SmallIndex(4)) } };",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::Sparse {",
                "        transitions: vec![",
                "            Transition { start: 1, end: 2, next: StateID(SmallIndex(5)) },",
                "            Transition { start: 3, end: 4, next: StateID(SmallIndex(6)) },",
                "        ],",
                "    };",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    let state = State::Sparse { transitions: vec![Transition { start: 1, end: 2, next: StateID(SmallIndex(5)) }, Transition { start: 3, end: 4, next: StateID(SmallIndex(6)) }] };",
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    let state = State::Sparse {",
                "        transitions: vec![",
                "            Transition { start: 1, end: 2, next: StateID(SmallIndex(5)) },",
                "            Transition { start: 3, end: 4, next: StateID(SmallIndex(6)) },",
                "        ],",
                "    };",
                "    let _ = state.goto();",
                "    let state = State::Sparse { transitions: vec![Transition { start: 1, end: 2, next: StateID(SmallIndex(5)) }, Transition { start: 3, end: 4, next: StateID(SmallIndex(6)) }] };",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: *self matches State::UnionReverse { ref alternates } at line 134 is true\n",
        "precondition: *self matches State::UnionReverse { ref alternates } at line 134 is true\n",
        "precondition: alternates.len() == 1 at line 140 is false\n",
        "expected return value/type: Some(alternates[0])\n"
      ],
      "input_infer": "State::UnionReverse with alternates containing 0 or more than 1 StateID (e.g., Vec<StateID> with length 0 or greater than 1)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::UnionReverse { alternates: Vec::new() };",
                "    let result = state.goto();",
                "}"
              ],
              "oracle": [
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::UnionReverse { alternates: Vec::new() };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::UnionReverse { alternates: Vec::new() };",
                "    let result = state.goto();",
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::UnionReverse { alternates: Vec::new() };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let next_state_id1 = StateID(SmallIndex(1));",
                "    let next_state_id2 = StateID(SmallIndex(2));",
                "    let state = State::UnionReverse { alternates: vec![next_state_id1, next_state_id2] };",
                "    let result = state.goto();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_none());",
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let next_state_id1 = StateID(SmallIndex(1));",
                "    let next_state_id2 = StateID(SmallIndex(2));",
                "    let state = State::UnionReverse { alternates: vec![next_state_id1, next_state_id2] };",
                "    let result = state.goto();",
                "    assert!(result.is_none());",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: *self matches State::UnionReverse { ref alternates } at line 134 is true\n",
        "precondition: *self matches State::UnionReverse { ref alternates } at line 134 is true\n",
        "precondition: alternates.len() == 1 at line 140 is true\n",
        "expected return value/type: None\n"
      ],
      "input_infer": "*self is an instance of State::UnionReverse with alternates containing more than one element and should not equal 1.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state_id_1 = StateID(SmallIndex(1));",
                "    let state_id_2 = StateID(SmallIndex(2));",
                "    let state_id_3 = StateID(SmallIndex(3));",
                "    ",
                "    let state = State::UnionReverse {",
                "        alternates: vec![state_id_1, state_id_2, state_id_3],",
                "    };",
                "",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    let state_id_1 = StateID(SmallIndex(1));",
                "    let state_id_2 = StateID(SmallIndex(2));",
                "    let state_id_3 = StateID(SmallIndex(3));",
                "    ",
                "    let state = State::UnionReverse {",
                "        alternates: vec![state_id_1, state_id_2, state_id_3],",
                "    };",
                "",
                "    let _ = state.goto();",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::UnionReverse {",
                "        alternates: vec![],",
                "    };",
                "",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    let state = State::UnionReverse { alternates: vec![] };",
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    let state = State::UnionReverse {",
                "        alternates: vec![],",
                "    };",
                "",
                "    let _ = state.goto();",
                "    let state = State::UnionReverse { alternates: vec![] };",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "precondition: *self matches State::Union { ref alternates } at line 134 is true\n",
        "precondition: *self matches State::Union { ref alternates } at line 134 is true\n",
        "precondition: alternates.len() == 1 at line 136 is false\n",
        "expected return value/type: Some(alternates[0])\n"
      ],
      "input_infer": "self matches State::Union { alternates: Vec<StateID> } where alternates.len() > 1\n",
      "answers": [
        {
          "uses": [
            "use crate::util::primitives::SmallIndex;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::util::primitives::SmallIndex;",
                "",
                "    let state_id1 = StateID(SmallIndex(1));",
                "    let state_id2 = StateID(SmallIndex(2));",
                "    let state_id3 = StateID(SmallIndex(3));",
                "",
                "    let alternates = vec![state_id1, state_id2, state_id3];",
                "",
                "    let state = State::Union { alternates };",
                "",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    use crate::util::primitives::SmallIndex;",
                "",
                "    let state_id1 = StateID(SmallIndex(1));",
                "    let state_id2 = StateID(SmallIndex(2));",
                "    let state_id3 = StateID(SmallIndex(3));",
                "",
                "    let alternates = vec![state_id1, state_id2, state_id3];",
                "",
                "    let state = State::Union { alternates };",
                "",
                "    let _ = state.goto();",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::util::primitives::SmallIndex;",
                "",
                "    let state_id1 = StateID(SmallIndex(1));",
                "    let state_id2 = StateID(SmallIndex(2));",
                "    let state_id3 = StateID(SmallIndex(3));",
                "",
                "    let alternates = vec![state_id1, state_id2, state_id3];",
                "",
                "    let state = State::UnionReverse { alternates };",
                "",
                "    let _ = state.goto();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(state.goto(), None);"
              ],
              "code": [
                "{",
                "    use crate::util::primitives::SmallIndex;",
                "",
                "    let state_id1 = StateID(SmallIndex(1));",
                "    let state_id2 = StateID(SmallIndex(2));",
                "    let state_id3 = StateID(SmallIndex(3));",
                "",
                "    let alternates = vec![state_id1, state_id2, state_id3];",
                "",
                "    let state = State::UnionReverse { alternates };",
                "",
                "    let _ = state.goto();",
                "    assert_eq!(state.goto(), None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "precondition: *self matches State::Union { ref alternates } at line 134 is true\n",
        "precondition: *self matches State::Union { ref alternates } at line 134 is true\n",
        "precondition: alternates.len() == 1 at line 136 is true\n",
        "expected return value/type: None\n"
      ],
      "input_infer": "*self should be of type State::Union with alternates having a length of 0 or more than 1.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::Union { alternates: Vec::new() };",
                "    let _result = state.goto();",
                "}"
              ],
              "oracle": [
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(0))] };",
                "    let _result = state.goto();",
                "    assert_eq!(_result, Some(StateID(SmallIndex(0))));"
              ],
              "code": [
                "{",
                "    let state = State::Union { alternates: Vec::new() };",
                "    let _result = state.goto();",
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(0))] };",
                "    let _result = state.goto();",
                "    assert_eq!(_result, Some(StateID(SmallIndex(0))));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(1)), StateID(SmallIndex(2))] };",
                "    let _result = state.goto();",
                "}"
              ],
              "oracle": [
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(1)), StateID(SmallIndex(2))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(1)), StateID(SmallIndex(2))] };",
                "    let _result = state.goto();",
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(1)), StateID(SmallIndex(2))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "precondition: *self matches State::Empty { next } at line 134 is true\n",
        "precondition: *self matches State::Empty { next } at line 134 is true\n",
        "expected return value/type: Some(next)\n"
      ],
      "input_infer": "State::Empty with a valid StateID (next)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::Empty { next: next_state_id };",
                "    let result = state.goto();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Some(next_state_id));"
              ],
              "code": [
                "{",
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::Empty { next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(next_state_id));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let next_state_id = StateID(SmallIndex(2));",
                "    let state = State::Union { alternates: vec![next_state_id] };",
                "    let result = state.goto();",
                "}"
              ],
              "oracle": [
                "    let next_state_id = StateID(SmallIndex(4));",
                "    let state = State::Empty { next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(next_state_id));",
                "    ",
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::Union { alternates: vec![next_state_id] };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(next_state_id));",
                "    ",
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(3)), StateID(SmallIndex(4))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let state = State::UnionReverse { alternates: vec![StateID(SmallIndex(5))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(StateID(SmallIndex(5))));",
                "    ",
                "    let state = State::UnionReverse { alternates: vec![StateID(SmallIndex(10)), StateID(SmallIndex(20))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let state = State::Fail;",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let next_state_id = StateID(SmallIndex(3));",
                "    let state = State::CaptureStart { pattern_id: PatternID(SmallIndex(1)), group_index: SmallIndex(0), next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let next_state_id = StateID(SmallIndex(6));",
                "    let state = State::CaptureEnd { pattern_id: PatternID(SmallIndex(2)), group_index: SmallIndex(1), next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);"
              ],
              "code": [
                "{",
                "    let next_state_id = StateID(SmallIndex(2));",
                "    let state = State::Union { alternates: vec![next_state_id] };",
                "    let result = state.goto();",
                "    let next_state_id = StateID(SmallIndex(4));",
                "    let state = State::Empty { next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(next_state_id));",
                "    ",
                "    let next_state_id = StateID(SmallIndex(1));",
                "    let state = State::Union { alternates: vec![next_state_id] };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(next_state_id));",
                "    ",
                "    let state = State::Union { alternates: vec![StateID(SmallIndex(3)), StateID(SmallIndex(4))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let state = State::UnionReverse { alternates: vec![StateID(SmallIndex(5))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(StateID(SmallIndex(5))));",
                "    ",
                "    let state = State::UnionReverse { alternates: vec![StateID(SmallIndex(10)), StateID(SmallIndex(20))] };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let state = State::Fail;",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let next_state_id = StateID(SmallIndex(3));",
                "    let state = State::CaptureStart { pattern_id: PatternID(SmallIndex(1)), group_index: SmallIndex(0), next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "    ",
                "    let next_state_id = StateID(SmallIndex(6));",
                "    let state = State::CaptureEnd { pattern_id: PatternID(SmallIndex(2)), group_index: SmallIndex(1), next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, None);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let next_state_id = StateID(SmallIndex(3));",
                "    let state = State::UnionReverse { alternates: vec![next_state_id] };",
                "    let result = state.goto();",
                "}"
              ],
              "oracle": [
                "    let next_state_id = StateID(SmallIndex(3));",
                "    let state = State::Empty { next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(next_state_id));"
              ],
              "code": [
                "{",
                "    let next_state_id = StateID(SmallIndex(3));",
                "    let state = State::UnionReverse { alternates: vec![next_state_id] };",
                "    let result = state.goto();",
                "    let next_state_id = StateID(SmallIndex(3));",
                "    let state = State::Empty { next: next_state_id };",
                "    let result = state.goto();",
                "    assert_eq!(result, Some(next_state_id));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}