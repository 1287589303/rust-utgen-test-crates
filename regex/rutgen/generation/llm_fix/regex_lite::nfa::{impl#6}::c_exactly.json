{
  "name": "regex_lite::nfa::{impl#6}::c_exactly",
  "mod_info": {
    "name": "nfa",
    "loc": "regex-lite/src/lib.rs:880:1:880:9"
  },
  "visible": false,
  "loc": "regex-lite/src/nfa.rs:527:5:529:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Valid test input conditions or ranges: n is a non-negative integer (0 to UINT32_MAX), hir represents a valid HIR struct with appropriate kind values and flags set.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, 0);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.unwrap().start, expected_start_id);",
                "    assert_eq!(result.unwrap().end, expected_end_id);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap().captures.len(), expected_captures_count);",
                "    assert_eq!(compiler.c_exactly(&hir, 1).is_ok(), true);",
                "    assert_eq!(compiler.c_exactly(&hir, 5).unwrap().start, expected_start_id_for_n5);",
                "    assert_eq!(compiler.c_exactly(&hir, 10).unwrap().end, expected_end_id_for_n10);",
                "    assert!(matches!(compiler.c_exactly(&hir, 0), Ok(thompson_ref) if thompson_ref.start == thompson_ref.end));",
                "    assert!(matches!(compiler.c_exactly(&hir, 2), Ok(thompson_ref) if thompson_ref.start != thompson_ref.end));",
                "    assert!(matches!(compiler.c_exactly(&hir, n), Ok(thompson_ref) if thompson_ref.captures.len() == n as usize));"
              ],
              "code": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, 0);",
                "    assert_eq!(result.unwrap().start, expected_start_id);",
                "    assert_eq!(result.unwrap().end, expected_end_id);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap().captures.len(), expected_captures_count);",
                "    assert_eq!(compiler.c_exactly(&hir, 1).is_ok(), true);",
                "    assert_eq!(compiler.c_exactly(&hir, 5).unwrap().start, expected_start_id_for_n5);",
                "    assert_eq!(compiler.c_exactly(&hir, 10).unwrap().end, expected_end_id_for_n10);",
                "    assert!(matches!(compiler.c_exactly(&hir, 0), Ok(thompson_ref) if thompson_ref.start == thompson_ref.end));",
                "    assert!(matches!(compiler.c_exactly(&hir, 2), Ok(thompson_ref) if thompson_ref.start != thompson_ref.end));",
                "    assert!(matches!(compiler.c_exactly(&hir, n), Ok(thompson_ref) if thompson_ref.captures.len() == n as usize));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, 1);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    let thompson_ref = result.unwrap();",
                "    assert_eq!(thompson_ref.start, expected_start_state_id);",
                "    assert_eq!(thompson_ref.end, expected_end_state_id);",
                "    assert!(thompson_ref.is_some());"
              ],
              "code": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, 1);",
                "    assert!(result.is_ok());",
                "    let thompson_ref = result.unwrap();",
                "    assert_eq!(thompson_ref.start, expected_start_state_id);",
                "    assert_eq!(thompson_ref.end, expected_end_state_id);",
                "    assert!(thompson_ref.is_some());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(u32::MAX);",
                "}"
              ],
              "oracle": [
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, 0);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 1);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 5);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 10);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, u32::MAX);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 0);",
                "    assert_eq!(result.unwrap().start, result.unwrap().end);"
              ],
              "code": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(u32::MAX);",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, 0);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 1);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 5);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 10);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, u32::MAX);",
                "    assert!(result.is_ok());",
                "    let result = compiler.c_exactly(&hir, 0);",
                "    assert_eq!(result.unwrap().start, result.unwrap().end);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, -1);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.err().unwrap().msg, \"Invalid argument: n must be non-negative\");"
              ],
              "code": [
                "{",
                "    let config = Config { nest_limit: 10, flags: Flags::default() };",
                "    let compiler = Compiler::new(config, String::from(\"test\"));",
                "    let hir = Hir { kind: HirKind::SomeKind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = compiler.c_exactly(&hir, -1);",
                "    assert_eq!(result.is_err(), true);",
                "    assert_eq!(result.err().unwrap().msg, \"Invalid argument: n must be non-negative\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}