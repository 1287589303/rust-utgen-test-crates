{
  "name": "regex_automata::nfa::thompson::compiler::{impl#6}::add_suffix",
  "mod_info": {
    "name": "nfa::thompson::compiler",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:60:1:60:14"
  },
  "visible": false,
  "loc": "regex-automata/src/nfa/thompson/compiler.rs:1819:5:1838:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: ranges.is_empty() at line 1820 is true\n"
      ],
      "input_infer": "ranges: &[Utf8Range] containing only one range with start and end values equal, and state.uncompiled containing at least one Utf8Node with last as None\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: Vec::new(),",
                "            last: None,",
                "        }],",
                "    };",
                "    let ranges = vec![Utf8Range { start: 5, end: 5 }];",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(state.uncompiled.len() == 1);",
                "    assert!(state.uncompiled[0].last.is_none());",
                "    assert!(state.uncompiled[0].last.is_some());",
                "    assert_eq!(state.uncompiled[0].last.as_ref().unwrap().start, 5);",
                "    assert_eq!(state.uncompiled[0].last.as_ref().unwrap().end, 5);",
                "    assert!(state.uncompiled.len() == 1);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: Vec::new(),",
                "            last: None,",
                "        }],",
                "    };",
                "    let ranges = vec![Utf8Range { start: 5, end: 5 }];",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "    assert!(state.uncompiled.len() == 1);",
                "    assert!(state.uncompiled[0].last.is_none());",
                "    assert!(state.uncompiled[0].last.is_some());",
                "    assert_eq!(state.uncompiled[0].last.as_ref().unwrap().start, 5);",
                "    assert_eq!(state.uncompiled[0].last.as_ref().unwrap().end, 5);",
                "    assert!(state.uncompiled.len() == 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[should_panic(expected = \"empty nodes\")]"
              ],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: Vec::new(),",
                "    };",
                "    let ranges = vec![Utf8Range { start: 5, end: 5 }];",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(std::panic::catch_unwind(|| {",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "    compiled: Utf8BoundedMap::default(),",
                "    uncompiled: Vec::new(),",
                "    };",
                "    let ranges: Vec<Uf8Range> = Vec::new();",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "    }).is_err());"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: Vec::new(),",
                "    };",
                "    let ranges = vec![Utf8Range { start: 5, end: 5 }];",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "    assert!(std::panic::catch_unwind(|| {",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "    compiled: Utf8BoundedMap::default(),",
                "    uncompiled: Vec::new(),",
                "    };",
                "    let ranges: Vec<Uf8Range> = Vec::new();",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "    }).is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: Vec::new(),",
                "            last: None,",
                "        }],",
                "    };",
                "    let ranges = vec![",
                "        Utf8Range { start: 3, end: 3 },",
                "        Utf8Range { start: 4, end: 4 },",
                "    ];",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(true);  // Precondition ranges.is_empty() is false, which should trigger the assertion in line 1820.",
                "    assert!(state.uncompiled.is_empty());  // Ensure the uncompiled list is empty before invoking add_suffix to test nearest edges of condition.",
                "    assert!(state.uncompiled.last().unwrap().last.is_none());  // Check if last transition is None before the addition.",
                "    assert_eq!(state.uncompiled.len(), 1);  // Ensure the length of uncompiled is 1 after initialization.",
                "    assert_eq!(state.uncompiled[0].trans.len(), 0);  // Validate that there are no transitions in the uncompiled node.",
                "    assert_eq!(state.uncompiled[0].last, None);  // Confirm last is None before adding a suffix transition."
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: Vec::new(),",
                "            last: None,",
                "        }],",
                "    };",
                "    let ranges = vec![",
                "        Utf8Range { start: 3, end: 3 },",
                "        Utf8Range { start: 4, end: 4 },",
                "    ];",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "    compiler.add_suffix(&ranges);",
                "    assert!(true);  // Precondition ranges.is_empty() is false, which should trigger the assertion in line 1820.",
                "    assert!(state.uncompiled.is_empty());  // Ensure the uncompiled list is empty before invoking add_suffix to test nearest edges of condition.",
                "    assert!(state.uncompiled.last().unwrap().last.is_none());  // Check if last transition is None before the addition.",
                "    assert_eq!(state.uncompiled.len(), 1);  // Ensure the length of uncompiled is 1 after initialization.",
                "    assert_eq!(state.uncompiled[0].trans.len(), 0);  // Validate that there are no transitions in the uncompiled node.",
                "    assert_eq!(state.uncompiled[0].last, None);  // Confirm last is None before adding a suffix transition.",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: ranges.is_empty() at line 1820 is false\n",
        "precondition: self.state.uncompiled[last].last.is_none() at line 1827 is true\n",
        "precondition: r in &ranges[1..] at line 1832 is true\n",
        "precondition: r in &ranges[1..] at line 1832 is false\n"
      ],
      "input_infer": "self.state.uncompiled must have at least 1 element and its last field must be None; ranges must contain at least 2 Utf8Range elements, with valid start and end values for each range\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
                "    };",
                "    let mut compiler = Utf8Compiler {",
                "        builder: &mut builder,",
                "        state: &mut state,",
                "        target: StateID(0),",
                "    };",
                "    ",
                "    let ranges = vec![",
                "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
                "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
                "    ];",
                "    ",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(!ranges.is_empty());",
                "    assert!(self.state.uncompiled[last].last.is_none());",
                "    let last = self.state.uncompiled.len().checked_sub(1).expect(\"non-empty nodes\");",
                "    self.state.uncompiled[last].last = Some(Utf8LastTransition { start: ranges[0].start, end: ranges[0].end });",
                "    assert!(self.state.uncompiled[last].last.is_some());",
                "    let ranges = vec![Utf8Range { start: 0x61, end: 0x61 }, Utf8Range { start: 0x62, end: 0x62 }];",
                "    assert_eq!(self.state.uncompiled.len(), 1);",
                "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().start, 0x62);",
                "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().end, 0x62);",
                "    assert!(self.state.uncompiled[0].last.is_some());",
                "    assert!(self.state.uncompiled[1].last.is_some());",
                "    let ranges_empty: Vec<Utf8Range> = vec![];",
                "    assert!(ranges_empty.is_empty());"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
                "    };",
                "    let mut compiler = Utf8Compiler {",
                "        builder: &mut builder,",
                "        state: &mut state,",
                "        target: StateID(0),",
                "    };",
                "    ",
                "    let ranges = vec![",
                "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
                "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
                "    ];",
                "    ",
                "    compiler.add_suffix(&ranges);",
                "    assert!(!ranges.is_empty());",
                "    assert!(self.state.uncompiled[last].last.is_none());",
                "    let last = self.state.uncompiled.len().checked_sub(1).expect(\"non-empty nodes\");",
                "    self.state.uncompiled[last].last = Some(Utf8LastTransition { start: ranges[0].start, end: ranges[0].end });",
                "    assert!(self.state.uncompiled[last].last.is_some());",
                "    let ranges = vec![Utf8Range { start: 0x61, end: 0x61 }, Utf8Range { start: 0x62, end: 0x62 }];",
                "    assert_eq!(self.state.uncompiled.len(), 1);",
                "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().start, 0x62);",
                "    assert_eq!(self.state.uncompiled[1].last.as_ref().unwrap().end, 0x62);",
                "    assert!(self.state.uncompiled[0].last.is_some());",
                "    assert!(self.state.uncompiled[1].last.is_some());",
                "    let ranges_empty: Vec<Utf8Range> = vec![];",
                "    assert!(ranges_empty.is_empty());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
                "    };",
                "    let mut compiler = Utf8Compiler {",
                "        builder: &mut builder,",
                "        state: &mut state,",
                "        target: StateID(0),",
                "    };",
                "    ",
                "    let ranges = vec![",
                "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
                "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
                "        Utf8Range { start: 0x63, end: 0x63 }, // 'c'",
                "    ];",
                "",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(!ranges.is_empty());",
                "    assert!(self.state.uncompiled[last].last.is_none());",
                "    assert!(r in &ranges[1..]);",
                "    assert!(!(r in &ranges[1..]));"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node { trans: vec![], last: None }],",
                "    };",
                "    let mut compiler = Utf8Compiler {",
                "        builder: &mut builder,",
                "        state: &mut state,",
                "        target: StateID(0),",
                "    };",
                "    ",
                "    let ranges = vec![",
                "        Utf8Range { start: 0x61, end: 0x61 }, // 'a'",
                "        Utf8Range { start: 0x62, end: 0x62 }, // 'b'",
                "        Utf8Range { start: 0x63, end: 0x63 }, // 'c'",
                "    ];",
                "",
                "    compiler.add_suffix(&ranges);",
                "    assert!(!ranges.is_empty());",
                "    assert!(self.state.uncompiled[last].last.is_none());",
                "    assert!(r in &ranges[1..]);",
                "    assert!(!(r in &ranges[1..]));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: ranges.is_empty() at line 1820 is false\n",
        "precondition: self.state.uncompiled[last].last.is_none() at line 1827 is true\n",
        "precondition: r in &ranges[1..] at line 1832 is false\n"
      ],
      "input_infer": "self.state.uncompiled must have at least one element with last field as None; ranges must contain at least one Utf8Range item with start and end values as u8 within the same valid character range, and any subsequent ranges in the array must be empty to satisfy the condition of line 1832\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: vec![],",
                "            last: None,",
                "        }],",
                "    };",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![Utf8Range {",
                "        start: 0x61, // 'a'",
                "        end: 0x61,   // 'a'",
                "    }];",
                "    ",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(!ranges.is_empty()); // Precondition: ranges.is_empty() at line 1820 is false",
                "    assert!(self.state.uncompiled[last].last.is_none()); // Precondition: self.state.uncompiled[last].last.is_none() at line 1827 is true",
                "    assert!(ranges.len() == 1); // Precondition: r in &ranges[1..] at line 1832 is false (no additional ranges)"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: vec![],",
                "            last: None,",
                "        }],",
                "    };",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![Utf8Range {",
                "        start: 0x61, // 'a'",
                "        end: 0x61,   // 'a'",
                "    }];",
                "    ",
                "    compiler.add_suffix(&ranges);",
                "    assert!(!ranges.is_empty()); // Precondition: ranges.is_empty() at line 1820 is false",
                "    assert!(self.state.uncompiled[last].last.is_none()); // Precondition: self.state.uncompiled[last].last.is_none() at line 1827 is true",
                "    assert!(ranges.len() == 1); // Precondition: r in &ranges[1..] at line 1832 is false (no additional ranges)",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: vec![],",
                "            last: None,",
                "        }],",
                "    };",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![",
                "        Utf8Range {",
                "            start: 0x62, // 'b'",
                "            end: 0x62,   // 'b'",
                "        },",
                "        Utf8Range {",
                "            start: 0x63, // 'c'",
                "            end: 0x63,   // 'c'",
                "        },",
                "    ];",
                "",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(!ranges.is_empty());",
                "    assert!(self.state.uncompiled[last].last.is_none());",
                "    assert_eq!(self.state.uncompiled[last].last, None);",
                "    assert!(self.state.uncompiled.len() > 0);",
                "    assert_eq!(self.state.uncompiled[0].trans.len(), 0);",
                "    assert_eq!(self.state.uncompiled[0].last, Some(Utf8LastTransition { start: 0x62, end: 0x62 }));",
                "    assert_eq!(self.state.uncompiled.len(), 2);",
                "    assert_eq!(self.state.uncompiled[1].last, Some(Utf8LastTransition { start: 0x63, end: 0x63 }));"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: vec![],",
                "            last: None,",
                "        }],",
                "    };",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![",
                "        Utf8Range {",
                "            start: 0x62, // 'b'",
                "            end: 0x62,   // 'b'",
                "        },",
                "        Utf8Range {",
                "            start: 0x63, // 'c'",
                "            end: 0x63,   // 'c'",
                "        },",
                "    ];",
                "",
                "    compiler.add_suffix(&ranges);",
                "    assert!(!ranges.is_empty());",
                "    assert!(self.state.uncompiled[last].last.is_none());",
                "    assert_eq!(self.state.uncompiled[last].last, None);",
                "    assert!(self.state.uncompiled.len() > 0);",
                "    assert_eq!(self.state.uncompiled[0].trans.len(), 0);",
                "    assert_eq!(self.state.uncompiled[0].last, Some(Utf8LastTransition { start: 0x62, end: 0x62 }));",
                "    assert_eq!(self.state.uncompiled.len(), 2);",
                "    assert_eq!(self.state.uncompiled[1].last, Some(Utf8LastTransition { start: 0x63, end: 0x63 }));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "precondition: ranges.is_empty() at line 1820 is false\n",
        "precondition: self.state.uncompiled[last].last.is_none() at line 1827 is false\n"
      ],
      "input_infer": "non-empty ranges array with at least one element where the last element of state.uncompiled has a last property set to None, and each range has valid start and end byte values that fall within UTF-8 encoding limits (0-127 for single byte, 0-31 for control bytes, 128-191 for continuation bytes)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: vec![],",
                "            last: None,",
                "        }],",
                "    };",
                "    ",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![",
                "        Utf8Range { start: 65, end: 90 }, // A-Z",
                "    ];",
                "",
                "    state.uncompiled.push(Utf8Node {",
                "        trans: vec![],",
                "        last: Some(Utf8LastTransition { start: 0, end: 0 }),",
                "    });",
                "",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(self.state.uncompiled.len() > 0);",
                "    assert!(self.state.uncompiled.last().unwrap().last.is_some());",
                "    assert_eq!(self.state.uncompiled.last().unwrap().last.as_ref().unwrap().start, 65);",
                "    assert_eq!(self.state.uncompiled.last().unwrap().last.as_ref().unwrap().end, 90);",
                "    assert_eq!(self.state.uncompiled.len(), 2);",
                "    assert!(self.state.uncompiled[0].last.is_none());"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![Utf8Node {",
                "            trans: vec![],",
                "            last: None,",
                "        }],",
                "    };",
                "    ",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![",
                "        Utf8Range { start: 65, end: 90 }, // A-Z",
                "    ];",
                "",
                "    state.uncompiled.push(Utf8Node {",
                "        trans: vec![],",
                "        last: Some(Utf8LastTransition { start: 0, end: 0 }),",
                "    });",
                "",
                "    compiler.add_suffix(&ranges);",
                "    assert!(self.state.uncompiled.len() > 0);",
                "    assert!(self.state.uncompiled.last().unwrap().last.is_some());",
                "    assert_eq!(self.state.uncompiled.last().unwrap().last.as_ref().unwrap().start, 65);",
                "    assert_eq!(self.state.uncompiled.last().unwrap().last.as_ref().unwrap().end, 90);",
                "    assert_eq!(self.state.uncompiled.len(), 2);",
                "    assert!(self.state.uncompiled[0].last.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![",
                "            Utf8Node {",
                "                trans: vec![],",
                "                last: None,",
                "            },",
                "            Utf8Node {",
                "                trans: vec![],",
                "                last: Some(Utf8LastTransition { start: 0, end: 0 }),",
                "            },",
                "        ],",
                "    };",
                "",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![",
                "        Utf8Range { start: 10, end: 20 },",
                "        Utf8Range { start: 30, end: 40 },",
                "    ];",
                "",
                "    compiler.add_suffix(&ranges);",
                "}"
              ],
              "oracle": [
                "    assert!(compiler.state.uncompiled[1].last.is_some());",
                "    assert_eq!(compiler.state.uncompiled.len(), 3);",
                "    assert_eq!(compiler.state.uncompiled[2].last.unwrap().start, 30);",
                "    assert_eq!(compiler.state.uncompiled[2].last.unwrap().end, 40);",
                "    assert_eq!(compiler.state.uncompiled[1].last.unwrap().start, 0);",
                "    assert_eq!(compiler.state.uncompiled[1].last.unwrap().end, 0);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::default();",
                "    let mut state = Utf8State {",
                "        compiled: Utf8BoundedMap::default(),",
                "        uncompiled: vec![",
                "            Utf8Node {",
                "                trans: vec![],",
                "                last: None,",
                "            },",
                "            Utf8Node {",
                "                trans: vec![],",
                "                last: Some(Utf8LastTransition { start: 0, end: 0 }),",
                "            },",
                "        ],",
                "    };",
                "",
                "    let mut compiler = Utf8Compiler::new(&mut builder, &mut state).unwrap();",
                "",
                "    let ranges = vec![",
                "        Utf8Range { start: 10, end: 20 },",
                "        Utf8Range { start: 30, end: 40 },",
                "    ];",
                "",
                "    compiler.add_suffix(&ranges);",
                "    assert!(compiler.state.uncompiled[1].last.is_some());",
                "    assert_eq!(compiler.state.uncompiled.len(), 3);",
                "    assert_eq!(compiler.state.uncompiled[2].last.unwrap().start, 30);",
                "    assert_eq!(compiler.state.uncompiled[2].last.unwrap().end, 40);",
                "    assert_eq!(compiler.state.uncompiled[1].last.unwrap().start, 0);",
                "    assert_eq!(compiler.state.uncompiled[1].last.unwrap().end, 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}