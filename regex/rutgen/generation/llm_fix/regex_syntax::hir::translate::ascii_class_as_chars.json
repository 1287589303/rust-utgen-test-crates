{
  "name": "regex_syntax::hir::translate::ascii_class_as_chars",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:44:1:44:19"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/translate.rs:1352:1:1356:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Test input conditions: ClassAsciiKind variants: Alnum, Alpha, Ascii, Blank, Cntrl, Digit, Graph, Lower, Print, Punct, Space, Upper, Word, Xdigit.\n",
      "answers": [
        {
          "uses": [
            "use crate::ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\x00', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\t', '\\t'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('a', 'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('A', 'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alnum;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\x00', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\t', '\\t'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9')]);",
                "    let kind = ClassAsciiKind::Graph;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('a', 'z')]);",
                "    let kind = ClassAsciiKind::Print;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Upper;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('A', 'Z')]);",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9')]);",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('a', 'z')]);",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('A', 'Z')]);",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Alpha;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9')]);",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('a', 'z')]);",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('A', 'Z')]);",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char), (65 as char, 90 as char), (97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(65 as char, 90 as char), (97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', ' '), ('\\t', '\\t')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char)]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', ' '), ('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(65 as char, 90 as char)]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char), (65 as char, 90 as char), ('_', '_'), (97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char), (65 as char, 70 as char), (97 as char, 102 as char)]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Ascii;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char), (65 as char, 90 as char), (97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(65 as char, 90 as char), (97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Blank; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', ' '), ('\\t', '\\t')]);",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char)]);",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Print; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', ' '), ('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r')]);",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(65 as char, 90 as char)]);",
                "    let kind = ClassAsciiKind::Word; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char), (65 as char, 90 as char), ('_', '_'), (97 as char, 122 as char)]);",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(48 as char, 57 as char), (65 as char, 70 as char), (97 as char, 102 as char)]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\x00', '\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', '~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('A', 'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Blank;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Alpha; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Ascii; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\x00', '\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Cntrl; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    ",
                "    let kind = ClassAsciiKind::Digit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9')]);",
                "    ",
                "    let kind = ClassAsciiKind::Graph; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Lower; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Print; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![(' ', '~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Punct; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    ",
                "    let kind = ClassAsciiKind::Space; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    ",
                "    let kind = ClassAsciiKind::Upper; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('A', 'Z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Word; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    ",
                "    let kind = ClassAsciiKind::Xdigit; let result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9')]);",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('a', 'z')]);",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('A', 'Z')]);",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Cntrl;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('A', 'Z'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9')]);",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '~')]);",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('a', 'z')]);",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![(' ', '~')]);",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('A', 'Z')]);",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect(); assert_eq!(_result, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, vec![('0', '9')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Digit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Graph;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, vec![('a', 'a'), ('b', 'b'), ('c', 'c'), ('d', 'd'), ('e', 'e'), ('f', 'f'), ('g', 'g'), ('h', 'h'), ('i', 'i'), ('j', 'j'), ('k', 'k'), ('l', 'l'), ('m', 'm'), ('n', 'n'), ('o', 'o'), ('p', 'p'), ('q', 'q'), ('r', 'r'), ('s', 's'), ('t', 't'), ('u', 'u'), ('v', 'v'), ('w', 'w'), ('x', 'x'), ('y', 'y'), ('z', 'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Lower;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('a', 'a'), ('b', 'b'), ('c', 'c'), ('d', 'd'), ('e', 'e'), ('f', 'f'), ('g', 'g'), ('h', 'h'), ('i', 'i'), ('j', 'j'), ('k', 'k'), ('l', 'l'), ('m', 'm'), ('n', 'n'), ('o', 'o'), ('p', 'p'), ('q', 'q'), ('r', 'r'), ('s', 's'), ('t', 't'), ('u', 'u'), ('v', 'v'), ('w', 'w'), ('x', 'x'), ('y', 'y'), ('z', 'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind_print = ClassAsciiKind::Print;",
                "    let result_print: Vec<_> = ascii_class_as_chars(&kind_print).collect();",
                "    assert_eq!(result_print, vec![(' ', '~')]);",
                "    ",
                "    let kind_digit = ClassAsciiKind::Digit;",
                "    let result_digit: Vec<_> = ascii_class_as_chars(&kind_digit).collect();",
                "    assert_eq!(result_digit, vec![('0', '9')]);",
                "    ",
                "    let kind_alpha = ClassAsciiKind::Alpha;",
                "    let result_alpha: Vec<_> = ascii_class_as_chars(&kind_alpha).collect();",
                "    assert_eq!(result_alpha, vec![('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind_upper = ClassAsciiKind::Upper;",
                "    let result_upper: Vec<_> = ascii_class_as_chars(&kind_upper).collect();",
                "    assert_eq!(result_upper, vec![('A', 'Z')]);",
                "    ",
                "    let kind_lower = ClassAsciiKind::Lower;",
                "    let result_lower: Vec<_> = ascii_class_as_chars(&kind_lower).collect();",
                "    assert_eq!(result_lower, vec![('a', 'z')]);",
                "    ",
                "    let kind_space = ClassAsciiKind::Space;",
                "    let result_space: Vec<_> = ascii_class_as_chars(&kind_space).collect();",
                "    assert_eq!(result_space, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    ",
                "    let kind_cntrl = ClassAsciiKind::Cntrl;",
                "    let result_cntrl: Vec<_> = ascii_class_as_chars(&kind_cntrl).collect();",
                "    assert_eq!(result_cntrl, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    ",
                "    let kind_alnum = ClassAsciiKind::Alnum;",
                "    let result_alnum: Vec<_> = ascii_class_as_chars(&kind_alnum).collect();",
                "    assert_eq!(result_alnum, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind_graph = ClassAsciiKind::Graph;",
                "    let result_graph: Vec<_> = ascii_class_as_chars(&kind_graph).collect();",
                "    assert_eq!(result_graph, vec![('!', '~')]);",
                "    ",
                "    let kind_punct = ClassAsciiKind::Punct;",
                "    let result_punct: Vec<_> = ascii_class_as_chars(&kind_punct).collect();",
                "    assert_eq!(result_punct, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    ",
                "    let kind_word = ClassAsciiKind::Word;",
                "    let result_word: Vec<_> = ascii_class_as_chars(&kind_word).collect();",
                "    assert_eq!(result_word, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    ",
                "    let kind_xdigit = ClassAsciiKind::Xdigit;",
                "    let result_xdigit: Vec<_> = ascii_class_as_chars(&kind_xdigit).collect();",
                "    assert_eq!(result_xdigit, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Print;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind_print = ClassAsciiKind::Print;",
                "    let result_print: Vec<_> = ascii_class_as_chars(&kind_print).collect();",
                "    assert_eq!(result_print, vec![(' ', '~')]);",
                "    ",
                "    let kind_digit = ClassAsciiKind::Digit;",
                "    let result_digit: Vec<_> = ascii_class_as_chars(&kind_digit).collect();",
                "    assert_eq!(result_digit, vec![('0', '9')]);",
                "    ",
                "    let kind_alpha = ClassAsciiKind::Alpha;",
                "    let result_alpha: Vec<_> = ascii_class_as_chars(&kind_alpha).collect();",
                "    assert_eq!(result_alpha, vec![('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind_upper = ClassAsciiKind::Upper;",
                "    let result_upper: Vec<_> = ascii_class_as_chars(&kind_upper).collect();",
                "    assert_eq!(result_upper, vec![('A', 'Z')]);",
                "    ",
                "    let kind_lower = ClassAsciiKind::Lower;",
                "    let result_lower: Vec<_> = ascii_class_as_chars(&kind_lower).collect();",
                "    assert_eq!(result_lower, vec![('a', 'z')]);",
                "    ",
                "    let kind_space = ClassAsciiKind::Space;",
                "    let result_space: Vec<_> = ascii_class_as_chars(&kind_space).collect();",
                "    assert_eq!(result_space, vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    ",
                "    let kind_cntrl = ClassAsciiKind::Cntrl;",
                "    let result_cntrl: Vec<_> = ascii_class_as_chars(&kind_cntrl).collect();",
                "    assert_eq!(result_cntrl, vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    ",
                "    let kind_alnum = ClassAsciiKind::Alnum;",
                "    let result_alnum: Vec<_> = ascii_class_as_chars(&kind_alnum).collect();",
                "    assert_eq!(result_alnum, vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    ",
                "    let kind_graph = ClassAsciiKind::Graph;",
                "    let result_graph: Vec<_> = ascii_class_as_chars(&kind_graph).collect();",
                "    assert_eq!(result_graph, vec![('!', '~')]);",
                "    ",
                "    let kind_punct = ClassAsciiKind::Punct;",
                "    let result_punct: Vec<_> = ascii_class_as_chars(&kind_punct).collect();",
                "    assert_eq!(result_punct, vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    ",
                "    let kind_word = ClassAsciiKind::Word;",
                "    let result_word: Vec<_> = ascii_class_as_chars(&kind_word).collect();",
                "    assert_eq!(result_word, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    ",
                "    let kind_xdigit = ClassAsciiKind::Xdigit;",
                "    let result_xdigit: Vec<_> = ascii_class_as_chars(&kind_xdigit).collect();",
                "    assert_eq!(result_xdigit, vec![('0', '9'), ('A', 'F'), ('a', 'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Punct;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Upper; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alnum).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alpha).collect::<Vec<_>>(), vec![('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Ascii).collect::<Vec<_>>(), vec![('\\x00', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Blank).collect::<Vec<_>>(), vec![('\\t', '\\t'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Cntrl).collect::<Vec<_>>(), vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Digit).collect::<Vec<_>>(), vec![('0', '9')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Graph).collect::<Vec<_>>(), vec![('!', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Lower).collect::<Vec<_>>(), vec![('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Print).collect::<Vec<_>>(), vec![(' ', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Punct).collect::<Vec<_>>(), vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Space).collect::<Vec<_>>(), vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Upper).collect::<Vec<_>>(), vec![('A', 'Z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Word).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Xdigit).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'F'), ('a', 'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Space;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alnum).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alpha).collect::<Vec<_>>(), vec![('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Ascii).collect::<Vec<_>>(), vec![('\\x00', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Blank).collect::<Vec<_>>(), vec![('\\t', '\\t'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Cntrl).collect::<Vec<_>>(), vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Digit).collect::<Vec<_>>(), vec![('0', '9')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Graph).collect::<Vec<_>>(), vec![('!', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Lower).collect::<Vec<_>>(), vec![('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Print).collect::<Vec<_>>(), vec![(' ', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Punct).collect::<Vec<_>>(), vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Space).collect::<Vec<_>>(), vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Upper).collect::<Vec<_>>(), vec![('A', 'Z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Word).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Xdigit).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'F'), ('a', 'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Upper;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alnum; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Alpha; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Ascii; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Blank; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Cntrl; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Digit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Graph; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Lower; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Print; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Punct; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Space; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Word; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    let kind = ClassAsciiKind::Xdigit; let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Word;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(_result, vec![('0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alnum).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alpha).collect::<Vec<_>>(), vec![('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Ascii).collect::<Vec<_>>(), vec![('\\x00', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Blank).collect::<Vec<_>>(), vec![('\\t', '\\t'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Cntrl).collect::<Vec<_>>(), vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Digit).collect::<Vec<_>>(), vec![('0', '9')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Graph).collect::<Vec<_>>(), vec![('!', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Lower).collect::<Vec<_>>(), vec![('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Print).collect::<Vec<_>>(), vec![(' ', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Punct).collect::<Vec<_>>(), vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Space).collect::<Vec<_>>(), vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Upper).collect::<Vec<_>>(), vec![('A', 'Z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Word).collect::<Vec<_>>(), vec![( '0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Xdigit).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'F'), ('a', 'f')]);"
              ],
              "code": [
                "{",
                "    use crate::ast::ClassAsciiKind;",
                "    let kind = ClassAsciiKind::Xdigit;",
                "    let _result: Vec<_> = ascii_class_as_chars(&kind).collect();",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alnum).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Alpha).collect::<Vec<_>>(), vec![('A', 'Z'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Ascii).collect::<Vec<_>>(), vec![('\\x00', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Blank).collect::<Vec<_>>(), vec![('\\t', '\\t'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Cntrl).collect::<Vec<_>>(), vec![('\\x00', '\\x1F'), ('\\x7F', '\\x7F')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Digit).collect::<Vec<_>>(), vec![('0', '9')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Graph).collect::<Vec<_>>(), vec![('!', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Lower).collect::<Vec<_>>(), vec![('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Print).collect::<Vec<_>>(), vec![(' ', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Punct).collect::<Vec<_>>(), vec![('!', '/'), (':', '@'), ('[', '`'), ('{', '~')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Space).collect::<Vec<_>>(), vec![('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'), ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Upper).collect::<Vec<_>>(), vec![('A', 'Z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Word).collect::<Vec<_>>(), vec![( '0', '9'), ('A', 'Z'), ('_', '_'), ('a', 'z')]);",
                "    assert_eq!(ascii_class_as_chars(&ClassAsciiKind::Xdigit).collect::<Vec<_>>(), vec![('0', '9'), ('A', 'F'), ('a', 'f')]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}