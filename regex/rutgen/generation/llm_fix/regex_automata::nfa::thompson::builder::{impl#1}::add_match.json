{
  "name": "regex_automata::nfa::thompson::builder::{impl#1}::add_match",
  "mod_info": {
    "name": "nfa::thompson::builder",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:58:1:58:13"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/builder.rs:1105:5:1109:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.add(State::Match { pattern_id })? at line 1107 is Err/None\n"
      ],
      "input_infer": "self.pattern_id must be set after start_pattern is called, the state identifier space should not be exhausted (test with 0 and limit - 1), memory usage should not exceed size limit (test with exact size limit values), and ensure that calling this method without a prior start_pattern results in a panic.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.add_match();",
                "}"
              ],
              "oracle": [
                "    assert!(builder.add_match().is_err());",
                "    assert!(builder.states.is_empty());",
                "    assert!(builder.memory_states == 0);",
                "    assert!(builder.pattern_id.is_none());"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.add_match();",
                "    assert!(builder.add_match().is_err());",
                "    assert!(builder.states.is_empty());",
                "    assert!(builder.memory_states == 0);",
                "    assert!(builder.pattern_id.is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    let _ = builder.add_match().unwrap();",
                "}"
              ],
              "oracle": [
                "    builder.start_pattern().unwrap();",
                "    assert!(builder.add_match().is_err());",
                "    builder.finish_pattern(builder.current_pattern_id()).unwrap();"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    let _ = builder.add_match().unwrap();",
                "    builder.start_pattern().unwrap();",
                "    assert!(builder.add_match().is_err());",
                "    builder.finish_pattern(builder.current_pattern_id()).unwrap();",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    for _ in 0..=u32::MAX {",
                "        let _ = builder.add_match();",
                "    }",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    for _ in 0..=u32::MAX {",
                "    let _ = builder.add_match();",
                "    }",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::StateIdentifierExhausted);",
                "    assert_eq!(builder.memory_usage(), expected_memory_usage);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    for _ in 0..=u32::MAX {",
                "        let _ = builder.add_match();",
                "    }",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    for _ in 0..=u32::MAX {",
                "    let _ = builder.add_match();",
                "    }",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::StateIdentifierExhausted);",
                "    assert_eq!(builder.memory_usage(), expected_memory_usage);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    builder.set_size_limit(Some(0)).unwrap(); // Set size limit to 0",
                "    let _ = builder.start_pattern().unwrap();",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::SizeLimitExceeded);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    builder.set_size_limit(Some(0)).unwrap(); // Set size limit to 0",
                "    let _ = builder.start_pattern().unwrap();",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::SizeLimitExceeded);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    builder.memory_states = 100; // Set the memory state usage to exactly 100",
                "    builder.set_size_limit(Some(100)).unwrap();",
                "    let result = builder.add_match();",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    builder.memory_states = 200;",
                "    builder.set_size_limit(Some(150)).unwrap();",
                "    assert!(result.is_err());",
                "    builder.memory_states = 100;",
                "    builder.set_size_limit(None).unwrap();",
                "    assert!(result.is_ok());",
                "    builder.clear();",
                "    assert!(builder.pattern_len() == 0);",
                "    builder.add_match().unwrap();",
                "    assert!(builder.get_size_limit().is_none());",
                "    builder.finish_pattern(builder.start_pattern().unwrap()).unwrap();"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    builder.memory_states = 100; // Set the memory state usage to exactly 100",
                "    builder.set_size_limit(Some(100)).unwrap();",
                "    let result = builder.add_match();",
                "    assert!(result.is_ok());",
                "    assert!(result.is_err());",
                "    builder.memory_states = 200;",
                "    builder.set_size_limit(Some(150)).unwrap();",
                "    assert!(result.is_err());",
                "    builder.memory_states = 100;",
                "    builder.set_size_limit(None).unwrap();",
                "    assert!(result.is_ok());",
                "    builder.clear();",
                "    assert!(builder.pattern_len() == 0);",
                "    builder.add_match().unwrap();",
                "    assert!(builder.get_size_limit().is_none());",
                "    builder.finish_pattern(builder.start_pattern().unwrap()).unwrap();",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    for _ in 0..u32::MAX - 1 {",
                "        let _ = builder.add_match().unwrap();",
                "    }",
                "    let result = builder.add_match();",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracle": [
                "    assert!(builder.memory_usage() < Some(usize::MAX));",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().kind, BuildErrorKind::TooManyStates);",
                "    assert!(builder.states.len() < u32::MAX as usize);",
                "    assert!(builder.pattern_len() > 0);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let _ = builder.start_pattern().unwrap();",
                "    for _ in 0..u32::MAX - 1 {",
                "        let _ = builder.add_match().unwrap();",
                "    }",
                "    let result = builder.add_match();",
                "    assert!(result.is_ok());",
                "    assert!(builder.memory_usage() < Some(usize::MAX));",
                "    assert!(result.is_err());",
                "    assert_eq!(result.err().unwrap().kind, BuildErrorKind::TooManyStates);",
                "    assert!(builder.states.len() < u32::MAX as usize);",
                "    assert!(builder.pattern_len() > 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.add(State::Match { pattern_id })? at line 1107 is Ok/Some\n",
        "expected return value/type: Ok(sid)\n"
      ],
      "input_infer": "self.pattern_id must be set (a valid PatternID), self.states must not exceed configured state identifier limits, self.memory_states must not exceed configured heap size limits, valid StateID must be returned; ensure to test with various sizes and limits including edge cases (0, MAX_STATE_ID, exceeding limits).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(None).unwrap();",
                "    let state_id = builder.add_match().unwrap();",
                "}"
              ],
              "oracle": [
                "    builder.add_match().expect(\"Expected add_match to succeed\");",
                "    builder.pattern_id.is_some();",
                "    builder.memory_states == 0;",
                "    builder.get_size_limit().is_none();"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(None).unwrap();",
                "    let state_id = builder.add_match().unwrap();",
                "    builder.add_match().expect(\"Expected add_match to succeed\");",
                "    builder.pattern_id.is_some();",
                "    builder.memory_states == 0;",
                "    builder.get_size_limit().is_none();",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(Some(100)).unwrap();",
                "    let state_id = builder.add_match().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(builder.memory_states, 0);",
                "    assert!(builder.pattern_id.is_some());",
                "    assert!(builder.current_pattern_id() == pattern_id);",
                "    assert_eq!(builder.get_size_limit(), Some(100));",
                "    assert!(builder.add(State::Match { pattern_id }).is_ok());",
                "    assert!(state_id != StateID::default());"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(Some(100)).unwrap();",
                "    let state_id = builder.add_match().unwrap();",
                "    assert_eq!(builder.memory_states, 0);",
                "    assert!(builder.pattern_id.is_some());",
                "    assert!(builder.current_pattern_id() == pattern_id);",
                "    assert_eq!(builder.get_size_limit(), Some(100));",
                "    assert!(builder.add(State::Match { pattern_id }).is_ok());",
                "    assert!(state_id != StateID::default());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    ",
                "    for _ in 0..5 {",
                "        builder.add_match().unwrap();",
                "    }",
                "    ",
                "    let state_id = builder.add_match().unwrap();",
                "}"
              ],
              "oracle": [
                "    assert!(builder.pattern_id.is_some());",
                "    assert_eq!(builder.states.len(), 6);",
                "    assert!(matches!(builder.add_match(), Ok(_)));",
                "    assert!(builder.current_pattern_id() == pattern_id);",
                "    assert!(builder.memory_states > 0);",
                "    assert!(builder.size_limit.is_none() || builder.memory_usage() <= builder.size_limit.unwrap());",
                "    assert!(builder.states.last().unwrap().is_match);",
                "    assert!(builder.states.last().unwrap().transitions.is_empty());",
                "    assert!(builder.states.last().unwrap().pattern_ids == pattern_id.0.to_le_bytes());",
                "    assert_eq!(builder.add(State::Match { pattern_id }).is_ok(), true);"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    ",
                "    for _ in 0..5 {",
                "        builder.add_match().unwrap();",
                "    }",
                "    ",
                "    let state_id = builder.add_match().unwrap();",
                "    assert!(builder.pattern_id.is_some());",
                "    assert_eq!(builder.states.len(), 6);",
                "    assert!(matches!(builder.add_match(), Ok(_)));",
                "    assert!(builder.current_pattern_id() == pattern_id);",
                "    assert!(builder.memory_states > 0);",
                "    assert!(builder.size_limit.is_none() || builder.memory_usage() <= builder.size_limit.unwrap());",
                "    assert!(builder.states.last().unwrap().is_match);",
                "    assert!(builder.states.last().unwrap().transitions.is_empty());",
                "    assert!(builder.states.last().unwrap().pattern_ids == pattern_id.0.to_le_bytes());",
                "    assert_eq!(builder.add(State::Match { pattern_id }).is_ok(), true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(Some(1)).unwrap();",
                "    ",
                "    // Test adding one match after setting a limit.",
                "    let _ = builder.add_match().unwrap();",
                "    ",
                "    // Test that an additional match exceeds the limit.",
                "    builder.memory_states = 1; // Simulating having one state already.",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(Some(1)).unwrap();",
                "    let match_state_id = builder.add_match().unwrap();",
                "    assert_eq!(match_state_id, expected_sid);",
                "    builder.memory_states = 1;",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());"
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(Some(1)).unwrap();",
                "    ",
                "    // Test adding one match after setting a limit.",
                "    let _ = builder.add_match().unwrap();",
                "    ",
                "    // Test that an additional match exceeds the limit.",
                "    builder.memory_states = 1; // Simulating having one state already.",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "    builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.memory_states = 0;",
                "    builder.set_size_limit(Some(1)).unwrap();",
                "    let match_state_id = builder.add_match().unwrap();",
                "    assert_eq!(match_state_id, expected_sid);",
                "    builder.memory_states = 1;",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.set_size_limit(None).unwrap();",
                "    ",
                "    // Fill state identifier space to its maximum.",
                "    let max_states = SmallIndex::MAX as usize;",
                "    for _ in 0..max_states {",
                "        builder.add_match().unwrap();",
                "    }",
                "    ",
                "    // One more match should exceed the state identifier limit.",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracle": [
                "    builder.add_match(); // Check adding match state when pattern_id is set and size limit is None.",
                "    builder.current_pattern_id(); // Verify that the correct PatternID is returned after start_pattern.",
                "    builder.finish_pattern(builder.start_pattern().unwrap()).unwrap(); // Ensure that calling finish_pattern after start_pattern is valid.",
                "    builder.add_match().unwrap(); // Confirm that a match state can be added after starting a pattern.",
                "    builder.set_size_limit(Some(0)).unwrap(); // Set size limit to 0 to test exceeding conditions.",
                "    assert!(matches!(builder.add_match(), Err(BuildError::too_many_states(_)))); // Validate that adding match exceeds state identifier space.",
                "    assert_eq!(builder.memory_states, 0); // Ensure no memory is used when the size limit is set to zero.",
                "    builder.clear(); // Test clearing the builder after errors to ensure reset state.",
                "    builder.add_match().unwrap(); // Validate adding match after clearing builder works as expected."
              ],
              "code": [
                "{",
                "    let mut builder = Builder::new();",
                "    let pattern_id = builder.start_pattern().unwrap();",
                "    builder.pattern_id = Some(pattern_id);",
                "    builder.set_size_limit(None).unwrap();",
                "    ",
                "    // Fill state identifier space to its maximum.",
                "    let max_states = SmallIndex::MAX as usize;",
                "    for _ in 0..max_states {",
                "        builder.add_match().unwrap();",
                "    }",
                "    ",
                "    // One more match should exceed the state identifier limit.",
                "    let result = builder.add_match();",
                "    assert!(result.is_err());",
                "    builder.add_match(); // Check adding match state when pattern_id is set and size limit is None.",
                "    builder.current_pattern_id(); // Verify that the correct PatternID is returned after start_pattern.",
                "    builder.finish_pattern(builder.start_pattern().unwrap()).unwrap(); // Ensure that calling finish_pattern after start_pattern is valid.",
                "    builder.add_match().unwrap(); // Confirm that a match state can be added after starting a pattern.",
                "    builder.set_size_limit(Some(0)).unwrap(); // Set size limit to 0 to test exceeding conditions.",
                "    assert!(matches!(builder.add_match(), Err(BuildError::too_many_states(_)))); // Validate that adding match exceeds state identifier space.",
                "    assert_eq!(builder.memory_states, 0); // Ensure no memory is used when the size limit is set to zero.",
                "    builder.clear(); // Test clearing the builder after errors to ensure reset state.",
                "    builder.add_match().unwrap(); // Validate adding match after clearing builder works as expected.",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}