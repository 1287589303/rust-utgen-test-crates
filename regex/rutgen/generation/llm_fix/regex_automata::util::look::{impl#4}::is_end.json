{
  "name": "regex_automata::util::look::{impl#4}::is_end",
  "mod_info": {
    "name": "util::look",
    "loc": "regex-automata/src/util/mod.rs:38:1:38:14"
  },
  "visible": true,
  "loc": "regex-automata/src/util/look.rs:919:5:921:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: at == haystack.len()\n"
      ],
      "input_infer": "haystack as a non-empty byte slice with lengths from 0 to 10, at as 0 to 10 (including edge case where at == haystack.len())\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[];",
                "    let matcher = LookMatcher::new();",
                "    let at = 0;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    let haystack: &[u8] = &[1, 2, 3];",
                "    let at = 3;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    let at = 4;",
                "    assert_panics!(matcher.is_end(haystack, at));",
                "    let at = 2;",
                "    assert_eq!(matcher.is_end(haystack, at), false);"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[];",
                "    let matcher = LookMatcher::new();",
                "    let at = 0;",
                "    matcher.is_end(haystack, at);",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    let haystack: &[u8] = &[1, 2, 3];",
                "    let at = 3;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    let at = 4;",
                "    assert_panics!(matcher.is_end(haystack, at));",
                "    let at = 2;",
                "    assert_eq!(matcher.is_end(haystack, at), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1];",
                "    let matcher = LookMatcher::new();",
                "    let at = 1;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    let haystack: &[u8] = &[1];",
                "    let matcher = LookMatcher::new();",
                "    let at = 1;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    ",
                "    let haystack: &[u8] = &[1, 2, 3];",
                "    let matcher = LookMatcher::new();",
                "    let at = 3;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    ",
                "    let haystack: &[u8] = &[1, 2];",
                "    let matcher = LookMatcher::new();",
                "    let at = 2;",
                "    assert_eq!(matcher.is_end(haystack, at), false);",
                "    ",
                "    let haystack: &[u8] = &[];",
                "    let matcher = LookMatcher::new();",
                "    let at = 0;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    ",
                "    let haystack: &[u8] = &[1];",
                "    let matcher = LookMatcher::new();",
                "    let at = 2;",
                "    assert_eq!(matcher.is_end(haystack, at), false);"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1];",
                "    let matcher = LookMatcher::new();",
                "    let at = 1;",
                "    matcher.is_end(haystack, at);",
                "    let haystack: &[u8] = &[1];",
                "    let matcher = LookMatcher::new();",
                "    let at = 1;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    ",
                "    let haystack: &[u8] = &[1, 2, 3];",
                "    let matcher = LookMatcher::new();",
                "    let at = 3;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    ",
                "    let haystack: &[u8] = &[1, 2];",
                "    let matcher = LookMatcher::new();",
                "    let at = 2;",
                "    assert_eq!(matcher.is_end(haystack, at), false);",
                "    ",
                "    let haystack: &[u8] = &[];",
                "    let matcher = LookMatcher::new();",
                "    let at = 0;",
                "    assert_eq!(matcher.is_end(haystack, at), true);",
                "    ",
                "    let haystack: &[u8] = &[1];",
                "    let matcher = LookMatcher::new();",
                "    let at = 2;",
                "    assert_eq!(matcher.is_end(haystack, at), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2];",
                "    let matcher = LookMatcher::new();",
                "    let at = 2;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(matcher.is_end(haystack, 2), true);",
                "    assert_eq!(matcher.is_end(haystack, 1), false);",
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 3), false);"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2];",
                "    let matcher = LookMatcher::new();",
                "    let at = 2;",
                "    matcher.is_end(haystack, at);",
                "    assert_eq!(matcher.is_end(haystack, 2), true);",
                "    assert_eq!(matcher.is_end(haystack, 1), false);",
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 3), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3];",
                "    let matcher = LookMatcher::new();",
                "    let at = 3;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(matcher.is_end(haystack, 3), true);",
                "    assert_eq!(matcher.is_end(haystack, 2), false);",
                "    assert_eq!(matcher.is_end(haystack, 4), false);",
                "    assert_eq!(matcher.is_end(b\"\", 0), true);",
                "    assert_eq!(matcher.is_end(b\"abc\", 3), true);",
                "    assert_eq!(matcher.is_end(b\"abc\", 2), false);",
                "    assert_eq!(matcher.is_end(b\"abc\", 4), false);",
                "    assert_eq!(matcher.is_end(b\"abc\", usize::MAX), false);"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3];",
                "    let matcher = LookMatcher::new();",
                "    let at = 3;",
                "    matcher.is_end(haystack, at);",
                "    assert_eq!(matcher.is_end(haystack, 3), true);",
                "    assert_eq!(matcher.is_end(haystack, 2), false);",
                "    assert_eq!(matcher.is_end(haystack, 4), false);",
                "    assert_eq!(matcher.is_end(b\"\", 0), true);",
                "    assert_eq!(matcher.is_end(b\"abc\", 3), true);",
                "    assert_eq!(matcher.is_end(b\"abc\", 2), false);",
                "    assert_eq!(matcher.is_end(b\"abc\", 4), false);",
                "    assert_eq!(matcher.is_end(b\"abc\", usize::MAX), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4];",
                "    let matcher = LookMatcher::new();",
                "    let at = 4;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 1), false);",
                "    assert_eq!(matcher.is_end(haystack, 2), false);",
                "    assert_eq!(matcher.is_end(haystack, 3), false);",
                "    assert_eq!(matcher.is_end(haystack, 4), true);",
                "    assert_eq!(matcher.is_end(haystack, 5), false);"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4];",
                "    let matcher = LookMatcher::new();",
                "    let at = 4;",
                "    matcher.is_end(haystack, at);",
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 1), false);",
                "    assert_eq!(matcher.is_end(haystack, 2), false);",
                "    assert_eq!(matcher.is_end(haystack, 3), false);",
                "    assert_eq!(matcher.is_end(haystack, 4), true);",
                "    assert_eq!(matcher.is_end(haystack, 5), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5];",
                "    let matcher = LookMatcher::new();",
                "    let at = 5;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(matcher.is_end(haystack, 5), true);  // at == haystack.len()",
                "    assert_eq!(matcher.is_end(haystack, 0), false);  // at < haystack.len()",
                "    assert_eq!(matcher.is_end(haystack, 3), false);  // at < haystack.len()",
                "    assert_eq!(matcher.is_end(haystack, 6), false);  // at > haystack.len() (should not panic)"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5];",
                "    let matcher = LookMatcher::new();",
                "    let at = 5;",
                "    matcher.is_end(haystack, at);",
                "    assert_eq!(matcher.is_end(haystack, 5), true);  // at == haystack.len()",
                "    assert_eq!(matcher.is_end(haystack, 0), false);  // at < haystack.len()",
                "    assert_eq!(matcher.is_end(haystack, 3), false);  // at < haystack.len()",
                "    assert_eq!(matcher.is_end(haystack, 6), false);  // at > haystack.len() (should not panic)",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6];",
                "    let matcher = LookMatcher::new();",
                "    let at = 6;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert!(matcher.is_end(haystack, at));",
                "    let at_out_of_bounds = 7;",
                "    assert!(!matcher.is_end(haystack, at_out_of_bounds));",
                "    let at_zero = 0;",
                "    assert!(!matcher.is_end(haystack, at_zero));"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6];",
                "    let matcher = LookMatcher::new();",
                "    let at = 6;",
                "    matcher.is_end(haystack, at);",
                "    assert!(matcher.is_end(haystack, at));",
                "    let at_out_of_bounds = 7;",
                "    assert!(!matcher.is_end(haystack, at_out_of_bounds));",
                "    let at_zero = 0;",
                "    assert!(!matcher.is_end(haystack, at_zero));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7];",
                "    let matcher = LookMatcher::new();",
                "    let at = 7;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(matcher.is_end(haystack, 7), true);",
                "    assert_eq!(matcher.is_end(haystack, 6), false);",
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 8), false);"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7];",
                "    let matcher = LookMatcher::new();",
                "    let at = 7;",
                "    matcher.is_end(haystack, at);",
                "    assert_eq!(matcher.is_end(haystack, 7), true);",
                "    assert_eq!(matcher.is_end(haystack, 6), false);",
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 8), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8];",
                "    let matcher = LookMatcher::new();",
                "    let at = 8;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert!(matcher.is_end(haystack, 0) == false);",
                "    assert!(matcher.is_end(haystack, 5) == false);",
                "    assert!(matcher.is_end(haystack, 8) == true);",
                "    assert!(matcher.is_end(haystack, 9) == false);"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8];",
                "    let matcher = LookMatcher::new();",
                "    let at = 8;",
                "    matcher.is_end(haystack, at);",
                "    assert!(matcher.is_end(haystack, 0) == false);",
                "    assert!(matcher.is_end(haystack, 5) == false);",
                "    assert!(matcher.is_end(haystack, 8) == true);",
                "    assert!(matcher.is_end(haystack, 9) == false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9];",
                "    let matcher = LookMatcher::new();",
                "    let at = 9;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 5), false);",
                "    assert_eq!(matcher.is_end(haystack, 9), true);",
                "    assert_eq!(matcher.is_end(haystack, 10), false);",
                "    assert_panics!(matcher.is_end(haystack, 10));"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9];",
                "    let matcher = LookMatcher::new();",
                "    let at = 9;",
                "    matcher.is_end(haystack, at);",
                "    assert_eq!(matcher.is_end(haystack, 0), false);",
                "    assert_eq!(matcher.is_end(haystack, 5), false);",
                "    assert_eq!(matcher.is_end(haystack, 9), true);",
                "    assert_eq!(matcher.is_end(haystack, 10), false);",
                "    assert_panics!(matcher.is_end(haystack, 10));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                "    let matcher = LookMatcher::new();",
                "    let at = 10;",
                "    matcher.is_end(haystack, at);",
                "}"
              ],
              "oracle": [
                "    assert!(matcher.is_end(haystack, 10));",
                "    assert!(!matcher.is_end(haystack, 9));",
                "    assert!(!matcher.is_end(haystack, 11));",
                "    assert!(matcher.is_end(&[], 0));",
                "    assert!(!matcher.is_end(&[], 1));"
              ],
              "code": [
                "{",
                "    let haystack: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
                "    let matcher = LookMatcher::new();",
                "    let at = 10;",
                "    matcher.is_end(haystack, at);",
                "    assert!(matcher.is_end(haystack, 10));",
                "    assert!(!matcher.is_end(haystack, 9));",
                "    assert!(!matcher.is_end(haystack, 11));",
                "    assert!(matcher.is_end(&[], 0));",
                "    assert!(!matcher.is_end(&[], 1));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}