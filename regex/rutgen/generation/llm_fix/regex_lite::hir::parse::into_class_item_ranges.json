{
  "name": "regex_lite::hir::parse::into_class_item_ranges",
  "mod_info": {
    "name": "hir::parse",
    "loc": "regex-lite/src/hir/mod.rs:5:1:5:11"
  },
  "visible": false,
  "loc": "regex-lite/src/hir/parse.rs:1331:1:1339:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: core::mem::replace(&mut hir.kind, HirKind::Empty) matches HirKind::Char(ch) at line 1335 is false\n",
        "precondition: core::mem::replace(&mut hir.kind, HirKind::Empty) matches HirKind::Class(hir::Class { ranges }) at line 1336 is false\n",
        "precondition: core::mem::replace(&mut hir.kind, HirKind::Empty) matches _ at line 1337 is true\n",
        "expected return value/type: Err(Error::new(ERR_CLASS_INVALID_ITEM))\n"
      ],
      "input_infer": "Hir with kind set to HirKind::Empty or any variant that is not HirKind::Char or HirKind::Class.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Empty,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    let hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Empty,",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    let hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition { /* appropriate fields */ }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    let hir = Hir {",
                "    kind: HirKind::Repetition(Repetition { /* appropriate fields */ }),",
                "    is_start_anchored: false,",
                "    is_match_empty: false,",
                "    static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    assert_eq!(_result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Repetition(Repetition { /* appropriate fields */ }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    let hir = Hir {",
                "    kind: HirKind::Repetition(Repetition { /* appropriate fields */ }),",
                "    is_start_anchored: false,",
                "    is_match_empty: false,",
                "    static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    assert_eq!(_result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Look(Look { /* appropriate fields */ }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    assert!(_result.is_err());",
                "    assert_eq!(_result.unwrap_err(), Error::new(ERR_CLASS_INVALID_ITEM));"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Look(Look { /* appropriate fields */ }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    assert!(_result.is_err());",
                "    assert_eq!(_result.unwrap_err(), Error::new(ERR_CLASS_INVALID_ITEM));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Capture(Capture { /* appropriate fields */ }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    let hir = Hir { kind: HirKind::Capture(Capture { /* appropriate fields */ }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Capture(Capture { /* appropriate fields */ }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    let hir = Hir { kind: HirKind::Capture(Capture { /* appropriate fields */ }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Concat(vec![]),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    _result.unwrap_err().msg == ERR_CLASS_INVALID_ITEM"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Concat(vec![]),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    _result.unwrap_err().msg == ERR_CLASS_INVALID_ITEM",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Alternation(vec![]),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    let hir = Hir { kind: HirKind::Alternation(vec![]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Alternation(vec![]),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    let hir = Hir { kind: HirKind::Alternation(vec![]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: core::mem::replace(&mut hir.kind, HirKind::Empty) matches HirKind::Class(hir::Class { ranges }) at line 1334 is true\n",
        "precondition: core::mem::replace(&mut hir.kind, HirKind::Empty) matches HirKind::Class(hir::Class { ranges }) at line 1334 is true\n",
        "expected return value/type: Ok(ranges)\n"
      ],
      "input_infer": "Hir with kind set to Class containing a valid non-empty vector of ClassRange structs with start and end characters where start <= end, ensuring at least one valid character range.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_range = hir::ClassRange { start: 'a', end: 'b' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    let class_range = hir::ClassRange { start: 'a', end: 'b' };",
                "    let hir = Hir { kind: HirKind::Class(hir::Class { ranges: vec![class_range] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Ok(vec![class_range]));"
              ],
              "code": [
                "{",
                "    let class_range = hir::ClassRange { start: 'a', end: 'b' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "    let class_range = hir::ClassRange { start: 'a', end: 'b' };",
                "    let hir = Hir { kind: HirKind::Class(hir::Class { ranges: vec![class_range] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Ok(vec![class_range]));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'c' };",
                "    let class_range2 = hir::ClassRange { start: 'e', end: 'g' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'c' };",
                "    let class_range2 = hir::ClassRange { start: 'e', end: 'g' };",
                "    let hir = Hir { kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Ok(vec![class_range1, class_range2]));"
              ],
              "code": [
                "{",
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'c' };",
                "    let class_range2 = hir::ClassRange { start: 'e', end: 'g' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'c' };",
                "    let class_range2 = hir::ClassRange { start: 'e', end: 'g' };",
                "    let hir = Hir { kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert_eq!(result, Ok(vec![class_range1, class_range2]));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'd' };",
                "    let class_range2 = hir::ClassRange { start: 'c', end: 'f' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'd' };",
                "    let class_range2 = hir::ClassRange { start: 'c', end: 'f' };",
                "    let hir = Hir { kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), vec![class_range1, class_range2]);"
              ],
              "code": [
                "{",
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'd' };",
                "    let class_range2 = hir::ClassRange { start: 'c', end: 'f' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "    let class_range1 = hir::ClassRange { start: 'a', end: 'd' };",
                "    let class_range2 = hir::ClassRange { start: 'c', end: 'f' };",
                "    let hir = Hir { kind: HirKind::Class(hir::Class { ranges: vec![class_range1, class_range2] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
                "    let result = into_class_item_ranges(hir);",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), vec![class_range1, class_range2]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_range = hir::ClassRange { start: 'x', end: 'x' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    assert!(into_class_item_ranges(hir).is_ok());",
                "    let result = into_class_item_ranges(hir).unwrap();",
                "    assert_eq!(result.len(), 1);",
                "    assert_eq!(result[0].start, 'x');",
                "    assert_eq!(result[0].end, 'x');"
              ],
              "code": [
                "{",
                "    let class_range = hir::ClassRange { start: 'x', end: 'x' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "    assert!(into_class_item_ranges(hir).is_ok());",
                "    let result = into_class_item_ranges(hir).unwrap();",
                "    assert_eq!(result.len(), 1);",
                "    assert_eq!(result[0].start, 'x');",
                "    assert_eq!(result[0].end, 'x');",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_range = hir::ClassRange { start: '1', end: '2' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Class(hir::Class { ranges: vec![hir::ClassRange { start: '1', end: '2' }] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Ok(vec![hir::ClassRange { start: '1', end: '2' }]));",
                "    assert!(into_class_item_ranges(Hir { kind: HirKind::Class(hir::Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }).is_ok());",
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Concat(vec![]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Err(Error::new(ERR_CLASS_INVALID_ITEM)));"
              ],
              "code": [
                "{",
                "    let class_range = hir::ClassRange { start: '1', end: '2' };",
                "    let hir = Hir {",
                "        kind: HirKind::Class(hir::Class { ranges: vec![class_range] }),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _ = into_class_item_ranges(hir);",
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Class(hir::Class { ranges: vec![hir::ClassRange { start: '1', end: '2' }] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Ok(vec![hir::ClassRange { start: '1', end: '2' }]));",
                "    assert!(into_class_item_ranges(Hir { kind: HirKind::Class(hir::Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }).is_ok());",
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "    assert_eq!(into_class_item_ranges(Hir { kind: HirKind::Concat(vec![]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }), Err(Error::new(ERR_CLASS_INVALID_ITEM)));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "precondition: core::mem::replace(&mut hir.kind, HirKind::Empty) matches HirKind::Char(ch) at line 1334 is true\n",
        "precondition: core::mem::replace(&mut hir.kind, HirKind::Empty) matches HirKind::Char(ch) at line 1334 is true\n",
        "expected return value/type: Ok(vec![hir::ClassRange { start: ch, end: ch }])\n"
      ],
      "input_infer": "Hir with kind set to HirKind::Char containing any single valid character (e.g., 'a', '1', '#')\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Char('a'),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(vec![hir::ClassRange { start: 'a', end: 'a' }]));"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Char('a'),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    assert_eq!(_result, Ok(vec![hir::ClassRange { start: 'a', end: 'a' }]));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Char('1'),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(vec![hir::ClassRange { start: '1', end: '1' }]))"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Char('1'),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    assert_eq!(_result, Ok(vec![hir::ClassRange { start: '1', end: '1' }]))",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Char('#'),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(vec![hir::ClassRange { start: '#', end: '#' }]));"
              ],
              "code": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::Char('#'),",
                "        is_start_anchored: false,",
                "        is_match_empty: false,",
                "        static_explicit_captures_len: None,",
                "    };",
                "    let _result = into_class_item_ranges(hir);",
                "    assert_eq!(_result, Ok(vec![hir::ClassRange { start: '#', end: '#' }]));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}