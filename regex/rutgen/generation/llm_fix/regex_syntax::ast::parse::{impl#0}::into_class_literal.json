{
  "name": "regex_syntax::ast::parse::{impl#0}::into_class_literal",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:11:1:11:15"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/parse.rs:89:5:99:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self matches Literal(lit) at line 96 is false\n",
        "expected return value/type: Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral))\n"
      ],
      "input_infer": "self must be of type Primitive that is not Literal, and p must be a valid ParserI instance with an appropriate pattern containing a valid Span.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 0, end: 1 };",
                "    ",
                "    let primitive = Primitive::Assertion(Assertion { span, kind: AssertionKind::WordBoundary });",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Err(parser_instance.error(span, ast::ErrorKind::ClassRangeLiteral)));"
              ],
              "code": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 0, end: 1 };",
                "    ",
                "    let primitive = Primitive::Assertion(Assertion { span, kind: AssertionKind::WordBoundary });",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "    assert_eq!(result, Err(parser_instance.error(span, ast::ErrorKind::ClassRangeLiteral)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 1, end: 2 };",
                "",
                "    let primitive = Primitive::Dot(span);",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "}"
              ],
              "oracle": [
                "    assert!(matches!(result, Err(err) if err.kind == ast::ErrorKind::ClassRangeLiteral));"
              ],
              "code": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 1, end: 2 };",
                "",
                "    let primitive = Primitive::Dot(span);",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "    assert!(matches!(result, Err(err) if err.kind == ast::ErrorKind::ClassRangeLiteral));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 2, end: 3 };",
                "",
                "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "}"
              ],
              "oracle": [
                "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
                "    let expected_error_kind = ast::ErrorKind::ClassRangeLiteral;",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "    assert!(result.is_err());",
                "    if let Err(ref error) = result {",
                "    assert_eq!(error.kind, expected_error_kind);",
                "    assert_eq!(error.span, span);",
                "    }"
              ],
              "code": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 2, end: 3 };",
                "",
                "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "    let primitive = Primitive::Perl(ClassPerl { span, kind: ClassPerlKind::Word, negated: false });",
                "    let expected_error_kind = ast::ErrorKind::ClassRangeLiteral;",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "    assert!(result.is_err());",
                "    if let Err(ref error) = result {",
                "    assert_eq!(error.kind, expected_error_kind);",
                "    assert_eq!(error.span, span);",
                "    }",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 3, end: 4 };",
                "",
                "    let primitive = Primitive::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Letter });",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "}"
              ],
              "oracle": [
                "    let expected_error = Error { kind: ErrorKind::ClassRangeLiteral, pattern: \"test pattern\".to_string(), span };",
                "    assert_eq!(result, Err(expected_error));"
              ],
              "code": [
                "{",
                "    struct TestParser;",
                "",
                "    let parser_instance = ParserI::new(TestParser, \"test pattern\");",
                "    let span = Span { start: 3, end: 4 };",
                "",
                "    let primitive = Primitive::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Letter });",
                "",
                "    let result = primitive.into_class_literal(&parser_instance);",
                "    let expected_error = Error { kind: ErrorKind::ClassRangeLiteral, pattern: \"test pattern\".to_string(), span };",
                "    assert_eq!(result, Err(expected_error));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self matches Literal(lit) at line 95 is true\n",
        "precondition: self matches Literal(lit) at line 95 is true\n",
        "expected return value/type: Ok(lit)\n"
      ],
      "input_infer": "self should be a Primitive::Literal variant containing a valid ast::Literal instance represented by a non-empty Box<[u8]> and its corresponding Span should have a start and end Position that are valid byte offsets.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let literal_bytes: Box<[u8]> = Box::from([97, 98, 99]); // Corresponds to \"abc\"",
                "    let lit = ast::Literal { bytes: literal_bytes, exact: true };",
                "    ",
                "    let primitive = Primitive::Literal(lit);",
                "    ",
                "    let parser = ParserI::new(Default::default(), \"abc\");",
                "    ",
                "    let _result = primitive.into_class_literal(&parser);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(lit));"
              ],
              "code": [
                "{",
                "    let span = Span { start: Position(0), end: Position(5) };",
                "    let literal_bytes: Box<[u8]> = Box::from([97, 98, 99]); // Corresponds to \"abc\"",
                "    let lit = ast::Literal { bytes: literal_bytes, exact: true };",
                "    ",
                "    let primitive = Primitive::Literal(lit);",
                "    ",
                "    let parser = ParserI::new(Default::default(), \"abc\");",
                "    ",
                "    let _result = primitive.into_class_literal(&parser);",
                "    assert_eq!(_result, Ok(lit));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(4) };",
                "    let literal_bytes: Box<[u8]> = Box::from([120, 121, 122]); // Corresponds to \"xyz\"",
                "    let lit = ast::Literal { bytes: literal_bytes, exact: false };",
                "    ",
                "    let primitive = Primitive::Literal(lit);",
                "    ",
                "    let parser = ParserI::new(Default::default(), \"xyz\");",
                "    ",
                "    let _result = primitive.into_class_literal(&parser);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(lit));"
              ],
              "code": [
                "{",
                "    let span = Span { start: Position(0), end: Position(4) };",
                "    let literal_bytes: Box<[u8]> = Box::from([120, 121, 122]); // Corresponds to \"xyz\"",
                "    let lit = ast::Literal { bytes: literal_bytes, exact: false };",
                "    ",
                "    let primitive = Primitive::Literal(lit);",
                "    ",
                "    let parser = ParserI::new(Default::default(), \"xyz\");",
                "    ",
                "    let _result = primitive.into_class_literal(&parser);",
                "    assert_eq!(_result, Ok(lit));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let literal_bytes: Box<[u8]> = Box::from([]); // Empty literal",
                "    let lit = ast::Literal { bytes: literal_bytes, exact: true };",
                "    ",
                "    let primitive = Primitive::Literal(lit);",
                "    ",
                "    let parser = ParserI::new(Default::default(), \"\");",
                "    ",
                "    let _result = primitive.into_class_literal(&parser);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_result, Ok(lit));"
              ],
              "code": [
                "{",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let literal_bytes: Box<[u8]> = Box::from([]); // Empty literal",
                "    let lit = ast::Literal { bytes: literal_bytes, exact: true };",
                "    ",
                "    let primitive = Primitive::Literal(lit);",
                "    ",
                "    let parser = ParserI::new(Default::default(), \"\");",
                "    ",
                "    let _result = primitive.into_class_literal(&parser);",
                "    assert_eq!(_result, Ok(lit));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}