{
  "name": "regex_automata::util::wire::write_endianness_check",
  "mod_info": {
    "name": "util::wire",
    "loc": "regex-automata/src/util/mod.rs:46:1:46:14"
  },
  "visible": true,
  "loc": "regex-automata/src/util/wire.rs:515:1:524:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: dst.len() < nwrite at line 519 is true\n",
        "expected return value/type: Err(SerializeError::buffer_too_small(\"endianness check\"))\n"
      ],
      "input_infer": "dst length is less than 4 (i.e., valid ranges are 0, 1, 2, 3)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dst = [0u8; 0];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    let mut dst = [0u8; 0];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"endianness check\")));"
              ],
              "code": [
                "{",
                "    let mut dst = [0u8; 0];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "    let mut dst = [0u8; 0];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"endianness check\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dst = [0u8; 1];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    let expected = Err(SerializeError::buffer_too_small(\"endianness check\"));",
                "    assert_eq!(result, expected);",
                "    assert!(match result { Err(SerializeError { what, .. }) if what == \"endianness check\" => true, _ => false });",
                "    assert!(result.is_err());",
                "    assert!(result.as_ref().err().unwrap().what == \"endianness check\");"
              ],
              "code": [
                "{",
                "    let mut dst = [0u8; 1];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "    let expected = Err(SerializeError::buffer_too_small(\"endianness check\"));",
                "    assert_eq!(result, expected);",
                "    assert!(match result { Err(SerializeError { what, .. }) if what == \"endianness check\" => true, _ => false });",
                "    assert!(result.is_err());",
                "    assert!(result.as_ref().err().unwrap().what == \"endianness check\");",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dst = [0u8; 2];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"endianness check\")));"
              ],
              "code": [
                "{",
                "    let mut dst = [0u8; 2];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "    assert!(result.is_err());",
                "    assert_eq!(result, Err(SerializeError::buffer_too_small(\"endianness check\")));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut dst = [0u8; 3];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), SerializeError::buffer_too_small(\"endianness check\"));"
              ],
              "code": [
                "{",
                "    let mut dst = [0u8; 3];",
                "    let result: Result<usize, SerializeError> = write_endianness_check::<NE>(&mut dst);",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), SerializeError::buffer_too_small(\"endianness check\"));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: dst.len() < nwrite at line 519 is false, with bound dst.len() == nwrite\n",
        "expected return value/type: Ok(nwrite)\n"
      ],
      "input_infer": "dst.len() == 4 (exactly equal to the size of u32)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct LittleEndian;",
                "    impl Endian for LittleEndian {",
                "        fn write_u32(val: u32, dst: &mut [u8]) {",
                "            dst.copy_from_slice(&val.to_le_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buffer = [0u8; 4];",
                "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    // The assertion is omitted as per guidelines, but this will check",
                "    // that buffer contains the bytes representing 0xFEFF in little-endian.",
                "}"
              ],
              "oracle": [
                "    let buffer = [0u8; 4];",
                "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    assert_eq!(result, expected);",
                "    assert_eq!(buffer, [0xFF, 0xFE, 0x00, 0x00]);"
              ],
              "code": [
                "{",
                "    struct LittleEndian;",
                "    impl Endian for LittleEndian {",
                "        fn write_u32(val: u32, dst: &mut [u8]) {",
                "            dst.copy_from_slice(&val.to_le_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buffer = [0u8; 4];",
                "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    // The assertion is omitted as per guidelines, but this will check",
                "    // that buffer contains the bytes representing 0xFEFF in little-endian.",
                "    let buffer = [0u8; 4];",
                "    let result = write_endianness_check::<LittleEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    assert_eq!(result, expected);",
                "    assert_eq!(buffer, [0xFF, 0xFE, 0x00, 0x00]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct BigEndian;",
                "    impl Endian for BigEndian {",
                "        fn write_u32(val: u32, dst: &mut [u8]) {",
                "            dst.copy_from_slice(&val.to_be_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buffer = [0u8; 4];",
                "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    // The assertion is omitted as per guidelines, but this will check",
                "    // that buffer contains the bytes representing 0xFEFF in big-endian.",
                "}"
              ],
              "oracle": [
                "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    assert_eq!(result, expected);",
                "    assert_eq!(buffer, [0xFE, 0xFF, 0x00, 0x00]);"
              ],
              "code": [
                "{",
                "    struct BigEndian;",
                "    impl Endian for BigEndian {",
                "        fn write_u32(val: u32, dst: &mut [u8]) {",
                "            dst.copy_from_slice(&val.to_be_bytes());",
                "        }",
                "    }",
                "",
                "    let mut buffer = [0u8; 4];",
                "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    // The assertion is omitted as per guidelines, but this will check",
                "    // that buffer contains the bytes representing 0xFEFF in big-endian.",
                "    let result = write_endianness_check::<BigEndian>(&mut buffer);",
                "    let expected = Ok(4);",
                "    assert_eq!(result, expected);",
                "    assert_eq!(buffer, [0xFE, 0xFF, 0x00, 0x00]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}