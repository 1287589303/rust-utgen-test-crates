{
  "name": "regex_automata::dfa::onepass::{impl#12}::pattern_id_unchecked",
  "mod_info": {
    "name": "dfa::onepass",
    "loc": "regex-automata/src/dfa/mod.rs:339:1:339:17"
  },
  "visible": false,
  "loc": "regex-automata/src/dfa/onepass.rs:2721:5:2724:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "self.0 must be within the range [0, 0xFFFFFC00_00000000] for valid pattern IDs; boundary cases include 0, 0xFFFFFC00_00000000, and values where no pattern ID exists (less than 0x00000000_003FFFFF).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let epsilons = PatternEpsilons(0);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(epsilons.pattern_id_unchecked().as_usize(), 0);",
                "    let epsilons_non_empty = PatternEpsilons(0x00400000_00000000);",
                "    assert!(epsilons_non_empty.pattern_id_unchecked().as_usize() > 0);",
                "    let epsilons_out_of_bounds = PatternEpsilons(0x00000000_00400000);",
                "    let result = epsilons_out_of_bounds.pattern_id_unchecked();",
                "    assert!(result.as_usize() > PatternEpsilons::PATTERN_ID_LIMIT as usize);",
                "    let valid_pid = PatternID::new_unchecked(0x003FFFFF);",
                "    let epsilons_with_pid = epsilons.set_pattern_id(valid_pid);",
                "    assert_eq!(epsilons_with_pid.pattern_id_unchecked().as_usize(), 0x003FFFFF);"
              ],
              "code": [
                "{",
                "    let epsilons = PatternEpsilons(0);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "    assert_eq!(epsilons.pattern_id_unchecked().as_usize(), 0);",
                "    let epsilons_non_empty = PatternEpsilons(0x00400000_00000000);",
                "    assert!(epsilons_non_empty.pattern_id_unchecked().as_usize() > 0);",
                "    let epsilons_out_of_bounds = PatternEpsilons(0x00000000_00400000);",
                "    let result = epsilons_out_of_bounds.pattern_id_unchecked();",
                "    assert!(result.as_usize() > PatternEpsilons::PATTERN_ID_LIMIT as usize);",
                "    let valid_pid = PatternID::new_unchecked(0x003FFFFF);",
                "    let epsilons_with_pid = epsilons.set_pattern_id(valid_pid);",
                "    assert_eq!(epsilons_with_pid.pattern_id_unchecked().as_usize(), 0x003FFFFF);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let epsilons = PatternEpsilons(0xFFFFFC00_00000000);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(epsilons.pattern_id_unchecked(), PatternID::new_unchecked((0xFFFFFC00_00000000 >> PatternEpsilons::PATTERN_ID_SHIFT) as usize));",
                "    let epsilons_empty = PatternEpsilons(0);",
                "    assert!(epsilons_empty.pattern_id().is_none());",
                "    let epsilons_with_id = PatternEpsilons(0x000003FF_FFFFFFFF);",
                "    let expected_pattern_id = PatternID::new_unchecked((0x000003FF_FFFFFFFF >> PatternEpsilons::PATTERN_ID_SHIFT) as usize);",
                "    assert_eq!(epsilons_with_id.pattern_id_unchecked(), expected_pattern_id);",
                "    let epsilons_none = PatternEpsilons(PatternEpsilons::PATTERN_ID_NONE);",
                "    let pattern_id_for_none = epsilons_none.pattern_id_unchecked();",
                "    assert_eq!(pattern_id_for_none.as_usize(), (PatternEpsilons::PATTERN_ID_NONE >> PatternEpsilons::PATTERN_ID_SHIFT) as usize);"
              ],
              "code": [
                "{",
                "    let epsilons = PatternEpsilons(0xFFFFFC00_00000000);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "    assert_eq!(epsilons.pattern_id_unchecked(), PatternID::new_unchecked((0xFFFFFC00_00000000 >> PatternEpsilons::PATTERN_ID_SHIFT) as usize));",
                "    let epsilons_empty = PatternEpsilons(0);",
                "    assert!(epsilons_empty.pattern_id().is_none());",
                "    let epsilons_with_id = PatternEpsilons(0x000003FF_FFFFFFFF);",
                "    let expected_pattern_id = PatternID::new_unchecked((0x000003FF_FFFFFFFF >> PatternEpsilons::PATTERN_ID_SHIFT) as usize);",
                "    assert_eq!(epsilons_with_id.pattern_id_unchecked(), expected_pattern_id);",
                "    let epsilons_none = PatternEpsilons(PatternEpsilons::PATTERN_ID_NONE);",
                "    let pattern_id_for_none = epsilons_none.pattern_id_unchecked();",
                "    assert_eq!(pattern_id_for_none.as_usize(), (PatternEpsilons::PATTERN_ID_NONE >> PatternEpsilons::PATTERN_ID_SHIFT) as usize);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let epsilons = PatternEpsilons(0x00000000_00000000);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(epsilons.pattern_id_unchecked(), PatternID::new_unchecked(0));"
              ],
              "code": [
                "{",
                "    let epsilons = PatternEpsilons(0x00000000_00000000);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "    assert_eq!(epsilons.pattern_id_unchecked(), PatternID::new_unchecked(0));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let epsilons = PatternEpsilons(0x00000000_003FFFFF - 1);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(epsilons.pattern_id_unchecked().0, 0x00000000_003FFFFF >> PatternEpsilons::PATTERN_ID_SHIFT);",
                "    assert!(epsilons.pattern_id_unchecked().is_some());",
                "    assert_eq!(epsilons.pattern_id_unchecked().as_usize(), (0x00000000_003FFFFF - 1) >> PatternEpsilons::PATTERN_ID_SHIFT);"
              ],
              "code": [
                "{",
                "    let epsilons = PatternEpsilons(0x00000000_003FFFFF - 1);",
                "    let _result = epsilons.pattern_id_unchecked();",
                "    assert_eq!(epsilons.pattern_id_unchecked().0, 0x00000000_003FFFFF >> PatternEpsilons::PATTERN_ID_SHIFT);",
                "    assert!(epsilons.pattern_id_unchecked().is_some());",
                "    assert_eq!(epsilons.pattern_id_unchecked().as_usize(), (0x00000000_003FFFFF - 1) >> PatternEpsilons::PATTERN_ID_SHIFT);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}