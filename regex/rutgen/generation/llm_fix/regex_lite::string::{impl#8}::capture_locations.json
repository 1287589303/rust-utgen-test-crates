{
  "name": "regex_lite::string::{impl#8}::capture_locations",
  "mod_info": {
    "name": "string",
    "loc": "regex-lite/src/lib.rs:884:1:884:12"
  },
  "visible": true,
  "loc": "regex-lite/src/string.rs:1436:5:1440:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: CaptureLocations(vec![None; len])\n"
      ],
      "input_infer": "valid regex patterns with 0 to N capture groups where N is a reasonable upper limit (e.g., 10), ensuring group_len is non-negative and len is a multiple of 2\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(\"\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "}"
              ],
              "oracle": [
                "    let nfa = NFA::new(Config::default(), String::from(\"\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "    assert_eq!(locs.0, vec![None; locs.0.len()]);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(\"\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "    let nfa = NFA::new(Config::default(), String::from(\"\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "    assert_eq!(locs.0, vec![None; locs.0.len()]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"()\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(locs.0, vec![None, None]);",
                "    assert_eq!(locs.0.len(), 2);",
                "    assert_eq!(regex.pikevm.nfa().group_len(), 1);",
                "    assert_eq!(locs.0.capacity(), 2);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"()\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "    assert_eq!(locs.0, vec![None, None]);",
                "    assert_eq!(locs.0.len(), 2);",
                "    assert_eq!(regex.pikevm.nfa().group_len(), 1);",
                "    assert_eq!(locs.0.capacity(), 2);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"(.)(.)\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(locs.0.len(), 4);",
                "    assert_eq!(locs.0, vec![None, None, None, None]);",
                "    assert!(locs.0.iter().all(|&loc| loc.is_none()));",
                "    assert!(locs.0.capacity() >= 4);",
                "    assert!(locs.0.is_empty() == false);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"(.)(.)\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "    assert_eq!(locs.0.len(), 4);",
                "    assert_eq!(locs.0, vec![None, None, None, None]);",
                "    assert!(locs.0.iter().all(|&loc| loc.is_none()));",
                "    assert!(locs.0.capacity() >= 4);",
                "    assert!(locs.0.is_empty() == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"(.)(.)(\\w+)\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(locs.0, vec![None, None, None, None, None, None]);",
                "    assert_eq!(locs.0.len(), 6);",
                "    assert!(locs.0.iter().all(|&x| x.is_none()));",
                "    assert!(regex.capture_locations().0.is_empty() == false);"
              ],
              "code": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"(.)(.)(\\w+)\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "    assert_eq!(locs.0, vec![None, None, None, None, None, None]);",
                "    assert_eq!(locs.0.len(), 6);",
                "    assert!(locs.0.iter().all(|&x| x.is_none()));",
                "    assert!(regex.capture_locations().0.is_empty() == false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(locs.0.len(), 20);",
                "    assert_eq!(locs.0.iter().all(|&location| location.is_none()), true);",
                "    assert!(regex.captures_len() > 0);",
                "    assert!(regex.static_captures_len().is_none());"
              ],
              "code": [
                "{",
                "    let nfa = NFA::new(Config::default(), String::from(r\"(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\"), &Hir::new()).unwrap();",
                "    let pikevm = PikeVM::new(nfa);",
                "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
                "    let locs = regex.capture_locations();",
                "    assert_eq!(locs.0.len(), 20);",
                "    assert_eq!(locs.0.iter().all(|&location| location.is_none()), true);",
                "    assert!(regex.captures_len() > 0);",
                "    assert!(regex.static_captures_len().is_none());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}