{
  "name": "regex_automata::hybrid::dfa::{impl#3}::memory_usage",
  "mod_info": {
    "name": "hybrid::dfa",
    "loc": "regex-automata/src/hybrid/mod.rs:140:1:140:13"
  },
  "visible": true,
  "loc": "regex-automata/src/hybrid/dfa.rs:2021:5:2038:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: self.trans.len() * ID_SIZE\n        + self.starts.len() * ID_SIZE\n        + self.states.len() * STATE_SIZE\n        // Maps likely use more memory than this, but it's probably close.\n        + self.states_to_id.len() * (STATE_SIZE + ID_SIZE)\n        + self.sparses.memory_usage()\n        + self.stack.capacity() * ID_SIZE\n        + self.scratch_state_builder.capacity()\n        // Heap memory used by 'State' in both 'states' and 'states_to_id'.\n        + self.memory_usage_state\n"
      ],
      "input_infer": "trans.len() in the range 0 to MAX, starts.len() in the range 0 to 4 (default), states.len() in the range 0 to MAX, states_to_id.len() in the range 0 to MAX, sparses.memory_usage() in the range 0 to MAX, stack.capacity() in the range 0 to MAX, scratch_state_builder.capacity() in the range 0 to MAX, memory_usage_state in the range 0 to MAX\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = vec![LazyStateID(1), LazyStateID(2)];",
                "    let starts = vec![LazyStateID(1)];",
                "    let states = vec![State { transitions: vec![] }];",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(0);",
                "    let stack = vec![NFAStateID(1)].into_iter().collect::<Vec<_>>();",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 0;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 0,",
                "        bytes_searched: 0,",
                "        memory_usage_state: 0,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cache.trans.len(), 2);",
                "    assert_eq!(cache.starts.len(), 1);",
                "    assert_eq!(cache.states.len(), 1);",
                "    assert_eq!(cache.states_to_id.len(), 0);",
                "    assert_eq!(cache.sparses.memory_usage(), 0);",
                "    assert_eq!(cache.stack.capacity(), 1);",
                "    assert_eq!(cache.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(cache.memory_usage(),",
                "    (cache.trans.len() * size_of::<LazyStateID>()) +",
                "    (cache.starts.len() * size_of::<LazyStateID>()) +",
                "    (cache.states.len() * size_of::<State>()) +",
                "    (cache.states_to_id.len() * (size_of::<State>() + size_of::<LazyStateID>())) +",
                "    cache.sparses.memory_usage() +",
                "    (cache.stack.capacity() * size_of::<LazyStateID>()) +",
                "    cache.scratch_state_builder.capacity() +",
                "    cache.memory_usage_state);"
              ],
              "code": [
                "{",
                "    let trans = vec![LazyStateID(1), LazyStateID(2)];",
                "    let starts = vec![LazyStateID(1)];",
                "    let states = vec![State { transitions: vec![] }];",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(0);",
                "    let stack = vec![NFAStateID(1)].into_iter().collect::<Vec<_>>();",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 0;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 0,",
                "        bytes_searched: 0,",
                "        memory_usage_state: 0,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "    assert_eq!(cache.trans.len(), 2);",
                "    assert_eq!(cache.starts.len(), 1);",
                "    assert_eq!(cache.states.len(), 1);",
                "    assert_eq!(cache.states_to_id.len(), 0);",
                "    assert_eq!(cache.sparses.memory_usage(), 0);",
                "    assert_eq!(cache.stack.capacity(), 1);",
                "    assert_eq!(cache.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(cache.memory_usage(),",
                "    (cache.trans.len() * size_of::<LazyStateID>()) +",
                "    (cache.starts.len() * size_of::<LazyStateID>()) +",
                "    (cache.states.len() * size_of::<State>()) +",
                "    (cache.states_to_id.len() * (size_of::<State>() + size_of::<LazyStateID>())) +",
                "    cache.sparses.memory_usage() +",
                "    (cache.stack.capacity() * size_of::<LazyStateID>()) +",
                "    cache.scratch_state_builder.capacity() +",
                "    cache.memory_usage_state);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = vec![LazyStateID(1), LazyStateID(2), LazyStateID(3)];",
                "    let starts = vec![LazyStateID(1), LazyStateID(2)];",
                "    let states = vec![State { transitions: vec![] }, State { transitions: vec![] }];",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(0);",
                "    let stack = vec![NFAStateID(1); 5];",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 10;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 3,",
                "        bytes_searched: 100,",
                "        memory_usage_state: 10,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cache.trans.len(), 3);",
                "    assert_eq!(cache.starts.len(), 2);",
                "    assert_eq!(cache.states.len(), 2);",
                "    assert_eq!(cache.states_to_id.len(), 0);",
                "    assert_eq!(cache.sparses.memory_usage(), 0);",
                "    assert_eq!(cache.stack.capacity(), 5);",
                "    assert_eq!(cache.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(cache.memory_usage_state, 10);",
                "    assert_eq!(cache.memory_usage(), 3 * size_of::<LazyStateID>() + 2 * size_of::<LazyStateID>() + 2 * size_of::<State>() + 0 * (size_of::<State>() + size_of::<LazyStateID>()) + 0 + 5 * size_of::<LazyStateID>() + 0 + 10);"
              ],
              "code": [
                "{",
                "    let trans = vec![LazyStateID(1), LazyStateID(2), LazyStateID(3)];",
                "    let starts = vec![LazyStateID(1), LazyStateID(2)];",
                "    let states = vec![State { transitions: vec![] }, State { transitions: vec![] }];",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(0);",
                "    let stack = vec![NFAStateID(1); 5];",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 10;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 3,",
                "        bytes_searched: 100,",
                "        memory_usage_state: 10,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "    assert_eq!(cache.trans.len(), 3);",
                "    assert_eq!(cache.starts.len(), 2);",
                "    assert_eq!(cache.states.len(), 2);",
                "    assert_eq!(cache.states_to_id.len(), 0);",
                "    assert_eq!(cache.sparses.memory_usage(), 0);",
                "    assert_eq!(cache.stack.capacity(), 5);",
                "    assert_eq!(cache.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(cache.memory_usage_state, 10);",
                "    assert_eq!(cache.memory_usage(), 3 * size_of::<LazyStateID>() + 2 * size_of::<LazyStateID>() + 2 * size_of::<State>() + 0 * (size_of::<State>() + size_of::<LazyStateID>()) + 0 + 5 * size_of::<LazyStateID>() + 0 + 10);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Vec::new();",
                "    let starts = Vec::new();",
                "    let states = Vec::new();",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(0);",
                "    let stack = Vec::new();",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 0;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 0,",
                "        bytes_searched: 0,",
                "        memory_usage_state: 0,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(cache.trans.len(), 0);",
                "    assert_eq!(cache.starts.len(), 0);",
                "    assert_eq!(cache.states.len(), 0);",
                "    assert_eq!(cache.states_to_id.len(), 0);",
                "    assert_eq!(cache.sparses.memory_usage(), 0);",
                "    assert_eq!(cache.stack.capacity(), 0);",
                "    assert_eq!(cache.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(cache.memory_usage_state, 0);",
                "    assert_eq!(cache.memory_usage(), 0);"
              ],
              "code": [
                "{",
                "    let trans = Vec::new();",
                "    let starts = Vec::new();",
                "    let states = Vec::new();",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(0);",
                "    let stack = Vec::new();",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 0;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 0,",
                "        bytes_searched: 0,",
                "        memory_usage_state: 0,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "    assert_eq!(cache.trans.len(), 0);",
                "    assert_eq!(cache.starts.len(), 0);",
                "    assert_eq!(cache.states.len(), 0);",
                "    assert_eq!(cache.states_to_id.len(), 0);",
                "    assert_eq!(cache.sparses.memory_usage(), 0);",
                "    assert_eq!(cache.stack.capacity(), 0);",
                "    assert_eq!(cache.scratch_state_builder.capacity(), 0);",
                "    assert_eq!(cache.memory_usage_state, 0);",
                "    assert_eq!(cache.memory_usage(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = (0..1000).map(|_| LazyStateID(1)).collect::<Vec<_>>();",
                "    let starts = vec![LazyStateID(1), LazyStateID(2), LazyStateID(3)];",
                "    let states = (0..1000).map(|_| State { transitions: vec![] }).collect::<Vec<_>>();",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(100);",
                "    let stack = vec![NFAStateID(1); 100];",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 500;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 5,",
                "        bytes_searched: 5000,",
                "        memory_usage_state: 500,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "}"
              ],
              "oracle": [
                "    let trans_len = 1000;",
                "    let id_size = size_of::<LazyStateID>();",
                "    let starts_len = 3;",
                "    let states_len = 1000;",
                "    let state_size = size_of::<State>();",
                "    let states_to_id_len = 0;",
                "    let sparses_memory_usage = sparses.memory_usage();",
                "    let stack_capacity = 100;",
                "    let scratch_capacity = scratch_state_builder.capacity();",
                "    let memory_usage_state = 500;",
                "    ",
                "    let expected_memory_usage = (trans_len * id_size)",
                "    + (starts_len * id_size)",
                "    + (states_len * state_size)",
                "    + (states_to_id_len * (state_size + id_size))",
                "    + sparses_memory_usage",
                "    + (stack_capacity * id_size)",
                "    + scratch_capacity",
                "    + memory_usage_state;",
                "    ",
                "    assert_eq!(cache.memory_usage(), expected_memory_usage);"
              ],
              "code": [
                "{",
                "    let trans = (0..1000).map(|_| LazyStateID(1)).collect::<Vec<_>>();",
                "    let starts = vec![LazyStateID(1), LazyStateID(2), LazyStateID(3)];",
                "    let states = (0..1000).map(|_| State { transitions: vec![] }).collect::<Vec<_>>();",
                "    let states_to_id = std::collections::HashMap::new();",
                "    let sparses = SparseSets::new(100);",
                "    let stack = vec![NFAStateID(1); 100];",
                "    let scratch_state_builder = StateBuilderEmpty::new();",
                "    let memory_usage_state = 500;",
                "",
                "    let cache = Cache {",
                "        trans,",
                "        starts,",
                "        states,",
                "        states_to_id,",
                "        sparses,",
                "        stack,",
                "        scratch_state_builder,",
                "        memory_usage_state,",
                "        clear_count: 5,",
                "        bytes_searched: 5000,",
                "        memory_usage_state: 500,",
                "        progress: None,",
                "    };",
                "    ",
                "    let _ = cache.memory_usage();",
                "    let trans_len = 1000;",
                "    let id_size = size_of::<LazyStateID>();",
                "    let starts_len = 3;",
                "    let states_len = 1000;",
                "    let state_size = size_of::<State>();",
                "    let states_to_id_len = 0;",
                "    let sparses_memory_usage = sparses.memory_usage();",
                "    let stack_capacity = 100;",
                "    let scratch_capacity = scratch_state_builder.capacity();",
                "    let memory_usage_state = 500;",
                "    ",
                "    let expected_memory_usage = (trans_len * id_size)",
                "    + (starts_len * id_size)",
                "    + (states_len * state_size)",
                "    + (states_to_id_len * (state_size + id_size))",
                "    + sparses_memory_usage",
                "    + (stack_capacity * id_size)",
                "    + scratch_capacity",
                "    + memory_usage_state;",
                "    ",
                "    assert_eq!(cache.memory_usage(), expected_memory_usage);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}