{
  "name": "regex_lite::hir::{impl#3}::new",
  "mod_info": {
    "name": "hir",
    "loc": "regex-lite/src/lib.rs:877:1:877:9"
  },
  "visible": false,
  "loc": "regex-lite/src/hir/mod.rs:396:5:400:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: class\n"
      ],
      "input_infer": "Valid input: an empty iterator, a single ClassRange with start and end as the same character, multiple adjacent ClassRange instances, overlapping ClassRange instances, ranges provided in random order, maximum number of ClassRange instances with start character below or equal to end character within the valid Unicode range.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges: Vec<ClassRange> = Vec::new();",
                "    let class = Class::new(ranges);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class.ranges.len(), 0);",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![ClassRange { start: 'a', end: 'b' }];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'b' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'c', end: 'e' },",
                "    ClassRange { start: 'a', end: 'b' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 2);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'b' });",
                "    assert_eq!(class.ranges[1], ClassRange { start: 'c', end: 'e' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'a', end: 'c' },",
                "    ClassRange { start: 'b', end: 'd' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'd' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'e', end: 'g' },",
                "    ClassRange { start: 'a', end: 'c' },",
                "    ClassRange { start: 'b', end: 'd' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'g' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'x', end: 'z' },",
                "    ClassRange { start: 'a', end: 'z' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'z' });"
              ],
              "code": [
                "{",
                "    let ranges: Vec<ClassRange> = Vec::new();",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 0);",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![ClassRange { start: 'a', end: 'b' }];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'b' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'c', end: 'e' },",
                "    ClassRange { start: 'a', end: 'b' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 2);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'b' });",
                "    assert_eq!(class.ranges[1], ClassRange { start: 'c', end: 'e' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'a', end: 'c' },",
                "    ClassRange { start: 'b', end: 'd' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'd' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'e', end: 'g' },",
                "    ClassRange { start: 'a', end: 'c' },",
                "    ClassRange { start: 'b', end: 'd' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'g' });",
                "    ",
                "    let ranges: Vec<ClassRange> = vec![",
                "    ClassRange { start: 'x', end: 'z' },",
                "    ClassRange { start: 'a', end: 'z' }",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'z' });",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ClassRange { start: 'a', end: 'a' };",
                "    let class = Class::new(vec![range]);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0].start, 'a');",
                "    assert_eq!(class.ranges[0].end, 'a');",
                "    assert!(class.is_canonical());"
              ],
              "code": [
                "{",
                "    let range = ClassRange { start: 'a', end: 'a' };",
                "    let class = Class::new(vec![range]);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0].start, 'a');",
                "    assert_eq!(class.ranges[0].end, 'a');",
                "    assert!(class.is_canonical());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![",
                "        ClassRange { start: 'a', end: 'c' },",
                "        ClassRange { start: 'd', end: 'f' },",
                "    ];",
                "    let class = Class::new(ranges);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class.ranges.len(), 2);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'c' });",
                "    assert_eq!(class.ranges[1], ClassRange { start: 'd', end: 'f' });",
                "    assert!(class.is_canonical());"
              ],
              "code": [
                "{",
                "    let ranges = vec![",
                "        ClassRange { start: 'a', end: 'c' },",
                "        ClassRange { start: 'd', end: 'f' },",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 2);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'c' });",
                "    assert_eq!(class.ranges[1], ClassRange { start: 'd', end: 'f' });",
                "    assert!(class.is_canonical());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![",
                "        ClassRange { start: 'a', end: 'd' },",
                "        ClassRange { start: 'c', end: 'f' },",
                "    ];",
                "    let class = Class::new(ranges);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0].start, 'a');",
                "    assert_eq!(class.ranges[0].end, 'f');"
              ],
              "code": [
                "{",
                "    let ranges = vec![",
                "        ClassRange { start: 'a', end: 'd' },",
                "        ClassRange { start: 'c', end: 'f' },",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 1);",
                "    assert_eq!(class.ranges[0].start, 'a');",
                "    assert_eq!(class.ranges[0].end, 'f');",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges = vec![",
                "        ClassRange { start: 'z', end: 'z' },",
                "        ClassRange { start: 'b', end: 'b' },",
                "        ClassRange { start: 'a', end: 'a' },",
                "    ];",
                "    let class = Class::new(ranges);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class.ranges.len(), 3);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'a' });",
                "    assert_eq!(class.ranges[1], ClassRange { start: 'b', end: 'b' });",
                "    assert_eq!(class.ranges[2], ClassRange { start: 'z', end: 'z' });"
              ],
              "code": [
                "{",
                "    let ranges = vec![",
                "        ClassRange { start: 'z', end: 'z' },",
                "        ClassRange { start: 'b', end: 'b' },",
                "        ClassRange { start: 'a', end: 'a' },",
                "    ];",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 3);",
                "    assert_eq!(class.ranges[0], ClassRange { start: 'a', end: 'a' });",
                "    assert_eq!(class.ranges[1], ClassRange { start: 'b', end: 'b' });",
                "    assert_eq!(class.ranges[2], ClassRange { start: 'z', end: 'z' });",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ranges: Vec<ClassRange> = (0..=127)",
                "        .map(|i| ClassRange { start: char::from(i as u8), end: char::from(i as u8) })",
                "        .collect();",
                "    let class = Class::new(ranges);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class.ranges.len(), 128);",
                "    assert!(class.ranges.iter().all(|range| range.start == range.end));",
                "    assert_eq!(class.ranges[0].start, '\\0');",
                "    assert_eq!(class.ranges[127].end, '\\x7F');",
                "    assert!(class.is_canonical());"
              ],
              "code": [
                "{",
                "    let ranges: Vec<ClassRange> = (0..=127)",
                "        .map(|i| ClassRange { start: char::from(i as u8), end: char::from(i as u8) })",
                "        .collect();",
                "    let class = Class::new(ranges);",
                "    assert_eq!(class.ranges.len(), 128);",
                "    assert!(class.ranges.iter().all(|range| range.start == range.end));",
                "    assert_eq!(class.ranges[0].start, '\\0');",
                "    assert_eq!(class.ranges[127].end, '\\x7F');",
                "    assert!(class.is_canonical());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}