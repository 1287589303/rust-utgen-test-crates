{
  "name": "regex_automata::nfa::thompson::map::{impl#0}::set",
  "mod_info": {
    "name": "nfa::thompson::map",
    "loc": "regex-automata/src/nfa/thompson/mod.rs:65:1:65:9"
  },
  "visible": true,
  "loc": "regex-automata/src/nfa/thompson/map.rs:176:5:184:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "capacity: 1 to 10^6 (inclusive), key length: 0 to 255 (inclusive), start range for Transition: 0 to 255 (inclusive), end range for Transition: start to 255 (inclusive), hash: 0 to capacity-1 (inclusive), state_id: valid StateID instances.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Utf8BoundedMap::new(1);",
                "    let key = vec![];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(0);",
                "    map.set(key, hash, state_id);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), 1);",
                "    assert_eq!(map.map[hash].version, 0);",
                "    assert_eq!(map.map[hash].key.len(), 0);",
                "    assert_eq!(map.map[hash].val, StateID(0));",
                "    assert!(map.get(&key, hash).is_some());",
                "    assert_eq!(map.get(&key, hash).unwrap(), StateID(0));"
              ],
              "code": [
                "{",
                "    let mut map = Utf8BoundedMap::new(1);",
                "    let key = vec![];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(0);",
                "    map.set(key, hash, state_id);",
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), 1);",
                "    assert_eq!(map.map[hash].version, 0);",
                "    assert_eq!(map.map[hash].key.len(), 0);",
                "    assert_eq!(map.map[hash].val, StateID(0));",
                "    assert!(map.get(&key, hash).is_some());",
                "    assert_eq!(map.get(&key, hash).unwrap(), StateID(0));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = vec![Transition { start: 1, end: 1, next: StateID(1) }];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(1);",
                "    map.set(key.clone(), hash, state_id);",
                "}"
              ],
              "oracle": [
                "    map.version == 0",
                "    map.capacity == 10",
                "    map.map.len() == 10",
                "    map.map[hash].version == map.version",
                "    map.map[hash].key == key",
                "    map.map[hash].val == state_id"
              ],
              "code": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = vec![Transition { start: 1, end: 1, next: StateID(1) }];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(1);",
                "    map.set(key.clone(), hash, state_id);",
                "    map.version == 0",
                "    map.capacity == 10",
                "    map.map.len() == 10",
                "    map.map[hash].version == map.version",
                "    map.map[hash].key == key",
                "    map.map[hash].val == state_id",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = vec![Transition { start: 0, end: 255, next: StateID(2) }];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(2);",
                "    map.set(key.clone(), hash, state_id);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), 10);",
                "    assert!(map.map.iter().all(|entry| entry.version == 0));",
                "    assert_eq!(map.get(&key, hash), Some(state_id));",
                "    assert_eq!(map.map[hash].key, key);",
                "    assert_eq!(map.map[hash].val, state_id);",
                "    assert_eq!(map.map[hash].version, map.version);"
              ],
              "code": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = vec![Transition { start: 0, end: 255, next: StateID(2) }];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(2);",
                "    map.set(key.clone(), hash, state_id);",
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), 10);",
                "    assert!(map.map.iter().all(|entry| entry.version == 0));",
                "    assert_eq!(map.get(&key, hash), Some(state_id));",
                "    assert_eq!(map.map[hash].key, key);",
                "    assert_eq!(map.map[hash].val, state_id);",
                "    assert_eq!(map.map[hash].version, map.version);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let capacity = 1_000_000;",
                "    let mut map = Utf8BoundedMap::new(capacity);",
                "    let key = vec![Transition { start: 0, end: 0, next: StateID(3) }];",
                "    let hash = map.hash(&key) % capacity;",
                "    let state_id = StateID(3);",
                "    map.set(key.clone(), hash, state_id);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), capacity);",
                "    assert!(map.map[hash].version == 0);",
                "    assert!(map.map[hash].key == key);",
                "    assert!(map.map[hash].val == state_id);"
              ],
              "code": [
                "{",
                "    let capacity = 1_000_000;",
                "    let mut map = Utf8BoundedMap::new(capacity);",
                "    let key = vec![Transition { start: 0, end: 0, next: StateID(3) }];",
                "    let hash = map.hash(&key) % capacity;",
                "    let state_id = StateID(3);",
                "    map.set(key.clone(), hash, state_id);",
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), capacity);",
                "    assert!(map.map[hash].version == 0);",
                "    assert!(map.map[hash].key == key);",
                "    assert!(map.map[hash].val == state_id);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = vec![",
                "        Transition { start: 0, end: 1, next: StateID(4) },",
                "        Transition { start: 2, end: 3, next: StateID(5) },",
                "    ];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(4);",
                "    map.set(key, hash, state_id);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), 10);",
                "    assert_eq!(map.map[hash].version, 0);",
                "    assert_eq!(map.map[hash].key.len(), 2);",
                "    assert_eq!(map.map[hash].key[0], Transition { start: 0, end: 1, next: StateID(4) });",
                "    assert_eq!(map.map[hash].key[1], Transition { start: 2, end: 3, next: StateID(5) });",
                "    assert_eq!(map.map[hash].val, state_id);",
                "    assert!(map.get(&key, hash).is_some());",
                "    assert_eq!(map.get(&key, hash), Some(state_id));"
              ],
              "code": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = vec![",
                "        Transition { start: 0, end: 1, next: StateID(4) },",
                "        Transition { start: 2, end: 3, next: StateID(5) },",
                "    ];",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(4);",
                "    map.set(key, hash, state_id);",
                "    assert_eq!(map.version, 0);",
                "    assert_eq!(map.map.len(), 10);",
                "    assert_eq!(map.map[hash].version, 0);",
                "    assert_eq!(map.map[hash].key.len(), 2);",
                "    assert_eq!(map.map[hash].key[0], Transition { start: 0, end: 1, next: StateID(4) });",
                "    assert_eq!(map.map[hash].key[1], Transition { start: 2, end: 3, next: StateID(5) });",
                "    assert_eq!(map.map[hash].val, state_id);",
                "    assert!(map.get(&key, hash).is_some());",
                "    assert_eq!(map.get(&key, hash), Some(state_id));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = (0..255)",
                "        .map(|i| Transition { start: i, end: 255, next: StateID(i as u32) })",
                "        .collect::<Vec<Transition>>();",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(255);",
                "    map.set(key, hash, state_id);",
                "}"
              ],
              "oracle": [
                "    let map = Utf8BoundedMap::new(10);",
                "    let key = (0..255).map(|i| Transition { start: i, end: 255, next: StateID(i as u32) }).collect::<Vec<Transition>>();",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(255);",
                "    map.set(key, hash, state_id);",
                "    assert_eq!(map.get(&key, hash), Some(state_id));",
                "    assert_eq!(map.map[hash].version, map.version);",
                "    assert_eq!(map.map[hash].key.len(), 256);",
                "    assert_eq!(map.map[hash].val, state_id);",
                "    assert!(map.get(&key, hash).is_some());"
              ],
              "code": [
                "{",
                "    let mut map = Utf8BoundedMap::new(10);",
                "    let key = (0..255)",
                "        .map(|i| Transition { start: i, end: 255, next: StateID(i as u32) })",
                "        .collect::<Vec<Transition>>();",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(255);",
                "    map.set(key, hash, state_id);",
                "    let map = Utf8BoundedMap::new(10);",
                "    let key = (0..255).map(|i| Transition { start: i, end: 255, next: StateID(i as u32) }).collect::<Vec<Transition>>();",
                "    let hash = map.hash(&key);",
                "    let state_id = StateID(255);",
                "    map.set(key, hash, state_id);",
                "    assert_eq!(map.get(&key, hash), Some(state_id));",
                "    assert_eq!(map.map[hash].version, map.version);",
                "    assert_eq!(map.map[hash].key.len(), 256);",
                "    assert_eq!(map.map[hash].val, state_id);",
                "    assert!(map.get(&key, hash).is_some());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}