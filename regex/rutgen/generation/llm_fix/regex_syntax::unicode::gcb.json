{
  "name": "regex_syntax::unicode::gcb",
  "mod_info": {
    "name": "unicode",
    "loc": "regex-syntax/src/lib.rs:193:1:193:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/unicode.rs:813:1:828:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "valid static strings for canonical_name representing different grapheme cluster break properties, including an existing property, a non-existing property, and properties dependent on the \"unicode-segment\" feature flag\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = gcb(\"Extend\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap().some_property(), expected_value);  // Replace some_property and expected_value as appropriate",
                "    assert_eq!(result.unwrap_err(), Error::PropertyNotFound);  // When testing with an unknown property",
                "    let invalid_result = gcb(\"UnknownProperty\");",
                "    assert!(invalid_result.is_err());",
                "    assert_eq!(invalid_result.unwrap_err(), Error::PropertyNotFound);  // Ensure it returns the correct error type"
              ],
              "code": [
                "{",
                "    let result = gcb(\"Extend\");",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap().some_property(), expected_value);  // Replace some_property and expected_value as appropriate",
                "    assert_eq!(result.unwrap_err(), Error::PropertyNotFound);  // When testing with an unknown property",
                "    let invalid_result = gcb(\"UnknownProperty\");",
                "    assert!(invalid_result.is_err());",
                "    assert_eq!(invalid_result.unwrap_err(), Error::PropertyNotFound);  // Ensure it returns the correct error type",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = gcb(\"NonExistingProperty\");",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Err(Error::PropertyNotFound));",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(Error::PropertyNotFound)));",
                "    let result_existing = gcb(\"GraphemeClusterBreak\");",
                "    assert!(result_existing.is_ok());",
                "    assert!(matches!(result_existing, Ok(_)));"
              ],
              "code": [
                "{",
                "    let result = gcb(\"NonExistingProperty\");",
                "    assert_eq!(result, Err(Error::PropertyNotFound));",
                "    assert!(result.is_err());",
                "    assert!(matches!(result, Err(Error::PropertyNotFound)));",
                "    let result_existing = gcb(\"GraphemeClusterBreak\");",
                "    assert!(result_existing.is_ok());",
                "    assert!(matches!(result_existing, Ok(_)));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[cfg(feature = \"unicode-segment\")]"
              ],
              "prefix": [
                "{",
                "    let result = gcb(\"CR\");",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), expected_hir_class_for_cr);",
                "    ",
                "    #[cfg(not(feature = \"unicode-segment\"))]",
                "    #[test]",
                "    fn test_property_not_found() {",
                "    let result = gcb(\"CR\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::PropertyNotFound);",
                "    }",
                "    ",
                "    #[cfg(feature = \"unicode-segment\")]",
                "    #[test]",
                "    fn test_property_value_not_found() {",
                "    let result = gcb(\"INVALID_PROPERTY\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::PropertyValueNotFound);",
                "    }"
              ],
              "code": [
                "{",
                "    let result = gcb(\"CR\");",
                "    assert!(result.is_ok());",
                "    assert_eq!(result.unwrap(), expected_hir_class_for_cr);",
                "    ",
                "    #[cfg(not(feature = \"unicode-segment\"))]",
                "    #[test]",
                "    fn test_property_not_found() {",
                "    let result = gcb(\"CR\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::PropertyNotFound);",
                "    }",
                "    ",
                "    #[cfg(feature = \"unicode-segment\")]",
                "    #[test]",
                "    fn test_property_value_not_found() {",
                "    let result = gcb(\"INVALID_PROPERTY\");",
                "    assert!(result.is_err());",
                "    assert_eq!(result.unwrap_err(), Error::PropertyValueNotFound);",
                "    }",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [
                "#[cfg(not(feature = \"unicode-segment\"))]"
              ],
              "prefix": [
                "{",
                "    let result = gcb(\"CR\");",
                "}"
              ],
              "oracle": [
                "    assert_eq!(result, Err(Error::PropertyNotFound));"
              ],
              "code": [
                "{",
                "    let result = gcb(\"CR\");",
                "    assert_eq!(result, Err(Error::PropertyNotFound));",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}