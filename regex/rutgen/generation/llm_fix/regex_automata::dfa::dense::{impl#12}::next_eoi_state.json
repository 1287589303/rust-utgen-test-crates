{
  "name": "regex_automata::dfa::dense::{impl#12}::next_eoi_state",
  "mod_info": {
    "name": "dfa::dense",
    "loc": "regex-automata/src/dfa/mod.rs:337:1:337:15"
  },
  "visible": true,
  "loc": "regex-automata/src/dfa/dense.rs:3194:5:3198:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: self.trans()[o]\n"
      ],
      "input_infer": "0 <= current.as_usize() <= max_state_id, 0 <= self.byte_classes().eoi().as_usize() <= 256\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let current = StateID(0);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 0, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let _ = dfa.next_eoi_state(current);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(dfa.next_eoi_state(StateID(0)), dfa.trans()[0 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(1)), dfa.trans()[1 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(2)), dfa.trans()[2 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(255)), dfa.trans()[255 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(256)), dfa.trans()[256 + dfa.byte_classes().eoi().as_usize()]);"
              ],
              "code": [
                "{",
                "    let current = StateID(0);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 0, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let _ = dfa.next_eoi_state(current);",
                "    assert_eq!(dfa.next_eoi_state(StateID(0)), dfa.trans()[0 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(1)), dfa.trans()[1 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(2)), dfa.trans()[2 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(255)), dfa.trans()[255 + dfa.byte_classes().eoi().as_usize()]);",
                "    assert_eq!(dfa.next_eoi_state(StateID(256)), dfa.trans()[256 + dfa.byte_classes().eoi().as_usize()]);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let current = StateID(255);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 255, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let _ = dfa.next_eoi_state(current);",
                "}"
              ],
              "oracle": [
                "    let current = StateID(255);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, ... };",
                "    ",
                "    // Verify the expected output of next_eoi_state",
                "    let expected_output = dfa.trans()[current.as_usize() + eoi];",
                "    assert_eq!(dfa.next_eoi_state(current), expected_output);"
              ],
              "code": [
                "{",
                "    let current = StateID(255);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 255, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let _ = dfa.next_eoi_state(current);",
                "    let current = StateID(255);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, ... };",
                "    ",
                "    // Verify the expected output of next_eoi_state",
                "    let expected_output = dfa.trans()[current.as_usize() + eoi];",
                "    assert_eq!(dfa.next_eoi_state(current), expected_output);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let current = StateID(128);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 255, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let _ = dfa.next_eoi_state(current);",
                "}"
              ],
              "oracle": [
                "    let current = StateID(128);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 255, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let expected = dfa.trans()[current.as_usize() + eoi];",
                "    assert_eq!(dfa.next_eoi_state(current), expected);"
              ],
              "code": [
                "{",
                "    let current = StateID(128);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 255, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let _ = dfa.next_eoi_state(current);",
                "    let current = StateID(128);",
                "    let byte_classes = ByteClasses([0; 256]);",
                "    let eoi = byte_classes.eoi().as_usize();",
                "    let tt = TransitionTable { table: vec![0; 257], classes: byte_classes, stride2: 8 };",
                "    let dfa = DFA { tt, st: StartTable { table: vec![], kind: StartKind::Both, start_map: StartByteMap::default(), stride: 0, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None }, ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 }, special: Special { max: 255, quit_id: 0, min_match: 0, max_match: 0, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 }, accels: Accels { accels: vec![] }, pre: None, quitset: ByteSet { bits: BitSet::default() }, flags: Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false } };",
                "    let expected = dfa.trans()[current.as_usize() + eoi];",
                "    assert_eq!(dfa.next_eoi_state(current), expected);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}