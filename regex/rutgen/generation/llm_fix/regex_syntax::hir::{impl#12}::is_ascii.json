{
  "name": "regex_syntax::hir::{impl#12}::is_ascii",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:1167:5:1169:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "self.set.intervals() must contain a variety of ClassUnicodeRange instances, including: 1) no ranges (should return true), 2) ranges with only ASCII characters (should return true), 3) ranges that include non-ASCII characters (should return false), and 4) a range starting from the lowest (0) to the highest (U+10FFFF) character with mixed content.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_unicode = ClassUnicode::empty();",
                "    class_unicode.is_ascii();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class_unicode.is_ascii(), true);",
                "    ",
                "    let mut class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    assert_eq!(class_unicode.is_ascii(), true);",
                "    ",
                "    class_unicode.push(ClassUnicodeRange { start: '\\x80', end: '\\xFF' });",
                "    assert_eq!(class_unicode.is_ascii(), false);",
                "    ",
                "    let mut class_unicode2 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
                "    assert_eq!(class_unicode2.is_ascii(), true);",
                "    ",
                "    let mut class_unicode3 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    class_unicode3.push(ClassUnicodeRange { start: '0', end: '9' });",
                "    assert_eq!(class_unicode3.is_ascii(), true);",
                "    ",
                "    let mut class_unicode4 = ClassUnicode::new(vec![ClassUnicodeRange { start: '!', end: '/' }]);",
                "    assert_eq!(class_unicode4.is_ascii(), true);",
                "    ",
                "    class_unicode4.push(ClassUnicodeRange { start: '\\u{100}', end: '\\u{200}' });",
                "    assert_eq!(class_unicode4.is_ascii(), false);"
              ],
              "code": [
                "{",
                "    let class_unicode = ClassUnicode::empty();",
                "    class_unicode.is_ascii();",
                "    assert_eq!(class_unicode.is_ascii(), true);",
                "    ",
                "    let mut class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    assert_eq!(class_unicode.is_ascii(), true);",
                "    ",
                "    class_unicode.push(ClassUnicodeRange { start: '\\x80', end: '\\xFF' });",
                "    assert_eq!(class_unicode.is_ascii(), false);",
                "    ",
                "    let mut class_unicode2 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
                "    assert_eq!(class_unicode2.is_ascii(), true);",
                "    ",
                "    let mut class_unicode3 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    class_unicode3.push(ClassUnicodeRange { start: '0', end: '9' });",
                "    assert_eq!(class_unicode3.is_ascii(), true);",
                "    ",
                "    let mut class_unicode4 = ClassUnicode::new(vec![ClassUnicodeRange { start: '!', end: '/' }]);",
                "    assert_eq!(class_unicode4.is_ascii(), true);",
                "    ",
                "    class_unicode4.push(ClassUnicodeRange { start: '\\u{100}', end: '\\u{200}' });",
                "    assert_eq!(class_unicode4.is_ascii(), false);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ascii_range = vec![ClassUnicodeRange { start: 'a', end: 'z' }];",
                "    let class_unicode = ClassUnicode::new(ascii_range);",
                "    class_unicode.is_ascii();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class_unicode.is_ascii(), true);",
                "    ",
                "    let non_ascii_range = vec![ClassUnicodeRange { start: 'α', end: 'ω' }];",
                "    let class_unicode_non_ascii = ClassUnicode::new(non_ascii_range);",
                "    assert_eq!(class_unicode_non_ascii.is_ascii(), false);",
                "    ",
                "    let mixed_range = vec![",
                "    ClassUnicodeRange { start: 'a', end: 'z' },",
                "    ClassUnicodeRange { start: 'æ', end: 'ÿ' }",
                "    ];",
                "    let class_unicode_mixed = ClassUnicode::new(mixed_range);",
                "    assert_eq!(class_unicode_mixed.is_ascii(), false);",
                "    ",
                "    let empty_class_unicode = ClassUnicode::empty();",
                "    assert_eq!(empty_class_unicode.is_ascii(), true);",
                "    ",
                "    let ascii_single_character = vec![ClassUnicodeRange { start: 'A', end: 'A' }];",
                "    let class_unicode_single_ascii = ClassUnicode::new(ascii_single_character);",
                "    assert_eq!(class_unicode_single_ascii.is_ascii(), true);"
              ],
              "code": [
                "{",
                "    let ascii_range = vec![ClassUnicodeRange { start: 'a', end: 'z' }];",
                "    let class_unicode = ClassUnicode::new(ascii_range);",
                "    class_unicode.is_ascii();",
                "    assert_eq!(class_unicode.is_ascii(), true);",
                "    ",
                "    let non_ascii_range = vec![ClassUnicodeRange { start: 'α', end: 'ω' }];",
                "    let class_unicode_non_ascii = ClassUnicode::new(non_ascii_range);",
                "    assert_eq!(class_unicode_non_ascii.is_ascii(), false);",
                "    ",
                "    let mixed_range = vec![",
                "    ClassUnicodeRange { start: 'a', end: 'z' },",
                "    ClassUnicodeRange { start: 'æ', end: 'ÿ' }",
                "    ];",
                "    let class_unicode_mixed = ClassUnicode::new(mixed_range);",
                "    assert_eq!(class_unicode_mixed.is_ascii(), false);",
                "    ",
                "    let empty_class_unicode = ClassUnicode::empty();",
                "    assert_eq!(empty_class_unicode.is_ascii(), true);",
                "    ",
                "    let ascii_single_character = vec![ClassUnicodeRange { start: 'A', end: 'A' }];",
                "    let class_unicode_single_ascii = ClassUnicode::new(ascii_single_character);",
                "    assert_eq!(class_unicode_single_ascii.is_ascii(), true);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mixed_range = vec![",
                "        ClassUnicodeRange { start: 'a', end: 'z' },",
                "        ClassUnicodeRange { start: '¡', end: '¢' },",
                "    ];",
                "    let class_unicode = ClassUnicode::new(mixed_range);",
                "    class_unicode.is_ascii();",
                "}"
              ],
              "oracle": [
                "    assert!(!class_unicode.is_ascii());"
              ],
              "code": [
                "{",
                "    let mixed_range = vec![",
                "        ClassUnicodeRange { start: 'a', end: 'z' },",
                "        ClassUnicodeRange { start: '¡', end: '¢' },",
                "    ];",
                "    let class_unicode = ClassUnicode::new(mixed_range);",
                "    class_unicode.is_ascii();",
                "    assert!(!class_unicode.is_ascii());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mixed_range = vec![",
                "        ClassUnicodeRange { start: '\\0', end: '\\x7F' }, // ASCII",
                "        ClassUnicodeRange { start: 'Ž', end: 'ž' },    // Non-ASCII",
                "    ];",
                "    let class_unicode = ClassUnicode::new(mixed_range);",
                "    class_unicode.is_ascii();",
                "}"
              ],
              "oracle": [
                "    assert!(!class_unicode.is_ascii());"
              ],
              "code": [
                "{",
                "    let mixed_range = vec![",
                "        ClassUnicodeRange { start: '\\0', end: '\\x7F' }, // ASCII",
                "        ClassUnicodeRange { start: 'Ž', end: 'ž' },    // Non-ASCII",
                "    ];",
                "    let class_unicode = ClassUnicode::new(mixed_range);",
                "    class_unicode.is_ascii();",
                "    assert!(!class_unicode.is_ascii());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let full_range = vec![",
                "        ClassUnicodeRange { start: '\\0', end: '\\u{10FFFF}' },",
                "    ];",
                "    let class_unicode = ClassUnicode::new(full_range);",
                "    class_unicode.is_ascii();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(class_unicode.is_ascii(), false);",
                "    ",
                "    let ascii_range = vec![",
                "    ClassUnicodeRange { start: '\\0', end: '\\x7F' },",
                "    ];",
                "    let ascii_class_unicode = ClassUnicode::new(ascii_range);",
                "    assert_eq!(ascii_class_unicode.is_ascii(), true);",
                "    ",
                "    let mixed_range = vec![",
                "    ClassUnicodeRange { start: '\\0', end: '\\x7F' },",
                "    ClassUnicodeRange { start: '\\u{80}', end: '\\u{10FFFF}' },",
                "    ];",
                "    let mixed_class_unicode = ClassUnicode::new(mixed_range);",
                "    assert_eq!(mixed_class_unicode.is_ascii(), false);",
                "    ",
                "    let empty_class_unicode = ClassUnicode::empty();",
                "    assert_eq!(empty_class_unicode.is_ascii(), true);",
                "    ",
                "    let single_non_ascii_range = vec![",
                "    ClassUnicodeRange { start: '\\u{80}', end: '\\u{80}' },",
                "    ];",
                "    let non_ascii_class_unicode = ClassUnicode::new(single_non_ascii_range);",
                "    assert_eq!(non_ascii_class_unicode.is_ascii(), false);"
              ],
              "code": [
                "{",
                "    let full_range = vec![",
                "        ClassUnicodeRange { start: '\\0', end: '\\u{10FFFF}' },",
                "    ];",
                "    let class_unicode = ClassUnicode::new(full_range);",
                "    class_unicode.is_ascii();",
                "    assert_eq!(class_unicode.is_ascii(), false);",
                "    ",
                "    let ascii_range = vec![",
                "    ClassUnicodeRange { start: '\\0', end: '\\x7F' },",
                "    ];",
                "    let ascii_class_unicode = ClassUnicode::new(ascii_range);",
                "    assert_eq!(ascii_class_unicode.is_ascii(), true);",
                "    ",
                "    let mixed_range = vec![",
                "    ClassUnicodeRange { start: '\\0', end: '\\x7F' },",
                "    ClassUnicodeRange { start: '\\u{80}', end: '\\u{10FFFF}' },",
                "    ];",
                "    let mixed_class_unicode = ClassUnicode::new(mixed_range);",
                "    assert_eq!(mixed_class_unicode.is_ascii(), false);",
                "    ",
                "    let empty_class_unicode = ClassUnicode::empty();",
                "    assert_eq!(empty_class_unicode.is_ascii(), true);",
                "    ",
                "    let single_non_ascii_range = vec![",
                "    ClassUnicodeRange { start: '\\u{80}', end: '\\u{80}' },",
                "    ];",
                "    let non_ascii_class_unicode = ClassUnicode::new(single_non_ascii_range);",
                "    assert_eq!(non_ascii_class_unicode.is_ascii(), false);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}