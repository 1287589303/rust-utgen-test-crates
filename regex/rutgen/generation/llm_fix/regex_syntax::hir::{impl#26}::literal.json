{
  "name": "regex_syntax::hir::{impl#26}::literal",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/mod.rs:2433:5:2449:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Properties(Box::new(inner))\n"
      ],
      "input_infer": "lit.0 as a Box<[u8]> with lengths ranging from 0 to 1024 bytes, including both valid UTF-8 byte sequences and invalid UTF-8 byte sequences, checking edge cases for empty and single-byte arrays.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new([]));",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    let lit = Literal(Box::new([b'a']));",
                "    assert_eq!(Properties::literal(&lit).0.minimum_len, Some(1));",
                "    assert_eq!(Properties::literal(&lit).0.maximum_len, Some(1));",
                "    assert_eq!(Properties::literal(&lit).0.utf8, true);",
                "    assert_eq!(Properties::literal(&lit).0.literal, true);",
                "    assert_eq!(Properties::literal(&lit).0.alternation_literal, true);",
                "    let lit_empty = Literal(Box::new([]));",
                "    assert_eq!(Properties::literal(&lit_empty).0.minimum_len, Some(0));",
                "    assert_eq!(Properties::literal(&lit_empty).0.maximum_len, Some(0));",
                "    assert_eq!(Properties::literal(&lit_empty).0.utf8, true);",
                "    assert_eq!(Properties::literal(&lit_empty).0.literal, true);",
                "    assert_eq!(Properties::literal(&lit_empty).0.alternation_literal, true);"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new([]));",
                "    let _properties = Properties::literal(&lit);",
                "    let lit = Literal(Box::new([b'a']));",
                "    assert_eq!(Properties::literal(&lit).0.minimum_len, Some(1));",
                "    assert_eq!(Properties::literal(&lit).0.maximum_len, Some(1));",
                "    assert_eq!(Properties::literal(&lit).0.utf8, true);",
                "    assert_eq!(Properties::literal(&lit).0.literal, true);",
                "    assert_eq!(Properties::literal(&lit).0.alternation_literal, true);",
                "    let lit_empty = Literal(Box::new([]));",
                "    assert_eq!(Properties::literal(&lit_empty).0.minimum_len, Some(0));",
                "    assert_eq!(Properties::literal(&lit_empty).0.maximum_len, Some(0));",
                "    assert_eq!(Properties::literal(&lit_empty).0.utf8, true);",
                "    assert_eq!(Properties::literal(&lit_empty).0.literal, true);",
                "    assert_eq!(Properties::literal(&lit_empty).0.alternation_literal, true);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new([b'a']));",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_properties, Properties::literal(&Literal(Box::new([b'a']))));",
                "    assert!(matches!(_properties, Properties(_)));",
                "    assert_eq!(_properties.0.minimum_len, Some(1));",
                "    assert_eq!(_properties.0.maximum_len, Some(1));",
                "    assert!(matches!(_properties.0.look_set, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_prefix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_suffix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_prefix_any, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_suffix_any, LookSet { bits: 0 }));",
                "    assert!(_properties.0.utf8);",
                "    assert_eq!(_properties.0.explicit_captures_len, 0);",
                "    assert_eq!(_properties.0.static_explicit_captures_len, Some(0));",
                "    assert!(_properties.0.literal);",
                "    assert!(_properties.0.alternation_literal);"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new([b'a']));",
                "    let _properties = Properties::literal(&lit);",
                "    assert_eq!(_properties, Properties::literal(&Literal(Box::new([b'a']))));",
                "    assert!(matches!(_properties, Properties(_)));",
                "    assert_eq!(_properties.0.minimum_len, Some(1));",
                "    assert_eq!(_properties.0.maximum_len, Some(1));",
                "    assert!(matches!(_properties.0.look_set, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_prefix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_suffix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_prefix_any, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.0.look_set_suffix_any, LookSet { bits: 0 }));",
                "    assert!(_properties.0.utf8);",
                "    assert_eq!(_properties.0.explicit_captures_len, 0);",
                "    assert_eq!(_properties.0.static_explicit_captures_len, Some(0));",
                "    assert!(_properties.0.literal);",
                "    assert!(_properties.0.alternation_literal);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new([b'a', b'b', b'c', b'd']));",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_properties.minimum_len, Some(4));",
                "    assert_eq!(_properties.maximum_len, Some(4));",
                "    assert!(matches!(_properties.look_set, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix_any, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix_any, LookSet { bits: 0 }));",
                "    assert!(_properties.utf8);",
                "    assert_eq!(_properties.explicit_captures_len, 0);",
                "    assert_eq!(_properties.static_explicit_captures_len, Some(0));",
                "    assert!(_properties.literal);",
                "    assert!(_properties.alternation_literal);"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new([b'a', b'b', b'c', b'd']));",
                "    let _properties = Properties::literal(&lit);",
                "    assert_eq!(_properties.minimum_len, Some(4));",
                "    assert_eq!(_properties.maximum_len, Some(4));",
                "    assert!(matches!(_properties.look_set, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix_any, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix_any, LookSet { bits: 0 }));",
                "    assert!(_properties.utf8);",
                "    assert_eq!(_properties.explicit_captures_len, 0);",
                "    assert_eq!(_properties.static_explicit_captures_len, Some(0));",
                "    assert!(_properties.literal);",
                "    assert!(_properties.alternation_literal);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new([0xc2, 0xa9])); // ©",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_properties.minimum_len, Some(2));",
                "    assert_eq!(_properties.maximum_len, Some(2));",
                "    assert!(core::str::from_utf8(&lit.0).is_ok());",
                "    assert_eq!(_properties.utf8, true);",
                "    assert_eq!(_properties.explicit_captures_len, 0);",
                "    assert_eq!(_properties.static_explicit_captures_len, Some(0));",
                "    assert_eq!(_properties.literal, true);",
                "    assert_eq!(_properties.alternation_literal, true);",
                "    assert!(matches!(_properties.look_set, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix_any, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix_any, LookSet { bits: 0 }));"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new([0xc2, 0xa9])); // ©",
                "    let _properties = Properties::literal(&lit);",
                "    assert_eq!(_properties.minimum_len, Some(2));",
                "    assert_eq!(_properties.maximum_len, Some(2));",
                "    assert!(core::str::from_utf8(&lit.0).is_ok());",
                "    assert_eq!(_properties.utf8, true);",
                "    assert_eq!(_properties.explicit_captures_len, 0);",
                "    assert_eq!(_properties.static_explicit_captures_len, Some(0));",
                "    assert_eq!(_properties.literal, true);",
                "    assert_eq!(_properties.alternation_literal, true);",
                "    assert!(matches!(_properties.look_set, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_prefix_any, LookSet { bits: 0 }));",
                "    assert!(matches!(_properties.look_set_suffix_any, LookSet { bits: 0 }));",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new([0xff])); ",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    let lit = Literal(Box::new([0xff]));",
                "    let properties = Properties::literal(&lit);",
                "    assert_eq!(properties.0.minimum_len, Some(1));",
                "    assert_eq!(properties.0.maximum_len, Some(1));",
                "    assert!(properties.0.utf8 == false);",
                "    assert_eq!(properties.0.explicit_captures_len, 0);",
                "    assert_eq!(properties.0.static_explicit_captures_len, Some(0));",
                "    assert!(properties.0.literal);",
                "    assert!(properties.0.alternation_literal);"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new([0xff])); ",
                "    let _properties = Properties::literal(&lit);",
                "    let lit = Literal(Box::new([0xff]));",
                "    let properties = Properties::literal(&lit);",
                "    assert_eq!(properties.0.minimum_len, Some(1));",
                "    assert_eq!(properties.0.maximum_len, Some(1));",
                "    assert!(properties.0.utf8 == false);",
                "    assert_eq!(properties.0.explicit_captures_len, 0);",
                "    assert_eq!(properties.0.static_explicit_captures_len, Some(0));",
                "    assert!(properties.0.literal);",
                "    assert!(properties.0.alternation_literal);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new([0xf0, 0x90, 0x80, 0x80])); // Invalid sequence",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    let lit = Literal(Box::new([0xf0, 0x90, 0x80, 0x80])); // Invalid UTF-8 sequence",
                "    let properties = Properties::literal(&lit);",
                "    assert_eq!(properties.minimum_len, Some(4));",
                "    assert_eq!(properties.maximum_len, Some(4));",
                "    assert!(properties.look_set.is_empty());",
                "    assert!(properties.look_set_prefix.is_empty());",
                "    assert!(properties.look_set_suffix.is_empty());",
                "    assert!(properties.look_set_prefix_any.is_empty());",
                "    assert!(properties.look_set_suffix_any.is_empty());",
                "    assert!(!properties.utf8);",
                "    assert_eq!(properties.explicit_captures_len, 0);",
                "    assert_eq!(properties.static_explicit_captures_len, Some(0));",
                "    assert!(properties.literal);",
                "    assert!(properties.alternation_literal);"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new([0xf0, 0x90, 0x80, 0x80])); // Invalid sequence",
                "    let _properties = Properties::literal(&lit);",
                "    let lit = Literal(Box::new([0xf0, 0x90, 0x80, 0x80])); // Invalid UTF-8 sequence",
                "    let properties = Properties::literal(&lit);",
                "    assert_eq!(properties.minimum_len, Some(4));",
                "    assert_eq!(properties.maximum_len, Some(4));",
                "    assert!(properties.look_set.is_empty());",
                "    assert!(properties.look_set_prefix.is_empty());",
                "    assert!(properties.look_set_suffix.is_empty());",
                "    assert!(properties.look_set_prefix_any.is_empty());",
                "    assert!(properties.look_set_suffix_any.is_empty());",
                "    assert!(!properties.utf8);",
                "    assert_eq!(properties.explicit_captures_len, 0);",
                "    assert_eq!(properties.static_explicit_captures_len, Some(0));",
                "    assert!(properties.literal);",
                "    assert!(properties.alternation_literal);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new((0..1024).map(|i| (i % 256) as u8).collect::<Vec<u8>>().into_boxed_slice())); ",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    Properties::literal(&Literal(Box::new((0..0).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(0), maximum_len: Some(0), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new((0..1).map(|i| (i % 256) as u8).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(1), maximum_len: Some(1), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new((0..256).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(256), maximum_len: Some(256), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new((0..1024).map(|i| (i % 256) as u8).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(1024), maximum_len: Some(1024), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new(b\"\\xF0\\x9F\\x98\\x81\".to_vec().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(4), maximum_len: Some(4), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new((0..1024).map(|i| (i % 256) as u8).collect::<Vec<u8>>().into_boxed_slice())); ",
                "    let _properties = Properties::literal(&lit);",
                "    Properties::literal(&Literal(Box::new((0..0).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(0), maximum_len: Some(0), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new((0..1).map(|i| (i % 256) as u8).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(1), maximum_len: Some(1), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new((0..256).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(256), maximum_len: Some(256), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new((0..1024).map(|i| (i % 256) as u8).collect::<Vec<u8>>().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(1024), maximum_len: Some(1024), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "    ",
                "    Properties::literal(&Literal(Box::new(b\"\\xF0\\x9F\\x98\\x81\".to_vec().into_boxed_slice()))) // expect Properties(Box::new(PropertiesI { minimum_len: Some(4), maximum_len: Some(4), look_set: LookSet::empty(), look_set_prefix: LookSet::empty(), look_set_suffix: LookSet::empty(), look_set_prefix_any: LookSet::empty(), look_set_suffix_any: LookSet::empty(), utf8: true, explicit_captures_len: 0, static_explicit_captures_len: Some(0), literal: true, alternation_literal: true }))",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lit = Literal(Box::new([0xff; 1024])); ",
                "    let _properties = Properties::literal(&lit);",
                "}"
              ],
              "oracle": [
                "    assert_eq!(_properties.minimum_len, Some(1024));",
                "    assert_eq!(_properties.maximum_len, Some(1024));",
                "    assert_eq!(_properties.look_set.len(), 0);",
                "    assert_eq!(_properties.look_set_prefix.len(), 0);",
                "    assert_eq!(_properties.look_set_suffix.len(), 0);",
                "    assert_eq!(_properties.look_set_prefix_any.len(), 0);",
                "    assert_eq!(_properties.look_set_suffix_any.len(), 0);",
                "    assert!(!_properties.utf8);",
                "    assert_eq!(_properties.explicit_captures_len, 0);",
                "    assert_eq!(_properties.static_explicit_captures_len, Some(0));",
                "    assert!(_properties.literal);",
                "    assert!(_properties.alternation_literal);"
              ],
              "code": [
                "{",
                "    let lit = Literal(Box::new([0xff; 1024])); ",
                "    let _properties = Properties::literal(&lit);",
                "    assert_eq!(_properties.minimum_len, Some(1024));",
                "    assert_eq!(_properties.maximum_len, Some(1024));",
                "    assert_eq!(_properties.look_set.len(), 0);",
                "    assert_eq!(_properties.look_set_prefix.len(), 0);",
                "    assert_eq!(_properties.look_set_suffix.len(), 0);",
                "    assert_eq!(_properties.look_set_prefix_any.len(), 0);",
                "    assert_eq!(_properties.look_set_suffix_any.len(), 0);",
                "    assert!(!_properties.utf8);",
                "    assert_eq!(_properties.explicit_captures_len, 0);",
                "    assert_eq!(_properties.static_explicit_captures_len, Some(0));",
                "    assert!(_properties.literal);",
                "    assert!(_properties.alternation_literal);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}