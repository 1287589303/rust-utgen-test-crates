{
  "name": "regex_syntax::parser::{impl#0}::build",
  "mod_info": {
    "name": "parser",
    "loc": "regex-syntax/src/lib.rs:191:1:191:12"
  },
  "visible": true,
  "loc": "regex-syntax/src/parser.rs:37:5:39:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "expected return value/type: Parser { ast: self.ast.build(), hir: self.hir.build() }\n"
      ],
      "input_infer": "valid nest_limit values: 0 to 1000; octal: true or false; ignore_whitespace: true or false; empty_min_range: true or false; utf8: true or false; line_terminator values: 0 to 255; all combinations of bool flags for case_insensitive, multi_line, dot_matches_new_line, crlf, swap_greed, unicode.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(0)",
                "        .octal(false)",
                "        .ignore_whitespace(true)",
                "        .empty_min_range(false);",
                "    let parser = parser_builder.build();",
                "}"
              ],
              "oracle": [
                "    let parser_builder = ParserBuilder::new()",
                "    .nest_limit(0)",
                "    .octal(false)",
                "    .ignore_whitespace(true)",
                "    .empty_min_range(false);",
                "    let parser = parser_builder.build();",
                "    assert_eq!(parser.nest_limit, 0);",
                "    assert_eq!(parser.octal, false);",
                "    assert_eq!(parser.initial_ignore_whitespace, true);",
                "    assert_eq!(parser.empty_min_range, false);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.pos.get().offset, 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.scratch.borrow().len(), 0);"
              ],
              "code": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(0)",
                "        .octal(false)",
                "        .ignore_whitespace(true)",
                "        .empty_min_range(false);",
                "    let parser = parser_builder.build();",
                "    let parser_builder = ParserBuilder::new()",
                "    .nest_limit(0)",
                "    .octal(false)",
                "    .ignore_whitespace(true)",
                "    .empty_min_range(false);",
                "    let parser = parser_builder.build();",
                "    assert_eq!(parser.nest_limit, 0);",
                "    assert_eq!(parser.octal, false);",
                "    assert_eq!(parser.initial_ignore_whitespace, true);",
                "    assert_eq!(parser.empty_min_range, false);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.pos.get().offset, 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert!(parser.comments.borrow().is_empty());",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.scratch.borrow().len(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(500)",
                "        .octal(true)",
                "        .ignore_whitespace(false)",
                "        .empty_min_range(true);",
                "    let parser = parser_builder.build();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.nest_limit, 500);",
                "    assert!(parser.octal);",
                "    assert!(!parser.initial_ignore_whitespace);",
                "    assert!(parser.empty_min_range);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.scratch.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert_eq!(parser.pos.get().offset, 0);"
              ],
              "code": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(500)",
                "        .octal(true)",
                "        .ignore_whitespace(false)",
                "        .empty_min_range(true);",
                "    let parser = parser_builder.build();",
                "    assert_eq!(parser.nest_limit, 500);",
                "    assert!(parser.octal);",
                "    assert!(!parser.initial_ignore_whitespace);",
                "    assert!(parser.empty_min_range);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.scratch.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert_eq!(parser.pos.get().offset, 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(1000)",
                "        .octal(false)",
                "        .ignore_whitespace(true)",
                "        .empty_min_range(true);",
                "    let parser = parser_builder.build();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.nest_limit, 1000);",
                "    assert_eq!(parser.octal, false);",
                "    assert_eq!(parser.initial_ignore_whitespace, true);",
                "    assert_eq!(parser.empty_min_range, true);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.scratch.borrow(), \"\");",
                "    assert_eq!(parser.pos.get().offset, 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert_eq!(parser.capture_index.get(), 0);"
              ],
              "code": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(1000)",
                "        .octal(false)",
                "        .ignore_whitespace(true)",
                "        .empty_min_range(true);",
                "    let parser = parser_builder.build();",
                "    assert_eq!(parser.nest_limit, 1000);",
                "    assert_eq!(parser.octal, false);",
                "    assert_eq!(parser.initial_ignore_whitespace, true);",
                "    assert_eq!(parser.empty_min_range, true);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.scratch.borrow(), \"\");",
                "    assert_eq!(parser.pos.get().offset, 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(100)",
                "        .octal(true)",
                "        .ignore_whitespace(false)",
                "        .empty_min_range(false);",
                "    let parser = parser_builder.build();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.nest_limit, 100);",
                "    assert!(parser.octal);",
                "    assert!(!parser.initial_ignore_whitespace);",
                "    assert!(!parser.empty_min_range);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.scratch.borrow().len(), 0);"
              ],
              "code": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(100)",
                "        .octal(true)",
                "        .ignore_whitespace(false)",
                "        .empty_min_range(false);",
                "    let parser = parser_builder.build();",
                "    assert_eq!(parser.nest_limit, 100);",
                "    assert!(parser.octal);",
                "    assert!(!parser.initial_ignore_whitespace);",
                "    assert!(!parser.empty_min_range);",
                "    assert_eq!(parser.comments.borrow().len(), 0);",
                "    assert_eq!(parser.capture_names.borrow().len(), 0);",
                "    assert_eq!(parser.stack_group.borrow().len(), 0);",
                "    assert_eq!(parser.stack_class.borrow().len(), 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.scratch.borrow().len(), 0);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(999)",
                "        .octal(true)",
                "        .ignore_whitespace(true)",
                "        .utf8(false);",
                "    let parser = parser_builder.build();",
                "}"
              ],
              "oracle": [
                "    let parser_builder = ParserBuilder::new();",
                "    assert_eq!(parser_builder.nest_limit, 999);",
                "    assert_eq!(parser_builder.octal, true);",
                "    assert_eq!(parser_builder.ignore_whitespace, true);",
                "    assert_eq!(parser_builder.utf8, false);",
                "    let parser = parser_builder.build();",
                "    assert!(parser.ast.is_valid());",
                "    assert!(parser.hir.is_valid());"
              ],
              "code": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(999)",
                "        .octal(true)",
                "        .ignore_whitespace(true)",
                "        .utf8(false);",
                "    let parser = parser_builder.build();",
                "    let parser_builder = ParserBuilder::new();",
                "    assert_eq!(parser_builder.nest_limit, 999);",
                "    assert_eq!(parser_builder.octal, true);",
                "    assert_eq!(parser_builder.ignore_whitespace, true);",
                "    assert_eq!(parser_builder.utf8, false);",
                "    let parser = parser_builder.build();",
                "    assert!(parser.ast.is_valid());",
                "    assert!(parser.hir.is_valid());",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(250)",
                "        .line_terminator(255)",
                "        .utf8(true)",
                "        .ignore_whitespace(false);",
                "    let parser = parser_builder.build();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.nest_limit, 250);",
                "    assert_eq!(parser.ignore_whitespace.get(), false);",
                "    assert_eq!(parser.ast, parser_builder.ast.build());",
                "    assert_eq!(parser.hir, parser_builder.hir.build());",
                "    assert_eq!(parser.utf8, true);",
                "    assert_eq!(parser.line_terminator, 255);"
              ],
              "code": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(250)",
                "        .line_terminator(255)",
                "        .utf8(true)",
                "        .ignore_whitespace(false);",
                "    let parser = parser_builder.build();",
                "    assert_eq!(parser.nest_limit, 250);",
                "    assert_eq!(parser.ignore_whitespace.get(), false);",
                "    assert_eq!(parser.ast, parser_builder.ast.build());",
                "    assert_eq!(parser.hir, parser_builder.hir.build());",
                "    assert_eq!(parser.utf8, true);",
                "    assert_eq!(parser.line_terminator, 255);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(0)",
                "        .octal(false)",
                "        .ignore_whitespace(true)",
                "        .empty_min_range(true)",
                "        .utf8(true)",
                "        .line_terminator(128);",
                "    let parser = parser_builder.build();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(parser.nest_limit, 0);",
                "    assert_eq!(parser.octal, false);",
                "    assert_eq!(parser.initial_ignore_whitespace, true);",
                "    assert_eq!(parser.empty_min_range, true);",
                "    assert_eq!(parser.ignore_whitespace.get(), true);",
                "    assert_eq!(parser.scratch.borrow().is_empty(), true);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.comments.borrow().is_empty(), true);",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.pos.get().offset, 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);"
              ],
              "code": [
                "{",
                "    let parser_builder = ParserBuilder::new()",
                "        .nest_limit(0)",
                "        .octal(false)",
                "        .ignore_whitespace(true)",
                "        .empty_min_range(true)",
                "        .utf8(true)",
                "        .line_terminator(128);",
                "    let parser = parser_builder.build();",
                "    assert_eq!(parser.nest_limit, 0);",
                "    assert_eq!(parser.octal, false);",
                "    assert_eq!(parser.initial_ignore_whitespace, true);",
                "    assert_eq!(parser.empty_min_range, true);",
                "    assert_eq!(parser.ignore_whitespace.get(), true);",
                "    assert_eq!(parser.scratch.borrow().is_empty(), true);",
                "    assert_eq!(parser.capture_index.get(), 0);",
                "    assert_eq!(parser.comments.borrow().is_empty(), true);",
                "    assert!(parser.stack_group.borrow().is_empty());",
                "    assert!(parser.stack_class.borrow().is_empty());",
                "    assert!(parser.capture_names.borrow().is_empty());",
                "    assert_eq!(parser.pos.get().offset, 0);",
                "    assert_eq!(parser.pos.get().line, 1);",
                "    assert_eq!(parser.pos.get().column, 1);",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}