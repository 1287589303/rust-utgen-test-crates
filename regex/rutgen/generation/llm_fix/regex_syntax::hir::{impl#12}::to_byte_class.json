{
  "name": "regex_syntax::hir::{impl#12}::to_byte_class",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:190:1:190:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:1207:5:1219:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "precondition: self.is_ascii() at line 1208 is true\n",
        "expected return value/type: Some(ClassBytes::new(self.ranges().iter().map(|r| {\n            // Since we are guaranteed that our codepoint range is ASCII, the\n            // 'u8::try_from' calls below are guaranteed to be correct.\n            ClassBytesRange {\n                start: u8::try_from(r.start).unwrap(),\n                end: u8::try_from(r.end).unwrap(),\n            }\n        })))\n"
      ],
      "input_infer": "self.ranges() must contain only ClassUnicodeRange with start and end characters in the range ['\\x00', '\\x7F']\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![]);",
                "    let result = class_unicode.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 97, end: 122 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 65, end: 90 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 48, end: 57 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: ' ', end: ' ' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 32, end: 32 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 0, end: 127 }]);"
              ],
              "code": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![]);",
                "    let result = class_unicode.to_byte_class();",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 97, end: 122 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 65, end: 90 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 48, end: 57 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: ' ', end: ' ' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 32, end: 32 }]);",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 0, end: 127 }]);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
                "    let result = class_unicode.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
                "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]));",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
                "    let result = class_unicode.to_byte_class();",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
                "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]));",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![",
                "        ClassUnicodeRange { start: '\\x21', end: '\\x7E' },",
                "        ClassUnicodeRange { start: '\\x00', end: '\\x20' },",
                "    ]);",
                "    let result = class_unicode.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_some());",
                "    let class_bytes = result.unwrap();",
                "    assert_eq!(class_bytes.ranges().len(), 2);",
                "    assert_eq!(class_bytes.ranges()[0].start, 33);",
                "    assert_eq!(class_bytes.ranges()[0].end, 126);",
                "    assert_eq!(class_bytes.ranges()[1].start, 0);",
                "    assert_eq!(class_bytes.ranges()[1].end, 32);",
                "    assert!(class_bytes.is_ascii());"
              ],
              "code": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![",
                "        ClassUnicodeRange { start: '\\x21', end: '\\x7E' },",
                "        ClassUnicodeRange { start: '\\x00', end: '\\x20' },",
                "    ]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    let class_bytes = result.unwrap();",
                "    assert_eq!(class_bytes.ranges().len(), 2);",
                "    assert_eq!(class_bytes.ranges()[0].start, 33);",
                "    assert_eq!(class_bytes.ranges()[0].end, 126);",
                "    assert_eq!(class_bytes.ranges()[1].start, 0);",
                "    assert_eq!(class_bytes.ranges()[1].end, 32);",
                "    assert!(class_bytes.is_ascii());",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![",
                "        ClassUnicodeRange { start: '\\x30', end: '\\x39' }, // 0-9",
                "        ClassUnicodeRange { start: '\\x41', end: '\\x5A' }, // A-Z",
                "        ClassUnicodeRange { start: '\\x61', end: '\\x7A' }, // a-z",
                "    ]);",
                "    let result = class_unicode.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    assert!(result.is_some());",
                "    let class_bytes = result.unwrap();",
                "    let expected_ranges = vec![",
                "    ClassBytesRange { start: 0x30u8, end: 0x39u8 }, // 0-9",
                "    ClassBytesRange { start: 0x41u8, end: 0x5Au8 }, // A-Z",
                "    ClassBytesRange { start: 0x61u8, end: 0x7Au8 }, // a-z",
                "    ];",
                "    assert_eq!(class_bytes.set.intervals(), expected_ranges);"
              ],
              "code": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![",
                "        ClassUnicodeRange { start: '\\x30', end: '\\x39' }, // 0-9",
                "        ClassUnicodeRange { start: '\\x41', end: '\\x5A' }, // A-Z",
                "        ClassUnicodeRange { start: '\\x61', end: '\\x7A' }, // a-z",
                "    ]);",
                "    let result = class_unicode.to_byte_class();",
                "    assert!(result.is_some());",
                "    let class_bytes = result.unwrap();",
                "    let expected_ranges = vec![",
                "    ClassBytesRange { start: 0x30u8, end: 0x39u8 }, // 0-9",
                "    ClassBytesRange { start: 0x41u8, end: 0x5Au8 }, // A-Z",
                "    ClassBytesRange { start: 0x61u8, end: 0x7Au8 }, // a-z",
                "    ];",
                "    assert_eq!(class_bytes.set.intervals(), expected_ranges);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![",
                "        ClassUnicodeRange { start: '\\x00', end: '\\x00' }, // Single character range",
                "        ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }, // Single character range",
                "    ]);",
                "    let result = class_unicode.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x00' }, ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }]);",
                "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 0 }, ClassBytesRange { start: 127, end: 127 }]));",
                "    assert_eq!(result, expected);"
              ],
              "code": [
                "{",
                "    let class_unicode = ClassUnicode::new(vec![",
                "        ClassUnicodeRange { start: '\\x00', end: '\\x00' }, // Single character range",
                "        ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }, // Single character range",
                "    ]);",
                "    let result = class_unicode.to_byte_class();",
                "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x00' }, ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }]);",
                "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 0 }, ClassBytesRange { start: 127, end: 127 }]));",
                "    assert_eq!(result, expected);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "precondition: self.is_ascii() at line 1208 is false\n",
        "expected return value/type: None\n"
      ],
      "input_infer": "ClassUnicode instance with ranges that include at least one non-ASCII character (e.g., ranges including characters beyond '\\x7F')\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let non_ascii_range = ClassUnicodeRange {",
                "        start: '€', // Non-ASCII character",
                "        end: '€',",
                "    };",
                "    let unicode_class = ClassUnicode::new(vec![non_ascii_range]);",
                "    let byte_class = unicode_class.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(byte_class, None);"
              ],
              "code": [
                "{",
                "    let non_ascii_range = ClassUnicodeRange {",
                "        start: '€', // Non-ASCII character",
                "        end: '€',",
                "    };",
                "    let unicode_class = ClassUnicode::new(vec![non_ascii_range]);",
                "    let byte_class = unicode_class.to_byte_class();",
                "    assert_eq!(byte_class, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ascii_range = ClassUnicodeRange {",
                "        start: 'a',",
                "        end: 'z',",
                "    };",
                "    let non_ascii_range = ClassUnicodeRange {",
                "        start: '€', // Non-ASCII character",
                "        end: '€',",
                "    };",
                "    let unicode_class = ClassUnicode::new(vec![ascii_range, non_ascii_range]);",
                "    let byte_class = unicode_class.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(byte_class, None);"
              ],
              "code": [
                "{",
                "    let ascii_range = ClassUnicodeRange {",
                "        start: 'a',",
                "        end: 'z',",
                "    };",
                "    let non_ascii_range = ClassUnicodeRange {",
                "        start: '€', // Non-ASCII character",
                "        end: '€',",
                "    };",
                "    let unicode_class = ClassUnicode::new(vec![ascii_range, non_ascii_range]);",
                "    let byte_class = unicode_class.to_byte_class();",
                "    assert_eq!(byte_class, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let out_of_bounds_range = ClassUnicodeRange {",
                "        start: 'ÿ', // Non-ASCII character",
                "        end: 'ÿ',",
                "    };",
                "    let unicode_class = ClassUnicode::new(vec![out_of_bounds_range]);",
                "    let byte_class = unicode_class.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    assert_eq!(byte_class, None);"
              ],
              "code": [
                "{",
                "    let out_of_bounds_range = ClassUnicodeRange {",
                "        start: 'ÿ', // Non-ASCII character",
                "        end: 'ÿ',",
                "    };",
                "    let unicode_class = ClassUnicode::new(vec![out_of_bounds_range]);",
                "    let byte_class = unicode_class.to_byte_class();",
                "    assert_eq!(byte_class, None);",
                "}"
              ],
              "can_compile": true,
              "repaired": false
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unicode_class = ClassUnicode::empty();",
                "    let byte_class = unicode_class.to_byte_class();",
                "}"
              ],
              "oracle": [
                "    byte_class.is_none()"
              ],
              "code": [
                "{",
                "    let unicode_class = ClassUnicode::empty();",
                "    let byte_class = unicode_class.to_byte_class();",
                "    byte_class.is_none()",
                "}"
              ],
              "can_compile": false,
              "repaired": false
            }
          ]
        }
      ]
    }
  ]
}