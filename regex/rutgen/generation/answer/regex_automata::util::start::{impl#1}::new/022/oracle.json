[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestLookMatcher {",
          "        lineterm: DebugByte,",
          "    }",
          "",
          "    impl TestLookMatcher {",
          "        fn new(lineterm: u8) -> Self {",
          "            TestLookMatcher {",
          "                lineterm: DebugByte(lineterm),",
          "            }",
          "        }",
          "",
          "        fn get_line_terminator(&self) -> u8 {",
          "            self.lineterm.0",
          "        }",
          "    }",
          "",
          "    let lookm = TestLookMatcher::new(0xFF); // Custom line terminator greater than b'\\r' and not equal to b'\\n'",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "}"
        ],
        "oracle": [
          "    let lookm = TestLookMatcher::new(0xFF);",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\n')], Start::LineLF);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\r')], Start::LineCR);",
          "    assert_eq!(start_byte_map.map[usize::from(b'_')], Start::WordByte);",
          "    for byte in b'0'..=b'9' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'A'..=b'Z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'a'..=b'z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    assert_eq!(start_byte_map.map[usize::from(0xFF)], Start::CustomLineTerminator);"
        ],
        "code": [
          "{",
          "    struct TestLookMatcher {",
          "        lineterm: DebugByte,",
          "    }",
          "",
          "    impl TestLookMatcher {",
          "        fn new(lineterm: u8) -> Self {",
          "            TestLookMatcher {",
          "                lineterm: DebugByte(lineterm),",
          "            }",
          "        }",
          "",
          "        fn get_line_terminator(&self) -> u8 {",
          "            self.lineterm.0",
          "        }",
          "    }",
          "",
          "    let lookm = TestLookMatcher::new(0xFF); // Custom line terminator greater than b'\\r' and not equal to b'\\n'",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "    let lookm = TestLookMatcher::new(0xFF);",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\n')], Start::LineLF);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\r')], Start::LineCR);",
          "    assert_eq!(start_byte_map.map[usize::from(b'_')], Start::WordByte);",
          "    for byte in b'0'..=b'9' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'A'..=b'Z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'a'..=b'z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    assert_eq!(start_byte_map.map[usize::from(0xFF)], Start::CustomLineTerminator);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestLookMatcher {",
          "        lineterm: DebugByte,",
          "    }",
          "",
          "    impl TestLookMatcher {",
          "        fn new(lineterm: u8) -> Self {",
          "            TestLookMatcher {",
          "                lineterm: DebugByte(lineterm),",
          "            }",
          "        }",
          "",
          "        fn get_line_terminator(&self) -> u8 {",
          "            self.lineterm.0",
          "        }",
          "    }",
          "",
          "    let lookm = TestLookMatcher::new(0xFE); // Another custom line terminator",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(start_byte_map.map[usize::from(b'\\n')], Start::LineLF);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\r')], Start::LineCR);",
          "    assert_eq!(start_byte_map.map[usize::from(b'_')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'0')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'1')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'2')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'3')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'4')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'5')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'6')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'7')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'8')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'9')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'A')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'B')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'C')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'D')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'E')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'F')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'G')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'H')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'I')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'J')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'K')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'L')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'M')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'N')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'O')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'P')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'Q')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'R')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'S')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'T')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'U')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'V')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'W')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'X')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'Y')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'Z')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'a')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'b')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'c')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'd')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'e')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'f')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'g')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'h')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'i')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'j')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'k')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'l')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'm')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'n')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'o')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'p')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'q')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'r')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b's')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b't')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'u')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'v')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'w')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'x')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'y')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'z')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(0xFE)], Start::CustomLineTerminator);"
        ],
        "code": [
          "{",
          "    struct TestLookMatcher {",
          "        lineterm: DebugByte,",
          "    }",
          "",
          "    impl TestLookMatcher {",
          "        fn new(lineterm: u8) -> Self {",
          "            TestLookMatcher {",
          "                lineterm: DebugByte(lineterm),",
          "            }",
          "        }",
          "",
          "        fn get_line_terminator(&self) -> u8 {",
          "            self.lineterm.0",
          "        }",
          "    }",
          "",
          "    let lookm = TestLookMatcher::new(0xFE); // Another custom line terminator",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\n')], Start::LineLF);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\r')], Start::LineCR);",
          "    assert_eq!(start_byte_map.map[usize::from(b'_')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'0')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'1')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'2')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'3')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'4')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'5')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'6')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'7')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'8')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'9')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'A')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'B')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'C')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'D')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'E')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'F')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'G')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'H')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'I')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'J')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'K')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'L')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'M')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'N')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'O')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'P')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'Q')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'R')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'S')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'T')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'U')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'V')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'W')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'X')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'Y')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'Z')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'a')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'b')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'c')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'd')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'e')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'f')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'g')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'h')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'i')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'j')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'k')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'l')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'm')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'n')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'o')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'p')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'q')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'r')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b's')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b't')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'u')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'v')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'w')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'x')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'y')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[ usize::from(b'z')], Start::WordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(0xFE)], Start::CustomLineTerminator);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestLookMatcher {",
          "        lineterm: DebugByte,",
          "    }",
          "",
          "    impl TestLookMatcher {",
          "        fn new(lineterm: u8) -> Self {",
          "            TestLookMatcher {",
          "                lineterm: DebugByte(lineterm),",
          "            }",
          "        }",
          "",
          "        fn get_line_terminator(&self) -> u8 {",
          "            self.lineterm.0",
          "        }",
          "    }",
          "",
          "    let lookm = TestLookMatcher::new(0xA0); // Yet another custom line terminator",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "}"
        ],
        "oracle": [
          "    let lookm = TestLookMatcher::new(0xA0);",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\n')], Start::LineLF);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\r')], Start::LineCR);",
          "    assert_eq!(start_byte_map.map[usize::from(b'_')], Start::WordByte);",
          "    for byte in b'0'..=b'9' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'A'..=b'Z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'a'..=b'z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    assert_eq!(start_byte_map.map[usize::from(0xA0)], Start::CustomLineTerminator);"
        ],
        "code": [
          "{",
          "    struct TestLookMatcher {",
          "        lineterm: DebugByte,",
          "    }",
          "",
          "    impl TestLookMatcher {",
          "        fn new(lineterm: u8) -> Self {",
          "            TestLookMatcher {",
          "                lineterm: DebugByte(lineterm),",
          "            }",
          "        }",
          "",
          "        fn get_line_terminator(&self) -> u8 {",
          "            self.lineterm.0",
          "        }",
          "    }",
          "",
          "    let lookm = TestLookMatcher::new(0xA0); // Yet another custom line terminator",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "    let lookm = TestLookMatcher::new(0xA0);",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\n')], Start::LineLF);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\r')], Start::LineCR);",
          "    assert_eq!(start_byte_map.map[usize::from(b'_')], Start::WordByte);",
          "    for byte in b'0'..=b'9' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'A'..=b'Z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    for byte in b'a'..=b'z' {",
          "    assert_eq!(start_byte_map.map[usize::from(byte)], Start::WordByte);",
          "    }",
          "    assert_eq!(start_byte_map.map[usize::from(0xA0)], Start::CustomLineTerminator);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]