[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lookm = LookMatcher::new();",
          "    lookm.set_line_terminator(b'\\r');",
          "",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "",
          "    let byte_to_test1 = b':';",
          "    let byte_to_test2 = b'{';",
          "    let byte_to_test3 = b'|';",
          "    let byte_to_test4 = b'~';",
          "",
          "    let map_value1 = start_byte_map.get(byte_to_test1);",
          "    let map_value2 = start_byte_map.get(byte_to_test2);",
          "    let map_value3 = start_byte_map.get(byte_to_test3);",
          "    let map_value4 = start_byte_map.get(byte_to_test4);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(start_byte_map.get(b':'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'{'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'|'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'~'), Start::NonWordByte);"
        ],
        "code": [
          "{",
          "    let mut lookm = LookMatcher::new();",
          "    lookm.set_line_terminator(b'\\r');",
          "",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "",
          "    let byte_to_test1 = b':';",
          "    let byte_to_test2 = b'{';",
          "    let byte_to_test3 = b'|';",
          "    let byte_to_test4 = b'~';",
          "",
          "    let map_value1 = start_byte_map.get(byte_to_test1);",
          "    let map_value2 = start_byte_map.get(byte_to_test2);",
          "    let map_value3 = start_byte_map.get(byte_to_test3);",
          "    let map_value4 = start_byte_map.get(byte_to_test4);",
          "    assert_eq!(start_byte_map.get(b':'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'{'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'|'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'~'), Start::NonWordByte);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut lookm = LookMatcher::new();",
          "    lookm.set_line_terminator(b'\\x1A'); // an unusual line terminator",
          "",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "",
          "    let byte_to_test1 = b':';",
          "    let byte_to_test2 = b'{';",
          "    let byte_to_test3 = b'|';",
          "    let byte_to_test4 = b'~';",
          "",
          "    let map_value1 = start_byte_map.get(byte_to_test1);",
          "    let map_value2 = start_byte_map.get(byte_to_test2);",
          "    let map_value3 = start_byte_map.get(byte_to_test3);",
          "    let map_value4 = start_byte_map.get(byte_to_test4);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(start_byte_map.get(b':'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'{'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'|'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'~'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\x1A')], Start::CustomLineTerminator);"
        ],
        "code": [
          "{",
          "    let mut lookm = LookMatcher::new();",
          "    lookm.set_line_terminator(b'\\x1A'); // an unusual line terminator",
          "",
          "    let start_byte_map = StartByteMap::new(&lookm);",
          "",
          "    let byte_to_test1 = b':';",
          "    let byte_to_test2 = b'{';",
          "    let byte_to_test3 = b'|';",
          "    let byte_to_test4 = b'~';",
          "",
          "    let map_value1 = start_byte_map.get(byte_to_test1);",
          "    let map_value2 = start_byte_map.get(byte_to_test2);",
          "    let map_value3 = start_byte_map.get(byte_to_test3);",
          "    let map_value4 = start_byte_map.get(byte_to_test4);",
          "    assert_eq!(start_byte_map.get(b':'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'{'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'|'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.get(b'~'), Start::NonWordByte);",
          "    assert_eq!(start_byte_map.map[usize::from(b'\\x1A')], Start::CustomLineTerminator);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]