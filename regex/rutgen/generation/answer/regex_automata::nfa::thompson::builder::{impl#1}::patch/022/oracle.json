[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let sparse_state_id = builder.add_sparse(vec![Transition { start: 0, end: 1, next: StateID(0) }]).unwrap();",
          "    let another_state_id = builder.add_empty().unwrap(); // Just to have another valid StateID",
          "",
          "    builder.patch(sparse_state_id, another_state_id).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.states[from] matches State::Sparse { .. } at line 1149 is true;",
          "    self.patch(sparse_state_id, another_state_id).unwrap();",
          "    panic!(\"cannot patch from a sparse NFA state\");",
          "    unwrap_err();",
          "    assert!(matches!(builder.patch(sparse_state_id, another_state_id), Err(BuildError)));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let sparse_state_id = builder.add_sparse(vec![Transition { start: 0, end: 1, next: StateID(0) }]).unwrap();",
          "    let another_state_id = builder.add_empty().unwrap(); // Just to have another valid StateID",
          "",
          "    builder.patch(sparse_state_id, another_state_id).unwrap();",
          "    self.states[from] matches State::Sparse { .. } at line 1149 is true;",
          "    self.patch(sparse_state_id, another_state_id).unwrap();",
          "    panic!(\"cannot patch from a sparse NFA state\");",
          "    unwrap_err();",
          "    assert!(matches!(builder.patch(sparse_state_id, another_state_id), Err(BuildError)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let sparse_state_id_1 = builder.add_sparse(vec![Transition { start: 2, end: 3, next: StateID(1) }]).unwrap();",
          "    let sparse_state_id_2 = builder.add_sparse(vec![Transition { start: 4, end: 5, next: StateID(2) }]).unwrap();",
          "    let another_state_id = builder.add_empty().unwrap(); // Another state to patch to",
          "",
          "    builder.patch(sparse_state_id_1, another_state_id).unwrap();",
          "    builder.patch(sparse_state_id_2, another_state_id).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.states[sparse_state_id_1] matches State::Sparse { .. } at line 1149 is true",
          "    self.states[sparse_state_id_2] matches State::Sparse { .. } at line 1149 is true",
          "    panic!(\"cannot patch from a sparse NFA state\") is invoked when calling builder.patch(sparse_state_id_1, another_state_id)",
          "    panic!(\"cannot patch from a sparse NFA state\") is invoked when calling builder.patch(sparse_state_id_2, another_state_id)"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let sparse_state_id_1 = builder.add_sparse(vec![Transition { start: 2, end: 3, next: StateID(1) }]).unwrap();",
          "    let sparse_state_id_2 = builder.add_sparse(vec![Transition { start: 4, end: 5, next: StateID(2) }]).unwrap();",
          "    let another_state_id = builder.add_empty().unwrap(); // Another state to patch to",
          "",
          "    builder.patch(sparse_state_id_1, another_state_id).unwrap();",
          "    builder.patch(sparse_state_id_2, another_state_id).unwrap();",
          "    self.states[sparse_state_id_1] matches State::Sparse { .. } at line 1149 is true",
          "    self.states[sparse_state_id_2] matches State::Sparse { .. } at line 1149 is true",
          "    panic!(\"cannot patch from a sparse NFA state\") is invoked when calling builder.patch(sparse_state_id_1, another_state_id)",
          "    panic!(\"cannot patch from a sparse NFA state\") is invoked when calling builder.patch(sparse_state_id_2, another_state_id)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let initial_state_id = builder.add_match().unwrap(); // Create a match state",
          "    let sparse_state_id = builder.add_sparse(vec![Transition { start: 0, end: 255, next: StateID(0) }]).unwrap();",
          "",
          "    builder.patch(sparse_state_id, initial_state_id).unwrap(); // This should panic",
          "}"
        ],
        "oracle": [
          "    builder.patch(sparse_state_id, initial_state_id).unwrap(); // Expected to panic due to patching a sparse state"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let initial_state_id = builder.add_match().unwrap(); // Create a match state",
          "    let sparse_state_id = builder.add_sparse(vec![Transition { start: 0, end: 255, next: StateID(0) }]).unwrap();",
          "",
          "    builder.patch(sparse_state_id, initial_state_id).unwrap(); // This should panic",
          "    builder.patch(sparse_state_id, initial_state_id).unwrap(); // Expected to panic due to patching a sparse state",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]