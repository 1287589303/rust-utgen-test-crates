[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"foo\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "}"
        ],
        "oracle": [
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"foo\");",
          "    assert!(seq.literals().unwrap()[0].is_inexact());",
          "    assert!(!seq.literals().unwrap()[0].is_exact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"foo\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"foo\");",
          "    assert!(seq.literals().unwrap()[0].is_inexact());",
          "    assert!(!seq.literals().unwrap()[0].is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"bar\"),",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"bar\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\"), Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals().unwrap().len(), 2);"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"bar\"),",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"bar\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\"), Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"foo\"), Literal::inexact(b\"bar\")]));",
          "    seq.dedup();",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"bar\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "}"
        ],
        "oracle": [
          "    assert!(seq.literals.as_ref().unwrap().len() == 2);",
          "    assert_eq!(seq.literals.as_ref().unwrap()[0].as_bytes(), b\"foo\");",
          "    assert_eq!(seq.literals.as_ref().unwrap()[1].as_bytes(), b\"bar\");",
          "    assert!(seq.literals.as_ref().unwrap()[0].is_exact());",
          "    assert!(seq.literals.as_ref().unwrap()[1].is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "            Literal::inexact(b\"bar\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "    assert!(seq.literals.as_ref().unwrap().len() == 2);",
          "    assert_eq!(seq.literals.as_ref().unwrap()[0].as_bytes(), b\"foo\");",
          "    assert_eq!(seq.literals.as_ref().unwrap()[1].as_bytes(), b\"bar\");",
          "    assert!(seq.literals.as_ref().unwrap()[0].is_exact());",
          "    assert!(seq.literals.as_ref().unwrap()[1].is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![]),",
          "    };",
          "    seq.dedup();",
          "}"
        ],
        "oracle": [
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"a\"),",
          "    Literal::exact(\"a\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"a\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::inexact(\"b\"),",
          "    Literal::inexact(\"b\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"b\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"c\"),",
          "    Literal::inexact(\"c\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"c\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"d\"),",
          "    Literal::exact(\"e\"),",
          "    Literal::inexact(\"e\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"d\"), Literal::inexact(\"e\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::inexact(\"f\"),",
          "    Literal::exact(\"f\"),",
          "    Literal::exact(\"g\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"f\"), Literal::exact(\"g\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"h\"),",
          "    Literal::inexact(\"i\"),",
          "    Literal::inexact(\"i\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"h\"), Literal::inexact(\"i\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::inexact(\"j\"),",
          "    Literal::exact(\"j\"),",
          "    Literal::exact(\"j\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"j\")]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![]),",
          "    };",
          "    seq.dedup();",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"a\"),",
          "    Literal::exact(\"a\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"a\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::inexact(\"b\"),",
          "    Literal::inexact(\"b\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"b\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"c\"),",
          "    Literal::inexact(\"c\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"c\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"d\"),",
          "    Literal::exact(\"e\"),",
          "    Literal::inexact(\"e\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"d\"), Literal::inexact(\"e\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::inexact(\"f\"),",
          "    Literal::exact(\"f\"),",
          "    Literal::exact(\"g\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"f\"), Literal::exact(\"g\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::exact(\"h\"),",
          "    Literal::inexact(\"i\"),",
          "    Literal::inexact(\"i\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"h\"), Literal::inexact(\"i\")]));",
          "    ",
          "    let mut seq = Seq {",
          "    literals: Some(vec![",
          "    Literal::inexact(\"j\"),",
          "    Literal::exact(\"j\"),",
          "    Literal::exact(\"j\"),",
          "    ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"j\")]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"foo\");",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(!seq.literals().unwrap()[0].is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"foo\"),",
          "        ]),",
          "    };",
          "    seq.dedup();",
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"foo\");",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(!seq.literals().unwrap()[0].is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::infinite();",
          "    seq.dedup();",
          "}"
        ],
        "oracle": [
          "    assert!(seq.is_finite());",
          "    assert_eq!(None, seq.literals());",
          "    ",
          "    let mut seq = Seq::singleton(Literal::exact(\"test\"));",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::exact(\"test\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::exact(\"test\"), Literal::exact(\"test\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::exact(\"test\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::exact(\"foo\"), Literal::inexact(\"foo\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::inexact(\"foo\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::inexact(\"bar\"), Literal::exact(\"bar\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::inexact(\"bar\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::exact(\"foo\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::exact(\"foo\"), Literal::exact(\"bar\")]), seq.literals().map(|v| v.to_vec()));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::infinite();",
          "    seq.dedup();",
          "    assert!(seq.is_finite());",
          "    assert_eq!(None, seq.literals());",
          "    ",
          "    let mut seq = Seq::singleton(Literal::exact(\"test\"));",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::exact(\"test\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::exact(\"test\"), Literal::exact(\"test\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::exact(\"test\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::exact(\"foo\"), Literal::inexact(\"foo\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::inexact(\"foo\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::inexact(\"bar\"), Literal::exact(\"bar\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::inexact(\"bar\")]), seq.literals().map(|v| v.to_vec()));",
          "    ",
          "    let mut seq = Seq::new(vec![Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::exact(\"foo\")]);",
          "    seq.dedup();",
          "    assert_eq!(Some(vec![Literal::exact(\"foo\"), Literal::exact(\"bar\")]), seq.literals().map(|v| v.to_vec()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]