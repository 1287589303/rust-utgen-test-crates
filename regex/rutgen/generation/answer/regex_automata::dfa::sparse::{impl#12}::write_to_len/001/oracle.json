[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    ",
          "    let table = vec![0u8; 100]; // arbitrary length <= 1024",
          "    let stride = 4; // arbitrary value <= 8",
          "    let pattern_len = Some(2); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 100];",
          "    let stride = 4;",
          "    let pattern_len = Some(2);",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: None, universal_start_anchored: None };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 200];",
          "    let stride = 6;",
          "    let pattern_len = Some(3);",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: Some(0), universal_start_anchored: None };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 512];",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: None, universal_start_anchored: Some(1) };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 1024];",
          "    let stride = 2;",
          "    let pattern_len = Some(0);",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: Some(2), universal_start_anchored: Some(3) };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    ",
          "    let table = vec![0u8; 100]; // arbitrary length <= 1024",
          "    let stride = 4; // arbitrary value <= 8",
          "    let pattern_len = Some(2); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 100];",
          "    let stride = 4;",
          "    let pattern_len = Some(2);",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: None, universal_start_anchored: None };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 200];",
          "    let stride = 6;",
          "    let pattern_len = Some(3);",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: Some(0), universal_start_anchored: None };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 512];",
          "    let stride = 8;",
          "    let pattern_len = None;",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: None, universal_start_anchored: Some(1) };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 1024];",
          "    let stride = 2;",
          "    let pattern_len = Some(0);",
          "    let start_table = StartTable { table, kind, start_map, stride, pattern_len, universal_start_unanchored: Some(2), universal_start_anchored: Some(3) };",
          "    assert_eq!(start_table.write_to_len(), start_table.kind.write_to_len() + start_table.start_map.write_to_len() + size_of::<u32>() * 4 + start_table.table().len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![0u8; 200]; // arbitrary length <= 1024",
          "    let stride = 2; // arbitrary value <= 8",
          "    let pattern_len = Some(1); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: Some(StateID(SmallIndex::from(0))),",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(start_table.write_to_len(), kind.write_to_len() + start_map.write_to_len() + size_of::<u32>() + size_of::<u32>() + size_of::<u32>() + size_of::<u32>() + start_table.table().len());"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![0u8; 200]; // arbitrary length <= 1024",
          "    let stride = 2; // arbitrary value <= 8",
          "    let pattern_len = Some(1); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: Some(StateID(SmallIndex::from(0))),",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "    assert_eq!(start_table.write_to_len(), kind.write_to_len() + start_map.write_to_len() + size_of::<u32>() + size_of::<u32>() + size_of::<u32>() + size_of::<u32>() + start_table.table().len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![0u8; 50]; // arbitrary length <= 1024",
          "    let stride = 1; // arbitrary value <= 8",
          "    let pattern_len = Some(3); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: Some(StateID(SmallIndex::from(1))),",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 50]; // arbitrary length <= 1024",
          "    let stride = 1; // arbitrary value <= 8",
          "    let pattern_len = Some(3); // arbitrary value >= 0",
          "    let expected_length = kind.write_to_len() + start_map.write_to_len()",
          "    + size_of::<u32>()",
          "    + size_of::<u32>()",
          "    + size_of::<u32>()",
          "    + size_of::<u32>()",
          "    + table.len();",
          "    assert_eq!(start_table.write_to_len(), expected_length);"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![0u8; 50]; // arbitrary length <= 1024",
          "    let stride = 1; // arbitrary value <= 8",
          "    let pattern_len = Some(3); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: Some(StateID(SmallIndex::from(1))),",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "    let table = vec![0u8; 50]; // arbitrary length <= 1024",
          "    let stride = 1; // arbitrary value <= 8",
          "    let pattern_len = Some(3); // arbitrary value >= 0",
          "    let expected_length = kind.write_to_len() + start_map.write_to_len()",
          "    + size_of::<u32>()",
          "    + size_of::<u32>()",
          "    + size_of::<u32>()",
          "    + size_of::<u32>()",
          "    + table.len();",
          "    assert_eq!(start_table.write_to_len(), expected_length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![]; // empty table",
          "    let stride = 0; // arbitrary value <= 8",
          "    let pattern_len = None; // None value",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    let kind_length = StartKind::Both.write_to_len();",
          "    let start_map_length = StartByteMap::new(&LookMatcher {}).write_to_len();",
          "    let expected_length = kind_length + start_map_length + size_of::<u32>() * 4 + 0;",
          "    assert_eq!(start_table.write_to_len(), expected_length);",
          "    assert_eq!(start_table.write_to_len(), kind_length + start_map_length + size_of::<u32>() * 6);",
          "    assert!(start_table.write_to_len() >= 0);",
          "    assert!(start_table.write_to_len() < 64);"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![]; // empty table",
          "    let stride = 0; // arbitrary value <= 8",
          "    let pattern_len = None; // None value",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "    let kind_length = StartKind::Both.write_to_len();",
          "    let start_map_length = StartByteMap::new(&LookMatcher {}).write_to_len();",
          "    let expected_length = kind_length + start_map_length + size_of::<u32>() * 4 + 0;",
          "    assert_eq!(start_table.write_to_len(), expected_length);",
          "    assert_eq!(start_table.write_to_len(), kind_length + start_map_length + size_of::<u32>() * 6);",
          "    assert!(start_table.write_to_len() >= 0);",
          "    assert!(start_table.write_to_len() < 64);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![0u8; 1024]; // maximum length",
          "    let stride = 8; // maximum value <= 8",
          "    let pattern_len = Some(4); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: Some(StateID(SmallIndex::from(2))),",
          "        universal_start_anchored: Some(StateID(SmallIndex::from(3))),",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    let kind_len = StartKind::Both.write_to_len();",
          "    let start_map_len = StartByteMap::new(&LookMatcher {}).write_to_len();",
          "    let stride_size = size_of::<u32>();",
          "    let pattern_size = size_of::<u32>();",
          "    let univers_unanchored_size = size_of::<u32>();",
          "    let univers_anchored_size = size_of::<u32>();",
          "    let table_len = 1024;",
          "    ",
          "    let expected_length = kind_len + start_map_len + stride_size + pattern_size + univers_unanchored_size + univers_anchored_size + table_len;",
          "    ",
          "    assert_eq!(start_table.write_to_len(), expected_length);"
        ],
        "code": [
          "{",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap::new(&LookMatcher {});",
          "",
          "    let table = vec![0u8; 1024]; // maximum length",
          "    let stride = 8; // maximum value <= 8",
          "    let pattern_len = Some(4); // arbitrary value >= 0",
          "",
          "    let start_table = StartTable {",
          "        table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored: Some(StateID(SmallIndex::from(2))),",
          "        universal_start_anchored: Some(StateID(SmallIndex::from(3))),",
          "    };",
          "",
          "    let _ = start_table.write_to_len();",
          "    let kind_len = StartKind::Both.write_to_len();",
          "    let start_map_len = StartByteMap::new(&LookMatcher {}).write_to_len();",
          "    let stride_size = size_of::<u32>();",
          "    let pattern_size = size_of::<u32>();",
          "    let univers_unanchored_size = size_of::<u32>();",
          "    let univers_anchored_size = size_of::<u32>();",
          "    let table_len = 1024;",
          "    ",
          "    let expected_length = kind_len + start_map_len + stride_size + pattern_size + univers_unanchored_size + univers_anchored_size + table_len;",
          "    ",
          "    assert_eq!(start_table.write_to_len(), expected_length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]