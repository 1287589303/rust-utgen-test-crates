[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 0; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "    assert_eq!(*pool.owner_val.get(), None);",
          "    assert_eq!(pool.owner.load(Ordering::Acquire), THREAD_ID_UNOWNED);",
          "    assert!(pool.get_slow(caller, owner).value.is_some());",
          "    assert!(pool.owner.load(Ordering::Acquire) == THREAD_ID_INUSE);",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 0; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "    assert_eq!(*pool.owner_val.get(), None);",
          "    assert_eq!(pool.owner.load(Ordering::Acquire), THREAD_ID_UNOWNED);",
          "    assert!(pool.get_slow(caller, owner).value.is_some());",
          "    assert!(pool.owner.load(Ordering::Acquire) == THREAD_ID_INUSE);",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 1; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "    assert!(pool.owner.load(Ordering::Acquire) == THREAD_ID_UNOWNED);",
          "    assert!(owner == THREAD_ID_UNOWNED);",
          "    assert!(_guard.value.is_some());",
          "    assert_eq!(*_guard.value.as_ref().unwrap(), ExampleType);",
          "    assert!(pool.owner.load(Ordering::Acquire) == THREAD_ID_INUSE);",
          "    assert!(pool.stack.lock().unwrap().len() == 0);"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 1; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "    assert!(pool.owner.load(Ordering::Acquire) == THREAD_ID_UNOWNED);",
          "    assert!(owner == THREAD_ID_UNOWNED);",
          "    assert!(_guard.value.is_some());",
          "    assert_eq!(*_guard.value.as_ref().unwrap(), ExampleType);",
          "    assert!(pool.owner.load(Ordering::Acquire) == THREAD_ID_INUSE);",
          "    assert!(pool.stack.lock().unwrap().len() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 2; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(COUNTER.load(Ordering::SeqCst), 3);",
          "    assert!(pool.stack.lock().unwrap().is_empty());",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_UNOWNED);",
          "    assert!(_guard.value.is_some());",
          "    assert!(matches!(_guard.value.as_ref().unwrap().as_ref(), &ExampleType));",
          "    assert_eq!(owner, THREAD_ID_UNOWNED);",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_INUSE);"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 2; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(COUNTER.load(Ordering::SeqCst), 3);",
          "    assert!(pool.stack.lock().unwrap().is_empty());",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_UNOWNED);",
          "    assert!(_guard.value.is_some());",
          "    assert!(matches!(_guard.value.as_ref().unwrap().as_ref(), &ExampleType));",
          "    assert_eq!(owner, THREAD_ID_UNOWNED);",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_INUSE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 3; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(COUNTER.load(Ordering::SeqCst), 3);",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_INUSE);",
          "    assert!(pool.owner_val.get().is_some());",
          "    assert!(std::mem::size_of::<ExampleType>() > 0);",
          "    assert!(std::thread::panicking() == false);"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 3; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(COUNTER.load(Ordering::SeqCst), 3);",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_INUSE);",
          "    assert!(pool.owner_val.get().is_some());",
          "    assert!(std::mem::size_of::<ExampleType>() > 0);",
          "    assert!(std::thread::panicking() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 4; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(owner, THREAD_ID_UNOWNED);",
          "    assert!(pool.stack.locked.load(Ordering::SeqCst) == false);",
          "    assert!(pool.get_slow(caller, owner).value.is_some());",
          "    assert!(pool.stack.locked.load(Ordering::SeqCst) == true);",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_INUSE);",
          "    assert!(pool.owner_val.get().is_some());"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 4; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(owner, THREAD_ID_UNOWNED);",
          "    assert!(pool.stack.locked.load(Ordering::SeqCst) == false);",
          "    assert!(pool.get_slow(caller, owner).value.is_some());",
          "    assert!(pool.stack.locked.load(Ordering::SeqCst) == true);",
          "    assert!(pool.owner.load(Ordering::SeqCst) == THREAD_ID_INUSE);",
          "    assert!(pool.owner_val.get().is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 5; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pool.owner.load(Ordering::Acquire), THREAD_ID_INUSE);",
          "    assert!(pool.stack.lock().unwrap().is_empty());",
          "    assert!(pool.owner_val.get().is_some());",
          "    assert_eq!(pool.stacks.len(), MAX_POOL_STACKS);",
          "    assert!(matches!(_guard.value, Some(_)));"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 5; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(pool.owner.load(Ordering::Acquire), THREAD_ID_INUSE);",
          "    assert!(pool.stack.lock().unwrap().is_empty());",
          "    assert!(pool.owner_val.get().is_some());",
          "    assert_eq!(pool.stacks.len(), MAX_POOL_STACKS);",
          "    assert!(matches!(_guard.value, Some(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 6; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_guard.pool, &pool);",
          "    assert!(matches!(_guard.value, Some(_)));",
          "    assert!(owner == THREAD_ID_UNOWNED);",
          "    assert_ne!(_guard.pool.owner, THREAD_ID_UNOWNED);",
          "    assert!(_guard.pool.owner.is_in_use());",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 6; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(_guard.pool, &pool);",
          "    assert!(matches!(_guard.value, Some(_)));",
          "    assert!(owner == THREAD_ID_UNOWNED);",
          "    assert_ne!(_guard.pool.owner, THREAD_ID_UNOWNED);",
          "    assert!(_guard.pool.owner.is_in_use());",
          "    assert_eq!(pool.stack.lock().unwrap().len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 7; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "}"
        ],
        "oracle": [
          "    let pool: Pool<ExampleType, _> = Pool { stack: Mutex::new(vec![]), create: create_fn };",
          "    let caller = 7;",
          "    let owner = THREAD_ID_UNOWNED;",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(pool.stack.locked, false);",
          "    assert!(pool.owner.compare_exchange(THREAD_ID_UNOWNED, THREAD_ID_INUSE, Ordering::AcqRel, Ordering::Acquire).is_ok());",
          "    assert!(unsafe { *pool.owner_val.get() }.is_some());",
          "    assert!(matches!(_guard.value, Ok(_)));",
          "    assert_eq!(_guard.pool, &pool);",
          "    assert_eq!(pool.stack.locked, true);",
          "    assert_eq!(pool.owner.load(Ordering::SeqCst), THREAD_ID_INUSE);",
          "    assert!(pool.stack.data.get().is_empty());"
        ],
        "code": [
          "{",
          "    struct ExampleType;",
          "",
          "    let create_fn = || ExampleType;",
          "",
          "    let pool: Pool<ExampleType, _> = Pool {",
          "        stack: Mutex::new(vec![]),",
          "        create: create_fn,",
          "    };",
          "",
          "    let caller = 7; // THREAD_ID_UNOWNED",
          "    let owner = THREAD_ID_UNOWNED;",
          "",
          "    let _guard = pool.get_slow(caller, owner);",
          "    let pool: Pool<ExampleType, _> = Pool { stack: Mutex::new(vec![]), create: create_fn };",
          "    let caller = 7;",
          "    let owner = THREAD_ID_UNOWNED;",
          "    let _guard = pool.get_slow(caller, owner);",
          "    assert_eq!(pool.stack.locked, false);",
          "    assert!(pool.owner.compare_exchange(THREAD_ID_UNOWNED, THREAD_ID_INUSE, Ordering::AcqRel, Ordering::Acquire).is_ok());",
          "    assert!(unsafe { *pool.owner_val.get() }.is_some());",
          "    assert!(matches!(_guard.value, Ok(_)));",
          "    assert_eq!(_guard.pool, &pool);",
          "    assert_eq!(pool.stack.locked, true);",
          "    assert_eq!(pool.owner.load(Ordering::SeqCst), THREAD_ID_INUSE);",
          "    assert!(pool.stack.data.get().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]