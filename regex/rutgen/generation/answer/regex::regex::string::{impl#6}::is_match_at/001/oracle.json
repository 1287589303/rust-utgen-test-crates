[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, 0);",
          "}"
        ],
        "oracle": [
          "    assert!(re.is_match_at(hay, 0)); // Expected: true, match at start",
          "    assert!(re.is_match_at(hay, 2)); // Expected: false, no match due to context",
          "    assert!(!re.is_match_at(hay, hay.len())); // Expected: false, start at end of haystack",
          "    assert!(re.is_match_at(hay, 1)); // Expected: false, context prevents match",
          "    assert!(re.is_match_at(\"\", 0)); // Expected: false, empty string haystack",
          "    assert!(re.is_match_at(\"chew\", 0)); // Expected: true, exact match at start",
          "    assert!(re.is_match_at(\"eschew\", 0)); // Expected: true, match at start",
          "    assert!(re.is_match_at(\"chewy\", 0)); // Expected: false, ends with additional character"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, 0);",
          "    assert!(re.is_match_at(hay, 0)); // Expected: true, match at start",
          "    assert!(re.is_match_at(hay, 2)); // Expected: false, no match due to context",
          "    assert!(!re.is_match_at(hay, hay.len())); // Expected: false, start at end of haystack",
          "    assert!(re.is_match_at(hay, 1)); // Expected: false, context prevents match",
          "    assert!(re.is_match_at(\"\", 0)); // Expected: false, empty string haystack",
          "    assert!(re.is_match_at(\"chew\", 0)); // Expected: true, exact match at start",
          "    assert!(re.is_match_at(\"eschew\", 0)); // Expected: true, match at start",
          "    assert!(re.is_match_at(\"chewy\", 0)); // Expected: false, ends with additional character",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, 1);",
          "}"
        ],
        "oracle": [
          "    assert!(re.is_match_at(hay, 1)); // should return true, as 'chew' is present starting at index 1",
          "    assert!(!re.is_match_at(hay, 2)); // should return false, as 'chew' does not match when looking at the context starting at index 2",
          "    assert!(!re.is_match_at(hay, 3)); // should return false, as 'chew' does not match starting at index 3",
          "    assert!(!re.is_match_at(hay, 4)); // should return false, as 'chew' does not match starting at index 4",
          "    assert!(!re.is_match_at(hay, 5)); // should return false, as 'chew' does not match starting at index 5",
          "    assert!(re.is_match_at(hay, 0)); // should return false, as 'chew' does not match at the start of the haystack",
          "    assert!(re.is_match_at(\"\", 0)); // should return false, as haystack is empty",
          "    assert!(re.is_match_at(hay, hay.len())); // should panic, as start index is equal to haystack length",
          "    assert!(re.is_match_at(hay, hay.len() + 1)); // should panic, as start index exceeds haystack length"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, 1);",
          "    assert!(re.is_match_at(hay, 1)); // should return true, as 'chew' is present starting at index 1",
          "    assert!(!re.is_match_at(hay, 2)); // should return false, as 'chew' does not match when looking at the context starting at index 2",
          "    assert!(!re.is_match_at(hay, 3)); // should return false, as 'chew' does not match starting at index 3",
          "    assert!(!re.is_match_at(hay, 4)); // should return false, as 'chew' does not match starting at index 4",
          "    assert!(!re.is_match_at(hay, 5)); // should return false, as 'chew' does not match starting at index 5",
          "    assert!(re.is_match_at(hay, 0)); // should return false, as 'chew' does not match at the start of the haystack",
          "    assert!(re.is_match_at(\"\", 0)); // should return false, as haystack is empty",
          "    assert!(re.is_match_at(hay, hay.len())); // should panic, as start index is equal to haystack length",
          "    assert!(re.is_match_at(hay, hay.len() + 1)); // should panic, as start index exceeds haystack length",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, 2);",
          "}"
        ],
        "oracle": [
          "    assert!(re.is_match_at(hay, 0));",
          "    assert!(re.is_match_at(hay, 1));",
          "    assert!(re.is_match_at(hay, 2));",
          "    assert!(!re.is_match_at(hay, 3));",
          "    assert!(!re.is_match_at(hay, 4));",
          "    assert!(!re.is_match_at(hay, 5));",
          "    assert!(re.is_match_at(hay, 6));",
          "    assert!(!re.is_match_at(\"\", 0));",
          "    assert!(panic::catch_unwind(|| re.is_match_at(hay, hay.len() + 1)).is_err());",
          "    assert_eq!(re.is_match_at(hay, hay.len()), false);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, 2);",
          "    assert!(re.is_match_at(hay, 0));",
          "    assert!(re.is_match_at(hay, 1));",
          "    assert!(re.is_match_at(hay, 2));",
          "    assert!(!re.is_match_at(hay, 3));",
          "    assert!(!re.is_match_at(hay, 4));",
          "    assert!(!re.is_match_at(hay, 5));",
          "    assert!(re.is_match_at(hay, 6));",
          "    assert!(!re.is_match_at(\"\", 0));",
          "    assert!(panic::catch_unwind(|| re.is_match_at(hay, hay.len() + 1)).is_err());",
          "    assert_eq!(re.is_match_at(hay, hay.len()), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\bch\").unwrap();",
          "    let hay = \"chocolate\";",
          "    re.is_match_at(hay, hay.len());",
          "}"
        ],
        "oracle": [
          "    assert!(!re.is_match_at(hay, hay.len()));"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\bch\").unwrap();",
          "    let hay = \"chocolate\";",
          "    re.is_match_at(hay, hay.len());",
          "    assert!(!re.is_match_at(hay, hay.len()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, hay.len() + 1);",
          "}"
        ],
        "oracle": [
          "    assert!(re.is_match_at(hay, 0));",
          "    assert!(re.is_match_at(hay, 2));",
          "    assert!(!re.is_match_at(hay, 1));",
          "    assert!(!re.is_match_at(hay, hay.len()));",
          "    assert!(!re.is_match_at(hay, hay.len() + 1));",
          "    assert!(!re.is_match_at(\"\", 0));",
          "    assert!(!re.is_match_at(\"chew\", 1));",
          "    assert!(re.is_match_at(\"chew chew\", 0));",
          "    assert!(re.is_match_at(\"chew chew\", 5));",
          "    assert!(!re.is_match_at(\"chewy\", 0));"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\bchew\\b\").unwrap();",
          "    let hay = \"eschew\";",
          "    re.is_match_at(hay, hay.len() + 1);",
          "    assert!(re.is_match_at(hay, 0));",
          "    assert!(re.is_match_at(hay, 2));",
          "    assert!(!re.is_match_at(hay, 1));",
          "    assert!(!re.is_match_at(hay, hay.len()));",
          "    assert!(!re.is_match_at(hay, hay.len() + 1));",
          "    assert!(!re.is_match_at(\"\", 0));",
          "    assert!(!re.is_match_at(\"chew\", 1));",
          "    assert!(re.is_match_at(\"chew chew\", 0));",
          "    assert!(re.is_match_at(\"chew chew\", 5));",
          "    assert!(!re.is_match_at(\"chewy\", 0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]