[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::default();",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        expressions: vec![",
          "            Ast::Literal(Box::new(Literal { span: Span::new(0, 1), c: 'a' })),",
          "            Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::new(1, 2), negated: false, kind: ClassUnicodeKind::OneLetter('L') })),",
          "        ],",
          "    }));",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"a[L]\");",
          "    visitor.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(visitor.pop_concat_expr().is_some(), true);",
          "    assert_eq!(visitor.pop_alt_expr().is_some(), true);",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Concat(_)));",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Class(_)));",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Literal(_)));",
          "    assert!(visitor.pop_concat_expr().is_none());",
          "    assert!(visitor.trans().stack.borrow().is_empty());"
        ],
        "code": [
          "{",
          "    let mut translator = Translator::default();",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        expressions: vec![",
          "            Ast::Literal(Box::new(Literal { span: Span::new(0, 1), c: 'a' })),",
          "            Ast::ClassUnicode(Box::new(ClassUnicode { span: Span::new(1, 2), negated: false, kind: ClassUnicodeKind::OneLetter('L') })),",
          "        ],",
          "    }));",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"a[L]\");",
          "    visitor.visit_post(&ast).unwrap();",
          "    assert_eq!(visitor.pop_concat_expr().is_some(), true);",
          "    assert_eq!(visitor.pop_alt_expr().is_some(), true);",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Concat(_)));",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Class(_)));",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Literal(_)));",
          "    assert!(visitor.pop_concat_expr().is_none());",
          "    assert!(visitor.trans().stack.borrow().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::default();",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        expressions: vec![",
          "            Ast::Repetition(Box::new(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::new(1, 2), c: 'b' }))) })),",
          "            Ast::Alternation(Box::new(Alternation { expressions: vec![Ast::Literal(Box::new(Literal { span: Span::new(2, 3), c: 'c' }))] })),",
          "        ],",
          "    }));",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"b|c\");",
          "    visitor.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    let ast = Ast::Concat(Box::new(Concat { expressions: vec![Ast::Repetition(Box::new(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::new(1, 2), c: 'b' }))) })), Ast::Alternation(Box::new(Alternation { expressions: vec![Ast::Literal(Box::new(Literal { span: Span::new(2, 3), c: 'c' }))] }))], }));",
          "    ",
          "    let mut visitor = TranslatorI::new(&translator, \"b|c\");",
          "    visitor.visit_post(&ast).unwrap();",
          "    ",
          "    assert_eq!(visitor.trans().stack.borrow().len(), 1);",
          "    ",
          "    match visitor.pop() {",
          "    Some(HirFrame::Expr(hir)) => {",
          "    match hir.kind {",
          "    HirKind::Concat(ref exprs) => {",
          "    assert_eq!(exprs.len(), 2);",
          "    assert!(!matches!(*exprs[0].kind(), HirKind::Empty));",
          "    assert!(!matches!(*exprs[1].kind(), HirKind::Empty));",
          "    }",
          "    _ => panic!(\"Expected a Concatenation expression\"),",
          "    }",
          "    }",
          "    _ => panic!(\"Expected an expression in HirFrame\"),",
          "    }",
          "    ",
          "    assert!(visitor.pop_concat_expr().is_some());",
          "    ",
          "    let expr = visitor.pop_concat_expr().unwrap();",
          "    assert!(!matches!(*expr.kind(), HirKind::Empty));",
          "    ",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Empty));",
          "    ",
          "    let result = visitor.visit_post(&ast);",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let mut translator = Translator::default();",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        expressions: vec![",
          "            Ast::Repetition(Box::new(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::new(1, 2), c: 'b' }))) })),",
          "            Ast::Alternation(Box::new(Alternation { expressions: vec![Ast::Literal(Box::new(Literal { span: Span::new(2, 3), c: 'c' }))] })),",
          "        ],",
          "    }));",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"b|c\");",
          "    visitor.visit_post(&ast).unwrap();",
          "    let ast = Ast::Concat(Box::new(Concat { expressions: vec![Ast::Repetition(Box::new(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::new(1, 2), c: 'b' }))) })), Ast::Alternation(Box::new(Alternation { expressions: vec![Ast::Literal(Box::new(Literal { span: Span::new(2, 3), c: 'c' }))] }))], }));",
          "    ",
          "    let mut visitor = TranslatorI::new(&translator, \"b|c\");",
          "    visitor.visit_post(&ast).unwrap();",
          "    ",
          "    assert_eq!(visitor.trans().stack.borrow().len(), 1);",
          "    ",
          "    match visitor.pop() {",
          "    Some(HirFrame::Expr(hir)) => {",
          "    match hir.kind {",
          "    HirKind::Concat(ref exprs) => {",
          "    assert_eq!(exprs.len(), 2);",
          "    assert!(!matches!(*exprs[0].kind(), HirKind::Empty));",
          "    assert!(!matches!(*exprs[1].kind(), HirKind::Empty));",
          "    }",
          "    _ => panic!(\"Expected a Concatenation expression\"),",
          "    }",
          "    }",
          "    _ => panic!(\"Expected an expression in HirFrame\"),",
          "    }",
          "    ",
          "    assert!(visitor.pop_concat_expr().is_some());",
          "    ",
          "    let expr = visitor.pop_concat_expr().unwrap();",
          "    assert!(!matches!(*expr.kind(), HirKind::Empty));",
          "    ",
          "    assert!(matches!(*visitor.pop_concat_expr().unwrap().kind(), HirKind::Empty));",
          "    ",
          "    let result = visitor.visit_post(&ast);",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::default();",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        expressions: vec![",
          "            Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::new(0, 3), negated: false, kind: ClassSet::Normal })),",
          "            Ast::Repetition(Box::new(Repetition { span: Span::new(3, 5), op: RepetitionOp::OneOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::new(5, 6), c: 'd' }))) })),",
          "        ],",
          "    }));",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"[abc]d+\");",
          "    visitor.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    visitor.visit_post(&Ast::Concat(_));",
          "    let mut exprs = vec![];",
          "    while let Some(expr) = visitor.pop_concat_expr() {",
          "    assert!(!matches!(*expr.kind(), HirKind::Empty));",
          "    exprs.push(expr);",
          "    }",
          "    assert_eq!(exprs.len(), 2);",
          "    assert!(matches!(*exprs[0].kind(), HirKind::Class(Class::_)));",
          "    assert!(matches!(*exprs[1].kind(), HirKind::Repetition(_)));",
          "    assert!(visitor.stack.borrow().is_empty());",
          "    assert_eq!(visitor.finish().unwrap(), Ok(()));"
        ],
        "code": [
          "{",
          "    let mut translator = Translator::default();",
          "    let ast = Ast::Concat(Box::new(Concat {",
          "        expressions: vec![",
          "            Ast::ClassBracketed(Box::new(ClassBracketed { span: Span::new(0, 3), negated: false, kind: ClassSet::Normal })),",
          "            Ast::Repetition(Box::new(Repetition { span: Span::new(3, 5), op: RepetitionOp::OneOrMore, greedy: true, ast: Box::new(Ast::Literal(Box::new(Literal { span: Span::new(5, 6), c: 'd' }))) })),",
          "        ],",
          "    }));",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"[abc]d+\");",
          "    visitor.visit_post(&ast).unwrap();",
          "    visitor.visit_post(&Ast::Concat(_));",
          "    let mut exprs = vec![];",
          "    while let Some(expr) = visitor.pop_concat_expr() {",
          "    assert!(!matches!(*expr.kind(), HirKind::Empty));",
          "    exprs.push(expr);",
          "    }",
          "    assert_eq!(exprs.len(), 2);",
          "    assert!(matches!(*exprs[0].kind(), HirKind::Class(Class::_)));",
          "    assert!(matches!(*exprs[1].kind(), HirKind::Repetition(_)));",
          "    assert!(visitor.stack.borrow().is_empty());",
          "    assert_eq!(visitor.finish().unwrap(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]