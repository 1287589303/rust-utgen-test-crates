[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = ast::Literal { span: Span { start: Position(0), end: Position(1) }, c: 'a' };",
          "    let ast = Ast::Literal(Box::new(literal));",
          "    ",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags::default()),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut translator_i = TranslatorI::new(&translator, \"a\");",
          "    translator_i.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.push_char('a');",
          "    self.push_byte(0x61);",
          "    self.push(HirFrame::Expr(Hir::literal(vec![0x61])));",
          "    self.push(HirFrame::Expr(Hir::class(hir::Class::Bytes(cls))));",
          "    self.push(HirFrame::Expr(Hir::class(hir::Class::Unicode(cls))));",
          "    self.push(HirFrame::Expr(Hir::dot(hir::Dot::AnyChar)));",
          "    self.push(HirFrame::Expr(Hir::look(hir::Look::Start)));",
          "    self.push(HirFrame::Expr(Hir::look(hir::Look::End)));"
        ],
        "code": [
          "{",
          "    let literal = ast::Literal { span: Span { start: Position(0), end: Position(1) }, c: 'a' };",
          "    let ast = Ast::Literal(Box::new(literal));",
          "    ",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags::default()),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut translator_i = TranslatorI::new(&translator, \"a\");",
          "    translator_i.visit_post(&ast).unwrap();",
          "    self.push_char('a');",
          "    self.push_byte(0x61);",
          "    self.push(HirFrame::Expr(Hir::literal(vec![0x61])));",
          "    self.push(HirFrame::Expr(Hir::class(hir::Class::Bytes(cls))));",
          "    self.push(HirFrame::Expr(Hir::class(hir::Class::Unicode(cls))));",
          "    self.push(HirFrame::Expr(Hir::dot(hir::Dot::AnyChar)));",
          "    self.push(HirFrame::Expr(Hir::look(hir::Look::Start)));",
          "    self.push(HirFrame::Expr(Hir::look(hir::Look::End)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = ast::Literal { span: Span { start: Position(0), end: Position(1) }, c: 'A' };",
          "    let ast = Ast::Literal(Box::new(literal));",
          "    ",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: Some(true),",
          "            multi_line: Some(false),",
          "            dot_matches_new_line: Some(false),",
          "            swap_greed: Some(false),",
          "            unicode: Some(true),",
          "            crlf: Some(false),",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut translator_i = TranslatorI::new(&translator, \"A\");",
          "    translator_i.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
          "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Expr(_))));",
          "    assert!(translator_i.trans().stack.borrow().contains(&HirFrame::Expr(Hir::literal(vec![65])))); // 'A' as u8",
          "    assert!(translator_i.trans().flags.get().case_insensitive.unwrap());",
          "    assert!(translator_i.trans().flags.get().unicode.unwrap());",
          "    assert!(translator_i.trans().stack.borrow().len() > 0);",
          "    assert!(translator_i.trans().stack.borrow().iter().any(|frame| matches!(frame, HirFrame::Expr(expr) if expr.kind == HirKind::Literal(Literal { c: 'A', .. } ))));"
        ],
        "code": [
          "{",
          "    let literal = ast::Literal { span: Span { start: Position(0), end: Position(1) }, c: 'A' };",
          "    let ast = Ast::Literal(Box::new(literal));",
          "    ",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: Some(true),",
          "            multi_line: Some(false),",
          "            dot_matches_new_line: Some(false),",
          "            swap_greed: Some(false),",
          "            unicode: Some(true),",
          "            crlf: Some(false),",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut translator_i = TranslatorI::new(&translator, \"A\");",
          "    translator_i.visit_post(&ast).unwrap();",
          "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
          "    assert!(matches!(translator_i.trans().stack.borrow().last(), Some(HirFrame::Expr(_))));",
          "    assert!(translator_i.trans().stack.borrow().contains(&HirFrame::Expr(Hir::literal(vec![65])))); // 'A' as u8",
          "    assert!(translator_i.trans().flags.get().case_insensitive.unwrap());",
          "    assert!(translator_i.trans().flags.get().unicode.unwrap());",
          "    assert!(translator_i.trans().stack.borrow().len() > 0);",
          "    assert!(translator_i.trans().stack.borrow().iter().any(|frame| matches!(frame, HirFrame::Expr(expr) if expr.kind == HirKind::Literal(Literal { c: 'A', .. } ))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]