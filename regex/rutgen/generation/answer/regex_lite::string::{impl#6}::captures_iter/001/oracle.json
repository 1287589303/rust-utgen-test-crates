[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939)\";",
          "    let captures = re.captures_iter(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.haystack, \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939)\");",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.next().is_some());",
          "    assert_eq!(captures.it.pikevm.nfa().group_len(), 2);",
          "    assert_eq!(captures.it.slots.len(), 4);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939)\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939)\");",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.next().is_some());",
          "    assert_eq!(captures.it.pikevm.nfa().group_len(), 2);",
          "    assert_eq!(captures.it.slots.len(), 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"No matches here.\";",
          "    let captures = re.captures_iter(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.haystack, \"No matches here.\");",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.next().is_none());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"No matches here.\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, \"No matches here.\");",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.next().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"\";",
          "    let captures = re.captures_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, \"\");",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.collect::<Vec<_>>().is_empty());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"\";",
          "    let captures = re.captures_iter(hay);",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, \"\");",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.collect::<Vec<_>>().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(\\w)\").unwrap();",
          "    let hay = \"A\";",
          "    let captures = re.captures_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"(\\w)\").unwrap();",
          "    let hay = \"A\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, hay);",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.next().is_some());",
          "    assert_eq!(captures.it.pikevm.nfa().group_len(), 2);",
          "    assert!(captures.it.slots.len() >= 2);",
          "    assert!(captures.it.last_match_end.is_none());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(\\w)\").unwrap();",
          "    let hay = \"A\";",
          "    let captures = re.captures_iter(hay);",
          "    let re = Regex::new(r\"(\\w)\").unwrap();",
          "    let hay = \"A\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, hay);",
          "    assert_eq!(captures.re, &re);",
          "    assert!(captures.it.next().is_some());",
          "    assert_eq!(captures.it.pikevm.nfa().group_len(), 2);",
          "    assert!(captures.it.slots.len() >= 2);",
          "    assert!(captures.it.last_match_end.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"'(?<title>[^']+)'\\s+\\((?<year>[0-9]{4})\\)\").unwrap();",
          "    let hay = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931)\";",
          "    let captures = re.captures_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"'(?<title>[^']+)'\\s+\\((?<year>[0-9]{4})\\)\").unwrap();",
          "    let hay = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931)\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, hay);",
          "    assert_eq!(captures.re, &re);",
          "    let expected_length = 3;",
          "    let match_iterator = captures.it;",
          "    assert_eq!(match_iterator.count(), expected_length);",
          "    let first_capture = match_iterator.next().unwrap();",
          "    assert_eq!(&first_capture[\"title\"], \"Citizen Kane\");",
          "    assert_eq!(&first_capture[\"year\"], \"1941\");",
          "    let second_capture = match_iterator.next().unwrap();",
          "    assert_eq!(&second_capture[\"title\"], \"The Wizard of Oz\");",
          "    assert_eq!(&second_capture[\"year\"], \"1939\");",
          "    let third_capture = match_iterator.next().unwrap();",
          "    assert_eq!(&third_capture[\"title\"], \"M\");",
          "    assert_eq!(&third_capture[\"year\"], \"1931\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"'(?<title>[^']+)'\\s+\\((?<year>[0-9]{4})\\)\").unwrap();",
          "    let hay = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931)\";",
          "    let captures = re.captures_iter(hay);",
          "    let re = Regex::new(r\"'(?<title>[^']+)'\\s+\\((?<year>[0-9]{4})\\)\").unwrap();",
          "    let hay = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931)\";",
          "    let captures = re.captures_iter(hay);",
          "    assert_eq!(captures.haystack, hay);",
          "    assert_eq!(captures.re, &re);",
          "    let expected_length = 3;",
          "    let match_iterator = captures.it;",
          "    assert_eq!(match_iterator.count(), expected_length);",
          "    let first_capture = match_iterator.next().unwrap();",
          "    assert_eq!(&first_capture[\"title\"], \"Citizen Kane\");",
          "    assert_eq!(&first_capture[\"year\"], \"1941\");",
          "    let second_capture = match_iterator.next().unwrap();",
          "    assert_eq!(&second_capture[\"title\"], \"The Wizard of Oz\");",
          "    assert_eq!(&second_capture[\"year\"], \"1939\");",
          "    let third_capture = match_iterator.next().unwrap();",
          "    assert_eq!(&third_capture[\"title\"], \"M\");",
          "    assert_eq!(&third_capture[\"year\"], \"1931\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"'A' (2000), 'B' (1999)\".repeat(1000); // Create a long haystack",
          "    let captures = re.captures_iter(&hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"'A' (2000), 'B' (1999)\".repeat(1000);",
          "    let captures = re.captures_iter(&hay);",
          "    assert_eq!(captures.haystack, &hay);",
          "    assert_eq!(captures.re, &re);",
          "    assert_eq!(captures.it, re.pikevm.captures_iter(re.pool.get(), hay.as_bytes()));"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"'A' (2000), 'B' (1999)\".repeat(1000); // Create a long haystack",
          "    let captures = re.captures_iter(&hay);",
          "    let re = Regex::new(r\"'([^']+)'\\s+\\(([0-9]{4})\\)\").unwrap();",
          "    let hay = \"'A' (2000), 'B' (1999)\".repeat(1000);",
          "    let captures = re.captures_iter(&hay);",
          "    assert_eq!(captures.haystack, &hay);",
          "    assert_eq!(captures.re, &re);",
          "    assert_eq!(captures.it, re.pikevm.captures_iter(re.pool.get(), hay.as_bytes()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]