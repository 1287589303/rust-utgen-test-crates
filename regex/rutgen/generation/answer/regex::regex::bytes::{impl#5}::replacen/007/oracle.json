[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\d+\").unwrap();",
          "    let haystack = b\"The year is 1973 and 1975.\";",
          "    let limit = 2;",
          "    let replacement = b\"NUM\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "}"
        ],
        "oracle": [
          "    let result = re.replacen(haystack, limit, replacement);",
          "    assert!(result.is_owned());",
          "    assert_eq!(result, Cow::Owned(b\"The year is NUM and NUM.\"));",
          "    assert!(result != Cow::Borrowed(haystack));",
          "    assert!(result.as_ref().len() < haystack.len());",
          "    assert!(result.as_ref().contains(&b'N'));",
          "    assert!(result.as_ref().contains(&b'U'));",
          "    assert!(result.as_ref().contains(&b'M'));",
          "    assert!(result.as_ref().contains(&b' '));",
          "    assert!(!result.as_ref().contains(&b'1'));",
          "    assert!(!result.as_ref().contains(&b'9'));"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\d+\").unwrap();",
          "    let haystack = b\"The year is 1973 and 1975.\";",
          "    let limit = 2;",
          "    let replacement = b\"NUM\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    assert!(result.is_owned());",
          "    assert_eq!(result, Cow::Owned(b\"The year is NUM and NUM.\"));",
          "    assert!(result != Cow::Borrowed(haystack));",
          "    assert!(result.as_ref().len() < haystack.len());",
          "    assert!(result.as_ref().contains(&b'N'));",
          "    assert!(result.as_ref().contains(&b'U'));",
          "    assert!(result.as_ref().contains(&b'M'));",
          "    assert!(result.as_ref().contains(&b' '));",
          "    assert!(!result.as_ref().contains(&b'1'));",
          "    assert!(!result.as_ref().contains(&b'9'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\d+\").unwrap();",
          "    let haystack = b\"Year: 2020, Year: 2021, Year: 2022\";",
          "    let limit = 3;",
          "    let replacement = b\"NUMBER\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(result, Cow::Owned(_)));",
          "    assert_eq!(result, Cow::Owned(b\"Year: NUMBER, Year: NUMBER, Year: 2022\".to_vec()));"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\d+\").unwrap();",
          "    let haystack = b\"Year: 2020, Year: 2021, Year: 2022\";",
          "    let limit = 3;",
          "    let replacement = b\"NUMBER\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    assert!(matches!(result, Cow::Owned(_)));",
          "    assert_eq!(result, Cow::Owned(b\"Year: NUMBER, Year: NUMBER, Year: 2022\".to_vec()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"[A-Za-z]+\").unwrap();",
          "    let haystack = b\"Just one match here.\";",
          "    let limit = 1;",
          "    let replacement = b\"MATCH\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(result, Cow::Owned(_)));",
          "    assert_eq!(result, Cow::Owned(b\"Just MATCH match here.\".to_vec()));"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"[A-Za-z]+\").unwrap();",
          "    let haystack = b\"Just one match here.\";",
          "    let limit = 1;",
          "    let replacement = b\"MATCH\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    assert!(matches!(result, Cow::Owned(_)));",
          "    assert_eq!(result, Cow::Owned(b\"Just MATCH match here.\".to_vec()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"[0-9]+\").unwrap();",
          "    let haystack = b\"No numbers found here.\";",
          "    let limit = 1;",
          "    let replacement = b\"NO_MATCH\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_owned());",
          "    assert_eq!(result, Cow::Owned(b\"No NO_MATCH numbers found here.\"[..]));",
          "    assert!(result.len() < haystack.len());",
          "    assert!(result.as_ref().contains(&b'NO_MATCH'[0]));",
          "    assert!(haystack.iter().any(|&b| b.is_ascii_digit()));",
          "    assert_eq!(result.as_ref().split(|&b| b == b' ').count(), 6);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"[0-9]+\").unwrap();",
          "    let haystack = b\"No numbers found here.\";",
          "    let limit = 1;",
          "    let replacement = b\"NO_MATCH\";",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    assert!(result.is_owned());",
          "    assert_eq!(result, Cow::Owned(b\"No NO_MATCH numbers found here.\"[..]));",
          "    assert!(result.len() < haystack.len());",
          "    assert!(result.as_ref().contains(&b'NO_MATCH'[0]));",
          "    assert!(haystack.iter().any(|&b| b.is_ascii_digit()));",
          "    assert_eq!(result.as_ref().split(|&b| b == b' ').count(), 6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]