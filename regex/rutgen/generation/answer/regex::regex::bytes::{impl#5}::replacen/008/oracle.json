[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let regex = Regex::new(r\"\\d+\").unwrap(); // Matches digits",
          "    let haystack: &[u8] = b\"123 456 789\";",
          "    let limit = 2;",
          "    let rep: &[u8] = b\"X\"; // Non-expansive replacement",
          "    ",
          "    let result = regex.replacen(haystack, limit, rep);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Cow::Owned(b\"X 456 789\".to_vec()));",
          "    assert_ne!(result, Cow::Borrowed(haystack));",
          "    assert!(result.as_ref().contains(&b'X'));",
          "    assert_eq!(result.len(), haystack.len() - 2 + 1);",
          "    assert!(!result.as_ref().contains(&b'1'));",
          "    assert!(!result.as_ref().contains(&b'2'));"
        ],
        "code": [
          "{",
          "    let regex = Regex::new(r\"\\d+\").unwrap(); // Matches digits",
          "    let haystack: &[u8] = b\"123 456 789\";",
          "    let limit = 2;",
          "    let rep: &[u8] = b\"X\"; // Non-expansive replacement",
          "    ",
          "    let result = regex.replacen(haystack, limit, rep);",
          "    assert_eq!(result, Cow::Owned(b\"X 456 789\".to_vec()));",
          "    assert_ne!(result, Cow::Borrowed(haystack));",
          "    assert!(result.as_ref().contains(&b'X'));",
          "    assert_eq!(result.len(), haystack.len() - 2 + 1);",
          "    assert!(!result.as_ref().contains(&b'1'));",
          "    assert!(!result.as_ref().contains(&b'2'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let regex = Regex::new(r\"[a-z]+\").unwrap(); // Matches lowercase words",
          "    let haystack: &[u8] = b\"hello world apple banana\";",
          "    let limit = 3;",
          "    let rep: &[u8] = b\"Z\"; // Non-expansive replacement",
          "    ",
          "    let result = regex.replacen(haystack, limit, rep);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Cow::Owned(b\"Z world Z Z banana\"[..]));",
          "    assert!(result.is_owned());",
          "    assert!(result.as_ref() != haystack);",
          "    assert_eq!(result.len(), 22);",
          "    assert!(result.iter().all(|&x| x != b'a' && x != b'e' && x != b'o'));",
          "    assert_eq!(result.get(0..1), Some(&b\"Z\"[..]));",
          "    assert_eq!(result.get(8..16), Some(&b\"world \"[..]));",
          "    assert_eq!(result.get(17..18), Some(&b\"Z\"[..]));",
          "    assert_eq!(result.get(19..22), Some(&b\"Z \"[..]));",
          "    assert_eq!(result.get(22..30), Some(&b\"banana\"[..]));"
        ],
        "code": [
          "{",
          "    let regex = Regex::new(r\"[a-z]+\").unwrap(); // Matches lowercase words",
          "    let haystack: &[u8] = b\"hello world apple banana\";",
          "    let limit = 3;",
          "    let rep: &[u8] = b\"Z\"; // Non-expansive replacement",
          "    ",
          "    let result = regex.replacen(haystack, limit, rep);",
          "    assert_eq!(result, Cow::Owned(b\"Z world Z Z banana\"[..]));",
          "    assert!(result.is_owned());",
          "    assert!(result.as_ref() != haystack);",
          "    assert_eq!(result.len(), 22);",
          "    assert!(result.iter().all(|&x| x != b'a' && x != b'e' && x != b'o'));",
          "    assert_eq!(result.get(0..1), Some(&b\"Z\"[..]));",
          "    assert_eq!(result.get(8..16), Some(&b\"world \"[..]));",
          "    assert_eq!(result.get(17..18), Some(&b\"Z\"[..]));",
          "    assert_eq!(result.get(19..22), Some(&b\"Z \"[..]));",
          "    assert_eq!(result.get(22..30), Some(&b\"banana\"[..]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let regex = Regex::new(r\"([a-z]+)\").unwrap(); // Matches lowercase words",
          "    let haystack: &[u8] = b\"test test test\";",
          "    let limit = 1;",
          "    let rep: &[u8] = b\"REPLACED\"; // Non-expansive replacement",
          "    ",
          "    let result = regex.replacen(haystack, limit, rep);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Cow::Owned(b\"REPLACED test test\"[..]));"
        ],
        "code": [
          "{",
          "    let regex = Regex::new(r\"([a-z]+)\").unwrap(); // Matches lowercase words",
          "    let haystack: &[u8] = b\"test test test\";",
          "    let limit = 1;",
          "    let rep: &[u8] = b\"REPLACED\"; // Non-expansive replacement",
          "    ",
          "    let result = regex.replacen(haystack, limit, rep);",
          "    assert_eq!(result, Cow::Owned(b\"REPLACED test test\"[..]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]