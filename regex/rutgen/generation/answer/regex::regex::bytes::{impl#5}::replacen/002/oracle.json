[
  {
    "uses": [
      "use alloc::borrow::Cow;",
      "use regex::bytes::Regex;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "    use alloc::borrow::Cow;",
          "",
          "    let re = Regex::new(r\"(?m)\\b(\\w+)\\b\").unwrap(); // Simple word boundary regex",
          "    let haystack = b\"apple banana apple orange apple\"; // Contains multiple matches for \"apple\"",
          "    let limit = 2; // Replace first 2 occurrences",
          "    let replacement = b\"fruit\"; // Replacement without capture expansions",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "}"
        ],
        "oracle": [
          "    let expected = Cow::Owned(b\"fruit banana fruit orange apple\"[..]);",
          "    assert_eq!(result, expected);",
          "    assert_eq!(result.as_ref().len(), haystack.len() - 3);",
          "    assert!(result.is_owned());",
          "    assert_eq!(result.as_bytes()[0..6], b\"fruit \");",
          "    assert_eq!(result.as_bytes()[7..13], b\"banana \");",
          "    assert_eq!(result.as_bytes()[14..20], b\"fruit \");"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "    use alloc::borrow::Cow;",
          "",
          "    let re = Regex::new(r\"(?m)\\b(\\w+)\\b\").unwrap(); // Simple word boundary regex",
          "    let haystack = b\"apple banana apple orange apple\"; // Contains multiple matches for \"apple\"",
          "    let limit = 2; // Replace first 2 occurrences",
          "    let replacement = b\"fruit\"; // Replacement without capture expansions",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    let expected = Cow::Owned(b\"fruit banana fruit orange apple\"[..]);",
          "    assert_eq!(result, expected);",
          "    assert_eq!(result.as_ref().len(), haystack.len() - 3);",
          "    assert!(result.is_owned());",
          "    assert_eq!(result.as_bytes()[0..6], b\"fruit \");",
          "    assert_eq!(result.as_bytes()[7..13], b\"banana \");",
          "    assert_eq!(result.as_bytes()[14..20], b\"fruit \");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "    use alloc::borrow::Cow;",
          "",
          "    let re = Regex::new(r\"(?m)grape\").unwrap(); // Regex that doesn't match the haystack",
          "    let haystack = b\"apple banana apple orange apple\"; // No \"grape\" present",
          "    let limit = 1; // Limited to 1",
          "    let replacement = b\"fruit\"; // Replacement without capture expansions",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(result, Cow::Owned(_)));",
          "    assert_eq!(result, &b\"apple banana apple orange apple\"[..]);",
          "    assert_ne!(result.len(), haystack.len());"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "    use alloc::borrow::Cow;",
          "",
          "    let re = Regex::new(r\"(?m)grape\").unwrap(); // Regex that doesn't match the haystack",
          "    let haystack = b\"apple banana apple orange apple\"; // No \"grape\" present",
          "    let limit = 1; // Limited to 1",
          "    let replacement = b\"fruit\"; // Replacement without capture expansions",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    assert!(matches!(result, Cow::Owned(_)));",
          "    assert_eq!(result, &b\"apple banana apple orange apple\"[..]);",
          "    assert_ne!(result.len(), haystack.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "    use alloc::borrow::Cow;",
          "",
          "    let re = Regex::new(r\"(?m)\\bapple\\b\").unwrap(); // Regex to match \"apple\"",
          "    let haystack = b\"apple banana apple orange apple\"; // Matches \"apple\" multiple times",
          "    let limit = 3; // Replace first 3 occurrences",
          "    let replacement = b\"fruit\"; // Replacement without capture expansions",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Cow::Owned(b\"fruit banana fruit orange fruit\"[..]));"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "    use alloc::borrow::Cow;",
          "",
          "    let re = Regex::new(r\"(?m)\\bapple\\b\").unwrap(); // Regex to match \"apple\"",
          "    let haystack = b\"apple banana apple orange apple\"; // Matches \"apple\" multiple times",
          "    let limit = 3; // Replace first 3 occurrences",
          "    let replacement = b\"fruit\"; // Replacement without capture expansions",
          "",
          "    let result = re.replacen(haystack, limit, replacement);",
          "    assert_eq!(result, Cow::Owned(b\"fruit banana fruit orange fruit\"[..]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]