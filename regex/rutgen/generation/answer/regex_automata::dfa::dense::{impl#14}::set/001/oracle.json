[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(1));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(2));",
          "    table.set(from, unit, to);",
          "}"
        ],
        "oracle": [
          "    assert!(table.is_valid(from), \"expected 'from' state to be valid\");",
          "    assert!(table.is_valid(to), \"expected 'to' state to be valid\");",
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(1));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(2));",
          "    table.set(from, unit, to);",
          "    assert!(table.is_valid(from), \"expected 'from' state to be valid\");",
          "    assert!(table.is_valid(to), \"expected 'to' state to be valid\");",
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(255));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(254));",
          "    table.set(from, unit, to);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());",
          "    assert!(table.is_valid(from));",
          "    assert!(table.is_valid(to));",
          "    assert_eq!(table.stride2, 1);",
          "    assert!(table.classes.is_singleton());"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(255));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(254));",
          "    table.set(from, unit, to);",
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());",
          "    assert!(table.is_valid(from));",
          "    assert!(table.is_valid(to));",
          "    assert_eq!(table.stride2, 1);",
          "    assert!(table.classes.is_singleton());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(1));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(1));",
          "    table.set(from, unit, to);",
          "}"
        ],
        "oracle": [
          "    assert!(table.is_valid(from));",
          "    assert!(table.is_valid(to));",
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(1));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(1));",
          "    table.set(from, unit, to);",
          "    assert!(table.is_valid(from));",
          "    assert!(table.is_valid(to));",
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(256)); // Invalid",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(1));",
          "    table.set(from, unit, to);",
          "}"
        ],
        "oracle": [
          "    assert!(self.is_valid(StateID(SmallIndex::from(256))), \"invalid 'from' state should be false\");",
          "    assert!(self.is_valid(StateID(SmallIndex::from(1))), \"valid 'to' state should be true\");",
          "    assert_panics!(table.set(StateID(SmallIndex::from(256)), alphabet::Unit::U8(0), StateID(SmallIndex::from(1))));"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(256)); // Invalid",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(1));",
          "    table.set(from, unit, to);",
          "    assert!(self.is_valid(StateID(SmallIndex::from(256))), \"invalid 'from' state should be false\");",
          "    assert!(self.is_valid(StateID(SmallIndex::from(1))), \"valid 'to' state should be true\");",
          "    assert_panics!(table.set(StateID(SmallIndex::from(256)), alphabet::Unit::U8(0), StateID(SmallIndex::from(1))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(1));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(256)); // Invalid",
          "    table.set(from, unit, to);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(table.is_valid(from), true);",
          "    assert_eq!(table.is_valid(to), false);",
          "    assert_panics!(table.set(from, unit, to));",
          "    assert_ne!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());",
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], 0);"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let mut table = TransitionTable {",
          "        table: vec![0; 256], // Initialized with size 256",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "    let from = StateID(SmallIndex::from(1));",
          "    let unit = alphabet::Unit::U8(0);",
          "    let to = StateID(SmallIndex::from(256)); // Invalid",
          "    table.set(from, unit, to);",
          "    assert_eq!(table.is_valid(from), true);",
          "    assert_eq!(table.is_valid(to), false);",
          "    assert_panics!(table.set(from, unit, to));",
          "    assert_ne!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], to.as_u32());",
          "    assert_eq!(table.table[from.as_usize() + table.classes.get_by_unit(unit)], 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]