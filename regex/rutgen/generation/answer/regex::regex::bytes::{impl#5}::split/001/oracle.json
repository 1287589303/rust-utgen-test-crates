[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"Mary had a little lamb\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"Mary\"[..], &b\"had\"[..], &b\"a\"[..], &b\"little\"[..], &b\"lamb\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"X\").unwrap();",
          "    let hay_empty = b\"\";",
          "    let split_empty = re_empty.split(hay_empty);",
          "    assert_eq!(split_empty.haystack, hay_empty);",
          "    assert_eq!(split_empty.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..]]);",
          "    ",
          "    let re_multiple = Regex::new(r\"X\").unwrap();",
          "    let hay_multiple = b\"lionXXtigerXleopard\";",
          "    let split_multiple = re_multiple.split(hay_multiple);",
          "    assert_eq!(split_multiple.haystack, hay_multiple);",
          "    assert_eq!(split_multiple.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_double_colon = Regex::new(r\"::\").unwrap();",
          "    let hay_double_colon = b\"lion::tiger::leopard\";",
          "    let split_double_colon = re_double_colon.split(hay_double_colon);",
          "    assert_eq!(split_double_colon.haystack, hay_double_colon);",
          "    assert_eq!(split_double_colon.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_spaces = Regex::new(r\" \").unwrap();",
          "    let hay_spaces = b\"    a  b c\";",
          "    let split_spaces = re_spaces.split(hay_spaces);",
          "    assert_eq!(split_spaces.haystack, hay_spaces);",
          "    assert_eq!(split_spaces.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_space_plus = Regex::new(r\" +\").unwrap();",
          "    let hay_space_plus = b\"    a  b c\";",
          "    let split_space_plus = re_space_plus.split(hay_space_plus);",
          "    assert_eq!(split_space_plus.haystack, hay_space_plus);",
          "    assert_eq!(split_space_plus.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty_string = Regex::new(r\"\").unwrap();",
          "    let hay_empty_string = \"笘ソ".as_bytes();",
          "    let split_empty_string = re_empty_string.split(hay_empty_string);",
          "    assert_eq!(split_empty_string.haystack, hay_empty_string);",
          "    assert_eq!(split_empty_string.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"Mary had a little lamb\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"Mary\"[..], &b\"had\"[..], &b\"a\"[..], &b\"little\"[..], &b\"lamb\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"X\").unwrap();",
          "    let hay_empty = b\"\";",
          "    let split_empty = re_empty.split(hay_empty);",
          "    assert_eq!(split_empty.haystack, hay_empty);",
          "    assert_eq!(split_empty.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..]]);",
          "    ",
          "    let re_multiple = Regex::new(r\"X\").unwrap();",
          "    let hay_multiple = b\"lionXXtigerXleopard\";",
          "    let split_multiple = re_multiple.split(hay_multiple);",
          "    assert_eq!(split_multiple.haystack, hay_multiple);",
          "    assert_eq!(split_multiple.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_double_colon = Regex::new(r\"::\").unwrap();",
          "    let hay_double_colon = b\"lion::tiger::leopard\";",
          "    let split_double_colon = re_double_colon.split(hay_double_colon);",
          "    assert_eq!(split_double_colon.haystack, hay_double_colon);",
          "    assert_eq!(split_double_colon.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_spaces = Regex::new(r\" \").unwrap();",
          "    let hay_spaces = b\"    a  b c\";",
          "    let split_spaces = re_spaces.split(hay_spaces);",
          "    assert_eq!(split_spaces.haystack, hay_spaces);",
          "    assert_eq!(split_spaces.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_space_plus = Regex::new(r\" +\").unwrap();",
          "    let hay_space_plus = b\"    a  b c\";",
          "    let split_space_plus = re_space_plus.split(hay_space_plus);",
          "    assert_eq!(split_space_plus.haystack, hay_space_plus);",
          "    assert_eq!(split_space_plus.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty_string = Regex::new(r\"\").unwrap();",
          "    let hay_empty_string = \"笘ソ".as_bytes();",
          "    let split_empty_string = re_empty_string.split(hay_empty_string);",
          "    assert_eq!(split_empty_string.haystack, hay_empty_string);",
          "    assert_eq!(split_empty_string.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..]]);",
          "    ",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"Mary had a little lamb\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"Mary\"[..], &b\"had\"[..], &b\"a\"[..], &b\"little\"[..], &b\"lamb\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"lionXXtigerXleopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"::\").unwrap();",
          "    let hay = b\"lion::tiger::leopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"0\").unwrap();",
          "    let hay = b\"010\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"1\"[..], &b\"\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"\").unwrap();",
          "    let hay = \"笘ソ".as_bytes();",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);",
          "    ",
          "    let re = Regex::new(r\" +\").unwrap();",
          "    let hay = b\"    a  b c\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..]]);",
          "    ",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"Mary had a little lamb\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"Mary\"[..], &b\"had\"[..], &b\"a\"[..], &b\"little\"[..], &b\"lamb\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"lionXXtigerXleopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"::\").unwrap();",
          "    let hay = b\"lion::tiger::leopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"0\").unwrap();",
          "    let hay = b\"010\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"1\"[..], &b\"\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"\").unwrap();",
          "    let hay = \"笘ソ".as_bytes();",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);",
          "    ",
          "    let re = Regex::new(r\" +\").unwrap();",
          "    let hay = b\"    a  b c\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"lionXXtigerXleopard\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"lionXXtigerXleopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"Mary had a little lamb\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"Mary\"[..], &b\"had\"[..], &b\"a\"[..], &b\"little\"[..], &b\"lamb\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"::\").unwrap();",
          "    let hay = b\"lion::tiger::leopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"XXXXaXXbXc\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"0\").unwrap();",
          "    let hay = b\"010\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"1\"[..], &b\"\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"\").unwrap();",
          "    let hay = \"笘ソ".as_bytes();",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"lionXXtigerXleopard\";",
          "    let split = re.split(hay);",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"lionXXtigerXleopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"Mary had a little lamb\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"Mary\"[..], &b\"had\"[..], &b\"a\"[..], &b\"little\"[..], &b\"lamb\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"::\").unwrap();",
          "    let hay = b\"lion::tiger::leopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"XXXXaXXbXc\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"0\").unwrap();",
          "    let hay = b\"010\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"1\"[..], &b\"\"[..]]);",
          "    ",
          "    let re = Regex::new(r\"\").unwrap();",
          "    let hay = \"笘ソ".as_bytes();",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"::\").unwrap();",
          "    let hay = b\"lion::tiger::leopard\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(split.haystack, b\"lion::tiger::leopard\");",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"X\").unwrap();",
          "    let hay_empty = b\"\";",
          "    let split_empty = re_empty.split(hay_empty);",
          "    assert_eq!(split_empty.haystack, b\"\");",
          "    assert_eq!(split_empty.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..]]);",
          "    ",
          "    let re_multiple = Regex::new(r\"X\").unwrap();",
          "    let hay_multiple = b\"lionXXtigerXleopard\";",
          "    let split_multiple = re_multiple.split(hay_multiple);",
          "    assert_eq!(split_multiple.haystack, b\"lionXXtigerXleopard\");",
          "    assert_eq!(split_multiple.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_space = Regex::new(r\" \").unwrap();",
          "    let hay_space = b\"    a  b c\";",
          "    let split_space = re_space.split(hay_space);",
          "    assert_eq!(split_space.haystack, b\"    a  b c\");",
          "    assert_eq!(split_space.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty_match = Regex::new(r\"\").unwrap();",
          "    let hay_empty_match = \"笘ソ".as_bytes();",
          "    let split_empty_match = re_empty_match.split(hay_empty_match);",
          "    assert_eq!(split_empty_match.haystack, hay_empty_match);",
          "    assert_eq!(split_empty_match.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"::\").unwrap();",
          "    let hay = b\"lion::tiger::leopard\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, b\"lion::tiger::leopard\");",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"X\").unwrap();",
          "    let hay_empty = b\"\";",
          "    let split_empty = re_empty.split(hay_empty);",
          "    assert_eq!(split_empty.haystack, b\"\");",
          "    assert_eq!(split_empty.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..]]);",
          "    ",
          "    let re_multiple = Regex::new(r\"X\").unwrap();",
          "    let hay_multiple = b\"lionXXtigerXleopard\";",
          "    let split_multiple = re_multiple.split(hay_multiple);",
          "    assert_eq!(split_multiple.haystack, b\"lionXXtigerXleopard\");",
          "    assert_eq!(split_multiple.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "    ",
          "    let re_space = Regex::new(r\" \").unwrap();",
          "    let hay_space = b\"    a  b c\";",
          "    let split_space = re_space.split(hay_space);",
          "    assert_eq!(split_space.haystack, b\"    a  b c\");",
          "    assert_eq!(split_space.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty_match = Regex::new(r\"\").unwrap();",
          "    let hay_empty_match = \"笘ソ".as_bytes();",
          "    let split_empty_match = re_empty_match.split(hay_empty_match);",
          "    assert_eq!(split_empty_match.haystack, hay_empty_match);",
          "    assert_eq!(split_empty_match.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"XXXXaXXbXc\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.count() == 8);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"\").unwrap();",
          "    let split_empty = re_empty.split(hay);",
          "    assert_eq!(split_empty.it.count(), 5);",
          "    assert_eq!(split_empty.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'X'][..], &[b'X'][..], &[b'X'][..], &[b'X'][..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..], &[][..]]);",
          "    ",
          "    let re_space = Regex::new(r\" \").unwrap();",
          "    let split_space = re_space.split(b\"    a  b c\");",
          "    assert_eq!(split_space.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_tab = Regex::new(r\"\\t\").unwrap();",
          "    let split_tab = re_tab.split(b\"hello\\tworld\");",
          "    assert_eq!(split_tab.it.collect::<Vec<&[u8]>>(), vec![&b\"hello\"[..], &b\"world\"[..]]);",
          "    ",
          "    let re_colon = Regex::new(r\"::\").unwrap();",
          "    let split_colon = re_colon.split(b\"lion::tiger::leopard\");",
          "    assert_eq!(split_colon.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"X\").unwrap();",
          "    let hay = b\"XXXXaXXbXc\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.count() == 8);",
          "    assert_eq!(split.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"\").unwrap();",
          "    let split_empty = re_empty.split(hay);",
          "    assert_eq!(split_empty.it.count(), 5);",
          "    assert_eq!(split_empty.it.collect::<Vec<&[u8]>>(), vec![&[][..], &[b'X'][..], &[b'X'][..], &[b'X'][..], &[b'X'][..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..], &[][..]]);",
          "    ",
          "    let re_space = Regex::new(r\" \").unwrap();",
          "    let split_space = re_space.split(b\"    a  b c\");",
          "    assert_eq!(split_space.it.collect::<Vec<&[u8]>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_tab = Regex::new(r\"\\t\").unwrap();",
          "    let split_tab = re_tab.split(b\"hello\\tworld\");",
          "    assert_eq!(split_tab.it.collect::<Vec<&[u8]>>(), vec![&b\"hello\"[..], &b\"world\"[..]]);",
          "    ",
          "    let re_colon = Regex::new(r\"::\").unwrap();",
          "    let split_colon = re_colon.split(b\"lion::tiger::leopard\");",
          "    assert_eq!(split_colon.it.collect::<Vec<&[u8]>>(), vec![&b\"lion\"[..], &b\"tiger\"[..], &b\"leopard\"[..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"0\").unwrap();",
          "    let hay = b\"010\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    split.haystack == b\"010\"",
          "    split.it == re.meta.split(b\"010\")",
          "    split.it.collect::<Vec<&[u8]>>() == vec![&b\"\"[..], &b\"1\"[..], &b\"\"[..]]"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"0\").unwrap();",
          "    let hay = b\"010\";",
          "    let split = re.split(hay);",
          "    split.haystack == b\"010\"",
          "    split.it == re.meta.split(b\"010\")",
          "    split.it.collect::<Vec<&[u8]>>() == vec![&b\"\"[..], &b\"1\"[..], &b\"\"[..]]",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\").unwrap();",
          "    let hay = \"笘ソ".as_bytes();",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.next().is_none());",
          "    assert_eq!(split.it.collect::<Vec<_>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\").unwrap();",
          "    let hay = \"笘ソ".as_bytes();",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.next().is_none());",
          "    assert_eq!(split.it.collect::<Vec<_>>(), vec![&[][..], &[b'\\xE2'][..], &[b'\\x98'][..], &[b'\\x83'][..], &[][..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"    a  b c\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.next().is_some());",
          "    assert_eq!(split.it.count(), 6);",
          "    assert_eq!(split.it.collect::<Vec<_>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\" \").unwrap();",
          "    let hay = b\"    a  b c\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.next().is_some());",
          "    assert_eq!(split.it.count(), 6);",
          "    assert_eq!(split.it.collect::<Vec<_>>(), vec![&b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"\"[..], &b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\" +\").unwrap();",
          "    let hay = b\"    a  b c\";",
          "    let split = re.split(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.next().is_none());",
          "    let fields: Vec<&[u8]> = split.collect();",
          "    assert_eq!(fields, vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"\").unwrap();",
          "    let empty_hay = b\"\";",
          "    let empty_split = re_empty.split(empty_hay);",
          "    assert_eq!(empty_split.haystack, empty_hay);",
          "    let empty_fields: Vec<&[u8]> = empty_split.collect();",
          "    assert_eq!(empty_fields, vec![&[][..]]);",
          "    ",
          "    let re_single_space = Regex::new(r\" \").unwrap();",
          "    let single_space_hay = b\"a b\";",
          "    let single_space_split = re_single_space.split(single_space_hay);",
          "    let single_space_fields: Vec<&[u8]> = single_space_split.collect();",
          "    assert_eq!(single_space_fields, vec![&b\"a\"[..], &b\"\"[..], &b\"b\"[..]]);",
          "    ",
          "    let re_multiple_spaces = Regex::new(r\" +\").unwrap();",
          "    let multiple_spaces_hay = b\"    a    b c\";",
          "    let multiple_spaces_split = re_multiple_spaces.split(multiple_spaces_hay);",
          "    let multiple_spaces_fields: Vec<&[u8]> = multiple_spaces_split.collect();",
          "    assert_eq!(multiple_spaces_fields, vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_contiguous_spaces = Regex::new(r\" +\").unwrap();",
          "    let contiguous_spaces_hay = b\"   a   b   \";",
          "    let contiguous_spaces_split = re_contiguous_spaces.split(contiguous_spaces_hay);",
          "    let contiguous_spaces_fields: Vec<&[u8]> = contiguous_spaces_split.collect();",
          "    assert_eq!(contiguous_spaces_fields, vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"\"[..]]);",
          "    ",
          "    let re_tabs = Regex::new(r\"\\t+\").unwrap();",
          "    let tabs_hay = b\"a\\t\\tb\\tc\";",
          "    let tabs_split = re_tabs.split(tabs_hay);",
          "    let tabs_fields: Vec<&[u8]> = tabs_split.collect();",
          "    assert_eq!(tabs_fields, vec![&b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_custom_delimiter = Regex::new(r\"::\").unwrap();",
          "    let custom_delimiter_hay = b\"a::b::c\";",
          "    let custom_delimiter_split = re_custom_delimiter.split(custom_delimiter_hay);",
          "    let custom_delimiter_fields: Vec<&[u8]> = custom_delimiter_split.collect();",
          "    assert_eq!(custom_delimiter_fields, vec![&b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\" +\").unwrap();",
          "    let hay = b\"    a  b c\";",
          "    let split = re.split(hay);",
          "    assert_eq!(split.haystack, hay);",
          "    assert!(split.it.next().is_none());",
          "    let fields: Vec<&[u8]> = split.collect();",
          "    assert_eq!(fields, vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_empty = Regex::new(r\"\").unwrap();",
          "    let empty_hay = b\"\";",
          "    let empty_split = re_empty.split(empty_hay);",
          "    assert_eq!(empty_split.haystack, empty_hay);",
          "    let empty_fields: Vec<&[u8]> = empty_split.collect();",
          "    assert_eq!(empty_fields, vec![&[][..]]);",
          "    ",
          "    let re_single_space = Regex::new(r\" \").unwrap();",
          "    let single_space_hay = b\"a b\";",
          "    let single_space_split = re_single_space.split(single_space_hay);",
          "    let single_space_fields: Vec<&[u8]> = single_space_split.collect();",
          "    assert_eq!(single_space_fields, vec![&b\"a\"[..], &b\"\"[..], &b\"b\"[..]]);",
          "    ",
          "    let re_multiple_spaces = Regex::new(r\" +\").unwrap();",
          "    let multiple_spaces_hay = b\"    a    b c\";",
          "    let multiple_spaces_split = re_multiple_spaces.split(multiple_spaces_hay);",
          "    let multiple_spaces_fields: Vec<&[u8]> = multiple_spaces_split.collect();",
          "    assert_eq!(multiple_spaces_fields, vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_contiguous_spaces = Regex::new(r\" +\").unwrap();",
          "    let contiguous_spaces_hay = b\"   a   b   \";",
          "    let contiguous_spaces_split = re_contiguous_spaces.split(contiguous_spaces_hay);",
          "    let contiguous_spaces_fields: Vec<&[u8]> = contiguous_spaces_split.collect();",
          "    assert_eq!(contiguous_spaces_fields, vec![&b\"\"[..], &b\"a\"[..], &b\"b\"[..], &b\"\"[..]]);",
          "    ",
          "    let re_tabs = Regex::new(r\"\\t+\").unwrap();",
          "    let tabs_hay = b\"a\\t\\tb\\tc\";",
          "    let tabs_split = re_tabs.split(tabs_hay);",
          "    let tabs_fields: Vec<&[u8]> = tabs_split.collect();",
          "    assert_eq!(tabs_fields, vec![&b\"a\"[..], &b\"\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "    ",
          "    let re_custom_delimiter = Regex::new(r\"::\").unwrap();",
          "    let custom_delimiter_hay = b\"a::b::c\";",
          "    let custom_delimiter_split = re_custom_delimiter.split(custom_delimiter_hay);",
          "    let custom_delimiter_fields: Vec<&[u8]> = custom_delimiter_split.collect();",
          "    assert_eq!(custom_delimiter_fields, vec![&b\"a\"[..], &b\"b\"[..], &b\"c\"[..]]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]