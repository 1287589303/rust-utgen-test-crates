[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let pattern_len = 0;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "}"
        ],
        "oracle": [
          "    let classes = ByteClasses([0; 256]);",
          "    let pattern_len = 0;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "    ",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert!(matches!(dfa.st, StartTable::dead(starts, &lookm, None)));",
          "    assert_eq!(dfa.ms.len(), pattern_len);",
          "    assert!(dfa.special.validate().is_ok());",
          "    assert!(dfa.accels.is_empty());",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([0; 256]);",
          "    let pattern_len = 0;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    let classes = ByteClasses([0; 256]);",
          "    let pattern_len = 0;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "    ",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert!(matches!(dfa.st, StartTable::dead(starts, &lookm, None)));",
          "    assert_eq!(dfa.ms.len(), pattern_len);",
          "    assert!(dfa.special.validate().is_ok());",
          "    assert!(dfa.accels.is_empty());",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([1; 256]);",
          "    let pattern_len = 1;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert_eq!(dfa.ms, MatchStates::empty(pattern_len));",
          "    assert_eq!(dfa.special, Special::new());",
          "    assert_eq!(dfa.accels, Accels::empty());",
          "    assert_eq!(dfa.pre, pre);",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([1; 256]);",
          "    let pattern_len = 1;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert_eq!(dfa.ms, MatchStates::empty(pattern_len));",
          "    assert_eq!(dfa.special, Special::new());",
          "    assert_eq!(dfa.accels, Accels::empty());",
          "    assert_eq!(dfa.pre, pre);",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([2; 256]);",
          "    let pattern_len = 256;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "}"
        ],
        "oracle": [
          "    let classes = ByteClasses([2; 256]);",
          "    let pattern_len = 256;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "    ",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert!(dfa.st.is_dead());",
          "    assert_eq!(dfa.ms.len(), pattern_len);",
          "    assert!(dfa.special == Special::new());",
          "    assert!(dfa.accels.is_empty());",
          "    assert!(dfa.pre.is_none());",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([2; 256]);",
          "    let pattern_len = 256;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    let classes = ByteClasses([2; 256]);",
          "    let pattern_len = 256;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = None;",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "    ",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert!(dfa.st.is_dead());",
          "    assert_eq!(dfa.ms.len(), pattern_len);",
          "    assert!(dfa.special == Special::new());",
          "    assert!(dfa.accels.is_empty());",
          "    assert!(dfa.pre.is_none());",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses([3; 256]);",
          "    let pattern_len = 10;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = Some(Prefilter { _unused: (), is_fast: true, max_needle_len: 5 });",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "}"
        ],
        "oracle": [
          "    let classes = ByteClasses([3; 256]);",
          "    let pattern_len = 10;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = Some(Prefilter { _unused: (), is_fast: true, max_needle_len: 5 });",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "    ",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert!(dfa.st.is_ok());",
          "    assert_eq!(dfa.ms, MatchStates::empty(pattern_len));",
          "    assert_eq!(dfa.special, Special::new());",
          "    assert_eq!(dfa.accels, Accels::empty());",
          "    assert_eq!(dfa.pre, pre);",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses([3; 256]);",
          "    let pattern_len = 10;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = Some(Prefilter { _unused: (), is_fast: true, max_needle_len: 5 });",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    let classes = ByteClasses([3; 256]);",
          "    let pattern_len = 10;",
          "    let starts = StartKind::Anchored;",
          "    let lookm = LookMatcher { lineterm: DebugByte::new() };",
          "    let starts_for_each_pattern = false;",
          "    let pre = Some(Prefilter { _unused: (), is_fast: true, max_needle_len: 5 });",
          "    let quitset = ByteSet { bits: BitSet::new() };",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: false };",
          "    ",
          "    let result = OwnedDFA::initial(classes, pattern_len, starts, &lookm, starts_for_each_pattern, pre, quitset, flags);",
          "    assert!(result.is_ok());",
          "    let dfa = result.unwrap();",
          "    assert_eq!(dfa.tt, TransitionTable::minimal(classes));",
          "    assert!(dfa.st.is_ok());",
          "    assert_eq!(dfa.ms, MatchStates::empty(pattern_len));",
          "    assert_eq!(dfa.special, Special::new());",
          "    assert_eq!(dfa.accels, Accels::empty());",
          "    assert_eq!(dfa.pre, pre);",
          "    assert_eq!(dfa.quitset, quitset);",
          "    assert_eq!(dfa.flags, flags);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]