[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literals = vec![];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[]\");",
          "    seq.literals().is_some();",
          "    seq.literals().unwrap().is_empty();"
        ],
        "code": [
          "{",
          "    let literals = vec![];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[]\");",
          "    seq.literals().is_some();",
          "    seq.literals().unwrap().is_empty();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Literal { bytes: vec![b'a'], exact: true };",
          "    let seq = Seq { literals: Some(vec![literal]) };",
          "    let _ = format!(\"{:?}\", seq);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"Seq\").is_ok()",
          "    self.literals().is_some()",
          "    self.literals().unwrap().len() > 0",
          "    format!(\"{:?}\", seq) == \"Seq[\\n    Literal { bytes: [97], exact: true }\\n]\"",
          "    seq.literals().unwrap()[0].bytes == vec![b'a']",
          "    seq.literals().unwrap()[0].exact == true"
        ],
        "code": [
          "{",
          "    let literal = Literal { bytes: vec![b'a'], exact: true };",
          "    let seq = Seq { literals: Some(vec![literal]) };",
          "    let _ = format!(\"{:?}\", seq);",
          "    write!(f, \"Seq\").is_ok()",
          "    self.literals().is_some()",
          "    self.literals().unwrap().len() > 0",
          "    format!(\"{:?}\", seq) == \"Seq[\\n    Literal { bytes: [97], exact: true }\\n]\"",
          "    seq.literals().unwrap()[0].bytes == vec![b'a']",
          "    seq.literals().unwrap()[0].exact == true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literals = vec![",
          "        Literal { bytes: vec![b'a'], exact: true },",
          "        Literal { bytes: vec![b'b'], exact: true },",
          "    ];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"Seq\").is_ok();",
          "    self.literals().is_some();",
          "    self.literals().unwrap().len() > 0;",
          "    self.literals().unwrap().iter().all(|lit| lit.bytes.len() > 0);",
          "    self.literals().unwrap().iter().all(|lit| lit.exact);",
          "    format!(\"{:?}\", seq).contains(\"Seq\");",
          "    format!(\"{:?}\", seq).contains(\"[\");",
          "    format!(\"{:?}\", seq).contains(\"]\");",
          "    format!(\"{:?}\", seq).contains(\"Literal\");"
        ],
        "code": [
          "{",
          "    let literals = vec![",
          "        Literal { bytes: vec![b'a'], exact: true },",
          "        Literal { bytes: vec![b'b'], exact: true },",
          "    ];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "    write!(f, \"Seq\").is_ok();",
          "    self.literals().is_some();",
          "    self.literals().unwrap().len() > 0;",
          "    self.literals().unwrap().iter().all(|lit| lit.bytes.len() > 0);",
          "    self.literals().unwrap().iter().all(|lit| lit.exact);",
          "    format!(\"{:?}\", seq).contains(\"Seq\");",
          "    format!(\"{:?}\", seq).contains(\"[\");",
          "    format!(\"{:?}\", seq).contains(\"]\");",
          "    format!(\"{:?}\", seq).contains(\"Literal\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Literal { bytes: vec![b'c'], exact: false };",
          "    let seq = Seq { literals: Some(vec![literal]) };",
          "    let _ = format!(\"{:?}\", seq);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[c]\");",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0].bytes, vec![b'c']);",
          "    assert!(!seq.literals().unwrap()[0].exact);"
        ],
        "code": [
          "{",
          "    let literal = Literal { bytes: vec![b'c'], exact: false };",
          "    let seq = Seq { literals: Some(vec![literal]) };",
          "    let _ = format!(\"{:?}\", seq);",
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[c]\");",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[0].bytes, vec![b'c']);",
          "    assert!(!seq.literals().unwrap()[0].exact);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literals = vec![",
          "        Literal { bytes: vec![b'd'], exact: false },",
          "        Literal { bytes: vec![b'e'], exact: false },",
          "    ];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().is_some(), true);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].bytes, vec![b'd']);",
          "    assert_eq!(seq.literals().unwrap()[1].bytes, vec![b'e']);",
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[\\nd\\n,e\\n]\");"
        ],
        "code": [
          "{",
          "    let literals = vec![",
          "        Literal { bytes: vec![b'd'], exact: false },",
          "        Literal { bytes: vec![b'e'], exact: false },",
          "    ];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "    assert_eq!(seq.literals().is_some(), true);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].bytes, vec![b'd']);",
          "    assert_eq!(seq.literals().unwrap()[1].bytes, vec![b'e']);",
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[\\nd\\n,e\\n]\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literals = vec![",
          "        Literal { bytes: vec![b'f'], exact: true },",
          "        Literal { bytes: vec![b'g'], exact: false },",
          "    ];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[f, g]\");",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert!(seq.literals().unwrap()[0].exact);",
          "    assert!(!seq.literals().unwrap()[1].exact);"
        ],
        "code": [
          "{",
          "    let literals = vec![",
          "        Literal { bytes: vec![b'f'], exact: true },",
          "        Literal { bytes: vec![b'g'], exact: false },",
          "    ];",
          "    let seq = Seq { literals: Some(literals) };",
          "    let _ = format!(\"{:?}\", seq);",
          "    assert_eq!(format!(\"{:?}\", seq), \"Seq[f, g]\");",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert!(seq.literals().unwrap()[0].exact);",
          "    assert!(!seq.literals().unwrap()[1].exact);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]