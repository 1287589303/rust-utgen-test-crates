[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = 0x7F; // upper bound of single-byte UTF-8 character",
          "    let result = len(byte);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(1));"
        ],
        "code": [
          "{",
          "    let byte = 0x7F; // upper bound of single-byte UTF-8 character",
          "    let result = len(byte);",
          "    assert_eq!(result, Some(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = 0x80; // lower bound of continuation bytes",
          "    let result = len(byte);",
          "}"
        ],
        "oracle": [
          "    let byte = 0x7F; // upper bound of single-byte characters",
          "    let expected = Some(1);",
          "    assert_eq!(len(byte), expected);"
        ],
        "code": [
          "{",
          "    let byte = 0x80; // lower bound of continuation bytes",
          "    let result = len(byte);",
          "    let byte = 0x7F; // upper bound of single-byte characters",
          "    let expected = Some(1);",
          "    assert_eq!(len(byte), expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = 0xC0; // lower bound of two-byte UTF-8 character",
          "    let result = len(byte);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let byte = 0xC0; // lower bound of two-byte UTF-8 character",
          "    let result = len(byte);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = 0xE0; // lower bound of three-byte UTF-8 character",
          "    let result = len(byte);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(len(0x00), Some(1)); // Test with ASCII byte",
          "    assert_eq!(len(0x7F), Some(1)); // Test with maximum ASCII byte",
          "    assert_eq!(len(0xC0), Some(2)); // Test with lower bound of two-byte UTF-8 character",
          "    assert_eq!(len(0xDF), Some(2)); // Test with upper bound of two-byte UTF-8 character",
          "    assert_eq!(len(0xE0), Some(3)); // Test with lower bound of three-byte UTF-8 character",
          "    assert_eq!(len(0xEF), Some(3)); // Test with upper bound of three-byte UTF-8 character",
          "    assert_eq!(len(0xF0), Some(4)); // Test with lower bound of four-byte UTF-8 character",
          "    assert_eq!(len(0xF7), Some(4)); // Test with upper bound of four-byte UTF-8 character",
          "    assert_eq!(len(0x80), None); // Test with invalid continuation byte",
          "    assert_eq!(len(0xF8), None); // Test with invalid leading byte for five-byte character"
        ],
        "code": [
          "{",
          "    let byte = 0xE0; // lower bound of three-byte UTF-8 character",
          "    let result = len(byte);",
          "    assert_eq!(len(0x00), Some(1)); // Test with ASCII byte",
          "    assert_eq!(len(0x7F), Some(1)); // Test with maximum ASCII byte",
          "    assert_eq!(len(0xC0), Some(2)); // Test with lower bound of two-byte UTF-8 character",
          "    assert_eq!(len(0xDF), Some(2)); // Test with upper bound of two-byte UTF-8 character",
          "    assert_eq!(len(0xE0), Some(3)); // Test with lower bound of three-byte UTF-8 character",
          "    assert_eq!(len(0xEF), Some(3)); // Test with upper bound of three-byte UTF-8 character",
          "    assert_eq!(len(0xF0), Some(4)); // Test with lower bound of four-byte UTF-8 character",
          "    assert_eq!(len(0xF7), Some(4)); // Test with upper bound of four-byte UTF-8 character",
          "    assert_eq!(len(0x80), None); // Test with invalid continuation byte",
          "    assert_eq!(len(0xF8), None); // Test with invalid leading byte for five-byte character",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = 0xF0; // lower bound of four-byte UTF-8 character",
          "    let result = len(byte);",
          "}"
        ],
        "oracle": [
          "    let byte = 0x7F;",
          "    let result = len(byte);",
          "    assert_eq!(result, Some(1));"
        ],
        "code": [
          "{",
          "    let byte = 0xF0; // lower bound of four-byte UTF-8 character",
          "    let result = len(byte);",
          "    let byte = 0x7F;",
          "    let result = len(byte);",
          "    assert_eq!(result, Some(1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = 0xF8; // lower bound of invalid UTF-8 characters",
          "    let result = len(byte);",
          "}"
        ],
        "oracle": [
          "    let byte = 0x7F; // upper bound of valid single-byte UTF-8 character",
          "    let expected = Some(1); // expected return value for valid UTF-8 leading byte",
          "    assert_eq!(len(byte), expected); // validate result against expected output"
        ],
        "code": [
          "{",
          "    let byte = 0xF8; // lower bound of invalid UTF-8 characters",
          "    let result = len(byte);",
          "    let byte = 0x7F; // upper bound of valid single-byte UTF-8 character",
          "    let expected = Some(1); // expected return value for valid UTF-8 leading byte",
          "    assert_eq!(len(byte), expected); // validate result against expected output",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]