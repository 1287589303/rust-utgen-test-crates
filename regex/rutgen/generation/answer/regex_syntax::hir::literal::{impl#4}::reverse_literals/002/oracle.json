[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(vec![b'f', b'o', b'o']),",
          "            Literal::exact(vec![b'r', b'a', b'b']),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"oof\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"bar\");",
          "    assert!(seq.literals().is_some());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(vec![b'f', b'o', b'o']),",
          "            Literal::exact(vec![b'r', b'a', b'b']),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"oof\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"bar\");",
          "    assert!(seq.literals().is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[]));",
          "    seq.literals = Some(vec![Literal::exact(b\"abc\".to_vec()), Literal::exact(b\"def\".to_vec())]);",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"cba\".to_vec()), Literal::exact(b\"fed\".to_vec())]));",
          "    seq.literals = Some(vec![Literal::exact(b\"x\".to_vec())]);",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"x\".to_vec())]));",
          "    seq.literals = Some(vec![Literal::exact(b\"\".to_vec()), Literal::exact(b\"xyz\".to_vec())]);",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"zyx\".to_vec()), Literal::exact(b\"\".to_vec())]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[]));",
          "    seq.literals = Some(vec![Literal::exact(b\"abc\".to_vec()), Literal::exact(b\"def\".to_vec())]);",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"cba\".to_vec()), Literal::exact(b\"fed\".to_vec())]));",
          "    seq.literals = Some(vec![Literal::exact(b\"x\".to_vec())]);",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"x\".to_vec())]));",
          "    seq.literals = Some(vec![Literal::exact(b\"\".to_vec()), Literal::exact(b\"xyz\".to_vec())]);",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"zyx\".to_vec()), Literal::exact(b\"\".to_vec())]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![Literal::exact(vec![])]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'f', b'o', b'o'])]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'o', b'o', b'f'])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'r', b'a', b'b]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'b', b'a', b'r'])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'h', b'e', b'l', b'l', b'o])]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'o', b'l', b'l', b'e', b'h'])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'a', b'b']), Literal::exact(vec![b'c', b'd'])]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'b', b'a']), Literal::exact(vec![b'd', b'c'])]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![Literal::exact(vec![])]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'f', b'o', b'o'])]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'o', b'o', b'f'])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'r', b'a', b'b]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'b', b'a', b'r'])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'h', b'e', b'l', b'l', b'o])]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'o', b'l', b'l', b'e', b'h'])]));",
          "    let mut seq = Seq {",
          "    literals: Some(vec![Literal::exact(vec![b'a', b'b']), Literal::exact(vec![b'c', b'd'])]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(vec![b'b', b'a']), Literal::exact(vec![b'd', b'c'])]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]