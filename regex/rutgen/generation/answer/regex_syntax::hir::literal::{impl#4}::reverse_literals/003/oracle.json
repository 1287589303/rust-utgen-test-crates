[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"abc\".to_vec()),",
          "            Literal::exact(b\"def\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"cba\".to_vec()), Literal::exact(b\"fed\".to_vec())]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"abc\".to_vec()),",
          "            Literal::exact(b\"def\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"cba\".to_vec()), Literal::exact(b\"fed\".to_vec())]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"xyz\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"zyx\");",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len().unwrap(), 1);",
          "    assert_eq!(seq.max_literal_len().unwrap(), 3);"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"xyz\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"zyx\");",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len().unwrap(), 1);",
          "    assert_eq!(seq.max_literal_len().unwrap(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"hello\".to_vec()),",
          "            Literal::exact(b\"world\".to_vec()),",
          "            Literal::exact(b\"rust\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"olleh\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"dlrow\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"tsur\");"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"hello\".to_vec()),",
          "            Literal::exact(b\"world\".to_vec()),",
          "            Literal::exact(b\"rust\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"olleh\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"dlrow\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"tsur\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"one\".to_vec()),",
          "            Literal::exact(b\"two\".to_vec()),",
          "            Literal::exact(b\"three\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"eno\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"owt\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"eerht\");",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.literals().unwrap()[1].is_exact());",
          "    assert!(seq.literals().unwrap()[2].is_exact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"one\".to_vec()),",
          "            Literal::exact(b\"two\".to_vec()),",
          "            Literal::exact(b\"three\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"eno\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"owt\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"eerht\");",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.literals().unwrap()[1].is_exact());",
          "    assert!(seq.literals().unwrap()[2].is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"\".to_vec())]));",
          "    assert_eq!(seq.len(), Some(1));",
          "    assert!(seq.is_exact());",
          "    assert!(!seq.is_empty());",
          "    assert!(seq.is_finite());",
          "    assert!(seq.is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq {",
          "        literals: Some(vec![",
          "            Literal::exact(b\"\".to_vec()),",
          "        ]),",
          "    };",
          "    seq.reverse_literals();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"\".to_vec())]));",
          "    assert_eq!(seq.len(), Some(1));",
          "    assert!(seq.is_exact());",
          "    assert!(!seq.is_empty());",
          "    assert!(seq.is_finite());",
          "    assert!(seq.is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]