[
  {
    "uses": [
      "use crate::util::wire::Endian;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::util::wire::Endian;",
          "",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst[0] = (value & 0xFF) as u8;",
          "            dst[1] = ((value >> 8) & 0xFF) as u8;",
          "            dst[2] = ((value >> 16) & 0xFF) as u8;",
          "            dst[3] = ((value >> 24) & 0xFF) as u8;",
          "        }",
          "    }",
          "",
          "    let mut special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(2),",
          "        min_match: StateID(3),",
          "        max_match: StateID(4),",
          "        min_accel: StateID(5),",
          "        max_accel: StateID(6),",
          "        min_start: StateID(7),",
          "        max_start: StateID(8),",
          "    };",
          "",
          "    let buffer_size = special.write_to_len();",
          "    let mut buffer = vec![0u8; buffer_size];",
          "",
          "    let _ = special.write_to::<LittleEndian>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert!(special.write_to::<LittleEndian>(&mut buffer).is_ok(), \"Expected write_to to succeed with sufficient buffer size.\");",
          "    assert_eq!(buffer.len(), special.write_to_len(), \"Buffer size should match the expected length after write_to call.\");",
          "    assert_eq!(buffer.iter().take(special.write_to_len()).count(), special.write_to_len(), \"Number of bytes written must match write_to_len.\");",
          "    assert_eq!(buffer.iter().filter(|&&byte| byte != 0).count() % 8, 0, \"The number of non-zero bytes written should be a multiple of 8.\");",
          "    assert_ne!(special.write_to::<LittleEndian>(&mut buffer).unwrap(), 0, \"Expected some bytes to be written to buffer.\");"
        ],
        "code": [
          "{",
          "    use crate::util::wire::Endian;",
          "",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst[0] = (value & 0xFF) as u8;",
          "            dst[1] = ((value >> 8) & 0xFF) as u8;",
          "            dst[2] = ((value >> 16) & 0xFF) as u8;",
          "            dst[3] = ((value >> 24) & 0xFF) as u8;",
          "        }",
          "    }",
          "",
          "    let mut special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(2),",
          "        min_match: StateID(3),",
          "        max_match: StateID(4),",
          "        min_accel: StateID(5),",
          "        max_accel: StateID(6),",
          "        min_start: StateID(7),",
          "        max_start: StateID(8),",
          "    };",
          "",
          "    let buffer_size = special.write_to_len();",
          "    let mut buffer = vec![0u8; buffer_size];",
          "",
          "    let _ = special.write_to::<LittleEndian>(&mut buffer);",
          "    assert!(special.write_to::<LittleEndian>(&mut buffer).is_ok(), \"Expected write_to to succeed with sufficient buffer size.\");",
          "    assert_eq!(buffer.len(), special.write_to_len(), \"Buffer size should match the expected length after write_to call.\");",
          "    assert_eq!(buffer.iter().take(special.write_to_len()).count(), special.write_to_len(), \"Number of bytes written must match write_to_len.\");",
          "    assert_eq!(buffer.iter().filter(|&&byte| byte != 0).count() % 8, 0, \"The number of non-zero bytes written should be a multiple of 8.\");",
          "    assert_ne!(special.write_to::<LittleEndian>(&mut buffer).unwrap(), 0, \"Expected some bytes to be written to buffer.\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::util::wire::Endian;",
          "",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst[0] = (value & 0xFF) as u8;",
          "            dst[1] = ((value >> 8) & 0xFF) as u8;",
          "            dst[2] = ((value >> 16) & 0xFF) as u8;",
          "            dst[3] = ((value >> 24) & 0xFF) as u8;",
          "        }",
          "    }",
          "",
          "    let mut special = Special {",
          "        max: StateID(10),",
          "        quit_id: StateID(20),",
          "        min_match: StateID(30),",
          "        max_match: StateID(40),",
          "        min_accel: StateID(50),",
          "        max_accel: StateID(60),",
          "        min_start: StateID(70),",
          "        max_start: StateID(80),",
          "    };",
          "",
          "    let buffer_size = special.write_to_len();",
          "    let mut buffer = vec![0u8; buffer_size];",
          "",
          "    let _ = special.write_to::<LittleEndian>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(special.write_to::<LittleEndian>(&mut buffer).is_ok(), true, \"Expected successful write to buffer.\");",
          "    assert_eq!(buffer.len(), special.write_to_len(), \"Expected buffer length to match written bytes length.\");",
          "    assert_eq!(buffer.iter().all(|&x| x == 0), false, \"Expected some bytes in buffer to be non-zero after writing.\");",
          "    assert!(buffer.iter().take(4).eq(&[10u8, 0, 0, 0]), \"Expected first 4 bytes to match serialized max (StateID(10)).\");",
          "    assert!(buffer.iter().skip(4).take(4).eq(&[20u8, 0, 0, 0]), \"Expected second 4 bytes to match serialized quit_id (StateID(20)).\");",
          "    assert!(buffer.iter().skip(8).take(4).eq(&[30u8, 0, 0, 0]), \"Expected third 4 bytes to match serialized min_match (StateID(30)).\");",
          "    assert!(buffer.iter().skip(12).take(4).eq(&[40u8, 0, 0, 0]), \"Expected fourth 4 bytes to match serialized max_match (StateID(40)).\");",
          "    assert!(buffer.iter().skip(16).take(4).eq(&[50u8, 0, 0, 0]), \"Expected fifth 4 bytes to match serialized min_accel (StateID(50)).\");",
          "    assert!(buffer.iter().skip(20).take(4).eq(&[60u8, 0, 0, 0]), \"Expected sixth 4 bytes to match serialized max_accel (StateID(60)).\");",
          "    assert!(buffer.iter().skip(24).take(4).eq(&[70u8, 0, 0, 0]), \"Expected seventh 4 bytes to match serialized min_start (StateID(70)).\");",
          "    assert!(buffer.iter().skip(28).take(4).eq(&[80u8, 0, 0, 0]), \"Expected eighth 4 bytes to match serialized max_start (StateID(80)).\");",
          "    assert_eq!(special.write_to_len() % 8, 0, \"Expected written length to be a multiple of 8 bytes.\");",
          "    assert_eq!(buffer.len() >= special.write_to_len(), true, \"Expected buffer size to be adequate for write.\");"
        ],
        "code": [
          "{",
          "    use crate::util::wire::Endian;",
          "",
          "    struct LittleEndian;",
          "    impl Endian for LittleEndian {",
          "        fn write_u32(value: u32, dst: &mut [u8]) {",
          "            dst[0] = (value & 0xFF) as u8;",
          "            dst[1] = ((value >> 8) & 0xFF) as u8;",
          "            dst[2] = ((value >> 16) & 0xFF) as u8;",
          "            dst[3] = ((value >> 24) & 0xFF) as u8;",
          "        }",
          "    }",
          "",
          "    let mut special = Special {",
          "        max: StateID(10),",
          "        quit_id: StateID(20),",
          "        min_match: StateID(30),",
          "        max_match: StateID(40),",
          "        min_accel: StateID(50),",
          "        max_accel: StateID(60),",
          "        min_start: StateID(70),",
          "        max_start: StateID(80),",
          "    };",
          "",
          "    let buffer_size = special.write_to_len();",
          "    let mut buffer = vec![0u8; buffer_size];",
          "",
          "    let _ = special.write_to::<LittleEndian>(&mut buffer);",
          "    assert_eq!(special.write_to::<LittleEndian>(&mut buffer).is_ok(), true, \"Expected successful write to buffer.\");",
          "    assert_eq!(buffer.len(), special.write_to_len(), \"Expected buffer length to match written bytes length.\");",
          "    assert_eq!(buffer.iter().all(|&x| x == 0), false, \"Expected some bytes in buffer to be non-zero after writing.\");",
          "    assert!(buffer.iter().take(4).eq(&[10u8, 0, 0, 0]), \"Expected first 4 bytes to match serialized max (StateID(10)).\");",
          "    assert!(buffer.iter().skip(4).take(4).eq(&[20u8, 0, 0, 0]), \"Expected second 4 bytes to match serialized quit_id (StateID(20)).\");",
          "    assert!(buffer.iter().skip(8).take(4).eq(&[30u8, 0, 0, 0]), \"Expected third 4 bytes to match serialized min_match (StateID(30)).\");",
          "    assert!(buffer.iter().skip(12).take(4).eq(&[40u8, 0, 0, 0]), \"Expected fourth 4 bytes to match serialized max_match (StateID(40)).\");",
          "    assert!(buffer.iter().skip(16).take(4).eq(&[50u8, 0, 0, 0]), \"Expected fifth 4 bytes to match serialized min_accel (StateID(50)).\");",
          "    assert!(buffer.iter().skip(20).take(4).eq(&[60u8, 0, 0, 0]), \"Expected sixth 4 bytes to match serialized max_accel (StateID(60)).\");",
          "    assert!(buffer.iter().skip(24).take(4).eq(&[70u8, 0, 0, 0]), \"Expected seventh 4 bytes to match serialized min_start (StateID(70)).\");",
          "    assert!(buffer.iter().skip(28).take(4).eq(&[80u8, 0, 0, 0]), \"Expected eighth 4 bytes to match serialized max_start (StateID(80)).\");",
          "    assert_eq!(special.write_to_len() % 8, 0, \"Expected written length to be a multiple of 8 bytes.\");",
          "    assert_eq!(buffer.len() >= special.write_to_len(), true, \"Expected buffer size to be adequate for write.\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]