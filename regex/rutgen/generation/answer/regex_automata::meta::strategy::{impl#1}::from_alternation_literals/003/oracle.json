[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = RegexInfo(Arc::new(RegexInfoI {",
          "        props: vec![Prop {",
          "            look_set: vec![],",
          "            explicit_captures_len: 0,",
          "            is_alternation_literal: true,",
          "        }],",
          "        config: Config {",
          "            match_kind: MatchKind::LeftmostFirst,",
          "        },",
          "    }));",
          "    ",
          "    let literals = (0..3000).map(|i| {",
          "        Hir::from_literal(format!(\"literal_{}\", i).as_bytes())",
          "    }).collect::<Vec<Hir>>();",
          "    ",
          "    let hirs: &[&Hir] = &literals[..1];",
          "",
          "    let result = Pre::from_alternation_literals(&info, hirs);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    assert!(result.unwrap().group_info().is_some());",
          "    assert!(result.unwrap().pre.is_accelerated());",
          "    assert_eq!(result.unwrap().memory_usage(), 0);",
          "    assert!(result.unwrap().pre.search(&mut Cache::default(), &Input::new(b\"test input\")).is_none());",
          "    assert!(result.unwrap().pre.search_half(&mut Cache::default(), &Input::new(b\"test input\")).is_none());",
          "    assert!(result.unwrap().pre.is_match(&mut Cache::default(), &Input::new(b\"test input\")));",
          "    let mut slots = vec![None; 10];",
          "    assert!(result.unwrap().pre.search_slots(&mut Cache::default(), &Input::new(b\"test input\"), &mut slots).is_none());"
        ],
        "code": [
          "{",
          "    let info = RegexInfo(Arc::new(RegexInfoI {",
          "        props: vec![Prop {",
          "            look_set: vec![],",
          "            explicit_captures_len: 0,",
          "            is_alternation_literal: true,",
          "        }],",
          "        config: Config {",
          "            match_kind: MatchKind::LeftmostFirst,",
          "        },",
          "    }));",
          "    ",
          "    let literals = (0..3000).map(|i| {",
          "        Hir::from_literal(format!(\"literal_{}\", i).as_bytes())",
          "    }).collect::<Vec<Hir>>();",
          "    ",
          "    let hirs: &[&Hir] = &literals[..1];",
          "",
          "    let result = Pre::from_alternation_literals(&info, hirs);",
          "    assert!(result.is_some());",
          "    assert!(result.unwrap().group_info().is_some());",
          "    assert!(result.unwrap().pre.is_accelerated());",
          "    assert_eq!(result.unwrap().memory_usage(), 0);",
          "    assert!(result.unwrap().pre.search(&mut Cache::default(), &Input::new(b\"test input\")).is_none());",
          "    assert!(result.unwrap().pre.search_half(&mut Cache::default(), &Input::new(b\"test input\")).is_none());",
          "    assert!(result.unwrap().pre.is_match(&mut Cache::default(), &Input::new(b\"test input\")));",
          "    let mut slots = vec![None; 10];",
          "    assert!(result.unwrap().pre.search_slots(&mut Cache::default(), &Input::new(b\"test input\"), &mut slots).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = RegexInfo(Arc::new(RegexInfoI {",
          "        props: vec![Prop {",
          "            look_set: vec![],",
          "            explicit_captures_len: 0,",
          "            is_alternation_literal: true,",
          "        }],",
          "        config: Config {",
          "            match_kind: MatchKind::LeftmostFirst,",
          "        },",
          "    }));",
          "",
          "    let literals = (0..3000).map(|i| {",
          "        Hir::from_literal(format!(\"literal_{}\", i).as_bytes())",
          "    }).collect::<Vec<Hir>>();",
          "    ",
          "    let hirs: &[&Hir] = &literals[..1];",
          "",
          "    let result = Pre::from_alternation_literals(&info, hirs);",
          "}"
        ],
        "oracle": [
          "    let info = RegexInfo(Arc::new(RegexInfoI { props: vec![Prop { look_set: vec![], explicit_captures_len: 0, is_alternation_literal: true }] , config: Config { match_kind: MatchKind::LeftmostFirst }}));",
          "    let literals = (0..3000).map(|i| { Hir::from_literal(format!(\"literal_{}\", i).as_bytes()) }).collect::<Vec<Hir>>();",
          "    let hirs: &[&Hir] = &literals[..1];",
          "    let result = Pre::from_alternation_literals(&info, hirs);",
          "    assert!(result.is_some());",
          "    let strategy = result.unwrap();",
          "    assert!(strategy.is_match(&mut Cache::default(), &Input::from(\"literal_0\")));",
          "    let ac_result = strategy.create_cache();",
          "    assert!(ac_result.is_ok());",
          "    assert_eq!(strategy.group_info().len(), 1);",
          "    assert_eq!(strategy.memory_usage(), 0);",
          "    assert!(strategy.is_accelerated());"
        ],
        "code": [
          "{",
          "    let info = RegexInfo(Arc::new(RegexInfoI {",
          "        props: vec![Prop {",
          "            look_set: vec![],",
          "            explicit_captures_len: 0,",
          "            is_alternation_literal: true,",
          "        }],",
          "        config: Config {",
          "            match_kind: MatchKind::LeftmostFirst,",
          "        },",
          "    }));",
          "",
          "    let literals = (0..3000).map(|i| {",
          "        Hir::from_literal(format!(\"literal_{}\", i).as_bytes())",
          "    }).collect::<Vec<Hir>>();",
          "    ",
          "    let hirs: &[&Hir] = &literals[..1];",
          "",
          "    let result = Pre::from_alternation_literals(&info, hirs);",
          "    let info = RegexInfo(Arc::new(RegexInfoI { props: vec![Prop { look_set: vec![], explicit_captures_len: 0, is_alternation_literal: true }] , config: Config { match_kind: MatchKind::LeftmostFirst }}));",
          "    let literals = (0..3000).map(|i| { Hir::from_literal(format!(\"literal_{}\", i).as_bytes()) }).collect::<Vec<Hir>>();",
          "    let hirs: &[&Hir] = &literals[..1];",
          "    let result = Pre::from_alternation_literals(&info, hirs);",
          "    assert!(result.is_some());",
          "    let strategy = result.unwrap();",
          "    assert!(strategy.is_match(&mut Cache::default(), &Input::from(\"literal_0\")));",
          "    let ac_result = strategy.create_cache();",
          "    assert!(ac_result.is_ok());",
          "    assert_eq!(strategy.group_info().len(), 1);",
          "    assert_eq!(strategy.memory_usage(), 0);",
          "    assert!(strategy.is_accelerated());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]