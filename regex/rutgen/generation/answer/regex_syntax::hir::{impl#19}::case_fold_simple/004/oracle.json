[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(65, 122);",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(!ClassBytesRange::new(b'a', b'z').is_intersection_empty(range));",
          "    assert!(!ClassBytesRange::new(b'A', b'Z').is_intersection_empty(range));",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0], ClassBytesRange::new(33, 90));",
          "    assert_eq!(ranges[1], ClassBytesRange::new(97, 122));"
        ],
        "code": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(65, 122);",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "    assert!(!ClassBytesRange::new(b'a', b'z').is_intersection_empty(range));",
          "    assert!(!ClassBytesRange::new(b'A', b'Z').is_intersection_empty(range));",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0], ClassBytesRange::new(33, 90));",
          "    assert_eq!(ranges[1], ClassBytesRange::new(97, 122));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(97, 122);",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start(), 65);",
          "    assert_eq!(ranges[0].end(), 90);",
          "    assert_eq!(ranges[1].start(), 97);",
          "    assert_eq!(ranges[1].end(), 122);",
          "    assert!(ranges.iter().all(|r| r.start() >= 65 && r.end() <= 122));"
        ],
        "code": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(97, 122);",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start(), 65);",
          "    assert_eq!(ranges[0].end(), 90);",
          "    assert_eq!(ranges[1].start(), 97);",
          "    assert_eq!(ranges[1].end(), 122);",
          "    assert!(ranges.iter().all(|r| r.start() >= 65 && r.end() <= 122));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(65, 90);",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start(), 33);",
          "    assert_eq!(ranges[0].end(), 58);",
          "    assert_eq!(ranges[1].start(), 97);",
          "    assert_eq!(ranges[1].end(), 122);",
          "    assert!(matches!(range.case_fold_simple(&mut ranges), Ok(_)));"
        ],
        "code": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(65, 90);",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start(), 33);",
          "    assert_eq!(ranges[0].end(), 58);",
          "    assert_eq!(ranges[1].start(), 97);",
          "    assert_eq!(ranges[1].end(), 122);",
          "    assert!(matches!(range.case_fold_simple(&mut ranges), Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(98, 98); // 'b'",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0], ClassBytesRange::new(66, 66)); // 'B'",
          "    assert_eq!(ranges[1], ClassBytesRange::new(98, 98)); // 'b'",
          "    assert!(ClassBytesRange::new(98, 98).is_intersection_empty(&ranges[0]) == false);",
          "    assert!(ClassBytesRange::new(98, 98).is_intersection_empty(&ranges[1]) == false);",
          "    assert!(ranges[0].len() == 1);",
          "    assert!(ranges[1].len() == 1);"
        ],
        "code": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(98, 98); // 'b'",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0], ClassBytesRange::new(66, 66)); // 'B'",
          "    assert_eq!(ranges[1], ClassBytesRange::new(98, 98)); // 'b'",
          "    assert!(ClassBytesRange::new(98, 98).is_intersection_empty(&ranges[0]) == false);",
          "    assert!(ClassBytesRange::new(98, 98).is_intersection_empty(&ranges[1]) == false);",
          "    assert!(ranges[0].len() == 1);",
          "    assert!(ranges[1].len() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(67, 67); // 'C'",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start(), 35); // 'C' -> 'c'",
          "    assert_eq!(ranges[0].end(), 35);   // 'C' -> 'c'",
          "    assert_eq!(ranges[1].start(), 99);  // 'C' -> 'C'",
          "    assert_eq!(ranges[1].end(), 99);    // 'C' -> 'C'",
          "    assert_eq!(ranges[0].len(), 1);",
          "    assert_eq!(ranges[1].len(), 1);"
        ],
        "code": [
          "{",
          "    let mut ranges = Vec::new();",
          "    let range = ClassBytesRange::new(67, 67); // 'C'",
          "    range.case_fold_simple(&mut ranges).unwrap();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start(), 35); // 'C' -> 'c'",
          "    assert_eq!(ranges[0].end(), 35);   // 'C' -> 'c'",
          "    assert_eq!(ranges[1].start(), 99);  // 'C' -> 'C'",
          "    assert_eq!(ranges[1].end(), 99);    // 'C' -> 'C'",
          "    assert_eq!(ranges[0].len(), 1);",
          "    assert_eq!(ranges[1].len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]