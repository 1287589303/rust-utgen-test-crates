[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache { trans: vec![LazyStateID(0); 512], ..Default::default() };",
          "    let dfa = DFA {",
          "        classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let mut lazy = Lazy::new(&dfa, &mut cache);",
          "    let from = LazyStateID(1);",
          "    let to = LazyStateID(2);",
          "    lazy.set_all_transitions(from, to);",
          "}"
        ],
        "oracle": [
          "    assert!(lazy.dfa.classes.get_by_unit(alphabet::Unit(0)) == 0);",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(0))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(2).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(255))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans.iter().all(|&x| x == LazyStateID(2));",
          "    lazy.set_all_transitions(from, to);",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(0))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(1))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(2))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(255))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans.iter().filter(|&&x| x == LazyStateID(2)).count() == lazy.dfa.classes.stride2());",
          "    assert!(lazy.as_ref().is_valid(from));",
          "    assert!(lazy.as_ref().is_valid(to));",
          "    lazy.clear_cache();",
          "    assert!(lazy.cache.trans.iter().all(|&x| x == LazyStateID(0)));"
        ],
        "code": [
          "{",
          "    let mut cache = Cache { trans: vec![LazyStateID(0); 512], ..Default::default() };",
          "    let dfa = DFA {",
          "        classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let mut lazy = Lazy::new(&dfa, &mut cache);",
          "    let from = LazyStateID(1);",
          "    let to = LazyStateID(2);",
          "    lazy.set_all_transitions(from, to);",
          "    assert!(lazy.dfa.classes.get_by_unit(alphabet::Unit(0)) == 0);",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(0))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(2).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(255))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans.iter().all(|&x| x == LazyStateID(2));",
          "    lazy.set_all_transitions(from, to);",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(0))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(1))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(2))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans[LazyStateID(1).as_usize_untagged() + lazy.dfa.classes.get_by_unit(alphabet::Unit(255))] == LazyStateID(2));",
          "    assert!(lazy.cache.trans.iter().filter(|&&x| x == LazyStateID(2)).count() == lazy.dfa.classes.stride2());",
          "    assert!(lazy.as_ref().is_valid(from));",
          "    assert!(lazy.as_ref().is_valid(to));",
          "    lazy.clear_cache();",
          "    assert!(lazy.cache.trans.iter().all(|&x| x == LazyStateID(0)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut cache = Cache { trans: vec![LazyStateID(0); 512], ..Default::default() };",
          "    let dfa = DFA {",
          "        classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let mut lazy = Lazy::new(&dfa, &mut cache);",
          "    let from = LazyStateID(1);",
          "    let to = LazyStateID(2);",
          "    lazy.set_transition(from, alphabet::Unit(256), to); // Invalid byte",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lazy.cache.trans.len(), 512);",
          "    assert_eq!(lazy.dfa.classes.get_by_unit(alphabet::Unit(256)), 0);",
          "    assert!(matches!(lazy.set_transition(from, alphabet::Unit(256), to), Err(_)));"
        ],
        "code": [
          "{",
          "    let mut cache = Cache { trans: vec![LazyStateID(0); 512], ..Default::default() };",
          "    let dfa = DFA {",
          "        classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let mut lazy = Lazy::new(&dfa, &mut cache);",
          "    let from = LazyStateID(1);",
          "    let to = LazyStateID(2);",
          "    lazy.set_transition(from, alphabet::Unit(256), to); // Invalid byte",
          "    assert_eq!(lazy.cache.trans.len(), 512);",
          "    assert_eq!(lazy.dfa.classes.get_by_unit(alphabet::Unit(256)), 0);",
          "    assert!(matches!(lazy.set_transition(from, alphabet::Unit(256), to), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]