[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_total(5);",
          "",
          "    let lit1 = Literal::exact(vec![b'a']);",
          "    let lit2 = Literal::exact(vec![b'b', b'c']);",
          "    ",
          "    let mut seq1 = Seq::singleton(lit1);",
          "    let mut seq2 = Seq::singleton(lit2);",
          "    ",
          "    extractor.cross(seq1.clone(), &mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.limit_total, 5);",
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert!(seq1.max_cross_len(&seq2).map_or(false, |len| len <= extractor.limit_total));",
          "    assert_eq!(seq1.len().unwrap(), 1);",
          "    assert!(seq1.literals().is_some());",
          "    assert_eq!(seq1.literals().unwrap().len(), 1);",
          "    assert!(seq1.literals().unwrap()[0].is_exact());",
          "    assert!(seq2.len().map_or(false, |x| x <= extractor.limit_total));",
          "    assert!(seq2.literals().is_some());",
          "    assert_eq!(seq2.literals().unwrap().len(), 1);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_total(5);",
          "",
          "    let lit1 = Literal::exact(vec![b'a']);",
          "    let lit2 = Literal::exact(vec![b'b', b'c']);",
          "    ",
          "    let mut seq1 = Seq::singleton(lit1);",
          "    let mut seq2 = Seq::singleton(lit2);",
          "    ",
          "    extractor.cross(seq1.clone(), &mut seq2);",
          "    assert_eq!(extractor.limit_total, 5);",
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert!(seq1.max_cross_len(&seq2).map_or(false, |len| len <= extractor.limit_total));",
          "    assert_eq!(seq1.len().unwrap(), 1);",
          "    assert!(seq1.literals().is_some());",
          "    assert_eq!(seq1.literals().unwrap().len(), 1);",
          "    assert!(seq1.literals().unwrap()[0].is_exact());",
          "    assert!(seq2.len().map_or(false, |x| x <= extractor.limit_total));",
          "    assert!(seq2.literals().is_some());",
          "    assert_eq!(seq2.literals().unwrap().len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_total(9);",
          "",
          "    let lit1 = Literal::exact(vec![b'1']);",
          "    let lit2 = Literal::exact(vec![b'2', b'3']);",
          "    let lit3 = Literal::exact(vec![b'4']);",
          "    ",
          "    let mut seq1 = Seq::new(vec![lit1, lit3]);",
          "    let mut seq2 = Seq::new(vec![lit2]);",
          "    ",
          "    extractor.cross(seq1.clone(), &mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.limit_total, 9);",
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert!(seq1.max_cross_len(&seq2).is_some());",
          "    assert!(seq1.len().unwrap() > extractor.limit_total);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_total(9);",
          "",
          "    let lit1 = Literal::exact(vec![b'1']);",
          "    let lit2 = Literal::exact(vec![b'2', b'3']);",
          "    let lit3 = Literal::exact(vec![b'4']);",
          "    ",
          "    let mut seq1 = Seq::new(vec![lit1, lit3]);",
          "    let mut seq2 = Seq::new(vec![lit2]);",
          "    ",
          "    extractor.cross(seq1.clone(), &mut seq2);",
          "    assert_eq!(extractor.limit_total, 9);",
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert!(seq1.max_cross_len(&seq2).is_some());",
          "    assert!(seq1.len().unwrap() > extractor.limit_total);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_total(7);",
          "",
          "    let lit1 = Literal::exact(vec![b'x', b'y']);",
          "    ",
          "    let mut seq1 = Seq::singleton(lit1);",
          "    let mut seq2 = Seq::empty();",
          "    ",
          "    extractor.cross(seq1.clone(), &mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.limit_total, 7);",
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert!(seq1.max_cross_len(&seq2).is_none());",
          "    assert!(seq1.len().unwrap() <= extractor.limit_total);",
          "    assert!(seq2.is_infinite());",
          "    assert!(seq1.len().map_or(true, |x| x <= extractor.limit_total) == false);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new().kind(ExtractKind::Suffix).limit_total(7);",
          "",
          "    let lit1 = Literal::exact(vec![b'x', b'y']);",
          "    ",
          "    let mut seq1 = Seq::singleton(lit1);",
          "    let mut seq2 = Seq::empty();",
          "    ",
          "    extractor.cross(seq1.clone(), &mut seq2);",
          "    assert_eq!(extractor.limit_total, 7);",
          "    assert_eq!(extractor.kind, ExtractKind::Suffix);",
          "    assert!(seq1.max_cross_len(&seq2).is_none());",
          "    assert!(seq1.len().unwrap() <= extractor.limit_total);",
          "    assert!(seq2.is_infinite());",
          "    assert!(seq1.len().map_or(true, |x| x <= extractor.limit_total) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]