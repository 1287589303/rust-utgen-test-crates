[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 2; // ' ' (space) at index 2 is not a word character; 'b' before is a word character",
          "    look.is_match(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 1; // 'b' at index 1 is a word character; ' ' (space) before is a non-word character",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 3; // '1' at index 3 is a non-word character; ' ' (space) before is a non-word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 5; // '_' at index 5 is a word character; '2' before is a non-word character",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 7; // 'c' at index 7 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 8; // '@' at index 8 is a non-word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true);"
        ],
        "code": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 2; // ' ' (space) at index 2 is not a word character; 'b' before is a word character",
          "    look.is_match(haystack, at);",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 1; // 'b' at index 1 is a word character; ' ' (space) before is a non-word character",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 3; // '1' at index 3 is a non-word character; ' ' (space) before is a non-word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 5; // '_' at index 5 is a word character; '2' before is a non-word character",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 7; // 'c' at index 7 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 8; // '@' at index 8 is a non-word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 3; // '1' at index 3 is a word character; ' ' before is not",
          "    look.is_match(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(look.is_match(haystack, at), true);  // Word before is not a word character, after is a word character",
          "    at = 2; // ' ' at index 2 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before is a word character, after is not",
          "    at = 4; // '2' at index 4 is a word character; '1' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 5; // '_' at index 5 is a word character; '2' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 7; // 'c' at index 7 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 8; // '@' at index 8 is not a word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // Word before is a word character, after is not"
        ],
        "code": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 3; // '1' at index 3 is a word character; ' ' before is not",
          "    look.is_match(haystack, at);",
          "    assert_eq!(look.is_match(haystack, at), true);  // Word before is not a word character, after is a word character",
          "    at = 2; // ' ' at index 2 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before is a word character, after is not",
          "    at = 4; // '2' at index 4 is a word character; '1' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 5; // '_' at index 5 is a word character; '2' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 7; // 'c' at index 7 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // Word before and after are both word characters",
          "    at = 8; // '@' at index 8 is not a word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // Word before is a word character, after is not",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 4; // '2' at index 4 is a word character; '1' before is a word character",
          "    look.is_match(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(look.is_match(haystack, at), false); // at 4: '2' is a word character, '1' is a word character",
          "    at = 3; // ' ' at index 3 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // at 3: word_before ('b') != word_after (' ')",
          "    at = 5; // '_' at index 5 is a word character; '2' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // at 5: word_before ('2') != word_after ('_')",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // at 6: word_before ('_') != word_after ('a')",
          "    at = 7; // 'c' at index 7 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // at 7: word_before ('a') != word_after ('c')",
          "    at = 8; // '@' at index 8 is not a word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // at 8: word_before ('c') != word_after ('@')"
        ],
        "code": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 4; // '2' at index 4 is a word character; '1' before is a word character",
          "    look.is_match(haystack, at);",
          "    assert_eq!(look.is_match(haystack, at), false); // at 4: '2' is a word character, '1' is a word character",
          "    at = 3; // ' ' at index 3 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // at 3: word_before ('b') != word_after (' ')",
          "    at = 5; // '_' at index 5 is a word character; '2' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // at 5: word_before ('2') != word_after ('_')",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // at 6: word_before ('_') != word_after ('a')",
          "    at = 7; // 'c' at index 7 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // at 7: word_before ('a') != word_after ('c')",
          "    at = 8; // '@' at index 8 is not a word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // at 8: word_before ('c') != word_after ('@')",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 5; // '_' at index 5 is a word character; '2' before is a word character",
          "    look.is_match(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 4; // '1' at index 4 is a word character; ' ' before is not",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 0; // 'a' at index 0 is a word character; no character before",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 8; // '@' at index 8 is not a word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 7; // 'c' at index 7 is a word character; '@' after is not",
          "    assert_eq!(look.is_match(haystack, at), false);"
        ],
        "code": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 5; // '_' at index 5 is a word character; '2' before is a word character",
          "    look.is_match(haystack, at);",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 4; // '1' at index 4 is a word character; ' ' before is not",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "    at = 0; // 'a' at index 0 is a word character; no character before",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 8; // '@' at index 8 is not a word character; 'c' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true);",
          "    at = 7; // 'c' at index 7 is a word character; '@' after is not",
          "    assert_eq!(look.is_match(haystack, at), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    look.is_match(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 5; // '_' at index 5 is a word character; ' ' before is not a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is false, word_after is true",
          "    at = 4; // '2' at index 4 is not a word character; '1' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 3; // ' ' at index 3 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 2; // ' ' at index 2 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 1; // 'b' at index 1 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // word_before is true, word_after is true",
          "    at = 0; // 'a' at index 0 is a word character; beginning of haystack",
          "    assert_eq!(look.is_match(haystack, at), false); // word_before is false, word_after is true"
        ],
        "code": [
          "{",
          "    let look = Look::Word;",
          "    let haystack = &[b'a', b'b', b' ', b'1', b'2', b'_', b'a', b'c', b'@'];",
          "    let at = 6; // 'a' at index 6 is a word character; '_' before is a word character",
          "    look.is_match(haystack, at);",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 5; // '_' at index 5 is a word character; ' ' before is not a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is false, word_after is true",
          "    at = 4; // '2' at index 4 is not a word character; '1' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 3; // ' ' at index 3 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 2; // ' ' at index 2 is not a word character; 'b' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), true); // word_before is true, word_after is false",
          "    at = 1; // 'b' at index 1 is a word character; 'a' before is a word character",
          "    assert_eq!(look.is_match(haystack, at), false); // word_before is true, word_after is true",
          "    at = 0; // 'a' at index 0 is a word character; beginning of haystack",
          "    assert_eq!(look.is_match(haystack, at), false); // word_before is false, word_after is true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]