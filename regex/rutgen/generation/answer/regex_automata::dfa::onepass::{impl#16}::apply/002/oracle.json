[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots = Slots(1); // non-empty",
          "    let at = 0; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 1]; // length is 1",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "}"
        ],
        "oracle": [
          "    assert!(caller_explicit_slots[0].is_none());",
          "    assert_eq!(caller_explicit_slots.len(), 1);",
          "    assert!(caller_explicit_slots[0].is_none());"
        ],
        "code": [
          "{",
          "    let slots = Slots(1); // non-empty",
          "    let at = 0; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 1]; // length is 1",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "    assert!(caller_explicit_slots[0].is_none());",
          "    assert_eq!(caller_explicit_slots.len(), 1);",
          "    assert!(caller_explicit_slots[0].is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots = Slots(0b11111111111111111111111111111111); // non-empty and all slots set",
          "    let at = 15; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 32]; // length is 32",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(caller_explicit_slots[0], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[1], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[2], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[3], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[4], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[5], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[6], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[7], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[8], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[9], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[10], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[11], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[12], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[13], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[14], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[15], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[16], None);",
          "    assert_eq!(caller_explicit_slots[17], None);",
          "    assert_eq!(caller_explicit_slots[18], None);",
          "    assert_eq!(caller_explicit_slots[19], None);",
          "    assert_eq!(caller_explicit_slots[20], None);",
          "    assert_eq!(caller_explicit_slots[21], None);",
          "    assert_eq!(caller_explicit_slots[22], None);",
          "    assert_eq!(caller_explicit_slots[23], None);",
          "    assert_eq!(caller_explicit_slots[24], None);",
          "    assert_eq!(caller_explicit_slots[25], None);",
          "    assert_eq!(caller_explicit_slots[26], None);",
          "    assert_eq!(caller_explicit_slots[27], None);",
          "    assert_eq!(caller_explicit_slots[28], None);",
          "    assert_eq!(caller_explicit_slots[29], None);",
          "    assert_eq!(caller_explicit_slots[30], None);",
          "    assert_eq!(caller_explicit_slots[31], None);"
        ],
        "code": [
          "{",
          "    let slots = Slots(0b11111111111111111111111111111111); // non-empty and all slots set",
          "    let at = 15; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 32]; // length is 32",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "    assert_eq!(caller_explicit_slots[0], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[1], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[2], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[3], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[4], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[5], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[6], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[7], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[8], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[9], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[10], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[11], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[12], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[13], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[14], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[15], Some(NonMaxUsize::new(16)));",
          "    assert_eq!(caller_explicit_slots[16], None);",
          "    assert_eq!(caller_explicit_slots[17], None);",
          "    assert_eq!(caller_explicit_slots[18], None);",
          "    assert_eq!(caller_explicit_slots[19], None);",
          "    assert_eq!(caller_explicit_slots[20], None);",
          "    assert_eq!(caller_explicit_slots[21], None);",
          "    assert_eq!(caller_explicit_slots[22], None);",
          "    assert_eq!(caller_explicit_slots[23], None);",
          "    assert_eq!(caller_explicit_slots[24], None);",
          "    assert_eq!(caller_explicit_slots[25], None);",
          "    assert_eq!(caller_explicit_slots[26], None);",
          "    assert_eq!(caller_explicit_slots[27], None);",
          "    assert_eq!(caller_explicit_slots[28], None);",
          "    assert_eq!(caller_explicit_slots[29], None);",
          "    assert_eq!(caller_explicit_slots[30], None);",
          "    assert_eq!(caller_explicit_slots[31], None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots = Slots(2); // non-empty, sets slot 1",
          "    let at = 8; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 2]; // length is 2",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(caller_explicit_slots[0], None);",
          "    assert_eq!(caller_explicit_slots[1], Some(NonMaxUsize::new(8)));",
          "    assert_eq!(caller_explicit_slots.len(), 2);",
          "    assert!(slots.is_empty() == false);",
          "    assert!(slots.iter().next().is_some());",
          "    assert!(slots.iter().next().unwrap() >= caller_explicit_slots.len());",
          "    assert!(caller_explicit_slots[2..].iter().all(|&slot| slot.is_none()));"
        ],
        "code": [
          "{",
          "    let slots = Slots(2); // non-empty, sets slot 1",
          "    let at = 8; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 2]; // length is 2",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "    assert_eq!(caller_explicit_slots[0], None);",
          "    assert_eq!(caller_explicit_slots[1], Some(NonMaxUsize::new(8)));",
          "    assert_eq!(caller_explicit_slots.len(), 2);",
          "    assert!(slots.is_empty() == false);",
          "    assert!(slots.iter().next().is_some());",
          "    assert!(slots.iter().next().unwrap() >= caller_explicit_slots.len());",
          "    assert!(caller_explicit_slots[2..].iter().all(|&slot| slot.is_none()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots = Slots(4); // non-empty, sets slot 2",
          "    let at = 10; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 4]; // length is 4",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "}"
        ],
        "oracle": [
          "    caller_explicit_slots[0] should be None",
          "    caller_explicit_slots[1] should be None",
          "    caller_explicit_slots[2] should be Some(NonMaxUsize::new(10).unwrap())",
          "    caller_explicit_slots[3] should be None"
        ],
        "code": [
          "{",
          "    let slots = Slots(4); // non-empty, sets slot 2",
          "    let at = 10; // valid at",
          "    let mut caller_explicit_slots: Vec<Option<NonMaxUsize>> = vec![None; 4]; // length is 4",
          "    slots.apply(at, &mut caller_explicit_slots);",
          "    caller_explicit_slots[0] should be None",
          "    caller_explicit_slots[1] should be None",
          "    caller_explicit_slots[2] should be Some(NonMaxUsize::new(10).unwrap())",
          "    caller_explicit_slots[3] should be None",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]