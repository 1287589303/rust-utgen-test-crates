[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(\"\").unwrap();",
          "    let hay = \"\";",
          "    let _ = re.find_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"\\w+\").unwrap();",
          "    let hay = \"Hello world\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(!matches.it.is_empty());",
          "    ",
          "    let re = Regex::new(r\"\\d+\").unwrap();",
          "    let hay = \"123 456 789\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 3);",
          "    ",
          "    let re = Regex::new(r\"(?i)hello\").unwrap();",
          "    let hay = \"Hello hello HeLLo\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 3);",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
          "    let hay = \"This is a test\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 1);",
          "    ",
          "    let re = Regex::new(r\"\\w{13}\").unwrap();",
          "    let hay = \"Retroactively relinquishing\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 2);",
          "    ",
          "    let re = Regex::new(r\"\\s+\").unwrap();",
          "    let hay = \"Multiple    spaces\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(matches.it.count() > 0);",
          "    ",
          "    let re = Regex::new(r\"[aeiou]+\").unwrap();",
          "    let hay = \"Hello, world!\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 3);",
          "    ",
          "    let re = Regex::new(r\"[^a-zA-Z]+\").unwrap();",
          "    let hay = \"1234!@#$%^&*()\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 1);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(\"\").unwrap();",
          "    let hay = \"\";",
          "    let _ = re.find_iter(hay);",
          "    let re = Regex::new(r\"\\w+\").unwrap();",
          "    let hay = \"Hello world\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(!matches.it.is_empty());",
          "    ",
          "    let re = Regex::new(r\"\\d+\").unwrap();",
          "    let hay = \"123 456 789\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 3);",
          "    ",
          "    let re = Regex::new(r\"(?i)hello\").unwrap();",
          "    let hay = \"Hello hello HeLLo\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 3);",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
          "    let hay = \"This is a test\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 1);",
          "    ",
          "    let re = Regex::new(r\"\\w{13}\").unwrap();",
          "    let hay = \"Retroactively relinquishing\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 2);",
          "    ",
          "    let re = Regex::new(r\"\\s+\").unwrap();",
          "    let hay = \"Multiple    spaces\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(matches.it.count() > 0);",
          "    ",
          "    let re = Regex::new(r\"[aeiou]+\").unwrap();",
          "    let hay = \"Hello, world!\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 3);",
          "    ",
          "    let re = Regex::new(r\"[^a-zA-Z]+\").unwrap();",
          "    let hay = \"1234!@#$%^&*()\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert_eq!(matches.it.count(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\w\").unwrap();",
          "    let hay = \"a\";",
          "    let _ = re.find_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"\\w\").unwrap();",
          "    let hay = \"a\";",
          "    let matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(matches.it.next().is_some());",
          "    assert_eq!(matches.it.next().is_none());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\w\").unwrap();",
          "    let hay = \"a\";",
          "    let _ = re.find_iter(hay);",
          "    let re = Regex::new(r\"\\w\").unwrap();",
          "    let hay = \"a\";",
          "    let matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(matches.it.next().is_some());",
          "    assert_eq!(matches.it.next().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkla\";",
          "    let _ = re.find_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkla\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(matches.it.is_empty());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkla\";",
          "    let _ = re.find_iter(hay);",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkla\";",
          "    let matches: Matches = re.find_iter(hay);",
          "    assert_eq!(matches.haystack, hay);",
          "    assert!(matches.it.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkl abcdefghijkla abcdefghijklmnop\";",
          "    let _ = re.find_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkl abcdefghijkla abcdefghijklmnop\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, vec![\"abcdefghijkla\", \"abcdefghijklmnop\"]);",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"This string has no thirteen character words.\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, Vec::<&str>::new());",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, Vec::<&str>::new());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkl abcdefghijkla abcdefghijklmnop\";",
          "    let _ = re.find_iter(hay);",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"abcdefghijkl abcdefghijkla abcdefghijklmnop\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, vec![\"abcdefghijkla\", \"abcdefghijklmnop\"]);",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"This string has no thirteen character words.\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, Vec::<&str>::new());",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, Vec::<&str>::new());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"short\";",
          "    let _ = re.find_iter(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_matches.haystack, \"short\");",
          "    assert!(_matches.it.is_empty());",
          "    ",
          "    let hay = \"Retroactively relinquishing remunerations is reprehensible.\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, vec![",
          "    \"Retroactively\",",
          "    \"relinquishing\",",
          "    \"remunerations\",",
          "    \"reprehensible\",",
          "    ]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"short\";",
          "    let _ = re.find_iter(hay);",
          "    assert_eq!(_matches.haystack, \"short\");",
          "    assert!(_matches.it.is_empty());",
          "    ",
          "    let hay = \"Retroactively relinquishing remunerations is reprehensible.\";",
          "    let matches: Vec<_> = re.find_iter(hay).map(|m| m.as_str()).collect();",
          "    assert_eq!(matches, vec![",
          "    \"Retroactively\",",
          "    \"relinquishing\",",
          "    \"remunerations\",",
          "    \"reprehensible\",",
          "    ]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"\";",
          "    let _ = re.find_iter(hay);",
          "}"
        ],
        "oracle": [
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"\";",
          "    let result = re.find_iter(hay);",
          "    assert_eq!(result.haystack, hay);",
          "    assert!(result.it.is_empty());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"\";",
          "    let _ = re.find_iter(hay);",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"\";",
          "    let result = re.find_iter(hay);",
          "    assert_eq!(result.haystack, hay);",
          "    assert!(result.it.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"thisstringhasmorethan13characters\";",
          "    let _ = re.find_iter(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find_iter(\"thisstringhasmorethan13characters\").haystack, \"thisstringhasmorethan13characters\");",
          "    assert!(re.find_iter(\"thisstringhasmorethan13characters\").it.next().is_none());",
          "    assert!(re.find_iter(\"\").it.next().is_none());",
          "    assert_eq!(re.find_iter(\"exactlythirteen\").it.next().unwrap().as_str(), \"exactlythirteen\");",
          "    assert_eq!(re.find_iter(\"abc twelve thirteen thirteenth\").it.count(), 1);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = \"thisstringhasmorethan13characters\";",
          "    let _ = re.find_iter(hay);",
          "    assert_eq!(re.find_iter(\"thisstringhasmorethan13characters\").haystack, \"thisstringhasmorethan13characters\");",
          "    assert!(re.find_iter(\"thisstringhasmorethan13characters\").it.next().is_none());",
          "    assert!(re.find_iter(\"\").it.next().is_none());",
          "    assert_eq!(re.find_iter(\"exactlythirteen\").it.next().unwrap().as_str(), \"exactlythirteen\");",
          "    assert_eq!(re.find_iter(\"abc twelve thirteen thirteenth\").it.count(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]