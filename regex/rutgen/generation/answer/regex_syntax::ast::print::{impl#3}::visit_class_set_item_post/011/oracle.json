[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let item = ast::ClassSetItem::Empty(ast::Span::new(0, 0));",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    let result = writer.output;",
          "    assert_eq!(result, \"\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let item = ast::ClassSetItem::Empty(ast::Span::new(0, 0));",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    let result = writer.output;",
          "    assert_eq!(result, \"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let span = ast::Span::new(0, 1);",
          "    let literal = ast::Literal {",
          "        span,",
          "        kind: ast::LiteralKind::Verbatim,",
          "        c: 'a',",
          "    };",
          "    let item = ast::ClassSetItem::Literal(literal);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Empty(span)).unwrap();",
          "    assert_eq!(writer.output, \"\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let span = ast::Span::new(0, 1);",
          "    let literal = ast::Literal {",
          "        span,",
          "        kind: ast::LiteralKind::Verbatim,",
          "        c: 'a',",
          "    };",
          "    let item = ast::ClassSetItem::Literal(literal);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Empty(span)).unwrap();",
          "    assert_eq!(writer.output, \"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let span = ast::Span::new(0, 2);",
          "    let start = ast::Literal {",
          "        span,",
          "        kind: ast::LiteralKind::Verbatim,",
          "        c: 'a',",
          "    };",
          "    let end = ast::Literal {",
          "        span,",
          "        kind: ast::LiteralKind::Verbatim,",
          "        c: 'z',",
          "    };",
          "    let item = ast::ClassSetItem::Range(ast::ClassSetRange { span, start, end });",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, \"a-z\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let span = ast::Span::new(0, 2);",
          "    let start = ast::Literal {",
          "        span,",
          "        kind: ast::LiteralKind::Verbatim,",
          "        c: 'a',",
          "    };",
          "    let end = ast::Literal {",
          "        span,",
          "        kind: ast::LiteralKind::Verbatim,",
          "        c: 'z',",
          "    };",
          "    let item = ast::ClassSetItem::Range(ast::ClassSetRange { span, start, end });",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    assert_eq!(writer.output, \"a-z\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ascii_class = ast::ClassAscii {",
          "        span: ast::Span::new(0, 1),",
          "        kind: ast::ClassAsciiKind::Alnum,",
          "        negated: false,",
          "    };",
          "    let item = ast::ClassSetItem::Ascii(ascii_class);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, \"[:alnum:]\");",
          "    let item_empty = ast::ClassSetItem::Empty(ast::Span::new(0, 1));",
          "    let result_empty = writer.visit_class_set_item_post(&item_empty);",
          "    assert!(result_empty.is_ok());",
          "    assert_eq!(result_empty.unwrap(), Ok(()));"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let ascii_class = ast::ClassAscii {",
          "        span: ast::Span::new(0, 1),",
          "        kind: ast::ClassAsciiKind::Alnum,",
          "        negated: false,",
          "    };",
          "    let item = ast::ClassSetItem::Ascii(ascii_class);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    assert_eq!(writer.output, \"[:alnum:]\");",
          "    let item_empty = ast::ClassSetItem::Empty(ast::Span::new(0, 1));",
          "    let result_empty = writer.visit_class_set_item_post(&item_empty);",
          "    assert!(result_empty.is_ok());",
          "    assert_eq!(result_empty.unwrap(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let unicode_class = ast::ClassUnicode {",
          "        span: ast::Span::new(0, 1),",
          "        negated: false,",
          "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
          "    };",
          "    let item = ast::ClassSetItem::Unicode(unicode_class);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "}"
        ],
        "oracle": [
          "    let item = ast::ClassSetItem::Empty(ast::Span::new(0, 0));",
          "    assert_eq!(writer.visit_class_set_item_post(&item), Ok(()));"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let unicode_class = ast::ClassUnicode {",
          "        span: ast::Span::new(0, 1),",
          "        negated: false,",
          "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
          "    };",
          "    let item = ast::ClassSetItem::Unicode(unicode_class);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    let item = ast::ClassSetItem::Empty(ast::Span::new(0, 0));",
          "    assert_eq!(writer.visit_class_set_item_post(&item), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let perl_class = ast::ClassPerl {",
          "        span: ast::Span::new(0, 1),",
          "        kind: ast::ClassPerlKind::Digit,",
          "        negated: false,",
          "    };",
          "    let item = ast::ClassSetItem::Perl(perl_class);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.visit_class_set_item_post(&ast::ClassSetItem::Empty(ast::Span::new(0, 0))).unwrap(), Ok(()));"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let perl_class = ast::ClassPerl {",
          "        span: ast::Span::new(0, 1),",
          "        kind: ast::ClassPerlKind::Digit,",
          "        negated: false,",
          "    };",
          "    let item = ast::ClassSetItem::Perl(perl_class);",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    assert_eq!(writer.visit_class_set_item_post(&ast::ClassSetItem::Empty(ast::Span::new(0, 0))).unwrap(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let bracketed_class = ast::ClassBracketed {",
          "        span: ast::Span::new(0, 1),",
          "        negated: false,",
          "        kind: ast::ClassSet::Normal,",
          "    };",
          "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed_class));",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Empty(ast::Span::new(0, 1))).unwrap();",
          "    assert_eq!(writer.output, \"\");",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Literal(ast::Literal { span: ast::Span::new(0, 1), kind: ast::LiteralKind::Verbatim, c: 'a' })).unwrap();",
          "    assert_eq!(writer.output, \"a\");",
          "    writer.output.clear();",
          "    let range = ast::ClassSetRange { span: ast::Span::new(0, 2), start: ast::Literal { span: ast::Span::new(0, 1), kind: ast::LiteralKind::Verbatim, c: 'a' }, end: ast::Literal { span: ast::Span::new(1, 2), kind: ast::LiteralKind::Verbatim, c: 'b' }};",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Range(range)).unwrap();",
          "    assert_eq!(writer.output, \"a-b\");",
          "    writer.output.clear();",
          "    let ascii_class = ast::ClassAscii { span: ast::Span::new(0, 1), kind: ast::ClassAsciiKind::Alnum, negated: false };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Ascii(ascii_class)).unwrap();",
          "    assert_eq!(writer.output, \"[:alnum:]\");",
          "    writer.output.clear();",
          "    let unicode_class = ast::ClassUnicode { span: ast::Span::new(0, 1), negated: false, kind: ast::ClassUnicodeKind::OneLetter('a') };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Unicode(unicode_class)).unwrap();",
          "    assert_eq!(writer.output, r\"\\pa\");",
          "    writer.output.clear();",
          "    let perl_class = ast::ClassPerl { span: ast::Span::new(0, 1), kind: ast::ClassPerlKind::Digit, negated: false };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Perl(perl_class)).unwrap();",
          "    assert_eq!(writer.output, r\"\\d\");",
          "    writer.output.clear();",
          "    let bracketed_class = ast::ClassBracketed { span: ast::Span::new(0, 1), negated: false, kind: ast::ClassSet::Normal };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Bracketed(Box::new(bracketed_class))).unwrap();",
          "    assert_eq!(writer.output, \"]\");",
          "    writer.output.clear();",
          "    let union_class = ast::ClassSetUnion;",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Union(union_class)).unwrap();",
          "    assert_eq!(writer.output, \"\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter { output: String::new() };",
          "    let bracketed_class = ast::ClassBracketed {",
          "        span: ast::Span::new(0, 1),",
          "        negated: false,",
          "        kind: ast::ClassSet::Normal,",
          "    };",
          "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed_class));",
          "    writer.visit_class_set_item_post(&item).unwrap();",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Empty(ast::Span::new(0, 1))).unwrap();",
          "    assert_eq!(writer.output, \"\");",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Literal(ast::Literal { span: ast::Span::new(0, 1), kind: ast::LiteralKind::Verbatim, c: 'a' })).unwrap();",
          "    assert_eq!(writer.output, \"a\");",
          "    writer.output.clear();",
          "    let range = ast::ClassSetRange { span: ast::Span::new(0, 2), start: ast::Literal { span: ast::Span::new(0, 1), kind: ast::LiteralKind::Verbatim, c: 'a' }, end: ast::Literal { span: ast::Span::new(1, 2), kind: ast::LiteralKind::Verbatim, c: 'b' }};",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Range(range)).unwrap();",
          "    assert_eq!(writer.output, \"a-b\");",
          "    writer.output.clear();",
          "    let ascii_class = ast::ClassAscii { span: ast::Span::new(0, 1), kind: ast::ClassAsciiKind::Alnum, negated: false };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Ascii(ascii_class)).unwrap();",
          "    assert_eq!(writer.output, \"[:alnum:]\");",
          "    writer.output.clear();",
          "    let unicode_class = ast::ClassUnicode { span: ast::Span::new(0, 1), negated: false, kind: ast::ClassUnicodeKind::OneLetter('a') };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Unicode(unicode_class)).unwrap();",
          "    assert_eq!(writer.output, r\"\\pa\");",
          "    writer.output.clear();",
          "    let perl_class = ast::ClassPerl { span: ast::Span::new(0, 1), kind: ast::ClassPerlKind::Digit, negated: false };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Perl(perl_class)).unwrap();",
          "    assert_eq!(writer.output, r\"\\d\");",
          "    writer.output.clear();",
          "    let bracketed_class = ast::ClassBracketed { span: ast::Span::new(0, 1), negated: false, kind: ast::ClassSet::Normal };",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Bracketed(Box::new(bracketed_class))).unwrap();",
          "    assert_eq!(writer.output, \"]\");",
          "    writer.output.clear();",
          "    let union_class = ast::ClassSetUnion;",
          "    writer.visit_class_set_item_post(&ast::ClassSetItem::Union(union_class)).unwrap();",
          "    assert_eq!(writer.output, \"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]