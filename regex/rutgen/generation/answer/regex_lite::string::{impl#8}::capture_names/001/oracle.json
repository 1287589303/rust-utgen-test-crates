[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA::new(Config::default(), r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"a\")));",
          "    assert_eq!(names.next(), Some(Some(\"b\")));",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"c\")));",
          "    assert_eq!(names.next(), None);"
        ],
        "code": [
          "{",
          "    let nfa = NFA::new(Config::default(), r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"a\")));",
          "    assert_eq!(names.next(), Some(Some(\"b\")));",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"c\")));",
          "    assert_eq!(names.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA::new(Config::default(), \"\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), None);",
          "    ",
          "    let nfa = NFA::new(Config::default(), r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"a\")));",
          "    assert_eq!(names.next(), Some(Some(\"b\")));",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"c\")));",
          "    assert_eq!(names.next(), None);",
          "    ",
          "    let nfa = NFA::new(Config::default(), r\"[^\\s\\S]\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), None);"
        ],
        "code": [
          "{",
          "    let nfa = NFA::new(Config::default(), \"\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), None);",
          "    ",
          "    let nfa = NFA::new(Config::default(), r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"a\")));",
          "    assert_eq!(names.next(), Some(Some(\"b\")));",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"c\")));",
          "    assert_eq!(names.next(), None);",
          "    ",
          "    let nfa = NFA::new(Config::default(), r\"[^\\s\\S]\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA::new(Config::default(), r\"[^\\s\\S]\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(names.next(), Some(None));",
          "    let re = Regex::new(r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\").unwrap();",
          "    let mut names = re.capture_names();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"a\")));",
          "    assert_eq!(names.next(), Some(Some(\"b\")));",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"c\")));",
          "    assert_eq!(names.next(), None);",
          "    let re_empty = Regex::new(r\"\").unwrap();",
          "    let mut names_empty = re_empty.capture_names();",
          "    assert_eq!(names_empty.next(), Some(None));",
          "    assert_eq!(names_empty.next(), None);",
          "    let re_non_matching = Regex::new(r\"[^\\s\\S]\").unwrap();",
          "    let mut names_non_matching = re_non_matching.capture_names();",
          "    assert_eq!(names_non_matching.next(), Some(None));",
          "    assert_eq!(names_non_matching.next(), None);"
        ],
        "code": [
          "{",
          "    let nfa = NFA::new(Config::default(), r\"[^\\s\\S]\".to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa);",
          "    let regex = Regex { pikevm: Arc::new(pikevm), pool: CachePool::new() };",
          "    let mut names = regex.capture_names();",
          "    let _ = names.next();",
          "    let _ = names.next();",
          "    assert_eq!(names.next(), Some(None));",
          "    let re = Regex::new(r\"(?<a>.(?<b>.))(.)(?:.)(?<c>.)\").unwrap();",
          "    let mut names = re.capture_names();",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"a\")));",
          "    assert_eq!(names.next(), Some(Some(\"b\")));",
          "    assert_eq!(names.next(), Some(None));",
          "    assert_eq!(names.next(), Some(Some(\"c\")));",
          "    assert_eq!(names.next(), None);",
          "    let re_empty = Regex::new(r\"\").unwrap();",
          "    let mut names_empty = re_empty.capture_names();",
          "    assert_eq!(names_empty.next(), Some(None));",
          "    assert_eq!(names_empty.next(), None);",
          "    let re_non_matching = Regex::new(r\"[^\\s\\S]\").unwrap();",
          "    let mut names_non_matching = re_non_matching.capture_names();",
          "    assert_eq!(names_non_matching.next(), Some(None));",
          "    assert_eq!(names_non_matching.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]