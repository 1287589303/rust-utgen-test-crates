[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "        Hir::literal([b'd']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c']), Hir::literal([b'd']),]);",
          "    let expected = Hir::literal([b'a', b'b', b'c', b'd']);",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "        Hir::literal([b'd']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c']), Hir::literal([b'd']),]);",
          "    let expected = Hir::literal([b'a', b'b', b'c', b'd']);",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'x']),",
          "            Hir::literal([b'y']),",
          "        ]),",
          "        Hir::literal([b'z']),",
          "        Hir::literal([b'w']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "}"
        ],
        "oracle": [
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'x']), Hir::literal([b'y'])]), Hir::literal([b'z']), Hir::literal([b'w'])]);",
          "    let expected = Hir::literal(\"xyzw\".as_bytes());",
          "    assert_eq!(expected, hir);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'x', b'y']), Hir::literal(vec![b'z']), Hir::literal(vec![b'w'])]));",
          "    assert!(!new.is_empty());",
          "    assert_eq!(new.len(), 1);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'x']),",
          "            Hir::literal([b'y']),",
          "        ]),",
          "        Hir::literal([b'z']),",
          "        Hir::literal([b'w']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'x']), Hir::literal([b'y'])]), Hir::literal([b'z']), Hir::literal([b'w'])]);",
          "    let expected = Hir::literal(\"xyzw\".as_bytes());",
          "    assert_eq!(expected, hir);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'x', b'y']), Hir::literal(vec![b'z']), Hir::literal(vec![b'w'])]));",
          "    assert!(!new.is_empty());",
          "    assert_eq!(new.len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'h']),",
          "        Hir::empty(),",
          "        Hir::literal([b'i']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'h']), Hir::literal([b'i'])]));",
          "    assert!(matches!(hir.props, Properties(_)));",
          "    assert_eq!(hir.props.literal, true);",
          "    assert!(hir.props.minimum_len.is_some());",
          "    assert_eq!(hir.props.maximum_len, Some(2));"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'h']),",
          "        Hir::empty(),",
          "        Hir::literal([b'i']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'h']), Hir::literal([b'i'])]));",
          "    assert!(matches!(hir.props, Properties(_)));",
          "    assert_eq!(hir.props.literal, true);",
          "    assert!(hir.props.minimum_len.is_some());",
          "    assert_eq!(hir.props.maximum_len, Some(2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::empty(),",
          "        Hir::empty(),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::concat(vec![Hir::literal([b'a'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'a'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::empty()]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'a'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b', b'c'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b', b'c'])]));",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a'])]), Hir::literal([b'b'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::empty()])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'a'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::empty()]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b'])])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c']), Hir::literal([b'd']), Hir::literal([b'e'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b', b'c', b'd', b'e'])]));"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::empty(),",
          "        Hir::empty(),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "    let hir = Hir::concat(vec![Hir::literal([b'a'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'a'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::empty()]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'a'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b', b'c'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b', b'c'])]));",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a'])]), Hir::literal([b'b'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::empty()])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'a'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::empty()]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b'])])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b'])]));",
          "    let hir = Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c']), Hir::literal([b'd']), Hir::literal([b'e'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'a', b'b', b'c', b'd', b'e'])]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'1']),",
          "        Hir::concat(vec![",
          "            Hir::literal([b'2']),",
          "            Hir::literal([b'3']),",
          "        ]),",
          "        Hir::literal([b'4']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "}"
        ],
        "oracle": [
          "    Hir::literal([b'1']);",
          "    Hir::concat(vec![Hir::literal([b'2']), Hir::literal([b'3'])]);",
          "    Hir::literal([b'4']);",
          "    let hir = Hir::concat(vec![Hir::literal([b'1']), Hir::concat(vec![Hir::literal([b'2']), Hir::literal([b'3'])]), Hir::literal([b'4'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'1']), Hir::literal(vec![b'2', b'3']), Hir::literal(vec![b'4'])]));",
          "    assert!(new.len() == 1);",
          "    assert!(new.is_empty() == false);",
          "    assert!(let Some(prior_bytes) = prior_lit.take());"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'1']),",
          "        Hir::concat(vec![",
          "            Hir::literal([b'2']),",
          "            Hir::literal([b'3']),",
          "        ]),",
          "        Hir::literal([b'4']),",
          "    ]);",
          "    let _ = hir; // Placeholder for assertions",
          "    Hir::literal([b'1']);",
          "    Hir::concat(vec![Hir::literal([b'2']), Hir::literal([b'3'])]);",
          "    Hir::literal([b'4']);",
          "    let hir = Hir::concat(vec![Hir::literal([b'1']), Hir::concat(vec![Hir::literal([b'2']), Hir::literal([b'3'])]), Hir::literal([b'4'])]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'1']), Hir::literal(vec![b'2', b'3']), Hir::literal(vec![b'4'])]));",
          "    assert!(new.len() == 1);",
          "    assert!(new.is_empty() == false);",
          "    assert!(let Some(prior_bytes) = prior_lit.take());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]