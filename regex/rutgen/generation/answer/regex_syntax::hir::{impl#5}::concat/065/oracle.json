[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal(vec![b'a']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'b']),",
          "            Hir::literal(vec![b'c']),",
          "        ]),",
          "        Hir::literal(vec![b'x']),",
          "        Hir::literal(vec![b'y']),",
          "        Hir::literal(vec![b'z']),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::concat(vec![",
          "    Hir::literal(vec![b'a']),",
          "    Hir::concat(vec![",
          "    Hir::literal(vec![b'b']),",
          "    Hir::literal(vec![b'c']),",
          "    ]),",
          "    Hir::literal(vec![b'x']),",
          "    Hir::literal(vec![b'y']),",
          "    Hir::literal(vec![b'z']),",
          "    ]);",
          "    let expected = Hir::literal(\"abcxyz\".as_bytes());",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal(vec![b'a']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'b']),",
          "            Hir::literal(vec![b'c']),",
          "        ]),",
          "        Hir::literal(vec![b'x']),",
          "        Hir::literal(vec![b'y']),",
          "        Hir::literal(vec![b'z']),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "    let hir = Hir::concat(vec![",
          "    Hir::literal(vec![b'a']),",
          "    Hir::concat(vec![",
          "    Hir::literal(vec![b'b']),",
          "    Hir::literal(vec![b'c']),",
          "    ]),",
          "    Hir::literal(vec![b'x']),",
          "    Hir::literal(vec![b'y']),",
          "    Hir::literal(vec![b'z']),",
          "    ]);",
          "    let expected = Hir::literal(\"abcxyz\".as_bytes());",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal(vec![b'l', b'm', b'n']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'o']),",
          "            Hir::literal(vec![b'p']),",
          "        ]),",
          "        Hir::literal(vec![b'q', b'r', b's', b't']),",
          "        Hir::literal(vec![b'u']),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Hir::literal(vec![b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't', b'u']), hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert!(matches!(hir.props.0.maximum_len, Some(len) if len > 0));",
          "    assert!(matches!(hir.props.0.minimum_len, Some(len) if len > 0));",
          "    assert!(!hir.props.0.literal);",
          "    assert!(hir.props.0.explicit_captures_len > 0);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal(vec![b'l', b'm', b'n']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'o']),",
          "            Hir::literal(vec![b'p']),",
          "        ]),",
          "        Hir::literal(vec![b'q', b'r', b's', b't']),",
          "        Hir::literal(vec![b'u']),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "    assert_eq!(Hir::literal(vec![b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't', b'u']), hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert!(matches!(hir.props.0.maximum_len, Some(len) if len > 0));",
          "    assert!(matches!(hir.props.0.minimum_len, Some(len) if len > 0));",
          "    assert!(!hir.props.0.literal);",
          "    assert!(hir.props.0.explicit_captures_len > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'1']),",
          "            Hir::literal(vec![b'2']),",
          "        ]),",
          "        Hir::literal(vec![b'3']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'4']),",
          "            Hir::literal(vec![b'5']),",
          "        ]),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::concat(vec![",
          "    Hir::concat(vec![",
          "    Hir::literal(vec![b'1']),",
          "    Hir::literal(vec![b'2']),",
          "    ]),",
          "    Hir::literal(vec![b'3']),",
          "    Hir::concat(vec![",
          "    Hir::literal(vec![b'4']),",
          "    Hir::literal(vec![b'5']),",
          "    ]),",
          "    ]);",
          "    let expected = Hir::literal(vec![b'1', b'2', b'3', b'4', b'5']);",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'1']),",
          "            Hir::literal(vec![b'2']),",
          "        ]),",
          "        Hir::literal(vec![b'3']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'4']),",
          "            Hir::literal(vec![b'5']),",
          "        ]),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "    let hir = Hir::concat(vec![",
          "    Hir::concat(vec![",
          "    Hir::literal(vec![b'1']),",
          "    Hir::literal(vec![b'2']),",
          "    ]),",
          "    Hir::literal(vec![b'3']),",
          "    Hir::concat(vec![",
          "    Hir::literal(vec![b'4']),",
          "    Hir::literal(vec![b'5']),",
          "    ]),",
          "    ]);",
          "    let expected = Hir::literal(vec![b'1', b'2', b'3', b'4', b'5']);",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal(vec![b'a']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'b']),",
          "            Hir::literal(vec![b'c']),",
          "        ]),",
          "        Hir::literal(vec![b'd']),",
          "        Hir::literal(vec![b'e']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'f']),",
          "            Hir::literal(vec![b'g']),",
          "            Hir::literal(vec![b'h']),",
          "        ]),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "}"
        ],
        "oracle": [
          "    let expected = Hir::literal(vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h']);",
          "    assert_eq!(expected, hir);",
          "    let prior_bytes = vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h'];",
          "    assert!(prior_bytes.len() > 0);",
          "    assert!(hir.kind == HirKind::Concat(vec![Hir::literal(vec![b'a']),",
          "    Hir::literal(vec![b'b']),",
          "    Hir::literal(vec![b'c']),",
          "    Hir::literal(vec![b'd']),",
          "    Hir::literal(vec![b'e']),",
          "    Hir::literal(vec![b'f']),",
          "    Hir::literal(vec![b'g']),",
          "    Hir::literal(vec![b'h'])]));",
          "    assert!(hir.kind != HirKind::Empty);",
          "    assert!(hir.kind != HirKind::Alternation(vec![]));"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal(vec![b'a']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'b']),",
          "            Hir::literal(vec![b'c']),",
          "        ]),",
          "        Hir::literal(vec![b'd']),",
          "        Hir::literal(vec![b'e']),",
          "        Hir::concat(vec![",
          "            Hir::literal(vec![b'f']),",
          "            Hir::literal(vec![b'g']),",
          "            Hir::literal(vec![b'h']),",
          "        ]),",
          "    ]);",
          "    let _ = hir; // Placeholder for function invocation",
          "    let expected = Hir::literal(vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h']);",
          "    assert_eq!(expected, hir);",
          "    let prior_bytes = vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h'];",
          "    assert!(prior_bytes.len() > 0);",
          "    assert!(hir.kind == HirKind::Concat(vec![Hir::literal(vec![b'a']),",
          "    Hir::literal(vec![b'b']),",
          "    Hir::literal(vec![b'c']),",
          "    Hir::literal(vec![b'd']),",
          "    Hir::literal(vec![b'e']),",
          "    Hir::literal(vec![b'f']),",
          "    Hir::literal(vec![b'g']),",
          "    Hir::literal(vec![b'h'])]));",
          "    assert!(hir.kind != HirKind::Empty);",
          "    assert!(hir.kind != HirKind::Alternation(vec![]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]