[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::literal([b'b']),",
          "            Hir::literal([b'c']),",
          "        ]),",
          "    ]);",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Hir::concat(vec![Hir::literal(vec![b'a', b'b', b'c'])]), _result);",
          "    assert!(matches!(_result.kind, HirKind::Concat(_)));",
          "    assert!(_result.props.is_some());",
          "    assert_ne!(Hir::empty(), _result);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::literal([b'b']),",
          "            Hir::literal([b'c']),",
          "        ]),",
          "    ]);",
          "    let _result = hir;",
          "    assert_eq!(Hir::concat(vec![Hir::literal(vec![b'a', b'b', b'c'])]), _result);",
          "    assert!(matches!(_result.kind, HirKind::Concat(_)));",
          "    assert!(_result.props.is_some());",
          "    assert_ne!(Hir::empty(), _result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::literal([b'b']),",
          "        ]),",
          "        Hir::concat(vec![",
          "            Hir::literal([b'c']),",
          "            Hir::literal([b'd']),",
          "        ]),",
          "    ]);",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]), Hir::concat(vec![Hir::literal([b'c']), Hir::literal([b'd'])])]);",
          "    let expected = Hir::literal(\"ab\".as_bytes().to_vec().into_iter().chain(\"cd\".as_bytes().to_vec()).collect::<Vec<u8>>());",
          "    assert_eq!(expected, hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert!(matches!(hir.props, Properties(_)));",
          "    assert!(hir.props.is_literal());",
          "    assert!(hir.props.minimum_len().map_or(false, |len| len == 4));",
          "    assert!(hir.props.maximum_len().map_or(false, |len| len == 4));"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::literal([b'b']),",
          "        ]),",
          "        Hir::concat(vec![",
          "            Hir::literal([b'c']),",
          "            Hir::literal([b'd']),",
          "        ]),",
          "    ]);",
          "    let _result = hir;",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]), Hir::concat(vec![Hir::literal([b'c']), Hir::literal([b'd'])])]);",
          "    let expected = Hir::literal(\"ab\".as_bytes().to_vec().into_iter().chain(\"cd\".as_bytes().to_vec()).collect::<Vec<u8>>());",
          "    assert_eq!(expected, hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert!(matches!(hir.props, Properties(_)));",
          "    assert!(hir.props.is_literal());",
          "    assert!(hir.props.minimum_len().map_or(false, |len| len == 4));",
          "    assert!(hir.props.maximum_len().map_or(false, |len| len == 4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::literal([b'b']),",
          "            Hir::literal([b'c']),",
          "        ]),",
          "        Hir::concat(vec![",
          "            Hir::literal([b'd']),",
          "            Hir::literal([b'e']),",
          "        ]),",
          "    ]);",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c']),]), Hir::concat(vec![Hir::literal([b'd']), Hir::literal([b'e']),]),]);",
          "    let expected = Hir::literal(\"abcde\".as_bytes());",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::literal([b'b']),",
          "            Hir::literal([b'c']),",
          "        ]),",
          "        Hir::concat(vec![",
          "            Hir::literal([b'd']),",
          "            Hir::literal([b'e']),",
          "        ]),",
          "    ]);",
          "    let _result = hir;",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c']),]), Hir::concat(vec![Hir::literal([b'd']), Hir::literal([b'e']),]),]);",
          "    let expected = Hir::literal(\"abcde\".as_bytes());",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::empty(),",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "    ]);",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::concat(vec![Hir::empty(), Hir::literal([b'a']), Hir::literal([b'b'])]);",
          "    assert_eq!(Hir::literal(b\"ab\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]), Hir::literal([b'c'])]);",
          "    assert_eq!(Hir::literal(b\"abc\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::literal([b'x']), Hir::concat(vec![Hir::literal([b'y']), Hir::literal([b'z'])])]);",
          "    assert_eq!(Hir::literal(b\"xyz\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::literal([b'1']), Hir::literal([b'2']), Hir::literal([b'3'])]);",
          "    assert_eq!(Hir::literal(b\"123\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'α']), Hir::literal([b'β'])]), Hir::literal([b'γ'])]);",
          "    assert_eq!(Hir::literal(b\"αγ\".to_vec()), _result);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::empty(),",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "    ]);",
          "    let _result = hir;",
          "    let hir = Hir::concat(vec![Hir::empty(), Hir::literal([b'a']), Hir::literal([b'b'])]);",
          "    assert_eq!(Hir::literal(b\"ab\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]), Hir::literal([b'c'])]);",
          "    assert_eq!(Hir::literal(b\"abc\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::literal([b'x']), Hir::concat(vec![Hir::literal([b'y']), Hir::literal([b'z'])])]);",
          "    assert_eq!(Hir::literal(b\"xyz\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::literal([b'1']), Hir::literal([b'2']), Hir::literal([b'3'])]);",
          "    assert_eq!(Hir::literal(b\"123\".to_vec()), _result);",
          "    let hir = Hir::concat(vec![Hir::concat(vec![Hir::literal([b'α']), Hir::literal([b'β'])]), Hir::literal([b'γ'])]);",
          "    assert_eq!(Hir::literal(b\"αγ\".to_vec()), _result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c'])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]), Hir::literal([b'c'])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::empty(), Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c'])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::empty(), Hir::literal([b'c'])])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a'])]), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    let _result = hir;",
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c'])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::literal([b'b'])]), Hir::literal([b'c'])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::empty(), Hir::literal([b'a']), Hir::literal([b'b']), Hir::literal([b'c'])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::empty(), Hir::literal([b'c'])])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a'])]), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    assert_eq!(expected, _result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])]),",
          "        ]),",
          "        Hir::literal([b'd']),",
          "    ]);",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]), Hir::literal([b'd'])]);",
          "    assert_eq!(expected, _result);",
          "    let expected = Hir::literal(\"abcd\".as_bytes());",
          "    let subs: Vec<Hir> = vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])]), Hir::literal([b'd'])];",
          "    let new: Vec<Hir> = vec![Hir::literal([b'a']), Hir::literal([b'b', b'c']), Hir::literal([b'd'])];",
          "    assert_eq!(new.len(), 3);",
          "    assert_eq!(new.is_empty(), false);",
          "    assert_eq!(HirKind::Concat(new), _result.kind);",
          "    assert_eq!(Properties::concat(&new), _result.props);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal([b'a']),",
          "            Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])]),",
          "        ]),",
          "        Hir::literal([b'd']),",
          "    ]);",
          "    let _result = hir;",
          "    Hir::concat(vec![Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])])]), Hir::literal([b'd'])]);",
          "    assert_eq!(expected, _result);",
          "    let expected = Hir::literal(\"abcd\".as_bytes());",
          "    let subs: Vec<Hir> = vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])]), Hir::literal([b'd'])];",
          "    let new: Vec<Hir> = vec![Hir::literal([b'a']), Hir::literal([b'b', b'c']), Hir::literal([b'd'])];",
          "    assert_eq!(new.len(), 3);",
          "    assert_eq!(new.is_empty(), false);",
          "    assert_eq!(HirKind::Concat(new), _result.kind);",
          "    assert_eq!(Properties::concat(&new), _result.props);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]