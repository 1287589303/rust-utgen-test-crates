[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir1 = Hir::literal([b'a']);",
          "    let hir2 = Hir::literal([b'b']);",
          "    let hir3 = Hir::literal([b'c']);",
          "    let hir4 = Hir::literal([b'd']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        hir1,",
          "        Hir::concat(vec![",
          "            hir2,",
          "            hir3,",
          "        ]),",
          "        hir4,",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])]), Hir::literal([b'd'])]);",
          "    let expected = Hir::literal(\"abcd\".as_bytes());",
          "    assert_eq!(expected, hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert_eq!(hir.props.explicit_captures_len, 0);",
          "    assert!(hir.props.is_literal());",
          "    assert!(hir.props.minimum_len.is_some());",
          "    assert!(hir.props.maximum_len.is_some());",
          "    assert_eq!(hir.props.minimum_len.unwrap(), 4);",
          "    assert_eq!(hir.props.maximum_len.unwrap(), 4);"
        ],
        "code": [
          "{",
          "    let hir1 = Hir::literal([b'a']);",
          "    let hir2 = Hir::literal([b'b']);",
          "    let hir3 = Hir::literal([b'c']);",
          "    let hir4 = Hir::literal([b'd']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        hir1,",
          "        Hir::concat(vec![",
          "            hir2,",
          "            hir3,",
          "        ]),",
          "        hir4,",
          "    ]);",
          "    Hir::concat(vec![Hir::literal([b'a']), Hir::concat(vec![Hir::literal([b'b']), Hir::literal([b'c'])]), Hir::literal([b'd'])]);",
          "    let expected = Hir::literal(\"abcd\".as_bytes());",
          "    assert_eq!(expected, hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert_eq!(hir.props.explicit_captures_len, 0);",
          "    assert!(hir.props.is_literal());",
          "    assert!(hir.props.minimum_len.is_some());",
          "    assert!(hir.props.maximum_len.is_some());",
          "    assert_eq!(hir.props.minimum_len.unwrap(), 4);",
          "    assert_eq!(hir.props.maximum_len.unwrap(), 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_hir = Hir::empty();",
          "    let hir1 = Hir::literal([b'x']);",
          "    let hir2 = Hir::literal([b'y']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        empty_hir,",
          "        hir1,",
          "        Hir::concat(vec![",
          "            hir2,",
          "            Hir::literal([b'z']),",
          "        ]),",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Hir::literal(\"xyz\".as_bytes()), hir);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'x']), Hir::literal([b'y']), Hir::literal([b'z'])]));",
          "    assert!(matches!(hir.props.is_empty(), false));",
          "    assert!(hir.props.minimum_len.is_some());",
          "    assert!(hir.props.maximum_len.is_some());",
          "    assert_eq!(hir.props.literal, true);"
        ],
        "code": [
          "{",
          "    let empty_hir = Hir::empty();",
          "    let hir1 = Hir::literal([b'x']);",
          "    let hir2 = Hir::literal([b'y']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        empty_hir,",
          "        hir1,",
          "        Hir::concat(vec![",
          "            hir2,",
          "            Hir::literal([b'z']),",
          "        ]),",
          "    ]);",
          "    assert_eq!(Hir::literal(\"xyz\".as_bytes()), hir);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal([b'x']), Hir::literal([b'y']), Hir::literal([b'z'])]));",
          "    assert!(matches!(hir.props.is_empty(), false));",
          "    assert!(hir.props.minimum_len.is_some());",
          "    assert!(hir.props.maximum_len.is_some());",
          "    assert_eq!(hir.props.literal, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir1 = Hir::literal([b'1']);",
          "    let hir2 = Hir::literal([b'2']);",
          "    let hir3 = Hir::literal([b'3']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            hir1,",
          "            hir2,",
          "        ]),",
          "        hir3,",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Hir::literal([b'1', b'2', b'3']), hir);",
          "    assert!(hir.kind == HirKind::Concat(vec![Hir::literal([b'1', b'2']), Hir::literal([b'3'])]));",
          "    assert!(matches!(hir.props.minimum_len(), Some(3)));",
          "    assert!(matches!(hir.props.maximum_len(), Some(3)));"
        ],
        "code": [
          "{",
          "    let hir1 = Hir::literal([b'1']);",
          "    let hir2 = Hir::literal([b'2']);",
          "    let hir3 = Hir::literal([b'3']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![",
          "            hir1,",
          "            hir2,",
          "        ]),",
          "        hir3,",
          "    ]);",
          "    assert_eq!(Hir::literal([b'1', b'2', b'3']), hir);",
          "    assert!(hir.kind == HirKind::Concat(vec![Hir::literal([b'1', b'2']), Hir::literal([b'3'])]));",
          "    assert!(matches!(hir.props.minimum_len(), Some(3)));",
          "    assert!(matches!(hir.props.maximum_len(), Some(3)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]