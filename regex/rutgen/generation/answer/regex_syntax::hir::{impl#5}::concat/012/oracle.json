[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::empty(),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(expected, Hir::literal(\"abc\".as_bytes()));",
          "    assert!(matches!(_result.kind, HirKind::Concat(_)));",
          "    assert!(!_result.props.is_empty());",
          "    assert_eq!(_result.props.minimum_len(), Some(3));",
          "    assert_eq!(_result.props.maximum_len(), Some(3));",
          "    assert!(!matches!(_result.kind, HirKind::Empty));"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::empty(),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    let expected = Hir::literal(\"abc\".as_bytes());",
          "    let _result = hir;",
          "    assert_eq!(expected, Hir::literal(\"abc\".as_bytes()));",
          "    assert!(matches!(_result.kind, HirKind::Concat(_)));",
          "    assert!(!_result.props.is_empty());",
          "    assert_eq!(_result.props.minimum_len(), Some(3));",
          "    assert_eq!(_result.props.maximum_len(), Some(3));",
          "    assert!(!matches!(_result.kind, HirKind::Empty));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'd']),",
          "        Hir::empty(),",
          "        Hir::literal([b'e']),",
          "        Hir::literal([b'f']),",
          "    ]);",
          "    let expected = Hir::literal(\"def\".as_bytes());",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(expected, hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert!(hir.props.is_literal());",
          "    assert!(hir.props.minimum_len().is_some());",
          "    assert_eq!(hir.props.maximum_len().unwrap(), 3);",
          "    assert!(hir.props.utf8);",
          "    assert!(!hir.props.alternation_literal);",
          "    assert_eq!(hir.props.explicit_captures_len, 0);",
          "    assert!(hir.props.static_explicit_captures_len.is_none());",
          "    assert!(matches!(hir.props.look_set_prefix, LookSet::empty()));",
          "    assert!(matches!(hir.props.look_set_suffix, LookSet::empty()));"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'd']),",
          "        Hir::empty(),",
          "        Hir::literal([b'e']),",
          "        Hir::literal([b'f']),",
          "    ]);",
          "    let expected = Hir::literal(\"def\".as_bytes());",
          "    let _result = hir;",
          "    assert_eq!(expected, hir);",
          "    assert!(matches!(hir.kind, HirKind::Concat(_)));",
          "    assert!(hir.props.is_literal());",
          "    assert!(hir.props.minimum_len().is_some());",
          "    assert_eq!(hir.props.maximum_len().unwrap(), 3);",
          "    assert!(hir.props.utf8);",
          "    assert!(!hir.props.alternation_literal);",
          "    assert_eq!(hir.props.explicit_captures_len, 0);",
          "    assert!(hir.props.static_explicit_captures_len.is_none());",
          "    assert!(matches!(hir.props.look_set_prefix, LookSet::empty()));",
          "    assert!(matches!(hir.props.look_set_suffix, LookSet::empty()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::empty(),",
          "        Hir::literal([b'g']),",
          "        Hir::literal([b'h']),",
          "        Hir::empty(),",
          "    ]);",
          "    let expected = Hir::literal(\"gh\".as_bytes());",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Hir::literal(\"gh\".as_bytes()), Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).kind == HirKind::Concat(vec![Hir::literal([b'g']), Hir::literal([b'h'])]));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props == Properties::literal(&Hir::literal([b'g'])));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props == Properties::literal(&Hir::literal([b'h'])));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props.is_utf8);",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props.minimum_len == Some(2));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props.maximum_len == Some(2));"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::empty(),",
          "        Hir::literal([b'g']),",
          "        Hir::literal([b'h']),",
          "        Hir::empty(),",
          "    ]);",
          "    let expected = Hir::literal(\"gh\".as_bytes());",
          "    let _result = hir;",
          "    assert_eq!(Hir::literal(\"gh\".as_bytes()), Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).kind == HirKind::Concat(vec![Hir::literal([b'g']), Hir::literal([b'h'])]));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props == Properties::literal(&Hir::literal([b'g'])));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props == Properties::literal(&Hir::literal([b'h'])));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props.is_utf8);",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props.minimum_len == Some(2));",
          "    assert!(Hir::concat(vec![Hir::empty(), Hir::literal([b'g']), Hir::literal([b'h']), Hir::empty()]).props.maximum_len == Some(2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'i']),",
          "        Hir::literal([b'j']),",
          "        Hir::empty(),",
          "        Hir::literal([b'k']),",
          "    ]);",
          "    let expected = Hir::literal(\"ijk\".as_bytes());",
          "    let _result = hir;",
          "}"
        ],
        "oracle": [
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'i']),",
          "        Hir::literal([b'j']),",
          "        Hir::empty(),",
          "        Hir::literal([b'k']),",
          "    ]);",
          "    let expected = Hir::literal(\"ijk\".as_bytes());",
          "    let _result = hir;",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]