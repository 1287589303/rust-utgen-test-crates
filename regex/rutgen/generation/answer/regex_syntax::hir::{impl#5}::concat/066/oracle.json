[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit1 = Hir::literal([b'a']);",
          "    let lit2 = Hir::literal([b'b']);",
          "    let lit3 = Hir::literal([b'c']);",
          "    let lit4 = Hir::literal([b'd']);",
          "    let lit5 = Hir::literal([b'e']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![lit1, lit2]),",
          "        Hir::concat(vec![lit3, lit4, lit5]),",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(b\"ab\"), Hir::literal(b\"cde\")]));",
          "    assert!(matches!(hir.props, Properties(_)));"
        ],
        "code": [
          "{",
          "    let lit1 = Hir::literal([b'a']);",
          "    let lit2 = Hir::literal([b'b']);",
          "    let lit3 = Hir::literal([b'c']);",
          "    let lit4 = Hir::literal([b'd']);",
          "    let lit5 = Hir::literal([b'e']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![lit1, lit2]),",
          "        Hir::concat(vec![lit3, lit4, lit5]),",
          "    ]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(b\"ab\"), Hir::literal(b\"cde\")]));",
          "    assert!(matches!(hir.props, Properties(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit1 = Hir::literal([b'x']);",
          "    let lit2 = Hir::literal([b'y']);",
          "    let lit3 = Hir::literal([b'z']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![lit1, lit2]),",
          "        Hir::concat(vec![lit3]),",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'x', b'y']), Hir::literal(vec![b'z'])]));",
          "    assert_eq!(hir.props, Properties::concat(&vec![Hir::literal(vec![b'x', b'y']), Hir::literal(vec![b'z'])]));"
        ],
        "code": [
          "{",
          "    let lit1 = Hir::literal([b'x']);",
          "    let lit2 = Hir::literal([b'y']);",
          "    let lit3 = Hir::literal([b'z']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![lit1, lit2]),",
          "        Hir::concat(vec![lit3]),",
          "    ]);",
          "    assert_eq!(hir.kind, HirKind::Concat(vec![Hir::literal(vec![b'x', b'y']), Hir::literal(vec![b'z'])]));",
          "    assert_eq!(hir.props, Properties::concat(&vec![Hir::literal(vec![b'x', b'y']), Hir::literal(vec![b'z'])]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit1 = Hir::literal([b'1']);",
          "    let lit2 = Hir::literal([b'2']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'0']),",
          "        Hir::concat(vec![lit1, lit2]),",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(HirKind::Concat(vec![Hir::literal(vec![b'0']), Hir::literal(vec![b'1', b'2'])]), hir.kind);",
          "    assert!(matches!(hir.props, Properties(_)));",
          "    assert_eq!(hir.props.minimum_len(), Some(3));",
          "    assert_eq!(hir.props.maximum_len(), Some(3));"
        ],
        "code": [
          "{",
          "    let lit1 = Hir::literal([b'1']);",
          "    let lit2 = Hir::literal([b'2']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::literal([b'0']),",
          "        Hir::concat(vec![lit1, lit2]),",
          "    ]);",
          "    assert_eq!(HirKind::Concat(vec![Hir::literal(vec![b'0']), Hir::literal(vec![b'1', b'2'])]), hir.kind);",
          "    assert!(matches!(hir.props, Properties(_)));",
          "    assert_eq!(hir.props.minimum_len(), Some(3));",
          "    assert_eq!(hir.props.maximum_len(), Some(3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit1 = Hir::literal([b'h']);",
          "    let lit2 = Hir::literal([b'i']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![lit1]),",
          "        Hir::literal([b'j']),",
          "        Hir::concat(vec![lit2]),",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Hir { kind: HirKind::Concat(vec![Hir::literal(b\"hi\".to_vec()), Hir::literal(b\"j\".to_vec())]), props: Properties::concat(&vec![Hir::literal(b\"h\".to_vec()), Hir::literal(b\"j\".to_vec()), Hir::literal(b\"i\".to_vec())]) }, hir);"
        ],
        "code": [
          "{",
          "    let lit1 = Hir::literal([b'h']);",
          "    let lit2 = Hir::literal([b'i']);",
          "    ",
          "    let hir = Hir::concat(vec![",
          "        Hir::concat(vec![lit1]),",
          "        Hir::literal([b'j']),",
          "        Hir::concat(vec![lit2]),",
          "    ]);",
          "    assert_eq!(Hir { kind: HirKind::Concat(vec![Hir::literal(b\"hi\".to_vec()), Hir::literal(b\"j\".to_vec())]), props: Properties::concat(&vec![Hir::literal(b\"h\".to_vec()), Hir::literal(b\"j\".to_vec()), Hir::literal(b\"i\".to_vec())]) }, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]