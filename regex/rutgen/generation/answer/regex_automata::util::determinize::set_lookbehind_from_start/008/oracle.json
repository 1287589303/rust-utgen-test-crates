[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = StateBuilderMatches(vec![]);",
          "    let nfa = {",
          "        struct DummyNFA;",
          "        impl thompson::NFA for DummyNFA {",
          "            fn is_reverse(&self) -> bool {",
          "                true",
          "            }",
          "            fn look_matcher(&self) -> &LookMatcher {",
          "                &LookMatcher { lineterm: DebugByte(0) }  // lineterm can be any value != b'\\r'",
          "            }",
          "            fn look_set_any(&self) -> LookSet {",
          "                let mut lookset = LookSet::empty();",
          "                lookset.set_insert(Look::StartCRLF);",
          "                lookset.set_insert(Look::StartLF);",
          "                lookset  // contains_anchor_crlf() and contains_anchor_line() must be true",
          "            }",
          "        }",
          "        DummyNFA",
          "    };",
          "",
          "    let start = Start::LineCR;",
          "",
          "    set_lookbehind_from_start(&nfa, &start, &mut builder);",
          "}"
        ],
        "oracle": [
          "    builder.look_have.contains(Look::StartLF) == true",
          "    builder.look_have.contains(Look::StartCRLF) == true",
          "    builder.is_half_crlf() == true",
          "    builder.look_have.contains(Look::WordStartHalfAscii) == false",
          "    builder.look_have.contains(Look::WordStartHalfUnicode) == false",
          "    builder.set_look_have(|have| have.insert(Look::StartLF));",
          "    builder.set_look_have(|have| have.insert(Look::StartCRLF));",
          "    builder.set_is_half_crlf();",
          "    builder.look_have.contains_anchor_crlf() == true",
          "    builder.look_have.contains_anchor_line() == true",
          "    lineterm == b'\\r' == false",
          "    lookset.contains_word() == false"
        ],
        "code": [
          "{",
          "    let mut builder = StateBuilderMatches(vec![]);",
          "    let nfa = {",
          "        struct DummyNFA;",
          "        impl thompson::NFA for DummyNFA {",
          "            fn is_reverse(&self) -> bool {",
          "                true",
          "            }",
          "            fn look_matcher(&self) -> &LookMatcher {",
          "                &LookMatcher { lineterm: DebugByte(0) }  // lineterm can be any value != b'\\r'",
          "            }",
          "            fn look_set_any(&self) -> LookSet {",
          "                let mut lookset = LookSet::empty();",
          "                lookset.set_insert(Look::StartCRLF);",
          "                lookset.set_insert(Look::StartLF);",
          "                lookset  // contains_anchor_crlf() and contains_anchor_line() must be true",
          "            }",
          "        }",
          "        DummyNFA",
          "    };",
          "",
          "    let start = Start::LineCR;",
          "",
          "    set_lookbehind_from_start(&nfa, &start, &mut builder);",
          "    builder.look_have.contains(Look::StartLF) == true",
          "    builder.look_have.contains(Look::StartCRLF) == true",
          "    builder.is_half_crlf() == true",
          "    builder.look_have.contains(Look::WordStartHalfAscii) == false",
          "    builder.look_have.contains(Look::WordStartHalfUnicode) == false",
          "    builder.set_look_have(|have| have.insert(Look::StartLF));",
          "    builder.set_look_have(|have| have.insert(Look::StartCRLF));",
          "    builder.set_is_half_crlf();",
          "    builder.look_have.contains_anchor_crlf() == true",
          "    builder.look_have.contains_anchor_line() == true",
          "    lineterm == b'\\r' == false",
          "    lookset.contains_word() == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]