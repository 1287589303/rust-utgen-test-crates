[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 0;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);",
          "    let n: u128 = 1;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);",
          "    let n: u128 = 0x1234567890abcdef1234567890abcdef;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef]);",
          "    let n: u128 = u128::MAX;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);",
          "    let n: u128 = 0x00000000000000000000000000000001;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]);"
        ],
        "code": [
          "{",
          "    let n: u128 = 0;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);",
          "    let n: u128 = 1;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);",
          "    let n: u128 = 0x1234567890abcdef1234567890abcdef;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef]);",
          "    let n: u128 = u128::MAX;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);",
          "    let n: u128 = 0x00000000000000000000000000000001;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = u128::MAX;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, u128::MAX.to_be_bytes());",
          "    assert_eq!(dst.len(), 16);",
          "    assert!(dst.iter().all(|&byte| byte >= 0));",
          "    assert!(dst.iter().all(|&byte| byte <= 255));",
          "    assert_ne!(dst[0], 0);",
          "    assert_eq!(dst[15], 255);"
        ],
        "code": [
          "{",
          "    let n: u128 = u128::MAX;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, u128::MAX.to_be_bytes());",
          "    assert_eq!(dst.len(), 16);",
          "    assert!(dst.iter().all(|&byte| byte >= 0));",
          "    assert!(dst.iter().all(|&byte| byte <= 255));",
          "    assert_ne!(dst[0], 0);",
          "    assert_eq!(dst[15], 255);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 1 << 63; // Midpoint",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0]);",
          "    let n: u128 = 0;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0; 16]);",
          "    let n: u128 = u128::MAX;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);",
          "    let n: u128 = 1;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);"
        ],
        "code": [
          "{",
          "    let n: u128 = 1 << 63; // Midpoint",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0]);",
          "    let n: u128 = 0;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0; 16]);",
          "    let n: u128 = u128::MAX;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);",
          "    let n: u128 = 1;",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = u128::MAX - 1; // One less than max",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, (u128::MAX - 1).to_be_bytes());"
        ],
        "code": [
          "{",
          "    let n: u128 = u128::MAX - 1; // One less than max",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, (u128::MAX - 1).to_be_bytes());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 1; // Smallest non-zero",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);"
        ],
        "code": [
          "{",
          "    let n: u128 = 1; // Smallest non-zero",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let n: u128 = 1 << 64; // Another mid value",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst[0], 0);",
          "    assert_eq!(dst[1], 0);",
          "    assert_eq!(dst[2], 0);",
          "    assert_eq!(dst[3], 0);",
          "    assert_eq!(dst[4], 0);",
          "    assert_eq!(dst[5], 0);",
          "    assert_eq!(dst[6], 0);",
          "    assert_eq!(dst[7], 0);",
          "    assert_eq!(dst[8], 0);",
          "    assert_eq!(dst[9], 0);",
          "    assert_eq!(dst[10], 0);",
          "    assert_eq!(dst[11], 0);",
          "    assert_eq!(dst[12], 1);",
          "    assert_eq!(dst[13], 0);",
          "    assert_eq!(dst[14], 0);",
          "    assert_eq!(dst[15], 0);"
        ],
        "code": [
          "{",
          "    let n: u128 = 1 << 64; // Another mid value",
          "    let mut dst = [0u8; 16];",
          "    <BE as Endian>::write_u128(n, &mut dst);",
          "    assert_eq!(dst[0], 0);",
          "    assert_eq!(dst[1], 0);",
          "    assert_eq!(dst[2], 0);",
          "    assert_eq!(dst[3], 0);",
          "    assert_eq!(dst[4], 0);",
          "    assert_eq!(dst[5], 0);",
          "    assert_eq!(dst[6], 0);",
          "    assert_eq!(dst[7], 0);",
          "    assert_eq!(dst[8], 0);",
          "    assert_eq!(dst[9], 0);",
          "    assert_eq!(dst[10], 0);",
          "    assert_eq!(dst[11], 0);",
          "    assert_eq!(dst[12], 1);",
          "    assert_eq!(dst[13], 0);",
          "    assert_eq!(dst[14], 0);",
          "    assert_eq!(dst[15], 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]