[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'a'",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 4),",
          "                kind: LiteralKind::Exact,",
          "                c: 'b'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'c'",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 4),",
          "                kind: LiteralKind::Exact,",
          "                c: 'd'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert!(seq2.literals.is_some());",
          "    assert!(seq1.literals.is_some());",
          "    let result = seq1.cross_preamble(&mut seq2);",
          "    assert!(result.is_some());",
          "    let (lits1, lits2) = result.unwrap();",
          "    assert_eq!(lits1.len(), 2);",
          "    assert_eq!(lits2.len(), 2);"
        ],
        "code": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'a'",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 4),",
          "                kind: LiteralKind::Exact,",
          "                c: 'b'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'c'",
          "            },",
          "            Literal {",
          "                span: Span::new(1, 4),",
          "                kind: LiteralKind::Exact,",
          "                c: 'd'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "    assert!(seq2.literals.is_some());",
          "    assert!(seq1.literals.is_some());",
          "    let result = seq1.cross_preamble(&mut seq2);",
          "    assert!(result.is_some());",
          "    let (lits1, lits2) = result.unwrap();",
          "    assert_eq!(lits1.len(), 2);",
          "    assert_eq!(lits2.len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: 'x'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(1, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'y'",
          "            },",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: 'z'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "}"
        ],
        "oracle": [
          "    let mut seq1 = Seq { literals: Some(vec![Literal { span: Span::new(0, 2), kind: LiteralKind::Exact, c: 'x' },]) };",
          "    let mut seq2 = Seq { literals: Some(vec![Literal { span: Span::new(1, 3), kind: LiteralKind::Exact, c: 'y' }, Literal { span: Span::new(0, 1), kind: LiteralKind::Exact, c: 'z' },]) };",
          "    let result = seq1.cross_preamble(&mut seq2);",
          "    assert!(result.is_some());",
          "    let (lits1, lits2) = result.unwrap();",
          "    assert_eq!(lits1.len(), 1);",
          "    assert_eq!(lits2.len(), 2);",
          "    assert_eq!(lits1[0].c, 'x');",
          "    assert_eq!(lits2[0].c, 'y');",
          "    assert_eq!(lits2[1].c, 'z');"
        ],
        "code": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: 'x'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(1, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'y'",
          "            },",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: 'z'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "    let mut seq1 = Seq { literals: Some(vec![Literal { span: Span::new(0, 2), kind: LiteralKind::Exact, c: 'x' },]) };",
          "    let mut seq2 = Seq { literals: Some(vec![Literal { span: Span::new(1, 3), kind: LiteralKind::Exact, c: 'y' }, Literal { span: Span::new(0, 1), kind: LiteralKind::Exact, c: 'z' },]) };",
          "    let result = seq1.cross_preamble(&mut seq2);",
          "    assert!(result.is_some());",
          "    let (lits1, lits2) = result.unwrap();",
          "    assert_eq!(lits1.len(), 1);",
          "    assert_eq!(lits2.len(), 2);",
          "    assert_eq!(lits1[0].c, 'x');",
          "    assert_eq!(lits2[0].c, 'y');",
          "    assert_eq!(lits2[1].c, 'z');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 5),",
          "                kind: LiteralKind::Exact,",
          "                c: 'e'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 5),",
          "                kind: LiteralKind::Exact,",
          "                c: 'e'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq1.literals().is_some(), true);",
          "    assert_eq!(seq2.literals().is_some(), true);",
          "    assert!(seq1.cross_preamble(&mut seq2).is_some());",
          "    assert_eq!(seq1.cross_preamble(&mut seq2), Some((seq1.literals().unwrap(), seq2.literals().unwrap())));"
        ],
        "code": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 5),",
          "                kind: LiteralKind::Exact,",
          "                c: 'e'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 5),",
          "                kind: LiteralKind::Exact,",
          "                c: 'e'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "    assert_eq!(seq1.literals().is_some(), true);",
          "    assert_eq!(seq2.literals().is_some(), true);",
          "    assert!(seq1.cross_preamble(&mut seq2).is_some());",
          "    assert_eq!(seq1.cross_preamble(&mut seq2), Some((seq1.literals().unwrap(), seq2.literals().unwrap())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: 'a'",
          "            },",
          "            Literal {",
          "                span: Span::new(2, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'b'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: 'c'",
          "            },",
          "            Literal {",
          "                span: Span::new(3, 4),",
          "                kind: LiteralKind::Exact,",
          "                c: 'd'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq1.literals.is_some(), true);",
          "    assert_eq!(seq2.literals.is_some(), true);",
          "    assert!(seq1.cross_preamble(&mut seq2).is_some());",
          "    assert_eq!(seq1.literals().unwrap().len(), 2);",
          "    assert_eq!(seq2.literals().unwrap().len(), 2);",
          "    assert!(matches!(seq1.cross_preamble(&mut seq2), Some((lits1, lits2))));",
          "    assert_eq!(lits1.len(), 2);",
          "    assert_eq!(lits2.len(), 2);",
          "    assert_eq!(lits1[0].c, 'a');",
          "    assert_eq!(lits1[1].c, 'b');",
          "    assert_eq!(lits2[0].c, 'c');",
          "    assert_eq!(lits2[1].c, 'd');"
        ],
        "code": [
          "{",
          "    let mut seq1 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 1),",
          "                kind: LiteralKind::Exact,",
          "                c: 'a'",
          "            },",
          "            Literal {",
          "                span: Span::new(2, 3),",
          "                kind: LiteralKind::Exact,",
          "                c: 'b'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    let mut seq2 = Seq {",
          "        literals: Some(vec![",
          "            Literal {",
          "                span: Span::new(0, 2),",
          "                kind: LiteralKind::Exact,",
          "                c: 'c'",
          "            },",
          "            Literal {",
          "                span: Span::new(3, 4),",
          "                kind: LiteralKind::Exact,",
          "                c: 'd'",
          "            },",
          "        ]),",
          "    };",
          "",
          "    seq1.cross_preamble(&mut seq2);",
          "    assert_eq!(seq1.literals.is_some(), true);",
          "    assert_eq!(seq2.literals.is_some(), true);",
          "    assert!(seq1.cross_preamble(&mut seq2).is_some());",
          "    assert_eq!(seq1.literals().unwrap().len(), 2);",
          "    assert_eq!(seq2.literals().unwrap().len(), 2);",
          "    assert!(matches!(seq1.cross_preamble(&mut seq2), Some((lits1, lits2))));",
          "    assert_eq!(lits1.len(), 2);",
          "    assert_eq!(lits2.len(), 2);",
          "    assert_eq!(lits1[0].c, 'a');",
          "    assert_eq!(lits1[1].c, 'b');",
          "    assert_eq!(lits2[0].c, 'c');",
          "    assert_eq!(lits2[1].c, 'd');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]