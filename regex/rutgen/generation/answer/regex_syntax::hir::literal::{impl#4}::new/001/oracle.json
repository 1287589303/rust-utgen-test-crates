[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: Vec<&[u8]> = vec![];",
          "    let _seq = Seq::new(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.literals(), None);",
          "    assert!(Seq::new(input).is_empty());",
          "    assert!(Seq::new(input).is_finite());",
          "    assert_eq!(Seq::new(input).len(), Some(0));"
        ],
        "code": [
          "{",
          "    let input: Vec<&[u8]> = vec![];",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.literals(), None);",
          "    assert!(Seq::new(input).is_empty());",
          "    assert!(Seq::new(input).is_finite());",
          "    assert_eq!(Seq::new(input).len(), Some(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = vec![b\"\"];",
          "    let _seq = Seq::new(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.literals(), Some(&[Literal::exact(b\"\")].as_slice()));",
          "    assert!(Seq::new(vec![]).literals().is_none());",
          "    let input = vec![b\"a\", b\"b\", b\"c\"];",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.literals().unwrap().len(), 3);",
          "    assert_eq!(_seq.literals().unwrap()[0], Literal::exact(b\"a\"));",
          "    assert_eq!(_seq.literals().unwrap()[1], Literal::exact(b\"b\"));",
          "    assert_eq!(_seq.literals().unwrap()[2], Literal::exact(b\"c\"));"
        ],
        "code": [
          "{",
          "    let input = vec![b\"\"];",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.literals(), Some(&[Literal::exact(b\"\")].as_slice()));",
          "    assert!(Seq::new(vec![]).literals().is_none());",
          "    let input = vec![b\"a\", b\"b\", b\"c\"];",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.literals().unwrap().len(), 3);",
          "    assert_eq!(_seq.literals().unwrap()[0], Literal::exact(b\"a\"));",
          "    assert_eq!(_seq.literals().unwrap()[1], Literal::exact(b\"b\"));",
          "    assert_eq!(_seq.literals().unwrap()[2], Literal::exact(b\"c\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = vec![b\"abc\"];",
          "    let _seq = Seq::new(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.literals().unwrap().len(), 1);",
          "    assert_eq!(_seq.literals().unwrap()[0].bytes.as_slice(), b\"abc\");",
          "    assert!(_seq.literals().unwrap()[0].exact);",
          "    assert!(_seq.is_inexact());",
          "    assert_eq!(_seq.len().unwrap(), 1);"
        ],
        "code": [
          "{",
          "    let input = vec![b\"abc\"];",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.literals().unwrap().len(), 1);",
          "    assert_eq!(_seq.literals().unwrap()[0].bytes.as_slice(), b\"abc\");",
          "    assert!(_seq.literals().unwrap()[0].exact);",
          "    assert!(_seq.is_inexact());",
          "    assert_eq!(_seq.len().unwrap(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = vec![b\"longer byte string\", b\"another one\"];",
          "    let _seq = Seq::new(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.literals().unwrap().len(), 2);",
          "    assert_eq!(_seq.literals().unwrap()[0].kind, LiteralKind::Exact);",
          "    assert_eq!(_seq.literals().unwrap()[1].kind, LiteralKind::Exact);",
          "    assert_eq!(_seq.literals().unwrap()[0].span.start, 0);",
          "    assert_eq!(_seq.literals().unwrap()[1].span.start, 1);",
          "    assert_eq!(_seq.literals().unwrap()[0].c, 'l');",
          "    assert_eq!(_seq.literals().unwrap()[1].c, 'a');"
        ],
        "code": [
          "{",
          "    let input = vec![b\"longer byte string\", b\"another one\"];",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.literals().unwrap().len(), 2);",
          "    assert_eq!(_seq.literals().unwrap()[0].kind, LiteralKind::Exact);",
          "    assert_eq!(_seq.literals().unwrap()[1].kind, LiteralKind::Exact);",
          "    assert_eq!(_seq.literals().unwrap()[0].span.start, 0);",
          "    assert_eq!(_seq.literals().unwrap()[1].span.start, 1);",
          "    assert_eq!(_seq.literals().unwrap()[0].c, 'l');",
          "    assert_eq!(_seq.literals().unwrap()[1].c, 'a');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = vec![b\"short\", b\"this is a longer string\", b\"\"];",
          "    let _seq = Seq::new(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.literals().unwrap().len(), 3);",
          "    assert!(matches!(_seq.literals().unwrap()[0], Literal { .. }));",
          "    assert!(matches!(_seq.literals().unwrap()[1], Literal { .. }));",
          "    assert!(matches!(_seq.literals().unwrap()[2], Literal { .. }));",
          "    assert!(matches!(_seq.literals().unwrap()[0].bytes, b\"short\"));",
          "    assert!(matches!(_seq.literals().unwrap()[1].bytes, b\"this is a longer string\"));",
          "    assert!(matches!(_seq.literals().unwrap()[2].bytes, b\"\"));",
          "    assert!(!_seq.is_empty());",
          "    assert_eq!(_seq.len(), Some(3));"
        ],
        "code": [
          "{",
          "    let input = vec![b\"short\", b\"this is a longer string\", b\"\"];",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.literals().unwrap().len(), 3);",
          "    assert!(matches!(_seq.literals().unwrap()[0], Literal { .. }));",
          "    assert!(matches!(_seq.literals().unwrap()[1], Literal { .. }));",
          "    assert!(matches!(_seq.literals().unwrap()[2], Literal { .. }));",
          "    assert!(matches!(_seq.literals().unwrap()[0].bytes, b\"short\"));",
          "    assert!(matches!(_seq.literals().unwrap()[1].bytes, b\"this is a longer string\"));",
          "    assert!(matches!(_seq.literals().unwrap()[2].bytes, b\"\"));",
          "    assert!(!_seq.is_empty());",
          "    assert_eq!(_seq.len(), Some(3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: Vec<&[u8]> = (0..1000).map(|i| format!(\"string{}\", i).into_bytes()).collect();",
          "    let _seq = Seq::new(input);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_seq.len(), Some(1000));",
          "    assert!(!_seq.is_empty());",
          "    assert!(_seq.is_finite());",
          "    assert_eq!(_seq.literals().unwrap().len(), 1000);",
          "    assert!(_seq.is_exact());"
        ],
        "code": [
          "{",
          "    let input: Vec<&[u8]> = (0..1000).map(|i| format!(\"string{}\", i).into_bytes()).collect();",
          "    let _seq = Seq::new(input);",
          "    assert_eq!(_seq.len(), Some(1000));",
          "    assert!(!_seq.is_empty());",
          "    assert!(_seq.is_finite());",
          "    assert_eq!(_seq.literals().unwrap().len(), 1000);",
          "    assert!(_seq.is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]