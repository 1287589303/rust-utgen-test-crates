[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestParser {",
          "        capture_names: RefCell<Vec<CaptureName>>,",
          "    }",
          "",
          "    impl Borrow<Parser> for TestParser {",
          "        fn borrow(&self) -> &Parser {",
          "            unimplemented!()",
          "        }",
          "    }",
          "    ",
          "    let mut parser = TestParser {",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let cap = CaptureName {",
          "        span: Span { start: Position::default(), end: Position::default() },",
          "        name: String::from(\"unique_name\"),",
          "        index: 0,",
          "    };",
          "    ",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(()));"
        ],
        "code": [
          "{",
          "    struct TestParser {",
          "        capture_names: RefCell<Vec<CaptureName>>,",
          "    }",
          "",
          "    impl Borrow<Parser> for TestParser {",
          "        fn borrow(&self) -> &Parser {",
          "            unimplemented!()",
          "        }",
          "    }",
          "    ",
          "    let mut parser = TestParser {",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let cap = CaptureName {",
          "        span: Span { start: Position::default(), end: Position::default() },",
          "        name: String::from(\"unique_name\"),",
          "        index: 0,",
          "    };",
          "    ",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "    assert_eq!(result, Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestParser {",
          "        capture_names: RefCell<Vec<CaptureName>>,",
          "    }",
          "",
          "    impl Borrow<Parser> for TestParser {",
          "        fn borrow(&self) -> &Parser {",
          "            unimplemented!()",
          "        }",
          "    }",
          "    ",
          "    let mut capture_names = RefCell::new(vec![",
          "        CaptureName {",
          "            span: Span { start: Position::default(), end: Position::default() },",
          "            name: String::from(\"existing_name\"),",
          "            index: 1,",
          "        },",
          "    ]);",
          "    ",
          "    let parser = TestParser {",
          "        capture_names,",
          "    };",
          "    ",
          "    let cap = CaptureName {",
          "        span: Span { start: Position::default(), end: Position::default() },",
          "        name: String::from(\"another_unique_name\"),",
          "        index: 2,",
          "    };",
          "    ",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "}"
        ],
        "oracle": [
          "    let mut names = parser.capture_names.borrow_mut();",
          "    let initial_names_count = names.len();",
          "    let cap = CaptureName { span: Span::default(), name: String::from(\"another_unique_name\"), index: 2 };",
          "    assert_eq!(result, Ok(()));",
          "    assert_eq!(names.len(), initial_names_count + 1);",
          "    assert_eq!(names.last().unwrap().name, \"another_unique_name\");"
        ],
        "code": [
          "{",
          "    struct TestParser {",
          "        capture_names: RefCell<Vec<CaptureName>>,",
          "    }",
          "",
          "    impl Borrow<Parser> for TestParser {",
          "        fn borrow(&self) -> &Parser {",
          "            unimplemented!()",
          "        }",
          "    }",
          "    ",
          "    let mut capture_names = RefCell::new(vec![",
          "        CaptureName {",
          "            span: Span { start: Position::default(), end: Position::default() },",
          "            name: String::from(\"existing_name\"),",
          "            index: 1,",
          "        },",
          "    ]);",
          "    ",
          "    let parser = TestParser {",
          "        capture_names,",
          "    };",
          "    ",
          "    let cap = CaptureName {",
          "        span: Span { start: Position::default(), end: Position::default() },",
          "        name: String::from(\"another_unique_name\"),",
          "        index: 2,",
          "    };",
          "    ",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "    let mut names = parser.capture_names.borrow_mut();",
          "    let initial_names_count = names.len();",
          "    let cap = CaptureName { span: Span::default(), name: String::from(\"another_unique_name\"), index: 2 };",
          "    assert_eq!(result, Ok(()));",
          "    assert_eq!(names.len(), initial_names_count + 1);",
          "    assert_eq!(names.last().unwrap().name, \"another_unique_name\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestParser {",
          "        capture_names: RefCell<Vec<CaptureName>>,",
          "    }",
          "",
          "    impl Borrow<Parser> for TestParser {",
          "        fn borrow(&self) -> &Parser {",
          "            unimplemented!()",
          "        }",
          "    }",
          "    ",
          "    let parser = TestParser {",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let cap = CaptureName {",
          "        span: Span { start: Position::default(), end: Position::default() },",
          "        name: String::from(\"\"),",
          "        index: 3,",
          "    };",
          "    ",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "}"
        ],
        "oracle": [
          "    let parser = TestParser { capture_names: RefCell::new(vec![]) };",
          "    let cap = CaptureName { span: Span { start: Position::default(), end: Position::default() }, name: String::from(\"unique_capture\"), index: 0 };",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "    assert_eq!(result, Ok(()));",
          "    parser.capture_names.borrow_mut().push(cap.clone());",
          "    let result_duplicate = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "    assert!(result_duplicate.is_err());",
          "    assert_eq!(result_duplicate.unwrap_err().kind, ast::ErrorKind::GroupNameDuplicate { original: cap.span });"
        ],
        "code": [
          "{",
          "    struct TestParser {",
          "        capture_names: RefCell<Vec<CaptureName>>,",
          "    }",
          "",
          "    impl Borrow<Parser> for TestParser {",
          "        fn borrow(&self) -> &Parser {",
          "            unimplemented!()",
          "        }",
          "    }",
          "    ",
          "    let parser = TestParser {",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let cap = CaptureName {",
          "        span: Span { start: Position::default(), end: Position::default() },",
          "        name: String::from(\"\"),",
          "        index: 3,",
          "    };",
          "    ",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "    let parser = TestParser { capture_names: RefCell::new(vec![]) };",
          "    let cap = CaptureName { span: Span { start: Position::default(), end: Position::default() }, name: String::from(\"unique_capture\"), index: 0 };",
          "    let result = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "    assert_eq!(result, Ok(()));",
          "    parser.capture_names.borrow_mut().push(cap.clone());",
          "    let result_duplicate = ParserI::new(&parser, \"pattern\").add_capture_name(&cap);",
          "    assert!(result_duplicate.is_err());",
          "    assert_eq!(result_duplicate.unwrap_err().kind, ast::ErrorKind::GroupNameDuplicate { original: cap.span });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]