[
  {
    "uses": [
      "use regex::bytes::Regex;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
          "    let hay = b\"On 2010-03-14, I became a Tenneessee lamb.\";",
          "    let caps = re.captures(hay).unwrap();",
          "    ",
          "    let (full, [year, month, day]) = caps.extract::<3>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(full, b\"2010-03-14\");",
          "    assert_eq!(year, b\"2010\");",
          "    assert_eq!(month, b\"03\");",
          "    assert_eq!(day, b\"14\");"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
          "    let hay = b\"On 2010-03-14, I became a Tenneessee lamb.\";",
          "    let caps = re.captures(hay).unwrap();",
          "    ",
          "    let (full, [year, month, day]) = caps.extract::<3>();",
          "    assert_eq!(full, b\"2010-03-14\");",
          "    assert_eq!(year, b\"2010\");",
          "    assert_eq!(month, b\"03\");",
          "    assert_eq!(day, b\"14\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([a-zA-Z]{3})([0-9]{3})([!@#$%^&*()])\").unwrap();",
          "    let hay = b\"abc123$ def456& ghi789*\";",
          "    let caps = re.captures(hay).unwrap();",
          "    ",
          "    let (full, [text, num, symbol]) = caps.extract::<3>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(full, b\"abc123$\");",
          "    assert_eq!(text, b\"abc\");",
          "    assert_eq!(num, b\"123\");",
          "    assert_eq!(symbol, b\"$\");",
          "    ",
          "    let (full, [text, num, symbol]) = caps.extract::<3>();",
          "    assert_eq!(full, b\"def456&\");",
          "    assert_eq!(text, b\"def\");",
          "    assert_eq!(num, b\"456\");",
          "    assert_eq!(symbol, b\"&\");",
          "    ",
          "    let (full, [text, num, symbol]) = caps.extract::<3>();",
          "    assert_eq!(full, b\"ghi789*\");",
          "    assert_eq!(text, b\"ghi\");",
          "    assert_eq!(num, b\"789\");",
          "    assert_eq!(symbol, b\"*\");",
          "    ",
          "    let result = std::panic::catch_unwind(|| {",
          "    caps.extract::<2>();",
          "    });",
          "    assert!(result.is_err());",
          "    ",
          "    let result = std::panic::catch_unwind(|| {",
          "    caps.extract::<4>();",
          "    });",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([a-zA-Z]{3})([0-9]{3})([!@#$%^&*()])\").unwrap();",
          "    let hay = b\"abc123$ def456& ghi789*\";",
          "    let caps = re.captures(hay).unwrap();",
          "    ",
          "    let (full, [text, num, symbol]) = caps.extract::<3>();",
          "    assert_eq!(full, b\"abc123$\");",
          "    assert_eq!(text, b\"abc\");",
          "    assert_eq!(num, b\"123\");",
          "    assert_eq!(symbol, b\"$\");",
          "    ",
          "    let (full, [text, num, symbol]) = caps.extract::<3>();",
          "    assert_eq!(full, b\"def456&\");",
          "    assert_eq!(text, b\"def\");",
          "    assert_eq!(num, b\"456\");",
          "    assert_eq!(symbol, b\"&\");",
          "    ",
          "    let (full, [text, num, symbol]) = caps.extract::<3>();",
          "    assert_eq!(full, b\"ghi789*\");",
          "    assert_eq!(text, b\"ghi\");",
          "    assert_eq!(num, b\"789\");",
          "    assert_eq!(symbol, b\"*\");",
          "    ",
          "    let result = std::panic::catch_unwind(|| {",
          "    caps.extract::<2>();",
          "    });",
          "    assert!(result.is_err());",
          "    ",
          "    let result = std::panic::catch_unwind(|| {",
          "    caps.extract::<4>();",
          "    });",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([a-z]+)([0-9]+)\").unwrap();",
          "    let hay = b\"abc123\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let (_, [text]) = caps.extract::<2>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(caps.static_captures_len, Some(2));",
          "    assert!(matches!(std::panic::catch_unwind(|| caps.extract::<2>()), Err(_)));"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([a-z]+)([0-9]+)\").unwrap();",
          "    let hay = b\"abc123\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let (_, [text]) = caps.extract::<2>();",
          "    assert_eq!(caps.static_captures_len, Some(2));",
          "    assert!(matches!(std::panic::catch_unwind(|| caps.extract::<2>()), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([1-9])([0-9]{2})([0-9]{2})\").unwrap();",
          "    let hay = b\"123456\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let (_, [first, second, third]) = caps.extract::<4>();",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| {",
          "    let re = Regex::new(r\"([1-9])([0-9]{2})([0-9]{2})\").unwrap();",
          "    let hay = b\"123456\";",
          "    let caps = re.captures(hay).unwrap();",
          "    let (_, [first, second, third]) = caps.extract::<4>();",
          "    }).is_err());"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"([1-9])([0-9]{2})([0-9]{2})\").unwrap();",
          "    let hay = b\"123456\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let (_, [first, second, third]) = caps.extract::<4>();",
          "    assert!(std::panic::catch_unwind(|| {",
          "    let re = Regex::new(r\"([1-9])([0-9]{2})([0-9]{2})\").unwrap();",
          "    let hay = b\"123456\";",
          "    let caps = re.captures(hay).unwrap();",
          "    let (_, [first, second, third]) = caps.extract::<4>();",
          "    }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"(\\w+)-(\\d+)-(\\w+)\").unwrap();",
          "    let hay = b\"date-2023-rust\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let (full, [word, number, lang]) = caps.extract::<3>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(full, b\"date-2023-rust\");",
          "    assert_eq!(word, b\"date\");",
          "    assert_eq!(number, b\"2023\");",
          "    assert_eq!(lang, b\"rust\");"
        ],
        "code": [
          "{",
          "    use regex::bytes::Regex;",
          "",
          "    let re = Regex::new(r\"(\\w+)-(\\d+)-(\\w+)\").unwrap();",
          "    let hay = b\"date-2023-rust\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let (full, [word, number, lang]) = caps.extract::<3>();",
          "    assert_eq!(full, b\"date-2023-rust\");",
          "    assert_eq!(word, b\"date\");",
          "    assert_eq!(number, b\"2023\");",
          "    assert_eq!(lang, b\"rust\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]