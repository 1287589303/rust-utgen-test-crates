[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::new(5).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges.len(), 1);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 0);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 10);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(group_info.memory_extra == 0);",
          "    assert_eq!(group_info.pattern_len(), 1);"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::new(5).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "    assert_eq!(group_info.slot_ranges.len(), 1);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 0);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 10);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(group_info.memory_extra == 0);",
          "    assert_eq!(group_info.pattern_len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![",
          "            (SmallIndex::new(0).unwrap(), SmallIndex::new(4).unwrap()),",
          "            (SmallIndex::new(6).unwrap(), SmallIndex::new(10).unwrap()),",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(1).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "}"
        ],
        "oracle": [
          "    assert!(group_info.slot_ranges[0].0.as_usize() == 0);",
          "    assert!(group_info.slot_ranges[0].1.as_usize() == 4);",
          "    assert!(group_info.slot_ranges[1].0.as_usize() == 6);",
          "    assert!(group_info.slot_ranges[1].1.as_usize() == 10);",
          "    assert!(group_info.pattern_len() == 2);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(group_info.slot_ranges[0].0.as_usize() == 2); // Assuming pattern_len() * 2 = 2",
          "    assert!(group_info.slot_ranges[0].1.as_usize() == 6);",
          "    assert!(group_info.slot_ranges[1].0.as_usize() == 8);",
          "    assert!(group_info.slot_ranges[1].1.as_usize() == 12);"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![",
          "            (SmallIndex::new(0).unwrap(), SmallIndex::new(4).unwrap()),",
          "            (SmallIndex::new(6).unwrap(), SmallIndex::new(10).unwrap()),",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(1).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "    assert!(group_info.slot_ranges[0].0.as_usize() == 0);",
          "    assert!(group_info.slot_ranges[0].1.as_usize() == 4);",
          "    assert!(group_info.slot_ranges[1].0.as_usize() == 6);",
          "    assert!(group_info.slot_ranges[1].1.as_usize() == 10);",
          "    assert!(group_info.pattern_len() == 2);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(group_info.slot_ranges[0].0.as_usize() == 2); // Assuming pattern_len() * 2 = 2",
          "    assert!(group_info.slot_ranges[0].1.as_usize() == 6);",
          "    assert!(group_info.slot_ranges[1].0.as_usize() == 8);",
          "    assert!(group_info.slot_ranges[1].1.as_usize() == 12);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::new(SmallIndex::LIMIT as usize - 2).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "}"
        ],
        "oracle": [
          "    assert!(group_info.slot_ranges.len() == 1);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 0);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), SmallIndex::LIMIT as usize - 2);",
          "    let offset = group_info.pattern_len() * 2;",
          "    let new_end = group_info.slot_ranges[0].1.as_usize() + offset;",
          "    assert!(group_info.slot_ranges[0].1.as_usize() == SmallIndex::new(new_end).unwrap().as_usize());",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), SmallIndex::new(0 + offset).unwrap().as_usize());",
          "    assert!(group_info.fixup_slot_ranges().is_ok());"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::new(SmallIndex::LIMIT as usize - 2).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "    assert!(group_info.slot_ranges.len() == 1);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 0);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), SmallIndex::LIMIT as usize - 2);",
          "    let offset = group_info.pattern_len() * 2;",
          "    let new_end = group_info.slot_ranges[0].1.as_usize() + offset;",
          "    assert!(group_info.slot_ranges[0].1.as_usize() == SmallIndex::new(new_end).unwrap().as_usize());",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), SmallIndex::new(0 + offset).unwrap().as_usize());",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(SmallIndex::LIMIT as usize - 4).unwrap(), SmallIndex::new(SmallIndex::LIMIT as usize - 1).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges.len(), 1);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), SmallIndex::LIMIT as usize - 4);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), SmallIndex::LIMIT as usize - 1);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(matches!(group_info.slot_ranges[0].0, SmallIndex(_)));",
          "    assert!(matches!(group_info.slot_ranges[0].1, SmallIndex(_)));",
          "    assert!(group_info.slot_ranges[0].1.as_usize() > group_info.slot_ranges[0].0.as_usize());",
          "    assert!(group_info.pattern_len() > 0);"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(SmallIndex::LIMIT as usize - 4).unwrap(), SmallIndex::new(SmallIndex::LIMIT as usize - 1).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "    assert_eq!(group_info.slot_ranges.len(), 1);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), SmallIndex::LIMIT as usize - 4);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), SmallIndex::LIMIT as usize - 1);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(matches!(group_info.slot_ranges[0].0, SmallIndex(_)));",
          "    assert!(matches!(group_info.slot_ranges[0].1, SmallIndex(_)));",
          "    assert!(group_info.slot_ranges[0].1.as_usize() > group_info.slot_ranges[0].0.as_usize());",
          "    assert!(group_info.pattern_len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(1).unwrap(), SmallIndex::new(3).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(2).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "}"
        ],
        "oracle": [
          "    let mut group_info = GroupInfoInner { slot_ranges: vec![(SmallIndex::new(1).unwrap(), SmallIndex::new(3).unwrap())], ..Default::default() };",
          "    let pid = PatternID(SmallIndex::new(2).unwrap());",
          "    group_info.add_first_group(pid);",
          "    assert_eq!(group_info.fixup_slot_ranges(), Ok(()));",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 7);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 5);",
          "    assert_eq!(group_info.pattern_len(), 1);",
          "    group_info.slot_ranges.push((SmallIndex::new(5).unwrap(), SmallIndex::new(7).unwrap()));",
          "    assert_eq!(group_info.fixup_slot_ranges(), Ok(()));"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(1).unwrap(), SmallIndex::new(3).unwrap())],",
          "        ..Default::default()",
          "    };",
          "    let pid = PatternID(SmallIndex::new(2).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let _ = group_info.fixup_slot_ranges();",
          "    let mut group_info = GroupInfoInner { slot_ranges: vec![(SmallIndex::new(1).unwrap(), SmallIndex::new(3).unwrap())], ..Default::default() };",
          "    let pid = PatternID(SmallIndex::new(2).unwrap());",
          "    group_info.add_first_group(pid);",
          "    assert_eq!(group_info.fixup_slot_ranges(), Ok(()));",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 7);",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 5);",
          "    assert_eq!(group_info.pattern_len(), 1);",
          "    group_info.slot_ranges.push((SmallIndex::new(5).unwrap(), SmallIndex::new(7).unwrap()));",
          "    assert_eq!(group_info.fixup_slot_ranges(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]