[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::new(10).unwrap())],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    group_info.fixup_slot_ranges().unwrap();",
          "}"
        ],
        "oracle": [
          "    group_info.slot_ranges[0].1.as_usize() == 10",
          "    group_info.slot_ranges[0].0.as_usize() == 0",
          "    pid == PatternID(SmallIndex::new(0).unwrap())",
          "    group_info.fixup_slot_ranges().is_ok()",
          "    group_info.slot_ranges.len() == 1"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::new(10).unwrap())],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    group_info.fixup_slot_ranges().unwrap();",
          "    group_info.slot_ranges[0].1.as_usize() == 10",
          "    group_info.slot_ranges[0].0.as_usize() == 0",
          "    pid == PatternID(SmallIndex::new(0).unwrap())",
          "    group_info.fixup_slot_ranges().is_ok()",
          "    group_info.slot_ranges.len() == 1",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::MAX)],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    ",
          "    let result = group_info.fixup_slot_ranges();",
          "    assert!(result.is_err());",
          "}"
        ],
        "oracle": [
          "    let mut group_info = GroupInfoInner { slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::MAX)], name_to_index: vec![], index_to_name: vec![], memory_extra: 0 };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let result = group_info.fixup_slot_ranges();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, GroupInfoErrorKind::TooManyGroups { pattern: pid, minimum: 1 });",
          "    assert!(matches!(result, Err(GroupInfoError { kind: GroupInfoErrorKind::TooManyGroups { .. }})));",
          "    assert!(result.is_err());",
          "    assert!(result.as_ref().unwrap_err().kind == GroupInfoErrorKind::TooManyGroups { pattern: pid, minimum: 1 });"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::MAX)],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    ",
          "    let result = group_info.fixup_slot_ranges();",
          "    assert!(result.is_err());",
          "    let mut group_info = GroupInfoInner { slot_ranges: vec![(SmallIndex::new(0).unwrap(), SmallIndex::MAX)], name_to_index: vec![], index_to_name: vec![], memory_extra: 0 };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    let result = group_info.fixup_slot_ranges();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().kind, GroupInfoErrorKind::TooManyGroups { pattern: pid, minimum: 1 });",
          "    assert!(matches!(result, Err(GroupInfoError { kind: GroupInfoErrorKind::TooManyGroups { .. }})));",
          "    assert!(result.is_err());",
          "    assert!(result.as_ref().unwrap_err().kind == GroupInfoErrorKind::TooManyGroups { pattern: pid, minimum: 1 });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(5).unwrap(), SmallIndex::new(6).unwrap())],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    group_info.fixup_slot_ranges().unwrap();",
          "}"
        ],
        "oracle": [
          "    let mut group_info = GroupInfoInner { slot_ranges: vec![(SmallIndex::new(5).unwrap(), SmallIndex::new(6).unwrap())], name_to_index: vec![], index_to_name: vec![], memory_extra: 0 };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    group_info.fixup_slot_ranges().unwrap();",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 5 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 6 + group_info.pattern_len() * 2);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(matches!(group_info.fixup_slot_ranges().err(), None));",
          "    let new_end = group_info.slot_ranges[0].1.as_usize() + group_info.pattern_len() * 2;",
          "    assert!(SmallIndex::new(new_end).is_err());"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::new(5).unwrap(), SmallIndex::new(6).unwrap())],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    group_info.fixup_slot_ranges().unwrap();",
          "    let mut group_info = GroupInfoInner { slot_ranges: vec![(SmallIndex::new(5).unwrap(), SmallIndex::new(6).unwrap())], name_to_index: vec![], index_to_name: vec![], memory_extra: 0 };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    group_info.fixup_slot_ranges().unwrap();",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 5 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 6 + group_info.pattern_len() * 2);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(matches!(group_info.fixup_slot_ranges().err(), None));",
          "    let new_end = group_info.slot_ranges[0].1.as_usize() + group_info.pattern_len() * 2;",
          "    assert!(SmallIndex::new(new_end).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![",
          "            (SmallIndex::new(0).unwrap(), SmallIndex::new(2).unwrap()),",
          "            (SmallIndex::new(3).unwrap(), SmallIndex::new(5).unwrap()),",
          "        ],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid0 = PatternID(SmallIndex::new(0).unwrap());",
          "    let pid1 = PatternID(SmallIndex::new(1).unwrap());",
          "    group_info.add_first_group(pid0);",
          "    group_info.add_first_group(pid1);",
          "    ",
          "    group_info.fixup_slot_ranges().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 0 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 2 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[1].0.as_usize(), 3 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[1].1.as_usize(), 5 + group_info.pattern_len() * 2);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(group_info.slot_ranges.len() > 0);"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![",
          "            (SmallIndex::new(0).unwrap(), SmallIndex::new(2).unwrap()),",
          "            (SmallIndex::new(3).unwrap(), SmallIndex::new(5).unwrap()),",
          "        ],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid0 = PatternID(SmallIndex::new(0).unwrap());",
          "    let pid1 = PatternID(SmallIndex::new(1).unwrap());",
          "    group_info.add_first_group(pid0);",
          "    group_info.add_first_group(pid1);",
          "    ",
          "    group_info.fixup_slot_ranges().unwrap();",
          "    assert_eq!(group_info.slot_ranges[0].0.as_usize(), 0 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[0].1.as_usize(), 2 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[1].0.as_usize(), 3 + group_info.pattern_len() * 2);",
          "    assert_eq!(group_info.slot_ranges[1].1.as_usize(), 5 + group_info.pattern_len() * 2);",
          "    assert!(group_info.fixup_slot_ranges().is_ok());",
          "    assert!(group_info.slot_ranges.len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::MAX, SmallIndex::MAX)],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    ",
          "    group_info.fixup_slot_ranges().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges.len(), 1);",
          "    assert_eq!(group_info.slot_ranges[0].0, SmallIndex::new(0).unwrap());",
          "    assert_eq!(group_info.slot_ranges[0].1, SmallIndex::MAX);",
          "    assert!(group_info.fixup_slot_ranges().is_err());",
          "    assert!(matches!(group_info.fixup_slot_ranges(), Err(GroupInfoError { kind: GroupInfoErrorKind::TooManyGroups { pattern, minimum } })));",
          "    assert_eq!(minimum, 1);",
          "    assert_eq!(group_info.memory_extra, 0);"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner {",
          "        slot_ranges: vec![(SmallIndex::MAX, SmallIndex::MAX)],",
          "        name_to_index: vec![],",
          "        index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pid = PatternID(SmallIndex::new(0).unwrap());",
          "    group_info.add_first_group(pid);",
          "    ",
          "    group_info.fixup_slot_ranges().unwrap();",
          "    assert_eq!(group_info.slot_ranges.len(), 1);",
          "    assert_eq!(group_info.slot_ranges[0].0, SmallIndex::new(0).unwrap());",
          "    assert_eq!(group_info.slot_ranges[0].1, SmallIndex::MAX);",
          "    assert!(group_info.fixup_slot_ranges().is_err());",
          "    assert!(matches!(group_info.fixup_slot_ranges(), Err(GroupInfoError { kind: GroupInfoErrorKind::TooManyGroups { pattern, minimum } })));",
          "    assert_eq!(minimum, 1);",
          "    assert_eq!(group_info.memory_extra, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]