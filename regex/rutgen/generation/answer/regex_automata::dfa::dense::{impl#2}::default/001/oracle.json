[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::default();",
          "}"
        ],
        "oracle": [
          "    assert!(builder.config == Config::default());",
          "    assert!(builder.thompson == thompson::Compiler::new());"
        ],
        "code": [
          "{",
          "    let builder = Builder::default();",
          "    assert!(builder.config == Config::default());",
          "    assert!(builder.thompson == thompson::Compiler::new());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let default_config = Config {",
          "        pre: None,",
          "        visited_capacity: None,",
          "        ..Config::default()",
          "    };",
          "    builder.configure(default_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.config.pre, None);",
          "    assert_eq!(builder.config.visited_capacity, None);",
          "    assert_eq!(builder.config.accelerate, None);",
          "    assert_eq!(builder.config.minimize, None);",
          "    assert_eq!(builder.config.match_kind, None);",
          "    assert_eq!(builder.config.start_kind, None);",
          "    assert_eq!(builder.config.starts_for_each_pattern, None);",
          "    assert_eq!(builder.config.byte_classes, None);",
          "    assert_eq!(builder.config.unicode_word_boundary, None);",
          "    assert_eq!(builder.config.quitset, None);",
          "    assert_eq!(builder.config.specialize_start_states, None);",
          "    assert_eq!(builder.config.dfa_size_limit, None);",
          "    assert_eq!(builder.config.determinize_size_limit, None);",
          "    assert_eq!(builder.config.utf8, None);",
          "    assert_eq!(builder.config.reverse, None);",
          "    assert_eq!(builder.config.nfa_size_limit, None);",
          "    assert_eq!(builder.config.shrink, None);",
          "    assert_eq!(builder.config.which_captures, None);",
          "    assert_eq!(builder.config.look_matcher, None);",
          "    assert_eq!(builder.config.unanchored_prefix, None);",
          "    assert_eq!(builder.config.case_insensitive, false);",
          "    assert_eq!(builder.config.multi_line, false);",
          "    assert_eq!(builder.config.dot_matches_new_line, false);",
          "    assert_eq!(builder.config.crlf, false);",
          "    assert_eq!(builder.config.line_terminator, 0);",
          "    assert_eq!(builder.config.swap_greed, false);",
          "    assert_eq!(builder.config.ignore_whitespace, false);",
          "    assert_eq!(builder.config.nest_limit, 0);",
          "    assert_eq!(builder.config.octal, false);"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let default_config = Config {",
          "        pre: None,",
          "        visited_capacity: None,",
          "        ..Config::default()",
          "    };",
          "    builder.configure(default_config);",
          "    assert_eq!(builder.config.pre, None);",
          "    assert_eq!(builder.config.visited_capacity, None);",
          "    assert_eq!(builder.config.accelerate, None);",
          "    assert_eq!(builder.config.minimize, None);",
          "    assert_eq!(builder.config.match_kind, None);",
          "    assert_eq!(builder.config.start_kind, None);",
          "    assert_eq!(builder.config.starts_for_each_pattern, None);",
          "    assert_eq!(builder.config.byte_classes, None);",
          "    assert_eq!(builder.config.unicode_word_boundary, None);",
          "    assert_eq!(builder.config.quitset, None);",
          "    assert_eq!(builder.config.specialize_start_states, None);",
          "    assert_eq!(builder.config.dfa_size_limit, None);",
          "    assert_eq!(builder.config.determinize_size_limit, None);",
          "    assert_eq!(builder.config.utf8, None);",
          "    assert_eq!(builder.config.reverse, None);",
          "    assert_eq!(builder.config.nfa_size_limit, None);",
          "    assert_eq!(builder.config.shrink, None);",
          "    assert_eq!(builder.config.which_captures, None);",
          "    assert_eq!(builder.config.look_matcher, None);",
          "    assert_eq!(builder.config.unanchored_prefix, None);",
          "    assert_eq!(builder.config.case_insensitive, false);",
          "    assert_eq!(builder.config.multi_line, false);",
          "    assert_eq!(builder.config.dot_matches_new_line, false);",
          "    assert_eq!(builder.config.crlf, false);",
          "    assert_eq!(builder.config.line_terminator, 0);",
          "    assert_eq!(builder.config.swap_greed, false);",
          "    assert_eq!(builder.config.ignore_whitespace, false);",
          "    assert_eq!(builder.config.nest_limit, 0);",
          "    assert_eq!(builder.config.octal, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let builder = Builder::default();",
          "    let config = builder.config.clone();",
          "    ",
          "    assert!(config.accelerate.is_none());",
          "    assert!(config.pre.is_none());",
          "    assert!(config.minimize.is_none());",
          "    assert!(config.match_kind.is_none());",
          "    assert!(config.start_kind.is_none());",
          "    assert!(config.starts_for_each_pattern.is_none());",
          "    assert!(config.byte_classes.is_none());",
          "    assert!(config.unicode_word_boundary.is_none());",
          "    assert!(config.quitset.is_none());",
          "    assert!(config.specialize_start_states.is_none());",
          "    assert!(config.dfa_size_limit.is_none());",
          "    assert!(config.determinize_size_limit.is_none());",
          "}"
        ],
        "oracle": [
          "    let builder = Builder::default();",
          "    let config = builder.config.clone();",
          "    ",
          "    assert!(config.accelerate.is_none());",
          "    assert!(config.pre.is_none());",
          "    assert!(config.minimize.is_none());",
          "    assert!(config.match_kind.is_none());",
          "    assert!(config.start_kind.is_none());",
          "    assert!(config.starts_for_each_pattern.is_none());",
          "    assert!(config.byte_classes.is_none());",
          "    assert!(config.unicode_word_boundary.is_none());",
          "    assert!(config.quitset.is_none());",
          "    assert!(config.specialize_start_states.is_none());",
          "    assert!(config.dfa_size_limit.is_none());",
          "    assert!(config.determinize_size_limit.is_none());"
        ],
        "code": [
          "{",
          "    let builder = Builder::default();",
          "    let config = builder.config.clone();",
          "    ",
          "    assert!(config.accelerate.is_none());",
          "    assert!(config.pre.is_none());",
          "    assert!(config.minimize.is_none());",
          "    assert!(config.match_kind.is_none());",
          "    assert!(config.start_kind.is_none());",
          "    assert!(config.starts_for_each_pattern.is_none());",
          "    assert!(config.byte_classes.is_none());",
          "    assert!(config.unicode_word_boundary.is_none());",
          "    assert!(config.quitset.is_none());",
          "    assert!(config.specialize_start_states.is_none());",
          "    assert!(config.dfa_size_limit.is_none());",
          "    assert!(config.determinize_size_limit.is_none());",
          "    let builder = Builder::default();",
          "    let config = builder.config.clone();",
          "    ",
          "    assert!(config.accelerate.is_none());",
          "    assert!(config.pre.is_none());",
          "    assert!(config.minimize.is_none());",
          "    assert!(config.match_kind.is_none());",
          "    assert!(config.start_kind.is_none());",
          "    assert!(config.starts_for_each_pattern.is_none());",
          "    assert!(config.byte_classes.is_none());",
          "    assert!(config.unicode_word_boundary.is_none());",
          "    assert!(config.quitset.is_none());",
          "    assert!(config.specialize_start_states.is_none());",
          "    assert!(config.dfa_size_limit.is_none());",
          "    assert!(config.determinize_size_limit.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let full_config = Config {",
          "        accelerate: Some(false),",
          "        pre: Some(None),",
          "        minimize: Some(false),",
          "        match_kind: Some(MatchKind::Ordinary),",
          "        start_kind: Some(StartKind::First),",
          "        starts_for_each_pattern: Some(false),",
          "        byte_classes: Some(false),",
          "        unicode_word_boundary: Some(false),",
          "        quitset: Some(ByteSet::new()),",
          "        specialize_start_states: Some(false),",
          "        dfa_size_limit: Some(Some(0)),",
          "        determinize_size_limit: Some(Some(0)),",
          "    };",
          "    builder.configure(full_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Builder::default().config.accelerate, None);",
          "    assert_eq!(Builder::default().config.pre, None);",
          "    assert_eq!(Builder::default().config.minimize, None);",
          "    assert_eq!(Builder::default().config.match_kind, None);",
          "    assert_eq!(Builder::default().config.start_kind, None);",
          "    assert_eq!(Builder::default().config.starts_for_each_pattern, None);",
          "    assert_eq!(Builder::default().config.byte_classes, None);",
          "    assert_eq!(Builder::default().config.unicode_word_boundary, None);",
          "    assert_eq!(Builder::default().config.quitset, None);",
          "    assert_eq!(Builder::default().config.specialize_start_states, None);",
          "    assert_eq!(Builder::default().config.dfa_size_limit, None);",
          "    assert_eq!(Builder::default().config.determinize_size_limit, None);"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let full_config = Config {",
          "        accelerate: Some(false),",
          "        pre: Some(None),",
          "        minimize: Some(false),",
          "        match_kind: Some(MatchKind::Ordinary),",
          "        start_kind: Some(StartKind::First),",
          "        starts_for_each_pattern: Some(false),",
          "        byte_classes: Some(false),",
          "        unicode_word_boundary: Some(false),",
          "        quitset: Some(ByteSet::new()),",
          "        specialize_start_states: Some(false),",
          "        dfa_size_limit: Some(Some(0)),",
          "        determinize_size_limit: Some(Some(0)),",
          "    };",
          "    builder.configure(full_config);",
          "    assert_eq!(Builder::default().config.accelerate, None);",
          "    assert_eq!(Builder::default().config.pre, None);",
          "    assert_eq!(Builder::default().config.minimize, None);",
          "    assert_eq!(Builder::default().config.match_kind, None);",
          "    assert_eq!(Builder::default().config.start_kind, None);",
          "    assert_eq!(Builder::default().config.starts_for_each_pattern, None);",
          "    assert_eq!(Builder::default().config.byte_classes, None);",
          "    assert_eq!(Builder::default().config.unicode_word_boundary, None);",
          "    assert_eq!(Builder::default().config.quitset, None);",
          "    assert_eq!(Builder::default().config.specialize_start_states, None);",
          "    assert_eq!(Builder::default().config.dfa_size_limit, None);",
          "    assert_eq!(Builder::default().config.determinize_size_limit, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let minimum_config = Config {",
          "        quitset: Some(ByteSet::new()),",
          "        dfa_size_limit: Some(None),",
          "        determinize_size_limit: Some(None),",
          "        ..Config::default()",
          "    };",
          "    builder.configure(minimum_config);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.config.quitset, Some(ByteSet::new()));",
          "    assert_eq!(builder.config.dfa_size_limit, Some(None));",
          "    assert_eq!(builder.config.determinize_size_limit, Some(None));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let minimum_config = Config {",
          "        quitset: Some(ByteSet::new()),",
          "        dfa_size_limit: Some(None),",
          "        determinize_size_limit: Some(None),",
          "        ..Config::default()",
          "    };",
          "    builder.configure(minimum_config);",
          "    assert_eq!(builder.config.quitset, Some(ByteSet::new()));",
          "    assert_eq!(builder.config.dfa_size_limit, Some(None));",
          "    assert_eq!(builder.config.determinize_size_limit, Some(None));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]