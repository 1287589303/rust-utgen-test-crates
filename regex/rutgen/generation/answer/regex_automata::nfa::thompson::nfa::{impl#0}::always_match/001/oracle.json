[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(builder.start_pattern().is_ok());",
          "    assert_eq!(builder.start_pattern().unwrap().as_usize(), 0);",
          "    assert!(builder.add_capture_start(StateID::ZERO, 0, None).is_ok());",
          "    assert!(builder.add_capture_end(StateID::ZERO, 0).is_ok());",
          "    assert!(builder.add_match().is_ok());",
          "    assert!(builder.patch(start_id, end_id).is_ok());",
          "    assert!(builder.patch(end_id, match_id).is_ok());",
          "    assert!(builder.finish_pattern(start_id).is_ok());",
          "    assert!(builder.build(start_id, start_id).is_ok());"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "    assert!(builder.start_pattern().is_ok());",
          "    assert_eq!(builder.start_pattern().unwrap().as_usize(), 0);",
          "    assert!(builder.add_capture_start(StateID::ZERO, 0, None).is_ok());",
          "    assert!(builder.add_capture_end(StateID::ZERO, 0).is_ok());",
          "    assert!(builder.add_match().is_ok());",
          "    assert!(builder.patch(start_id, end_id).is_ok());",
          "    assert!(builder.patch(end_id, match_id).is_ok());",
          "    assert!(builder.finish_pattern(start_id).is_ok());",
          "    assert!(builder.build(start_id, start_id).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(builder.states.len() > 0);",
          "    assert_eq!(builder.start_pattern.len(), 1);",
          "    assert!(builder.pattern_id.is_none());",
          "    assert!(builder.memory_usage() > 0);",
          "    assert!(builder.has_capture());",
          "    assert!(builder.has_empty());",
          "    assert!(builder.is_utf8());",
          "    assert!(builder.start_pattern[0] == StateID::ZERO);",
          "    assert!(builder.pattern_len() == 1);",
          "    assert!(builder.current_pattern_id().as_usize() == 0);"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "    assert!(builder.states.len() > 0);",
          "    assert_eq!(builder.start_pattern.len(), 1);",
          "    assert!(builder.pattern_id.is_none());",
          "    assert!(builder.memory_usage() > 0);",
          "    assert!(builder.has_capture());",
          "    assert!(builder.has_empty());",
          "    assert!(builder.is_utf8());",
          "    assert!(builder.start_pattern[0] == StateID::ZERO);",
          "    assert!(builder.pattern_len() == 1);",
          "    assert!(builder.current_pattern_id().as_usize() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    builder.set_utf8(true);",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(pid.as_usize(), 0);",
          "    assert!(builder.has_capture());",
          "    assert_eq!(builder.memory_usage(), expected_memory_usage);",
          "    assert!(builder.states.len() > 0);",
          "    assert!(builder.start_pattern.len() > 0);",
          "    assert!(builder.pattern_len() == 1);"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    builder.set_utf8(true);",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "    assert_eq!(pid.as_usize(), 0);",
          "    assert!(builder.has_capture());",
          "    assert_eq!(builder.memory_usage(), expected_memory_usage);",
          "    assert!(builder.states.len() > 0);",
          "    assert!(builder.start_pattern.len() > 0);",
          "    assert!(builder.pattern_len() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    builder.set_reverse(true);",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(builder.is_reverse());",
          "    assert_eq!(builder.pattern_len(), 1);",
          "    assert!(builder.has_capture());",
          "    assert!(builder.start_pattern.len() > 0);",
          "    assert_eq!(builder.start_pattern(0).unwrap(), StateID::ZERO);",
          "    assert_eq!(builder.memory_usage(), 0);",
          "    assert!(builder.add_empty().is_ok());",
          "    assert_eq!(builder.states.len(), 3);",
          "    assert!(builder.finish_pattern(StateID::ZERO).is_ok());",
          "    assert!(builder.add_match().is_ok());",
          "    assert!(builder.add_capture_start(StateID::ZERO, 0, None).is_ok());",
          "    assert!(builder.add_capture_end(StateID::ZERO, 0).is_ok());"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    builder.set_reverse(true);",
          "    let pid = builder.start_pattern().unwrap();",
          "    let start_id = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();",
          "    let match_id = builder.add_match().unwrap();",
          "    builder.patch(start_id, end_id).unwrap();",
          "    builder.patch(end_id, match_id).unwrap();",
          "    let _ = builder.finish_pattern(start_id).unwrap();",
          "    let _ = builder.build(start_id, start_id).unwrap();",
          "    assert!(builder.is_reverse());",
          "    assert_eq!(builder.pattern_len(), 1);",
          "    assert!(builder.has_capture());",
          "    assert!(builder.start_pattern.len() > 0);",
          "    assert_eq!(builder.start_pattern(0).unwrap(), StateID::ZERO);",
          "    assert_eq!(builder.memory_usage(), 0);",
          "    assert!(builder.add_empty().is_ok());",
          "    assert_eq!(builder.states.len(), 3);",
          "    assert!(builder.finish_pattern(StateID::ZERO).is_ok());",
          "    assert!(builder.add_match().is_ok());",
          "    assert!(builder.add_capture_start(StateID::ZERO, 0, None).is_ok());",
          "    assert!(builder.add_capture_end(StateID::ZERO, 0).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]