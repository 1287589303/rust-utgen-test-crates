[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"alpha\"),",
          "        Literal::exact(\"beta\"),",
          "        Literal::exact(\"gamma\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"alpha\"), Literal::exact(\"beta\"), Literal::exact(\"gamma\")]));",
          "    ",
          "    let mut seq_empty = Seq::new(vec![]);",
          "    seq_empty.minimize_by_preference();",
          "    assert_eq!(seq_empty.literals(), Some(&[]));",
          "    ",
          "    let mut seq_inexact = Seq::new(vec![",
          "    Literal::inexact(\"sam\"),",
          "    Literal::exact(\"samwise\"),",
          "    ]);",
          "    seq_inexact.minimize_by_preference();",
          "    assert_eq!(seq_inexact.literals(), Some(&[Literal::inexact(\"sam\"), Literal::exact(\"samwise\")]));",
          "    ",
          "    let mut seq_prefix = Seq::new(vec![",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"bar\"),",
          "    Literal::inexact(\"\"),",
          "    Literal::exact(\"quux\"),",
          "    ]);",
          "    seq_prefix.minimize_by_preference();",
          "    assert_eq!(seq_prefix.literals(), Some(&[Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq_empty_first = Seq::new(vec![",
          "    Literal::inexact(\"\"),",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"quux\"),",
          "    ]);",
          "    seq_empty_first.minimize_by_preference();",
          "    assert_eq!(seq_empty_first.literals(), Some(&[Literal::inexact(\"\")]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"alpha\"),",
          "        Literal::exact(\"beta\"),",
          "        Literal::exact(\"gamma\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"alpha\"), Literal::exact(\"beta\"), Literal::exact(\"gamma\")]));",
          "    ",
          "    let mut seq_empty = Seq::new(vec![]);",
          "    seq_empty.minimize_by_preference();",
          "    assert_eq!(seq_empty.literals(), Some(&[]));",
          "    ",
          "    let mut seq_inexact = Seq::new(vec![",
          "    Literal::inexact(\"sam\"),",
          "    Literal::exact(\"samwise\"),",
          "    ]);",
          "    seq_inexact.minimize_by_preference();",
          "    assert_eq!(seq_inexact.literals(), Some(&[Literal::inexact(\"sam\"), Literal::exact(\"samwise\")]));",
          "    ",
          "    let mut seq_prefix = Seq::new(vec![",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"bar\"),",
          "    Literal::inexact(\"\"),",
          "    Literal::exact(\"quux\"),",
          "    ]);",
          "    seq_prefix.minimize_by_preference();",
          "    assert_eq!(seq_prefix.literals(), Some(&[Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq_empty_first = Seq::new(vec![",
          "    Literal::inexact(\"\"),",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"quux\"),",
          "    ]);",
          "    seq_empty_first.minimize_by_preference();",
          "    assert_eq!(seq_empty_first.literals(), Some(&[Literal::inexact(\"\")]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::inexact(\"alpha\"),",
          "        Literal::inexact(\"beta\"),",
          "        Literal::inexact(\"gamma\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(seq.is_inexact());",
          "    assert!(seq.literals().unwrap().contains(&Literal::inexact(\"alpha\")));",
          "    assert!(seq.literals().unwrap().contains(&Literal::inexact(\"beta\")));",
          "    assert!(seq.literals().unwrap().contains(&Literal::inexact(\"gamma\")));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::inexact(\"alpha\"),",
          "        Literal::inexact(\"beta\"),",
          "        Literal::inexact(\"gamma\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(seq.is_inexact());",
          "    assert!(seq.literals().unwrap().contains(&Literal::inexact(\"alpha\")));",
          "    assert!(seq.literals().unwrap().contains(&Literal::inexact(\"beta\")));",
          "    assert!(seq.literals().unwrap().contains(&Literal::inexact(\"gamma\")));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"alpha\"),",
          "        Literal::exact(\"alpha\"),",
          "        Literal::exact(\"beta\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"alpha\"), Literal::inexact(\"beta\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"a\"),",
          "    Literal::exact(\"b\"),",
          "    Literal::exact(\"c\"),",
          "    Literal::inexact(\"d\"),",
          "    Literal::exact(\"a\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"a\"), Literal::inexact(\"b\"), Literal::inexact(\"c\"), Literal::inexact(\"d\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"x\"),",
          "    Literal::inexact(\"y\"),",
          "    Literal::exact(\"x\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"x\"), Literal::inexact(\"y\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::inexact(\"\"]),",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"bar\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"\"), Literal::exact(\"foo\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"\"),",
          "    Literal::exact(\"baz\"),",
          "    Literal::exact(\"quux\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"\"), Literal::exact(\"baz\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::inexact(\"foo\"),",
          "    Literal::inexact(\"bar\"),",
          "    Literal::inexact(\"\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"foo\"), Literal::inexact(\"bar\"), Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"first\"),",
          "    Literal::exact(\"first\"),",
          "    Literal::exact(\"second\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"first\"), Literal::inexact(\"second\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"A\"),",
          "    Literal::exact(\"B\"),",
          "    Literal::inexact(\"C\"),",
          "    Literal::exact(\"A\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"A\"), Literal::inexact(\"B\"), Literal::inexact(\"C\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"hello\"),",
          "    Literal::exact(\"world\"),",
          "    Literal::inexact(\"hello\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"hello\"), Literal::inexact(\"world\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"test\"),",
          "    Literal::exact(\"test\"),",
          "    Literal::exact(\"example\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"test\"), Literal::inexact(\"example\")]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"alpha\"),",
          "        Literal::exact(\"alpha\"),",
          "        Literal::exact(\"beta\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"alpha\"), Literal::inexact(\"beta\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"a\"),",
          "    Literal::exact(\"b\"),",
          "    Literal::exact(\"c\"),",
          "    Literal::inexact(\"d\"),",
          "    Literal::exact(\"a\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"a\"), Literal::inexact(\"b\"), Literal::inexact(\"c\"), Literal::inexact(\"d\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"x\"),",
          "    Literal::inexact(\"y\"),",
          "    Literal::exact(\"x\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"x\"), Literal::inexact(\"y\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::inexact(\"\"]),",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"bar\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"\"), Literal::exact(\"foo\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"\"),",
          "    Literal::exact(\"baz\"),",
          "    Literal::exact(\"quux\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"\"), Literal::exact(\"baz\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::inexact(\"foo\"),",
          "    Literal::inexact(\"bar\"),",
          "    Literal::inexact(\"\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"foo\"), Literal::inexact(\"bar\"), Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"first\"),",
          "    Literal::exact(\"first\"),",
          "    Literal::exact(\"second\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"first\"), Literal::inexact(\"second\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"A\"),",
          "    Literal::exact(\"B\"),",
          "    Literal::inexact(\"C\"),",
          "    Literal::exact(\"A\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"A\"), Literal::inexact(\"B\"), Literal::inexact(\"C\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"hello\"),",
          "    Literal::exact(\"world\"),",
          "    Literal::inexact(\"hello\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"hello\"), Literal::inexact(\"world\")]));",
          "    ",
          "    let mut seq = Seq::new(vec![",
          "    Literal::exact(\"test\"),",
          "    Literal::exact(\"test\"),",
          "    Literal::exact(\"example\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"test\"), Literal::inexact(\"example\")]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"foo\"),",
          "        Literal::exact(\"bar\"),",
          "        Literal::inexact(\"\"),",
          "        Literal::exact(\"quux\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap(), &[Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::inexact(\"\")]);",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(!seq.is_exact());",
          "    assert!(seq.is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"foo\"),",
          "        Literal::exact(\"bar\"),",
          "        Literal::inexact(\"\"),",
          "        Literal::exact(\"quux\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals().unwrap(), &[Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::inexact(\"\")]);",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(!seq.is_exact());",
          "    assert!(seq.is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::inexact(\"\"),",
          "        Literal::exact(\"foo\"),",
          "        Literal::exact(\"quux\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"\"), Literal::exact(\"foo\"), Literal::exact(\"quux\")]));",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(!seq.is_exact());",
          "    assert!(seq.is_inexact());",
          "    assert_eq!(seq.max_literal_len(), Some(5));",
          "    assert_eq!(seq.min_literal_len(), Some(0));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::inexact(\"\"),",
          "        Literal::exact(\"foo\"),",
          "        Literal::exact(\"quux\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(\"\"), Literal::exact(\"foo\"), Literal::exact(\"quux\")]));",
          "    assert!(seq.is_finite());",
          "    assert!(!seq.is_empty());",
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(!seq.is_exact());",
          "    assert!(seq.is_inexact());",
          "    assert_eq!(seq.max_literal_len(), Some(5));",
          "    assert_eq!(seq.min_literal_len(), Some(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"alpha\"),",
          "        Literal::inexact(\"beta\"),",
          "        Literal::exact(\"alpha\"),",
          "        Literal::inexact(\"delta\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"alpha\"), Literal::inexact(\"beta\"), Literal::inexact(\"delta\")]));",
          "    ",
          "    let mut seq_empty = Seq::new(vec![",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"bar\"),",
          "    Literal::inexact(\"\"),",
          "    Literal::inexact(\"quux\"),",
          "    Literal::inexact(\"fox\"),",
          "    ]);",
          "    seq_empty.minimize_by_preference();",
          "    assert_eq!(seq_empty.literals(), Some(&[Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq_empty_start = Seq::new(vec![",
          "    Literal::inexact(\"\"),",
          "    Literal::exact(\"foo\"),",
          "    Literal::inexact(\"quux\"),",
          "    Literal::inexact(\"fox\"),",
          "    ]);",
          "    seq_empty_start.minimize_by_preference();",
          "    assert_eq!(seq_empty_start.literals(), Some(&[Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq_singleton = Seq::new(vec![Literal::exact(\"sam\")]);",
          "    seq_singleton.minimize_by_preference();",
          "    assert_eq!(seq_singleton.literals(), Some(&[Literal::exact(\"sam\")]));",
          "    ",
          "    let mut seq_duplicate = Seq::new(vec![",
          "    Literal::inexact(\"alpha\"),",
          "    Literal::exact(\"alpha\"),",
          "    Literal::inexact(\"beta\"),",
          "    Literal::exact(\"beta\"),",
          "    ]);",
          "    seq_duplicate.minimize_by_preference();",
          "    assert_eq!(seq_duplicate.literals(), Some(&[Literal::inexact(\"alpha\"), Literal::exact(\"beta\")]));",
          "    ",
          "    let mut seq_reversed = Seq::new(vec![",
          "    Literal::exact(\"samwise\"),",
          "    Literal::exact(\"sam\"),",
          "    ]);",
          "    seq_reversed.minimize_by_preference();",
          "    assert_eq!(seq_reversed.literals(), Some(&[Literal::exact(\"samwise\"), Literal::exact(\"sam\")]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::exact(\"alpha\"),",
          "        Literal::inexact(\"beta\"),",
          "        Literal::exact(\"alpha\"),",
          "        Literal::inexact(\"delta\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(\"alpha\"), Literal::inexact(\"beta\"), Literal::inexact(\"delta\")]));",
          "    ",
          "    let mut seq_empty = Seq::new(vec![",
          "    Literal::exact(\"foo\"),",
          "    Literal::exact(\"bar\"),",
          "    Literal::inexact(\"\"),",
          "    Literal::inexact(\"quux\"),",
          "    Literal::inexact(\"fox\"),",
          "    ]);",
          "    seq_empty.minimize_by_preference();",
          "    assert_eq!(seq_empty.literals(), Some(&[Literal::exact(\"foo\"), Literal::exact(\"bar\"), Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq_empty_start = Seq::new(vec![",
          "    Literal::inexact(\"\"),",
          "    Literal::exact(\"foo\"),",
          "    Literal::inexact(\"quux\"),",
          "    Literal::inexact(\"fox\"),",
          "    ]);",
          "    seq_empty_start.minimize_by_preference();",
          "    assert_eq!(seq_empty_start.literals(), Some(&[Literal::inexact(\"\")]));",
          "    ",
          "    let mut seq_singleton = Seq::new(vec![Literal::exact(\"sam\")]);",
          "    seq_singleton.minimize_by_preference();",
          "    assert_eq!(seq_singleton.literals(), Some(&[Literal::exact(\"sam\")]));",
          "    ",
          "    let mut seq_duplicate = Seq::new(vec![",
          "    Literal::inexact(\"alpha\"),",
          "    Literal::exact(\"alpha\"),",
          "    Literal::inexact(\"beta\"),",
          "    Literal::exact(\"beta\"),",
          "    ]);",
          "    seq_duplicate.minimize_by_preference();",
          "    assert_eq!(seq_duplicate.literals(), Some(&[Literal::inexact(\"alpha\"), Literal::exact(\"beta\")]));",
          "    ",
          "    let mut seq_reversed = Seq::new(vec![",
          "    Literal::exact(\"samwise\"),",
          "    Literal::exact(\"sam\"),",
          "    ]);",
          "    seq_reversed.minimize_by_preference();",
          "    assert_eq!(seq_reversed.literals(), Some(&[Literal::exact(\"samwise\"), Literal::exact(\"sam\")]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::inexact(\"\"),",
          "        Literal::exact(\"foo\"),",
          "        Literal::exact(\"bar\"),",
          "        Literal::exact(\"baz\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].kind, LiteralKind::Exact);",
          "    assert_eq!(seq.literals().unwrap()[1].kind, LiteralKind::Exact);",
          "    assert_eq!(seq.literals().unwrap()[2].kind, LiteralKind::Inexact);",
          "    assert_eq!(seq.literals().unwrap()[0].c, 'f');",
          "    assert_eq!(seq.literals().unwrap()[1].c, 'b');",
          "    assert_eq!(seq.literals().unwrap()[2].c, '');"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![",
          "        Literal::inexact(\"\"),",
          "        Literal::exact(\"foo\"),",
          "        Literal::exact(\"bar\"),",
          "        Literal::exact(\"baz\"),",
          "    ]);",
          "    seq.minimize_by_preference();",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].kind, LiteralKind::Exact);",
          "    assert_eq!(seq.literals().unwrap()[1].kind, LiteralKind::Exact);",
          "    assert_eq!(seq.literals().unwrap()[2].kind, LiteralKind::Inexact);",
          "    assert_eq!(seq.literals().unwrap()[0].c, 'f');",
          "    assert_eq!(seq.literals().unwrap()[1].c, 'b');",
          "    assert_eq!(seq.literals().unwrap()[2].c, '');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]