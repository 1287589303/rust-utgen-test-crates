[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler::new();",
          "    let nfa = compiler.build(\"a\").unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(compiler.build(\"a\").is_ok(), true);",
          "    assert_eq!(compiler.build(\"a\").unwrap().states.len(), expected_states_for_a);",
          "    assert_eq!(compiler.build(\"b\").is_ok(), true);",
          "    assert_eq!(compiler.build(\"b\").unwrap().states.len(), expected_states_for_b);",
          "    assert_eq!(compiler.build(\"[a-z]\").is_ok(), true);",
          "    assert_eq!(compiler.build(\"[a-z]\").unwrap().states.len(), expected_states_for_range);",
          "    assert!(compiler.build(\"\").is_err());",
          "    assert!(compiler.build(\"a{1000}\").is_err());  // Test against size limit",
          "    assert!(compiler.build(\"([a-z]+)\").is_ok());  // Test complex regex",
          "    assert_eq!(compiler.build(\".*\").is_ok(), true);",
          "    assert_eq!(compiler.build(\".*\").unwrap().states.len(), expected_states_for_wildcard);"
        ],
        "code": [
          "{",
          "    let compiler = Compiler::new();",
          "    let nfa = compiler.build(\"a\").unwrap();",
          "    assert_eq!(compiler.build(\"a\").is_ok(), true);",
          "    assert_eq!(compiler.build(\"a\").unwrap().states.len(), expected_states_for_a);",
          "    assert_eq!(compiler.build(\"b\").is_ok(), true);",
          "    assert_eq!(compiler.build(\"b\").unwrap().states.len(), expected_states_for_b);",
          "    assert_eq!(compiler.build(\"[a-z]\").is_ok(), true);",
          "    assert_eq!(compiler.build(\"[a-z]\").unwrap().states.len(), expected_states_for_range);",
          "    assert!(compiler.build(\"\").is_err());",
          "    assert!(compiler.build(\"a{1000}\").is_err());  // Test against size limit",
          "    assert!(compiler.build(\"([a-z]+)\").is_ok());  // Test complex regex",
          "    assert_eq!(compiler.build(\".*\").is_ok(), true);",
          "    assert_eq!(compiler.build(\".*\").unwrap().states.len(), expected_states_for_wildcard);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler::new();",
          "    let nfa = compiler.build(\"a|b|c\").unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nfa.start_pattern.len(), 1);",
          "    assert!(nfa.states.len() > 0);",
          "    assert!(nfa.memory_states > 0);",
          "    assert!(!nfa.reverse);",
          "    assert_eq!(nfa.utf8, true);",
          "    assert_eq!(nfa.look_matcher, default_look_matcher());",
          "    assert!(nfa.size_limit.is_none());",
          "    assert!(nfa.captures[0].is_empty());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler::new();",
          "    let nfa = compiler.build(\"a|b|c\").unwrap();",
          "    assert_eq!(nfa.start_pattern.len(), 1);",
          "    assert!(nfa.states.len() > 0);",
          "    assert!(nfa.memory_states > 0);",
          "    assert!(!nfa.reverse);",
          "    assert_eq!(nfa.utf8, true);",
          "    assert_eq!(nfa.look_matcher, default_look_matcher());",
          "    assert!(nfa.size_limit.is_none());",
          "    assert!(nfa.captures[0].is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler::new();",
          "    let nfa = compiler.build(\"\").unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(compiler.build(\"\").is_ok());",
          "    assert_eq!(compiler.build(\"\").unwrap(), /* expected NFA for empty pattern */);",
          "    assert_eq!(compiler.build(\"abc\").is_ok(), true);",
          "    assert!(compiler.build(\"abc\").is_ok());",
          "    assert!(compiler.build(\"(?-u)\\\\w\").is_ok());",
          "    assert!(compiler.build(\"(?-u)\\\\d\").is_ok());",
          "    assert!(compiler.build(\".*\").is_ok());",
          "    assert!(compiler.build(\"[a-z]\").is_ok());",
          "    assert!(compiler.build(\"a|b\").is_ok());",
          "    assert!(compiler.build(\"(?i)abc\").is_ok());",
          "    assert!(compiler.build(\"a*\").is_ok());",
          "    assert!(compiler.build(\"a+\").is_ok());",
          "    assert!(compiler.build(\"a?\").is_ok());",
          "    assert!(compiler.build(\"(?x)a # comment\").is_ok());",
          "    assert!(compiler.build(r\"\\w+\").is_ok());",
          "    assert!(compiler.build(\"(^|\\\\s)pattern(\\\\s|$)\").is_ok());",
          "    assert!(compiler.build(\"[^a-z]\").is_ok());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler::new();",
          "    let nfa = compiler.build(\"\").unwrap();",
          "    assert!(compiler.build(\"\").is_ok());",
          "    assert_eq!(compiler.build(\"\").unwrap(), /* expected NFA for empty pattern */);",
          "    assert_eq!(compiler.build(\"abc\").is_ok(), true);",
          "    assert!(compiler.build(\"abc\").is_ok());",
          "    assert!(compiler.build(\"(?-u)\\\\w\").is_ok());",
          "    assert!(compiler.build(\"(?-u)\\\\d\").is_ok());",
          "    assert!(compiler.build(\".*\").is_ok());",
          "    assert!(compiler.build(\"[a-z]\").is_ok());",
          "    assert!(compiler.build(\"a|b\").is_ok());",
          "    assert!(compiler.build(\"(?i)abc\").is_ok());",
          "    assert!(compiler.build(\"a*\").is_ok());",
          "    assert!(compiler.build(\"a+\").is_ok());",
          "    assert!(compiler.build(\"a?\").is_ok());",
          "    assert!(compiler.build(\"(?x)a # comment\").is_ok());",
          "    assert!(compiler.build(r\"\\w+\").is_ok());",
          "    assert!(compiler.build(\"(^|\\\\s)pattern(\\\\s|$)\").is_ok());",
          "    assert!(compiler.build(\"[^a-z]\").is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler::new();",
          "    let result = compiler.build(\"[\");",
          "    assert!(result.is_err());",
          "}"
        ],
        "oracle": [
          "    assert!(compiler.build(\"[\") == Err(BuildError::syntax(_)));",
          "    assert!(compiler.build(\"\") == Err(BuildError::syntax(_)));",
          "    assert!(compiler.build(\"(?-u)\\\\w\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"[^a-z]\") == Ok(NFA(_)));",
          "    assert!(compiler.build(\"(.|\\\\s)\") == Ok(NFA(_)));",
          "    assert!(compiler.build(\".*\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"\\d+\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"(?i)abc\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"[a-z]{3,5}\") == Ok(NFA(_)));",
          "    assert!(compiler.build(\"a{10000}\") == Err(BuildError::size_limit_exceeded(_)));"
        ],
        "code": [
          "{",
          "    let compiler = Compiler::new();",
          "    let result = compiler.build(\"[\");",
          "    assert!(result.is_err());",
          "    assert!(compiler.build(\"[\") == Err(BuildError::syntax(_)));",
          "    assert!(compiler.build(\"\") == Err(BuildError::syntax(_)));",
          "    assert!(compiler.build(\"(?-u)\\\\w\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"[^a-z]\") == Ok(NFA(_)));",
          "    assert!(compiler.build(\"(.|\\\\s)\") == Ok(NFA(_)));",
          "    assert!(compiler.build(\".*\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"\\d+\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"(?i)abc\") == Ok(NFA(_)));",
          "    assert!(compiler.build(r\"[a-z]{3,5}\") == Ok(NFA(_)));",
          "    assert!(compiler.build(\"a{10000}\") == Err(BuildError::size_limit_exceeded(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let config = Config { nfa_size_limit: Some(1), ..Default::default() };",
          "    compiler.configure(config);",
          "    let result = compiler.build(\"a{100}\");",
          "    assert!(result.is_err());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::SizeLimitExceeded);",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::TooManyStates);"
        ],
        "code": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let config = Config { nfa_size_limit: Some(1), ..Default::default() };",
          "    compiler.configure(config);",
          "    let result = compiler.build(\"a{100}\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::SizeLimitExceeded);",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::TooManyStates);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler::new();",
          "    let result = compiler.build(\"(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z){1000}\");",
          "    assert!(result.is_err());",
          "}"
        ],
        "oracle": [
          "    compiler.build(\"(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z){1000}\").is_err()"
        ],
        "code": [
          "{",
          "    let compiler = Compiler::new();",
          "    let result = compiler.build(\"(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z){1000}\");",
          "    assert!(result.is_err());",
          "    compiler.build(\"(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z){1000}\").is_err()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let config = Config { utf8: Some(true), ..Default::default() };",
          "    compiler.configure(config);",
          "    let nfa = compiler.build(r\"\\w\").unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nfa.states.len(), expected_states_len);",
          "    assert_eq!(nfa.start_pattern, expected_start_pattern);",
          "    assert!(nfa.utf8);",
          "    assert!(nfa.look_matcher.is_some());",
          "    assert!(nfa.memory_states < expected_memory_limit);",
          "    assert!(nfa.size_limit.is_some());",
          "    assert_eq!(nfa.pattern_id, Some(expected_pattern_id));"
        ],
        "code": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let config = Config { utf8: Some(true), ..Default::default() };",
          "    compiler.configure(config);",
          "    let nfa = compiler.build(r\"\\w\").unwrap();",
          "    assert_eq!(nfa.states.len(), expected_states_len);",
          "    assert_eq!(nfa.start_pattern, expected_start_pattern);",
          "    assert!(nfa.utf8);",
          "    assert!(nfa.look_matcher.is_some());",
          "    assert!(nfa.memory_states < expected_memory_limit);",
          "    assert!(nfa.size_limit.is_some());",
          "    assert_eq!(nfa.pattern_id, Some(expected_pattern_id));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let config = Config { reverse: Some(true), ..Default::default() };",
          "    compiler.configure(config);",
          "    let nfa = compiler.build(\"abc\").unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(nfa.is_ok());",
          "    assert_eq!(nfa.states.len(), expected_state_count);",
          "    assert_eq!(nfa.start_states, expected_start_states);",
          "    assert!(nfa.size() <= compiler.config.nfa_size_limit.unwrap_or_default());",
          "    assert!(nfa.is_reverse());",
          "    assert!(nfa.match_kind == compiler.config.match_kind);",
          "    assert!(nfa.memory_states <= compiler.config.active_size_limit.unwrap_or(0));",
          "    assert!(nfa.utf8 == compiler.config.utf8);",
          "    assert!(nfa.utf8_old == compiler.config.utf8_empty.unwrap_or(false));",
          "    assert!(nfa.memory_states <= compiler.config.memory_states);",
          "    assert!(nfa.memory_states > 0);",
          "    assert_eq!(nfa.captures.len(), expected_captures_count);",
          "    assert_eq!(nfa.states.first().unwrap().id, expected_first_state_id);",
          "    assert_eq!(nfa.size_limit(), compiler.config.nfa_size_limit);",
          "    assert_eq!(nfa.transitions.len(), expected_transitions_count);",
          "    assert!(nfa.start_pattern.first().unwrap().is_some());",
          "    assert!(nfa.get_memory_usage().is_positive());",
          "    assert!(nfa.growable());",
          "    assert!(nfa.has_final_state());",
          "    assert_eq!(nfa.final_state.id, expected_final_state_id);"
        ],
        "code": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let config = Config { reverse: Some(true), ..Default::default() };",
          "    compiler.configure(config);",
          "    let nfa = compiler.build(\"abc\").unwrap();",
          "    assert!(nfa.is_ok());",
          "    assert_eq!(nfa.states.len(), expected_state_count);",
          "    assert_eq!(nfa.start_states, expected_start_states);",
          "    assert!(nfa.size() <= compiler.config.nfa_size_limit.unwrap_or_default());",
          "    assert!(nfa.is_reverse());",
          "    assert!(nfa.match_kind == compiler.config.match_kind);",
          "    assert!(nfa.memory_states <= compiler.config.active_size_limit.unwrap_or(0));",
          "    assert!(nfa.utf8 == compiler.config.utf8);",
          "    assert!(nfa.utf8_old == compiler.config.utf8_empty.unwrap_or(false));",
          "    assert!(nfa.memory_states <= compiler.config.memory_states);",
          "    assert!(nfa.memory_states > 0);",
          "    assert_eq!(nfa.captures.len(), expected_captures_count);",
          "    assert_eq!(nfa.states.first().unwrap().id, expected_first_state_id);",
          "    assert_eq!(nfa.size_limit(), compiler.config.nfa_size_limit);",
          "    assert_eq!(nfa.transitions.len(), expected_transitions_count);",
          "    assert!(nfa.start_pattern.first().unwrap().is_some());",
          "    assert!(nfa.get_memory_usage().is_positive());",
          "    assert!(nfa.growable());",
          "    assert!(nfa.has_final_state());",
          "    assert_eq!(nfa.final_state.id, expected_final_state_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]