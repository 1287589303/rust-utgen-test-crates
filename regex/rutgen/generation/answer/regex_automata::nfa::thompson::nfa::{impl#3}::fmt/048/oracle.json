[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id1 = StateID(SmallIndex::from_usize(0));",
          "    let state_id2 = StateID(SmallIndex::from_usize(1));",
          "    ",
          "    let pattern_id = PatternID::from_usize(0);",
          "    ",
          "    let nfa = Inner {",
          "        states: Vec::new(),",
          "        start_anchored: state_id1,",
          "        start_unanchored: state_id2,",
          "        start_pattern: vec![state_id1, state_id2],",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes: ByteClasses::default(),",
          "        has_capture: false,",
          "        has_empty: false,",
          "        utf8: false,",
          "        reverse: false,",
          "        look_matcher: LookMatcher::default(),",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    let _result = nfa.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    writeln!(f, \"thompson::NFA(\")?;",
          "    self.states.clear();",
          "    assert!(self.states.is_empty());",
          "    let pattern_len = self.start_pattern.len();",
          "    assert!(pattern_len > 1);",
          "    writeln!(f, \"\")?;",
          "    for pid in 0..pattern_len {",
          "    assert!(pid < pattern_len);",
          "    let sid = self.start_pattern[pid];",
          "    assert!(writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize()).is_err());",
          "    }"
        ],
        "code": [
          "{",
          "    let state_id1 = StateID(SmallIndex::from_usize(0));",
          "    let state_id2 = StateID(SmallIndex::from_usize(1));",
          "    ",
          "    let pattern_id = PatternID::from_usize(0);",
          "    ",
          "    let nfa = Inner {",
          "        states: Vec::new(),",
          "        start_anchored: state_id1,",
          "        start_unanchored: state_id2,",
          "        start_pattern: vec![state_id1, state_id2],",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes: ByteClasses::default(),",
          "        has_capture: false,",
          "        has_empty: false,",
          "        utf8: false,",
          "        reverse: false,",
          "        look_matcher: LookMatcher::default(),",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    let _result = nfa.fmt(&mut formatter);",
          "    writeln!(f, \"thompson::NFA(\")?;",
          "    self.states.clear();",
          "    assert!(self.states.is_empty());",
          "    let pattern_len = self.start_pattern.len();",
          "    assert!(pattern_len > 1);",
          "    writeln!(f, \"\")?;",
          "    for pid in 0..pattern_len {",
          "    assert!(pid < pattern_len);",
          "    let sid = self.start_pattern[pid];",
          "    assert!(writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize()).is_err());",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id1 = StateID(SmallIndex::from_usize(0));",
          "    let state_id2 = StateID(SmallIndex::from_usize(1));",
          "",
          "    let nfa = Inner {",
          "        states: Vec::new(),",
          "        start_anchored: state_id1,",
          "        start_unanchored: state_id2,",
          "        start_pattern: vec![state_id1, state_id2],",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes: ByteClasses::default(),",
          "        has_capture: false,",
          "        has_empty: false,",
          "        utf8: false,",
          "        reverse: false,",
          "        look_matcher: LookMatcher::default(),",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    let _result = nfa.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    writeln!(f, \"thompson::NFA(\")? == Ok(())",
          "    self.states.iter().with_state_ids().len() == 0",
          "    pattern_len > 1 == true",
          "    writeln!(f, \"\")? == Ok(())",
          "    (0..pattern_len).contains(&pid)",
          "    writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize())? == Err(())"
        ],
        "code": [
          "{",
          "    let state_id1 = StateID(SmallIndex::from_usize(0));",
          "    let state_id2 = StateID(SmallIndex::from_usize(1));",
          "",
          "    let nfa = Inner {",
          "        states: Vec::new(),",
          "        start_anchored: state_id1,",
          "        start_unanchored: state_id2,",
          "        start_pattern: vec![state_id1, state_id2],",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes: ByteClasses::default(),",
          "        has_capture: false,",
          "        has_empty: false,",
          "        utf8: false,",
          "        reverse: false,",
          "        look_matcher: LookMatcher::default(),",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    let _result = nfa.fmt(&mut formatter);",
          "    writeln!(f, \"thompson::NFA(\")? == Ok(())",
          "    self.states.iter().with_state_ids().len() == 0",
          "    pattern_len > 1 == true",
          "    writeln!(f, \"\")? == Ok(())",
          "    (0..pattern_len).contains(&pid)",
          "    writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize())? == Err(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]