[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id_1 = StateID(SmallIndex::new(1));",
          "    let state_id_2 = StateID(SmallIndex::new(2));",
          "    let state_id_3 = StateID(SmallIndex::new(3));",
          "    ",
          "    let states = vec![",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "    ];",
          "    ",
          "    let start_anchored = StateID(SmallIndex::new(0));",
          "    let start_unanchored = StateID(SmallIndex::new(1));",
          "    let start_pattern = vec![state_id_1, state_id_2];",
          "",
          "    let byte_classes = ByteClasses([0; 256]);",
          "    ",
          "    let inner = Inner {",
          "        states,",
          "        start_anchored,",
          "        start_unanchored,",
          "        start_pattern,",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes,",
          "        has_capture: false,",
          "        has_empty: false,",
          "        utf8: false,",
          "        reverse: false,",
          "        look_matcher: LookMatcher { lineterm: DebugByte::default() },",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let result = inner.fmt(&mut fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    writeln!(f, \"thompson::NFA(\")? at line 1461 is Ok/Some",
          "    (sid, state) in self.states.iter().with_state_ids() at line 1462 is true",
          "    sid == self.start_anchored at line 1463 is false",
          "    sid == self.start_unanchored at line 1465 is false",
          "    writeln!(f, \"{}{:06?}: {:?}\", status, sid.as_usize(), state)? at line 1470 is Ok/Some",
          "    (sid, state) in self.states.iter().with_state_ids() at line 1462 is false",
          "    pattern_len > 1 at line 1473 is true",
          "    writeln!(f, \"\")? at line 1474 is Ok/Some",
          "    pid in 0..pattern_len at line 1475 is true",
          "    writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize())? at line 1477 is Ok/Some",
          "    pid in 0..pattern_len at line 1475 is false",
          "    writeln!(f, \"\")? at line 1480 is Ok/Some",
          "    writeln!(f, \"transition equivalence classes: {:?}\", self.byte_classes,)? at line 1481 is Ok/Some",
          "    writeln!(f, \")\")? at line 1486 is Ok/Some",
          "    result is Ok(())"
        ],
        "code": [
          "{",
          "    let state_id_1 = StateID(SmallIndex::new(1));",
          "    let state_id_2 = StateID(SmallIndex::new(2));",
          "    let state_id_3 = StateID(SmallIndex::new(3));",
          "    ",
          "    let states = vec![",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "    ];",
          "    ",
          "    let start_anchored = StateID(SmallIndex::new(0));",
          "    let start_unanchored = StateID(SmallIndex::new(1));",
          "    let start_pattern = vec![state_id_1, state_id_2];",
          "",
          "    let byte_classes = ByteClasses([0; 256]);",
          "    ",
          "    let inner = Inner {",
          "        states,",
          "        start_anchored,",
          "        start_unanchored,",
          "        start_pattern,",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes,",
          "        has_capture: false,",
          "        has_empty: false,",
          "        utf8: false,",
          "        reverse: false,",
          "        look_matcher: LookMatcher { lineterm: DebugByte::default() },",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let result = inner.fmt(&mut fmt::Formatter::new());",
          "    writeln!(f, \"thompson::NFA(\")? at line 1461 is Ok/Some",
          "    (sid, state) in self.states.iter().with_state_ids() at line 1462 is true",
          "    sid == self.start_anchored at line 1463 is false",
          "    sid == self.start_unanchored at line 1465 is false",
          "    writeln!(f, \"{}{:06?}: {:?}\", status, sid.as_usize(), state)? at line 1470 is Ok/Some",
          "    (sid, state) in self.states.iter().with_state_ids() at line 1462 is false",
          "    pattern_len > 1 at line 1473 is true",
          "    writeln!(f, \"\")? at line 1474 is Ok/Some",
          "    pid in 0..pattern_len at line 1475 is true",
          "    writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize())? at line 1477 is Ok/Some",
          "    pid in 0..pattern_len at line 1475 is false",
          "    writeln!(f, \"\")? at line 1480 is Ok/Some",
          "    writeln!(f, \"transition equivalence classes: {:?}\", self.byte_classes,)? at line 1481 is Ok/Some",
          "    writeln!(f, \")\")? at line 1486 is Ok/Some",
          "    result is Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id_1 = StateID(SmallIndex::new(1));",
          "    let state_id_2 = StateID(SmallIndex::new(2));",
          "    ",
          "    let states = vec![",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "    ];",
          "    ",
          "    let start_anchored = StateID(SmallIndex::new(0));",
          "    let start_unanchored = StateID(SmallIndex::new(1));",
          "    let start_pattern = vec![state_id_1, state_id_2];",
          "",
          "    let byte_classes = ByteClasses([0; 256]);",
          "",
          "    let inner = Inner {",
          "        states,",
          "        start_anchored,",
          "        start_unanchored,",
          "        start_pattern,",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes,",
          "        has_capture: true,",
          "        has_empty: true,",
          "        utf8: true,",
          "        reverse: true,",
          "        look_matcher: LookMatcher { lineterm: DebugByte::default() },",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let result = inner.fmt(&mut fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    writeln!(f, \"thompson::NFA(\")? == Ok(())",
          "    (sid, state) in self.states.iter().with_state_ids() is true",
          "    sid == self.start_anchored is false",
          "    sid == self.start_unanchored is false",
          "    writeln!(f, \"{}{:06?}: {:?}\", status, sid.as_usize(), state)? == Ok(())",
          "    (sid, state) in self.states.iter().with_state_ids() is false",
          "    pattern_len > 1 is true",
          "    writeln!(f, \"\")? == Ok(())",
          "    pid in 0..pattern_len is true",
          "    writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize())? == Ok(())",
          "    pid in 0..pattern_len is false",
          "    writeln!(f, \"\")? == Ok(())",
          "    writeln!(f, \"transition equivalence classes: {:?}\", self.byte_classes)? == Ok(())",
          "    writeln!(f, \")\")? == Ok(())",
          "    result == Ok(())"
        ],
        "code": [
          "{",
          "    let state_id_1 = StateID(SmallIndex::new(1));",
          "    let state_id_2 = StateID(SmallIndex::new(2));",
          "    ",
          "    let states = vec![",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "        State { transitions: vec![] },",
          "    ];",
          "    ",
          "    let start_anchored = StateID(SmallIndex::new(0));",
          "    let start_unanchored = StateID(SmallIndex::new(1));",
          "    let start_pattern = vec![state_id_1, state_id_2];",
          "",
          "    let byte_classes = ByteClasses([0; 256]);",
          "",
          "    let inner = Inner {",
          "        states,",
          "        start_anchored,",
          "        start_unanchored,",
          "        start_pattern,",
          "        group_info: GroupInfo::default(),",
          "        byte_class_set: ByteClassSet::default(),",
          "        byte_classes,",
          "        has_capture: true,",
          "        has_empty: true,",
          "        utf8: true,",
          "        reverse: true,",
          "        look_matcher: LookMatcher { lineterm: DebugByte::default() },",
          "        look_set_any: LookSet::default(),",
          "        look_set_prefix_any: LookSet::default(),",
          "        memory_extra: 0,",
          "    };",
          "",
          "    let result = inner.fmt(&mut fmt::Formatter::new());",
          "    writeln!(f, \"thompson::NFA(\")? == Ok(())",
          "    (sid, state) in self.states.iter().with_state_ids() is true",
          "    sid == self.start_anchored is false",
          "    sid == self.start_unanchored is false",
          "    writeln!(f, \"{}{:06?}: {:?}\", status, sid.as_usize(), state)? == Ok(())",
          "    (sid, state) in self.states.iter().with_state_ids() is false",
          "    pattern_len > 1 is true",
          "    writeln!(f, \"\")? == Ok(())",
          "    pid in 0..pattern_len is true",
          "    writeln!(f, \"START({:06?}): {:?}\", pid, sid.as_usize())? == Ok(())",
          "    pid in 0..pattern_len is false",
          "    writeln!(f, \"\")? == Ok(())",
          "    writeln!(f, \"transition equivalence classes: {:?}\", self.byte_classes)? == Ok(())",
          "    writeln!(f, \")\")? == Ok(())",
          "    result == Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]