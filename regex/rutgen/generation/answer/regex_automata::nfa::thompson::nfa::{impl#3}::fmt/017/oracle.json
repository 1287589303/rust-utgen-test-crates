[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2)); // This will be the unanchored state",
          "    let state_id_3 = StateID(SmallIndex(3)); // Anchored state",
          "",
          "    let state_2 = State {",
          "        id: state_id_2,",
          "        stride2: 0,",
          "        transitions: &[state_id_1.0, state_id_3.0],",
          "    };",
          "    ",
          "    let state_3 = State {",
          "        id: state_id_3,",
          "        stride2: 1,",
          "        transitions: &[state_id_1.0],",
          "    };",
          "",
          "    let inner = Inner {",
          "        states: vec![state_2.clone(), state_3.clone()],",
          "        start_anchored: state_id_3,",
          "        start_unanchored: state_id_2,",
          "        start_pattern: vec![state_id_2],",
          "        byte_classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "",
          "    let mut output = String::new();",
          "    let _result = inner.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(output, \"thompson::NFA(\\n >00001: State {\\n  transitions: [],\\n}\\n00003: State {\\n  transitions: [],\\n}\\n\\nSTART(0): 00001\\n\\ntransition equivalence classes: ByteClasses([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]),"
        ],
        "code": [
          "{",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2)); // This will be the unanchored state",
          "    let state_id_3 = StateID(SmallIndex(3)); // Anchored state",
          "",
          "    let state_2 = State {",
          "        id: state_id_2,",
          "        stride2: 0,",
          "        transitions: &[state_id_1.0, state_id_3.0],",
          "    };",
          "    ",
          "    let state_3 = State {",
          "        id: state_id_3,",
          "        stride2: 1,",
          "        transitions: &[state_id_1.0],",
          "    };",
          "",
          "    let inner = Inner {",
          "        states: vec![state_2.clone(), state_3.clone()],",
          "        start_anchored: state_id_3,",
          "        start_unanchored: state_id_2,",
          "        start_pattern: vec![state_id_2],",
          "        byte_classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "",
          "    let mut output = String::new();",
          "    let _result = inner.fmt(&mut output);",
          "    assert_eq!(output, \"thompson::NFA(\\n >00001: State {\\n  transitions: [],\\n}\\n00003: State {\\n  transitions: [],\\n}\\n\\nSTART(0): 00001\\n\\ntransition equivalence classes: ByteClasses([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]),",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id_1 = StateID(SmallIndex(0)); // Start anchored",
          "    let state_id_2 = StateID(SmallIndex(1)); // Start unanchored",
          "    let state_id_3 = StateID(SmallIndex(2)); // Another state",
          "    ",
          "    let state_3 = State {",
          "        id: state_id_3,",
          "        stride2: 0,",
          "        transitions: &[state_id_1.0],",
          "    };",
          "",
          "    let inner = Inner {",
          "        states: vec![state_3.clone()],",
          "        start_anchored: state_id_1,",
          "        start_unanchored: state_id_2,",
          "        start_pattern: vec![state_id_1],",
          "        byte_classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "",
          "    let mut output = String::new();",
          "    let _result = inner.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    assert!(writeln!(output, \"thompson::NFA(\").is_ok());",
          "    assert!(inner.states.iter().count() > 0);",
          "    assert_ne!(state_id_1, inner.start_anchored);",
          "    assert_eq!(state_id_2, inner.start_unanchored);",
          "    assert!(writeln!(output, \"{}{:06?}: {:?}\", ' ', state_id_2.as_usize(), inner.states[0]).is_err());"
        ],
        "code": [
          "{",
          "    let state_id_1 = StateID(SmallIndex(0)); // Start anchored",
          "    let state_id_2 = StateID(SmallIndex(1)); // Start unanchored",
          "    let state_id_3 = StateID(SmallIndex(2)); // Another state",
          "    ",
          "    let state_3 = State {",
          "        id: state_id_3,",
          "        stride2: 0,",
          "        transitions: &[state_id_1.0],",
          "    };",
          "",
          "    let inner = Inner {",
          "        states: vec![state_3.clone()],",
          "        start_anchored: state_id_1,",
          "        start_unanchored: state_id_2,",
          "        start_pattern: vec![state_id_1],",
          "        byte_classes: ByteClasses([0; 256]),",
          "        ..Default::default()",
          "    };",
          "",
          "    let mut output = String::new();",
          "    let _result = inner.fmt(&mut output);",
          "    assert!(writeln!(output, \"thompson::NFA(\").is_ok());",
          "    assert!(inner.states.iter().count() > 0);",
          "    assert_ne!(state_id_1, inner.start_anchored);",
          "    assert_eq!(state_id_2, inner.start_unanchored);",
          "    assert!(writeln!(output, \"{}{:06?}: {:?}\", ' ', state_id_2.as_usize(), inner.states[0]).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]