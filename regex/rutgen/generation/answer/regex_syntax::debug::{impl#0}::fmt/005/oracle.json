[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = super::Byte(b' ');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    write!(formatter, \"' '\") == Ok(())",
          "    let byte = super::Byte(b'a');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\x61\");",
          "    let byte = super::Byte(b'z');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\x7a\");",
          "    let byte = super::Byte(b'\\n');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\n\");",
          "    let byte = super::Byte(b'\\r');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\r\");",
          "    let byte = super::Byte(b'\\x1F');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\x1f\");",
          "    let byte = super::Byte(b'\\x20');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"' '\");"
        ],
        "code": [
          "{",
          "    let byte = super::Byte(b' ');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    write!(formatter, \"' '\") == Ok(())",
          "    let byte = super::Byte(b'a');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\x61\");",
          "    let byte = super::Byte(b'z');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\x7a\");",
          "    let byte = super::Byte(b'\\n');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\n\");",
          "    let byte = super::Byte(b'\\r');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\r\");",
          "    let byte = super::Byte(b'\\x1F');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"\\\\x1f\");",
          "    let byte = super::Byte(b'\\x20');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.as_str(), \"' '\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = super::Byte(b'\\0');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(formatter.to_string(), \"\\x00\");",
          "    assert_eq!(byte.0, b'\\0');",
          "    assert!(formatter.buf.len() > 0);",
          "    assert!(formatter.buf.contains(\"\\x00\"));",
          "    assert_eq!(core::str::from_utf8(&formatter.buf).unwrap(), \"\\x00\");"
        ],
        "code": [
          "{",
          "    let byte = super::Byte(b'\\0');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.to_string(), \"\\x00\");",
          "    assert_eq!(byte.0, b'\\0');",
          "    assert!(formatter.buf.len() > 0);",
          "    assert!(formatter.buf.contains(\"\\x00\"));",
          "    assert_eq!(core::str::from_utf8(&formatter.buf).unwrap(), \"\\x00\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = super::Byte(b'\\x01');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"' '\");",
          "    core::str::from_utf8(&bytes[..len]).unwrap();",
          "    len += 1;",
          "    b -= 32;",
          "    core::ascii::escape_default(self.0).enumerate();",
          "    core::ascii::escape_default(self.0).count();",
          "    bytes[len] = b;",
          "    b'a' <= b && b <= b'f';",
          "    self.0 == b' ';",
          "    let byte = super::Byte(b' ');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);"
        ],
        "code": [
          "{",
          "    let byte = super::Byte(b'\\x01');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    write!(f, \"' '\");",
          "    core::str::from_utf8(&bytes[..len]).unwrap();",
          "    len += 1;",
          "    b -= 32;",
          "    core::ascii::escape_default(self.0).enumerate();",
          "    core::ascii::escape_default(self.0).count();",
          "    bytes[len] = b;",
          "    b'a' <= b && b <= b'f';",
          "    self.0 == b' ';",
          "    let byte = super::Byte(b' ');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = super::Byte(b'\\x02');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(byte.0, b'\\x02');",
          "    assert!(formatter.has_value());",
          "    assert!(formatter.output_contains(\"\\\\x02\"));",
          "    assert!(formatter.output_length() > 0);"
        ],
        "code": [
          "{",
          "    let byte = super::Byte(b'\\x02');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(byte.0, b'\\x02');",
          "    assert!(formatter.has_value());",
          "    assert!(formatter.output_contains(\"\\\\x02\"));",
          "    assert!(formatter.output_length() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = super::Byte(b'\\x0A');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(byte.0, b'\\x0A');",
          "    assert!(formatter.buf.is_empty());",
          "    assert_eq!(core::str::from_utf8(&[b'\\\\', b'n']).unwrap(), \"\\n\");"
        ],
        "code": [
          "{",
          "    let byte = super::Byte(b'\\x0A');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(byte.0, b'\\x0A');",
          "    assert!(formatter.buf.is_empty());",
          "    assert_eq!(core::str::from_utf8(&[b'\\\\', b'n']).unwrap(), \"\\n\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = super::Byte(b'\\xFF');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    write!(formatter, \"' '\").unwrap();",
          "    assert_eq!(formatter.string(), \"' '\");",
          "    assert_eq!(super::Byte(b' ').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(super::Byte(b'\\x00').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(super::Byte(b'\\x20').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(super::Byte(b'\\xFF').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(formatter.string(), \"\\\\xFF\");",
          "    assert_eq!(formatter.string(), \"\\\\x00\");",
          "    assert_eq!(formatter.string(), \"' '\");"
        ],
        "code": [
          "{",
          "    let byte = super::Byte(b'\\xFF');",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    write!(formatter, \"' '\").unwrap();",
          "    assert_eq!(formatter.string(), \"' '\");",
          "    assert_eq!(super::Byte(b' ').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(super::Byte(b'\\x00').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(super::Byte(b'\\x20').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(super::Byte(b'\\xFF').fmt(&mut formatter), Ok(()));",
          "    assert_eq!(formatter.string(), \"\\\\xFF\");",
          "    assert_eq!(formatter.string(), \"\\\\x00\");",
          "    assert_eq!(formatter.string(), \"' '\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = super::Byte(b'\\x61'); // 'a'",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(formatter.to_string(), \"a\");",
          "    ",
          "    let byte_space = super::Byte(b' '); // ASCII space",
          "    let mut formatter_space = core::fmt::Formatter::new();",
          "    let _ = byte_space.fmt(&mut formatter_space);",
          "    assert_eq!(formatter_space.to_string(), \"' '\");"
        ],
        "code": [
          "{",
          "    let byte = super::Byte(b'\\x61'); // 'a'",
          "    let mut formatter = core::fmt::Formatter::new();",
          "    let _ = byte.fmt(&mut formatter);",
          "    assert_eq!(formatter.to_string(), \"a\");",
          "    ",
          "    let byte_space = super::Byte(b' '); // ASCII space",
          "    let mut formatter_space = core::fmt::Formatter::new();",
          "    let _ = byte_space.fmt(&mut formatter_space);",
          "    assert_eq!(formatter_space.to_string(), \"' '\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]