[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_id = StateID(0);",
          "    let pid = Some(PatternID(1));",
          "    ",
          "    let config = Config::default();",
          "    let nfa = NFA(Arc::new(Inner::default()));",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            stride2: 0,",
          "            start_map: StartByteMap::default(),",
          "            classes: ByteClasses::default(),",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![StateID(0)],",
          "        nfa_to_dfa_id: vec![StateID(0)],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses::default(),",
          "    };",
          "    ",
          "    builder.dfa.starts.push(StateID(0));",
          "",
          "    // This should panic because self.dfa.starts.len() == pid.one_more() is false",
          "    let _ = builder.add_start_state(pid, nfa_id);",
          "}"
        ],
        "oracle": [
          "    assert!(builder.dfa.starts.len() == 1);",
          "    let nfa_id = StateID(0);",
          "    let pid = Some(PatternID(1));",
          "    let result = builder.add_start_state(pid, nfa_id);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::SomeExpectedError);",
          "    assert!(builder.dfa.starts.len() == 1);"
        ],
        "code": [
          "{",
          "    let nfa_id = StateID(0);",
          "    let pid = Some(PatternID(1));",
          "    ",
          "    let config = Config::default();",
          "    let nfa = NFA(Arc::new(Inner::default()));",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            stride2: 0,",
          "            start_map: StartByteMap::default(),",
          "            classes: ByteClasses::default(),",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![StateID(0)],",
          "        nfa_to_dfa_id: vec![StateID(0)],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses::default(),",
          "    };",
          "    ",
          "    builder.dfa.starts.push(StateID(0));",
          "",
          "    // This should panic because self.dfa.starts.len() == pid.one_more() is false",
          "    let _ = builder.add_start_state(pid, nfa_id);",
          "    assert!(builder.dfa.starts.len() == 1);",
          "    let nfa_id = StateID(0);",
          "    let pid = Some(PatternID(1));",
          "    let result = builder.add_start_state(pid, nfa_id);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, BuildErrorKind::SomeExpectedError);",
          "    assert!(builder.dfa.starts.len() == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_id = StateID(1);",
          "    let pid = Some(PatternID(0));",
          "    ",
          "    let config = Config::default();",
          "    let nfa = NFA(Arc::new(Inner::default()));",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            stride2: 0,",
          "            start_map: StartByteMap::default(),",
          "            classes: ByteClasses::default(),",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![StateID(1)],",
          "        nfa_to_dfa_id: vec![StateID(0)],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses::default(),",
          "    };",
          "    ",
          "    // This should panic because self.dfa.starts is not empty",
          "    let _ = builder.add_start_state(pid, nfa_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.dfa.starts.len(), 1); // expected length before adding state",
          "    assert!(builder.dfa.starts.is_empty() == false); // ensures precondition fails",
          "    assert!(std::panic::catch_unwind(|| builder.add_start_state(pid, nfa_id)).is_err()); // expects panic when precondition fails",
          "    assert!(builder.uncompiled_nfa_ids.len() == 1); // ensures NFA state is tracked",
          "    assert!(builder.nfa_to_dfa_id[nfa_id.0] == DEAD); // verifies that the mapping is set to DEAD before being added",
          "    assert!(builder.stack.is_empty()); // verifies that stack remains unchanged",
          "    assert!(builder.seen.len() == 0); // verifies that no states have been seen yet"
        ],
        "code": [
          "{",
          "    let nfa_id = StateID(1);",
          "    let pid = Some(PatternID(0));",
          "    ",
          "    let config = Config::default();",
          "    let nfa = NFA(Arc::new(Inner::default()));",
          "    let mut builder = InternalBuilder {",
          "        dfa: DFA {",
          "            config: config.clone(),",
          "            nfa,",
          "            stride2: 0,",
          "            start_map: StartByteMap::default(),",
          "            classes: ByteClasses::default(),",
          "            quitset: ByteSet::default(),",
          "            cache_capacity: 0,",
          "        },",
          "        uncompiled_nfa_ids: vec![StateID(1)],",
          "        nfa_to_dfa_id: vec![StateID(0)],",
          "        stack: vec![],",
          "        seen: SparseSet::default(),",
          "        matched: false,",
          "        config,",
          "        nfa: &nfa,",
          "        classes: ByteClasses::default(),",
          "    };",
          "    ",
          "    // This should panic because self.dfa.starts is not empty",
          "    let _ = builder.add_start_state(pid, nfa_id);",
          "    assert_eq!(builder.dfa.starts.len(), 1); // expected length before adding state",
          "    assert!(builder.dfa.starts.is_empty() == false); // ensures precondition fails",
          "    assert!(std::panic::catch_unwind(|| builder.add_start_state(pid, nfa_id)).is_err()); // expects panic when precondition fails",
          "    assert!(builder.uncompiled_nfa_ids.len() == 1); // ensures NFA state is tracked",
          "    assert!(builder.nfa_to_dfa_id[nfa_id.0] == DEAD); // verifies that the mapping is set to DEAD before being added",
          "    assert!(builder.stack.is_empty()); // verifies that stack remains unchanged",
          "    assert!(builder.seen.len() == 0); // verifies that no states have been seen yet",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]