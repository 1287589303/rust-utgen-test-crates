[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = b\"I categorically deny having triskaidekaphobia.\";",
          "    re.find(hay).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(hay).is_some(), true);",
          "    let result = re.find(hay).unwrap();",
          "    assert_eq!(result.start, 2);",
          "    assert_eq!(result.end, 15);",
          "    assert_eq!(result.haystack[result.start..result.end], b\"categorically\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = b\"I categorically deny having triskaidekaphobia.\";",
          "    re.find(hay).unwrap();",
          "    assert_eq!(re.find(hay).is_some(), true);",
          "    let result = re.find(hay).unwrap();",
          "    assert_eq!(result.start, 2);",
          "    assert_eq!(result.end, 15);",
          "    assert_eq!(result.haystack[result.start..result.end], b\"categorically\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay: &[u8] = b\"\";",
          "    let result = re.find(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    ",
          "    let hay: &[u8] = b\"I categorically deny having triskaidekaphobia.\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 2);",
          "    assert_eq!(result.unwrap().end, 15);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"categorically\");",
          "    ",
          "    let hay: &[u8] = b\"A short text.\";",
          "    let result = re.find(hay);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hay: &[u8] = b\"Crystallographically\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 0);",
          "    assert_eq!(result.unwrap().end, 20);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"Crystallographically\");",
          "    ",
          "    let hay: &[u8] = b\"Some other random text with Shibboleth.\";",
          "    let result = re.find(hay);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay: &[u8] = b\"\";",
          "    let result = re.find(hay);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hay: &[u8] = b\"I categorically deny having triskaidekaphobia.\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 2);",
          "    assert_eq!(result.unwrap().end, 15);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"categorically\");",
          "    ",
          "    let hay: &[u8] = b\"A short text.\";",
          "    let result = re.find(hay);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hay: &[u8] = b\"Crystallographically\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 0);",
          "    assert_eq!(result.unwrap().end, 20);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"Crystallographically\");",
          "    ",
          "    let hay: &[u8] = b\"Some other random text with Shibboleth.\";",
          "    let result = re.find(hay);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{10}\\b\").unwrap();",
          "    let hay = b\"I categorically deny having triskaidekaphobia.\";",
          "    let result = re.find(hay);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_none());",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = b\"I categorically deny having triskaidekaphobia.\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 2);",
          "    assert_eq!(result.unwrap().end, 15);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"categorically\");",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
          "    let hay = b\"I am here.\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 5);",
          "    assert_eq!(result.unwrap().end, 9);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"here\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{10}\\b\").unwrap();",
          "    let hay = b\"I categorically deny having triskaidekaphobia.\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_none());",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{13}\\b\").unwrap();",
          "    let hay = b\"I categorically deny having triskaidekaphobia.\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 2);",
          "    assert_eq!(result.unwrap().end, 15);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"categorically\");",
          "    ",
          "    let re = Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
          "    let hay = b\"I am here.\";",
          "    let result = re.find(hay);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().start, 5);",
          "    assert_eq!(result.unwrap().end, 9);",
          "    assert_eq!(result.unwrap().as_bytes(), b\"here\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
          "    let hay = b\"The quick brown fox jumps over the lazy dogs.\";",
          "    re.find(hay).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(hay).unwrap().start, 0);",
          "    assert_eq!(re.find(hay).unwrap().end, 3);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"The\");",
          "    assert_eq!(re.find(hay).unwrap().start, hay.iter().position(|&x| x == b' ').unwrap() + 1);",
          "    assert_eq!(re.find(hay).unwrap().end, hay.iter().position(|&x| x == b' ', re.find(hay).unwrap().start).unwrap());",
          "    assert!(re.find(hay).is_some());",
          "    assert!(re.find(hay).unwrap().end <= hay.len());",
          "    assert!(re.find(hay).unwrap().start < re.find(hay).unwrap().end);",
          "    assert!(re.find(hay).unwrap() == re.find(hay));",
          "    assert!(re.find(hay).unwrap().start < hay.len());",
          "    assert!(re.find(hay).unwrap().as_bytes().len() == 3);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{5}\\b\").unwrap();",
          "    let hay = b\"The quick brown fox jumps over the lazy dogs.\";",
          "    re.find(hay).unwrap();",
          "    assert_eq!(re.find(hay).unwrap().start, 0);",
          "    assert_eq!(re.find(hay).unwrap().end, 3);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"The\");",
          "    assert_eq!(re.find(hay).unwrap().start, hay.iter().position(|&x| x == b' ').unwrap() + 1);",
          "    assert_eq!(re.find(hay).unwrap().end, hay.iter().position(|&x| x == b' ', re.find(hay).unwrap().start).unwrap());",
          "    assert!(re.find(hay).is_some());",
          "    assert!(re.find(hay).unwrap().end <= hay.len());",
          "    assert!(re.find(hay).unwrap().start < re.find(hay).unwrap().end);",
          "    assert!(re.find(hay).unwrap() == re.find(hay));",
          "    assert!(re.find(hay).unwrap().start < hay.len());",
          "    assert!(re.find(hay).unwrap().as_bytes().len() == 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\bfox\\b\").unwrap();",
          "    let hay = b\"The quick brown fox.\";",
          "    re.find(hay).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(hay), Some(Match { haystack: hay, start: 16, end: 19 }));",
          "    assert_eq!(re.find(hay).map(|m| m.start), Some(16));",
          "    assert_eq!(re.find(hay).map(|m| m.end), Some(19));",
          "    assert_eq!(re.find(b\"The quick brown dog.\"), None);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\bfox\\b\").unwrap();",
          "    let hay = b\"The quick brown fox.\";",
          "    re.find(hay).unwrap();",
          "    assert_eq!(re.find(hay), Some(Match { haystack: hay, start: 16, end: 19 }));",
          "    assert_eq!(re.find(hay).map(|m| m.start), Some(16));",
          "    assert_eq!(re.find(hay).map(|m| m.end), Some(19));",
          "    assert_eq!(re.find(b\"The quick brown dog.\"), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\blazy\\b\").unwrap();",
          "    let hay = b\"Lazily does the dog doze.\";",
          "    re.find(hay).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).unwrap().start, 0);",
          "    assert_eq!(re.find(hay).unwrap().end, 4);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"Lazy\");",
          "    assert!(re.find(b\"\").is_none());",
          "    assert!(re.find(b\"Lazydog\").is_none());",
          "    assert!(re.find(b\"Lazily\").is_some());",
          "    assert_eq!(re.find(b\"Lazily does the dog doze.\")?.as_bytes(), b\"Lazy\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\blazy\\b\").unwrap();",
          "    let hay = b\"Lazily does the dog doze.\";",
          "    re.find(hay).unwrap();",
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).unwrap().start, 0);",
          "    assert_eq!(re.find(hay).unwrap().end, 4);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"Lazy\");",
          "    assert!(re.find(b\"\").is_none());",
          "    assert!(re.find(b\"Lazydog\").is_none());",
          "    assert!(re.find(b\"Lazily\").is_some());",
          "    assert_eq!(re.find(b\"Lazily does the dog doze.\")?.as_bytes(), b\"Lazy\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\bthe\\b\").unwrap();",
          "    let hay = b\"The cat sat on the mat.\";",
          "    re.find(hay).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(hay).unwrap().start, 0);",
          "    assert_eq!(re.find(hay).unwrap().end, 3);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"the\");",
          "    assert!(re.find(b\"no matches here\").is_none());",
          "    assert!(re.find(b\"theotherword\").is_none());",
          "    assert_eq!(re.find(b\"the mat\").unwrap().start, 0);",
          "    assert_eq!(re.find(b\"the mat\").unwrap().end, 3);",
          "    assert_eq!(re.find(b\"mat the\").unwrap().start, 4);",
          "    assert_eq!(re.find(b\"mat the\").unwrap().end, 7);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\bthe\\b\").unwrap();",
          "    let hay = b\"The cat sat on the mat.\";",
          "    re.find(hay).unwrap();",
          "    assert_eq!(re.find(hay).unwrap().start, 0);",
          "    assert_eq!(re.find(hay).unwrap().end, 3);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"the\");",
          "    assert!(re.find(b\"no matches here\").is_none());",
          "    assert!(re.find(b\"theotherword\").is_none());",
          "    assert_eq!(re.find(b\"the mat\").unwrap().start, 0);",
          "    assert_eq!(re.find(b\"the mat\").unwrap().end, 3);",
          "    assert_eq!(re.find(b\"mat the\").unwrap().start, 4);",
          "    assert_eq!(re.find(b\"mat the\").unwrap().end, 7);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{6,}\\b\").unwrap();",
          "    let hay = b\"This is a long string with several longer words.\";",
          "    re.find(hay).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(hay).unwrap().start, 10);",
          "    assert_eq!(re.find(hay).unwrap().end, 13);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"long\");",
          "    assert_eq!(re.find(hay).unwrap().haystack, hay);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\b\\w{6,}\\b\").unwrap();",
          "    let hay = b\"This is a long string with several longer words.\";",
          "    re.find(hay).unwrap();",
          "    assert_eq!(re.find(hay).unwrap().start, 10);",
          "    assert_eq!(re.find(hay).unwrap().end, 13);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"long\");",
          "    assert_eq!(re.find(hay).unwrap().haystack, hay);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"\\d{3}\").unwrap();",
          "    let hay = b\"Num: 123, Num: 456, Num: 789\";",
          "    re.find(hay).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(hay).unwrap().start, 5);",
          "    assert_eq!(re.find(hay).unwrap().end, 8);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"123\");",
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).unwrap().haystack, hay);",
          "    assert_eq!(re.find(hay).unwrap().end - re.find(hay).unwrap().start, 3);",
          "    assert_eq!(re.find(b\"no digits here\"), None);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"\\d{3}\").unwrap();",
          "    let hay = b\"Num: 123, Num: 456, Num: 789\";",
          "    re.find(hay).unwrap();",
          "    assert_eq!(re.find(hay).unwrap().start, 5);",
          "    assert_eq!(re.find(hay).unwrap().end, 8);",
          "    assert_eq!(re.find(hay).unwrap().as_bytes(), b\"123\");",
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).unwrap().haystack, hay);",
          "    assert_eq!(re.find(hay).unwrap().end - re.find(hay).unwrap().start, 3);",
          "    assert_eq!(re.find(b\"no digits here\"), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]