[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'a', end: 'b' },",
          "        ClassUnicodeRange { start: 'd', end: 'e' },",
          "        ClassUnicodeRange { start: 'g', end: 'h' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges().len(), 3);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'a', end: 'b' });",
          "    assert_eq!(class_unicode.ranges()[1], ClassUnicodeRange { start: 'd', end: 'e' });",
          "    assert_eq!(class_unicode.ranges()[2], ClassUnicodeRange { start: 'g', end: 'h' });",
          "    assert!(class_unicode.ranges().is_sorted());",
          "    assert!(class_unicode.ranges().is_unique());"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'a', end: 'b' },",
          "        ClassUnicodeRange { start: 'd', end: 'e' },",
          "        ClassUnicodeRange { start: 'g', end: 'h' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "    assert_eq!(class_unicode.ranges().len(), 3);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'a', end: 'b' });",
          "    assert_eq!(class_unicode.ranges()[1], ClassUnicodeRange { start: 'd', end: 'e' });",
          "    assert_eq!(class_unicode.ranges()[2], ClassUnicodeRange { start: 'g', end: 'h' });",
          "    assert!(class_unicode.ranges().is_sorted());",
          "    assert!(class_unicode.ranges().is_unique());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'x', end: 'x' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges(), class_unicode.set.intervals());",
          "    assert!(class_unicode.ranges().len() > 0);",
          "    assert_eq!(class_unicode.ranges()[0].start, 'x');",
          "    assert_eq!(class_unicode.ranges()[0].end, 'x');",
          "    assert!(class_unicode.ranges().is_slice());",
          "    assert!(!class_unicode.ranges().is_empty());"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'x', end: 'x' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "    assert_eq!(class_unicode.ranges(), class_unicode.set.intervals());",
          "    assert!(class_unicode.ranges().len() > 0);",
          "    assert_eq!(class_unicode.ranges()[0].start, 'x');",
          "    assert_eq!(class_unicode.ranges()[0].end, 'x');",
          "    assert!(class_unicode.ranges().is_slice());",
          "    assert!(!class_unicode.ranges().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "    let _ = class_unicode.ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges(), &[]);",
          "    let class_unicode_with_ranges = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    assert_eq!(class_unicode_with_ranges.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let class_unicode_with_multiple_ranges = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'f' }]);",
          "    assert_eq!(class_unicode_with_multiple_ranges.ranges(), &[ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'f' }]);",
          "    let class_unicode_case_folded = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    class_unicode_case_folded.case_fold_simple();",
          "    assert_eq!(class_unicode_case_folded.ranges(), &[ClassUnicodeRange { start: 'A', end: 'Z' }]);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "    let _ = class_unicode.ranges();",
          "    assert_eq!(class_unicode.ranges(), &[]);",
          "    let class_unicode_with_ranges = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    assert_eq!(class_unicode_with_ranges.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let class_unicode_with_multiple_ranges = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'f' }]);",
          "    assert_eq!(class_unicode_with_multiple_ranges.ranges(), &[ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'f' }]);",
          "    let class_unicode_case_folded = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    class_unicode_case_folded.case_fold_simple();",
          "    assert_eq!(class_unicode_case_folded.ranges(), &[ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'm', end: 'n' },",
          "        ClassUnicodeRange { start: 'n', end: 'o' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges().len(), 2);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'm', end: 'n' });",
          "    assert_eq!(class_unicode.ranges()[1], ClassUnicodeRange { start: 'n', end: 'o' });",
          "    assert!(class_unicode.ranges().is_sorted());",
          "    assert!(class_unicode.ranges().iter().all(|range| range.start <= range.end));",
          "    assert!(class_unicode.ranges().iter().count() == class_unicode.set.intervals().len());"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'm', end: 'n' },",
          "        ClassUnicodeRange { start: 'n', end: 'o' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "    assert_eq!(class_unicode.ranges().len(), 2);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'm', end: 'n' });",
          "    assert_eq!(class_unicode.ranges()[1], ClassUnicodeRange { start: 'n', end: 'o' });",
          "    assert!(class_unicode.ranges().is_sorted());",
          "    assert!(class_unicode.ranges().iter().all(|range| range.start <= range.end));",
          "    assert!(class_unicode.ranges().iter().count() == class_unicode.set.intervals().len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'p', end: 'r' },",
          "        ClassUnicodeRange { start: 'q', end: 's' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges().len(), 2);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'p', end: 'r' });",
          "    assert_eq!(class_unicode.ranges()[1], ClassUnicodeRange { start: 'q', end: 's' });"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'p', end: 'r' },",
          "        ClassUnicodeRange { start: 'q', end: 's' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let _ = class_unicode.ranges();",
          "    assert_eq!(class_unicode.ranges().len(), 2);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'p', end: 'r' });",
          "    assert_eq!(class_unicode.ranges()[1], ClassUnicodeRange { start: 'q', end: 's' });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]