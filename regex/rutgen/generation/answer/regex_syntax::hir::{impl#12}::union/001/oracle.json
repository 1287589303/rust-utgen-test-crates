[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'b' },",
          "        ClassUnicodeRange { start: 'd', end: 'e' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'f', end: 'g' },",
          "        ClassUnicodeRange { start: 'i', end: 'j' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'e' }, ClassUnicodeRange { start: 'f', end: 'g' }, ClassUnicodeRange { start: 'i', end: 'j' }]);"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'b' },",
          "        ClassUnicodeRange { start: 'd', end: 'e' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'f', end: 'g' },",
          "        ClassUnicodeRange { start: 'i', end: 'j' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'e' }, ClassUnicodeRange { start: 'f', end: 'g' }, ClassUnicodeRange { start: 'i', end: 'j' }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "        ClassUnicodeRange { start: 'e', end: 'h' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'b', end: 'd' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    let class_a = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'c' }, ClassUnicodeRange { start: 'e', end: 'h' }]);",
          "    let class_b = ClassUnicode::new(vec![ClassUnicodeRange { start: 'b', end: 'd' }]);",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'c' }, ClassUnicodeRange { start: 'b', end: 'd' }, ClassUnicodeRange { start: 'e', end: 'h' }]);",
          "    ",
          "    let mut class_c = ClassUnicode::new(vec![ClassUnicodeRange { start: 'x', end: 'y' }]);",
          "    let class_d = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'b' }]);",
          "    class_c.union(&class_d);",
          "    assert_eq!(class_c.ranges(), &[ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'x', end: 'y' }]);",
          "    ",
          "    let mut class_e = ClassUnicode::new(vec![]);",
          "    let class_f = ClassUnicode::new(vec![ClassUnicodeRange { start: '1', end: '3' }]);",
          "    class_e.union(&class_f);",
          "    assert_eq!(class_e.ranges(), &[ClassUnicodeRange { start: '1', end: '3' }]);",
          "    ",
          "    let mut class_g = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let class_h = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    class_g.union(&class_h);",
          "    assert_eq!(class_g.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    ",
          "    let mut class_i = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let class_j = ClassUnicode::new(vec![]);",
          "    class_i.union(&class_j);",
          "    assert_eq!(class_i.ranges(), &[ClassUnicodeRange { start: '0', end: '9' }]);"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "        ClassUnicodeRange { start: 'e', end: 'h' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'b', end: 'd' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "    let class_a = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'c' }, ClassUnicodeRange { start: 'e', end: 'h' }]);",
          "    let class_b = ClassUnicode::new(vec![ClassUnicodeRange { start: 'b', end: 'd' }]);",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'c' }, ClassUnicodeRange { start: 'b', end: 'd' }, ClassUnicodeRange { start: 'e', end: 'h' }]);",
          "    ",
          "    let mut class_c = ClassUnicode::new(vec![ClassUnicodeRange { start: 'x', end: 'y' }]);",
          "    let class_d = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'b' }]);",
          "    class_c.union(&class_d);",
          "    assert_eq!(class_c.ranges(), &[ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'x', end: 'y' }]);",
          "    ",
          "    let mut class_e = ClassUnicode::new(vec![]);",
          "    let class_f = ClassUnicode::new(vec![ClassUnicodeRange { start: '1', end: '3' }]);",
          "    class_e.union(&class_f);",
          "    assert_eq!(class_e.ranges(), &[ClassUnicodeRange { start: '1', end: '3' }]);",
          "    ",
          "    let mut class_g = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let class_h = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    class_g.union(&class_h);",
          "    assert_eq!(class_g.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    ",
          "    let mut class_i = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let class_j = ClassUnicode::new(vec![]);",
          "    class_i.union(&class_j);",
          "    assert_eq!(class_i.ranges(), &[ClassUnicodeRange { start: '0', end: '9' }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ]);",
          "    let class_b = ClassUnicode::empty();",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'c' }]);"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ]);",
          "    let class_b = ClassUnicode::empty();",
          "    class_a.union(&class_b);",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'c' }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::empty();",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'x', end: 'z' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_a.ranges(), &[]);",
          "    class_a.push(ClassUnicodeRange { start: 'x', end: 'z' });",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'x', end: 'z' }]);",
          "    assert!(class_a.is_ascii());",
          "    assert_eq!(class_a.minimum_len(), Some(1));",
          "    assert_eq!(class_a.maximum_len(), Some(3));"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::empty();",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'x', end: 'z' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "    assert_eq!(class_a.ranges(), &[]);",
          "    class_a.push(ClassUnicodeRange { start: 'x', end: 'z' });",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'x', end: 'z' }]);",
          "    assert!(class_a.is_ascii());",
          "    assert_eq!(class_a.minimum_len(), Some(1));",
          "    assert_eq!(class_a.maximum_len(), Some(3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    class_a.ranges() == class_b.ranges()",
          "    class_a.ranges() == vec![ClassUnicodeRange { start: 'a', end: 'c' }]",
          "    class_b.ranges() == vec![ClassUnicodeRange { start: 'a', end: 'c' }]",
          "    class_a.set.folded == class_b.set.folded"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "    class_a.ranges() == class_b.ranges()",
          "    class_a.ranges() == vec![ClassUnicodeRange { start: 'a', end: 'c' }]",
          "    class_b.ranges() == vec![ClassUnicodeRange { start: 'a', end: 'c' }]",
          "    class_a.set.folded == class_b.set.folded",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'a' },",
          "        ClassUnicodeRange { start: 'b', end: 'b' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'c', end: 'c' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    class_a.ranges().len() == 3",
          "    class_a.ranges()[0] == ClassUnicodeRange { start: 'a', end: 'a' }",
          "    class_a.ranges()[1] == ClassUnicodeRange { start: 'b', end: 'b' }",
          "    class_a.ranges()[2] == ClassUnicodeRange { start: 'c', end: 'c' }",
          "    class_a.set.folded == false"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'a' },",
          "        ClassUnicodeRange { start: 'b', end: 'b' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'c', end: 'c' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "    class_a.ranges().len() == 3",
          "    class_a.ranges()[0] == ClassUnicodeRange { start: 'a', end: 'a' }",
          "    class_a.ranges()[1] == ClassUnicodeRange { start: 'b', end: 'b' }",
          "    class_a.ranges()[2] == ClassUnicodeRange { start: 'c', end: 'c' }",
          "    class_a.set.folded == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'z' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'z', end: 'a' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    assert!(class_a.set.ranges.len() > 0);",
          "    assert!(class_a.set.folded == false);",
          "    assert!(class_a.ranges().contains(&ClassUnicodeRange { start: 'a', end: 'z' }));",
          "    assert!(class_a.ranges().contains(&ClassUnicodeRange { start: 'z', end: 'a' }) == false);",
          "    class_a.union(&class_b);",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }, ClassUnicodeRange { start: 'z', end: 'a' }]);",
          "    assert!(class_a.set.folded == false);",
          "    assert_eq!(class_a.set.ranges.len(), 2);"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'z' },",
          "    ]);",
          "    let class_b = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'z', end: 'a' },",
          "    ]);",
          "    class_a.union(&class_b);",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    assert!(class_a.set.ranges.len() > 0);",
          "    assert!(class_a.set.folded == false);",
          "    assert!(class_a.ranges().contains(&ClassUnicodeRange { start: 'a', end: 'z' }));",
          "    assert!(class_a.ranges().contains(&ClassUnicodeRange { start: 'z', end: 'a' }) == false);",
          "    class_a.union(&class_b);",
          "    assert_eq!(class_a.ranges(), &[ClassUnicodeRange { start: 'a', end: 'z' }, ClassUnicodeRange { start: 'z', end: 'a' }]);",
          "    assert!(class_a.set.folded == false);",
          "    assert_eq!(class_a.set.ranges.len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_a = ClassUnicode::new((1..=50).map(|i| ClassUnicodeRange { start: char::from('a' as u8 + i - 1), end: char::from('a' as u8 + i - 1) }));",
          "    let class_b = ClassUnicode::new((51..=100).map(|i| ClassUnicodeRange { start: char::from('a' as u8 + i - 1), end: char::from('a' as u8 + i - 1) }));",
          "    class_a.union(&class_b);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_a.ranges().len(), 100);",
          "    assert_eq!(class_a.ranges()[0], ClassUnicodeRange { start: 'a', end: 'a' });",
          "    assert_eq!(class_a.ranges()[49], ClassUnicodeRange { start: 'z', end: 'z' });",
          "    assert_eq!(class_a.ranges()[50], ClassUnicodeRange { start: 'A', end: 'A' });",
          "    assert_eq!(class_a.ranges()[99], ClassUnicodeRange { start: 'd', end: 'd' });",
          "    assert!(class_a.is_ascii());"
        ],
        "code": [
          "{",
          "    let mut class_a = ClassUnicode::new((1..=50).map(|i| ClassUnicodeRange { start: char::from('a' as u8 + i - 1), end: char::from('a' as u8 + i - 1) }));",
          "    let class_b = ClassUnicode::new((51..=100).map(|i| ClassUnicodeRange { start: char::from('a' as u8 + i - 1), end: char::from('a' as u8 + i - 1) }));",
          "    class_a.union(&class_b);",
          "    assert_eq!(class_a.ranges().len(), 100);",
          "    assert_eq!(class_a.ranges()[0], ClassUnicodeRange { start: 'a', end: 'a' });",
          "    assert_eq!(class_a.ranges()[49], ClassUnicodeRange { start: 'z', end: 'z' });",
          "    assert_eq!(class_a.ranges()[50], ClassUnicodeRange { start: 'A', end: 'A' });",
          "    assert_eq!(class_a.ranges()[99], ClassUnicodeRange { start: 'd', end: 'd' });",
          "    assert!(class_a.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]