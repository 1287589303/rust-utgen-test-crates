[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_set = LookSet::empty();",
          "    let other_set = LookSet::singleton(Look::SomeVariant);",
          "    self_set.set_intersect(other_set);",
          "}"
        ],
        "oracle": [
          "    let mut self_set = LookSet::empty();",
          "    let other_set = LookSet::singleton(Look::SomeVariant);",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    assert!(self_set.is_empty());"
        ],
        "code": [
          "{",
          "    let mut self_set = LookSet::empty();",
          "    let other_set = LookSet::singleton(Look::SomeVariant);",
          "    self_set.set_intersect(other_set);",
          "    let mut self_set = LookSet::empty();",
          "    let other_set = LookSet::singleton(Look::SomeVariant);",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    assert!(self_set.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_set = LookSet::singleton(Look::SomeVariant);",
          "    let other_set = LookSet::empty();",
          "    self_set.set_intersect(other_set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(self_set.is_empty());",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    assert!(self_set.contains_anchor());",
          "    assert!(self_set.contains_anchor_haystack());",
          "    assert!(self_set.contains_anchor_line());",
          "    assert!(self_set.contains_anchor_lf());",
          "    assert!(self_set.contains_anchor_crlf());",
          "    assert!(!self_set.contains_word());",
          "    assert!(!self_set.contains_word_unicode());",
          "    assert!(!self_set.contains_word_ascii());"
        ],
        "code": [
          "{",
          "    let mut self_set = LookSet::singleton(Look::SomeVariant);",
          "    let other_set = LookSet::empty();",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(self_set.is_empty());",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    assert!(self_set.contains_anchor());",
          "    assert!(self_set.contains_anchor_haystack());",
          "    assert!(self_set.contains_anchor_line());",
          "    assert!(self_set.contains_anchor_lf());",
          "    assert!(self_set.contains_anchor_crlf());",
          "    assert!(!self_set.contains_word());",
          "    assert!(!self_set.contains_word_unicode());",
          "    assert!(!self_set.contains_word_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_set = LookSet::full();",
          "    let other_set = LookSet::full();",
          "    self_set.set_intersect(other_set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_set.bits, other_set.bits);",
          "    assert!(!self_set.is_empty());",
          "    assert!(self_set.contains_anchor());",
          "    assert!(self_set.contains_word());",
          "    assert_eq!(self_set.len(), 10);",
          "    self_set.set_intersect(LookSet::empty());",
          "    assert!(self_set.is_empty());",
          "    assert_eq!(self_set.len(), 0);",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.bits, other_set.bits);",
          "    assert!(!self_set.is_empty());"
        ],
        "code": [
          "{",
          "    let mut self_set = LookSet::full();",
          "    let other_set = LookSet::full();",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.bits, other_set.bits);",
          "    assert!(!self_set.is_empty());",
          "    assert!(self_set.contains_anchor());",
          "    assert!(self_set.contains_word());",
          "    assert_eq!(self_set.len(), 10);",
          "    self_set.set_intersect(LookSet::empty());",
          "    assert!(self_set.is_empty());",
          "    assert_eq!(self_set.len(), 0);",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.bits, other_set.bits);",
          "    assert!(!self_set.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_set = LookSet::singleton(Look::SomeVariant);",
          "    let other_set = LookSet::singleton(Look::AnotherVariant);",
          "    self_set.set_intersect(other_set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(self_set.is_empty());",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    assert!(!self_set.contains(Look::AnotherVariant));",
          "    assert!(!self_set.contains_anchor());",
          "    assert!(!self_set.contains_word());",
          "    assert!(!self_set.contains_word_unicode());",
          "    assert!(!self_set.contains_word_ascii());",
          "    assert_eq!(self_set.bits, 0);"
        ],
        "code": [
          "{",
          "    let mut self_set = LookSet::singleton(Look::SomeVariant);",
          "    let other_set = LookSet::singleton(Look::AnotherVariant);",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(self_set.is_empty());",
          "    assert!(!self_set.contains(Look::SomeVariant));",
          "    assert!(!self_set.contains(Look::AnotherVariant));",
          "    assert!(!self_set.contains_anchor());",
          "    assert!(!self_set.contains_word());",
          "    assert!(!self_set.contains_word_unicode());",
          "    assert!(!self_set.contains_word_ascii());",
          "    assert_eq!(self_set.bits, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_set = LookSet::singleton(Look::SomeVariant);",
          "    let other_set = LookSet::singleton(Look::SomeVariant);",
          "    self_set.set_intersect(other_set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_set.len(), 1);",
          "    assert!(self_set.contains(Look::SomeVariant));",
          "    assert!(!self_set.contains(Look::AnotherVariant));",
          "    assert!(!self_set.is_empty());",
          "    ",
          "    let mut empty_set = LookSet::empty();",
          "    let non_empty_set = LookSet::singleton(Look::SomeVariant);",
          "    empty_set.set_intersect(non_empty_set);",
          "    assert!(empty_set.is_empty());",
          "    ",
          "    let mut full_set = LookSet::full();",
          "    let another_set = LookSet::singleton(Look::AnotherVariant);",
          "    full_set.set_intersect(another_set);",
          "    assert!(!full_set.is_empty());",
          "    assert!(full_set.contains(Look::AnotherVariant));",
          "    assert!(full_set.contains(Look::SomeVariant));",
          "    ",
          "    let mut set_a = LookSet::singleton(Look::SomeVariant);",
          "    let set_b = LookSet::singleton(Look::AnotherVariant);",
          "    set_a.set_intersect(set_b);",
          "    assert!(set_a.is_empty());",
          "    ",
          "    let mut intersect_set = LookSet::union(",
          "    LookSet::singleton(Look::SomeVariant),",
          "    LookSet::singleton(Look::AnotherVariant)",
          "    );",
          "    intersect_set.set_intersect(LookSet::singleton(Look::SomeVariant));",
          "    assert_eq!(intersect_set.len(), 1);",
          "    assert!(intersect_set.contains(Look::SomeVariant));",
          "    assert!(!intersect_set.contains(Look::AnotherVariant));",
          "    ",
          "    let mut first_set = LookSet::singleton(Look::SomeVariant);",
          "    let second_set = LookSet::singleton(Look::SomeVariant);",
          "    first_set.set_intersect(second_set);",
          "    assert_eq!(first_set.bits, second_set.bits);"
        ],
        "code": [
          "{",
          "    let mut self_set = LookSet::singleton(Look::SomeVariant);",
          "    let other_set = LookSet::singleton(Look::SomeVariant);",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.len(), 1);",
          "    assert!(self_set.contains(Look::SomeVariant));",
          "    assert!(!self_set.contains(Look::AnotherVariant));",
          "    assert!(!self_set.is_empty());",
          "    ",
          "    let mut empty_set = LookSet::empty();",
          "    let non_empty_set = LookSet::singleton(Look::SomeVariant);",
          "    empty_set.set_intersect(non_empty_set);",
          "    assert!(empty_set.is_empty());",
          "    ",
          "    let mut full_set = LookSet::full();",
          "    let another_set = LookSet::singleton(Look::AnotherVariant);",
          "    full_set.set_intersect(another_set);",
          "    assert!(!full_set.is_empty());",
          "    assert!(full_set.contains(Look::AnotherVariant));",
          "    assert!(full_set.contains(Look::SomeVariant));",
          "    ",
          "    let mut set_a = LookSet::singleton(Look::SomeVariant);",
          "    let set_b = LookSet::singleton(Look::AnotherVariant);",
          "    set_a.set_intersect(set_b);",
          "    assert!(set_a.is_empty());",
          "    ",
          "    let mut intersect_set = LookSet::union(",
          "    LookSet::singleton(Look::SomeVariant),",
          "    LookSet::singleton(Look::AnotherVariant)",
          "    );",
          "    intersect_set.set_intersect(LookSet::singleton(Look::SomeVariant));",
          "    assert_eq!(intersect_set.len(), 1);",
          "    assert!(intersect_set.contains(Look::SomeVariant));",
          "    assert!(!intersect_set.contains(Look::AnotherVariant));",
          "    ",
          "    let mut first_set = LookSet::singleton(Look::SomeVariant);",
          "    let second_set = LookSet::singleton(Look::SomeVariant);",
          "    first_set.set_intersect(second_set);",
          "    assert_eq!(first_set.bits, second_set.bits);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_set = LookSet { bits: 0b1100 };",
          "    let other_set = LookSet { bits: 0b1010 };",
          "    self_set.set_intersect(other_set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_set.bits, 0b1000);"
        ],
        "code": [
          "{",
          "    let mut self_set = LookSet { bits: 0b1100 };",
          "    let other_set = LookSet { bits: 0b1010 };",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.bits, 0b1000);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_set = LookSet { bits: 0b0011 };",
          "    let other_set = LookSet { bits: 0b1100 };",
          "    self_set.set_intersect(other_set);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self_set.bits, 0b0000);",
          "    assert!(self_set.is_empty());",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(!self_set.contains(Look::SomeValue));",
          "    assert!(!self_set.contains_anchor());",
          "    assert!(!self_set.contains_word());",
          "    assert!(!self_set.contains_word_unicode());",
          "    assert!(!self_set.contains_word_ascii());"
        ],
        "code": [
          "{",
          "    let mut self_set = LookSet { bits: 0b0011 };",
          "    let other_set = LookSet { bits: 0b1100 };",
          "    self_set.set_intersect(other_set);",
          "    assert_eq!(self_set.bits, 0b0000);",
          "    assert!(self_set.is_empty());",
          "    assert_eq!(self_set.len(), 0);",
          "    assert!(!self_set.contains(Look::SomeValue));",
          "    assert!(!self_set.contains_anchor());",
          "    assert!(!self_set.contains_word());",
          "    assert!(!self_set.contains_word_unicode());",
          "    assert!(!self_set.contains_word_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]