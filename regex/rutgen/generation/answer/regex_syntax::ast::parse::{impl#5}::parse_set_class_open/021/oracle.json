[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[^a-z]\"; // valid character class with negation",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '[');",
          "    assert_eq!(parser.pos(), start_pos);",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() == '^');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() == '-');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() == ']');",
          "    assert!(parser.error(Span::new(start_pos, parser.pos()), ast::ErrorKind::ClassUnclosed).is_err());",
          "    assert_eq!(union.items.len(), 1);",
          "    assert_eq!(union.items[0], ClassSetItem::Literal(Literal { span: parser.span_char(), kind: LiteralKind::Verbatim, c: '-' }));",
          "    assert_eq!(set.span.start, start_pos);",
          "    assert_eq!(set.negated, true);",
          "    assert!(set.kind.is_empty());",
          "    assert!(parser.span().is_empty());"
        ],
        "code": [
          "{",
          "    let pattern = \"[^a-z]\"; // valid character class with negation",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "    assert_eq!(parser.char(), '[');",
          "    assert_eq!(parser.pos(), start_pos);",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() == '^');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() == '-');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() == ']');",
          "    assert!(parser.error(Span::new(start_pos, parser.pos()), ast::ErrorKind::ClassUnclosed).is_err());",
          "    assert_eq!(union.items.len(), 1);",
          "    assert_eq!(union.items[0], ClassSetItem::Literal(Literal { span: parser.span_char(), kind: LiteralKind::Verbatim, c: '-' }));",
          "    assert_eq!(set.span.start, start_pos);",
          "    assert_eq!(set.negated, true);",
          "    assert!(set.kind.is_empty());",
          "    assert!(parser.span().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[a-zA-Z0-9]\"; // valid character class with literals",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '[');",
          "    assert_eq!(parser.pos(), start_pos);",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(!parser.bump_and_bump_space());",
          "    assert!(parser.char() != '^');",
          "    assert_eq!(union.items.len(), 0);",
          "    assert!(parser.char() == ']');",
          "    assert!(union.items.is_empty());",
          "    assert!(!parser.bump_and_bump_space());",
          "    assert_eq!(set.span.start, start_pos);",
          "    assert_eq!(set.negated, false);",
          "    assert!(set.kind.is_empty());",
          "    assert!(set.kind.is_one_line());",
          "    assert!(Err(ErrorKind::ClassUnclosed).is_err());"
        ],
        "code": [
          "{",
          "    let pattern = \"[a-zA-Z0-9]\"; // valid character class with literals",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "    assert_eq!(parser.char(), '[');",
          "    assert_eq!(parser.pos(), start_pos);",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(!parser.bump_and_bump_space());",
          "    assert!(parser.char() != '^');",
          "    assert_eq!(union.items.len(), 0);",
          "    assert!(parser.char() == ']');",
          "    assert!(union.items.is_empty());",
          "    assert!(!parser.bump_and_bump_space());",
          "    assert_eq!(set.span.start, start_pos);",
          "    assert_eq!(set.negated, false);",
          "    assert!(set.kind.is_empty());",
          "    assert!(set.kind.is_one_line());",
          "    assert!(Err(ErrorKind::ClassUnclosed).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[ ]\"; // valid character class with whitespace",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"[ ]\"; // input pattern with whitespace in character class",
          "    let expected_negated = false; // negation is not expected",
          "    let expected_items_length = 0; // initially, there should be no items in the union",
          "    let expected_class_bracketed_span = Span { start: start_pos, end: parser.pos.get() }; // expected span of the resulting class",
          "    let expected_class_set_union_span = Span { start: expected_class_bracketed_span.start, end: expected_class_bracketed_span.start }; // expected span of the union",
          "    ",
          "    let result = parser.parse_set_class_open();",
          "    assert!(result.is_ok(), \"Expected successful parsing, found an error instead\");",
          "    ",
          "    let (set_bracketed, union) = result.unwrap();",
          "    assert_eq!(set_bracketed.negated, expected_negated, \"Expected negated to be false\");",
          "    assert_eq!(union.items.len(), expected_items_length, \"Expected union to have no items\");",
          "    assert_eq!(set_bracketed.span, expected_class_bracketed_span, \"Expected class bracketed span to match\");",
          "    assert_eq!(union.span, expected_class_set_union_span, \"Expected union span to match\");"
        ],
        "code": [
          "{",
          "    let pattern = \"[ ]\"; // valid character class with whitespace",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "    let pattern = \"[ ]\"; // input pattern with whitespace in character class",
          "    let expected_negated = false; // negation is not expected",
          "    let expected_items_length = 0; // initially, there should be no items in the union",
          "    let expected_class_bracketed_span = Span { start: start_pos, end: parser.pos.get() }; // expected span of the resulting class",
          "    let expected_class_set_union_span = Span { start: expected_class_bracketed_span.start, end: expected_class_bracketed_span.start }; // expected span of the union",
          "    ",
          "    let result = parser.parse_set_class_open();",
          "    assert!(result.is_ok(), \"Expected successful parsing, found an error instead\");",
          "    ",
          "    let (set_bracketed, union) = result.unwrap();",
          "    assert_eq!(set_bracketed.negated, expected_negated, \"Expected negated to be false\");",
          "    assert_eq!(union.items.len(), expected_items_length, \"Expected union to have no items\");",
          "    assert_eq!(set_bracketed.span, expected_class_bracketed_span, \"Expected class bracketed span to match\");",
          "    assert_eq!(union.span, expected_class_set_union_span, \"Expected union span to match\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[a-z -]\"; // valid character class with literal '-' after valid characters",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.pos.get(), Position { offset: 7, line: 1, column: 8 });",
          "    assert!(parser.stack_class.borrow().is_empty());",
          "    let result = parser.parse_set_class_open();",
          "    assert!(result.is_ok());",
          "    let (set, union) = result.unwrap();",
          "    assert_eq!(set.negated, false);",
          "    assert_eq!(union.items.len(), 2);",
          "    assert_eq!(union.items[0], ClassSetItem::Literal(Literal { span: _, kind: LiteralKind::Verbatim, c: 'a' }));",
          "    assert_eq!(union.items[1], ClassSetItem::Literal(Literal { span: _, kind: LiteralKind::Verbatim, c: 'z' }));",
          "    assert_eq!(set.kind, ClassSet::union(ClassSetUnion { span: _, items: vec![ClassSetItem::Literal(Literal { span: _, kind: LiteralKind::Verbatim, c: '-' })] } ));"
        ],
        "code": [
          "{",
          "    let pattern = \"[a-z -]\"; // valid character class with literal '-' after valid characters",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser {",
          "            pos: Cell::new(start_pos),",
          "            capture_index: Cell::new(0),",
          "            nest_limit: 10,",
          "            octal: false,",
          "            initial_ignore_whitespace: false,",
          "            empty_min_range: false,",
          "            ignore_whitespace: Cell::new(false),",
          "            comments: RefCell::new(vec![]),",
          "            stack_group: RefCell::new(vec![]),",
          "            stack_class: RefCell::new(vec![]),",
          "            capture_names: RefCell::new(vec![]),",
          "            scratch: RefCell::new(String::new()),",
          "        },",
          "        pattern,",
          "    };",
          "    let _ = parser.parse_set_class_open();",
          "    assert_eq!(parser.pos.get(), Position { offset: 7, line: 1, column: 8 });",
          "    assert!(parser.stack_class.borrow().is_empty());",
          "    let result = parser.parse_set_class_open();",
          "    assert!(result.is_ok());",
          "    let (set, union) = result.unwrap();",
          "    assert_eq!(set.negated, false);",
          "    assert_eq!(union.items.len(), 2);",
          "    assert_eq!(union.items[0], ClassSetItem::Literal(Literal { span: _, kind: LiteralKind::Verbatim, c: 'a' }));",
          "    assert_eq!(union.items[1], ClassSetItem::Literal(Literal { span: _, kind: LiteralKind::Verbatim, c: 'z' }));",
          "    assert_eq!(set.kind, ClassSet::union(ClassSetUnion { span: _, items: vec![ClassSetItem::Literal(Literal { span: _, kind: LiteralKind::Verbatim, c: '-' })] } ));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]