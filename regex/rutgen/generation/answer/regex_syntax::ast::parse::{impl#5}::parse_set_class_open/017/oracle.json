[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[^-]\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((expected_set, expected_union)));",
          "    assert!(result.is_ok());",
          "    assert!(union.items.is_empty());",
          "    assert_eq!(parser.char(), ']');",
          "    assert_eq!(parser.char(), '-');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() != '^');"
        ],
        "code": [
          "{",
          "    let pattern = \"[^-]\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "    assert_eq!(result, Ok((expected_set, expected_union)));",
          "    assert!(result.is_ok());",
          "    assert!(union.items.is_empty());",
          "    assert_eq!(parser.char(), ']');",
          "    assert_eq!(parser.char(), '-');",
          "    assert!(parser.bump_and_bump_space());",
          "    assert!(parser.char() != '^');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[^-]abc\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (set, union) = result.unwrap();",
          "    assert_eq!(union.items.len(), 1);",
          "    assert!(matches!(union.items[0], ClassSetItem::Literal(_)));",
          "    assert_eq!(set.negated, true);",
          "    assert_eq!(set.span.start.offset, 0);",
          "    assert_eq!(set.span.end.offset, 1);",
          "    assert_eq!(union.span.start.offset, 0);",
          "    assert_eq!(union.span.end.offset, 1);",
          "    assert!(union.items.iter().any(|item| matches!(item, ClassSetItem::Literal(literal) if literal.c == ']')));",
          "    assert!(union.items.iter().any(|item| matches!(item, ClassSetItem::Literal(literal) if literal.c == '-')));"
        ],
        "code": [
          "{",
          "    let pattern = \"[^-]abc\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "    assert!(result.is_ok());",
          "    let (set, union) = result.unwrap();",
          "    assert_eq!(union.items.len(), 1);",
          "    assert!(matches!(union.items[0], ClassSetItem::Literal(_)));",
          "    assert_eq!(set.negated, true);",
          "    assert_eq!(set.span.start.offset, 0);",
          "    assert_eq!(set.span.end.offset, 1);",
          "    assert_eq!(union.span.start.offset, 0);",
          "    assert_eq!(union.span.end.offset, 1);",
          "    assert!(union.items.iter().any(|item| matches!(item, ClassSetItem::Literal(literal) if literal.c == ']')));",
          "    assert!(union.items.iter().any(|item| matches!(item, ClassSetItem::Literal(literal) if literal.c == '-')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[^abc-]\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((ast::ClassBracketed { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 10, line: 1, column: 11 } }, negated: true, kind: ast::ClassSet::union(ast::ClassSetUnion { span: Span { start: Position { offset: 1, line: 1, column: 2 }, end: Position { offset: 1, line: 1, column: 2 } }, items: vec![] }) }), ast::ClassSetUnion { span: Span { start: Position { offset: 1, line: 1, column: 2 }, end: Position { offset: 10, line: 1, column: 11 } }, items: vec![ast::ClassSetItem::Literal(ast::Literal { span: Span { start: Position { offset: 1, line: 1, column: 2 }, end: Position { offset: 1, line: 1, column: 3 } }, kind: ast::LiteralKind::Verbatim, c: '-' })] })));"
        ],
        "code": [
          "{",
          "    let pattern = \"[^abc-]\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "    assert_eq!(result, Ok((ast::ClassBracketed { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 10, line: 1, column: 11 } }, negated: true, kind: ast::ClassSet::union(ast::ClassSetUnion { span: Span { start: Position { offset: 1, line: 1, column: 2 }, end: Position { offset: 1, line: 1, column: 2 } }, items: vec![] }) }), ast::ClassSetUnion { span: Span { start: Position { offset: 1, line: 1, column: 2 }, end: Position { offset: 10, line: 1, column: 11 } }, items: vec![ast::ClassSetItem::Literal(ast::Literal { span: Span { start: Position { offset: 1, line: 1, column: 2 }, end: Position { offset: 1, line: 1, column: 3 } }, kind: ast::LiteralKind::Verbatim, c: '-' })] })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[]\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((set, union)));",
          "    assert_eq!(union.items.len(), 1);",
          "    assert_eq!(union.items[0].kind, ast::LiteralKind::Verbatim);",
          "    assert_eq!(union.items[0].c, ']');",
          "    assert!(set.negated == false);",
          "    assert!(set.span.start.offset == 0);",
          "    assert!(set.span.end.offset == 2);",
          "    assert!(union.span.start.offset == 0);",
          "    assert!(union.span.end.offset == 1);",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let pattern = \"[]\";",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize as needed */ },",
          "        pattern,",
          "    };",
          "    let result = parser.parse_set_class_open();",
          "    assert_eq!(result, Ok((set, union)));",
          "    assert_eq!(union.items.len(), 1);",
          "    assert_eq!(union.items[0].kind, ast::LiteralKind::Verbatim);",
          "    assert_eq!(union.items[0].c, ']');",
          "    assert!(set.negated == false);",
          "    assert!(set.span.start.offset == 0);",
          "    assert!(set.span.end.offset == 2);",
          "    assert!(union.span.start.offset == 0);",
          "    assert!(union.span.end.offset == 1);",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]