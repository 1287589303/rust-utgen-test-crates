[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"first_group\")],",
          "        vec![None, Some(\"second_group\")],",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(info.pattern_len(), 2);",
          "    assert_eq!(info.slot_len(), 4);",
          "    assert_eq!(info.group_len(PatternID::new(0).unwrap()), 2);",
          "    assert_eq!(info.group_len(PatternID::new(1).unwrap()), 1);",
          "    assert_eq!(info.to_name(PatternID::new(0).unwrap(), 1), Some(\"first_group\"));",
          "    assert_eq!(info.to_name(PatternID::new(1).unwrap(), 0), None);"
        ],
        "code": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"first_group\")],",
          "        vec![None, Some(\"second_group\")],",
          "    ]);",
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(info.pattern_len(), 2);",
          "    assert_eq!(info.slot_len(), 4);",
          "    assert_eq!(info.group_len(PatternID::new(0).unwrap()), 2);",
          "    assert_eq!(info.group_len(PatternID::new(1).unwrap()), 1);",
          "    assert_eq!(info.to_name(PatternID::new(0).unwrap(), 1), Some(\"first_group\"));",
          "    assert_eq!(info.to_name(PatternID::new(1).unwrap(), 0), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None], // Only the implicit group",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(info.pattern_len(), 1);",
          "    assert_eq!(info.slot_len(), 2);",
          "    assert_eq!(info.group_len(PatternID::new(0).unwrap()), 1);",
          "    assert_eq!(info.slots(PatternID::new(0).unwrap(), 0), Some((0, 1)));",
          "    assert_eq!(info.to_name(PatternID::new(0).unwrap(), 0), None);"
        ],
        "code": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None], // Only the implicit group",
          "    ]);",
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(info.pattern_len(), 1);",
          "    assert_eq!(info.slot_len(), 2);",
          "    assert_eq!(info.group_len(PatternID::new(0).unwrap()), 1);",
          "    assert_eq!(info.slots(PatternID::new(0).unwrap(), 0), Some((0, 1)));",
          "    assert_eq!(info.to_name(PatternID::new(0).unwrap(), 0), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"group1\"), Some(\"group2\")],",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, GroupInfoErrorKind::FirstMustBeUnnamed { pattern: PatternID::must(0) });",
          "    assert_eq!(result, Err(GroupInfoError::first_must_be_unnamed(PatternID::must(0))));"
        ],
        "code": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"group1\"), Some(\"group2\")],",
          "    ]);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, GroupInfoErrorKind::FirstMustBeUnnamed { pattern: PatternID::must(0) });",
          "    assert_eq!(result, Err(GroupInfoError::first_must_be_unnamed(PatternID::must(0))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = GroupInfo::new(Vec::<Vec<Option<String>>>::new());",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(0, info.pattern_len());",
          "    assert_eq!(0, info.slot_len());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None, Some(\"a\")], vec![None]]);",
          "    assert!(result.is_err());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None]]);",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![Some(\"foo\")]]);",
          "    assert!(result.is_err());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None, Some(\"foo\"), Some(\"foo\")]]);",
          "    assert!(result.is_err());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None, Some(\"foo\")], vec![None, Some(\"foo\")]]);",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let result = GroupInfo::new(Vec::<Vec<Option<String>>>::new());",
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(0, info.pattern_len());",
          "    assert_eq!(0, info.slot_len());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None, Some(\"a\")], vec![None]]);",
          "    assert!(result.is_err());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None]]);",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![Some(\"foo\")]]);",
          "    assert!(result.is_err());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None, Some(\"foo\"), Some(\"foo\")]]);",
          "    assert!(result.is_err());",
          "    ",
          "    let result = GroupInfo::new(vec![vec![None, Some(\"foo\")], vec![None, Some(\"foo\")]]);",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![], // Missing the first unnamed group",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert!(GroupInfo::new(vec![vec![]]).is_err());"
        ],
        "code": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![], // Missing the first unnamed group",
          "    ]);",
          "    assert!(GroupInfo::new(vec![vec![]]).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"duplicate\"), Some(\"duplicate\")], // Duplicate names in the same pattern",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, GroupInfoErrorKind::Duplicate {",
          "    pattern: PatternID(SmallIndex::new(0).unwrap()),",
          "    name: Arc::from(\"duplicate\"),",
          "    });"
        ],
        "code": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"duplicate\"), Some(\"duplicate\")], // Duplicate names in the same pattern",
          "    ]);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, GroupInfoErrorKind::Duplicate {",
          "    pattern: PatternID(SmallIndex::new(0).unwrap()),",
          "    name: Arc::from(\"duplicate\"),",
          "    });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"first\")],",
          "        vec![None, Some(\"second\")],",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(info.pattern_len(), 2);",
          "    assert_eq!(info.slot_len(), 4);",
          "    assert_eq!(info.group_len(PatternID::new(0).unwrap()), 2);",
          "    assert_eq!(info.group_len(PatternID::new(1).unwrap()), 2);"
        ],
        "code": [
          "{",
          "    let result = GroupInfo::new(vec![",
          "        vec![None, Some(\"first\")],",
          "        vec![None, Some(\"second\")],",
          "    ]);",
          "    assert!(result.is_ok());",
          "    let info = result.unwrap();",
          "    assert_eq!(info.pattern_len(), 2);",
          "    assert_eq!(info.slot_len(), 4);",
          "    assert_eq!(info.group_len(PatternID::new(0).unwrap()), 2);",
          "    assert_eq!(info.group_len(PatternID::new(1).unwrap()), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut groups = vec![None]; // Implicit group",
          "    for i in 0..=u32::MAX {",
          "        groups.push(Some(\"group_name\"));",
          "    }",
          "    let result = GroupInfo::new(vec![groups]);",
          "}"
        ],
        "oracle": [
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"group_name\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"group_name\"), Some(\"group_name\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None], vec![None, Some(\"group_name\")]]).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![]]).is_err());",
          "    assert!(GroupInfo::new(Vec::<Vec<Option<String>>>::new()).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![None, None]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![Some(\"duplicate\")], vec![Some(\"duplicate\")]]).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"foo\")], vec![None, Some(\"bar\"), Some(\"foo\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"foo\"), None], vec![None, Some(\"foo\")]]).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![Some(\"first\"), Some(\"first\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None, None], vec![Some(\"test\")]]).is_ok());"
        ],
        "code": [
          "{",
          "    let mut groups = vec![None]; // Implicit group",
          "    for i in 0..=u32::MAX {",
          "        groups.push(Some(\"group_name\"));",
          "    }",
          "    let result = GroupInfo::new(vec![groups]);",
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"group_name\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"group_name\"), Some(\"group_name\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None], vec![None, Some(\"group_name\")]]).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![]]).is_err());",
          "    assert!(GroupInfo::new(Vec::<Vec<Option<String>>>::new()).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![None, None]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![Some(\"duplicate\")], vec![Some(\"duplicate\")]]).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"foo\")], vec![None, Some(\"bar\"), Some(\"foo\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None, Some(\"foo\"), None], vec![None, Some(\"foo\")]]).is_ok());",
          "    assert!(GroupInfo::new(vec![vec![Some(\"first\"), Some(\"first\")]]).is_err());",
          "    assert!(GroupInfo::new(vec![vec![None, None], vec![Some(\"test\")]]).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]