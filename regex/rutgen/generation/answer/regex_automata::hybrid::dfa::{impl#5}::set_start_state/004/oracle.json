[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let config = Config::new().starts_for_each_pattern(false);",
          "    let nfa = thompson::NFA::default();",
          "    let dfa = DFA {",
          "        config,",
          "        nfa,",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1,",
          "    };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    let id = LazyStateID(0);",
          "    let start = Start::from_usize(0).unwrap();",
          "    lazy.set_start_state(Anchored::No, start, id);",
          "}"
        ],
        "oracle": [
          "    assert!(lazy.as_ref().is_valid(id));",
          "    let start_index = start.as_usize();",
          "    assert_eq!(start_index, 0);",
          "    let index = match Anchored::No {",
          "    Anchored::No => start_index,",
          "    _ => unreachable!()",
          "    };",
          "    assert_eq!(index, 0);",
          "    assert_eq!(lazy.cache.starts[index], id);",
          "    lazy.set_start_state(Anchored::No, start, id);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let config = Config::new().starts_for_each_pattern(false);",
          "    let nfa = thompson::NFA::default();",
          "    let dfa = DFA {",
          "        config,",
          "        nfa,",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1,",
          "    };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    let id = LazyStateID(0);",
          "    let start = Start::from_usize(0).unwrap();",
          "    lazy.set_start_state(Anchored::No, start, id);",
          "    assert!(lazy.as_ref().is_valid(id));",
          "    let start_index = start.as_usize();",
          "    assert_eq!(start_index, 0);",
          "    let index = match Anchored::No {",
          "    Anchored::No => start_index,",
          "    _ => unreachable!()",
          "    };",
          "    assert_eq!(index, 0);",
          "    assert_eq!(lazy.cache.starts[index], id);",
          "    lazy.set_start_state(Anchored::No, start, id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let config = Config::new().starts_for_each_pattern(false);",
          "    let nfa = thompson::NFA::default();",
          "    let dfa = DFA {",
          "        config,",
          "        nfa,",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1,",
          "    };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    let id = LazyStateID(1);",
          "    let start = Start::from_usize(5).unwrap();",
          "    lazy.set_start_state(Anchored::No, start, id);",
          "}"
        ],
        "oracle": [
          "    assert!(lazy.as_ref().is_valid(id));",
          "    assert_eq!(self.cache.starts[Start::len() + start.as_usize()], id);",
          "    lazy.set_start_state(Anchored::No, start, id);",
          "    lazy.set_start_state(Anchored::Yes, start, id);",
          "    lazy.set_start_state(Anchored::Pattern(PatternID(0)), start, id);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let config = Config::new().starts_for_each_pattern(false);",
          "    let nfa = thompson::NFA::default();",
          "    let dfa = DFA {",
          "        config,",
          "        nfa,",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::default(),",
          "        quitset: ByteSet::default(),",
          "        cache_capacity: 1,",
          "    };",
          "    let mut lazy = Lazy { dfa: &dfa, cache: &mut cache };",
          "    let id = LazyStateID(1);",
          "    let start = Start::from_usize(5).unwrap();",
          "    lazy.set_start_state(Anchored::No, start, id);",
          "    assert!(lazy.as_ref().is_valid(id));",
          "    assert_eq!(self.cache.starts[Start::len() + start.as_usize()], id);",
          "    lazy.set_start_state(Anchored::No, start, id);",
          "    lazy.set_start_state(Anchored::Yes, start, id);",
          "    lazy.set_start_state(Anchored::Pattern(PatternID(0)), start, id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]