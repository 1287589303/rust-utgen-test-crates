[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_len: usize = 5; // a valid size",
          "    let stride2: usize = 5; // within valid range [1, 9]",
          "    let classes = ByteClasses([0; 256]);",
          "",
          "    let mut slice = vec![0u8; 256 + 8]; // Enough space for state_len, stride2, and classes",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].copy_from_slice(&classes.0);",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (tt, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, 8 + 256);",
          "    assert_eq!(tt.stride2, stride2);",
          "    assert_eq!(tt.classes, classes);",
          "    assert_eq!(tt.table.len(), (state_len << stride2) >> 2);",
          "    assert!(tt.classes.alphabet_len() <= (1usize << stride2));"
        ],
        "code": [
          "{",
          "    let state_len: usize = 5; // a valid size",
          "    let stride2: usize = 5; // within valid range [1, 9]",
          "    let classes = ByteClasses([0; 256]);",
          "",
          "    let mut slice = vec![0u8; 256 + 8]; // Enough space for state_len, stride2, and classes",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].copy_from_slice(&classes.0);",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());",
          "    let (tt, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, 8 + 256);",
          "    assert_eq!(tt.stride2, stride2);",
          "    assert_eq!(tt.classes, classes);",
          "    assert_eq!(tt.table.len(), (state_len << stride2) >> 2);",
          "    assert!(tt.classes.alphabet_len() <= (1usize << stride2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_len: usize = 3; // a valid size",
          "    let stride2: usize = 1; // minimum valid value",
          "    let classes = ByteClasses([0; 256]);",
          "",
          "    let mut slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].copy_from_slice(&classes.0);",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    let slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].copy_from_slice(&classes.0);",
          "    assert!(result.is_ok());",
          "    let (tt, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, slice.len());",
          "    assert_eq!(tt.stride2, stride2);",
          "    assert_eq!(tt.classes, classes);",
          "    assert_eq!(tt.table.len(), state_len);",
          "    assert!(tt.alphabet_len() <= (1usize << stride2));",
          "    assert!(slice[8..(8+256)].iter().all(|&b| b == 0));",
          "    assert!(tt.table.iter().all(|&t| t == 0));"
        ],
        "code": [
          "{",
          "    let state_len: usize = 3; // a valid size",
          "    let stride2: usize = 1; // minimum valid value",
          "    let classes = ByteClasses([0; 256]);",
          "",
          "    let mut slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].copy_from_slice(&classes.0);",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    let slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].copy_from_slice(&classes.0);",
          "    assert!(result.is_ok());",
          "    let (tt, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, slice.len());",
          "    assert_eq!(tt.stride2, stride2);",
          "    assert_eq!(tt.classes, classes);",
          "    assert_eq!(tt.table.len(), state_len);",
          "    assert!(tt.alphabet_len() <= (1usize << stride2));",
          "    assert!(slice[8..(8+256)].iter().all(|&b| b == 0));",
          "    assert!(tt.table.iter().all(|&t| t == 0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_len: usize = 4; // a valid size",
          "    let stride2: usize = 3; // within valid range [1, 9]",
          "    ",
          "    let mut slice = vec![0u8; 256 + 8]; ",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "",
          "    // Setting invalid ByteClasses",
          "    slice[8..(8+256)].fill(5); // An arbitrary value that does not correspond to valid classes",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    let slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().0, \"found equivalence class greater than alphabet len\");",
          "    ",
          "    let slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].fill(0); // Setting a valid value for classes",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let state_len: usize = 4; // a valid size",
          "    let stride2: usize = 3; // within valid range [1, 9]",
          "    ",
          "    let mut slice = vec![0u8; 256 + 8]; ",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "",
          "    // Setting invalid ByteClasses",
          "    slice[8..(8+256)].fill(5); // An arbitrary value that does not correspond to valid classes",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    let slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().0, \"found equivalence class greater than alphabet len\");",
          "    ",
          "    let slice = vec![0u8; 256 + 8];",
          "    slice[..4].copy_from_slice(&(state_len as u32).to_le_bytes());",
          "    slice[4..8].copy_from_slice(&(stride2 as u32).to_le_bytes());",
          "    slice[8..(8+256)].fill(0); // Setting a valid value for classes",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]