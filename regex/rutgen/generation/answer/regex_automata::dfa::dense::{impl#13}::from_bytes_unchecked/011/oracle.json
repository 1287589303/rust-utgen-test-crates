[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_len: u32 = 2; // should be > 0",
          "    let stride2: u32 = 9; // bound is 9",
          "    let alphabet_len: u32 = 512; // 2^9 = 512, thus classes.alphabet_len() = stride",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4; // StateID::SIZE is 4",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len]; // ensuring the slice length is >= 300",
          "    let mut cursor = 0;",
          "",
          "    // Write state_len",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "",
          "    // Write stride2",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "",
          "    // Write ByteClasses",
          "    let byte_classes = [0u8; 256]; // Placeholder for byte class since we need 256 bytes",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "",
          "    // Calculate the actual number of transitions and write them",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "        slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    assert_eq!(wire::try_read_u32_as_usize(&mut slice[..], \"state length\").is_ok(), true);",
          "    assert_eq!(wire::try_read_u32_as_usize(&mut slice[4..], \"stride2\").is_ok(), true);",
          "    assert_eq!(ByteClasses::from_bytes(&slice[8..]).is_ok(), true);",
          "    assert!(stride2 <= 9);",
          "    assert!(stride2 >= 1);",
          "    assert_eq!(classes.alphabet_len(), stride);",
          "    assert_eq!(wire::shl(state_len as usize, stride2 as usize, \"dense table transition length\").is_ok(), true);",
          "    assert_eq!(wire::mul(trans_len, StateID::SIZE, \"dense table state byte length\").is_ok(), true);",
          "    assert_eq!(wire::check_slice_len(&slice[264..], table_bytes_len, \"transition table\").is_ok(), true);",
          "    assert_eq!(wire::check_alignment::<StateID>(&slice[264..]).is_ok(), true);",
          "    assert_eq!(result, Ok((tt, slice.as_ptr().as_usize() - slice_start)));"
        ],
        "code": [
          "{",
          "    let state_len: u32 = 2; // should be > 0",
          "    let stride2: u32 = 9; // bound is 9",
          "    let alphabet_len: u32 = 512; // 2^9 = 512, thus classes.alphabet_len() = stride",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4; // StateID::SIZE is 4",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len]; // ensuring the slice length is >= 300",
          "    let mut cursor = 0;",
          "",
          "    // Write state_len",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "",
          "    // Write stride2",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "",
          "    // Write ByteClasses",
          "    let byte_classes = [0u8; 256]; // Placeholder for byte class since we need 256 bytes",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "",
          "    // Calculate the actual number of transitions and write them",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "        slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert_eq!(wire::try_read_u32_as_usize(&mut slice[..], \"state length\").is_ok(), true);",
          "    assert_eq!(wire::try_read_u32_as_usize(&mut slice[4..], \"stride2\").is_ok(), true);",
          "    assert_eq!(ByteClasses::from_bytes(&slice[8..]).is_ok(), true);",
          "    assert!(stride2 <= 9);",
          "    assert!(stride2 >= 1);",
          "    assert_eq!(classes.alphabet_len(), stride);",
          "    assert_eq!(wire::shl(state_len as usize, stride2 as usize, \"dense table transition length\").is_ok(), true);",
          "    assert_eq!(wire::mul(trans_len, StateID::SIZE, \"dense table state byte length\").is_ok(), true);",
          "    assert_eq!(wire::check_slice_len(&slice[264..], table_bytes_len, \"transition table\").is_ok(), true);",
          "    assert_eq!(wire::check_alignment::<StateID>(&slice[264..]).is_ok(), true);",
          "    assert_eq!(result, Ok((tt, slice.as_ptr().as_usize() - slice_start)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_len: u32 = 2; // should be > 0",
          "    let stride2: u32 = 1; // bound is 1",
          "    let alphabet_len: u32 = 2; // 1 << 1 = 2, thus classes.alphabet_len() = stride",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4; // StateID::SIZE is 4",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len]; // ensuring the slice length is >= 300",
          "    let mut cursor = 0;",
          "",
          "    // Write state_len",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "",
          "    // Write stride2",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "",
          "    // Write ByteClasses",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "",
          "    // Calculate the actual number of transitions and write them",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "        slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "}"
        ],
        "oracle": [
          "    unsafe fn from_bytes_unchecked_edge_case() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 1;",
          "    let alphabet_len: u32 = 2;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());",
          "    }",
          "    ",
          "    unsafe fn from_bytes_unchecked_stride_too_large() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 9;",
          "    let alphabet_len: u32 = 2;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_err());",
          "    }",
          "    ",
          "    unsafe fn from_bytes_unchecked_stride_too_small() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 0;",
          "    let alphabet_len: u32 = 2;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_err());",
          "    }",
          "    ",
          "    unsafe fn from_bytes_unchecked_alphabet_length_too_large() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 2; // Alphabet will be larger than stride",
          "    let alphabet_len: u32 = 4;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [4u8; 256]; // Setting all to 4 to ensure alphabet length is too large",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_err());",
          "    }"
        ],
        "code": [
          "{",
          "    let state_len: u32 = 2; // should be > 0",
          "    let stride2: u32 = 1; // bound is 1",
          "    let alphabet_len: u32 = 2; // 1 << 1 = 2, thus classes.alphabet_len() = stride",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4; // StateID::SIZE is 4",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len]; // ensuring the slice length is >= 300",
          "    let mut cursor = 0;",
          "",
          "    // Write state_len",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "",
          "    // Write stride2",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "",
          "    // Write ByteClasses",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "",
          "    // Calculate the actual number of transitions and write them",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "        slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    unsafe fn from_bytes_unchecked_edge_case() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 1;",
          "    let alphabet_len: u32 = 2;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_ok());",
          "    }",
          "    ",
          "    unsafe fn from_bytes_unchecked_stride_too_large() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 9;",
          "    let alphabet_len: u32 = 2;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_err());",
          "    }",
          "    ",
          "    unsafe fn from_bytes_unchecked_stride_too_small() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 0;",
          "    let alphabet_len: u32 = 2;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [0u8; 256];",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_err());",
          "    }",
          "    ",
          "    unsafe fn from_bytes_unchecked_alphabet_length_too_large() {",
          "    let state_len: u32 = 2;",
          "    let stride2: u32 = 2; // Alphabet will be larger than stride",
          "    let alphabet_len: u32 = 4;",
          "    let table_len: usize = (state_len as usize) * (1 << stride2) * 4;",
          "    let mut slice: Vec<u8> = vec![0; 300 + table_len];",
          "    let mut cursor = 0;",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"state length\").unwrap().1;",
          "    slice[..4].copy_from_slice(&state_len.to_le_bytes());",
          "    ",
          "    cursor += wire::try_read_u32_as_usize(&mut slice[cursor..], \"stride2\").unwrap().1;",
          "    slice[4..8].copy_from_slice(&stride2.to_le_bytes());",
          "    ",
          "    let byte_classes = [4u8; 256]; // Setting all to 4 to ensure alphabet length is too large",
          "    cursor += ByteClasses::from_bytes(&slice[cursor..]).unwrap().1;",
          "    slice[8..264].copy_from_slice(&byte_classes);",
          "    ",
          "    let num_transitions = (state_len as usize) * (1 << stride2);",
          "    for i in 0..num_transitions {",
          "    slice[264 + (i * 4)..264 + ((i + 1) * 4)].copy_from_slice(&(i as u32).to_le_bytes());",
          "    }",
          "    ",
          "    let result = unsafe { TransitionTable::from_bytes_unchecked(&mut slice) };",
          "    assert!(result.is_err());",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]