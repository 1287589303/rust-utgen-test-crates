[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Empty(Box::new(Span { start: 0, end: 0 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "}"
        ],
        "oracle": [
          "    let ast_empty = Ast::Empty(Box::new(Span { start: 0, end: 0 }));",
          "    let ast_flags = Ast::Flags(Box::new(SetFlags));",
          "    let ast_literal = Ast::Literal(Box::new(Literal));",
          "    let ast_dot = Ast::Dot(Box::new(Span { start: 0, end: 1 }));",
          "    let ast_assertion = Ast::Assertion(Box::new(Assertion));",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(ClassUnicode));",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(ClassPerl));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter_empty = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_empty.visit_pre(&ast_empty), Ok(()));",
          "    let mut nest_limiter_flags = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_flags.visit_pre(&ast_flags), Ok(()));",
          "    let mut nest_limiter_literal = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_literal.visit_pre(&ast_literal), Ok(()));",
          "    let mut nest_limiter_dot = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_dot.visit_pre(&ast_dot), Ok(()));",
          "    let mut nest_limiter_assertion = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_assertion.visit_pre(&ast_assertion), Ok(()));",
          "    let mut nest_limiter_class_unicode = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_class_unicode.visit_pre(&ast_class_unicode), Ok(()));",
          "    let mut nest_limiter_class_perl = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_class_perl.visit_pre(&ast_class_perl), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Empty(Box::new(Span { start: 0, end: 0 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "    let ast_empty = Ast::Empty(Box::new(Span { start: 0, end: 0 }));",
          "    let ast_flags = Ast::Flags(Box::new(SetFlags));",
          "    let ast_literal = Ast::Literal(Box::new(Literal));",
          "    let ast_dot = Ast::Dot(Box::new(Span { start: 0, end: 1 }));",
          "    let ast_assertion = Ast::Assertion(Box::new(Assertion));",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(ClassUnicode));",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(ClassPerl));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter_empty = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_empty.visit_pre(&ast_empty), Ok(()));",
          "    let mut nest_limiter_flags = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_flags.visit_pre(&ast_flags), Ok(()));",
          "    let mut nest_limiter_literal = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_literal.visit_pre(&ast_literal), Ok(()));",
          "    let mut nest_limiter_dot = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_dot.visit_pre(&ast_dot), Ok(()));",
          "    let mut nest_limiter_assertion = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_assertion.visit_pre(&ast_assertion), Ok(()));",
          "    let mut nest_limiter_class_unicode = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_class_unicode.visit_pre(&ast_class_unicode), Ok(()));",
          "    let mut nest_limiter_class_perl = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter_class_perl.visit_pre(&ast_class_perl), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Flags(Box::new(SetFlags));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Flags(Box::new(SetFlags))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Empty(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 0 } }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Assertion(Box::new(Assertion { span: Span { start: 0, end: 0 } }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Dot(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span { start: 0, end: 0 } }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Literal(Box::new(Literal { span: Span { start: 0, end: 0 } }))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Flags(Box::new(SetFlags));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Flags(Box::new(SetFlags))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Empty(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 0 } }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Assertion(Box::new(Assertion { span: Span { start: 0, end: 0 } }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Dot(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassUnicode(Box::new(ClassUnicode { span: Span { start: 0, end: 0 } }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Literal(Box::new(Literal { span: Span { start: 0, end: 0 } }))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Literal(Box::new(Literal { value: 'a' }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Literal(Box::new(Literal { value: 'a' }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Flags(Box::new(SetFlags {}))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Empty(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassPerl(Box::new(ClassPerl {})), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Dot(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassUnicode(Box::new(ClassUnicode {}))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Literal(Box::new(Literal { value: 'a' }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Literal(Box::new(Literal { value: 'a' }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Flags(Box::new(SetFlags {}))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Empty(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassPerl(Box::new(ClassPerl {})), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Dot(Box::new(Span { start: 0, end: 0 }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassUnicode(Box::new(ClassUnicode {}))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::Dot(Box::new(Span { start: 0, end: 1 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Repetition(Box::new(Repetition { span: Span { start: 0, end: 2 }, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span { start: 0, end: 0 }))) }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Group(Box::new(Group { span: Span { start: 0, end: 1 }, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Box::new(Span { start: 0, end: 1 }))) }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Alternation(Box::new(Alternation { span: Span { start: 0, end: 1 }, asts: vec![Ast::Empty(Box::new(Span { start: 0, end: 0 }))] }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Concat(Box::new(Concat { span: Span { start: 0, end: 1 }, asts: vec![Ast::Literal(Box::new(Literal { span: Span { start: 0, end: 1 }, value: 'a' }))] }))), Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::Dot(Box::new(Span { start: 0, end: 1 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::ClassBracketed(Box::new(ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ClassSet::Normal }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Repetition(Box::new(Repetition { span: Span { start: 0, end: 2 }, op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Empty(Box::new(Span { start: 0, end: 0 }))) }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Group(Box::new(Group { span: Span { start: 0, end: 1 }, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Box::new(Span { start: 0, end: 1 }))) }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Alternation(Box::new(Alternation { span: Span { start: 0, end: 1 }, asts: vec![Ast::Empty(Box::new(Span { start: 0, end: 0 }))] }))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_pre(&Ast::Concat(Box::new(Concat { span: Span { start: 0, end: 1 }, asts: vec![Ast::Literal(Box::new(Literal { span: Span { start: 0, end: 1 }, value: 'a' }))] }))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "}"
        ],
        "oracle": [
          "    let ast = Ast::Empty(Box::new(Span { start: 0, end: 5 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Flags(Box::new(SetFlags {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Literal(Box::new(Literal {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Dot(Box::new(Span { start: 0, end: 5 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Assertion(Box::new(Assertion {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));"
        ],
        "code": [
          "{",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "    let ast = Ast::Empty(Box::new(Span { start: 0, end: 5 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Flags(Box::new(SetFlags {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Literal(Box::new(Literal {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Dot(Box::new(Span { start: 0, end: 5 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::Assertion(Box::new(Assertion {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "    ",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode {}));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let result = nest_limiter.visit_pre(&ast);",
          "    assert_eq!(result, Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "}"
        ],
        "oracle": [
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Flags(Box::new(SetFlags { span: Span { start: 0, end: 2 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Empty(Box::new(Span { start: 0, end: 0 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Assertion(Box::new(Assertion { span: Span { start: 0, end: 1 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Dot(Box::new(Span { start: 0, end: 1 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Literal(Box::new(Literal { span: Span { start: 0, end: 1 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Repetition(Box::new(Repetition { span: Span { start: 0, end: 5 }, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 5 } }))) }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Err(ast::Error::NestLimitExceeded(10)));",
          "    ",
          "    let ast = Ast::ClassBracketed(Box::new(ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ClassSet::Normal }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Err(ast::Error::NestLimitExceeded(10)));"
        ],
        "code": [
          "{",
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    let _ = nest_limiter.visit_pre(&ast);",
          "    let ast = Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Flags(Box::new(SetFlags { span: Span { start: 0, end: 2 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Empty(Box::new(Span { start: 0, end: 0 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Assertion(Box::new(Assertion { span: Span { start: 0, end: 1 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Dot(Box::new(Span { start: 0, end: 1 }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::ClassUnicode(Box::new(ClassUnicode { span: Span { start: 0, end: 5 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Literal(Box::new(Literal { span: Span { start: 0, end: 1 } }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Ok(()));",
          "    ",
          "    let ast = Ast::Repetition(Box::new(Repetition { span: Span { start: 0, end: 5 }, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::ClassPerl(Box::new(ClassPerl { span: Span { start: 0, end: 5 } }))) }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Err(ast::Error::NestLimitExceeded(10)));",
          "    ",
          "    let ast = Ast::ClassBracketed(Box::new(ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ClassSet::Normal }));",
          "    let parser = ParserI { parser: Parser { nest_limit: 10 }, pattern: \".*\" };",
          "    let mut nest_limiter = NestLimiter::new(&parser);",
          "    assert_eq!(nest_limiter.visit_pre(&ast), Err(ast::Error::NestLimitExceeded(10)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]