[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::u8(0),",
          "        byte: 0,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ranges.range, None);",
          "    assert!(ranges.elements.next().is_some());",
          "    assert_eq!(ranges.elements.class.as_u8(), Some(0));",
          "    assert_eq!(ranges.elements.byte, 0);",
          "    assert!(ranges.elements.next().is_some());",
          "    assert_eq!(ranges.next().is_some(), true);",
          "    assert_eq!(ranges.range, Some((Unit::u8(0), Unit::u8(0))));",
          "    assert!(ranges.range.take().is_some());",
          "    assert_eq!(ranges.elements.next().is_none(), false);",
          "    assert_eq!(ranges.range, Some((Unit::u8(0), Unit::u8(0))));"
        ],
        "code": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::u8(0),",
          "        byte: 0,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next();",
          "    assert_eq!(ranges.range, None);",
          "    assert!(ranges.elements.next().is_some());",
          "    assert_eq!(ranges.elements.class.as_u8(), Some(0));",
          "    assert_eq!(ranges.elements.byte, 0);",
          "    assert!(ranges.elements.next().is_some());",
          "    assert_eq!(ranges.next().is_some(), true);",
          "    assert_eq!(ranges.range, Some((Unit::u8(0), Unit::u8(0))));",
          "    assert!(ranges.range.take().is_some());",
          "    assert_eq!(ranges.elements.next().is_none(), false);",
          "    assert_eq!(ranges.range, Some((Unit::u8(0), Unit::u8(0))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::eoi(1),",
          "        byte: 0,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next();",
          "}"
        ],
        "oracle": [
          "    let unit_eoi = Unit::eoi(1);",
          "    let unit_u8_zero = Unit::u8(0);",
          "    let byte_class_element_ranges = ByteClassElementRanges { elements: elements, range: None };",
          "    assert_eq!(byte_class_element_ranges.next(), Some((unit_eoi, unit_eoi)));",
          "    assert_eq!(byte_class_element_ranges.next(), None);",
          "    assert!(byte_class_element_ranges.range.is_none());",
          "    assert!(byte_class_element_ranges.elements.next().is_some());"
        ],
        "code": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::eoi(1),",
          "        byte: 0,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next();",
          "    let unit_eoi = Unit::eoi(1);",
          "    let unit_u8_zero = Unit::u8(0);",
          "    let byte_class_element_ranges = ByteClassElementRanges { elements: elements, range: None };",
          "    assert_eq!(byte_class_element_ranges.next(), Some((unit_eoi, unit_eoi)));",
          "    assert_eq!(byte_class_element_ranges.next(), None);",
          "    assert!(byte_class_element_ranges.range.is_none());",
          "    assert!(byte_class_element_ranges.elements.next().is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::u8(255),",
          "        byte: 255,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ranges.range, None);",
          "    assert_eq!(ranges.elements.class.as_u8(), Some(255));",
          "    assert!(ranges.elements.class.is_byte(255));",
          "    assert!(!ranges.elements.class.is_eoi());",
          "    assert_eq!(ranges.elements.byte, 255);"
        ],
        "code": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::u8(255),",
          "        byte: 255,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next();",
          "    assert_eq!(ranges.range, None);",
          "    assert_eq!(ranges.elements.class.as_u8(), Some(255));",
          "    assert!(ranges.elements.class.is_byte(255));",
          "    assert!(!ranges.elements.class.is_eoi());",
          "    assert_eq!(ranges.elements.byte, 255);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::u8(0),",
          "        byte: 0,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next(); // This will trigger the condition for reaching None",
          "}"
        ],
        "oracle": [
          "    assert!(ranges.range.is_none());",
          "    assert_eq!(ranges.elements.class.as_usize(), 0);",
          "    assert!(ranges.elements.next().is_some());",
          "    assert!(ranges.elements.next().is_none());",
          "    assert!(ranges.elements.next().is_none());"
        ],
        "code": [
          "{",
          "    struct TestByteClasses;",
          "    let classes = TestByteClasses;",
          "    let elements = ByteClassElements {",
          "        classes: &classes,",
          "        class: Unit::u8(0),",
          "        byte: 0,",
          "    };",
          "    let mut ranges = ByteClassElementRanges {",
          "        elements: elements,",
          "        range: None,",
          "    };",
          "    let _ = ranges.next(); // This will trigger the condition for reaching None",
          "    assert!(ranges.range.is_none());",
          "    assert_eq!(ranges.elements.class.as_usize(), 0);",
          "    assert!(ranges.elements.next().is_some());",
          "    assert!(ranges.elements.next().is_none());",
          "    assert!(ranges.elements.next().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]