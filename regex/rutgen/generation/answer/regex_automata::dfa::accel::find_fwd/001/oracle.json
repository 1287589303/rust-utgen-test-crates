[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let needles: &[u8] = &[];",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "}"
        ],
        "oracle": [
          "    let needles: &[u8] = &[0x61, 0x62]; // two needle bytes 'a' and 'b'",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    assert_eq!(find_fwd(needles, haystack, at), Some(1)); // expect index of 'a'",
          "    ",
          "    let needles: &[u8] = &[0x61]; // one needle byte 'a'",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    assert_eq!(find_fwd(needles, haystack, at), Some(1)); // expect index of 'a'",
          "    ",
          "    let needles: &[u8] = &[0x61, 0x62, 0x63]; // three needle bytes 'a', 'b', 'c'",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    assert_eq!(find_fwd(needles, haystack, at), Some(1)); // expect index of 'a'",
          "    ",
          "    #[should_panic]",
          "    let needles: &[u8] = &[]; // empty needles",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at); // expect panic for empty needles",
          "    ",
          "    #[should_panic]",
          "    let needles: &[u8] = &[0x61, 0x62, 0x63, 0x64]; // invalid length 4 needles",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at); // expect panic for invalid needles length"
        ],
        "code": [
          "{",
          "    let needles: &[u8] = &[];",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "    let needles: &[u8] = &[0x61, 0x62]; // two needle bytes 'a' and 'b'",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    assert_eq!(find_fwd(needles, haystack, at), Some(1)); // expect index of 'a'",
          "    ",
          "    let needles: &[u8] = &[0x61]; // one needle byte 'a'",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    assert_eq!(find_fwd(needles, haystack, at), Some(1)); // expect index of 'a'",
          "    ",
          "    let needles: &[u8] = &[0x61, 0x62, 0x63]; // three needle bytes 'a', 'b', 'c'",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    assert_eq!(find_fwd(needles, haystack, at), Some(1)); // expect index of 'a'",
          "    ",
          "    #[should_panic]",
          "    let needles: &[u8] = &[]; // empty needles",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at); // expect panic for empty needles",
          "    ",
          "    #[should_panic]",
          "    let needles: &[u8] = &[0x61, 0x62, 0x63, 0x64]; // invalid length 4 needles",
          "    let haystack: &[u8] = b\"example\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at); // expect panic for invalid needles length",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let needles: &[u8] = &[0x41]; // 'A'",
          "    let haystack: &[u8] = b\"example with A inside\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(find_fwd(&[0x41], b\"example with A inside\", 0), Some(14)); // needles.len() matches 1",
          "    panic::catch_unwind(|| find_fwd(&[], b\"example with A inside\", 0)).unwrap_err(); // needles.len() matches 0",
          "    assert_eq!(find_fwd(&[0x41, 0x42], b\"example with A inside\", 0), Some(14)); // needles.len() matches 2",
          "    assert_eq!(find_fwd(&[0x41, 0x42, 0x43], b\"example with A inside\", 0), Some(14)); // needles.len() matches 3"
        ],
        "code": [
          "{",
          "    let needles: &[u8] = &[0x41]; // 'A'",
          "    let haystack: &[u8] = b\"example with A inside\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "    assert_eq!(find_fwd(&[0x41], b\"example with A inside\", 0), Some(14)); // needles.len() matches 1",
          "    panic::catch_unwind(|| find_fwd(&[], b\"example with A inside\", 0)).unwrap_err(); // needles.len() matches 0",
          "    assert_eq!(find_fwd(&[0x41, 0x42], b\"example with A inside\", 0), Some(14)); // needles.len() matches 2",
          "    assert_eq!(find_fwd(&[0x41, 0x42, 0x43], b\"example with A inside\", 0), Some(14)); // needles.len() matches 3",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let needles: &[u8] = &[0x41, 0x42]; // 'A' and 'B'",
          "    let haystack: &[u8] = b\"example with A inside\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "}"
        ],
        "oracle": [
          "    let needles_2: &[u8] = &[0x41, 0x42];",
          "    let haystack_2: &[u8] = b\"example with A inside\";",
          "    let at_2 = 0;",
          "    assert_eq!(find_fwd(needles_2, haystack_2, at_2), Some(14));",
          "    ",
          "    let needles_0: &[u8] = &[];",
          "    let haystack_0: &[u8] = b\"example\";",
          "    let at_0 = 0;",
          "    let result_0 = std::panic::catch_unwind(|| { find_fwd(needles_0, haystack_0, at_0) });",
          "    assert!(result_0.is_err());",
          "    ",
          "    let needles_1: &[u8] = &[0x41];",
          "    let haystack_1: &[u8] = b\"example with A inside\";",
          "    let at_1 = 0;",
          "    assert_eq!(find_fwd(needles_1, haystack_1, at_1), Some(14));",
          "    ",
          "    let needles_3: &[u8] = &[0x41, 0x42, 0x43];",
          "    let haystack_3: &[u8] = b\"example with A, B, and C inside\";",
          "    let at_3 = 0;",
          "    assert_eq!(find_fwd(needles_3, haystack_3, at_3), Some(14));"
        ],
        "code": [
          "{",
          "    let needles: &[u8] = &[0x41, 0x42]; // 'A' and 'B'",
          "    let haystack: &[u8] = b\"example with A inside\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "    let needles_2: &[u8] = &[0x41, 0x42];",
          "    let haystack_2: &[u8] = b\"example with A inside\";",
          "    let at_2 = 0;",
          "    assert_eq!(find_fwd(needles_2, haystack_2, at_2), Some(14));",
          "    ",
          "    let needles_0: &[u8] = &[];",
          "    let haystack_0: &[u8] = b\"example\";",
          "    let at_0 = 0;",
          "    let result_0 = std::panic::catch_unwind(|| { find_fwd(needles_0, haystack_0, at_0) });",
          "    assert!(result_0.is_err());",
          "    ",
          "    let needles_1: &[u8] = &[0x41];",
          "    let haystack_1: &[u8] = b\"example with A inside\";",
          "    let at_1 = 0;",
          "    assert_eq!(find_fwd(needles_1, haystack_1, at_1), Some(14));",
          "    ",
          "    let needles_3: &[u8] = &[0x41, 0x42, 0x43];",
          "    let haystack_3: &[u8] = b\"example with A, B, and C inside\";",
          "    let at_3 = 0;",
          "    assert_eq!(find_fwd(needles_3, haystack_3, at_3), Some(14));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let needles: &[u8] = &[0x41, 0x42, 0x43]; // 'A', 'B', and 'C'",
          "    let haystack: &[u8] = b\"example with A, B, and C inside\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(find_fwd(&[0x41, 0x42], b\"example with A, B, and C inside\", 0), Some(15));",
          "    assert_eq!(find_fwd(&[0x41, 0x42, 0x43], b\"example with A, B, and C inside\", 0), Some(15));",
          "    assert!(std::panic::catch_unwind(|| find_fwd(&[], b\"example with A, B, and C inside\", 0)).is_err());",
          "    assert_eq!(find_fwd(&[0x41], b\"example with A, B, and C inside\", 0), Some(15));",
          "    assert_eq!(find_fwd(&[0x41, 0x42, 0x43], b\"example with A, B, and C inside\", 5), Some(15));"
        ],
        "code": [
          "{",
          "    let needles: &[u8] = &[0x41, 0x42, 0x43]; // 'A', 'B', and 'C'",
          "    let haystack: &[u8] = b\"example with A, B, and C inside\";",
          "    let at = 0;",
          "    let _ = find_fwd(needles, haystack, at);",
          "    assert_eq!(find_fwd(&[0x41, 0x42], b\"example with A, B, and C inside\", 0), Some(15));",
          "    assert_eq!(find_fwd(&[0x41, 0x42, 0x43], b\"example with A, B, and C inside\", 0), Some(15));",
          "    assert!(std::panic::catch_unwind(|| find_fwd(&[], b\"example with A, B, and C inside\", 0)).is_err());",
          "    assert_eq!(find_fwd(&[0x41], b\"example with A, B, and C inside\", 0), Some(15));",
          "    assert_eq!(find_fwd(&[0x41, 0x42, 0x43], b\"example with A, B, and C inside\", 5), Some(15));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]