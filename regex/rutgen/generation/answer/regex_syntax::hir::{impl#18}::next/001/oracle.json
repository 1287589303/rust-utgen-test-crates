[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_bytes_range = ClassBytesRange { start: 1, end: 10 };",
          "    let interval_set_iter = IntervalSetIter(vec![class_bytes_range].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_iter.next().is_some(), true);",
          "    assert_eq!(class_bytes_iter.next().unwrap().start, 1);",
          "    assert_eq!(class_bytes_iter.next().unwrap().end, 10);",
          "    assert_eq!(class_bytes_iter.next().is_some(), false);",
          "    assert_eq!(class_bytes_iter.0.next().is_some(), false);"
        ],
        "code": [
          "{",
          "    let class_bytes_range = ClassBytesRange { start: 1, end: 10 };",
          "    let interval_set_iter = IntervalSetIter(vec![class_bytes_range].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "    assert_eq!(class_bytes_iter.next().is_some(), true);",
          "    assert_eq!(class_bytes_iter.next().unwrap().start, 1);",
          "    assert_eq!(class_bytes_iter.next().unwrap().end, 10);",
          "    assert_eq!(class_bytes_iter.next().is_some(), false);",
          "    assert_eq!(class_bytes_iter.0.next().is_some(), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_bytes_range = ClassBytesRange { start: 0, end: 255 };",
          "    let interval_set_iter = IntervalSetIter(vec![class_bytes_range].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_iter.next().is_some(), true);",
          "    assert_eq!(class_bytes_iter.next().unwrap(), &class_bytes_range);",
          "    assert_eq!(class_bytes_iter.next().is_none(), true);"
        ],
        "code": [
          "{",
          "    let class_bytes_range = ClassBytesRange { start: 0, end: 255 };",
          "    let interval_set_iter = IntervalSetIter(vec![class_bytes_range].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "    assert_eq!(class_bytes_iter.next().is_some(), true);",
          "    assert_eq!(class_bytes_iter.next().unwrap(), &class_bytes_range);",
          "    assert_eq!(class_bytes_iter.next().is_none(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_bytes_range = ClassBytesRange { start: 100, end: 100 };",
          "    let interval_set_iter = IntervalSetIter(vec![class_bytes_range].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes_iter.next().is_some(), true);",
          "    assert_eq!(class_bytes_iter.next(), Some(&class_bytes_range));",
          "    assert_eq!(class_bytes_iter.next().is_none(), true);"
        ],
        "code": [
          "{",
          "    let class_bytes_range = ClassBytesRange { start: 100, end: 100 };",
          "    let interval_set_iter = IntervalSetIter(vec![class_bytes_range].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "    assert_eq!(class_bytes_iter.next().is_some(), true);",
          "    assert_eq!(class_bytes_iter.next(), Some(&class_bytes_range));",
          "    assert_eq!(class_bytes_iter.next().is_none(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set_iter = IntervalSetIter(vec![].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "}"
        ],
        "oracle": [
          "    let interval_set_iter = IntervalSetIter(vec![].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    assert_eq!(class_bytes_iter.next(), None);",
          "    let interval_set_iter_non_empty = IntervalSetIter(vec![ClassBytesRange { start: 1, end: 2 }].iter());",
          "    let mut class_bytes_iter_non_empty = ClassBytesIter(interval_set_iter_non_empty);",
          "    assert_eq!(class_bytes_iter_non_empty.next(), Some(&ClassBytesRange { start: 1, end: 2 }));",
          "    class_bytes_iter_non_empty.next();",
          "    assert_eq!(class_bytes_iter_non_empty.next(), None);"
        ],
        "code": [
          "{",
          "    let interval_set_iter = IntervalSetIter(vec![].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    let _ = class_bytes_iter.next();",
          "    let interval_set_iter = IntervalSetIter(vec![].iter());",
          "    let mut class_bytes_iter = ClassBytesIter(interval_set_iter);",
          "    assert_eq!(class_bytes_iter.next(), None);",
          "    let interval_set_iter_non_empty = IntervalSetIter(vec![ClassBytesRange { start: 1, end: 2 }].iter());",
          "    let mut class_bytes_iter_non_empty = ClassBytesIter(interval_set_iter_non_empty);",
          "    assert_eq!(class_bytes_iter_non_empty.next(), Some(&ClassBytesRange { start: 1, end: 2 }));",
          "    class_bytes_iter_non_empty.next();",
          "    assert_eq!(class_bytes_iter_non_empty.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]