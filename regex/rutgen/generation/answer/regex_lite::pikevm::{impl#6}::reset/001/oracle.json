[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA {",
          "        pattern: String::new(),",
          "        states: vec![State::new()], // One state for the empty pattern",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "}"
        ],
        "oracle": [
          "    slot_table.slots_per_state == nfa.group_len().checked_mul(2).unwrap();",
          "    slot_table.slots_for_captures == slot_table.slots_per_state;",
          "    let len = nfa.len().checked_add(1).and_then(|x| x.checked_mul(slot_table.slots_per_state)).expect(\"slot table length doesn't overflow\");",
          "    slot_table.table.len() == len;",
          "    slot_table.table.iter().all(|slot| slot.is_none());"
        ],
        "code": [
          "{",
          "    let nfa = NFA {",
          "        pattern: String::new(),",
          "        states: vec![State::new()], // One state for the empty pattern",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "    slot_table.slots_per_state == nfa.group_len().checked_mul(2).unwrap();",
          "    slot_table.slots_for_captures == slot_table.slots_per_state;",
          "    let len = nfa.len().checked_add(1).and_then(|x| x.checked_mul(slot_table.slots_per_state)).expect(\"slot table length doesn't overflow\");",
          "    slot_table.table.len() == len;",
          "    slot_table.table.iter().all(|slot| slot.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"a\".to_string(),",
          "        states: vec![State::new()], // One state for a single character pattern",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "}"
        ],
        "oracle": [
          "    slot_table.slots_per_state should equal nfa.group_len() * 2 after reset",
          "    slot_table.slots_for_captures should equal slot_table.slots_per_state after reset",
          "    slot_table.table length should be equal to (nfa.len() + 1) * slot_table.slots_per_state after reset",
          "    slot_table.table should be initialized to None for all elements after reset"
        ],
        "code": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"a\".to_string(),",
          "        states: vec![State::new()], // One state for a single character pattern",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "    slot_table.slots_per_state should equal nfa.group_len() * 2 after reset",
          "    slot_table.slots_for_captures should equal slot_table.slots_per_state after reset",
          "    slot_table.table length should be equal to (nfa.len() + 1) * slot_table.slots_per_state after reset",
          "    slot_table.table should be initialized to None for all elements after reset",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"abc\".to_string(),",
          "        states: vec![State::new(), State::new(), State::new()], // Three states for 'abc'",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(slot_table.slots_per_state, nfa.group_len() * 2);",
          "    assert_eq!(slot_table.slots_for_captures, slot_table.slots_per_state);",
          "    assert!(slot_table.table.len() > 0);",
          "    assert!(slot_table.table.iter().all(|&slot| slot.is_none()));"
        ],
        "code": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"abc\".to_string(),",
          "        states: vec![State::new(), State::new(), State::new()], // Three states for 'abc'",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "    assert_eq!(slot_table.slots_per_state, nfa.group_len() * 2);",
          "    assert_eq!(slot_table.slots_for_captures, slot_table.slots_per_state);",
          "    assert!(slot_table.table.len() > 0);",
          "    assert!(slot_table.table.iter().all(|&slot| slot.is_none()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"a\".repeat(128), // Max states case for long pattern",
          "        states: (0..128).map(|_| State::new()).collect(), // 128 states",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "}"
        ],
        "oracle": [
          "    slot_table.slots_per_state == nfa.group_len().checked_mul(2).unwrap()",
          "    slot_table.slots_for_captures == slot_table.slots_per_state",
          "    let len = nfa.len().checked_add(1).and_then(|x| x.checked_mul(slot_table.slots_per_state)).expect(\"slot table length doesn't overflow\");",
          "    slot_table.table.len() == len",
          "    slot_table.table.iter().all(|&slot| slot.is_none())"
        ],
        "code": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"a\".repeat(128), // Max states case for long pattern",
          "        states: (0..128).map(|_| State::new()).collect(), // 128 states",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable::new();",
          "",
          "    slot_table.reset(&pike_vm);",
          "    slot_table.slots_per_state == nfa.group_len().checked_mul(2).unwrap()",
          "    slot_table.slots_for_captures == slot_table.slots_per_state",
          "    let len = nfa.len().checked_add(1).and_then(|x| x.checked_mul(slot_table.slots_per_state)).expect(\"slot table length doesn't overflow\");",
          "    slot_table.table.len() == len",
          "    slot_table.table.iter().all(|&slot| slot.is_none())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"ab\".to_string(),",
          "        states: vec![State::new(), State::new()], // Two states for 'ab'",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable { table: vec![None; 101], slots_per_state: 0, slots_for_captures: 0 };",
          "",
          "    slot_table.reset(&pike_vm);",
          "}"
        ],
        "oracle": [
          "    slot_table.slots_per_state should equal nfa.group_len() * 2 after reset",
          "    slot_table.slots_for_captures should equal slot_table.slots_per_state after reset",
          "    slot_table.table should have a length that is nfa.len() + 1 multiplied by slot_table.slots_per_state after reset",
          "    slot_table.table should contain only None values after reset"
        ],
        "code": [
          "{",
          "    let nfa = NFA {",
          "        pattern: \"ab\".to_string(),",
          "        states: vec![State::new(), State::new()], // Two states for 'ab'",
          "        start: StateID(0),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa.clone());",
          "    let mut slot_table = SlotTable { table: vec![None; 101], slots_per_state: 0, slots_for_captures: 0 };",
          "",
          "    slot_table.reset(&pike_vm);",
          "    slot_table.slots_per_state should equal nfa.group_len() * 2 after reset",
          "    slot_table.slots_for_captures should equal slot_table.slots_per_state after reset",
          "    slot_table.table should have a length that is nfa.len() + 1 multiplied by slot_table.slots_per_state after reset",
          "    slot_table.table should contain only None values after reset",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]