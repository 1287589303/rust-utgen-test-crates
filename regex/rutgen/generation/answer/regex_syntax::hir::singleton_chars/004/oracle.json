[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![b'a'])),",
          "            props: Properties {},",
          "        },",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![b'b'])),",
          "            props: Properties {},",
          "        },",
          "    ];",
          "    let _ = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'a'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'b'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a', 'b']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'\\xFF'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'c'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'd'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'e'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'f'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'\\xC0', b'\\xA0'])), // invalid UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'g'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'h'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'\\xF0', b'\\x9F', b'\\x8D', b'\\x95'])), // valid multi-byte character",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['g', 'h']));"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![b'a'])),",
          "            props: Properties {},",
          "        },",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![b'b'])),",
          "            props: Properties {},",
          "        },",
          "    ];",
          "    let _ = singleton_chars(&hirs);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'a'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'b'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a', 'b']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'\\xFF'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'c'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'd'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'e'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'f'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'\\xC0', b'\\xA0'])), // invalid UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'g'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'h'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'\\xF0', b'\\x9F', b'\\x8D', b'\\x95'])), // valid multi-byte character",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['g', 'h']));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "            props: Properties {},",
          "        },",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111101])), // 'Á' in UTF-8",
          "            props: Properties {},",
          "        },",
          "    ];",
          "    let _ = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111101])), // 'Á' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['À', 'Á']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b11000001])), // invalid UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Empty, // non-literal",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111101])), // 'Á' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['À', 'Á', 'À']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec![]));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "            props: Properties {},",
          "        },",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111101])), // 'Á' in UTF-8",
          "            props: Properties {},",
          "        },",
          "    ];",
          "    let _ = singleton_chars(&hirs);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111101])), // 'Á' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['À', 'Á']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b11000001])), // invalid UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Empty, // non-literal",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111101])), // 'Á' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100])), // 'À' in UTF-8",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['À', 'Á', 'À']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec![]));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000000])), // Invalid UTF-8 sequence",
          "            props: Properties {},",
          "        },",
          "    ];",
          "    let _ = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'a'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a']));",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000000])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'b'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'a'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'b'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a', 'b']));",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'c'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000000])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000000])), // Invalid UTF-8 sequence",
          "            props: Properties {},",
          "        },",
          "    ];",
          "    let _ = singleton_chars(&hirs);",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'a'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a']));",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000000])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'b'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'a'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'b'])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a', 'b']));",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![b'c'])),",
          "    props: Properties {},",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000000])),",
          "    props: Properties {},",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs: Vec<Hir> = vec![];",
          "    let _ = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![97])) }, Hir { kind: HirKind::Literal(Literal(vec![98])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['a', 'b']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![99])) }, Hir { kind: HirKind::Literal(Literal(vec![100])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['c', 'd']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![0xE2, 0x9C, 0x94])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['✔']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Class(Class(vec![97, 98, 99])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![0xFF])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![0xE2, 0x28])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let hirs: Vec<Hir> = vec![];",
          "    let _ = singleton_chars(&hirs);",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![97])) }, Hir { kind: HirKind::Literal(Literal(vec![98])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['a', 'b']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![99])) }, Hir { kind: HirKind::Literal(Literal(vec![100])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['c', 'd']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![0xE2, 0x9C, 0x94])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['✔']));",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Class(Class(vec![97, 98, 99])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![0xFF])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let hirs: Vec<Hir> = vec![Hir { kind: HirKind::Literal(Literal(vec![0xE2, 0x28])) }];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![b'a'])),",
          "            props: Properties {},",
          "        },",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100, b'x'])), // 'À' but with an extra byte",
          "            props: Properties {},",
          "        },",
          "    ];  ",
          "    let _ = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a']));",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    assert!(singleton_chars(&hirs).is_some());",
          "    assert!(singleton_chars(&hirs).is_none());"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![b'a'])),",
          "            props: Properties {},",
          "        },",
          "        Hir { ",
          "            kind: HirKind::Literal(Literal(vec![0b11000010, 0b10111100, b'x'])), // 'À' but with an extra byte",
          "            props: Properties {},",
          "        },",
          "    ];  ",
          "    let _ = singleton_chars(&hirs);",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a']));",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    assert!(singleton_chars(&hirs).is_some());",
          "    assert!(singleton_chars(&hirs).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]