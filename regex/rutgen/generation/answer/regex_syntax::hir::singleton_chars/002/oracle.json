[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![0, 159, 146, 150])), // Invalid UTF-8 sequence",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(singleton_chars(&hirs), None);"
        ],
        "code": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![0, 159, 146, 150])), // Invalid UTF-8 sequence",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![0xC0, 0x80])), // Valid bytes but decode to unassignable character",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![Hir { kind: HirKind::Literal(Literal(vec![0xC0, 0x80])), props: Properties::default() }];",
          "    assert_eq!(singleton_chars(&hirs), None);"
        ],
        "code": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![0xC0, 0x80])), // Valid bytes but decode to unassignable character",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "    let hirs = vec![Hir { kind: HirKind::Literal(Literal(vec![0xC0, 0x80])), props: Properties::default() }];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![])), // Empty byte sequence",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![97])), // Valid single char (\"a\")",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000000, 0b10111111])), // Valid UTF-8 for \"每\"",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['每']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![240, 159, 146, 150])), // Valid UTF-8 for \"\"",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0])), // Invalid UTF-8",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![240])), // Incorrect byte leading to no valid char",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![172, 173])), // Valid double bytes but expecting single char return",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);"
        ],
        "code": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![])), // Empty byte sequence",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![97])), // Valid single char (\"a\")",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['a']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0b11000000, 0b10111111])), // Valid UTF-8 for \"每\"",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['每']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![240, 159, 146, 150])), // Valid UTF-8 for \"\"",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), Some(vec!['']));",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0])), // Invalid UTF-8",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![240])), // Incorrect byte leading to no valid char",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![172, 173])), // Valid double bytes but expecting single char return",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid starting byte for UTF-8",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid starting byte for UTF-8",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);"
        ],
        "code": [
          "{",
          "    struct Literal(Vec<u8>);",
          "",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid starting byte for UTF-8",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "    singleton_chars(&hirs);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid starting byte for UTF-8",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    assert_eq!(singleton_chars(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]