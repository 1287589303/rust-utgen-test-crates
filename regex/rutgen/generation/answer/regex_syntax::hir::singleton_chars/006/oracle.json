[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal1 = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x61])), // 'a'",
          "        props: Properties::default(),",
          "    };",
          "    let literal2 = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x62])), // 'b'",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![literal1, literal2];",
          "    let result = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(vec!['a', 'b']));"
        ],
        "code": [
          "{",
          "    let literal1 = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x61])), // 'a'",
          "        props: Properties::default(),",
          "    };",
          "    let literal2 = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x62])), // 'b'",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![literal1, literal2];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['a', 'b']));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs: Vec<Hir> = vec![];",
          "    let result = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs: Vec<Hir> = vec![];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec![]));"
        ],
        "code": [
          "{",
          "    let hirs: Vec<Hir> = vec![];",
          "    let result = singleton_chars(&hirs);",
          "    let hirs: Vec<Hir> = vec![];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec![]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid byte",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![literal];",
          "    let result = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_none());"
        ],
        "code": [
          "{",
          "    let literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid byte",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![literal];",
          "    let result = singleton_chars(&hirs);",
          "    assert!(result.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let valid_literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x63])), // 'c'",
          "        props: Properties::default(),",
          "    };",
          "    let invalid_literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid byte",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![valid_literal, invalid_literal];",
          "    let result = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    assert_eq!(singletons.len(), 1);",
          "    assert_eq!(singletons[0], 'c');"
        ],
        "code": [
          "{",
          "    let valid_literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x63])), // 'c'",
          "        props: Properties::default(),",
          "    };",
          "    let invalid_literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0xFF])), // Invalid byte",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![valid_literal, invalid_literal];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    assert_eq!(singletons.len(), 1);",
          "    assert_eq!(singletons[0], 'c');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x64])), // 'd'",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![literal];",
          "    let result = singleton_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(vec!['d']));"
        ],
        "code": [
          "{",
          "    let literal = Hir {",
          "        kind: HirKind::Literal(Literal(vec![0x64])), // 'd'",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![literal];",
          "    let result = singleton_chars(&hirs);",
          "    assert_eq!(result, Some(vec!['d']));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]