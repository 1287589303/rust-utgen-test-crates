[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice = vec![0u8; ",
          "        2 * std::mem::size_of::<u128>() + ",
          "        std::mem::size_of::<u32>() + ",
          "        std::mem::size_of::<Flags>() + ",
          "        std::mem::size_of::<Transitions<&[u8]>>() + ",
          "        std::mem::size_of::<StartTable<&[u8]>>() + ",
          "        std::mem::size_of::<Special>() + ",
          "        std::mem::size_of::<ByteSet>()];",
          "    ",
          "    let label_len = wire::write_label(&mut slice, LABEL).unwrap();",
          "    let endianness_len = wire::write_endianness_check(&mut slice[label_len..]).unwrap();",
          "    let version_len = wire::write_version(&mut slice[label_len + endianness_len..], VERSION).unwrap();",
          "    ",
          "    let (flags, flags_len) = Flags::from_bytes(&slice[label_len + endianness_len + version_len..]).unwrap();",
          "    let (transitions, trans_len) = Transitions::<&[u8]>::from_bytes_unchecked(&slice[label_len + endianness_len + version_len + flags_len..]).unwrap();",
          "    ",
          "    let (start_table, start_len) = StartTable::from_bytes_unchecked(&slice[label_len + endianness_len + version_len + flags_len + trans_len..]).unwrap();",
          "    ",
          "    let (special, special_len) = Special::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + trans_len + start_len..]).unwrap();",
          "    ",
          "    let (quitset, quitset_len) = ByteSet::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + trans_len + start_len + special_len..]).unwrap();",
          "",
          "    unsafe {",
          "        let result = DFA::from_bytes_unchecked(&slice).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(wire::read_label(&slice[nr..], LABEL).is_ok());",
          "    assert!(wire::read_endianness_check(&slice[nr..]).is_ok());",
          "    assert!(wire::read_version(&slice[nr..], VERSION).is_ok());",
          "    assert!(wire::try_read_u32(&slice[nr..], \"unused space\").is_ok());",
          "    assert!(Flags::from_bytes(&slice[nr..]).is_ok());",
          "    assert!(Transitions::from_bytes_unchecked(&slice[nr..]).is_err());"
        ],
        "code": [
          "{",
          "    let mut slice = vec![0u8; ",
          "        2 * std::mem::size_of::<u128>() + ",
          "        std::mem::size_of::<u32>() + ",
          "        std::mem::size_of::<Flags>() + ",
          "        std::mem::size_of::<Transitions<&[u8]>>() + ",
          "        std::mem::size_of::<StartTable<&[u8]>>() + ",
          "        std::mem::size_of::<Special>() + ",
          "        std::mem::size_of::<ByteSet>()];",
          "    ",
          "    let label_len = wire::write_label(&mut slice, LABEL).unwrap();",
          "    let endianness_len = wire::write_endianness_check(&mut slice[label_len..]).unwrap();",
          "    let version_len = wire::write_version(&mut slice[label_len + endianness_len..], VERSION).unwrap();",
          "    ",
          "    let (flags, flags_len) = Flags::from_bytes(&slice[label_len + endianness_len + version_len..]).unwrap();",
          "    let (transitions, trans_len) = Transitions::<&[u8]>::from_bytes_unchecked(&slice[label_len + endianness_len + version_len + flags_len..]).unwrap();",
          "    ",
          "    let (start_table, start_len) = StartTable::from_bytes_unchecked(&slice[label_len + endianness_len + version_len + flags_len + trans_len..]).unwrap();",
          "    ",
          "    let (special, special_len) = Special::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + trans_len + start_len..]).unwrap();",
          "    ",
          "    let (quitset, quitset_len) = ByteSet::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + trans_len + start_len + special_len..]).unwrap();",
          "",
          "    unsafe {",
          "        let result = DFA::from_bytes_unchecked(&slice).unwrap();",
          "    }",
          "    assert!(wire::read_label(&slice[nr..], LABEL).is_ok());",
          "    assert!(wire::read_endianness_check(&slice[nr..]).is_ok());",
          "    assert!(wire::read_version(&slice[nr..], VERSION).is_ok());",
          "    assert!(wire::try_read_u32(&slice[nr..], \"unused space\").is_ok());",
          "    assert!(Flags::from_bytes(&slice[nr..]).is_ok());",
          "    assert!(Transitions::from_bytes_unchecked(&slice[nr..]).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut slice = vec![0u8; ",
          "        2 * std::mem::size_of::<u128>() + ",
          "        std::mem::size_of::<u32>() + ",
          "        std::mem::size_of::<Flags>() + ",
          "        std::mem::size_of::<Transitions<&[u8]>>() + ",
          "        std::mem::size_of::<StartTable<&[u8]>>() + ",
          "        std::mem::size_of::<Special>() + ",
          "        std::mem::size_of::<ByteSet>()];",
          "    ",
          "    let label_len = wire::write_label(&mut slice, LABEL).unwrap();",
          "    let endianness_len = wire::write_endianness_check(&mut slice[label_len..]).unwrap();",
          "    let version_len = wire::write_version(&mut slice[label_len + endianness_len..], VERSION).unwrap();",
          "    ",
          "    let (flags, flags_len) = Flags::from_bytes(&slice[label_len + endianness_len + version_len..]).unwrap();",
          "    ",
          "    let invalid_transitions_slice = vec![0u8; 1]; // Invalid transitions that will cause an error",
          "    slice.extend(invalid_transitions_slice);",
          "    ",
          "    let (start_table, start_len) = StartTable::from_bytes_unchecked(&slice[label_len + endianness_len + version_len + flags_len..]).unwrap();",
          "    ",
          "    let (special, special_len) = Special::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + start_len..]).unwrap();",
          "    ",
          "    let (quitset, quitset_len) = ByteSet::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + start_len + special_len..]).unwrap();",
          "",
          "    unsafe {",
          "        let result = DFA::from_bytes_unchecked(&slice).unwrap();",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(wire::read_label(&slice[nr..], LABEL).is_ok());",
          "    assert!(wire::read_endianness_check(&slice[nr..]).is_ok());",
          "    assert!(wire::read_version(&slice[nr..], VERSION).is_ok());",
          "    assert!(wire::try_read_u32(&slice[nr..], \"unused space\").is_ok());",
          "    assert!(Flags::from_bytes(&slice[nr..]).is_ok());",
          "    assert!(Transitions::from_bytes_unchecked(&slice[nr..]).is_err());"
        ],
        "code": [
          "{",
          "    let mut slice = vec![0u8; ",
          "        2 * std::mem::size_of::<u128>() + ",
          "        std::mem::size_of::<u32>() + ",
          "        std::mem::size_of::<Flags>() + ",
          "        std::mem::size_of::<Transitions<&[u8]>>() + ",
          "        std::mem::size_of::<StartTable<&[u8]>>() + ",
          "        std::mem::size_of::<Special>() + ",
          "        std::mem::size_of::<ByteSet>()];",
          "    ",
          "    let label_len = wire::write_label(&mut slice, LABEL).unwrap();",
          "    let endianness_len = wire::write_endianness_check(&mut slice[label_len..]).unwrap();",
          "    let version_len = wire::write_version(&mut slice[label_len + endianness_len..], VERSION).unwrap();",
          "    ",
          "    let (flags, flags_len) = Flags::from_bytes(&slice[label_len + endianness_len + version_len..]).unwrap();",
          "    ",
          "    let invalid_transitions_slice = vec![0u8; 1]; // Invalid transitions that will cause an error",
          "    slice.extend(invalid_transitions_slice);",
          "    ",
          "    let (start_table, start_len) = StartTable::from_bytes_unchecked(&slice[label_len + endianness_len + version_len + flags_len..]).unwrap();",
          "    ",
          "    let (special, special_len) = Special::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + start_len..]).unwrap();",
          "    ",
          "    let (quitset, quitset_len) = ByteSet::from_bytes(&slice[label_len + endianness_len + version_len + flags_len + start_len + special_len..]).unwrap();",
          "",
          "    unsafe {",
          "        let result = DFA::from_bytes_unchecked(&slice).unwrap();",
          "    }",
          "    assert!(wire::read_label(&slice[nr..], LABEL).is_ok());",
          "    assert!(wire::read_endianness_check(&slice[nr..]).is_ok());",
          "    assert!(wire::read_version(&slice[nr..], VERSION).is_ok());",
          "    assert!(wire::try_read_u32(&slice[nr..], \"unused space\").is_ok());",
          "    assert!(Flags::from_bytes(&slice[nr..]).is_ok());",
          "    assert!(Transitions::from_bytes_unchecked(&slice[nr..]).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]