[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Create a non-final state with transitions.",
          "    let state_id = trie.add_empty();",
          "    let transition = Transition {",
          "        range: Utf8Range::from(1..=5),",
          "        next_id: StateID::new_unchecked(2), // Non-final state ID",
          "    };",
          "",
          "    trie.add_transition(state_id, transition.range, transition.next_id);",
          "",
          "    // Invoke the duplicate function.",
          "    let new_id = trie.duplicate(state_id);",
          "}"
        ],
        "oracle": [
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != state_id);",
          "    assert!(trie.state(new_id).transitions.len() == trie.state(state_id).transitions.len());",
          "    assert!(trie.state(new_id).transitions[0].range == trie.state(state_id).transitions[0].range);",
          "    assert!(trie.state(new_id).transitions[0].next_id != trie.state(state_id).transitions[0].next_id);",
          "    assert!(trie.state(new_id).transitions[0].next_id == trie.state(2).next_id);"
        ],
        "code": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Create a non-final state with transitions.",
          "    let state_id = trie.add_empty();",
          "    let transition = Transition {",
          "        range: Utf8Range::from(1..=5),",
          "        next_id: StateID::new_unchecked(2), // Non-final state ID",
          "    };",
          "",
          "    trie.add_transition(state_id, transition.range, transition.next_id);",
          "",
          "    // Invoke the duplicate function.",
          "    let new_id = trie.duplicate(state_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != state_id);",
          "    assert!(trie.state(new_id).transitions.len() == trie.state(state_id).transitions.len());",
          "    assert!(trie.state(new_id).transitions[0].range == trie.state(state_id).transitions[0].range);",
          "    assert!(trie.state(new_id).transitions[0].next_id != trie.state(state_id).transitions[0].next_id);",
          "    assert!(trie.state(new_id).transitions[0].next_id == trie.state(2).next_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Create a non-final state with multiple transitions.",
          "    let state_id = trie.add_empty();",
          "    let transition1 = Transition {",
          "        range: Utf8Range::from(1..=5),",
          "        next_id: StateID::new_unchecked(2), // Non-final state ID",
          "    };",
          "    let transition2 = Transition {",
          "        range: Utf8Range::from(6..=10),",
          "        next_id: StateID::new_unchecked(3), // Another non-final state ID",
          "    };",
          "",
          "    trie.add_transition(state_id, transition1.range, transition1.next_id);",
          "    trie.add_transition(state_id, transition2.range, transition2.next_id);",
          "",
          "    // Invoke the duplicate function.",
          "    let new_id = trie.duplicate(state_id);",
          "}"
        ],
        "oracle": [
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != state_id);",
          "    assert_eq!(trie.state(new_id).transitions.len(), 2);",
          "    assert_eq!(trie.state(new_id).transitions[0].range, Utf8Range::from(1..=5));",
          "    assert_eq!(trie.state(new_id).transitions[0].next_id, StateID::new_unchecked(2));",
          "    assert_eq!(trie.state(new_id).transitions[1].range, Utf8Range::from(6..=10));",
          "    assert_eq!(trie.state(new_id).transitions[1].next_id, StateID::new_unchecked(3));"
        ],
        "code": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Create a non-final state with multiple transitions.",
          "    let state_id = trie.add_empty();",
          "    let transition1 = Transition {",
          "        range: Utf8Range::from(1..=5),",
          "        next_id: StateID::new_unchecked(2), // Non-final state ID",
          "    };",
          "    let transition2 = Transition {",
          "        range: Utf8Range::from(6..=10),",
          "        next_id: StateID::new_unchecked(3), // Another non-final state ID",
          "    };",
          "",
          "    trie.add_transition(state_id, transition1.range, transition1.next_id);",
          "    trie.add_transition(state_id, transition2.range, transition2.next_id);",
          "",
          "    // Invoke the duplicate function.",
          "    let new_id = trie.duplicate(state_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != state_id);",
          "    assert_eq!(trie.state(new_id).transitions.len(), 2);",
          "    assert_eq!(trie.state(new_id).transitions[0].range, Utf8Range::from(1..=5));",
          "    assert_eq!(trie.state(new_id).transitions[0].next_id, StateID::new_unchecked(2));",
          "    assert_eq!(trie.state(new_id).transitions[1].range, Utf8Range::from(6..=10));",
          "    assert_eq!(trie.state(new_id).transitions[1].next_id, StateID::new_unchecked(3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Create a root state with transitions pointing to another non-final state.",
          "    let state_id = trie.add_empty();",
          "    let inner_state_id = trie.add_empty();",
          "",
          "    let transition = Transition {",
          "        range: Utf8Range::from(1..=5),",
          "        next_id: inner_state_id, // Non-final state ID",
          "    };",
          "",
          "    trie.add_transition(state_id, transition.range, transition.next_id);",
          "",
          "    // Add a transition to a final state to the inner state.",
          "    let final_transition = Transition {",
          "        range: Utf8Range::from(6..=10),",
          "        next_id: FINAL, // Final state",
          "    };",
          "    ",
          "    trie.add_transition(inner_state_id, final_transition.range, final_transition.next_id);",
          "",
          "    // Invoke the duplicate function.",
          "    let new_id = trie.duplicate(state_id);",
          "}"
        ],
        "oracle": [
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != state_id);",
          "    assert!(trie.state(new_id).transitions.len() == trie.state(state_id).transitions.len());",
          "    assert!(trie.state(new_id).transitions[0].range == Utf8Range::from(1..=5));",
          "    assert!(trie.state(new_id).transitions[0].next_id != FINAL);",
          "    assert!(trie.state(new_id).transitions[0].next_id != inner_state_id);",
          "    assert!(trie.state(new_id).transitions[1].range == Utf8Range::from(6..=10));",
          "    assert!(trie.state(new_id).transitions[1].next_id == FINAL);"
        ],
        "code": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Create a root state with transitions pointing to another non-final state.",
          "    let state_id = trie.add_empty();",
          "    let inner_state_id = trie.add_empty();",
          "",
          "    let transition = Transition {",
          "        range: Utf8Range::from(1..=5),",
          "        next_id: inner_state_id, // Non-final state ID",
          "    };",
          "",
          "    trie.add_transition(state_id, transition.range, transition.next_id);",
          "",
          "    // Add a transition to a final state to the inner state.",
          "    let final_transition = Transition {",
          "        range: Utf8Range::from(6..=10),",
          "        next_id: FINAL, // Final state",
          "    };",
          "    ",
          "    trie.add_transition(inner_state_id, final_transition.range, final_transition.next_id);",
          "",
          "    // Invoke the duplicate function.",
          "    let new_id = trie.duplicate(state_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != state_id);",
          "    assert!(trie.state(new_id).transitions.len() == trie.state(state_id).transitions.len());",
          "    assert!(trie.state(new_id).transitions[0].range == Utf8Range::from(1..=5));",
          "    assert!(trie.state(new_id).transitions[0].next_id != FINAL);",
          "    assert!(trie.state(new_id).transitions[0].next_id != inner_state_id);",
          "    assert!(trie.state(new_id).transitions[1].range == Utf8Range::from(6..=10));",
          "    assert!(trie.state(new_id).transitions[1].next_id == FINAL);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]