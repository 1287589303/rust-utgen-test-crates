[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Add a state with valid transitions",
          "    let old_id = trie.add_empty();",
          "    let transition_range = Utf8Range::from(0..=127);",
          "    let transition_next_id = StateID::new_unchecked(2); // not FINAL",
          "    trie.add_transition(old_id, transition_range.clone(), transition_next_id);",
          "    ",
          "    // Add a transition that leads to FINAL",
          "    trie.add_transition(transition_next_id, Utf8Range::from(128..=255), FINAL);",
          "",
          "    // Now we can call the duplicate function",
          "    let new_id = trie.duplicate(old_id);",
          "}"
        ],
        "oracle": [
          "    trie.state(old_id).transitions.len() > 0",
          "    trie.state(old_id).transitions[0].next_id == FINAL",
          "    trie.state(old_id).transitions[0].range == transition_range",
          "    trie.state(old_id).transitions[0].next_id == transition_next_id",
          "    trie.state(old_id).transitions.len() == 1",
          "    trie.states.len() > 1",
          "    new_id != FINAL",
          "    new_id != old_id",
          "    trie.state(new_id).transitions.len() > 0",
          "    trie.state(new_id).transitions[0].range == transition_range",
          "    trie.state(new_id).transitions[0].next_id == FINAL"
        ],
        "code": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Add a state with valid transitions",
          "    let old_id = trie.add_empty();",
          "    let transition_range = Utf8Range::from(0..=127);",
          "    let transition_next_id = StateID::new_unchecked(2); // not FINAL",
          "    trie.add_transition(old_id, transition_range.clone(), transition_next_id);",
          "    ",
          "    // Add a transition that leads to FINAL",
          "    trie.add_transition(transition_next_id, Utf8Range::from(128..=255), FINAL);",
          "",
          "    // Now we can call the duplicate function",
          "    let new_id = trie.duplicate(old_id);",
          "    trie.state(old_id).transitions.len() > 0",
          "    trie.state(old_id).transitions[0].next_id == FINAL",
          "    trie.state(old_id).transitions[0].range == transition_range",
          "    trie.state(old_id).transitions[0].next_id == transition_next_id",
          "    trie.state(old_id).transitions.len() == 1",
          "    trie.states.len() > 1",
          "    new_id != FINAL",
          "    new_id != old_id",
          "    trie.state(new_id).transitions.len() > 0",
          "    trie.state(new_id).transitions[0].range == transition_range",
          "    trie.state(new_id).transitions[0].next_id == FINAL",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "",
          "    // Create the first state",
          "    let old_id = trie.add_empty();",
          "    let transition1_next_id = StateID::new_unchecked(2); // not FINAL",
          "    let transition2_next_id = StateID::new_unchecked(3); // not FINAL",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition1_next_id);",
          "    trie.add_transition(old_id, Utf8Range::from(128..=255), transition2_next_id);",
          "",
          "    // Both transitions lead to FINAL",
          "    trie.add_transition(transition1_next_id, Utf8Range::from(0..=255), FINAL);",
          "    trie.add_transition(transition2_next_id, Utf8Range::from(0..=255), FINAL);",
          "",
          "    // Call duplicate",
          "    let new_id = trie.duplicate(old_id);",
          "}"
        ],
        "oracle": [
          "    let mut trie = RangeTrie::new();",
          "    let old_id = trie.add_empty();",
          "    let transition1_next_id = StateID::new_unchecked(2);",
          "    let transition2_next_id = StateID::new_unchecked(3);",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition1_next_id);",
          "    trie.add_transition(old_id, Utf8Range::from(128..=255), transition2_next_id);",
          "    trie.add_transition(transition1_next_id, Utf8Range::from(0..=255), FINAL);",
          "    trie.add_transition(transition2_next_id, Utf8Range::from(0..=255), FINAL);",
          "    let new_id = trie.duplicate(old_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != old_id);",
          "    let new_state = trie.state(new_id);",
          "    assert_eq!(new_state.transitions.len(), 2);",
          "    assert_eq!(new_state.transitions[0].range, Utf8Range::from(0..=127));",
          "    assert_eq!(new_state.transitions[1].range, Utf8Range::from(128..=255));",
          "    let old_state = trie.state(old_id);",
          "    assert_eq!(old_state.transitions.len(), 2);",
          "    assert!(old_state.transitions[0].next_id == FINAL);",
          "    assert!(old_state.transitions[1].next_id == FINAL);"
        ],
        "code": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "",
          "    // Create the first state",
          "    let old_id = trie.add_empty();",
          "    let transition1_next_id = StateID::new_unchecked(2); // not FINAL",
          "    let transition2_next_id = StateID::new_unchecked(3); // not FINAL",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition1_next_id);",
          "    trie.add_transition(old_id, Utf8Range::from(128..=255), transition2_next_id);",
          "",
          "    // Both transitions lead to FINAL",
          "    trie.add_transition(transition1_next_id, Utf8Range::from(0..=255), FINAL);",
          "    trie.add_transition(transition2_next_id, Utf8Range::from(0..=255), FINAL);",
          "",
          "    // Call duplicate",
          "    let new_id = trie.duplicate(old_id);",
          "    let mut trie = RangeTrie::new();",
          "    let old_id = trie.add_empty();",
          "    let transition1_next_id = StateID::new_unchecked(2);",
          "    let transition2_next_id = StateID::new_unchecked(3);",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition1_next_id);",
          "    trie.add_transition(old_id, Utf8Range::from(128..=255), transition2_next_id);",
          "    trie.add_transition(transition1_next_id, Utf8Range::from(0..=255), FINAL);",
          "    trie.add_transition(transition2_next_id, Utf8Range::from(0..=255), FINAL);",
          "    let new_id = trie.duplicate(old_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(new_id != old_id);",
          "    let new_state = trie.state(new_id);",
          "    assert_eq!(new_state.transitions.len(), 2);",
          "    assert_eq!(new_state.transitions[0].range, Utf8Range::from(0..=127));",
          "    assert_eq!(new_state.transitions[1].range, Utf8Range::from(128..=255));",
          "    let old_state = trie.state(old_id);",
          "    assert_eq!(old_state.transitions.len(), 2);",
          "    assert!(old_state.transitions[0].next_id == FINAL);",
          "    assert!(old_state.transitions[1].next_id == FINAL);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "",
          "    // Add a state and several transitions",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id1 = StateID::new_unchecked(2);",
          "    let transition_next_id2 = StateID::new_unchecked(3); // not FINAL",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id1);",
          "    trie.add_transition(transition_next_id1, Utf8Range::from(128..=255), transition_next_id2);",
          "",
          "    // Set transition that leads to FINAL for second state",
          "    trie.add_transition(transition_next_id2, Utf8Range::from(0..=255), FINAL);",
          "",
          "    // Duplicate the old state",
          "    let new_id = trie.duplicate(old_id);",
          "}"
        ],
        "oracle": [
          "    let mut trie = RangeTrie::new();",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id1 = StateID::new_unchecked(2);",
          "    let transition_next_id2 = StateID::new_unchecked(3);",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id1);",
          "    trie.add_transition(transition_next_id1, Utf8Range::from(128..=255), transition_next_id2);",
          "    trie.add_transition(transition_next_id2, Utf8Range::from(0..=255), FINAL);",
          "    let new_id = trie.duplicate(old_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(trie.state(new_id).transitions.len() > 0);",
          "    assert!(trie.state(new_id).transitions.iter().any(|t| t.next_id != FINAL));",
          "    assert_eq!(trie.state(old_id).transitions.len(), trie.state(new_id).transitions.len());",
          "    for t in &trie.state(old_id).transitions {",
          "    assert!(trie.state(new_id).transitions.iter().any(|new_t| new_t.range == t.range));",
          "    }"
        ],
        "code": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "",
          "    // Add a state and several transitions",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id1 = StateID::new_unchecked(2);",
          "    let transition_next_id2 = StateID::new_unchecked(3); // not FINAL",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id1);",
          "    trie.add_transition(transition_next_id1, Utf8Range::from(128..=255), transition_next_id2);",
          "",
          "    // Set transition that leads to FINAL for second state",
          "    trie.add_transition(transition_next_id2, Utf8Range::from(0..=255), FINAL);",
          "",
          "    // Duplicate the old state",
          "    let new_id = trie.duplicate(old_id);",
          "    let mut trie = RangeTrie::new();",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id1 = StateID::new_unchecked(2);",
          "    let transition_next_id2 = StateID::new_unchecked(3);",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id1);",
          "    trie.add_transition(transition_next_id1, Utf8Range::from(128..=255), transition_next_id2);",
          "    trie.add_transition(transition_next_id2, Utf8Range::from(0..=255), FINAL);",
          "    let new_id = trie.duplicate(old_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(trie.state(new_id).transitions.len() > 0);",
          "    assert!(trie.state(new_id).transitions.iter().any(|t| t.next_id != FINAL));",
          "    assert_eq!(trie.state(old_id).transitions.len(), trie.state(new_id).transitions.len());",
          "    for t in &trie.state(old_id).transitions {",
          "    assert!(trie.state(new_id).transitions.iter().any(|new_t| new_t.range == t.range));",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Add states and ensure some transitions lead to FINAL",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id = StateID::new_unchecked(2); // not FINAL",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id);",
          "    trie.add_transition(transition_next_id, Utf8Range::from(128..=255), FINAL);",
          "",
          "    // Call duplicate",
          "    let new_id = trie.duplicate(old_id);",
          "}"
        ],
        "oracle": [
          "    let mut trie = RangeTrie::new();",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id = StateID::new_unchecked(2);",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id);",
          "    trie.add_transition(transition_next_id, Utf8Range::from(128..=255), FINAL);",
          "    let new_id = trie.duplicate(old_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(trie.state(new_id).transitions.len() > 0);",
          "    assert!(trie.state(new_id).transitions[0].next_id != FINAL);",
          "    assert!(trie.state(old_id).transitions[0].next_id == transition_next_id);",
          "    assert!(trie.state(new_id).transitions[0].range == trie.state(old_id).transitions[0].range);",
          "    assert!(trie.state(new_id).transitions[0].next_id != old_id);",
          "    assert!(trie.state(new_id).transitions[0].next_id != transition_next_id);",
          "    assert!(trie.state(new_id).transitions[1].next_id == FINAL);",
          "    assert!(trie.state(new_id).transitions[1].range == Utf8Range::from(128..=255));"
        ],
        "code": [
          "{",
          "    let mut trie = RangeTrie::new();",
          "    ",
          "    // Add states and ensure some transitions lead to FINAL",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id = StateID::new_unchecked(2); // not FINAL",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id);",
          "    trie.add_transition(transition_next_id, Utf8Range::from(128..=255), FINAL);",
          "",
          "    // Call duplicate",
          "    let new_id = trie.duplicate(old_id);",
          "    let mut trie = RangeTrie::new();",
          "    let old_id = trie.add_empty();",
          "    let transition_next_id = StateID::new_unchecked(2);",
          "    trie.add_transition(old_id, Utf8Range::from(0..=127), transition_next_id);",
          "    trie.add_transition(transition_next_id, Utf8Range::from(128..=255), FINAL);",
          "    let new_id = trie.duplicate(old_id);",
          "    assert!(new_id != FINAL);",
          "    assert!(trie.state(new_id).transitions.len() > 0);",
          "    assert!(trie.state(new_id).transitions[0].next_id != FINAL);",
          "    assert!(trie.state(old_id).transitions[0].next_id == transition_next_id);",
          "    assert!(trie.state(new_id).transitions[0].range == trie.state(old_id).transitions[0].range);",
          "    assert!(trie.state(new_id).transitions[0].next_id != old_id);",
          "    assert!(trie.state(new_id).transitions[0].next_id != transition_next_id);",
          "    assert!(trie.state(new_id).transitions[1].next_id == FINAL);",
          "    assert!(trie.state(new_id).transitions[1].range == Utf8Range::from(128..=255));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]