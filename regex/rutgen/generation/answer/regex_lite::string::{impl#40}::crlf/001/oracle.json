[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"^foo$\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"\\r\\nfoo\\r\\n\";",
          "    re.find(hay);",
          "}"
        ],
        "oracle": [
          "    builder.crlf(true);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    builder.crlf(false);",
          "    assert_eq!(builder.hir_config.flags.crlf, false);",
          "    let mut builder = RegexBuilder::new(r\"^foo$\").multi_line(true).crlf(true);",
          "    let re = builder.build().unwrap();",
          "    let result = re.find(\"\\r\\nfoo\\r\\n\").map(|m| m.as_str());",
          "    assert_eq!(result, Some(\"foo\"));",
          "    let ranges: Vec<_> = re.find_iter(\"\\r\\n\\r\\n\").map(|m| m.range()).collect();",
          "    assert_eq!(ranges, vec![0..0, 2..2, 4..4]);"
        ],
        "code": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"^foo$\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"\\r\\nfoo\\r\\n\";",
          "    re.find(hay);",
          "    builder.crlf(true);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    builder.crlf(false);",
          "    assert_eq!(builder.hir_config.flags.crlf, false);",
          "    let mut builder = RegexBuilder::new(r\"^foo$\").multi_line(true).crlf(true);",
          "    let re = builder.build().unwrap();",
          "    let result = re.find(\"\\r\\nfoo\\r\\n\").map(|m| m.as_str());",
          "    assert_eq!(result, Some(\"foo\"));",
          "    let ranges: Vec<_> = re.find_iter(\"\\r\\n\\r\\n\").map(|m| m.range()).collect();",
          "    assert_eq!(ranges, vec![0..0, 2..2, 4..4]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"^foo$\");",
          "    let re = builder.multi_line(true).crlf(false).build().unwrap();",
          "    let hay = \"\\r\\nfoo\\r\\n\";",
          "    re.find(hay);",
          "}"
        ],
        "oracle": [
          "    builder.crlf(false);",
          "    assert_eq!(builder.hir_config.flags.crlf, false);",
          "    let re = builder.build().expect(\"Failed to build regex\");",
          "    assert!(re.find(hay).is_none());",
          "    builder.crlf(true);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    let re = builder.build().expect(\"Failed to build regex\");",
          "    assert_eq!(Some(\"foo\"), re.find(hay).map(|m| m.as_str()));"
        ],
        "code": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"^foo$\");",
          "    let re = builder.multi_line(true).crlf(false).build().unwrap();",
          "    let hay = \"\\r\\nfoo\\r\\n\";",
          "    re.find(hay);",
          "    builder.crlf(false);",
          "    assert_eq!(builder.hir_config.flags.crlf, false);",
          "    let re = builder.build().expect(\"Failed to build regex\");",
          "    assert!(re.find(hay).is_none());",
          "    builder.crlf(true);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    let re = builder.build().expect(\"Failed to build regex\");",
          "    assert_eq!(Some(\"foo\"), re.find(hay).map(|m| m.as_str()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"\\r\\n\\r\\n\";",
          "    re.find(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    assert_eq!(builder.hir_config.flags.multi_line, true);",
          "    assert_eq!(builder.nfa_config.size_limit, None);",
          "    assert_eq!(builder.nest_limit, 0);",
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).unwrap().range(), 0..0);",
          "    assert_eq!(re.find(hay).unwrap().range(), 2..2);",
          "    assert_eq!(re.find(hay).unwrap().range(), 4..4);"
        ],
        "code": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"\\r\\n\\r\\n\";",
          "    re.find(hay);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    assert_eq!(builder.hir_config.flags.multi_line, true);",
          "    assert_eq!(builder.nfa_config.size_limit, None);",
          "    assert_eq!(builder.nest_limit, 0);",
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).unwrap().range(), 0..0);",
          "    assert_eq!(re.find(hay).unwrap().range(), 2..2);",
          "    assert_eq!(re.find(hay).unwrap().range(), 4..4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"^\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"\\r\\nabc\";",
          "    re.find(hay);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    assert_eq!(builder.hir_config.flags.multi_line, true);",
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).map(|m| m.as_str()), Some(\"abc\"));",
          "    assert_eq!(re.find(\"\\r\\n\"), Some(\"\"));",
          "    assert_eq!(re.find(\"\\n\"), Some(\"\"));",
          "    assert_eq!(re.find(\"\\r\"), Some(\"\"));"
        ],
        "code": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"^\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"\\r\\nabc\";",
          "    re.find(hay);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    assert_eq!(builder.hir_config.flags.multi_line, true);",
          "    assert!(re.find(hay).is_some());",
          "    assert_eq!(re.find(hay).map(|m| m.as_str()), Some(\"abc\"));",
          "    assert_eq!(re.find(\"\\r\\n\"), Some(\"\"));",
          "    assert_eq!(re.find(\"\\n\"), Some(\"\"));",
          "    assert_eq!(re.find(\"\\r\"), Some(\"\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"$\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"abc\\r\\n\";",
          "    re.find(hay);",
          "}"
        ],
        "oracle": [
          "    builder.crlf(true);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    builder.crlf(false);",
          "    assert_eq!(builder.hir_config.flags.crlf, false);",
          "    let re = builder.multi_line(true).build().unwrap();",
          "    let hay = \"\\r\\nabc\\r\\n\";",
          "    assert_eq!(Some(\"\"), re.find(hay).map(|m| m.as_str()));",
          "    let re_crlf = RegexBuilder::new(r\"^foo$\").multi_line(true).crlf(true).build().unwrap();",
          "    let hay_crlf = \"\\r\\nfoo\\r\\n\";",
          "    assert_eq!(Some(\"foo\"), re_crlf.find(hay_crlf).map(|m| m.as_str()));",
          "    let re_no_crlf = RegexBuilder::new(r\"^foo$\").multi_line(true).crlf(false).build().unwrap();",
          "    let hay_no_crlf = \"\\r\\nfoo\\r\\n\";",
          "    assert_eq!(None, re_no_crlf.find(hay_no_crlf));",
          "    let re_iter = RegexBuilder::new(r\"^\").multi_line(true).crlf(true).build().unwrap();",
          "    let hay_iter = \"\\r\\n\\r\\n\";",
          "    let ranges: Vec<_> = re_iter.find_iter(hay_iter).map(|m| m.range()).collect();",
          "    assert_eq!(ranges, vec![0..0, 2..2, 4..4]);"
        ],
        "code": [
          "{",
          "    let mut builder = RegexBuilder::new(r\"$\");",
          "    let re = builder.multi_line(true).crlf(true).build().unwrap();",
          "    let hay = \"abc\\r\\n\";",
          "    re.find(hay);",
          "    builder.crlf(true);",
          "    assert_eq!(builder.hir_config.flags.crlf, true);",
          "    builder.crlf(false);",
          "    assert_eq!(builder.hir_config.flags.crlf, false);",
          "    let re = builder.multi_line(true).build().unwrap();",
          "    let hay = \"\\r\\nabc\\r\\n\";",
          "    assert_eq!(Some(\"\"), re.find(hay).map(|m| m.as_str()));",
          "    let re_crlf = RegexBuilder::new(r\"^foo$\").multi_line(true).crlf(true).build().unwrap();",
          "    let hay_crlf = \"\\r\\nfoo\\r\\n\";",
          "    assert_eq!(Some(\"foo\"), re_crlf.find(hay_crlf).map(|m| m.as_str()));",
          "    let re_no_crlf = RegexBuilder::new(r\"^foo$\").multi_line(true).crlf(false).build().unwrap();",
          "    let hay_no_crlf = \"\\r\\nfoo\\r\\n\";",
          "    assert_eq!(None, re_no_crlf.find(hay_no_crlf));",
          "    let re_iter = RegexBuilder::new(r\"^\").multi_line(true).crlf(true).build().unwrap();",
          "    let hay_iter = \"\\r\\n\\r\\n\";",
          "    let ranges: Vec<_> = re_iter.find_iter(hay_iter).map(|m| m.range()).collect();",
          "    assert_eq!(ranges, vec![0..0, 2..2, 4..4]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]