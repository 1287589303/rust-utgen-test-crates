[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::exact(Vec::<u8>::new());",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(length, 0);",
          "    lit = Literal::exact(vec![1, 2, 3]);",
          "    length = lit.len();",
          "    assert_eq!(length, 3);",
          "    lit = Literal::exact(vec![42]);",
          "    length = lit.len();",
          "    assert_eq!(length, 1);"
        ],
        "code": [
          "{",
          "    let lit = Literal::exact(Vec::<u8>::new());",
          "    let length = lit.len();",
          "    assert_eq!(length, 0);",
          "    lit = Literal::exact(vec![1, 2, 3]);",
          "    length = lit.len();",
          "    assert_eq!(length, 3);",
          "    lit = Literal::exact(vec![42]);",
          "    length = lit.len();",
          "    assert_eq!(length, 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::inexact(Vec::<u8>::new());",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lit.len(), 0);",
          "    let lit = Literal::inexact(vec![1, 2, 3]);",
          "    assert_eq!(lit.len(), 3);",
          "    let lit = Literal::exact(vec![1, 2, 3, 4]);",
          "    assert_eq!(lit.len(), 4);",
          "    let lit = Literal::exact(vec![]);",
          "    assert_eq!(lit.len(), 0);",
          "    let lit = Literal::inexact(vec![b'a', b'b', b'c']);",
          "    assert_eq!(lit.len(), 3);",
          "    let lit = Literal::inexact(vec![b'x', b'y']);",
          "    assert_eq!(lit.len(), 2);",
          "    let lit = Literal::exact(vec![b'a']);",
          "    assert_eq!(lit.len(), 1);"
        ],
        "code": [
          "{",
          "    let lit = Literal::inexact(Vec::<u8>::new());",
          "    let length = lit.len();",
          "    assert_eq!(lit.len(), 0);",
          "    let lit = Literal::inexact(vec![1, 2, 3]);",
          "    assert_eq!(lit.len(), 3);",
          "    let lit = Literal::exact(vec![1, 2, 3, 4]);",
          "    assert_eq!(lit.len(), 4);",
          "    let lit = Literal::exact(vec![]);",
          "    assert_eq!(lit.len(), 0);",
          "    let lit = Literal::inexact(vec![b'a', b'b', b'c']);",
          "    assert_eq!(lit.len(), 3);",
          "    let lit = Literal::inexact(vec![b'x', b'y']);",
          "    assert_eq!(lit.len(), 2);",
          "    let lit = Literal::exact(vec![b'a']);",
          "    assert_eq!(lit.len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::exact(vec![1, 2, 3]);",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(length, 3);",
          "    assert_eq!(lit.len(), lit.as_bytes().len());",
          "    assert!(lit.len() > 0);",
          "    let empty_lit = Literal::exact(vec![]);",
          "    assert_eq!(empty_lit.len(), 0);",
          "    let inexact_lit = Literal::inexact(vec![1, 2, 3, 4, 5]);",
          "    assert_eq!(inexact_lit.len(), 5);"
        ],
        "code": [
          "{",
          "    let lit = Literal::exact(vec![1, 2, 3]);",
          "    let length = lit.len();",
          "    assert_eq!(length, 3);",
          "    assert_eq!(lit.len(), lit.as_bytes().len());",
          "    assert!(lit.len() > 0);",
          "    let empty_lit = Literal::exact(vec![]);",
          "    assert_eq!(empty_lit.len(), 0);",
          "    let inexact_lit = Literal::inexact(vec![1, 2, 3, 4, 5]);",
          "    assert_eq!(inexact_lit.len(), 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::inexact(vec![4, 5, 6]);",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(length, 3);"
        ],
        "code": [
          "{",
          "    let lit = Literal::inexact(vec![4, 5, 6]);",
          "    let length = lit.len();",
          "    assert_eq!(length, 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::exact(vec![0; 1000]);",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(length, 1000);"
        ],
        "code": [
          "{",
          "    let lit = Literal::exact(vec![0; 1000]);",
          "    let length = lit.len();",
          "    assert_eq!(length, 1000);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::inexact(vec![0; 1000]);",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(length, 1000);",
          "    assert!(lit.len() > 0);",
          "    assert!(!lit.is_empty());",
          "    assert_eq!(lit.as_bytes().len(), length);"
        ],
        "code": [
          "{",
          "    let lit = Literal::inexact(vec![0; 1000]);",
          "    let length = lit.len();",
          "    assert_eq!(length, 1000);",
          "    assert!(lit.len() > 0);",
          "    assert!(!lit.is_empty());",
          "    assert_eq!(lit.as_bytes().len(), length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::exact(vec![255; 1000]);",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(length, 1000);",
          "    assert!(length > 0);",
          "    assert!(lit.is_empty() == false);",
          "    assert!(lit.is_exact() == true);",
          "    assert_eq!(lit.len(), lit.as_bytes().len());"
        ],
        "code": [
          "{",
          "    let lit = Literal::exact(vec![255; 1000]);",
          "    let length = lit.len();",
          "    assert_eq!(length, 1000);",
          "    assert!(length > 0);",
          "    assert!(lit.is_empty() == false);",
          "    assert!(lit.is_exact() == true);",
          "    assert_eq!(lit.len(), lit.as_bytes().len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lit = Literal::inexact(vec![255; 1000]);",
          "    let length = lit.len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(length, 1000);",
          "    assert!(lit.len() > 0);",
          "    assert!(!lit.is_empty());",
          "    lit.keep_last_bytes(500);",
          "    assert_eq!(lit.len(), 500);",
          "    lit.keep_first_bytes(250);",
          "    assert_eq!(lit.len(), 250);",
          "    lit.make_inexact();",
          "    assert!(lit.is_inexact());"
        ],
        "code": [
          "{",
          "    let lit = Literal::inexact(vec![255; 1000]);",
          "    let length = lit.len();",
          "    assert_eq!(length, 1000);",
          "    assert!(lit.len() > 0);",
          "    assert!(!lit.is_empty());",
          "    lit.keep_last_bytes(500);",
          "    assert_eq!(lit.len(), 500);",
          "    lit.keep_first_bytes(250);",
          "    assert_eq!(lit.len(), 250);",
          "    lit.make_inexact();",
          "    assert!(lit.is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]