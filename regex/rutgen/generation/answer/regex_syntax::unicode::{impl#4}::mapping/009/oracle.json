[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[",
          "        ('a', &['A']),",
          "        ('b', &['B']),",
          "        ('c', &['C']),",
          "        ('d', &['D']),",
          "        ('e', &['E']),",
          "    ];",
          "",
          "    let mut folder = SimpleCaseFolder {",
          "        table,",
          "        last: Some('a'),",
          "        next: 2, // point to the third entry",
          "    };",
          "",
          "    let c: char = 'd'; // 'd' is the next character, should match 'd' in the table.",
          "    let result = folder.mapping(c);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, &['D']);",
          "    assert!(folder.last == Some('d'));",
          "    assert!(folder.next == 3);",
          "    assert!(folder.table.len() == 5);",
          "    assert!(folder.get('d').is_ok());"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[",
          "        ('a', &['A']),",
          "        ('b', &['B']),",
          "        ('c', &['C']),",
          "        ('d', &['D']),",
          "        ('e', &['E']),",
          "    ];",
          "",
          "    let mut folder = SimpleCaseFolder {",
          "        table,",
          "        last: Some('a'),",
          "        next: 2, // point to the third entry",
          "    };",
          "",
          "    let c: char = 'd'; // 'd' is the next character, should match 'd' in the table.",
          "    let result = folder.mapping(c);",
          "    assert_eq!(result, &['D']);",
          "    assert!(folder.last == Some('d'));",
          "    assert!(folder.next == 3);",
          "    assert!(folder.table.len() == 5);",
          "    assert!(folder.get('d').is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[",
          "        ('a', &['A']),",
          "        ('b', &['B']),",
          "        ('c', &['C']),",
          "        ('e', &['E']),",
          "        ('f', &['F']),",
          "    ];",
          "",
          "    let mut folder = SimpleCaseFolder {",
          "        table,",
          "        last: Some('a'),",
          "        next: 2, // point to the third entry",
          "    };",
          "",
          "    let c: char = 'f'; // 'f' is beyond 'e' and not at table index 2.",
          "    let result = folder.mapping(c);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, &['F']);",
          "    assert_eq!(folder.last, Some('f'));",
          "    assert_eq!(folder.next, 5);",
          "    assert!(folder.get('f').is_ok());",
          "    assert!(folder.get('f').unwrap() > 2);",
          "    assert_eq!(folder.get('z').is_err(), true);",
          "    assert_eq!(folder.mapping('d'), &[]);",
          "    assert!(folder.mapping('g').is_empty());",
          "    assert!(folder.next, 5);"
        ],
        "code": [
          "{",
          "    let table: &'static [(char, &'static [char])] = &[",
          "        ('a', &['A']),",
          "        ('b', &['B']),",
          "        ('c', &['C']),",
          "        ('e', &['E']),",
          "        ('f', &['F']),",
          "    ];",
          "",
          "    let mut folder = SimpleCaseFolder {",
          "        table,",
          "        last: Some('a'),",
          "        next: 2, // point to the third entry",
          "    };",
          "",
          "    let c: char = 'f'; // 'f' is beyond 'e' and not at table index 2.",
          "    let result = folder.mapping(c);",
          "    assert_eq!(result, &['F']);",
          "    assert_eq!(folder.last, Some('f'));",
          "    assert_eq!(folder.next, 5);",
          "    assert!(folder.get('f').is_ok());",
          "    assert!(folder.get('f').unwrap() > 2);",
          "    assert_eq!(folder.get('z').is_err(), true);",
          "    assert_eq!(folder.mapping('d'), &[]);",
          "    assert!(folder.mapping('g').is_empty());",
          "    assert!(folder.next, 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]