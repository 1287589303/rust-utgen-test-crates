[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"(a)\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 0, name: None, sub: Box::new(DummyHir { kind: HirKind::Char('a') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(1, None, &hir);",
          "}"
        ],
        "oracle": [
          "    let pres = _ in 0..(1.as_usize().saturating_sub(0)) is true;",
          "    let pres = _ in 0..(1.as_usize().saturating_sub(0)) is false;",
          "    let pres = 1.as_usize() >= 0 is false;",
          "    let pres = compiler.add(State::Capture { target: 0, slot: 2 }) is Ok(Some);",
          "    let pres = compiler.c(&hir) is Ok(Some);",
          "    let pres = compiler.add(State::Capture { target: 0, slot: 3 }) is Ok(Some);",
          "    let pres = compiler.patch(start, inner.start) is Ok(Some);",
          "    let pres = compiler.patch(inner.end, end) is Ok(Some);",
          "    let expected = Ok(ThompsonRef { start, end });"
        ],
        "code": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"(a)\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 0, name: None, sub: Box::new(DummyHir { kind: HirKind::Char('a') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(1, None, &hir);",
          "    let pres = _ in 0..(1.as_usize().saturating_sub(0)) is true;",
          "    let pres = _ in 0..(1.as_usize().saturating_sub(0)) is false;",
          "    let pres = 1.as_usize() >= 0 is false;",
          "    let pres = compiler.add(State::Capture { target: 0, slot: 2 }) is Ok(Some);",
          "    let pres = compiler.c(&hir) is Ok(Some);",
          "    let pres = compiler.add(State::Capture { target: 0, slot: 3 }) is Ok(Some);",
          "    let pres = compiler.patch(start, inner.start) is Ok(Some);",
          "    let pres = compiler.patch(inner.end, end) is Ok(Some);",
          "    let expected = Ok(ThompsonRef { start, end });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"(a)(b)\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 0, name: Some(\"group_name\"), sub: Box::new(DummyHir { kind: HirKind::Char('a') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(1, Some(\"group_name\"), &hir);",
          "}"
        ],
        "oracle": [
          "    let existing_groups_len = compiler.nfa.borrow().cap_index_to_name.len();",
          "    assert!(1 > existing_groups_len);",
          "    let _ = compiler.nfa.borrow_mut().cap_index_to_name.push(None); // line 546",
          "    ",
          "    assert!(1 >= existing_groups_len); // line 548",
          "    assert!(compiler.add(State::Capture { target: 0, slot: 2 }).is_ok()); // line 564",
          "    assert!(compiler.c(&hir).is_ok()); // line 565",
          "    assert!(compiler.add(State::Capture { target: 0, slot: 3 }).is_ok()); // line 569",
          "    let start = compiler.add(State::Capture { target: 0, slot: 2 }).unwrap();",
          "    let inner = compiler.c(&hir).unwrap();",
          "    let end = compiler.add(State::Capture { target: 0, slot: 3 }).unwrap();",
          "    assert!(compiler.patch(start, inner.start).is_ok()); // line 570",
          "    assert!(compiler.patch(inner.end, end).is_ok()); // line 571",
          "    let result = compiler.c_capture(1, Some(\"group_name\"), &hir);",
          "    assert_eq!(result, Ok(ThompsonRef { start, end })); // line 573"
        ],
        "code": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"(a)(b)\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 0, name: Some(\"group_name\"), sub: Box::new(DummyHir { kind: HirKind::Char('a') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(1, Some(\"group_name\"), &hir);",
          "    let existing_groups_len = compiler.nfa.borrow().cap_index_to_name.len();",
          "    assert!(1 > existing_groups_len);",
          "    let _ = compiler.nfa.borrow_mut().cap_index_to_name.push(None); // line 546",
          "    ",
          "    assert!(1 >= existing_groups_len); // line 548",
          "    assert!(compiler.add(State::Capture { target: 0, slot: 2 }).is_ok()); // line 564",
          "    assert!(compiler.c(&hir).is_ok()); // line 565",
          "    assert!(compiler.add(State::Capture { target: 0, slot: 3 }).is_ok()); // line 569",
          "    let start = compiler.add(State::Capture { target: 0, slot: 2 }).unwrap();",
          "    let inner = compiler.c(&hir).unwrap();",
          "    let end = compiler.add(State::Capture { target: 0, slot: 3 }).unwrap();",
          "    assert!(compiler.patch(start, inner.start).is_ok()); // line 570",
          "    assert!(compiler.patch(inner.end, end).is_ok()); // line 571",
          "    let result = compiler.c_capture(1, Some(\"group_name\"), &hir);",
          "    assert_eq!(result, Ok(ThompsonRef { start, end })); // line 573",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"(a)(b)?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 1, name: Some(\"group_name\"), sub: Box::new(DummyHir { kind: HirKind::Char('b') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(2, Some(\"group_name\"), &hir);",
          "}"
        ],
        "oracle": [
          "    let existing_groups_len = compiler.nfa.borrow().cap_index_to_name.len();",
          "    assert!(2 > existing_groups_len);",
          "    for _ in 0..(2 - existing_groups_len) {",
          "    compiler.nfa.borrow_mut().cap_index_to_name.push(None);",
          "    }",
          "    assert!(2 >= existing_groups_len);",
          "    let slot = 2.checked_mul(2).expect(\"capture group slots exhausted\");",
          "    let start = compiler.add(State::Capture { target: 0, slot }).unwrap();",
          "    let inner = compiler.c(&hir).unwrap();",
          "    let slot = slot.checked_add(1).expect(\"capture group slots exhausted\");",
          "    let end = compiler.add(State::Capture { target: 0, slot }).unwrap();",
          "    compiler.patch(start, inner.start).unwrap();",
          "    compiler.patch(inner.end, end).unwrap();",
          "    let result = Ok(ThompsonRef { start, end });",
          "    assert_eq!(compiler.c_capture(2, Some(\"group_name\"), &hir), result);"
        ],
        "code": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"(a)(b)?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 1, name: Some(\"group_name\"), sub: Box::new(DummyHir { kind: HirKind::Char('b') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(2, Some(\"group_name\"), &hir);",
          "    let existing_groups_len = compiler.nfa.borrow().cap_index_to_name.len();",
          "    assert!(2 > existing_groups_len);",
          "    for _ in 0..(2 - existing_groups_len) {",
          "    compiler.nfa.borrow_mut().cap_index_to_name.push(None);",
          "    }",
          "    assert!(2 >= existing_groups_len);",
          "    let slot = 2.checked_mul(2).expect(\"capture group slots exhausted\");",
          "    let start = compiler.add(State::Capture { target: 0, slot }).unwrap();",
          "    let inner = compiler.c(&hir).unwrap();",
          "    let slot = slot.checked_add(1).expect(\"capture group slots exhausted\");",
          "    let end = compiler.add(State::Capture { target: 0, slot }).unwrap();",
          "    compiler.patch(start, inner.start).unwrap();",
          "    compiler.patch(inner.end, end).unwrap();",
          "    let result = Ok(ThompsonRef { start, end });",
          "    assert_eq!(compiler.c_capture(2, Some(\"group_name\"), &hir), result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"a(b)?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 0, name: None, sub: Box::new(DummyHir { kind: HirKind::Char('b') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(0, None, &hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(compiler.nfa.borrow().cap_index_to_name.len(), existing_groups_len + 1);",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"b\")));",
          "    assert_eq!(compiler.nfa.borrow().cap_index_to_name.last(), Some(&Some(Arc::from(\"b\"))));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.get(0).is_none());",
          "    assert!(self.add(State::Capture { target: 0, slot }).is_ok());",
          "    assert!(self.c(&hir).is_ok());",
          "    assert!(self.add(State::Capture { target: 0, slot: slot + 1 }).is_ok());",
          "    assert!(self.patch(start, inner.start).is_ok());",
          "    assert!(self.patch(inner.end, end).is_ok());",
          "    assert!(compiler.c_capture(1, Some(\"b\"), &hir).is_ok());",
          "    assert!(compiler.c_capture(1, None, &hir).is_ok());",
          "    assert!(compiler.c_capture(2, Some(\"capture\"), &hir).is_ok());"
        ],
        "code": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"a(b)?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 0, name: None, sub: Box::new(DummyHir { kind: HirKind::Char('b') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(0, None, &hir);",
          "    assert_eq!(compiler.nfa.borrow().cap_index_to_name.len(), existing_groups_len + 1);",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"b\")));",
          "    assert_eq!(compiler.nfa.borrow().cap_index_to_name.last(), Some(&Some(Arc::from(\"b\"))));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.get(0).is_none());",
          "    assert!(self.add(State::Capture { target: 0, slot }).is_ok());",
          "    assert!(self.c(&hir).is_ok());",
          "    assert!(self.add(State::Capture { target: 0, slot: slot + 1 }).is_ok());",
          "    assert!(self.patch(start, inner.start).is_ok());",
          "    assert!(self.patch(inner.end, end).is_ok());",
          "    assert!(compiler.c_capture(1, Some(\"b\"), &hir).is_ok());",
          "    assert!(compiler.c_capture(1, None, &hir).is_ok());",
          "    assert!(compiler.c_capture(2, Some(\"capture\"), &hir).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"a(b)?(c)\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 1, name: Some(\"group_name\"), sub: Box::new(DummyHir { kind: HirKind::Char('c') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(3, Some(\"group_name\"), &hir);",
          "}"
        ],
        "oracle": [
          "    let existing_groups_len = compiler.nfa.borrow().cap_index_to_name.len();",
          "    for _ in 0..(3.as_usize().saturating_sub(existing_groups_len)) {",
          "    compiler.nfa.borrow_mut().cap_index_to_name.push(None);",
          "    }",
          "    assert_eq!(compiler.c_capture(3, Some(\"group_name\"), &hir), Ok(ThompsonRef { start: _, end: _ }));",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"group_name\")));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() >= 4);",
          "    assert!(compiler.nfa.borrow().memory_extra > 0);",
          "    let intermediate = compiler.c(&hir).expect(\"unexpected error\");",
          "    assert_eq!(compiler.add(State::Capture { target: 0, slot: 6 }), Ok(_));",
          "    assert_eq!(compiler.patch(intermediate.start, _), Ok(()));",
          "    assert_eq!(compiler.patch(_, intermediate.end), Ok(()));"
        ],
        "code": [
          "{",
          "    struct DummyHir {",
          "        kind: hir::HirKind,",
          "    }",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags::empty() };",
          "    let pattern = String::from(\"a(b)?(c)\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    ",
          "    let hir = Hir { kind: HirKind::Capture { index: 1, name: Some(\"group_name\"), sub: Box::new(DummyHir { kind: HirKind::Char('c') }) }, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    ",
          "    let _ = compiler.c_capture(3, Some(\"group_name\"), &hir);",
          "    let existing_groups_len = compiler.nfa.borrow().cap_index_to_name.len();",
          "    for _ in 0..(3.as_usize().saturating_sub(existing_groups_len)) {",
          "    compiler.nfa.borrow_mut().cap_index_to_name.push(None);",
          "    }",
          "    assert_eq!(compiler.c_capture(3, Some(\"group_name\"), &hir), Ok(ThompsonRef { start: _, end: _ }));",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"group_name\")));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() >= 4);",
          "    assert!(compiler.nfa.borrow().memory_extra > 0);",
          "    let intermediate = compiler.c(&hir).expect(\"unexpected error\");",
          "    assert_eq!(compiler.add(State::Capture { target: 0, slot: 6 }), Ok(_));",
          "    assert_eq!(compiler.patch(intermediate.start, _), Ok(()));",
          "    assert_eq!(compiler.patch(_, intermediate.end), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]