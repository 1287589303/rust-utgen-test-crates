[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = [0u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false }, 4)));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().1, 4);",
          "    assert_eq!(result.unwrap().0.has_empty, false);",
          "    assert_eq!(result.unwrap().0.is_utf8, false);",
          "    assert_eq!(result.unwrap().0.is_always_start_anchored, false);"
        ],
        "code": [
          "{",
          "    let slice = [0u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "    assert_eq!(result, Ok((Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false }, 4)));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().1, 4);",
          "    assert_eq!(result.unwrap().0.has_empty, false);",
          "    assert_eq!(result.unwrap().0.is_utf8, false);",
          "    assert_eq!(result.unwrap().0.is_always_start_anchored, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = [1u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((Flags { has_empty: true, is_utf8: false, is_always_start_anchored: false }, 4)));"
        ],
        "code": [
          "{",
          "    let slice = [1u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "    assert_eq!(result, Ok((Flags { has_empty: true, is_utf8: false, is_always_start_anchored: false }, 4)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = [3u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((Flags { has_empty: true, is_utf8: false, is_always_start_anchored: true }, 4)));"
        ],
        "code": [
          "{",
          "    let slice = [3u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "    assert_eq!(result, Ok((Flags { has_empty: true, is_utf8: false, is_always_start_anchored: true }, 4)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = [7u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (flags, nread) = result.unwrap();",
          "    assert_eq!(flags.has_empty, true);",
          "    assert_eq!(flags.is_utf8, false);",
          "    assert_eq!(flags.is_always_start_anchored, false);",
          "    assert_eq!(nread, 4);"
        ],
        "code": [
          "{",
          "    let slice = [7u8, 0u8, 0u8, 0u8];",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "    assert!(result.is_ok());",
          "    let (flags, nread) = result.unwrap();",
          "    assert_eq!(flags.has_empty, true);",
          "    assert_eq!(flags.is_utf8, false);",
          "    assert_eq!(flags.is_always_start_anchored, false);",
          "    assert_eq!(nread, 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice = [0u8, 0u8, 0u8, 0u8]; // testing with all bits off",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false }, 4)));"
        ],
        "code": [
          "{",
          "    let slice = [0u8, 0u8, 0u8, 0u8]; // testing with all bits off",
          "    let result = <Flags as Flags>::from_bytes(&slice);",
          "    assert_eq!(result, Ok((Flags { has_empty: false, is_utf8: false, is_always_start_anchored: false }, 4)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]