[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capacity = 10;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 1;",
          "",
          "    let transition = Transition { start: 0, end: 1, next: StateID(0) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![transition],",
          "        val: StateID(0),",
          "    });",
          "",
          "    if hash < map.map.len() {",
          "        let result = map.get(&[transition], hash);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let capacity = 10;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 1;",
          "    let transition = Transition { start: 0, end: 1, next: StateID(0) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry { version: 1, key: vec![transition], val: StateID(0) });",
          "    if hash < map.map.len() {",
          "    let result = map.get(&[transition], hash);",
          "    assert_eq!(result, Some(StateID(0)));",
          "    }"
        ],
        "code": [
          "{",
          "    let capacity = 10;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 1;",
          "",
          "    let transition = Transition { start: 0, end: 1, next: StateID(0) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![transition],",
          "        val: StateID(0),",
          "    });",
          "",
          "    if hash < map.map.len() {",
          "        let result = map.get(&[transition], hash);",
          "    }",
          "    let capacity = 10;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 1;",
          "    let transition = Transition { start: 0, end: 1, next: StateID(0) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry { version: 1, key: vec![transition], val: StateID(0) });",
          "    if hash < map.map.len() {",
          "    let result = map.get(&[transition], hash);",
          "    assert_eq!(result, Some(StateID(0)));",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capacity = 5;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 2;",
          "",
          "    let transition1 = Transition { start: 2, end: 3, next: StateID(1) };",
          "    let transition2 = Transition { start: 4, end: 5, next: StateID(1) };",
          "    let hash = map.hash(&[transition1, transition2]);",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 2,",
          "        key: vec![transition1, transition2],",
          "        val: StateID(1),",
          "    });",
          "",
          "    if hash < map.map.len() {",
          "        let result = map.get(&[transition1, transition2], hash);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let capacity = 5;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 2;",
          "    let transition1 = Transition { start: 2, end: 3, next: StateID(1) };",
          "    let transition2 = Transition { start: 4, end: 5, next: StateID(1) };",
          "    let hash = map.hash(&[transition1, transition2]);",
          "    map.map.push(Utf8BoundedEntry { version: 2, key: vec![transition1, transition2], val: StateID(1) });",
          "    if hash < map.map.len() {",
          "    let result = map.get(&[transition1, transition2], hash);",
          "    assert_eq!(result, Some(StateID(1)));",
          "    }"
        ],
        "code": [
          "{",
          "    let capacity = 5;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 2;",
          "",
          "    let transition1 = Transition { start: 2, end: 3, next: StateID(1) };",
          "    let transition2 = Transition { start: 4, end: 5, next: StateID(1) };",
          "    let hash = map.hash(&[transition1, transition2]);",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 2,",
          "        key: vec![transition1, transition2],",
          "        val: StateID(1),",
          "    });",
          "",
          "    if hash < map.map.len() {",
          "        let result = map.get(&[transition1, transition2], hash);",
          "    }",
          "    let capacity = 5;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 2;",
          "    let transition1 = Transition { start: 2, end: 3, next: StateID(1) };",
          "    let transition2 = Transition { start: 4, end: 5, next: StateID(1) };",
          "    let hash = map.hash(&[transition1, transition2]);",
          "    map.map.push(Utf8BoundedEntry { version: 2, key: vec![transition1, transition2], val: StateID(1) });",
          "    if hash < map.map.len() {",
          "    let result = map.get(&[transition1, transition2], hash);",
          "    assert_eq!(result, Some(StateID(1)));",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capacity = 8;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 3;",
          "",
          "    let transition = Transition { start: 0, end: 255, next: StateID(2) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 3,",
          "        key: vec![transition],",
          "        val: StateID(2),",
          "    });",
          "",
          "    if hash < map.map.len() {",
          "        let result = map.get(&[transition], hash);",
          "    }",
          "}"
        ],
        "oracle": [
          "    let capacity = 8;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 3;",
          "    let transition = Transition { start: 0, end: 255, next: StateID(2) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry { version: 3, key: vec![transition], val: StateID(2) });",
          "    assert!(hash < map.map.len());",
          "    let result = map.get(&[transition], hash);",
          "    assert_eq!(result, Some(StateID(2)));"
        ],
        "code": [
          "{",
          "    let capacity = 8;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 3;",
          "",
          "    let transition = Transition { start: 0, end: 255, next: StateID(2) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 3,",
          "        key: vec![transition],",
          "        val: StateID(2),",
          "    });",
          "",
          "    if hash < map.map.len() {",
          "        let result = map.get(&[transition], hash);",
          "    }",
          "    let capacity = 8;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    map.version = 3;",
          "    let transition = Transition { start: 0, end: 255, next: StateID(2) };",
          "    let hash = map.hash(&[transition]);",
          "    map.map.push(Utf8BoundedEntry { version: 3, key: vec![transition], val: StateID(2) });",
          "    assert!(hash < map.map.len());",
          "    let result = map.get(&[transition], hash);",
          "    assert_eq!(result, Some(StateID(2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]