[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(5);",
          "    map.version = 1;",
          "    map.capacity = 5;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 0, end: 1, next: StateID(0) }],",
          "        val: StateID(1),",
          "    });",
          "    let key = vec![Transition { start: 2, end: 3, next: StateID(2) }];",
          "    let hash = 0;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "}"
        ],
        "oracle": [
          "    let mut map = Utf8BoundedMap::new(5);",
          "    map.version = 1;",
          "    map.capacity = 5;",
          "    map.map.push(Utf8BoundedEntry {",
          "    version: 1,",
          "    key: vec![Transition { start: 0, end: 1, next: StateID(0) }],",
          "    val: StateID(1),",
          "    });",
          "    let key = vec![Transition { start: 2, end: 3, next: StateID(2) }];",
          "    let hash = 0;",
          "    ",
          "    let result = map.get(&key, hash);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(5);",
          "    map.version = 1;",
          "    map.capacity = 5;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 0, end: 1, next: StateID(0) }],",
          "        val: StateID(1),",
          "    });",
          "    let key = vec![Transition { start: 2, end: 3, next: StateID(2) }];",
          "    let hash = 0;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "    let mut map = Utf8BoundedMap::new(5);",
          "    map.version = 1;",
          "    map.capacity = 5;",
          "    map.map.push(Utf8BoundedEntry {",
          "    version: 1,",
          "    key: vec![Transition { start: 0, end: 1, next: StateID(0) }],",
          "    val: StateID(1),",
          "    });",
          "    let key = vec![Transition { start: 2, end: 3, next: StateID(2) }];",
          "    let hash = 0;",
          "    ",
          "    let result = map.get(&key, hash);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(3);",
          "    map.version = 2;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 4, end: 5, next: StateID(3) }],",
          "        val: StateID(4),",
          "    });",
          "    let key = vec![Transition { start: 6, end: 7, next: StateID(5) }];",
          "    let hash = 0;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "}"
        ],
        "oracle": [
          "    let mut map = Utf8BoundedMap::new(3);",
          "    map.version = 2;",
          "    map.map.push(Utf8BoundedEntry {",
          "    version: 1,",
          "    key: vec![Transition { start: 4, end: 5, next: StateID(3) }],",
          "    val: StateID(4),",
          "    });",
          "    let key = vec![Transition { start: 6, end: 7, next: StateID(5) }];",
          "    let hash = 0;",
          "    ",
          "    let result = map.get(&key, hash);",
          "    assert!(result.is_none());"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(3);",
          "    map.version = 2;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 4, end: 5, next: StateID(3) }],",
          "        val: StateID(4),",
          "    });",
          "    let key = vec![Transition { start: 6, end: 7, next: StateID(5) }];",
          "    let hash = 0;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "    let mut map = Utf8BoundedMap::new(3);",
          "    map.version = 2;",
          "    map.map.push(Utf8BoundedEntry {",
          "    version: 1,",
          "    key: vec![Transition { start: 4, end: 5, next: StateID(3) }],",
          "    val: StateID(4),",
          "    });",
          "    let key = vec![Transition { start: 6, end: 7, next: StateID(5) }];",
          "    let hash = 0;",
          "    ",
          "    let result = map.get(&key, hash);",
          "    assert!(result.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(2);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 8, end: 9, next: StateID(6) }],",
          "        val: StateID(7),",
          "    });",
          "    let key: Vec<Transition> = Vec::new();",
          "    let hash = 0;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "}"
        ],
        "oracle": [
          "    let mut map = Utf8BoundedMap::new(2);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry {",
          "    version: 1,",
          "    key: vec![Transition { start: 8, end: 9, next: StateID(6) }],",
          "    val: StateID(7),",
          "    });",
          "    let key: Vec<Transition> = Vec::new();",
          "    let hash = 0;",
          "    let result = map.get(&key, hash);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(2);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 8, end: 9, next: StateID(6) }],",
          "        val: StateID(7),",
          "    });",
          "    let key: Vec<Transition> = Vec::new();",
          "    let hash = 0;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "    let mut map = Utf8BoundedMap::new(2);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry {",
          "    version: 1,",
          "    key: vec![Transition { start: 8, end: 9, next: StateID(6) }],",
          "    val: StateID(7),",
          "    });",
          "    let key: Vec<Transition> = Vec::new();",
          "    let hash = 0;",
          "    let result = map.get(&key, hash);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 10, end: 11, next: StateID(8) }],",
          "        val: StateID(9),",
          "    });",
          "    let key = vec![Transition { start: 12, end: 13, next: StateID(10) }];",
          "    let hash = 9;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "}"
        ],
        "oracle": [
          "    let mut map = Utf8BoundedMap::new(10);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry { version: 1, key: vec![Transition { start: 10, end: 11, next: StateID(8) }], val: StateID(9) });",
          "    let key = vec![Transition { start: 12, end: 13, next: StateID(10) }];",
          "    let hash = 9;",
          "    let result = map.get(&key, hash);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry {",
          "        version: 1,",
          "        key: vec![Transition { start: 10, end: 11, next: StateID(8) }],",
          "        val: StateID(9),",
          "    });",
          "    let key = vec![Transition { start: 12, end: 13, next: StateID(10) }];",
          "    let hash = 9;",
          "",
          "    let result = map.get(&key, hash);",
          "    // no assertion, just calling the function",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    map.version = 1;",
          "    map.map.push(Utf8BoundedEntry { version: 1, key: vec![Transition { start: 10, end: 11, next: StateID(8) }], val: StateID(9) });",
          "    let key = vec![Transition { start: 12, end: 13, next: StateID(10) }];",
          "    let hash = 9;",
          "    let result = map.get(&key, hash);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]