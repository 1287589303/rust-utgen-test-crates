[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo $bar baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(&b\"foo BAR baz\"[..], dst);",
          "    replacement = b\"foo $$$baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"foo $baz\"[..], dst);",
          "    replacement = b\"foo $bar$$$baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"foo BAR$baz\"[..], dst);",
          "    replacement = b\"$$$foo $bar baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"$foo BAR baz\"[..], dst);",
          "    replacement = b\"$$$foo $bar$$baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"$foo BAR$baz\"[..], dst);"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo $bar baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"foo BAR baz\"[..], dst);",
          "    replacement = b\"foo $$$baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"foo $baz\"[..], dst);",
          "    replacement = b\"foo $bar$$$baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"foo BAR$baz\"[..], dst);",
          "    replacement = b\"$$$foo $bar baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"$foo BAR baz\"[..], dst);",
          "    replacement = b\"$$$foo $bar$$baz\".to_vec();",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(&b\"$foo BAR$baz\"[..], dst);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo $$bar baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    dst.extend_from_slice(b\"foo \");",
          "    assert_eq!(&b\"foo BAR baz\"[..], dst);",
          "    replacement = &replacement[2..];",
          "    dst.push(b'$');",
          "    replacement.get(1).map_or(false, |&b| b == b'$');"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo $$bar baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    dst.extend_from_slice(b\"foo \");",
          "    assert_eq!(&b\"foo BAR baz\"[..], dst);",
          "    replacement = &replacement[2..];",
          "    dst.push(b'$');",
          "    replacement.get(1).map_or(false, |&b| b == b'$');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo $bar baz $baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, b\"foo BAR baz $baz\");",
          "    assert_eq!(replacement, b\"foo $bar baz $baz\");",
          "    assert!(memchr(b'$', &replacement).is_some());",
          "    assert!(!replacement.is_empty());",
          "    assert!(replacement.get(1).map_or(false, |&b| b == b'$'));",
          "    assert!(replacement.is_empty());"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo $bar baz $baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    assert_eq!(dst, b\"foo BAR baz $baz\");",
          "    assert_eq!(replacement, b\"foo $bar baz $baz\");",
          "    assert!(memchr(b'$', &replacement).is_some());",
          "    assert!(!replacement.is_empty());",
          "    assert!(replacement.get(1).map_or(false, |&b| b == b'$'));",
          "    assert!(replacement.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        // This should not be called since there's no capture reference",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        // This should not be called either",
          "        None",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    dst.is_empty() == true",
          "    dst.len() == 0",
          "    dst extends from_slice(replacement)",
          "    replacement == b\"foo baz\""
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let mut replacement = b\"foo baz\".to_vec();",
          "    let mut append = |index: usize, dst: &mut Vec<u8>| {",
          "        // This should not be called since there's no capture reference",
          "    };",
          "    let mut name_to_index = |name: &str| {",
          "        // This should not be called either",
          "        None",
          "    };",
          "    bytes(&mut replacement, &mut append, &mut name_to_index, &mut dst);",
          "    dst.is_empty() == true",
          "    dst.len() == 0",
          "    dst extends from_slice(replacement)",
          "    replacement == b\"foo baz\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]