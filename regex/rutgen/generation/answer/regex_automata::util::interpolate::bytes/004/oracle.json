[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"foo $1 bar\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 1 {",
          "            dst.extend_from_slice(b\"NUMBER\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| -> Option<usize> {",
          "        None",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, b\"foo NUMBER bar\");",
          "    assert!(!dst.is_empty());",
          "    assert!(dst.len() > 0);",
          "    assert!(dst.contains(&b'N'));",
          "    assert!(dst.contains(&b'U'));",
          "    assert!(dst.contains(&b'M'));",
          "    assert!(dst.contains(&b'B'));",
          "    assert!(dst.contains(&b'E'));",
          "    assert!(dst.contains(&b'R'));",
          "    assert!(!dst.contains(&b'$'));"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"foo $1 bar\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 1 {",
          "            dst.extend_from_slice(b\"NUMBER\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| -> Option<usize> {",
          "        None",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    assert_eq!(dst, b\"foo NUMBER bar\");",
          "    assert!(!dst.is_empty());",
          "    assert!(dst.len() > 0);",
          "    assert!(dst.contains(&b'N'));",
          "    assert!(dst.contains(&b'U'));",
          "    assert!(dst.contains(&b'M'));",
          "    assert!(dst.contains(&b'B'));",
          "    assert!(dst.contains(&b'E'));",
          "    assert!(dst.contains(&b'R'));",
          "    assert!(!dst.contains(&b'$'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"foo $bar baz\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"NAMED\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    dst.extend_from_slice(&b\"foo NAMED baz\"[..]);",
          "    assert_eq!(&dst[..], b\"foo NAMED baz\");",
          "    assert_eq!(dst.len(), 13);",
          "    assert!(dst.contains(&b'N'));",
          "    assert!(dst.contains(&b'A'));",
          "    assert!(dst.contains(&b'M'));",
          "    assert!(dst.contains(&b'E'));",
          "    assert!(dst.contains(&b'D'));"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"foo $bar baz\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"NAMED\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    dst.extend_from_slice(&b\"foo NAMED baz\"[..]);",
          "    assert_eq!(&dst[..], b\"foo NAMED baz\");",
          "    assert_eq!(dst.len(), 13);",
          "    assert!(dst.contains(&b'N'));",
          "    assert!(dst.contains(&b'A'));",
          "    assert!(dst.contains(&b'M'));",
          "    assert!(dst.contains(&b'E'));",
          "    assert!(dst.contains(&b'D'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"$1 and $bar\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 1 {",
          "            dst.extend_from_slice(b\"NUMBER\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(1)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, b\"NUMBER and \");",
          "    assert_eq!(dst, b\"NUMBER and \");",
          "    assert_eq!(dst, b\"NUMBER and \");",
          "    assert_eq!(&dst[..], b\"NUMBER and \");",
          "    assert_eq!(dst.len(), 12);",
          "    assert!(dst.contains(&b'N'));",
          "    assert!(dst.contains(&b'U'));",
          "    assert!(dst.contains(&b'M'));",
          "    assert!(dst.contains(&b'E'));",
          "    assert!(dst.contains(&b'R'));",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'N').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'U').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'M').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'E').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'R').count(), 1);"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"$1 and $bar\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 1 {",
          "            dst.extend_from_slice(b\"NUMBER\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(1)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    assert_eq!(dst, b\"NUMBER and \");",
          "    assert_eq!(dst, b\"NUMBER and \");",
          "    assert_eq!(dst, b\"NUMBER and \");",
          "    assert_eq!(&dst[..], b\"NUMBER and \");",
          "    assert_eq!(dst.len(), 12);",
          "    assert!(dst.contains(&b'N'));",
          "    assert!(dst.contains(&b'U'));",
          "    assert!(dst.contains(&b'M'));",
          "    assert!(dst.contains(&b'E'));",
          "    assert!(dst.contains(&b'R'));",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'N').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'U').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'M').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'E').count(), 1);",
          "    assert_eq!(dst.iter().filter(|&&b| b == b'R').count(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"foo $$bar baz\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"NAMED\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(&b\"foo $NAMED baz\"[..], dst);",
          "    assert_eq!(dst.len(), 15);",
          "    assert_eq!(dst[3..8], b\"$NAMED\");",
          "    assert!(dst.contains(&b'B'));",
          "    assert!(dst.ends_with(&b\"baz\"));"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement: &[u8] = b\"foo $$bar baz\";",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"NAMED\");",
          "        }",
          "    };",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "    ",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    assert_eq!(&b\"foo $NAMED baz\"[..], dst);",
          "    assert_eq!(dst.len(), 15);",
          "    assert_eq!(dst[3..8], b\"$NAMED\");",
          "    assert!(dst.contains(&b'B'));",
          "    assert!(dst.ends_with(&b\"baz\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]