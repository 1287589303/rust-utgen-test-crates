[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"foo $bar baz\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert!(!replacement.is_empty());",
          "    assert_eq!(memchr(b'$', replacement).is_some(), true);",
          "    assert!(replacement.get(1).map_or(false, |&b| b == b'$') == false);",
          "    assert!(!replacement.is_empty());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(matches!(cap_ref.cap, Ref::Named(_)));",
          "    assert!(name_to_index(name).is_some());",
          "    assert!(replacement.is_empty());"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"foo $bar baz\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    assert!(!replacement.is_empty());",
          "    assert_eq!(memchr(b'$', replacement).is_some(), true);",
          "    assert!(replacement.get(1).map_or(false, |&b| b == b'$') == false);",
          "    assert!(!replacement.is_empty());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(matches!(cap_ref.cap, Ref::Named(_)));",
          "    assert!(name_to_index(name).is_some());",
          "    assert!(replacement.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"foo $$bar baz\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst.len(), 10);",
          "    assert_eq!(&dst[..], b\"foo $BAR baz\");"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"foo $$bar baz\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 0 {",
          "            dst.extend_from_slice(b\"BAR\");",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    assert_eq!(dst.len(), 10);",
          "    assert_eq!(&dst[..], b\"foo $BAR baz\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"foo $1 baz\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 1 {",
          "            dst.extend_from_slice(b\"ONE\");",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        None  // This will not be used in this particular case",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert!(dst.is_empty());",
          "    assert_eq!(dst.len(), 0);",
          "    assert_eq!(dst, b\"foo ONE baz\");",
          "    assert!(dst.contains(&b'ONE'));",
          "    assert!(!dst.contains(&b'bar'));",
          "    assert_eq!(dst[0..4], b\"foo \");",
          "    assert_eq!(dst[4..7], b\"ONE\");",
          "    assert_eq!(dst[7..11], b\" baz\");"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"foo $1 baz\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        if index == 1 {",
          "            dst.extend_from_slice(b\"ONE\");",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        None  // This will not be used in this particular case",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    assert!(dst.is_empty());",
          "    assert_eq!(dst.len(), 0);",
          "    assert_eq!(dst, b\"foo ONE baz\");",
          "    assert!(dst.contains(&b'ONE'));",
          "    assert!(!dst.contains(&b'bar'));",
          "    assert_eq!(dst[0..4], b\"foo \");",
          "    assert_eq!(dst[4..7], b\"ONE\");",
          "    assert_eq!(dst[7..11], b\" baz\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"$bar goes to $1\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        match index {",
          "            0 => dst.extend_from_slice(b\"BAR\"),",
          "            1 => dst.extend_from_slice(b\"ONE\"),",
          "            _ => {}",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, b\"BAR goes to \");",
          "    assert_eq!(memchr(b'$', replacement), Some(0));",
          "    assert!(replacement.get(1).map_or(false, |&b| b != b'$'));",
          "    assert!(!replacement.is_empty());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(matches!(find_cap_ref(replacement).unwrap().cap, Ref::Named(name) if name == \"bar\"));",
          "    assert!(name_to_index(\"bar\").is_some());",
          "    assert!(replacement.is_empty());"
        ],
        "code": [
          "{",
          "    let mut dst = Vec::new();",
          "    let replacement = b\"$bar goes to $1\";",
          "",
          "    let append = |index: usize, dst: &mut Vec<u8>| {",
          "        match index {",
          "            0 => dst.extend_from_slice(b\"BAR\"),",
          "            1 => dst.extend_from_slice(b\"ONE\"),",
          "            _ => {}",
          "        }",
          "    };",
          "",
          "    let name_to_index = |name: &str| {",
          "        if name == \"bar\" {",
          "            Some(0)",
          "        } else {",
          "            None",
          "        }",
          "    };",
          "",
          "    bytes(replacement, append, name_to_index, &mut dst);",
          "    assert_eq!(dst, b\"BAR goes to \");",
          "    assert_eq!(memchr(b'$', replacement), Some(0));",
          "    assert!(replacement.get(1).map_or(false, |&b| b != b'$'));",
          "    assert!(!replacement.is_empty());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(find_cap_ref(replacement).is_some());",
          "    assert!(matches!(find_cap_ref(replacement).unwrap().cap, Ref::Named(name) if name == \"bar\"));",
          "    assert!(name_to_index(\"bar\").is_some());",
          "    assert!(replacement.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]