[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Clone)]",
          "    struct DummyTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let sparse_data = vec![0u8; 1000];",
          "    let classes = ByteClasses([0; 256]);",
          "    let state_len = 258; // Ensure at least 257 + dead state",
          "    let pattern_len = 0;",
          "",
          "    let transitions = DummyTransitions {",
          "        sparse: sparse_data.clone(),",
          "        classes,",
          "        state_len,",
          "        pattern_len,",
          "    };",
          "",
          "    let id = StateID(257);  // Bound id.as_usize() == self.sparse().len()",
          "    let sp = Special {",
          "        max: StateID(257),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(256),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(3),",
          "        min_start: StateID(0),",
          "        max_start: StateID(256),",
          "    };",
          "",
          "    let state_bytes = vec![",
          "        0, 1, // ntrans = 1",
          "        0, 1, // input range start, end (0-0)",
          "        1, // next state ID (mock)",
          "        0, 0, 0, 0, // pattern IDs length = 0",
          "        0, // accel_len",
          "    ];",
          "",
          "    let state_ptr = state_bytes.as_slice();",
          "",
          "    transitions.sparse.extend_from_slice(state_ptr);",
          "",
          "    let result = transitions.try_state(&sp, id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(state));",
          "    assert_eq!(id.as_usize(), transitions.sparse.len());",
          "    let (ntrans, _) = wire::try_read_u16_as_usize(&transitions.sparse[id.as_usize()..], \"state transition length\").unwrap();",
          "    assert_eq!(ntrans, 1);",
          "    assert!(ntrans <= 257);",
          "    assert!(ntrans > 0);",
          "    assert_eq!(sp.is_match_state(id), false);",
          "    let input_ranges_len = ntrans.checked_mul(2).unwrap();",
          "    wire::check_slice_len(&transitions.sparse[id.as_usize() + 2..], input_ranges_len, \"sparse byte pairs\").unwrap();",
          "    let input_ranges = &transitions.sparse[id.as_usize() + 2..id.as_usize() + 2 + input_ranges_len];",
          "    for pair in input_ranges.chunks(2) {",
          "    let (start, end) = (pair[0], pair[1]);",
          "    assert!(start <= end);",
          "    }",
          "    let next_len = ntrans.checked_mul(transitions.id_len()).unwrap();",
          "    wire::check_slice_len(&transitions.sparse[id.as_usize() + 2 + input_ranges_len..], next_len, \"sparse trans state IDs\").unwrap();",
          "    let next = &transitions.sparse[id.as_usize() + 2 + input_ranges_len + next_len..];",
          "    assert!(!next.is_empty());",
          "    let (pattern_ids, _) = (&next[..0], next);",
          "    assert!(pattern_ids.is_empty());",
          "    assert!(sp.is_match_state(id) == false);",
          "    assert!(sp.is_match_state(id) != true);",
          "    let (accel_len, _) = (usize::from(state_ptr[0]), &state_ptr[1..]);",
          "    assert!(accel_len <= 3);",
          "    assert!(accel_len == 0 && sp.is_accel_state(id) == false);",
          "    wire::check_slice_len(accel_len, \"sparse corrupt accelerator length\").unwrap();",
          "    assert!(sp.is_quit_state(state.next_at(state.ntrans - 1)) == false);"
        ],
        "code": [
          "{",
          "    #[derive(Clone)]",
          "    struct DummyTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let sparse_data = vec![0u8; 1000];",
          "    let classes = ByteClasses([0; 256]);",
          "    let state_len = 258; // Ensure at least 257 + dead state",
          "    let pattern_len = 0;",
          "",
          "    let transitions = DummyTransitions {",
          "        sparse: sparse_data.clone(),",
          "        classes,",
          "        state_len,",
          "        pattern_len,",
          "    };",
          "",
          "    let id = StateID(257);  // Bound id.as_usize() == self.sparse().len()",
          "    let sp = Special {",
          "        max: StateID(257),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(256),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(3),",
          "        min_start: StateID(0),",
          "        max_start: StateID(256),",
          "    };",
          "",
          "    let state_bytes = vec![",
          "        0, 1, // ntrans = 1",
          "        0, 1, // input range start, end (0-0)",
          "        1, // next state ID (mock)",
          "        0, 0, 0, 0, // pattern IDs length = 0",
          "        0, // accel_len",
          "    ];",
          "",
          "    let state_ptr = state_bytes.as_slice();",
          "",
          "    transitions.sparse.extend_from_slice(state_ptr);",
          "",
          "    let result = transitions.try_state(&sp, id);",
          "    assert_eq!(result, Ok(state));",
          "    assert_eq!(id.as_usize(), transitions.sparse.len());",
          "    let (ntrans, _) = wire::try_read_u16_as_usize(&transitions.sparse[id.as_usize()..], \"state transition length\").unwrap();",
          "    assert_eq!(ntrans, 1);",
          "    assert!(ntrans <= 257);",
          "    assert!(ntrans > 0);",
          "    assert_eq!(sp.is_match_state(id), false);",
          "    let input_ranges_len = ntrans.checked_mul(2).unwrap();",
          "    wire::check_slice_len(&transitions.sparse[id.as_usize() + 2..], input_ranges_len, \"sparse byte pairs\").unwrap();",
          "    let input_ranges = &transitions.sparse[id.as_usize() + 2..id.as_usize() + 2 + input_ranges_len];",
          "    for pair in input_ranges.chunks(2) {",
          "    let (start, end) = (pair[0], pair[1]);",
          "    assert!(start <= end);",
          "    }",
          "    let next_len = ntrans.checked_mul(transitions.id_len()).unwrap();",
          "    wire::check_slice_len(&transitions.sparse[id.as_usize() + 2 + input_ranges_len..], next_len, \"sparse trans state IDs\").unwrap();",
          "    let next = &transitions.sparse[id.as_usize() + 2 + input_ranges_len + next_len..];",
          "    assert!(!next.is_empty());",
          "    let (pattern_ids, _) = (&next[..0], next);",
          "    assert!(pattern_ids.is_empty());",
          "    assert!(sp.is_match_state(id) == false);",
          "    assert!(sp.is_match_state(id) != true);",
          "    let (accel_len, _) = (usize::from(state_ptr[0]), &state_ptr[1..]);",
          "    assert!(accel_len <= 3);",
          "    assert!(accel_len == 0 && sp.is_accel_state(id) == false);",
          "    wire::check_slice_len(accel_len, \"sparse corrupt accelerator length\").unwrap();",
          "    assert!(sp.is_quit_state(state.next_at(state.ntrans - 1)) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Clone)]",
          "    struct DummyTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let sparse_data = vec![0u8; 1000];",
          "    let classes = ByteClasses([0; 256]);",
          "    let state_len = 258; // Ensure at least 257 + dead state",
          "    let pattern_len = 0;",
          "",
          "    let transitions = DummyTransitions {",
          "        sparse: sparse_data.clone(),",
          "        classes,",
          "        state_len,",
          "        pattern_len,",
          "    };",
          "",
          "    let id = StateID(257);",
          "    let sp = Special {",
          "        max: StateID(257),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(256),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(3),",
          "        min_start: StateID(0),",
          "        max_start: StateID(256),",
          "    };",
          "",
          "    let state_bytes = vec![",
          "        0, 257, // ntrans = 257",
          "        0, 1, // input range start, end (0-0)",
          "        1, // next state ID (mock)",
          "        1, 0, 0, 0, // pattern IDs length (1)",
          "        1, 2, 3, 4, // invalid pattern ID",
          "        3, // accel_len",
          "        1, 2, 3 // accelerators",
          "    ];",
          "",
          "    let state_ptr = state_bytes.as_slice();",
          "    transitions.sparse.extend_from_slice(state_ptr);",
          "",
          "    let result = transitions.try_state(&sp, id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(id.as_usize(), transitions.sparse.len());",
          "    assert!(transitions.try_state(&sp, id).is_err());",
          "    assert_eq!(transitions.try_state(&sp, StateID(0)).is_err(), true);",
          "    assert!(transitions.try_state(&sp, StateID(256)).is_ok());",
          "    assert!(transitions.try_state(&sp, StateID(257)).is_err());",
          "    assert!(transitions.try_state(&sp, StateID(258)).is_err());",
          "    assert_eq!(transitions.try_state(&sp, id).unwrap_err().0, \"invalid transition length\");",
          "    assert_eq!(transitions.try_state(&sp, id).unwrap_err().0, \"state marked as a match, but has no pattern IDs\");",
          "    assert!(transitions.try_state(&sp, id).is_ok());",
          "    assert_eq!(transitions.try_state(&sp, id).unwrap().pattern_ids.len(), 4);",
          "    assert!(transitions.try_state(&sp, id).unwrap().is_match);",
          "    assert!(transitions.try_state(&sp, id).unwrap().ntrans == 257);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel.len() == 3);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel[0] == 1);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel[1] == 2);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel[2] == 3);",
          "    assert!(!sp.is_quit_state(transitions.try_state(&sp, id).unwrap().next_at(0)));"
        ],
        "code": [
          "{",
          "    #[derive(Clone)]",
          "    struct DummyTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let sparse_data = vec![0u8; 1000];",
          "    let classes = ByteClasses([0; 256]);",
          "    let state_len = 258; // Ensure at least 257 + dead state",
          "    let pattern_len = 0;",
          "",
          "    let transitions = DummyTransitions {",
          "        sparse: sparse_data.clone(),",
          "        classes,",
          "        state_len,",
          "        pattern_len,",
          "    };",
          "",
          "    let id = StateID(257);",
          "    let sp = Special {",
          "        max: StateID(257),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(256),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(3),",
          "        min_start: StateID(0),",
          "        max_start: StateID(256),",
          "    };",
          "",
          "    let state_bytes = vec![",
          "        0, 257, // ntrans = 257",
          "        0, 1, // input range start, end (0-0)",
          "        1, // next state ID (mock)",
          "        1, 0, 0, 0, // pattern IDs length (1)",
          "        1, 2, 3, 4, // invalid pattern ID",
          "        3, // accel_len",
          "        1, 2, 3 // accelerators",
          "    ];",
          "",
          "    let state_ptr = state_bytes.as_slice();",
          "    transitions.sparse.extend_from_slice(state_ptr);",
          "",
          "    let result = transitions.try_state(&sp, id);",
          "    assert_eq!(id.as_usize(), transitions.sparse.len());",
          "    assert!(transitions.try_state(&sp, id).is_err());",
          "    assert_eq!(transitions.try_state(&sp, StateID(0)).is_err(), true);",
          "    assert!(transitions.try_state(&sp, StateID(256)).is_ok());",
          "    assert!(transitions.try_state(&sp, StateID(257)).is_err());",
          "    assert!(transitions.try_state(&sp, StateID(258)).is_err());",
          "    assert_eq!(transitions.try_state(&sp, id).unwrap_err().0, \"invalid transition length\");",
          "    assert_eq!(transitions.try_state(&sp, id).unwrap_err().0, \"state marked as a match, but has no pattern IDs\");",
          "    assert!(transitions.try_state(&sp, id).is_ok());",
          "    assert_eq!(transitions.try_state(&sp, id).unwrap().pattern_ids.len(), 4);",
          "    assert!(transitions.try_state(&sp, id).unwrap().is_match);",
          "    assert!(transitions.try_state(&sp, id).unwrap().ntrans == 257);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel.len() == 3);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel[0] == 1);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel[1] == 2);",
          "    assert!(transitions.try_state(&sp, id).unwrap().accel[2] == 3);",
          "    assert!(!sp.is_quit_state(transitions.try_state(&sp, id).unwrap().next_at(0)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]