[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: Vec::new(),",
          "    };",
          "    let _ = captures.slots();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.slots(), &[]);",
          "    ",
          "    let captures_some = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: Some(PatternID::default()),",
          "    slots: vec![Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(3))],",
          "    };",
          "    assert_eq!(captures_some.slots(), &[Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(3))]);",
          "    ",
          "    let captures_none = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![None, None, Some(NonMaxUsize::new(2)), Some(NonMaxUsize::new(5))],",
          "    };",
          "    assert_eq!(captures_none.slots(), &[None, None, Some(NonMaxUsize::new(2)), Some(NonMaxUsize::new(5))]);",
          "    ",
          "    let captures_mixed = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: Some(PatternID::default()),",
          "    slots: vec![None, Some(NonMaxUsize::new(1)), None, Some(NonMaxUsize::new(4))],",
          "    };",
          "    assert_eq!(captures_mixed.slots(), &[None, Some(NonMaxUsize::new(1)), None, Some(NonMaxUsize::new(4))]);"
        ],
        "code": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: Vec::new(),",
          "    };",
          "    let _ = captures.slots();",
          "    assert_eq!(captures.slots(), &[]);",
          "    ",
          "    let captures_some = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: Some(PatternID::default()),",
          "    slots: vec![Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(3))],",
          "    };",
          "    assert_eq!(captures_some.slots(), &[Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(3))]);",
          "    ",
          "    let captures_none = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![None, None, Some(NonMaxUsize::new(2)), Some(NonMaxUsize::new(5))],",
          "    };",
          "    assert_eq!(captures_none.slots(), &[None, None, Some(NonMaxUsize::new(2)), Some(NonMaxUsize::new(5))]);",
          "    ",
          "    let captures_mixed = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: Some(PatternID::default()),",
          "    slots: vec![None, Some(NonMaxUsize::new(1)), None, Some(NonMaxUsize::new(4))],",
          "    };",
          "    assert_eq!(captures_mixed.slots(), &[None, Some(NonMaxUsize::new(1)), None, Some(NonMaxUsize::new(4))]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; 10],",
          "    };",
          "    let _ = captures.slots();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.slots(), &[None, None, None, None, None, None, None, None, None, None]);",
          "    ",
          "    let captures_with_some_slots = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![None, None, NonMaxUsize::new(0).into(), NonMaxUsize::new(3).into()],",
          "    };",
          "    assert_eq!(captures_with_some_slots.slots(), &[None, None, Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(3))]);",
          "    ",
          "    let captures_filled_slots = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![Some(NonMaxUsize::new(1)), Some(NonMaxUsize::new(2)), None, None],",
          "    };",
          "    assert_eq!(captures_filled_slots.slots(), &[Some(NonMaxUsize::new(1)), Some(NonMaxUsize::new(2)), None, None]);",
          "    ",
          "    let captures_empty_slots = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![],",
          "    };",
          "    assert_eq!(captures_empty_slots.slots(), &[]);"
        ],
        "code": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; 10],",
          "    };",
          "    let _ = captures.slots();",
          "    assert_eq!(captures.slots(), &[None, None, None, None, None, None, None, None, None, None]);",
          "    ",
          "    let captures_with_some_slots = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![None, None, NonMaxUsize::new(0).into(), NonMaxUsize::new(3).into()],",
          "    };",
          "    assert_eq!(captures_with_some_slots.slots(), &[None, None, Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(3))]);",
          "    ",
          "    let captures_filled_slots = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![Some(NonMaxUsize::new(1)), Some(NonMaxUsize::new(2)), None, None],",
          "    };",
          "    assert_eq!(captures_filled_slots.slots(), &[Some(NonMaxUsize::new(1)), Some(NonMaxUsize::new(2)), None, None]);",
          "    ",
          "    let captures_empty_slots = Captures {",
          "    group_info: GroupInfo::default(),",
          "    pid: None,",
          "    slots: vec![],",
          "    };",
          "    assert_eq!(captures_empty_slots.slots(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![",
          "            Some(NonMaxUsize::new(0)),",
          "            None,",
          "            Some(NonMaxUsize::new(3)),",
          "            None,",
          "            Some(NonMaxUsize::new(5)),",
          "        ],",
          "    };",
          "    let _ = captures.slots();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.slots(), vec![Some(NonMaxUsize::new(0)), None, Some(NonMaxUsize::new(3)), None, Some(NonMaxUsize::new(5))].as_slice());"
        ],
        "code": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![",
          "            Some(NonMaxUsize::new(0)),",
          "            None,",
          "            Some(NonMaxUsize::new(3)),",
          "            None,",
          "            Some(NonMaxUsize::new(5)),",
          "        ],",
          "    };",
          "    let _ = captures.slots();",
          "    assert_eq!(captures.slots(), vec![Some(NonMaxUsize::new(0)), None, Some(NonMaxUsize::new(3)), None, Some(NonMaxUsize::new(5))].as_slice());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![",
          "            Some(NonMaxUsize::new(0)),",
          "            Some(NonMaxUsize::new(1)),",
          "            Some(NonMaxUsize::new(2)),",
          "            Some(NonMaxUsize::new(3)),",
          "            Some(NonMaxUsize::new(4)),",
          "        ],",
          "    };",
          "    let _ = captures.slots();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.slots(), &[Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(1)), Some(NonMaxUsize::new(2)), Some(NonMaxUsize::new(3)), Some(NonMaxUsize::new(4))]);"
        ],
        "code": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![",
          "            Some(NonMaxUsize::new(0)),",
          "            Some(NonMaxUsize::new(1)),",
          "            Some(NonMaxUsize::new(2)),",
          "            Some(NonMaxUsize::new(3)),",
          "            Some(NonMaxUsize::new(4)),",
          "        ],",
          "    };",
          "    let _ = captures.slots();",
          "    assert_eq!(captures.slots(), &[Some(NonMaxUsize::new(0)), Some(NonMaxUsize::new(1)), Some(NonMaxUsize::new(2)), Some(NonMaxUsize::new(3)), Some(NonMaxUsize::new(4))]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![Some(NonMaxUsize::new(1)); 100],",
          "    };",
          "    let _ = captures.slots();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.slots().len(), 100);",
          "    assert_eq!(captures.slots()[0], Some(NonMaxUsize::new(1)));",
          "    assert_eq!(captures.slots()[50], Some(NonMaxUsize::new(1)));",
          "    assert_eq!(captures.slots()[99], Some(NonMaxUsize::new(1)));"
        ],
        "code": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![Some(NonMaxUsize::new(1)); 100],",
          "    };",
          "    let _ = captures.slots();",
          "    assert_eq!(captures.slots().len(), 100);",
          "    assert_eq!(captures.slots()[0], Some(NonMaxUsize::new(1)));",
          "    assert_eq!(captures.slots()[50], Some(NonMaxUsize::new(1)));",
          "    assert_eq!(captures.slots()[99], Some(NonMaxUsize::new(1)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; alloc::MAX],",
          "    };",
          "    let _ = captures.slots();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.slots(), &[None; alloc::MAX]);"
        ],
        "code": [
          "{",
          "    let captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![None; alloc::MAX],",
          "    };",
          "    let _ = captures.slots();",
          "    assert_eq!(captures.slots(), &[None; alloc::MAX]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]