[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\").unwrap();",
          "    let hay = \"On 14-03-2010, I became a Tennessee lamb.\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"year=${year}, month=${month}, day=${day}\", &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, \"year=2010, month=03, day=14\");",
          "    ",
          "    let mut dst_empty = String::new();",
          "    caps.expand(\"no refs here\", &mut dst_empty);",
          "    assert_eq!(dst_empty, \"no refs here\");",
          "    ",
          "    let mut dst_with_unbraced = String::new();",
          "    caps.expand(\"year=$year, month=$month, day=$day\", &mut dst_with_unbraced);",
          "    assert_eq!(dst_with_unbraced, \"year=2010, month=03, day=14\");",
          "    ",
          "    let mut dst_invalid_ref = String::new();",
          "    caps.expand(\"invalid=$foo\", &mut dst_invalid_ref);",
          "    assert_eq!(dst_invalid_ref, \"invalid=\");",
          "    ",
          "    let mut dst_brace_without_closing = String::new();",
          "    caps.expand(\"invalid ${foo\", &mut dst_brace_without_closing);",
          "    assert_eq!(dst_brace_without_closing, \"invalid ${foo\");",
          "    ",
          "    let mut dst_literal_dollar = String::new();",
          "    caps.expand(\"$$ is a literal dollar\", &mut dst_literal_dollar);",
          "    assert_eq!(dst_literal_dollar, \"$ is a literal dollar\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\").unwrap();",
          "    let hay = \"On 14-03-2010, I became a Tennessee lamb.\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"year=${year}, month=${month}, day=${day}\", &mut dst);",
          "    assert_eq!(dst, \"year=2010, month=03, day=14\");",
          "    ",
          "    let mut dst_empty = String::new();",
          "    caps.expand(\"no refs here\", &mut dst_empty);",
          "    assert_eq!(dst_empty, \"no refs here\");",
          "    ",
          "    let mut dst_with_unbraced = String::new();",
          "    caps.expand(\"year=$year, month=$month, day=$day\", &mut dst_with_unbraced);",
          "    assert_eq!(dst_with_unbraced, \"year=2010, month=03, day=14\");",
          "    ",
          "    let mut dst_invalid_ref = String::new();",
          "    caps.expand(\"invalid=$foo\", &mut dst_invalid_ref);",
          "    assert_eq!(dst_invalid_ref, \"invalid=\");",
          "    ",
          "    let mut dst_brace_without_closing = String::new();",
          "    caps.expand(\"invalid ${foo\", &mut dst_brace_without_closing);",
          "    assert_eq!(dst_brace_without_closing, \"invalid ${foo\");",
          "    ",
          "    let mut dst_literal_dollar = String::new();",
          "    caps.expand(\"$$ is a literal dollar\", &mut dst_literal_dollar);",
          "    assert_eq!(dst_literal_dollar, \"$ is a literal dollar\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\").unwrap();",
          "    let hay = \"On 14-03-2010, I became a Tennessee lamb.\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"\", &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"year=$year, month=$month, day=$day\", &mut dst);",
          "    assert_eq!(dst, \"year=2010, month=03, day=14\");",
          "    dst.clear();",
          "    caps.expand(\"No capture groups used.\", &mut dst);",
          "    assert_eq!(dst, \"No capture groups used.\");",
          "    dst.clear();",
          "    caps.expand(\"Invalid reference $10.\", &mut dst);",
          "    assert_eq!(dst, \"Invalid reference .\");",
          "    dst.clear();",
          "    caps.expand(\"Just a dollar sign $$.\", &mut dst);",
          "    assert_eq!(dst, \"Just a dollar sign $.\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(?<day>[0-9]{2})-(?<month>[0-9]{2})-(?<year>[0-9]{4})\").unwrap();",
          "    let hay = \"On 14-03-2010, I became a Tennessee lamb.\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"\", &mut dst);",
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"year=$year, month=$month, day=$day\", &mut dst);",
          "    assert_eq!(dst, \"year=2010, month=03, day=14\");",
          "    dst.clear();",
          "    caps.expand(\"No capture groups used.\", &mut dst);",
          "    assert_eq!(dst, \"No capture groups used.\");",
          "    dst.clear();",
          "    caps.expand(\"Invalid reference $10.\", &mut dst);",
          "    assert_eq!(dst, \"Invalid reference .\");",
          "    dst.clear();",
          "    caps.expand(\"Just a dollar sign $$.\", &mut dst);",
          "    assert_eq!(dst, \"Just a dollar sign $.\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(?<number>[0-9]{2})\").unwrap();",
          "    let hay = \"The number is 42.\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"Number: $number\", &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, \"Number: 42\");",
          "    let mut dst_empty = String::new();",
          "    caps.expand(\"No match: $nonexistent\", &mut dst_empty);",
          "    assert_eq!(dst_empty, \"No match: \");",
          "    let mut dst_braced = String::new();",
          "    caps.expand(\"Braced: ${number}\", &mut dst_braced);",
          "    assert_eq!(dst_braced, \"Braced: 42\");",
          "    let mut dst_mixed = String::new();",
          "    caps.expand(\"Value: $number, Next: $number1\", &mut dst_mixed);",
          "    assert_eq!(dst_mixed, \"Value: 42, Next: \");",
          "    let mut dst_literal = String::new();",
          "    caps.expand(\"Literal: $$\", &mut dst_literal);",
          "    assert_eq!(dst_literal, \"Literal: $\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(?<number>[0-9]{2})\").unwrap();",
          "    let hay = \"The number is 42.\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"Number: $number\", &mut dst);",
          "    assert_eq!(dst, \"Number: 42\");",
          "    let mut dst_empty = String::new();",
          "    caps.expand(\"No match: $nonexistent\", &mut dst_empty);",
          "    assert_eq!(dst_empty, \"No match: \");",
          "    let mut dst_braced = String::new();",
          "    caps.expand(\"Braced: ${number}\", &mut dst_braced);",
          "    assert_eq!(dst_braced, \"Braced: 42\");",
          "    let mut dst_mixed = String::new();",
          "    caps.expand(\"Value: $number, Next: $number1\", &mut dst_mixed);",
          "    assert_eq!(dst_mixed, \"Value: 42, Next: \");",
          "    let mut dst_literal = String::new();",
          "    caps.expand(\"Literal: $$\", &mut dst_literal);",
          "    assert_eq!(dst_literal, \"Literal: $\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(?<name>\\w+) (?<age>[0-9]+)\").unwrap();",
          "    let hay = \"Alice 30\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"${name} is ${age} years old.\", &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, \"Alice is 30 years old.\");",
          "    assert!(dst.contains(\"Alice\"));",
          "    assert!(dst.contains(\"30\"));",
          "    assert!(!dst.contains(\"$\"));",
          "    assert!(!dst.contains(\"name\"));",
          "    assert!(!dst.contains(\"age\"));"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(?<name>\\w+) (?<age>[0-9]+)\").unwrap();",
          "    let hay = \"Alice 30\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"${name} is ${age} years old.\", &mut dst);",
          "    assert_eq!(dst, \"Alice is 30 years old.\");",
          "    assert!(dst.contains(\"Alice\"));",
          "    assert!(dst.contains(\"30\"));",
          "    assert!(!dst.contains(\"$\"));",
          "    assert!(!dst.contains(\"name\"));",
          "    assert!(!dst.contains(\"age\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
          "    let hay = \"abc\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"$3$4\", &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"$1\", &mut dst);",
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"${1}\", &mut dst);",
          "    assert_eq!(dst, \"a\");",
          "    caps.expand(\"$$\", &mut dst);",
          "    assert_eq!(dst, \"$\");",
          "    caps.expand(\"$0\", &mut dst);",
          "    assert_eq!(dst, \"abc\");",
          "    caps.expand(\"$2$x\", &mut dst);",
          "    assert_eq!(dst, \"bx\");",
          "    caps.expand(\"x$3\", &mut dst);",
          "    assert_eq!(dst, \"x\");",
          "    caps.expand(\"${non_existent}\", &mut dst);",
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"$1$non_existent\", &mut dst);",
          "    assert_eq!(dst, \"a\");",
          "    caps.expand(\"${0}\", &mut dst);",
          "    assert_eq!(dst, \"abc\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
          "    let hay = \"abc\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"$3$4\", &mut dst);",
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"$1\", &mut dst);",
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"${1}\", &mut dst);",
          "    assert_eq!(dst, \"a\");",
          "    caps.expand(\"$$\", &mut dst);",
          "    assert_eq!(dst, \"$\");",
          "    caps.expand(\"$0\", &mut dst);",
          "    assert_eq!(dst, \"abc\");",
          "    caps.expand(\"$2$x\", &mut dst);",
          "    assert_eq!(dst, \"bx\");",
          "    caps.expand(\"x$3\", &mut dst);",
          "    assert_eq!(dst, \"x\");",
          "    caps.expand(\"${non_existent}\", &mut dst);",
          "    assert_eq!(dst, \"\");",
          "    caps.expand(\"$1$non_existent\", &mut dst);",
          "    assert_eq!(dst, \"a\");",
          "    caps.expand(\"${0}\", &mut dst);",
          "    assert_eq!(dst, \"abc\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(?<key>[A-Za-z]+): (?<value>\\d+)\").unwrap();",
          "    let hay = \"X: 10\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"${key} costs $value bucks.\", &mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst, \"X costs 10 bucks.\");",
          "    assert_eq!(dst.len(), 24);",
          "    assert_eq!(dst.chars().last().unwrap(), '.');",
          "    assert!(dst.contains(\"costs\"));",
          "    assert!(dst.contains(\"bucks\"));",
          "    assert!(!dst.contains(\"${key}\"));",
          "    assert!(!dst.contains(\"$value\"));",
          "    caps.expand(\"$$\", &mut dst);",
          "    assert_eq!(dst, \"$\");",
          "    caps.expand(\"${invalid}\", &mut dst);",
          "    assert_eq!(dst, \"\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(?<key>[A-Za-z]+): (?<value>\\d+)\").unwrap();",
          "    let hay = \"X: 10\";",
          "    let caps = re.captures(hay).unwrap();",
          "",
          "    let mut dst = String::new();",
          "    caps.expand(\"${key} costs $value bucks.\", &mut dst);",
          "    assert_eq!(dst, \"X costs 10 bucks.\");",
          "    assert_eq!(dst.len(), 24);",
          "    assert_eq!(dst.chars().last().unwrap(), '.');",
          "    assert!(dst.contains(\"costs\"));",
          "    assert!(dst.contains(\"bucks\"));",
          "    assert!(!dst.contains(\"${key}\"));",
          "    assert!(!dst.contains(\"$value\"));",
          "    caps.expand(\"$$\", &mut dst);",
          "    assert_eq!(dst, \"$\");",
          "    caps.expand(\"${invalid}\", &mut dst);",
          "    assert_eq!(dst, \"\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]