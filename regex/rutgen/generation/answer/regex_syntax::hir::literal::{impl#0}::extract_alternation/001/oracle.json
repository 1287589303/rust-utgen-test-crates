[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(7)",
          "        .limit_total(100);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![1, 2, 3])) },",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![4, 5, 6])) },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "}"
        ],
        "oracle": [
          "    seq.is_finite();",
          "    seq.len().unwrap() <= 100;",
          "    seq.is_exact();",
          "    seq.literals().unwrap().len() <= 10;",
          "    seq.max_literal_len().unwrap() <= 7;",
          "    seq.min_literal_len().unwrap() <= 3;",
          "    seq.union(&mut extractor.extract(&hir_elements[0]));",
          "    seq.union(&mut extractor.extract(&hir_elements[1]));",
          "    extractor.limit_total(100);",
          "    extractor.limit_class(10);",
          "    extractor.limit_repeat(5);",
          "    extractor.limit_literal_len(7);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(10)",
          "        .limit_repeat(5)",
          "        .limit_literal_len(7)",
          "        .limit_total(100);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![1, 2, 3])) },",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![4, 5, 6])) },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "    seq.is_finite();",
          "    seq.len().unwrap() <= 100;",
          "    seq.is_exact();",
          "    seq.literals().unwrap().len() <= 10;",
          "    seq.max_literal_len().unwrap() <= 7;",
          "    seq.min_literal_len().unwrap() <= 3;",
          "    seq.union(&mut extractor.extract(&hir_elements[0]));",
          "    seq.union(&mut extractor.extract(&hir_elements[1]));",
          "    extractor.limit_total(100);",
          "    extractor.limit_class(10);",
          "    extractor.limit_repeat(5);",
          "    extractor.limit_literal_len(7);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(50)",
          "        .limit_repeat(10)",
          "        .limit_literal_len(5)",
          "        .limit_total(300);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![7, 8])) },",
          "        Hir { kind: HirKind::Class(hir::Class::Unicode(vec![9, 10])) },",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![11])) },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "}"
        ],
        "oracle": [
          "    let mut extractor = Extractor::new().limit_class(50).limit_repeat(10).limit_literal_len(5).limit_total(300);",
          "    let hir_elements: Vec<Hir> = vec![Hir { kind: HirKind::Literal(hir::Literal(vec![7, 8])) }, Hir { kind: HirKind::Class(hir::Class::Unicode(vec![9, 10])) }, Hir { kind: HirKind::Literal(hir::Literal(vec![11])) }];",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "    assert!(seq.is_finite());",
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(seq.literals().unwrap().iter().all(|lit| lit.is_exact()));",
          "    assert!(seq.max_literal_len().unwrap() <= 5);",
          "    assert!(seq.max_union_len(&seq).map_or(true, |len| len <= 300));"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(50)",
          "        .limit_repeat(10)",
          "        .limit_literal_len(5)",
          "        .limit_total(300);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![7, 8])) },",
          "        Hir { kind: HirKind::Class(hir::Class::Unicode(vec![9, 10])) },",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![11])) },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "    let mut extractor = Extractor::new().limit_class(50).limit_repeat(10).limit_literal_len(5).limit_total(300);",
          "    let hir_elements: Vec<Hir> = vec![Hir { kind: HirKind::Literal(hir::Literal(vec![7, 8])) }, Hir { kind: HirKind::Class(hir::Class::Unicode(vec![9, 10])) }, Hir { kind: HirKind::Literal(hir::Literal(vec![11])) }];",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "    assert!(seq.is_finite());",
          "    assert_eq!(seq.len(), Some(3));",
          "    assert!(seq.literals().unwrap().iter().all(|lit| lit.is_exact()));",
          "    assert!(seq.max_literal_len().unwrap() <= 5);",
          "    assert!(seq.max_union_len(&seq).map_or(true, |len| len <= 300));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(20)",
          "        .limit_repeat(3)",
          "        .limit_literal_len(6)",
          "        .limit_total(200);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![12, 13, 14, 15])) },",
          "        Hir { kind: HirKind::Repetition(hir::Repetition::new(2, None, HirKind::Literal(hir::Literal(vec![16])))) },",
          "        Hir { kind: HirKind::Class(hir::Class::Bytes(vec![17, 18])) },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "}"
        ],
        "oracle": [
          "    seq.is_finite() == true",
          "    seq.len().unwrap() <= extractor.limit_total",
          "    seq.literals().is_some()",
          "    seq.max_union_len(&seq) <= Some(extractor.limit_total)",
          "    seq.max_cross_len(&seq).is_none()",
          "    seq.is_empty() == false",
          "    seq.is_exact() || seq.is_inexact()",
          "    seq.literals().unwrap().len() <= extractor.limit_literal_len",
          "    seq.literals().unwrap().iter().all(|lit| lit.bytes().len() <= extractor.limit_literal_len)",
          "    extractor.extract_alternation(hir_elements.iter()).is_finite() == true",
          "    extractor.extract_alternation(hir_elements.iter()).len().unwrap() < extractor.limit_total"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(20)",
          "        .limit_repeat(3)",
          "        .limit_literal_len(6)",
          "        .limit_total(200);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![12, 13, 14, 15])) },",
          "        Hir { kind: HirKind::Repetition(hir::Repetition::new(2, None, HirKind::Literal(hir::Literal(vec![16])))) },",
          "        Hir { kind: HirKind::Class(hir::Class::Bytes(vec![17, 18])) },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "    seq.is_finite() == true",
          "    seq.len().unwrap() <= extractor.limit_total",
          "    seq.literals().is_some()",
          "    seq.max_union_len(&seq) <= Some(extractor.limit_total)",
          "    seq.max_cross_len(&seq).is_none()",
          "    seq.is_empty() == false",
          "    seq.is_exact() || seq.is_inexact()",
          "    seq.literals().unwrap().len() <= extractor.limit_literal_len",
          "    seq.literals().unwrap().iter().all(|lit| lit.bytes().len() <= extractor.limit_literal_len)",
          "    extractor.extract_alternation(hir_elements.iter()).is_finite() == true",
          "    extractor.extract_alternation(hir_elements.iter()).len().unwrap() < extractor.limit_total",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(5)",
          "        .limit_repeat(1)",
          "        .limit_literal_len(1)",
          "        .limit_total(50);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![])) },",
          "        Hir { kind: HirKind::Capture { sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![1])) }) } },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "}"
        ],
        "oracle": [
          "    seq.is_finite();",
          "    seq = extractor.extract_alternation(hir_elements.iter());",
          "    seq.len().map_or(true, |x| x <= 50);",
          "    seq.literals().is_some();",
          "    seq.literals().unwrap().len().map_or(false, |len| len <= 5);",
          "    seq.is_exact();",
          "    seq.is_empty();",
          "    seq.min_literal_len().map_or(true, |len| len <= 1);",
          "    seq.max_literal_len().map_or(true, |len| len <= 1);",
          "    seq.literals().unwrap().contains(&Literal::exact(vec![]));",
          "    seq.literals().unwrap().contains(&Literal::exact(vec![1]));"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(5)",
          "        .limit_repeat(1)",
          "        .limit_literal_len(1)",
          "        .limit_total(50);",
          "",
          "    let hir_elements: Vec<Hir> = vec![",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![])) },",
          "        Hir { kind: HirKind::Capture { sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![1])) }) } },",
          "    ];",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "    seq.is_finite();",
          "    seq = extractor.extract_alternation(hir_elements.iter());",
          "    seq.len().map_or(true, |x| x <= 50);",
          "    seq.literals().is_some();",
          "    seq.literals().unwrap().len().map_or(false, |len| len <= 5);",
          "    seq.is_exact();",
          "    seq.is_empty();",
          "    seq.min_literal_len().map_or(true, |len| len <= 1);",
          "    seq.max_literal_len().map_or(true, |len| len <= 1);",
          "    seq.literals().unwrap().contains(&Literal::exact(vec![]));",
          "    seq.literals().unwrap().contains(&Literal::exact(vec![1]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(100)",
          "        .limit_repeat(100)",
          "        .limit_literal_len(10)",
          "        .limit_total(1000);",
          "",
          "    let hir_elements: Vec<Hir> = (0..10).map(|i| {",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![i])) }",
          "    }).collect();",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "}"
        ],
        "oracle": [
          "    seq.is_finite() == true",
          "    seq.len().is_some()",
          "    seq.literals().unwrap().len() == 10",
          "    seq.literals().unwrap()[0] == Literal::exact(vec![0])",
          "    seq.literals().unwrap()[1] == Literal::exact(vec![1])",
          "    seq.literals().unwrap()[2] == Literal::exact(vec![2])",
          "    seq.literals().unwrap()[3] == Literal::exact(vec![3])",
          "    seq.literals().unwrap()[4] == Literal::exact(vec![4])",
          "    seq.literals().unwrap()[5] == Literal::exact(vec![5])",
          "    seq.literals().unwrap()[6] == Literal::exact(vec![6])",
          "    seq.literals().unwrap()[7] == Literal::exact(vec![7])",
          "    seq.literals().unwrap()[8] == Literal::exact(vec![8])",
          "    seq.literals().unwrap()[9] == Literal::exact(vec![9])"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .limit_class(100)",
          "        .limit_repeat(100)",
          "        .limit_literal_len(10)",
          "        .limit_total(1000);",
          "",
          "    let hir_elements: Vec<Hir> = (0..10).map(|i| {",
          "        Hir { kind: HirKind::Literal(hir::Literal(vec![i])) }",
          "    }).collect();",
          "",
          "    let seq = extractor.extract_alternation(hir_elements.iter());",
          "    seq.is_finite() == true",
          "    seq.len().is_some()",
          "    seq.literals().unwrap().len() == 10",
          "    seq.literals().unwrap()[0] == Literal::exact(vec![0])",
          "    seq.literals().unwrap()[1] == Literal::exact(vec![1])",
          "    seq.literals().unwrap()[2] == Literal::exact(vec![2])",
          "    seq.literals().unwrap()[3] == Literal::exact(vec![3])",
          "    seq.literals().unwrap()[4] == Literal::exact(vec![4])",
          "    seq.literals().unwrap()[5] == Literal::exact(vec![5])",
          "    seq.literals().unwrap()[6] == Literal::exact(vec![6])",
          "    seq.literals().unwrap()[7] == Literal::exact(vec![7])",
          "    seq.literals().unwrap()[8] == Literal::exact(vec![8])",
          "    seq.literals().unwrap()[9] == Literal::exact(vec![9])",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]