[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start: &[u8] = &[0x00, 0x01, 0x02, 0x03];",
          "    let end: &[u8] = &[0x7F, 0x7E, 0x7D, 0x7C];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len(), 4);",
          "    assert_eq!(result[0].start, 0x00);",
          "    assert_eq!(result[0].end, 0x7F);",
          "    assert_eq!(result[1].start, 0x01);",
          "    assert_eq!(result[1].end, 0x7E);",
          "    assert_eq!(result[2].start, 0x02);",
          "    assert_eq!(result[2].end, 0x7D);",
          "    assert_eq!(result[3].start, 0x03);",
          "    assert_eq!(result[3].end, 0x7C);"
        ],
        "code": [
          "{",
          "    let start: &[u8] = &[0x00, 0x01, 0x02, 0x03];",
          "    let end: &[u8] = &[0x7F, 0x7E, 0x7D, 0x7C];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "    assert_eq!(result.len(), 4);",
          "    assert_eq!(result[0].start, 0x00);",
          "    assert_eq!(result[0].end, 0x7F);",
          "    assert_eq!(result[1].start, 0x01);",
          "    assert_eq!(result[1].end, 0x7E);",
          "    assert_eq!(result[2].start, 0x02);",
          "    assert_eq!(result[2].end, 0x7D);",
          "    assert_eq!(result[3].start, 0x03);",
          "    assert_eq!(result[3].end, 0x7C);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let end: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "}"
        ],
        "oracle": [
          "    let start: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let end: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    assert_eq!(utf8_sequence.as_slice().len(), 4);",
          "    assert_eq!(utf8_sequence.as_slice()[0], Utf8Range { start: 0xFC, end: 0xFC });",
          "    assert_eq!(utf8_sequence.as_slice()[1], Utf8Range { start: 0xFD, end: 0xFD });",
          "    assert_eq!(utf8_sequence.as_slice()[2], Utf8Range { start: 0xFE, end: 0xFE });",
          "    assert_eq!(utf8_sequence.as_slice()[3], Utf8Range { start: 0xFF, end: 0xFF });"
        ],
        "code": [
          "{",
          "    let start: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let end: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "    let start: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let end: &[u8] = &[0xFC, 0xFD, 0xFE, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    assert_eq!(utf8_sequence.as_slice().len(), 4);",
          "    assert_eq!(utf8_sequence.as_slice()[0], Utf8Range { start: 0xFC, end: 0xFC });",
          "    assert_eq!(utf8_sequence.as_slice()[1], Utf8Range { start: 0xFD, end: 0xFD });",
          "    assert_eq!(utf8_sequence.as_slice()[2], Utf8Range { start: 0xFE, end: 0xFE });",
          "    assert_eq!(utf8_sequence.as_slice()[3], Utf8Range { start: 0xFF, end: 0xFF });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start: &[u8] = &[0x10, 0x40, 0x80, 0xC0];",
          "    let end: &[u8] = &[0x1F, 0x5F, 0xBF, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "}"
        ],
        "oracle": [
          "    let start: &[u8] = &[0x10, 0x40, 0x80, 0xC0];",
          "    let end: &[u8] = &[0x1F, 0x5F, 0xBF, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "    assert_eq!(result.len(), 4);",
          "    assert_eq!(result[0], Utf8Range { start: 0x10, end: 0x1F });",
          "    assert_eq!(result[1], Utf8Range { start: 0x40, end: 0x5F });",
          "    assert_eq!(result[2], Utf8Range { start: 0x80, end: 0xBF });",
          "    assert_eq!(result[3], Utf8Range { start: 0xC0, end: 0xFF });"
        ],
        "code": [
          "{",
          "    let start: &[u8] = &[0x10, 0x40, 0x80, 0xC0];",
          "    let end: &[u8] = &[0x1F, 0x5F, 0xBF, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "    let start: &[u8] = &[0x10, 0x40, 0x80, 0xC0];",
          "    let end: &[u8] = &[0x1F, 0x5F, 0xBF, 0xFF];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "    assert_eq!(result.len(), 4);",
          "    assert_eq!(result[0], Utf8Range { start: 0x10, end: 0x1F });",
          "    assert_eq!(result[1], Utf8Range { start: 0x40, end: 0x5F });",
          "    assert_eq!(result[2], Utf8Range { start: 0x80, end: 0xBF });",
          "    assert_eq!(result[3], Utf8Range { start: 0xC0, end: 0xFF });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start: &[u8] = &[0x03, 0x02, 0x01, 0x00];",
          "    let end: &[u8] = &[0x03, 0x02, 0x01, 0x00];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len(), 4);",
          "    assert_eq!(result[0], Utf8Range { start: 0x03, end: 0x03 });",
          "    assert_eq!(result[1], Utf8Range { start: 0x02, end: 0x02 });",
          "    assert_eq!(result[2], Utf8Range { start: 0x01, end: 0x01 });",
          "    assert_eq!(result[3], Utf8Range { start: 0x00, end: 0x00 });"
        ],
        "code": [
          "{",
          "    let start: &[u8] = &[0x03, 0x02, 0x01, 0x00];",
          "    let end: &[u8] = &[0x03, 0x02, 0x01, 0x00];",
          "    let utf8_sequence = Utf8Sequence::from_encoded_range(start, end);",
          "    let result = utf8_sequence.as_slice();",
          "    assert_eq!(result.len(), 4);",
          "    assert_eq!(result[0], Utf8Range { start: 0x03, end: 0x03 });",
          "    assert_eq!(result[1], Utf8Range { start: 0x02, end: 0x02 });",
          "    assert_eq!(result[2], Utf8Range { start: 0x01, end: 0x01 });",
          "    assert_eq!(result[3], Utf8Range { start: 0x00, end: 0x00 });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]