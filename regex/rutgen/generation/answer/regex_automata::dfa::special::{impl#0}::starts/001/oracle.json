[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(2),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(2),",
          "        min_start: StateID(0), // DEAD state",
          "        max_start: StateID(2),",
          "    };",
          "    special.starts();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(special.starts(), false);"
        ],
        "code": [
          "{",
          "    let special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(2),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(2),",
          "        min_start: StateID(0), // DEAD state",
          "        max_start: StateID(2),",
          "    };",
          "    special.starts();",
          "    assert_eq!(special.starts(), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let special = Special {",
          "        max: StateID(2),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(2),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(2),",
          "        min_start: StateID(1), // valid start state",
          "        max_start: StateID(2),",
          "    };",
          "    special.starts();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(special.starts(), true);",
          "    special.min_start = DEAD;",
          "    assert_eq!(special.starts(), false);",
          "    special.min_start = StateID(0);",
          "    assert_eq!(special.starts(), false);",
          "    special.min_start = StateID(3);",
          "    assert_eq!(special.starts(), true);"
        ],
        "code": [
          "{",
          "    let special = Special {",
          "        max: StateID(2),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(2),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(2),",
          "        min_start: StateID(1), // valid start state",
          "        max_start: StateID(2),",
          "    };",
          "    special.starts();",
          "    assert_eq!(special.starts(), true);",
          "    special.min_start = DEAD;",
          "    assert_eq!(special.starts(), false);",
          "    special.min_start = StateID(0);",
          "    assert_eq!(special.starts(), false);",
          "    special.min_start = StateID(3);",
          "    assert_eq!(special.starts(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let special = Special {",
          "        max: StateID(UINT_MAX),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(UINT_MAX - 1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(UINT_MAX - 1),",
          "        min_start: StateID(UINT_MAX), // valid but max start",
          "        max_start: StateID(UINT_MAX),",
          "    };",
          "    special.starts();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(special.starts(), false); // min_start is dead state (UINT_MAX)",
          "    ",
          "    special.min_start = StateID(0); // valid start state",
          "    assert_eq!(special.starts(), true); // min_start is now a valid state"
        ],
        "code": [
          "{",
          "    let special = Special {",
          "        max: StateID(UINT_MAX),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(UINT_MAX - 1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(UINT_MAX - 1),",
          "        min_start: StateID(UINT_MAX), // valid but max start",
          "        max_start: StateID(UINT_MAX),",
          "    };",
          "    special.starts();",
          "    assert_eq!(special.starts(), false); // min_start is dead state (UINT_MAX)",
          "    ",
          "    special.min_start = StateID(0); // valid start state",
          "    assert_eq!(special.starts(), true); // min_start is now a valid state",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let special = Special {",
          "        max: StateID(UINT_MAX),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(UINT_MAX - 1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(UINT_MAX - 1),",
          "        min_start: StateID(1), // valid start state",
          "        max_start: StateID(UINT_MAX),",
          "    };",
          "    special.starts();",
          "}"
        ],
        "oracle": [
          "    assert!(special.starts()); // min_start is valid (1)",
          "    special.min_start = StateID(DEAD); // invalid start state",
          "    assert!(!special.starts()); // should return false",
          "    special.min_start = StateID(2); // valid start state",
          "    assert!(special.starts()); // should return true",
          "    special.min_start = StateID(UINT_MAX); // valid boundary start state",
          "    assert!(special.starts()); // should return true",
          "    special.min_start = StateID(UINT_MAX + 1); // invalid start state (out of range)",
          "    assert!(!special.starts()); // should return false"
        ],
        "code": [
          "{",
          "    let special = Special {",
          "        max: StateID(UINT_MAX),",
          "        quit_id: StateID(1),",
          "        min_match: StateID(1),",
          "        max_match: StateID(UINT_MAX - 1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(UINT_MAX - 1),",
          "        min_start: StateID(1), // valid start state",
          "        max_start: StateID(UINT_MAX),",
          "    };",
          "    special.starts();",
          "    assert!(special.starts()); // min_start is valid (1)",
          "    special.min_start = StateID(DEAD); // invalid start state",
          "    assert!(!special.starts()); // should return false",
          "    special.min_start = StateID(2); // valid start state",
          "    assert!(special.starts()); // should return true",
          "    special.min_start = StateID(UINT_MAX); // valid boundary start state",
          "    assert!(special.starts()); // should return true",
          "    special.min_start = StateID(UINT_MAX + 1); // invalid start state (out of range)",
          "    assert!(!special.starts()); // should return false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]