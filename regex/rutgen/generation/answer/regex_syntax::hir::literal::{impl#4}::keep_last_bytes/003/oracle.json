[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"a\", b\"foo\", b\"quux\"]);",
          "    seq.keep_last_bytes(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert!(seq.literals().unwrap()[1].is_exact());",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"foo\");",
          "    assert!(seq.literals().unwrap()[2].is_exact());",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"quux\");"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"a\", b\"foo\", b\"quux\"]);",
          "    seq.keep_last_bytes(0);",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert!(seq.literals().unwrap()[1].is_exact());",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"foo\");",
          "    assert!(seq.literals().unwrap()[2].is_exact());",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"quux\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"hello\", b\"world\", b\"rust\"]);",
          "    seq.keep_last_bytes(3);",
          "}"
        ],
        "oracle": [
          "    let mut seq = Seq::new(&[b\"hello\", b\"world\", b\"rust\"]);",
          "    seq.keep_last_bytes(3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"llo\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"rld\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"ust\");",
          "    assert!(seq.literals().unwrap()[0].is_inexact());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"hello\", b\"world\", b\"rust\"]);",
          "    seq.keep_last_bytes(3);",
          "    let mut seq = Seq::new(&[b\"hello\", b\"world\", b\"rust\"]);",
          "    seq.keep_last_bytes(3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"llo\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"rld\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"ust\");",
          "    assert!(seq.literals().unwrap()[0].is_inexact());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"byte\", b\"code\", b\"test\"]);",
          "    seq.keep_last_bytes(4);",
          "}"
        ],
        "oracle": [
          "    assert!(seq.len().unwrap() == 3);",
          "    assert!(seq.literals().unwrap()[0].as_bytes() == b\"byte\");",
          "    assert!(seq.literals().unwrap()[1].is_exact());",
          "    assert!(seq.literals().unwrap()[2].as_bytes() == b\"test\");",
          "    assert!(seq.literals().unwrap()[2].is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"byte\", b\"code\", b\"test\"]);",
          "    seq.keep_last_bytes(4);",
          "    assert!(seq.len().unwrap() == 3);",
          "    assert!(seq.literals().unwrap()[0].as_bytes() == b\"byte\");",
          "    assert!(seq.literals().unwrap()[1].is_exact());",
          "    assert!(seq.literals().unwrap()[2].as_bytes() == b\"test\");",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"short\", b\"longer\", b\"lengthy\"]);",
          "    seq.keep_last_bytes(10);",
          "}"
        ],
        "oracle": [
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert!(seq.literals().unwrap()[0].len() <= 10);",
          "    assert!(seq.literals().unwrap()[1].len() <= 10);",
          "    assert!(seq.literals().unwrap()[2].len() <= 10);",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"short\", b\"longer\", b\"lengthy\"]);",
          "    seq.keep_last_bytes(10);",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert!(seq.literals().unwrap()[0].len() <= 10);",
          "    assert!(seq.literals().unwrap()[1].len() <= 10);",
          "    assert!(seq.literals().unwrap()[2].len() <= 10);",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]