[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 10;",
          "    let pattern_len = Some(5);",
          "    let universal_start_unanchored = Some(StateID(1));",
          "    let universal_start_anchored = Some(StateID(2));",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "    ",
          "    let _ = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_table.table(), &table);",
          "    assert_eq!(_table.kind, kind);",
          "    assert_eq!(_table.start_map, start_map);",
          "    assert_eq!(_table.stride, stride);",
          "    assert_eq!(_table.pattern_len, pattern_len);",
          "    assert_eq!(_table.universal_start_unanchored, universal_start_unanchored);",
          "    assert_eq!(_table.universal_start_anchored, universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 10;",
          "    let pattern_len = Some(5);",
          "    let universal_start_unanchored = Some(StateID(1));",
          "    let universal_start_anchored = Some(StateID(2));",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "    ",
          "    let _ = start_table.as_ref();",
          "    assert_eq!(_table.table(), &table);",
          "    assert_eq!(_table.kind, kind);",
          "    assert_eq!(_table.start_map, start_map);",
          "    assert_eq!(_table.stride, stride);",
          "    assert_eq!(_table.pattern_len, pattern_len);",
          "    assert_eq!(_table.universal_start_unanchored, universal_start_unanchored);",
          "    assert_eq!(_table.universal_start_anchored, universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: [u8; 8] = [1, 1, 1, 1, 1, 1, 1, 1];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 20;",
          "    let pattern_len = Some(3);",
          "    let universal_start_unanchored = Some(StateID(3));",
          "    let universal_start_anchored = None;",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    let table: [u8; 8] = [1, 1, 1, 1, 1, 1, 1, 1];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 20;",
          "    let pattern_len = Some(3);",
          "    let universal_start_unanchored = Some(StateID(3));",
          "    let universal_start_anchored = None;",
          "    let start_table = StartTable {",
          "    table: &table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let result = start_table.as_ref();",
          "    assert_eq!(result.table(), start_table.table());",
          "    assert_eq!(result.kind, start_table.kind);",
          "    assert_eq!(result.start_map, start_table.start_map);",
          "    assert_eq!(result.stride, start_table.stride);",
          "    assert_eq!(result.pattern_len, start_table.pattern_len);",
          "    assert_eq!(result.universal_start_unanchored, start_table.universal_start_unanchored);",
          "    assert_eq!(result.universal_start_anchored, start_table.universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: [u8; 8] = [1, 1, 1, 1, 1, 1, 1, 1];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 20;",
          "    let pattern_len = Some(3);",
          "    let universal_start_unanchored = Some(StateID(3));",
          "    let universal_start_anchored = None;",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "    let table: [u8; 8] = [1, 1, 1, 1, 1, 1, 1, 1];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 20;",
          "    let pattern_len = Some(3);",
          "    let universal_start_unanchored = Some(StateID(3));",
          "    let universal_start_anchored = None;",
          "    let start_table = StartTable {",
          "    table: &table,",
          "    kind,",
          "    start_map,",
          "    stride,",
          "    pattern_len,",
          "    universal_start_unanchored,",
          "    universal_start_anchored,",
          "    };",
          "    let result = start_table.as_ref();",
          "    assert_eq!(result.table(), start_table.table());",
          "    assert_eq!(result.kind, start_table.kind);",
          "    assert_eq!(result.start_map, start_table.start_map);",
          "    assert_eq!(result.stride, start_table.stride);",
          "    assert_eq!(result.pattern_len, start_table.pattern_len);",
          "    assert_eq!(result.universal_start_unanchored, start_table.universal_start_unanchored);",
          "    assert_eq!(result.universal_start_anchored, start_table.universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 5;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = Some(StateID(4));",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    let expected_table: [&u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
          "    let expected_kind = StartKind::Anchored;",
          "    let expected_start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride = 5;",
          "    let expected_pattern_len = Some(0);",
          "    let expected_universal_start_unanchored = None;",
          "    let expected_universal_start_anchored = Some(StateID(4));",
          "    ",
          "    let result = start_table.as_ref();",
          "    assert_eq!(result.table.as_ref(), expected_table);",
          "    assert_eq!(result.kind, expected_kind);",
          "    assert_eq!(result.start_map, expected_start_map);",
          "    assert_eq!(result.stride, expected_stride);",
          "    assert_eq!(result.pattern_len, expected_pattern_len);",
          "    assert_eq!(result.universal_start_unanchored, expected_universal_start_unanchored);",
          "    assert_eq!(result.universal_start_anchored, expected_universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
          "    let kind = StartKind::Anchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 5;",
          "    let pattern_len = Some(0);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = Some(StateID(4));",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "    let expected_table: [&u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
          "    let expected_kind = StartKind::Anchored;",
          "    let expected_start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride = 5;",
          "    let expected_pattern_len = Some(0);",
          "    let expected_universal_start_unanchored = None;",
          "    let expected_universal_start_anchored = Some(StateID(4));",
          "    ",
          "    let result = start_table.as_ref();",
          "    assert_eq!(result.table.as_ref(), expected_table);",
          "    assert_eq!(result.kind, expected_kind);",
          "    assert_eq!(result.start_map, expected_start_map);",
          "    assert_eq!(result.stride, expected_stride);",
          "    assert_eq!(result.pattern_len, expected_pattern_len);",
          "    assert_eq!(result.universal_start_unanchored, expected_universal_start_unanchored);",
          "    assert_eq!(result.universal_start_anchored, expected_universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: [u8; 8] = [10, 20, 30, 40, 50, 60, 70, 80];",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 15;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored = Some(StateID(5));",
          "    let universal_start_anchored = Some(StateID(6));",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    let expected_table: &[u8] = &table;",
          "    let expected_kind = StartKind::Both;",
          "    let expected_start_map = start_table.start_map.clone();",
          "    let expected_stride = 15;",
          "    let expected_pattern_len = None;",
          "    let expected_universal_start_unanchored = Some(StateID(5));",
          "    let expected_universal_start_anchored = Some(StateID(6));",
          "    ",
          "    assert_eq!(_.table(), expected_table);",
          "    assert_eq!(_.kind, expected_kind);",
          "    assert_eq!(_.start_map, expected_start_map);",
          "    assert_eq!(_.stride, expected_stride);",
          "    assert_eq!(_.pattern_len, expected_pattern_len);",
          "    assert_eq!(_.universal_start_unanchored, expected_universal_start_unanchored);",
          "    assert_eq!(_.universal_start_anchored, expected_universal_start_anchored);"
        ],
        "code": [
          "{",
          "    let table: [u8; 8] = [10, 20, 30, 40, 50, 60, 70, 80];",
          "    let kind = StartKind::Both;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 15;",
          "    let pattern_len = None;",
          "    let universal_start_unanchored = Some(StateID(5));",
          "    let universal_start_anchored = Some(StateID(6));",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "    let expected_table: &[u8] = &table;",
          "    let expected_kind = StartKind::Both;",
          "    let expected_start_map = start_table.start_map.clone();",
          "    let expected_stride = 15;",
          "    let expected_pattern_len = None;",
          "    let expected_universal_start_unanchored = Some(StateID(5));",
          "    let expected_universal_start_anchored = Some(StateID(6));",
          "    ",
          "    assert_eq!(_.table(), expected_table);",
          "    assert_eq!(_.kind, expected_kind);",
          "    assert_eq!(_.start_map, expected_start_map);",
          "    assert_eq!(_.stride, expected_stride);",
          "    assert_eq!(_.pattern_len, expected_pattern_len);",
          "    assert_eq!(_.universal_start_unanchored, expected_universal_start_unanchored);",
          "    assert_eq!(_.universal_start_anchored, expected_universal_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let table: [u8; 8] = [0; 8];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 1;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "}"
        ],
        "oracle": [
          "    let expected_table: &[u8] = &[0; 8];",
          "    let expected_kind: StartKind = StartKind::Unanchored;",
          "    let expected_start_map: StartByteMap = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride: usize = 1;",
          "    let expected_pattern_len: Option<usize> = Some(1);",
          "    let expected_universal_start_unanchored: Option<StateID> = None;",
          "    let expected_universal_start_anchored: Option<StateID> = None;",
          "    let expected_start_table = StartTable {",
          "    table: expected_table,",
          "    kind: expected_kind,",
          "    start_map: expected_start_map.clone(),",
          "    stride: expected_stride,",
          "    pattern_len: expected_pattern_len,",
          "    universal_start_unanchored: expected_universal_start_unanchored,",
          "    universal_start_anchored: expected_universal_start_anchored,",
          "    };",
          "    assert_eq!(start_table.as_ref(), expected_start_table);"
        ],
        "code": [
          "{",
          "    let table: [u8; 8] = [0; 8];",
          "    let kind = StartKind::Unanchored;",
          "    let start_map = StartByteMap { map: [Start::default(); 256] };",
          "    let stride = 1;",
          "    let pattern_len = Some(1);",
          "    let universal_start_unanchored = None;",
          "    let universal_start_anchored = None;",
          "",
          "    let start_table = StartTable {",
          "        table: &table,",
          "        kind,",
          "        start_map,",
          "        stride,",
          "        pattern_len,",
          "        universal_start_unanchored,",
          "        universal_start_anchored,",
          "    };",
          "",
          "    let _ = start_table.as_ref();",
          "    let expected_table: &[u8] = &[0; 8];",
          "    let expected_kind: StartKind = StartKind::Unanchored;",
          "    let expected_start_map: StartByteMap = StartByteMap { map: [Start::default(); 256] };",
          "    let expected_stride: usize = 1;",
          "    let expected_pattern_len: Option<usize> = Some(1);",
          "    let expected_universal_start_unanchored: Option<StateID> = None;",
          "    let expected_universal_start_anchored: Option<StateID> = None;",
          "    let expected_start_table = StartTable {",
          "    table: expected_table,",
          "    kind: expected_kind,",
          "    start_map: expected_start_map.clone(),",
          "    stride: expected_stride,",
          "    pattern_len: expected_pattern_len,",
          "    universal_start_unanchored: expected_universal_start_unanchored,",
          "    universal_start_anchored: expected_universal_start_anchored,",
          "    };",
          "    assert_eq!(start_table.as_ref(), expected_start_table);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]