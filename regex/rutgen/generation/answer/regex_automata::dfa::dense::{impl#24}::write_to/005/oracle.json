[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone, Debug)]",
      "struct TestEndian;",
      "impl Endian for TestEndian {",
      "    fn write_u32(value: u32, dst: &mut [u8]) {",
      "        dst[..4].copy_from_slice(&value.to_le_bytes());",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slices = vec![1u32, 2u32, 3u32, 4u32];",
          "    let pattern_ids = vec![5u32, 6u32];",
          "    let pattern_len = 2;",
          "",
          "    let match_states = MatchStates {",
          "        slices: slices.clone(),",
          "        pattern_ids: pattern_ids.clone(),",
          "        pattern_len,",
          "    };",
          "",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "",
          "    match_states.write_to::<TestEndian>(&mut buffer).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.len(), nwrite);",
          "    assert_eq!(buffer[0..4], (match_states.len() as u32).to_le_bytes());",
          "    assert_eq!(buffer[4..12], [(1u32).to_le_bytes(), (2u32).to_le_bytes(), (3u32).to_le_bytes(), (4u32).to_le_bytes()].concat());",
          "    assert_eq!(buffer[12..16], (match_states.pattern_len as u32).to_le_bytes());",
          "    assert_eq!(buffer[16..20], (match_states.pattern_ids().len() as u32).to_le_bytes());",
          "    assert_eq!(buffer[20..24], [(5u32).to_le_bytes(), (6u32).to_le_bytes()].concat());"
        ],
        "code": [
          "{",
          "    let slices = vec![1u32, 2u32, 3u32, 4u32];",
          "    let pattern_ids = vec![5u32, 6u32];",
          "    let pattern_len = 2;",
          "",
          "    let match_states = MatchStates {",
          "        slices: slices.clone(),",
          "        pattern_ids: pattern_ids.clone(),",
          "        pattern_len,",
          "    };",
          "",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "",
          "    match_states.write_to::<TestEndian>(&mut buffer).unwrap();",
          "    assert_eq!(buffer.len(), nwrite);",
          "    assert_eq!(buffer[0..4], (match_states.len() as u32).to_le_bytes());",
          "    assert_eq!(buffer[4..12], [(1u32).to_le_bytes(), (2u32).to_le_bytes(), (3u32).to_le_bytes(), (4u32).to_le_bytes()].concat());",
          "    assert_eq!(buffer[12..16], (match_states.pattern_len as u32).to_le_bytes());",
          "    assert_eq!(buffer[16..20], (match_states.pattern_ids().len() as u32).to_le_bytes());",
          "    assert_eq!(buffer[20..24], [(5u32).to_le_bytes(), (6u32).to_le_bytes()].concat());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slices = vec![1u32, 2u32, 3u32, 4u32];",
          "    let pattern_ids = vec![5u32, 6u32];",
          "    let pattern_len = 2;",
          "",
          "    let match_states = MatchStates {",
          "        slices: slices.clone(),",
          "        pattern_ids: pattern_ids.clone(),",
          "        pattern_len,",
          "    };",
          "",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "",
          "    match_states.write_to::<TestEndian>(&mut buffer).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(match_states.len(), 2);",
          "    assert_eq!(match_states.pattern_len, 2);",
          "    assert_eq!(match_states.slices(), &[PatternID(1), PatternID(2), PatternID(3), PatternID(4)]);",
          "    assert_eq!(match_states.pattern_ids(), &[PatternID(5), PatternID(6)]);",
          "    assert_eq!(match_states.write_to_len(), 40);",
          "    assert!(match_states.write_to::<TestEndian>(&mut buffer).is_ok());",
          "    assert_eq!(buffer[0..4], (2u32.to_le_bytes()));",
          "    assert_eq!(buffer[8..16], (1u32.to_le_bytes()));",
          "    assert_eq!(buffer[16..24], (2u32.to_le_bytes()));",
          "    assert_eq!(buffer[24..32], (3u32.to_le_bytes()));",
          "    assert_eq!(buffer[32..40], (4u32.to_le_bytes()));",
          "    assert_eq!(buffer[36..40], (2u32.to_le_bytes()));",
          "    assert_eq!(buffer[40..44], (5u32.to_le_bytes()));",
          "    assert_eq!(buffer[44..48], (6u32.to_le_bytes()));"
        ],
        "code": [
          "{",
          "    let slices = vec![1u32, 2u32, 3u32, 4u32];",
          "    let pattern_ids = vec![5u32, 6u32];",
          "    let pattern_len = 2;",
          "",
          "    let match_states = MatchStates {",
          "        slices: slices.clone(),",
          "        pattern_ids: pattern_ids.clone(),",
          "        pattern_len,",
          "    };",
          "",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "",
          "    match_states.write_to::<TestEndian>(&mut buffer).unwrap();",
          "    assert_eq!(match_states.len(), 2);",
          "    assert_eq!(match_states.pattern_len, 2);",
          "    assert_eq!(match_states.slices(), &[PatternID(1), PatternID(2), PatternID(3), PatternID(4)]);",
          "    assert_eq!(match_states.pattern_ids(), &[PatternID(5), PatternID(6)]);",
          "    assert_eq!(match_states.write_to_len(), 40);",
          "    assert!(match_states.write_to::<TestEndian>(&mut buffer).is_ok());",
          "    assert_eq!(buffer[0..4], (2u32.to_le_bytes()));",
          "    assert_eq!(buffer[8..16], (1u32.to_le_bytes()));",
          "    assert_eq!(buffer[16..24], (2u32.to_le_bytes()));",
          "    assert_eq!(buffer[24..32], (3u32.to_le_bytes()));",
          "    assert_eq!(buffer[32..40], (4u32.to_le_bytes()));",
          "    assert_eq!(buffer[36..40], (2u32.to_le_bytes()));",
          "    assert_eq!(buffer[40..44], (5u32.to_le_bytes()));",
          "    assert_eq!(buffer[44..48], (6u32.to_le_bytes()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slices = vec![10u32, 20u32, 30u32, 40u32];",
          "    let pattern_ids = vec![50u32];",
          "    let pattern_len = 1;",
          "",
          "    let match_states = MatchStates {",
          "        slices: slices.clone(),",
          "        pattern_ids: pattern_ids.clone(),",
          "        pattern_len,",
          "    };",
          "",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "",
          "    match_states.write_to::<TestEndian>(&mut buffer).unwrap();",
          "}"
        ],
        "oracle": [
          "    let slices = vec![10u32, 20u32, 30u32, 40u32];",
          "    let pattern_ids = vec![50u32];",
          "    let pattern_len = 1;",
          "    ",
          "    let match_states = MatchStates {",
          "    slices: slices.clone(),",
          "    pattern_ids: pattern_ids.clone(),",
          "    pattern_len,",
          "    };",
          "    ",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    ",
          "    assert_eq!(match_states.write_to::<TestEndian>(&mut buffer).unwrap(), nwrite);",
          "    assert!(buffer.len() == nwrite);",
          "    assert!(match_states.slices().len() > 0);",
          "    assert!(match_states.pattern_ids().len() > 0);"
        ],
        "code": [
          "{",
          "    let slices = vec![10u32, 20u32, 30u32, 40u32];",
          "    let pattern_ids = vec![50u32];",
          "    let pattern_len = 1;",
          "",
          "    let match_states = MatchStates {",
          "        slices: slices.clone(),",
          "        pattern_ids: pattern_ids.clone(),",
          "        pattern_len,",
          "    };",
          "",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "",
          "    match_states.write_to::<TestEndian>(&mut buffer).unwrap();",
          "    let slices = vec![10u32, 20u32, 30u32, 40u32];",
          "    let pattern_ids = vec![50u32];",
          "    let pattern_len = 1;",
          "    ",
          "    let match_states = MatchStates {",
          "    slices: slices.clone(),",
          "    pattern_ids: pattern_ids.clone(),",
          "    pattern_len,",
          "    };",
          "    ",
          "    let nwrite = match_states.write_to_len();",
          "    let mut buffer = vec![0u8; nwrite];",
          "    ",
          "    assert_eq!(match_states.write_to::<TestEndian>(&mut buffer).unwrap(), nwrite);",
          "    assert!(buffer.len() == nwrite);",
          "    assert!(match_states.slices().len() > 0);",
          "    assert!(match_states.pattern_ids().len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]