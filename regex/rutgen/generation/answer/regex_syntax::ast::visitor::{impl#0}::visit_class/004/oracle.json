[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        result: Result<(), ()>,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let lhs = ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "        span: Span::new(0, 5),",
          "        kind: ClassSetBinaryOpKind::Union,",
          "        lhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('a')))),",
          "        rhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('b')))),",
          "    }));",
          "",
          "    let rhs = ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "        span: Span::new(6, 10),",
          "        kind: ClassSetBinaryOpKind::Union,",
          "        lhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('c')))),",
          "        rhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('d')))),",
          "    }));",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::new(0, 10),",
          "        negated: false,",
          "        kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "            span: Span::new(0, 10),",
          "            kind: ClassSetBinaryOpKind::Union,",
          "            lhs: Box::new(lhs),",
          "            rhs: Box::new(rhs),",
          "        })),",
          "    };",
          "",
          "    let mut visitor = TestVisitor { result: Ok(()) };",
          "    let mut heap_visitor = HeapVisitor::new();",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "}"
        ],
        "oracle": [
          "    heap_visitor.visit_class_pre(&ast, &visitor).unwrap();",
          "    let x = heap_visitor.induct_class(&ast).unwrap();",
          "    heap_visitor.visit_class_post(&ast, &visitor).unwrap();",
          "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
          "    let x = heap_visitor.pop_class(frame).unwrap();",
          "    heap_visitor.visit_class_post(&post_ast, &visitor).unwrap();",
          "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        result: Result<(), ()>,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let lhs = ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "        span: Span::new(0, 5),",
          "        kind: ClassSetBinaryOpKind::Union,",
          "        lhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('a')))),",
          "        rhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('b')))),",
          "    }));",
          "",
          "    let rhs = ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "        span: Span::new(6, 10),",
          "        kind: ClassSetBinaryOpKind::Union,",
          "        lhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('c')))),",
          "        rhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('d')))),",
          "    }));",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::new(0, 10),",
          "        negated: false,",
          "        kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "            span: Span::new(0, 10),",
          "            kind: ClassSetBinaryOpKind::Union,",
          "            lhs: Box::new(lhs),",
          "            rhs: Box::new(rhs),",
          "        })),",
          "    };",
          "",
          "    let mut visitor = TestVisitor { result: Ok(()) };",
          "    let mut heap_visitor = HeapVisitor::new();",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "    heap_visitor.visit_class_pre(&ast, &visitor).unwrap();",
          "    let x = heap_visitor.induct_class(&ast).unwrap();",
          "    heap_visitor.visit_class_post(&ast, &visitor).unwrap();",
          "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
          "    let x = heap_visitor.pop_class(frame).unwrap();",
          "    heap_visitor.visit_class_post(&post_ast, &visitor).unwrap();",
          "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        result: Result<(), ()>,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::new(0, 10),",
          "        negated: false,",
          "        kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "            span: Span::new(0, 10),",
          "            kind: ClassSetBinaryOpKind::Intersect,",
          "            lhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('a')))),",
          "            rhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('b')))),",
          "        })),",
          "    };",
          "",
          "    let mut visitor = TestVisitor { result: Ok(()) };",
          "    let mut heap_visitor = HeapVisitor::new();",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.visit_class_pre(&ast, visitor).is_ok();",
          "    self.induct_class(&ast).is_some();",
          "    self.visit_class_post(&ast, visitor).is_ok();",
          "    self.stack_class.pop().is_some();",
          "    self.pop_class(frame).is_some();",
          "    self.visit_class_post(&post_ast, visitor).is_ok();",
          "    self.stack_class.pop().is_none();",
          "    self.stack_class.pop().is_none();",
          "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        result: Result<(), ()>,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::new(0, 10),",
          "        negated: false,",
          "        kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "            span: Span::new(0, 10),",
          "            kind: ClassSetBinaryOpKind::Intersect,",
          "            lhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('a')))),",
          "            rhs: Box::new(ClassSet::Item(Box::new(ClassSetItem::Single('b')))),",
          "        })),",
          "    };",
          "",
          "    let mut visitor = TestVisitor { result: Ok(()) };",
          "    let mut heap_visitor = HeapVisitor::new();",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "    self.visit_class_pre(&ast, visitor).is_ok();",
          "    self.induct_class(&ast).is_some();",
          "    self.visit_class_post(&ast, visitor).is_ok();",
          "    self.stack_class.pop().is_some();",
          "    self.pop_class(frame).is_some();",
          "    self.visit_class_post(&post_ast, visitor).is_ok();",
          "    self.stack_class.pop().is_none();",
          "    self.stack_class.pop().is_none();",
          "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        result: Result<(), ()>,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::new(0, 10),",
          "        negated: false,",
          "        kind: ClassSet::Item(Box::new(ClassSetItem::Single('a'))),",
          "    };",
          "",
          "    let mut visitor = TestVisitor { result: Ok(()) };",
          "    let mut heap_visitor = HeapVisitor::new();",
          "    heap_visitor.stack_class.pop(); // ensure the stack is empty",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.visit_class_pre(&ast, visitor).unwrap();",
          "    self.stack_class.push((ast, ClassInduct::from_bracketed(&ast)));",
          "    let child = self.induct_class(&ast).unwrap().child();",
          "    self.visit_class_post(&ast, visitor).unwrap();",
          "    let (post_ast, frame) = self.stack_class.pop().unwrap();",
          "    let pop_frame = self.pop_class(frame).unwrap();",
          "    self.visit_class_post(&post_ast, visitor).unwrap();",
          "    self.stack_class.pop();",
          "    self.stack_class.pop();",
          "    Ok(())"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        result: Result<(), ()>,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::new(0, 10),",
          "        negated: false,",
          "        kind: ClassSet::Item(Box::new(ClassSetItem::Single('a'))),",
          "    };",
          "",
          "    let mut visitor = TestVisitor { result: Ok(()) };",
          "    let mut heap_visitor = HeapVisitor::new();",
          "    heap_visitor.stack_class.pop(); // ensure the stack is empty",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "    self.visit_class_pre(&ast, visitor).unwrap();",
          "    self.stack_class.push((ast, ClassInduct::from_bracketed(&ast)));",
          "    let child = self.induct_class(&ast).unwrap().child();",
          "    self.visit_class_post(&ast, visitor).unwrap();",
          "    let (post_ast, frame) = self.stack_class.pop().unwrap();",
          "    let pop_frame = self.pop_class(frame).unwrap();",
          "    self.visit_class_post(&post_ast, visitor).unwrap();",
          "    self.stack_class.pop();",
          "    self.stack_class.pop();",
          "    Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]