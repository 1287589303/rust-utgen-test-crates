[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        binary_op_called: bool,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            self.binary_op_called = true;",
          "            Err(())",
          "        }",
          "    }",
          "",
          "    let mut visitor = TestVisitor { binary_op_called: false };",
          "    ",
          "    let ast = ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::Item(Box::new(ast::ClassSetItem::Bracketed(ClassBracketed {",
          "            span: Span::default(),",
          "            negated: false,",
          "            kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "                span: Span::default(),",
          "                kind: ClassSetBinaryOpKind::Union,",
          "                lhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')))),",
          "                rhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')))),",
          "            })),",
          "        }))),",
          "    };",
          "",
          "    let mut visitor_impl = HeapVisitor::new();",
          "    visitor_impl.visit_class(&ast, &mut visitor).ok();",
          "}"
        ],
        "oracle": [
          "    self.visit_class_pre(&ast, visitor).is_ok();",
          "    let induct_result = self.induct_class(&ast).is_some();",
          "    self.visit_class_post(&ast, visitor).is_ok();",
          "    self.stack_class.pop().is_some();",
          "    let pop_result = self.pop_class(frame).is_some();",
          "    let frame_is_binary_rhs = matches!(x, ClassFrame::BinaryRHS { .. });",
          "    let visit_result = visitor.visit_class_set_binary_op_in(op).is_err();"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        binary_op_called: bool,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            self.binary_op_called = true;",
          "            Err(())",
          "        }",
          "    }",
          "",
          "    let mut visitor = TestVisitor { binary_op_called: false };",
          "    ",
          "    let ast = ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::Item(Box::new(ast::ClassSetItem::Bracketed(ClassBracketed {",
          "            span: Span::default(),",
          "            negated: false,",
          "            kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "                span: Span::default(),",
          "                kind: ClassSetBinaryOpKind::Union,",
          "                lhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')))),",
          "                rhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')))),",
          "            })),",
          "        }))),",
          "    };",
          "",
          "    let mut visitor_impl = HeapVisitor::new();",
          "    visitor_impl.visit_class(&ast, &mut visitor).ok();",
          "    self.visit_class_pre(&ast, visitor).is_ok();",
          "    let induct_result = self.induct_class(&ast).is_some();",
          "    self.visit_class_post(&ast, visitor).is_ok();",
          "    self.stack_class.pop().is_some();",
          "    let pop_result = self.pop_class(frame).is_some();",
          "    let frame_is_binary_rhs = matches!(x, ClassFrame::BinaryRHS { .. });",
          "    let visit_result = visitor.visit_class_set_binary_op_in(op).is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestVisitor {",
          "        binary_op_called: bool,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            self.binary_op_called = true;",
          "            Err(())",
          "        }",
          "    }",
          "",
          "    let mut visitor = TestVisitor { binary_op_called: false };",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "            span: Span::default(),",
          "            kind: ClassSetBinaryOpKind::Intersection,",
          "            lhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('c')))),",
          "            rhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('d')))),",
          "        })),",
          "    };",
          "",
          "    let mut visitor_impl = HeapVisitor::new();",
          "    visitor_impl.visit_class(&ast, &mut visitor).ok();",
          "}"
        ],
        "oracle": [
          "    self.visit_class_pre(&ast, &mut visitor).unwrap();",
          "    let x = self.induct_class(&ast).unwrap();",
          "    self.visit_class_post(&ast, &mut visitor).unwrap();",
          "    let (post_ast, frame) = self.stack_class.pop().unwrap();",
          "    let x = self.pop_class(frame).unwrap();",
          "    if let ClassFrame::BinaryRHS { ref op, .. } = x {",
          "    assert!(visitor.visit_class_set_binary_op_in(op).is_err());",
          "    }"
        ],
        "code": [
          "{",
          "    struct TestVisitor {",
          "        binary_op_called: bool,",
          "    }",
          "",
          "    impl Visitor for TestVisitor {",
          "        type Output = ();",
          "        type Err = ();",
          "",
          "        fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
          "            self.binary_op_called = true;",
          "            Err(())",
          "        }",
          "    }",
          "",
          "    let mut visitor = TestVisitor { binary_op_called: false };",
          "",
          "    let ast = ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
          "            span: Span::default(),",
          "            kind: ClassSetBinaryOpKind::Intersection,",
          "            lhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('c')))),",
          "            rhs: Box::new(ClassSet::Item(Box::new(ast::ClassSetItem::Single('d')))),",
          "        })),",
          "    };",
          "",
          "    let mut visitor_impl = HeapVisitor::new();",
          "    visitor_impl.visit_class(&ast, &mut visitor).ok();",
          "    self.visit_class_pre(&ast, &mut visitor).unwrap();",
          "    let x = self.induct_class(&ast).unwrap();",
          "    self.visit_class_post(&ast, &mut visitor).unwrap();",
          "    let (post_ast, frame) = self.stack_class.pop().unwrap();",
          "    let x = self.pop_class(frame).unwrap();",
          "    if let ClassFrame::BinaryRHS { ref op, .. } = x {",
          "    assert!(visitor.visit_class_set_binary_op_in(op).is_err());",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]