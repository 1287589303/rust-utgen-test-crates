[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 10, end: 20 }),",
          "    };",
          "    let next_state = StateID(1);",
          "    utf8_node.set_last_transition(next_state);",
          "}"
        ],
        "oracle": [
          "    utf8_node.trans.len() == 1",
          "    utf8_node.trans[0].start == 10",
          "    utf8_node.trans[0].end == 20",
          "    utf8_node.trans[0].next == StateID(1)",
          "    utf8_node.last.is_none()"
        ],
        "code": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 10, end: 20 }),",
          "    };",
          "    let next_state = StateID(1);",
          "    utf8_node.set_last_transition(next_state);",
          "    utf8_node.trans.len() == 1",
          "    utf8_node.trans[0].start == 10",
          "    utf8_node.trans[0].end == 20",
          "    utf8_node.trans[0].next == StateID(1)",
          "    utf8_node.last.is_none()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 0, end: 0 }),",
          "    };",
          "    let next_state = StateID(0);",
          "    utf8_node.set_last_transition(next_state);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 0);",
          "    assert_eq!(utf8_node.trans[0].end, 0);",
          "    assert_eq!(utf8_node.trans[0].next, next_state);",
          "    assert_eq!(utf8_node.last, None);"
        ],
        "code": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 0, end: 0 }),",
          "    };",
          "    let next_state = StateID(0);",
          "    utf8_node.set_last_transition(next_state);",
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 0);",
          "    assert_eq!(utf8_node.trans[0].end, 0);",
          "    assert_eq!(utf8_node.trans[0].next, next_state);",
          "    assert_eq!(utf8_node.last, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 255, end: 255 }),",
          "    };",
          "    let next_state = StateID(255);",
          "    utf8_node.set_last_transition(next_state);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 255);",
          "    assert_eq!(utf8_node.trans[0].end, 255);",
          "    assert_eq!(utf8_node.trans[0].next, StateID(255));",
          "    assert_eq!(utf8_node.last, None);"
        ],
        "code": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 255, end: 255 }),",
          "    };",
          "    let next_state = StateID(255);",
          "    utf8_node.set_last_transition(next_state);",
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 255);",
          "    assert_eq!(utf8_node.trans[0].end, 255);",
          "    assert_eq!(utf8_node.trans[0].next, StateID(255));",
          "    assert_eq!(utf8_node.last, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 123, end: 200 }),",
          "    };",
          "    let next_state = StateID(50);",
          "    utf8_node.set_last_transition(next_state);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 123);",
          "    assert_eq!(utf8_node.trans[0].end, 200);",
          "    assert_eq!(utf8_node.trans[0].next, next_state);",
          "    assert!(utf8_node.last.is_none());"
        ],
        "code": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 123, end: 200 }),",
          "    };",
          "    let next_state = StateID(50);",
          "    utf8_node.set_last_transition(next_state);",
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 123);",
          "    assert_eq!(utf8_node.trans[0].end, 200);",
          "    assert_eq!(utf8_node.trans[0].next, next_state);",
          "    assert!(utf8_node.last.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 5, end: 250 }),",
          "    };",
          "    let next_state = StateID(100);",
          "    utf8_node.set_last_transition(next_state);",
          "}"
        ],
        "oracle": [
          "    let utf8_node = Utf8Node { trans: vec![Transition { start: 5, end: 250, next: StateID(100) }], last: None };",
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 5);",
          "    assert_eq!(utf8_node.trans[0].end, 250);",
          "    assert_eq!(utf8_node.trans[0].next, StateID(100));",
          "    assert!(utf8_node.last.is_none());"
        ],
        "code": [
          "{",
          "    let mut utf8_node = Utf8Node {",
          "        trans: vec![],",
          "        last: Some(Utf8LastTransition { start: 5, end: 250 }),",
          "    };",
          "    let next_state = StateID(100);",
          "    utf8_node.set_last_transition(next_state);",
          "    let utf8_node = Utf8Node { trans: vec![Transition { start: 5, end: 250, next: StateID(100) }], last: None };",
          "    assert_eq!(utf8_node.trans.len(), 1);",
          "    assert_eq!(utf8_node.trans[0].start, 5);",
          "    assert_eq!(utf8_node.trans[0].end, 250);",
          "    assert_eq!(utf8_node.trans[0].next, StateID(100));",
          "    assert!(utf8_node.last.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]