[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        0x02, 0x00, 0x00, 0x00, // state_len = 2",
          "        0x04, 0x00, 0x00, 0x00, // slice offset pair length (4 bytes)",
          "        0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "        0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // second slice offset (2)",
          "        0x01, 0x00, 0x00, 0x00, // second slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // pattern length (2)",
          "        0x02, 0x00, 0x00, 0x00, // pattern ID length (2)",
          "        0x01, 0x00, 0x00, 0x00, // pattern ID 0",
          "        0x02, 0x00, 0x00, 0x00, // pattern ID 1",
          "    ];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let state_len = wire::try_read_u32_as_usize(slice, \"match state length\")?.0;",
          "    let pair_len = wire::mul(2, state_len, \"match state offset pairs\")?;",
          "    let slices_bytes_len = wire::mul(pair_len, PatternID::SIZE, \"match state slice offset byte length\")?;",
          "    wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?;",
          "    wire::check_alignment::<PatternID>(slice)?;",
          "    let pattern_len = wire::try_read_u32_as_usize(slice, \"pattern length\")?.0;",
          "    let idlen = wire::try_read_u32_as_usize(slice, \"pattern ID length\")?.0;",
          "    let pattern_ids_len = wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?;"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        0x02, 0x00, 0x00, 0x00, // state_len = 2",
          "        0x04, 0x00, 0x00, 0x00, // slice offset pair length (4 bytes)",
          "        0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "        0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // second slice offset (2)",
          "        0x01, 0x00, 0x00, 0x00, // second slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // pattern length (2)",
          "        0x02, 0x00, 0x00, 0x00, // pattern ID length (2)",
          "        0x01, 0x00, 0x00, 0x00, // pattern ID 0",
          "        0x02, 0x00, 0x00, 0x00, // pattern ID 1",
          "    ];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    let state_len = wire::try_read_u32_as_usize(slice, \"match state length\")?.0;",
          "    let pair_len = wire::mul(2, state_len, \"match state offset pairs\")?;",
          "    let slices_bytes_len = wire::mul(pair_len, PatternID::SIZE, \"match state slice offset byte length\")?;",
          "    wire::check_slice_len(slice, slices_bytes_len, \"match state slices\")?;",
          "    wire::check_alignment::<PatternID>(slice)?;",
          "    let pattern_len = wire::try_read_u32_as_usize(slice, \"pattern length\")?.0;",
          "    let idlen = wire::try_read_u32_as_usize(slice, \"pattern ID length\")?.0;",
          "    let pattern_ids_len = wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\")?;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        0x01, 0x00, 0x00, 0x00, // state_len = 1",
          "        0x04, 0x00, 0x00, 0x00, // slice offset pair length (4 bytes)",
          "        0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "        0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // pattern length (2)",
          "        0x03, 0x00, 0x00, 0x00, // pattern ID length (3)",
          "        0x01, 0x00, 0x00, 0x00, // pattern ID 0",
          "        0x02, 0x00, 0x00, 0x00, // pattern ID 1",
          "        0x03, 0x00, 0x00, 0x00, // pattern ID 2",
          "    ];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let result = wire::try_read_u32_as_usize(slice, \"match state length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::mul(2, state_len, \"match state offset pairs\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::mul(pair_len, PatternID::SIZE, \"match state slice offset byte length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::check_slice_len(slice, slices_bytes_len, \"match state slices\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::check_alignment::<PatternID>(slice);",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::try_read_u32_as_usize(slice, \"pattern length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::try_read_u32_as_usize(slice, \"pattern ID length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\");",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        0x01, 0x00, 0x00, 0x00, // state_len = 1",
          "        0x04, 0x00, 0x00, 0x00, // slice offset pair length (4 bytes)",
          "        0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "        0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // pattern length (2)",
          "        0x03, 0x00, 0x00, 0x00, // pattern ID length (3)",
          "        0x01, 0x00, 0x00, 0x00, // pattern ID 0",
          "        0x02, 0x00, 0x00, 0x00, // pattern ID 1",
          "        0x03, 0x00, 0x00, 0x00, // pattern ID 2",
          "    ];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    let result = wire::try_read_u32_as_usize(slice, \"match state length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::mul(2, state_len, \"match state offset pairs\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::mul(pair_len, PatternID::SIZE, \"match state slice offset byte length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::check_slice_len(slice, slices_bytes_len, \"match state slices\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::check_alignment::<PatternID>(slice);",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::try_read_u32_as_usize(slice, \"pattern length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::try_read_u32_as_usize(slice, \"pattern ID length\");",
          "    assert!(result.is_ok());",
          "    ",
          "    let result = wire::mul(idlen, PatternID::SIZE, \"pattern ID byte length\");",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        0x03, 0x00, 0x00, 0x00, // state_len = 3",
          "        0x06, 0x00, 0x00, 0x00, // slice offset pair length (6 bytes)",
          "        0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "        0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // second slice offset (2)",
          "        0x01, 0x00, 0x00, 0x00, // second slice length (1)",
          "        0x04, 0x00, 0x00, 0x00, // third slice offset (4)",
          "        0x01, 0x00, 0x00, 0x00, // third slice length (1)",
          "        0x05, 0x00, 0x00, 0x00, // pattern length (5)",
          "        0x00, 0x00, 0x00, 0x00, // pattern ID length (0)",
          "    ];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let slice: &[u8] = &[",
          "    0x03, 0x00, 0x00, 0x00, // state_len = 3",
          "    0x06, 0x00, 0x00, 0x00, // slice offset pair length (6 bytes)",
          "    0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "    0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "    0x02, 0x00, 0x00, 0x00, // second slice offset (2)",
          "    0x01, 0x00, 0x00, 0x00, // second slice length (1)",
          "    0x04, 0x00, 0x00, 0x00, // third slice offset (4)",
          "    0x01, 0x00, 0x00, 0x00, // third slice length (1)",
          "    0x05, 0x00, 0x00, 0x00, // pattern length (5)",
          "    0x00, 0x00, 0x00, 0x00, // pattern ID length (0)",
          "    ];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());",
          "    let (ms, _) = result.unwrap();",
          "    assert_eq!(ms.pattern_len, 5);",
          "    assert_eq!(ms.slices.len(), 6);"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        0x03, 0x00, 0x00, 0x00, // state_len = 3",
          "        0x06, 0x00, 0x00, 0x00, // slice offset pair length (6 bytes)",
          "        0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "        0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "        0x02, 0x00, 0x00, 0x00, // second slice offset (2)",
          "        0x01, 0x00, 0x00, 0x00, // second slice length (1)",
          "        0x04, 0x00, 0x00, 0x00, // third slice offset (4)",
          "        0x01, 0x00, 0x00, 0x00, // third slice length (1)",
          "        0x05, 0x00, 0x00, 0x00, // pattern length (5)",
          "        0x00, 0x00, 0x00, 0x00, // pattern ID length (0)",
          "    ];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    let slice: &[u8] = &[",
          "    0x03, 0x00, 0x00, 0x00, // state_len = 3",
          "    0x06, 0x00, 0x00, 0x00, // slice offset pair length (6 bytes)",
          "    0x00, 0x00, 0x00, 0x00, // first slice offset (0)",
          "    0x01, 0x00, 0x00, 0x00, // first slice length (1)",
          "    0x02, 0x00, 0x00, 0x00, // second slice offset (2)",
          "    0x01, 0x00, 0x00, 0x00, // second slice length (1)",
          "    0x04, 0x00, 0x00, 0x00, // third slice offset (4)",
          "    0x01, 0x00, 0x00, 0x00, // third slice length (1)",
          "    0x05, 0x00, 0x00, 0x00, // pattern length (5)",
          "    0x00, 0x00, 0x00, 0x00, // pattern ID length (0)",
          "    ];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());",
          "    let (ms, _) = result.unwrap();",
          "    assert_eq!(ms.pattern_len, 5);",
          "    assert_eq!(ms.slices.len(), 6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]