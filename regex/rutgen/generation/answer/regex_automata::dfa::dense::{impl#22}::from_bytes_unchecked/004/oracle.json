[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_len: u32 = 1; // one match state",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize; // two pairs for state_len",
          "    let pattern_id_len: u32 = 1; // one pattern ID",
          "",
          "    let slices_bytes_len = (pair_len * 4) as usize; // each pattern ID is 4 bytes",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "",
          "    let mut bytes: Vec<u8> = vec![",
          "        // Mock slice containing the data.",
          "    ];",
          "",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for state length",
          "    bytes.resize(bytes.len() + slices_bytes_len + pattern_ids_len, 0);",
          "",
          "    // Fill slices",
          "    let slices: Vec<u32> = vec![0, 4]; // offsets",
          "    for (i, &b) in slices.iter().enumerate() {",
          "        bytes[8 + (i * 4)..8 + (i * 4) + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "",
          "    bytes.extend_from_slice(&(1 as u32).to_le_bytes()); // pattern length",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for pattern length",
          "",
          "    bytes.extend_from_slice(&(pattern_id_len as u32).to_le_bytes()); // pattern ID length",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for pattern ID length",
          "",
          "    // Fill pattern ids",
          "    let pattern_ids: Vec<u32> = vec![0];",
          "    for (i, &b) in pattern_ids.iter().enumerate() {",
          "        let offset = 8 + slices_bytes_len + (i * 4);",
          "        bytes[offset..offset + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "}"
        ],
        "oracle": [
          "    let state_len: u32 = 1;",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize;",
          "    let pattern_id_len: u32 = 1;",
          "    let slices_bytes_len = (pair_len * 4) as usize;",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "    let mut bytes: Vec<u8> = vec![];",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    bytes.resize(bytes.len() + slices_bytes_len + pattern_ids_len, 0);",
          "    let slices: Vec<u32> = vec![0, 4];",
          "    for (i, &b) in slices.iter().enumerate() {",
          "    bytes[8 + (i * 4)..8 + (i * 4) + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "    bytes.extend_from_slice(&(1 as u32).to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    bytes.extend_from_slice(&(pattern_id_len as u32).to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    let pattern_ids: Vec<u32> = vec![0];",
          "    for (i, &b) in pattern_ids.iter().enumerate() {",
          "    let offset = 8 + slices_bytes_len + (i * 4);",
          "    bytes[offset..offset + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "    assert_eq!(match_states.pattern_len, 1);",
          "    assert_eq!(match_states.slices.len(), 2);",
          "    assert_eq!(match_states.pattern_ids.len(), 1);"
        ],
        "code": [
          "{",
          "    let state_len: u32 = 1; // one match state",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize; // two pairs for state_len",
          "    let pattern_id_len: u32 = 1; // one pattern ID",
          "",
          "    let slices_bytes_len = (pair_len * 4) as usize; // each pattern ID is 4 bytes",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "",
          "    let mut bytes: Vec<u8> = vec![",
          "        // Mock slice containing the data.",
          "    ];",
          "",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for state length",
          "    bytes.resize(bytes.len() + slices_bytes_len + pattern_ids_len, 0);",
          "",
          "    // Fill slices",
          "    let slices: Vec<u32> = vec![0, 4]; // offsets",
          "    for (i, &b) in slices.iter().enumerate() {",
          "        bytes[8 + (i * 4)..8 + (i * 4) + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "",
          "    bytes.extend_from_slice(&(1 as u32).to_le_bytes()); // pattern length",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for pattern length",
          "",
          "    bytes.extend_from_slice(&(pattern_id_len as u32).to_le_bytes()); // pattern ID length",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for pattern ID length",
          "",
          "    // Fill pattern ids",
          "    let pattern_ids: Vec<u32> = vec![0];",
          "    for (i, &b) in pattern_ids.iter().enumerate() {",
          "        let offset = 8 + slices_bytes_len + (i * 4);",
          "        bytes[offset..offset + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "    let state_len: u32 = 1;",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize;",
          "    let pattern_id_len: u32 = 1;",
          "    let slices_bytes_len = (pair_len * 4) as usize;",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "    let mut bytes: Vec<u8> = vec![];",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    bytes.resize(bytes.len() + slices_bytes_len + pattern_ids_len, 0);",
          "    let slices: Vec<u32> = vec![0, 4];",
          "    for (i, &b) in slices.iter().enumerate() {",
          "    bytes[8 + (i * 4)..8 + (i * 4) + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "    bytes.extend_from_slice(&(1 as u32).to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    bytes.extend_from_slice(&(pattern_id_len as u32).to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    let pattern_ids: Vec<u32> = vec![0];",
          "    for (i, &b) in pattern_ids.iter().enumerate() {",
          "    let offset = 8 + slices_bytes_len + (i * 4);",
          "    bytes[offset..offset + 4].copy_from_slice(&b.to_le_bytes());",
          "    }",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "    assert_eq!(match_states.pattern_len, 1);",
          "    assert_eq!(match_states.slices.len(), 2);",
          "    assert_eq!(match_states.pattern_ids.len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut bytes: Vec<u8> = vec![0; 5]; // Not enough data to read state length",
          "",
          "    unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(unsafe { MatchStates::from_bytes_unchecked(&bytes) }, Err(DeserializeError(_))));"
        ],
        "code": [
          "{",
          "    let mut bytes: Vec<u8> = vec![0; 5]; // Not enough data to read state length",
          "",
          "    unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "    assert!(matches!(unsafe { MatchStates::from_bytes_unchecked(&bytes) }, Err(DeserializeError(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let state_len: u32 = 1; // one match state",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize; // two pairs for state_len",
          "    let pattern_id_len: u32 = 1; // one pattern ID",
          "",
          "    let slices_bytes_len = (pair_len * 4) as usize; // each pattern ID is 4 bytes",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "",
          "    let mut bytes: Vec<u8> = vec![",
          "        // Mock slice containing the data.",
          "    ];",
          "",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for state length",
          "    bytes.resize(bytes.len() + slices_bytes_len - 1, 0); // Intentional under-sizing",
          "",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "}"
        ],
        "oracle": [
          "    let state_len: u32 = 1;",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize;",
          "    let pattern_id_len: u32 = 1;",
          "    ",
          "    let slices_bytes_len = (pair_len * 4) as usize;",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "    ",
          "    let mut bytes: Vec<u8> = vec![",
          "    // Mock slice containing the data.",
          "    ];",
          "    ",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    bytes.resize(bytes.len() + slices_bytes_len - 1, 0);",
          "    ",
          "    assert_eq!(wire::try_read_u32_as_usize(&bytes, \"match state length\"), Ok((1, 4)));",
          "    assert_eq!(wire::mul(2, state_len as usize, \"match state offset pairs\"), Ok(2));",
          "    assert_eq!(wire::mul(pair_len, PatternID::SIZE, \"match state slice offset byte length\"), Ok(slices_bytes_len));",
          "    assert_eq!(wire::check_slice_len(&bytes[8..], slices_bytes_len, \"match state slices\").is_err(), true);"
        ],
        "code": [
          "{",
          "    let state_len: u32 = 1; // one match state",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize; // two pairs for state_len",
          "    let pattern_id_len: u32 = 1; // one pattern ID",
          "",
          "    let slices_bytes_len = (pair_len * 4) as usize; // each pattern ID is 4 bytes",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "",
          "    let mut bytes: Vec<u8> = vec![",
          "        // Mock slice containing the data.",
          "    ];",
          "",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes()); // nr for state length",
          "    bytes.resize(bytes.len() + slices_bytes_len - 1, 0); // Intentional under-sizing",
          "",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "    let state_len: u32 = 1;",
          "    let pair_len: usize = (state_len.checked_mul(2).unwrap()) as usize;",
          "    let pattern_id_len: u32 = 1;",
          "    ",
          "    let slices_bytes_len = (pair_len * 4) as usize;",
          "    let pattern_ids_len = (pattern_id_len * 4) as usize;",
          "    ",
          "    let mut bytes: Vec<u8> = vec![",
          "    // Mock slice containing the data.",
          "    ];",
          "    ",
          "    bytes.extend_from_slice(&state_len.to_le_bytes());",
          "    bytes.extend_from_slice(&0_u32.to_le_bytes());",
          "    bytes.resize(bytes.len() + slices_bytes_len - 1, 0);",
          "    ",
          "    assert_eq!(wire::try_read_u32_as_usize(&bytes, \"match state length\"), Ok((1, 4)));",
          "    assert_eq!(wire::mul(2, state_len as usize, \"match state offset pairs\"), Ok(2));",
          "    assert_eq!(wire::mul(pair_len, PatternID::SIZE, \"match state slice offset byte length\"), Ok(slices_bytes_len));",
          "    assert_eq!(wire::check_slice_len(&bytes[8..], slices_bytes_len, \"match state slices\").is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_len: u32 = 0; // No match states",
          "    let bytes: Vec<u8> = state_len.to_le_bytes().to_vec();",
          "",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "    assert_eq!(match_states.pattern_len, 0);",
          "}"
        ],
        "oracle": [
          "    assert!(wire::try_read_u32_as_usize(&bytes, \"match state length\").is_ok());",
          "    assert!(wire::mul(2, 0, \"match state offset pairs\").is_ok());",
          "    assert!(wire::mul(0, PatternID::SIZE, \"match state slice offset byte length\").is_ok());",
          "    assert!(wire::check_slice_len(&bytes, 0, \"match state slices\").is_err());",
          "    assert_eq!(match_states.slices, core::slice::from_ref(&0));",
          "    assert_eq!(match_states.pattern_ids, core::slice::from_ref(&0));"
        ],
        "code": [
          "{",
          "    let state_len: u32 = 0; // No match states",
          "    let bytes: Vec<u8> = state_len.to_le_bytes().to_vec();",
          "",
          "    let (match_states, _) = unsafe { MatchStates::from_bytes_unchecked(&bytes) }.unwrap();",
          "    assert_eq!(match_states.pattern_len, 0);",
          "    assert!(wire::try_read_u32_as_usize(&bytes, \"match state length\").is_ok());",
          "    assert!(wire::mul(2, 0, \"match state offset pairs\").is_ok());",
          "    assert!(wire::mul(0, PatternID::SIZE, \"match state slice offset byte length\").is_ok());",
          "    assert!(wire::check_slice_len(&bytes, 0, \"match state slices\").is_err());",
          "    assert_eq!(match_states.slices, core::slice::from_ref(&0));",
          "    assert_eq!(match_states.pattern_ids, core::slice::from_ref(&0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]