[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: [u8; 32] = [",
          "        0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "        0x04, 0x00, 0x00, 0x00, // slices bytes length (4 bytes for 1 pair)",
          "        0x00, 0x00, 0x00, 0x00, // offset 0",
          "        0x01, 0x00, 0x00, 0x00, // length 1",
          "        0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "        0x01, 0x00, 0x00, 0x00, // idlen (1)",
          "        0x01, 0x00, 0x00, 0x00, // pattern_id 0",
          "    ];",
          "    ",
          "    let slice = &data[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let data: [u8; 32] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data[..]) }.is_ok());",
          "    ",
          "    let data_invalid_length: [u8; 32] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data_invalid_length[..]) }.is_err());",
          "    ",
          "    let data_invalid_alignment: [u8; 16] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data_invalid_alignment[..]) }.is_err());",
          "    ",
          "    let data_minimum_invalid: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data_minimum_invalid[..]) }.is_err());"
        ],
        "code": [
          "{",
          "    let data: [u8; 32] = [",
          "        0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "        0x04, 0x00, 0x00, 0x00, // slices bytes length (4 bytes for 1 pair)",
          "        0x00, 0x00, 0x00, 0x00, // offset 0",
          "        0x01, 0x00, 0x00, 0x00, // length 1",
          "        0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "        0x01, 0x00, 0x00, 0x00, // idlen (1)",
          "        0x01, 0x00, 0x00, 0x00, // pattern_id 0",
          "    ];",
          "    ",
          "    let slice = &data[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    let data: [u8; 32] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data[..]) }.is_ok());",
          "    ",
          "    let data_invalid_length: [u8; 32] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data_invalid_length[..]) }.is_err());",
          "    ",
          "    let data_invalid_alignment: [u8; 16] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data_invalid_alignment[..]) }.is_err());",
          "    ",
          "    let data_minimum_invalid: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    assert!(unsafe { MatchStates::from_bytes_unchecked(&data_minimum_invalid[..]) }.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: [u8; 16] = [",
          "        0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "        0x04, 0x00, 0x00, 0x00, // slices bytes length (4 bytes for 1 pair)",
          "        0x00, 0x00, 0x00, 0x00, // offset 0",
          "        0x01, 0x00, 0x00, 0x00, // length 1",
          "        0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "        0x01, 0x00, 0x00, 0x00, // idlen (1)",
          "    ];",
          "    ",
          "    let slice = &data[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let data: [u8; 16] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    let slice = &data[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let data: [u8; 16] = [",
          "        0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "        0x04, 0x00, 0x00, 0x00, // slices bytes length (4 bytes for 1 pair)",
          "        0x00, 0x00, 0x00, 0x00, // offset 0",
          "        0x01, 0x00, 0x00, 0x00, // length 1",
          "        0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "        0x01, 0x00, 0x00, 0x00, // idlen (1)",
          "    ];",
          "    ",
          "    let slice = &data[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    let data: [u8; 16] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];",
          "    let slice = &data[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let data: [u8; 24] = [",
          "        0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "        0x04, 0x00, 0x00, 0x00, // slice bytes length",
          "        0x00, 0x00, 0x00, 0x00, // offset 0",
          "        0x01, 0x00, 0x00, 0x00, // length 1",
          "        0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // invalid idlen (2), should cause failure",
          "    ];",
          "",
          "    let slice = &data[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let data: [u8; 24] = [",
          "    0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "    0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "    0x04, 0x00, 0x00, 0x00, // slice bytes length",
          "    0x00, 0x00, 0x00, 0x00, // offset 0",
          "    0x01, 0x00, 0x00, 0x00, // length 1",
          "    0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "    0x02, 0x00, 0x00, 0x00, // invalid idlen (2), should cause failure",
          "    ];",
          "    ",
          "    let slice = &data[..];",
          "    ",
          "    assert!(wire::try_read_u32_as_usize(slice, \"match state length\").is_ok());",
          "    assert!(wire::mul(2, 1, \"match state offset pairs\").is_ok());",
          "    assert!(wire::mul(2, PatternID::SIZE, \"match state slice offset byte length\").is_ok());",
          "    assert!(wire::check_slice_len(slice, 4, \"match state slices\").is_ok());",
          "    assert!(wire::check_alignment::<PatternID>(slice).is_ok());",
          "    assert!(wire::try_read_u32_as_usize(slice, \"pattern length\").is_err());"
        ],
        "code": [
          "{",
          "    let data: [u8; 24] = [",
          "        0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "        0x04, 0x00, 0x00, 0x00, // slice bytes length",
          "        0x00, 0x00, 0x00, 0x00, // offset 0",
          "        0x01, 0x00, 0x00, 0x00, // length 1",
          "        0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "        0x02, 0x00, 0x00, 0x00, // invalid idlen (2), should cause failure",
          "    ];",
          "",
          "    let slice = &data[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    let data: [u8; 24] = [",
          "    0x01, 0x00, 0x00, 0x00, // state_len (1)",
          "    0x02, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (2)",
          "    0x04, 0x00, 0x00, 0x00, // slice bytes length",
          "    0x00, 0x00, 0x00, 0x00, // offset 0",
          "    0x01, 0x00, 0x00, 0x00, // length 1",
          "    0x01, 0x00, 0x00, 0x00, // pattern_len (1)",
          "    0x02, 0x00, 0x00, 0x00, // invalid idlen (2), should cause failure",
          "    ];",
          "    ",
          "    let slice = &data[..];",
          "    ",
          "    assert!(wire::try_read_u32_as_usize(slice, \"match state length\").is_ok());",
          "    assert!(wire::mul(2, 1, \"match state offset pairs\").is_ok());",
          "    assert!(wire::mul(2, PatternID::SIZE, \"match state slice offset byte length\").is_ok());",
          "    assert!(wire::check_slice_len(slice, 4, \"match state slices\").is_ok());",
          "    assert!(wire::check_alignment::<PatternID>(slice).is_ok());",
          "    assert!(wire::try_read_u32_as_usize(slice, \"pattern length\").is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: [u8; 512] = [",
          "        // Header",
          "        0x7F, 0x00, 0x00, 0x00, // state_len (127)",
          "        0xFE, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (254)",
          "    ];",
          "    ",
          "    // Fill in the slice offsets and lengths for the maximum valid case",
          "    let mut buffer = data.to_vec();",
          "    for i in 0..127 {",
          "        buffer.extend_from_slice(&[(i * 4) as u32 as u8; 4]); // Offset",
          "        buffer.extend_from_slice(&[1u32 as u8; 4]); // Length",
          "    }",
          "    buffer.extend_from_slice(&[0x7F, 0x00, 0x00, 0x00]); // pattern_len (127)",
          "    buffer.extend_from_slice(&[127u32 as u8; 4]); // idlen (127)",
          "    for i in 0..127 {",
          "        buffer.extend_from_slice(&[i as u8; 4]); // pattern_ids",
          "    }",
          "",
          "    let slice = &buffer[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let slice_invalid_pattern_len = &buffer[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_invalid_pattern_len) };",
          "    assert!(result.is_err());",
          "    ",
          "    let invalid_slice = &[0x7F, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(invalid_slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let data_exceeding_length = vec![0u8; 513];",
          "    let slice_exceeding_length = &data_exceeding_length[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_exceeding_length) };",
          "    assert!(result.is_err());",
          "    ",
          "    let data_incorrect_alignment = vec![0x7F, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x01, 0x02];",
          "    let slice_incorrect_alignment = &data_incorrect_alignment[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_incorrect_alignment) };",
          "    assert!(result.is_err());",
          "    ",
          "    let data_arithmetic_overflow = vec![0xFFFFFFFF; 512];",
          "    let slice_arithmetic_overflow = &data_arithmetic_overflow[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_arithmetic_overflow) };",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let data: [u8; 512] = [",
          "        // Header",
          "        0x7F, 0x00, 0x00, 0x00, // state_len (127)",
          "        0xFE, 0x00, 0x00, 0x00, // pair_len = 2 * state_len (254)",
          "    ];",
          "    ",
          "    // Fill in the slice offsets and lengths for the maximum valid case",
          "    let mut buffer = data.to_vec();",
          "    for i in 0..127 {",
          "        buffer.extend_from_slice(&[(i * 4) as u32 as u8; 4]); // Offset",
          "        buffer.extend_from_slice(&[1u32 as u8; 4]); // Length",
          "    }",
          "    buffer.extend_from_slice(&[0x7F, 0x00, 0x00, 0x00]); // pattern_len (127)",
          "    buffer.extend_from_slice(&[127u32 as u8; 4]); // idlen (127)",
          "    for i in 0..127 {",
          "        buffer.extend_from_slice(&[i as u8; 4]); // pattern_ids",
          "    }",
          "",
          "    let slice = &buffer[..];",
          "    let _ = unsafe { MatchStates::from_bytes_unchecked(slice) };",
          "    let slice_invalid_pattern_len = &buffer[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_invalid_pattern_len) };",
          "    assert!(result.is_err());",
          "    ",
          "    let invalid_slice = &[0x7F, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(invalid_slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let data_exceeding_length = vec![0u8; 513];",
          "    let slice_exceeding_length = &data_exceeding_length[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_exceeding_length) };",
          "    assert!(result.is_err());",
          "    ",
          "    let data_incorrect_alignment = vec![0x7F, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x01, 0x02];",
          "    let slice_incorrect_alignment = &data_incorrect_alignment[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_incorrect_alignment) };",
          "    assert!(result.is_err());",
          "    ",
          "    let data_arithmetic_overflow = vec![0xFFFFFFFF; 512];",
          "    let slice_arithmetic_overflow = &data_arithmetic_overflow[..];",
          "    let result = unsafe { MatchStates::from_bytes_unchecked(slice_arithmetic_overflow) };",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]