[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_state_id = StateID(1); // Use an arbitrary valid StateID",
          "    let mut sparse_set = SparseSet::new(2);",
          "    sparse_set.insert(nfa_state_id);",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::Start));",
          "",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    assert!(!builder.look_need().is_empty());",
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert!(builder.look_need().len() == 1);",
          "    assert!(builder.look_have().is_empty());",
          "    assert!(builder.memory_usage() > 0);"
        ],
        "code": [
          "{",
          "    let nfa_state_id = StateID(1); // Use an arbitrary valid StateID",
          "    let mut sparse_set = SparseSet::new(2);",
          "    sparse_set.insert(nfa_state_id);",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::Start));",
          "",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "    assert!(!builder.look_need().is_empty());",
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert!(builder.look_need().len() == 1);",
          "    assert!(builder.look_have().is_empty());",
          "    assert!(builder.memory_usage() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_state_id = StateID(2); // Use an arbitrary valid StateID",
          "    let mut sparse_set = SparseSet::new(2);",
          "    sparse_set.insert(nfa_state_id);",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(1),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::End));",
          "",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    assert!(builder.look_need().contains(Look::End));",
          "    assert_eq!(builder.prev_nfa_state_id, StateID(1));",
          "    assert!(builder.repr.is_empty());",
          "    assert!(sparse_set.contains(nfa_state_id));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert!(!builder.look_need().is_empty());",
          "    assert!(builder.repr.is_empty() || builder.repr.iter().next().is_none());",
          "    assert!(builder.look_have().is_empty());",
          "    builder.add_nfa_state_id(nfa_state_id);",
          "    assert!(builder.look_need().contains(Look::End));",
          "    assert!(builder.look_have().contains(LookSet::empty()));",
          "    assert_eq!(builder.look_need().len(), 1);"
        ],
        "code": [
          "{",
          "    let nfa_state_id = StateID(2); // Use an arbitrary valid StateID",
          "    let mut sparse_set = SparseSet::new(2);",
          "    sparse_set.insert(nfa_state_id);",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(1),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::End));",
          "",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "    assert!(builder.look_need().contains(Look::End));",
          "    assert_eq!(builder.prev_nfa_state_id, StateID(1));",
          "    assert!(builder.repr.is_empty());",
          "    assert!(sparse_set.contains(nfa_state_id));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert!(!builder.look_need().is_empty());",
          "    assert!(builder.repr.is_empty() || builder.repr.iter().next().is_none());",
          "    assert!(builder.look_have().is_empty());",
          "    builder.add_nfa_state_id(nfa_state_id);",
          "    assert!(builder.look_need().contains(Look::End));",
          "    assert!(builder.look_have().contains(LookSet::empty()));",
          "    assert_eq!(builder.look_need().len(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_state_id = StateID(3); // Use an arbitrary valid StateID",
          "    let mut sparse_set = SparseSet::new(2);",
          "    sparse_set.insert(nfa_state_id);",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(2),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::full());",
          "",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    builder.add_nfa_state_id(nfa_state_id);",
          "    builder.set_look_need(|need| need.insert(Look::Union));",
          "    builder.set_look_have(|_| LookSet::full());",
          "    builder.look_need().is_empty();"
        ],
        "code": [
          "{",
          "    let nfa_state_id = StateID(3); // Use an arbitrary valid StateID",
          "    let mut sparse_set = SparseSet::new(2);",
          "    sparse_set.insert(nfa_state_id);",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(2),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::full());",
          "",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "    builder.add_nfa_state_id(nfa_state_id);",
          "    builder.set_look_need(|need| need.insert(Look::Union));",
          "    builder.set_look_have(|_| LookSet::full());",
          "    builder.look_need().is_empty();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]