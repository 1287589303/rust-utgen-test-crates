[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = thompson::NFA::new(\"abc\").unwrap();",
          "    let mut set = SparseSet::new(3);",
          "    let state_id_1 = StateID(0);",
          "    let state_id_2 = StateID(1);",
          "    let state_id_3 = StateID(2);",
          "    set.insert(state_id_1);",
          "    set.insert(state_id_2);",
          "    set.insert(state_id_3);",
          "    let mut builder = StateBuilderNFA {",
          "        repr: Vec::new(),",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    builder.set_look_need(|_| LookSet::singleton(Look::Start));",
          "",
          "    add_nfa_states(&nfa, &set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert_eq!(builder.as_bytes().len(), 0);",
          "    assert!(builder.repr.is_empty());",
          "    assert!(builder.look_need().contains_word_ascii() == false);",
          "    assert!(builder.look_need().contains_word_unicode() == false);",
          "    assert!(builder.look_need().contains_anchor() == false);",
          "    assert!(builder.look_need().contains_anchor_haystack() == false);",
          "    assert!(builder.look_need().contains_anchor_line() == false);",
          "    assert!(builder.look_need().contains_anchor_lf() == false);",
          "    assert!(builder.look_need().contains_anchor_crlf() == false);",
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert!(set.len() == 3);",
          "    assert!(set.contains(state_id_1));",
          "    assert!(set.contains(state_id_2));",
          "    assert!(set.contains(state_id_3));"
        ],
        "code": [
          "{",
          "    let nfa = thompson::NFA::new(\"abc\").unwrap();",
          "    let mut set = SparseSet::new(3);",
          "    let state_id_1 = StateID(0);",
          "    let state_id_2 = StateID(1);",
          "    let state_id_3 = StateID(2);",
          "    set.insert(state_id_1);",
          "    set.insert(state_id_2);",
          "    set.insert(state_id_3);",
          "    let mut builder = StateBuilderNFA {",
          "        repr: Vec::new(),",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    builder.set_look_need(|_| LookSet::singleton(Look::Start));",
          "",
          "    add_nfa_states(&nfa, &set, &mut builder);",
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert_eq!(builder.as_bytes().len(), 0);",
          "    assert!(builder.repr.is_empty());",
          "    assert!(builder.look_need().contains_word_ascii() == false);",
          "    assert!(builder.look_need().contains_word_unicode() == false);",
          "    assert!(builder.look_need().contains_anchor() == false);",
          "    assert!(builder.look_need().contains_anchor_haystack() == false);",
          "    assert!(builder.look_need().contains_anchor_line() == false);",
          "    assert!(builder.look_need().contains_anchor_lf() == false);",
          "    assert!(builder.look_need().contains_anchor_crlf() == false);",
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert!(set.len() == 3);",
          "    assert!(set.contains(state_id_1));",
          "    assert!(set.contains(state_id_2));",
          "    assert!(set.contains(state_id_3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let nfa = thompson::NFA::new(\"abc\").unwrap();",
          "    let mut set = SparseSet::new(1);",
          "    set.insert(StateID(0));",
          "    let mut builder = StateBuilderNFA {",
          "        repr: Vec::new(),",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "",
          "    add_nfa_states(&nfa, &set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert!(set.len() == 1);",
          "    assert!(builder.prev_nfa_state_id.0 == 0);",
          "    assert!(builder.repr.is_empty());",
          "    assert!(set.contains(StateID(0)) == true);",
          "    assert!(set.contains(StateID(1)) == false);",
          "    assert!(matches!(nfa.state(StateID(0)), thompson::State::ByteRange { .. }));"
        ],
        "code": [
          "{",
          "    let nfa = thompson::NFA::new(\"abc\").unwrap();",
          "    let mut set = SparseSet::new(1);",
          "    set.insert(StateID(0));",
          "    let mut builder = StateBuilderNFA {",
          "        repr: Vec::new(),",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "",
          "    add_nfa_states(&nfa, &set, &mut builder);",
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert!(set.len() == 1);",
          "    assert!(builder.prev_nfa_state_id.0 == 0);",
          "    assert!(builder.repr.is_empty());",
          "    assert!(set.contains(StateID(0)) == true);",
          "    assert!(set.contains(StateID(1)) == false);",
          "    assert!(matches!(nfa.state(StateID(0)), thompson::State::ByteRange { .. }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa = thompson::NFA::new(\"abc\").unwrap();",
          "    let mut set = SparseSet::new(1);",
          "    let state_id = StateID(1);",
          "    set.insert(state_id);",
          "    let mut builder = StateBuilderNFA {",
          "        repr: Vec::new(),",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    builder.set_look_need(|_| LookSet::full());",
          "",
          "    add_nfa_states(&nfa, &set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert!(builder.look_need().contains(Look::End));",
          "    assert!(builder.look_need().contains(Look::WordAscii));",
          "    assert!(builder.look_need().contains(Look::WordUnicode));",
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert_eq!(builder.prev_nfa_state_id, StateID(1));",
          "    assert_eq!(builder.repr.len(), 0);",
          "    assert!(builder.look_need().contains(Look::StartLF));",
          "    assert!(builder.look_need().contains(Look::EndLF));",
          "    assert!(builder.look_need().contains(Look::WordAsciiNegate));",
          "    assert!(builder.look_need().contains(Look::WordUnicodeNegate));",
          "    assert!(builder.look_need().contains(Look::WordStartAscii));",
          "    assert!(builder.look_need().contains(Look::WordEndAscii));",
          "    assert!(builder.look_need().contains(Look::WordStartUnicode));",
          "    assert!(builder.look_need().contains(Look::WordEndUnicode));",
          "    assert!(builder.look_need().contains(Look::WordStartHalfAscii));",
          "    assert!(builder.look_need().contains(Look::WordEndHalfAscii));",
          "    assert!(builder.look_need().contains(Look::WordStartHalfUnicode));",
          "    assert!(builder.look_need().contains(Look::WordEndHalfUnicode));",
          "    assert!(builder.look_need().len() > 0);"
        ],
        "code": [
          "{",
          "    let nfa = thompson::NFA::new(\"abc\").unwrap();",
          "    let mut set = SparseSet::new(1);",
          "    let state_id = StateID(1);",
          "    set.insert(state_id);",
          "    let mut builder = StateBuilderNFA {",
          "        repr: Vec::new(),",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    builder.set_look_need(|_| LookSet::full());",
          "",
          "    add_nfa_states(&nfa, &set, &mut builder);",
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert!(builder.look_need().contains(Look::End));",
          "    assert!(builder.look_need().contains(Look::WordAscii));",
          "    assert!(builder.look_need().contains(Look::WordUnicode));",
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert_eq!(builder.prev_nfa_state_id, StateID(1));",
          "    assert_eq!(builder.repr.len(), 0);",
          "    assert!(builder.look_need().contains(Look::StartLF));",
          "    assert!(builder.look_need().contains(Look::EndLF));",
          "    assert!(builder.look_need().contains(Look::WordAsciiNegate));",
          "    assert!(builder.look_need().contains(Look::WordUnicodeNegate));",
          "    assert!(builder.look_need().contains(Look::WordStartAscii));",
          "    assert!(builder.look_need().contains(Look::WordEndAscii));",
          "    assert!(builder.look_need().contains(Look::WordStartUnicode));",
          "    assert!(builder.look_need().contains(Look::WordEndUnicode));",
          "    assert!(builder.look_need().contains(Look::WordStartHalfAscii));",
          "    assert!(builder.look_need().contains(Look::WordEndHalfAscii));",
          "    assert!(builder.look_need().contains(Look::WordStartHalfUnicode));",
          "    assert!(builder.look_need().contains(Look::WordEndHalfUnicode));",
          "    assert!(builder.look_need().len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]