[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_id_fail = StateID(1);",
          "    let nfa_id_byte_range = StateID(2);",
          "    let nfa_id_dense = StateID(3);",
          "",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::Start));",
          "    ",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail);",
          "    sparse_set.insert(nfa_id_byte_range);",
          "    sparse_set.insert(nfa_id_dense);",
          "",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    builder.add_nfa_state_id(StateID(1));",
          "    builder.add_nfa_state_id(StateID(3));",
          "    builder.set_look_need(|need| need.insert(Look::Start));",
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert!(sparse_set.contains(nfa_id_fail));",
          "    assert!(!sparse_set.contains(StateID(4)));",
          "    assert!(!builder.look_need().is_empty());"
        ],
        "code": [
          "{",
          "    let nfa_id_fail = StateID(1);",
          "    let nfa_id_byte_range = StateID(2);",
          "    let nfa_id_dense = StateID(3);",
          "",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::Start));",
          "    ",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail);",
          "    sparse_set.insert(nfa_id_byte_range);",
          "    sparse_set.insert(nfa_id_dense);",
          "",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "    builder.add_nfa_state_id(StateID(1));",
          "    builder.add_nfa_state_id(StateID(3));",
          "    builder.set_look_need(|need| need.insert(Look::Start));",
          "    assert!(builder.look_need().contains(Look::Start));",
          "    assert!(sparse_set.contains(nfa_id_fail));",
          "    assert!(!sparse_set.contains(StateID(4)));",
          "    assert!(!builder.look_need().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_id_fail1 = StateID(1);",
          "    let nfa_id_fail2 = StateID(2);",
          "    let nfa_id_sparse = StateID(3);",
          "",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::End));",
          "",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail1);",
          "    sparse_set.insert(nfa_id_fail2);",
          "    sparse_set.insert(nfa_id_sparse);",
          "",
          "    let nfa = thompson::NFA::never_match();",
          "    ",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    builder.look_need().is_empty() == false",
          "    sparse_set.contains(nfa_id_fail1) == true",
          "    sparse_set.contains(nfa_id_fail2) == true",
          "    sparse_set.contains(nfa_id_sparse) == true",
          "    builder.prev_nfa_state_id == StateID(0)",
          "    builder.repr.len() > 0",
          "    builder.look_need().contains(Look::End) == true"
        ],
        "code": [
          "{",
          "    let nfa_id_fail1 = StateID(1);",
          "    let nfa_id_fail2 = StateID(2);",
          "    let nfa_id_sparse = StateID(3);",
          "",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::End));",
          "",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail1);",
          "    sparse_set.insert(nfa_id_fail2);",
          "    sparse_set.insert(nfa_id_sparse);",
          "",
          "    let nfa = thompson::NFA::never_match();",
          "    ",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "    builder.look_need().is_empty() == false",
          "    sparse_set.contains(nfa_id_fail1) == true",
          "    sparse_set.contains(nfa_id_fail2) == true",
          "    sparse_set.contains(nfa_id_sparse) == true",
          "    builder.prev_nfa_state_id == StateID(0)",
          "    builder.repr.len() > 0",
          "    builder.look_need().contains(Look::End) == true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let nfa_id_fail = StateID(1);",
          "    let nfa_id_look = StateID(2);",
          "    let nfa_id_dense = StateID(3);",
          "",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::WordAscii));",
          "",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail);",
          "    sparse_set.insert(nfa_id_look);",
          "    sparse_set.insert(nfa_id_dense);",
          "",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "}"
        ],
        "oracle": [
          "    let nfa_id_fail = StateID(1);",
          "    let nfa_id_look = StateID(2);",
          "    let nfa_id_dense = StateID(3);",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "    repr: vec![],",
          "    prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::WordAscii));",
          "    ",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail);",
          "    sparse_set.insert(nfa_id_look);",
          "    sparse_set.insert(nfa_id_dense);",
          "    ",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    assert!(builder.look_need().contains(Look::WordAscii));",
          "    assert!(builder.look_need().len() == 1);",
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert!(sparse_set.contains(nfa_id_fail));",
          "    assert!(sparse_set.contains(nfa_id_look));",
          "    assert!(sparse_set.contains(nfa_id_dense));",
          "    assert!(builder.prev_nfa_state_id == StateID(0));",
          "    assert!(builder.repr.is_empty());"
        ],
        "code": [
          "{",
          "    let nfa_id_fail = StateID(1);",
          "    let nfa_id_look = StateID(2);",
          "    let nfa_id_dense = StateID(3);",
          "",
          "    let mut builder = StateBuilderNFA {",
          "        repr: vec![],",
          "        prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::WordAscii));",
          "",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail);",
          "    sparse_set.insert(nfa_id_look);",
          "    sparse_set.insert(nfa_id_dense);",
          "",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    add_nfa_states(&nfa, &sparse_set, &mut builder);",
          "    let nfa_id_fail = StateID(1);",
          "    let nfa_id_look = StateID(2);",
          "    let nfa_id_dense = StateID(3);",
          "    ",
          "    let mut builder = StateBuilderNFA {",
          "    repr: vec![],",
          "    prev_nfa_state_id: StateID(0),",
          "    };",
          "    ",
          "    builder.set_look_need(|_| LookSet::singleton(Look::WordAscii));",
          "    ",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(nfa_id_fail);",
          "    sparse_set.insert(nfa_id_look);",
          "    sparse_set.insert(nfa_id_dense);",
          "    ",
          "    let nfa = thompson::NFA::always_match();",
          "    ",
          "    assert!(builder.look_need().contains(Look::WordAscii));",
          "    assert!(builder.look_need().len() == 1);",
          "    assert!(builder.look_need().is_empty() == false);",
          "    assert!(sparse_set.contains(nfa_id_fail));",
          "    assert!(sparse_set.contains(nfa_id_look));",
          "    assert!(sparse_set.contains(nfa_id_dense));",
          "    assert!(builder.prev_nfa_state_id == StateID(0));",
          "    assert!(builder.repr.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]