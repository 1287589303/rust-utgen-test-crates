[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"valid\";",
          "    let at: usize = 0;",
          "    let _ = fwd(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(fwd(b\"valid\", 0), Ok(true));",
          "    assert_eq!(fwd(b\"\\xff\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"\\x80\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"\", 0), Err(super::UnicodeWordBoundaryError::new()));",
          "    assert_eq!(fwd(b\"valid\", 5), Err(super::UnicodeWordBoundaryError::new()));",
          "    assert_eq!(fwd(b\"invalid\\xff\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"invalid\\x80\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid\", 1), Ok(true));",
          "    assert_eq!(fwd(b\"valid\", 2), Ok(true));",
          "    assert_eq!(fwd(b\"valid\", 3), Ok(true));",
          "    assert_eq!(fwd(b\"valid\", 4), Ok(true));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"valid\";",
          "    let at: usize = 0;",
          "    let _ = fwd(haystack, at);",
          "    assert_eq!(fwd(b\"valid\", 0), Ok(true));",
          "    assert_eq!(fwd(b\"\\xff\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"\\x80\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"\", 0), Err(super::UnicodeWordBoundaryError::new()));",
          "    assert_eq!(fwd(b\"valid\", 5), Err(super::UnicodeWordBoundaryError::new()));",
          "    assert_eq!(fwd(b\"invalid\\xff\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"invalid\\x80\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid\", 1), Ok(true));",
          "    assert_eq!(fwd(b\"valid\", 2), Ok(true));",
          "    assert_eq!(fwd(b\"valid\", 3), Ok(true));",
          "    assert_eq!(fwd(b\"valid\", 4), Ok(true));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = &[0xFF]; // Invalid UTF-8 byte",
          "    let at: usize = 0;",
          "    let _ = fwd(haystack, at);",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = &[0xFF]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(false));",
          "    let haystack: &[u8] = &[0xC2, 0xA0]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(true));",
          "    let haystack: &[u8] = &[0x00]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(true));",
          "    let haystack: &[u8] = b\"\"; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(false));",
          "    let haystack: &[u8] = &[0xFF, 0xFF]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(false));",
          "    let haystack: &[u8] = &[0xE2, 0x82, 0xAC]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(true));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = &[0xFF]; // Invalid UTF-8 byte",
          "    let at: usize = 0;",
          "    let _ = fwd(haystack, at);",
          "    let haystack: &[u8] = &[0xFF]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(false));",
          "    let haystack: &[u8] = &[0xC2, 0xA0]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(true));",
          "    let haystack: &[u8] = &[0x00]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(true));",
          "    let haystack: &[u8] = b\"\"; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(false));",
          "    let haystack: &[u8] = &[0xFF, 0xFF]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(false));",
          "    let haystack: &[u8] = &[0xE2, 0x82, 0xAC]; let at: usize = 0; assert_eq!(fwd(haystack, at), Ok(true));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = &[];",
          "    let at: usize = 0; // At the start of an empty slice",
          "    let _ = fwd(haystack, at);",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = &[0xE2, 0x9C, 0x94]; // Valid UTF-8 sequence (check for success case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(true));",
          "    ",
          "    let haystack: &[u8] = &[0x80, 0xFF]; // Invalid UTF-8 byte sequence (check for error handling)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(false));",
          "    ",
          "    let haystack: &[u8] = &[0x00]; // Single null byte (check for boundary case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(false));",
          "    ",
          "    let haystack: &[u8] = &[0xC3, 0xA9]; // Valid UTF-8 sequence (check for success case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(true));",
          "    ",
          "    let haystack: &[u8] = &[]; // Test with an empty slice (check for None case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(false));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = &[];",
          "    let at: usize = 0; // At the start of an empty slice",
          "    let _ = fwd(haystack, at);",
          "    let haystack: &[u8] = &[0xE2, 0x9C, 0x94]; // Valid UTF-8 sequence (check for success case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(true));",
          "    ",
          "    let haystack: &[u8] = &[0x80, 0xFF]; // Invalid UTF-8 byte sequence (check for error handling)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(false));",
          "    ",
          "    let haystack: &[u8] = &[0x00]; // Single null byte (check for boundary case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(false));",
          "    ",
          "    let haystack: &[u8] = &[0xC3, 0xA9]; // Valid UTF-8 sequence (check for success case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(true));",
          "    ",
          "    let haystack: &[u8] = &[]; // Test with an empty slice (check for None case)",
          "    let at: usize = 0;",
          "    let result = fwd(haystack, at);",
          "    assert_eq!(result, Ok(false));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"example\";",
          "    let at: usize = 3; // Starting at 'm'",
          "    let _ = fwd(haystack, at);",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"\"; let at: usize = 0; let result = fwd(haystack, at); assert_eq!(result, Ok(false));",
          "    let haystack: &[u8] = b\"invalid\\xff\"; let at: usize = 0; let result = fwd(haystack, at); assert_eq!(result, Ok(false));",
          "    let haystack: &[u8] = b\"valid\"; let at: usize = 1; let result = fwd(haystack, at); assert_eq!(result, Ok(true));",
          "    let haystack: &[u8] = b\"example\"; let at: usize = 6; let result = fwd(haystack, at); assert_eq!(result, Ok(false));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"example\";",
          "    let at: usize = 3; // Starting at 'm'",
          "    let _ = fwd(haystack, at);",
          "    let haystack: &[u8] = b\"\"; let at: usize = 0; let result = fwd(haystack, at); assert_eq!(result, Ok(false));",
          "    let haystack: &[u8] = b\"invalid\\xff\"; let at: usize = 0; let result = fwd(haystack, at); assert_eq!(result, Ok(false));",
          "    let haystack: &[u8] = b\"valid\"; let at: usize = 1; let result = fwd(haystack, at); assert_eq!(result, Ok(true));",
          "    let haystack: &[u8] = b\"example\"; let at: usize = 6; let result = fwd(haystack, at); assert_eq!(result, Ok(false));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"end\";",
          "    let at: usize = 2; // At the end of the slice",
          "    let _ = fwd(haystack, at);",
          "}"
        ],
        "oracle": [
          "    Ok(false);",
          "    Ok(true);",
          "    Err(super::UnicodeWordBoundaryError::new());",
          "    Some(Ok('d'));",
          "    Some(Err(b'e'));",
          "    Some(Err(b'n'));",
          "    None;",
          "    try_is_word_character('d').expect(\"expect success\");",
          "    try_is_word_character('e').expect(\"expect success\");",
          "    try_is_word_character('n').expect(\"expect success\");"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"end\";",
          "    let at: usize = 2; // At the end of the slice",
          "    let _ = fwd(haystack, at);",
          "    Ok(false);",
          "    Ok(true);",
          "    Err(super::UnicodeWordBoundaryError::new());",
          "    Some(Ok('d'));",
          "    Some(Err(b'e'));",
          "    Some(Err(b'n'));",
          "    None;",
          "    try_is_word_character('d').expect(\"expect success\");",
          "    try_is_word_character('e').expect(\"expect success\");",
          "    try_is_word_character('n').expect(\"expect success\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"partial \\xFF\"; // Valid followed by invalid",
          "    let at: usize = 8; // At the position of the invalid byte",
          "    let _ = fwd(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(fwd(b\"valid \\xFF\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\x00\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid c\", 6), Ok(true));",
          "    assert_eq!(fwd(b\"valid \\xC3\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\xE0\\xA0\", 6), Ok(true));",
          "    assert_eq!(fwd(b\"\\xFF\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\xED\\xA0\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\x7F\", 6), Ok(true));",
          "    assert_eq!(fwd(b\"\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"\\xC3\\xA9\", 0), Ok(true));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"partial \\xFF\"; // Valid followed by invalid",
          "    let at: usize = 8; // At the position of the invalid byte",
          "    let _ = fwd(haystack, at);",
          "    assert_eq!(fwd(b\"valid \\xFF\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\x00\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid c\", 6), Ok(true));",
          "    assert_eq!(fwd(b\"valid \\xC3\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\xE0\\xA0\", 6), Ok(true));",
          "    assert_eq!(fwd(b\"\\xFF\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\xED\\xA0\", 6), Ok(false));",
          "    assert_eq!(fwd(b\"valid \\x7F\", 6), Ok(true));",
          "    assert_eq!(fwd(b\"\", 0), Ok(false));",
          "    assert_eq!(fwd(b\"\\xC3\\xA9\", 0), Ok(true));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]