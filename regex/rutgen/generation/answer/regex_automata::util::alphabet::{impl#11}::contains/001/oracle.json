[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_set = ByteSet::empty();",
          "    assert!(!byte_set.contains(0));",
          "    assert!(!byte_set.contains(127));",
          "    assert!(!byte_set.contains(128));",
          "    assert!(!byte_set.contains(255));",
          "}"
        ],
        "oracle": [
          "    assert!(!byte_set.contains(0));  // Test for byte 0 not in empty ByteSet",
          "    assert!(!byte_set.contains(127));  // Test for byte 127 not in empty ByteSet",
          "    assert!(!byte_set.contains(128));  // Test for byte 128 not in empty ByteSet (out of range)",
          "    assert!(!byte_set.contains(255));  // Test for byte 255 not in empty ByteSet (out of range)"
        ],
        "code": [
          "{",
          "    let byte_set = ByteSet::empty();",
          "    assert!(!byte_set.contains(0));",
          "    assert!(!byte_set.contains(127));",
          "    assert!(!byte_set.contains(128));",
          "    assert!(!byte_set.contains(255));",
          "    assert!(!byte_set.contains(0));  // Test for byte 0 not in empty ByteSet",
          "    assert!(!byte_set.contains(127));  // Test for byte 127 not in empty ByteSet",
          "    assert!(!byte_set.contains(128));  // Test for byte 128 not in empty ByteSet (out of range)",
          "    assert!(!byte_set.contains(255));  // Test for byte 255 not in empty ByteSet (out of range)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    assert!(byte_set.contains(0));",
          "    assert!(!byte_set.contains(1));",
          "",
          "    byte_set.add(255);",
          "    assert!(byte_set.contains(255));",
          "    assert!(!byte_set.contains(254));",
          "}"
        ],
        "oracle": [
          "    assert!(byte_set.contains(0)); // Test if contains returns true for added byte 0",
          "    assert!(!byte_set.contains(1)); // Test if contains returns false for non-added byte 1",
          "    assert!(byte_set.contains(255)); // Test if contains returns true for added byte 255",
          "    assert!(!byte_set.contains(254)); // Test if contains returns false for non-added byte 254"
        ],
        "code": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(0);",
          "    assert!(byte_set.contains(0));",
          "    assert!(!byte_set.contains(1));",
          "",
          "    byte_set.add(255);",
          "    assert!(byte_set.contains(255));",
          "    assert!(!byte_set.contains(254));",
          "    assert!(byte_set.contains(0)); // Test if contains returns true for added byte 0",
          "    assert!(!byte_set.contains(1)); // Test if contains returns false for non-added byte 1",
          "    assert!(byte_set.contains(255)); // Test if contains returns true for added byte 255",
          "    assert!(!byte_set.contains(254)); // Test if contains returns false for non-added byte 254",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    for byte in 0..=255 {",
          "        byte_set.add(byte);",
          "    }",
          "    for byte in 0..=255 {",
          "        assert!(byte_set.contains(byte));",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert!(ByteSet::empty().contains(0) == false);",
          "    assert!(ByteSet::empty().contains(255) == false);",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(1);",
          "    assert!(byte_set.contains(1) == true);",
          "    assert!(byte_set.contains(0) == false);",
          "    byte_set.add(128);",
          "    assert!(byte_set.contains(128) == true);",
          "    assert!(byte_set.contains(129) == false);",
          "    byte_set.remove(1);",
          "    assert!(byte_set.contains(1) == false);",
          "    assert!(byte_set.contains(128) == true);",
          "    assert!(byte_set.contains(255) == false);",
          "    byte_set.remove(128);",
          "    assert!(byte_set.contains(128) == false);",
          "    for byte in 0..=255 {",
          "    assert!(byte_set.contains(byte) == false);",
          "    }",
          "    byte_set.add(255);",
          "    assert!(byte_set.contains(255) == true);"
        ],
        "code": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    for byte in 0..=255 {",
          "        byte_set.add(byte);",
          "    }",
          "    for byte in 0..=255 {",
          "        assert!(byte_set.contains(byte));",
          "    }",
          "    assert!(ByteSet::empty().contains(0) == false);",
          "    assert!(ByteSet::empty().contains(255) == false);",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(1);",
          "    assert!(byte_set.contains(1) == true);",
          "    assert!(byte_set.contains(0) == false);",
          "    byte_set.add(128);",
          "    assert!(byte_set.contains(128) == true);",
          "    assert!(byte_set.contains(129) == false);",
          "    byte_set.remove(1);",
          "    assert!(byte_set.contains(1) == false);",
          "    assert!(byte_set.contains(128) == true);",
          "    assert!(byte_set.contains(255) == false);",
          "    byte_set.remove(128);",
          "    assert!(byte_set.contains(128) == false);",
          "    for byte in 0..=255 {",
          "    assert!(byte_set.contains(byte) == false);",
          "    }",
          "    byte_set.add(255);",
          "    assert!(byte_set.contains(255) == true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(127);",
          "    byte_set.add(128);",
          "    ",
          "    assert!(byte_set.contains(127));",
          "    assert!(byte_set.contains(128));",
          "    assert!(!byte_set.contains(126));",
          "    assert!(!byte_set.contains(129));",
          "}"
        ],
        "oracle": [
          "    assert!(byte_set.contains(127) == true);",
          "    assert!(byte_set.contains(128) == true);",
          "    assert!(byte_set.contains(126) == false);",
          "    assert!(byte_set.contains(129) == false);"
        ],
        "code": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(127);",
          "    byte_set.add(128);",
          "    ",
          "    assert!(byte_set.contains(127));",
          "    assert!(byte_set.contains(128));",
          "    assert!(!byte_set.contains(126));",
          "    assert!(!byte_set.contains(129));",
          "    assert!(byte_set.contains(127) == true);",
          "    assert!(byte_set.contains(128) == true);",
          "    assert!(byte_set.contains(126) == false);",
          "    assert!(byte_set.contains(129) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(1);",
          "    byte_set.add(2);",
          "    byte_set.add(3);",
          "    ",
          "    assert!(byte_set.contains(1));",
          "    assert!(byte_set.contains(2));",
          "    assert!(byte_set.contains(3));",
          "    assert!(!byte_set.contains(0));",
          "    assert!(!byte_set.contains(4));",
          "}"
        ],
        "oracle": [
          "    assert!(byte_set.contains(1) == true);",
          "    assert!(byte_set.contains(2) == true);",
          "    assert!(byte_set.contains(3) == true);",
          "    assert!(byte_set.contains(0) == false);",
          "    assert!(byte_set.contains(4) == false);"
        ],
        "code": [
          "{",
          "    let mut byte_set = ByteSet::empty();",
          "    byte_set.add(1);",
          "    byte_set.add(2);",
          "    byte_set.add(3);",
          "    ",
          "    assert!(byte_set.contains(1));",
          "    assert!(byte_set.contains(2));",
          "    assert!(byte_set.contains(3));",
          "    assert!(!byte_set.contains(0));",
          "    assert!(!byte_set.contains(4));",
          "    assert!(byte_set.contains(1) == true);",
          "    assert!(byte_set.contains(2) == true);",
          "    assert!(byte_set.contains(3) == true);",
          "    assert!(byte_set.contains(0) == false);",
          "    assert!(byte_set.contains(4) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]