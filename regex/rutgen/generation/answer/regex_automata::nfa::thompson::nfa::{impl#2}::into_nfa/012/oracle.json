[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![],",
          "        states: vec![],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nfa, NFA(Arc::new(inner)));",
          "    assert!(inner.start_pattern.is_empty());",
          "    assert!(inner.states.is_empty());",
          "    assert_eq!(inner.byte_class_set, ByteClassSet::empty());",
          "    assert!(!inner.has_empty);",
          "    assert!(inner.look_set_prefix_any.is_empty());",
          "    assert!(inner.has_capture == false);",
          "    assert!(inner.byte_classes == ByteClasses::empty());"
        ],
        "code": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![],",
          "        states: vec![],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "    assert_eq!(nfa, NFA(Arc::new(inner)));",
          "    assert!(inner.start_pattern.is_empty());",
          "    assert!(inner.states.is_empty());",
          "    assert_eq!(inner.byte_class_set, ByteClassSet::empty());",
          "    assert!(!inner.has_empty);",
          "    assert!(inner.look_set_prefix_any.is_empty());",
          "    assert!(inner.has_capture == false);",
          "    assert!(inner.byte_classes == ByteClasses::empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![StateID(Default::default())],",
          "        states: vec![],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    let inner = Inner { start_pattern: vec![], states: vec![], byte_class_set: ByteClassSet::empty(), ..Default::default() };",
          "    assert_eq!(inner.into_nfa(), NFA(Arc::new(inner)));"
        ],
        "code": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![StateID(Default::default())],",
          "        states: vec![],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "    let inner = Inner { start_pattern: vec![], states: vec![], byte_class_set: ByteClassSet::empty(), ..Default::default() };",
          "    assert_eq!(inner.into_nfa(), NFA(Arc::new(inner)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![],",
          "        states: vec![State {",
          "            transitions: vec![],",
          "            ..Default::default()",
          "        }],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    let inner = Inner { start_pattern: vec![], states: vec![State { transitions: vec![], ..Default::default() }], byte_class_set: ByteClassSet::empty(), ..Default::default() };",
          "    let nfa = inner.into_nfa();",
          "    assert!(nfa.0.has_empty == false);",
          "    assert!(nfa.0.start_anchored == inner.start_anchored);",
          "    assert!(nfa.0.start_unanchored == inner.start_unanchored);",
          "    assert!(nfa.0.start_pattern.is_empty());",
          "    assert!(Arc::strong_count(&nfa.0) == 1);",
          "    assert!(nfa.0.byte_class_set == ByteClassSet::empty());",
          "    assert!(nfa.0.states.len() == 1);",
          "    assert!(nfa.0.states[0].transitions.is_empty());"
        ],
        "code": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![],",
          "        states: vec![State {",
          "            transitions: vec![],",
          "            ..Default::default()",
          "        }],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "    let inner = Inner { start_pattern: vec![], states: vec![State { transitions: vec![], ..Default::default() }], byte_class_set: ByteClassSet::empty(), ..Default::default() };",
          "    let nfa = inner.into_nfa();",
          "    assert!(nfa.0.has_empty == false);",
          "    assert!(nfa.0.start_anchored == inner.start_anchored);",
          "    assert!(nfa.0.start_unanchored == inner.start_unanchored);",
          "    assert!(nfa.0.start_pattern.is_empty());",
          "    assert!(Arc::strong_count(&nfa.0) == 1);",
          "    assert!(nfa.0.byte_class_set == ByteClassSet::empty());",
          "    assert!(nfa.0.states.len() == 1);",
          "    assert!(nfa.0.states[0].transitions.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![],",
          "        states: vec![State {",
          "            transitions: vec![],",
          "            ..Default::default()",
          "        }],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    assert!(nfa.0.has_empty == false);",
          "    assert!(nfa.0.start_pattern.is_empty());",
          "    assert!(nfa.0.states.len() == 1);",
          "    assert!(nfa.0.start_anchored == StateID::default());",
          "    assert!(nfa.0.start_unanchored == StateID::default());",
          "    assert!(nfa.0.byte_class_set.0.is_empty());",
          "    assert!(nfa.0.group_info().0.is_empty());"
        ],
        "code": [
          "{",
          "    let inner = Inner {",
          "        start_pattern: vec![],",
          "        states: vec![State {",
          "            transitions: vec![],",
          "            ..Default::default()",
          "        }],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    let nfa = inner.into_nfa();",
          "    assert!(nfa.0.has_empty == false);",
          "    assert!(nfa.0.start_pattern.is_empty());",
          "    assert!(nfa.0.states.len() == 1);",
          "    assert!(nfa.0.start_anchored == StateID::default());",
          "    assert!(nfa.0.start_unanchored == StateID::default());",
          "    assert!(nfa.0.byte_class_set.0.is_empty());",
          "    assert!(nfa.0.group_info().0.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]