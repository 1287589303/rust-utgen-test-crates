[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    ",
          "    let state_capture = State::Capture {",
          "        next: StateID(SmallIndex::new(2)),",
          "        pattern_id: PatternID(0),",
          "        group_index: SmallIndex::new(0),",
          "        slot: SmallIndex::new(0),",
          "    };",
          "    ",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "",
          "    let mut inner = Inner {",
          "        states: vec![state_capture.clone(), state_other],",
          "        start_anchored: StateID(SmallIndex::new(0)),",
          "        start_unanchored: StateID(SmallIndex::new(0)),",
          "        start_pattern: vec![StateID(SmallIndex::new(0))],",
          "        ..Default::default()",
          "    };",
          "",
          "    let result_nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    let state_capture = State::Capture { next: StateID(SmallIndex::new(2)), pattern_id: PatternID(0), group_index: SmallIndex::new(0), slot: SmallIndex::new(0) };",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "    let mut inner = Inner { states: vec![state_capture.clone(), state_other], start_anchored: StateID(SmallIndex::new(0)), start_unanchored: StateID(SmallIndex::new(0)), start_pattern: vec![StateID(SmallIndex::new(0))], ..Default::default() };",
          "    let result_nfa = inner.into_nfa();",
          "    assert_eq!(result_nfa.0.has_empty, true);",
          "    assert!(inner.look_set_prefix_any.contains(Look::CaptureStart));",
          "    assert!(inner.look_set_prefix_any.contains(Look::CaptureEnd));",
          "    assert_eq!(inner.byte_classes, inner.byte_class_set.byte_classes());",
          "    assert!(result_nfa.0.start_anchored == inner.start_anchored);",
          "    assert!(result_nfa.0.start_unanchored == inner.start_unanchored);"
        ],
        "code": [
          "{",
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    ",
          "    let state_capture = State::Capture {",
          "        next: StateID(SmallIndex::new(2)),",
          "        pattern_id: PatternID(0),",
          "        group_index: SmallIndex::new(0),",
          "        slot: SmallIndex::new(0),",
          "    };",
          "    ",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "",
          "    let mut inner = Inner {",
          "        states: vec![state_capture.clone(), state_other],",
          "        start_anchored: StateID(SmallIndex::new(0)),",
          "        start_unanchored: StateID(SmallIndex::new(0)),",
          "        start_pattern: vec![StateID(SmallIndex::new(0))],",
          "        ..Default::default()",
          "    };",
          "",
          "    let result_nfa = inner.into_nfa();",
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    let state_capture = State::Capture { next: StateID(SmallIndex::new(2)), pattern_id: PatternID(0), group_index: SmallIndex::new(0), slot: SmallIndex::new(0) };",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "    let mut inner = Inner { states: vec![state_capture.clone(), state_other], start_anchored: StateID(SmallIndex::new(0)), start_unanchored: StateID(SmallIndex::new(0)), start_pattern: vec![StateID(SmallIndex::new(0))], ..Default::default() };",
          "    let result_nfa = inner.into_nfa();",
          "    assert_eq!(result_nfa.0.has_empty, true);",
          "    assert!(inner.look_set_prefix_any.contains(Look::CaptureStart));",
          "    assert!(inner.look_set_prefix_any.contains(Look::CaptureEnd));",
          "    assert_eq!(inner.byte_classes, inner.byte_class_set.byte_classes());",
          "    assert!(result_nfa.0.start_anchored == inner.start_anchored);",
          "    assert!(result_nfa.0.start_unanchored == inner.start_unanchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    ",
          "    let state_capture1 = State::Capture {",
          "        next: StateID(SmallIndex::new(2)),",
          "        pattern_id: PatternID(0),",
          "        group_index: SmallIndex::new(0),",
          "        slot: SmallIndex::new(0),",
          "    };",
          "    ",
          "    let state_capture2 = State::Capture {",
          "        next: StateID(SmallIndex::new(3)),",
          "        pattern_id: PatternID(1),",
          "        group_index: SmallIndex::new(1),",
          "        slot: SmallIndex::new(1),",
          "    };",
          "",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "",
          "    let mut inner = Inner {",
          "        states: vec![state_capture1, state_other, state_capture2],",
          "        start_anchored: StateID(SmallIndex::new(0)),",
          "        start_unanchored: StateID(SmallIndex::new(0)),",
          "        start_pattern: vec![StateID(SmallIndex::new(0)), StateID(SmallIndex::new(2))],",
          "        ..Default::default()",
          "    };",
          "",
          "    let result_nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    let state_capture1 = State::Capture {",
          "    next: StateID(SmallIndex::new(2)),",
          "    pattern_id: PatternID(0),",
          "    group_index: SmallIndex::new(0),",
          "    slot: SmallIndex::new(0),",
          "    };",
          "    let state_capture2 = State::Capture {",
          "    next: StateID(SmallIndex::new(3)),",
          "    pattern_id: PatternID(1),",
          "    group_index: SmallIndex::new(1),",
          "    slot: SmallIndex::new(1),",
          "    };",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "    let mut inner = Inner {",
          "    states: vec![state_capture1, state_other, state_capture2],",
          "    start_anchored: StateID(SmallIndex::new(0)),",
          "    start_unanchored: StateID(SmallIndex::new(0)),",
          "    start_pattern: vec![StateID(SmallIndex::new(0)), StateID(SmallIndex::new(2))],",
          "    ..Default::default()",
          "    };",
          "    let result_nfa = inner.into_nfa();",
          "    assert_eq!(result_nfa, NFA(Arc::new(inner)));"
        ],
        "code": [
          "{",
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    ",
          "    let state_capture1 = State::Capture {",
          "        next: StateID(SmallIndex::new(2)),",
          "        pattern_id: PatternID(0),",
          "        group_index: SmallIndex::new(0),",
          "        slot: SmallIndex::new(0),",
          "    };",
          "    ",
          "    let state_capture2 = State::Capture {",
          "        next: StateID(SmallIndex::new(3)),",
          "        pattern_id: PatternID(1),",
          "        group_index: SmallIndex::new(1),",
          "        slot: SmallIndex::new(1),",
          "    };",
          "",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "",
          "    let mut inner = Inner {",
          "        states: vec![state_capture1, state_other, state_capture2],",
          "        start_anchored: StateID(SmallIndex::new(0)),",
          "        start_unanchored: StateID(SmallIndex::new(0)),",
          "        start_pattern: vec![StateID(SmallIndex::new(0)), StateID(SmallIndex::new(2))],",
          "        ..Default::default()",
          "    };",
          "",
          "    let result_nfa = inner.into_nfa();",
          "    let capture_state_id = StateID(SmallIndex::new(1));",
          "    let state_capture1 = State::Capture {",
          "    next: StateID(SmallIndex::new(2)),",
          "    pattern_id: PatternID(0),",
          "    group_index: SmallIndex::new(0),",
          "    slot: SmallIndex::new(0),",
          "    };",
          "    let state_capture2 = State::Capture {",
          "    next: StateID(SmallIndex::new(3)),",
          "    pattern_id: PatternID(1),",
          "    group_index: SmallIndex::new(1),",
          "    slot: SmallIndex::new(1),",
          "    };",
          "    let state_other = State::ByteRange { trans: Transition::new() };",
          "    let mut inner = Inner {",
          "    states: vec![state_capture1, state_other, state_capture2],",
          "    start_anchored: StateID(SmallIndex::new(0)),",
          "    start_unanchored: StateID(SmallIndex::new(0)),",
          "    start_pattern: vec![StateID(SmallIndex::new(0)), StateID(SmallIndex::new(2))],",
          "    ..Default::default()",
          "    };",
          "    let result_nfa = inner.into_nfa();",
          "    assert_eq!(result_nfa, NFA(Arc::new(inner)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    ",
          "    let state_capture = State::Capture {",
          "        next: StateID(SmallIndex::new(1)),",
          "        pattern_id: PatternID(0),",
          "        group_index: SmallIndex::new(0),",
          "        slot: SmallIndex::new(0),",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![state_capture],",
          "        start_anchored: StateID(SmallIndex::new(0)),",
          "        start_unanchored: StateID(SmallIndex::new(0)),",
          "        start_pattern: vec![],",
          "        ..Default::default()",
          "    };",
          "",
          "    let result_nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    assert!(result_nfa.0.has_empty);",
          "    assert_eq!(result_nfa.0.start_anchored, StateID(SmallIndex::new(0)));",
          "    assert_eq!(result_nfa.0.start_unanchored, StateID(SmallIndex::new(0)));",
          "    assert!(result_nfa.0.look_set_prefix_any.is_empty());",
          "    assert_eq!(inner.states.len(), 1);",
          "    assert!(inner.start_pattern.is_empty());",
          "    assert!(matches!(inner.states[0], State::Capture { .. }));"
        ],
        "code": [
          "{",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    ",
          "    let state_capture = State::Capture {",
          "        next: StateID(SmallIndex::new(1)),",
          "        pattern_id: PatternID(0),",
          "        group_index: SmallIndex::new(0),",
          "        slot: SmallIndex::new(0),",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![state_capture],",
          "        start_anchored: StateID(SmallIndex::new(0)),",
          "        start_unanchored: StateID(SmallIndex::new(0)),",
          "        start_pattern: vec![],",
          "        ..Default::default()",
          "    };",
          "",
          "    let result_nfa = inner.into_nfa();",
          "    assert!(result_nfa.0.has_empty);",
          "    assert_eq!(result_nfa.0.start_anchored, StateID(SmallIndex::new(0)));",
          "    assert_eq!(result_nfa.0.start_unanchored, StateID(SmallIndex::new(0)));",
          "    assert!(result_nfa.0.look_set_prefix_any.is_empty());",
          "    assert_eq!(inner.states.len(), 1);",
          "    assert!(inner.start_pattern.is_empty());",
          "    assert!(matches!(inner.states[0], State::Capture { .. }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]