[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_id_0 = StateID(SmallIndex(0));",
          "    let start_id_1 = StateID(SmallIndex(1));",
          "    ",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    ",
          "    let union_state = State::Union {",
          "        alternates: vec![state_id_2, state_id_3],",
          "    };",
          "    ",
          "    let look_state = State::Look {",
          "        look: Look::Start,",
          "        next: state_id_2,",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![union_state.clone(), look_state.clone()],",
          "        start_anchored: start_id_0,",
          "        start_unanchored: start_id_1,",
          "        start_pattern: vec![start_id_0, start_id_1],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    let start_id_0 = StateID(SmallIndex(0));",
          "    let start_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    let union_state = State::Union { alternates: vec![state_id_2, state_id_3] };",
          "    let look_state = State::Look { look: Look::Start, next: state_id_2 };",
          "    let mut inner = Inner { states: vec![union_state.clone(), look_state.clone()], start_anchored: start_id_0, start_unanchored: start_id_1, start_pattern: vec![start_id_0, start_id_1], byte_class_set: ByteClassSet::empty(), ..Default::default() };",
          "    let nfa = inner.into_nfa();",
          "    assert_eq!(nfa, NFA(Arc::new(inner)));",
          "    assert!(inner.look_set_prefix_any.contains(Look::Start));",
          "    assert!(inner.has_empty);"
        ],
        "code": [
          "{",
          "    let start_id_0 = StateID(SmallIndex(0));",
          "    let start_id_1 = StateID(SmallIndex(1));",
          "    ",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    ",
          "    let union_state = State::Union {",
          "        alternates: vec![state_id_2, state_id_3],",
          "    };",
          "    ",
          "    let look_state = State::Look {",
          "        look: Look::Start,",
          "        next: state_id_2,",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![union_state.clone(), look_state.clone()],",
          "        start_anchored: start_id_0,",
          "        start_unanchored: start_id_1,",
          "        start_pattern: vec![start_id_0, start_id_1],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let nfa = inner.into_nfa();",
          "    let start_id_0 = StateID(SmallIndex(0));",
          "    let start_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    let union_state = State::Union { alternates: vec![state_id_2, state_id_3] };",
          "    let look_state = State::Look { look: Look::Start, next: state_id_2 };",
          "    let mut inner = Inner { states: vec![union_state.clone(), look_state.clone()], start_anchored: start_id_0, start_unanchored: start_id_1, start_pattern: vec![start_id_0, start_id_1], byte_class_set: ByteClassSet::empty(), ..Default::default() };",
          "    let nfa = inner.into_nfa();",
          "    assert_eq!(nfa, NFA(Arc::new(inner)));",
          "    assert!(inner.look_set_prefix_any.contains(Look::Start));",
          "    assert!(inner.has_empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_id = StateID(SmallIndex(0));",
          "    ",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    ",
          "    let union_1 = State::Union {",
          "        alternates: vec![state_id_1, state_id_2],",
          "    };",
          "    ",
          "    let union_2 = State::Union {",
          "        alternates: vec![state_id_2, state_id_3],",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![union_1, union_2],",
          "        start_anchored: start_id,",
          "        start_unanchored: StateID(SmallIndex(1)),",
          "        start_pattern: vec![start_id],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    inner.start_pattern.contains(&start_id);",
          "    let Some(sid) = stack.pop();",
          "    seen.insert(sid);",
          "    matches!(\"State::Union\", self.states[sid]);",
          "    matches!(\"State::Union\", self.states[sid]);",
          "    let Some(sid) = stack.pop();",
          "    !inner.start_pattern.contains(&start_id);",
          "    assert_eq!(nfa, NFA(Arc::new(inner)));"
        ],
        "code": [
          "{",
          "    let start_id = StateID(SmallIndex(0));",
          "    ",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let state_id_3 = StateID(SmallIndex(3));",
          "    ",
          "    let union_1 = State::Union {",
          "        alternates: vec![state_id_1, state_id_2],",
          "    };",
          "    ",
          "    let union_2 = State::Union {",
          "        alternates: vec![state_id_2, state_id_3],",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![union_1, union_2],",
          "        start_anchored: start_id,",
          "        start_unanchored: StateID(SmallIndex(1)),",
          "        start_pattern: vec![start_id],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let nfa = inner.into_nfa();",
          "    inner.start_pattern.contains(&start_id);",
          "    let Some(sid) = stack.pop();",
          "    seen.insert(sid);",
          "    matches!(\"State::Union\", self.states[sid]);",
          "    matches!(\"State::Union\", self.states[sid]);",
          "    let Some(sid) = stack.pop();",
          "    !inner.start_pattern.contains(&start_id);",
          "    assert_eq!(nfa, NFA(Arc::new(inner)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_id = StateID(SmallIndex(0));",
          "    ",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let look_state = State::Look {",
          "        look: Look::End,",
          "        next: state_id_2,",
          "    };",
          "    ",
          "    let union_state = State::Union {",
          "        alternates: vec![state_id_1, state_id_2],",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![union_state, look_state],",
          "        start_anchored: start_id,",
          "        start_unanchored: StateID(SmallIndex(1)),",
          "        start_pattern: vec![start_id],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let nfa = inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nfa.has_empty, true);",
          "    assert!(nfa.look_set_prefix_any.contains(Look::End));",
          "    assert!(nfa.byte_classes == inner.byte_classes);",
          "    assert!(nfa.0.start_anchored == inner.start_anchored);",
          "    assert!(nfa.0.start_unanchored == inner.start_unanchored);",
          "    assert!(nfa.0.start_pattern == inner.start_pattern);",
          "    assert!(nfa.0.has_capture == false);",
          "    assert!(nfa.0.has_empty == true);",
          "    assert!(nfa.0.utf8 == false);",
          "    assert!(nfa.0.reverse == false);",
          "    assert!(nfa.0.memory_extra == 0);",
          "    assert!(nfa.0.states.len() == inner.states.len());",
          "    assert!(nfa.0.group_info == inner.group_info);",
          "    assert_eq!(nfa.0.byte_class_set, inner.byte_class_set);",
          "    assert_eq!(nfa.0.look_set_any, LookSet::empty());",
          "    assert_eq!(nfa.0.look_matcher.lineterm, Default::default());"
        ],
        "code": [
          "{",
          "    let start_id = StateID(SmallIndex(0));",
          "    ",
          "    let state_id_1 = StateID(SmallIndex(1));",
          "    let state_id_2 = StateID(SmallIndex(2));",
          "    let look_state = State::Look {",
          "        look: Look::End,",
          "        next: state_id_2,",
          "    };",
          "    ",
          "    let union_state = State::Union {",
          "        alternates: vec![state_id_1, state_id_2],",
          "    };",
          "    ",
          "    let mut inner = Inner {",
          "        states: vec![union_state, look_state],",
          "        start_anchored: start_id,",
          "        start_unanchored: StateID(SmallIndex(1)),",
          "        start_pattern: vec![start_id],",
          "        byte_class_set: ByteClassSet::empty(),",
          "        ..Default::default()",
          "    };",
          "    ",
          "    let nfa = inner.into_nfa();",
          "    assert_eq!(nfa.has_empty, true);",
          "    assert!(nfa.look_set_prefix_any.contains(Look::End));",
          "    assert!(nfa.byte_classes == inner.byte_classes);",
          "    assert!(nfa.0.start_anchored == inner.start_anchored);",
          "    assert!(nfa.0.start_unanchored == inner.start_unanchored);",
          "    assert!(nfa.0.start_pattern == inner.start_pattern);",
          "    assert!(nfa.0.has_capture == false);",
          "    assert!(nfa.0.has_empty == true);",
          "    assert!(nfa.0.utf8 == false);",
          "    assert!(nfa.0.reverse == false);",
          "    assert!(nfa.0.memory_extra == 0);",
          "    assert!(nfa.0.states.len() == inner.states.len());",
          "    assert!(nfa.0.group_info == inner.group_info);",
          "    assert_eq!(nfa.0.byte_class_set, inner.byte_class_set);",
          "    assert_eq!(nfa.0.look_set_any, LookSet::empty());",
          "    assert_eq!(nfa.0.look_matcher.lineterm, Default::default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]