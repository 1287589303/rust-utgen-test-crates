[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pattern = vec![StateID(Default::default())];",
          "    let state_id = StateID(Default::default());",
          "    ",
          "    let states = vec![",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::Match { pattern_id: PatternID(Default::default()) },",
          "    ];",
          "",
          "    let mut inner = Inner {",
          "        states,",
          "        start_pattern,",
          "        ..Default::default()",
          "    };",
          "",
          "    inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    assert!(inner.start_pattern.iter().any(|&id| id == start_id));",
          "    ",
          "    let sid = stack.pop().unwrap();",
          "    ",
          "    assert!(seen.insert(sid));",
          "    ",
          "    match self.states[sid] {",
          "    State::BinaryUnion { alt1, alt2 } => {",
          "    stack.push(alt2);",
          "    stack.push(alt1);",
          "    },",
          "    _ => panic!(\"Expected State::BinaryUnion\"),",
          "    }",
          "    ",
          "    let sid_after_pop = stack.pop().unwrap();",
          "    ",
          "    assert!(inner.start_pattern.iter().all(|&id| id != start_id));",
          "    ",
          "    let result = inner.into_nfa();",
          "    assert!(matches!(result, NFA(_)));"
        ],
        "code": [
          "{",
          "    let start_pattern = vec![StateID(Default::default())];",
          "    let state_id = StateID(Default::default());",
          "    ",
          "    let states = vec![",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::Match { pattern_id: PatternID(Default::default()) },",
          "    ];",
          "",
          "    let mut inner = Inner {",
          "        states,",
          "        start_pattern,",
          "        ..Default::default()",
          "    };",
          "",
          "    inner.into_nfa();",
          "    assert!(inner.start_pattern.iter().any(|&id| id == start_id));",
          "    ",
          "    let sid = stack.pop().unwrap();",
          "    ",
          "    assert!(seen.insert(sid));",
          "    ",
          "    match self.states[sid] {",
          "    State::BinaryUnion { alt1, alt2 } => {",
          "    stack.push(alt2);",
          "    stack.push(alt1);",
          "    },",
          "    _ => panic!(\"Expected State::BinaryUnion\"),",
          "    }",
          "    ",
          "    let sid_after_pop = stack.pop().unwrap();",
          "    ",
          "    assert!(inner.start_pattern.iter().all(|&id| id != start_id));",
          "    ",
          "    let result = inner.into_nfa();",
          "    assert!(matches!(result, NFA(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pattern = vec![StateID(Default::default())];",
          "    ",
          "    let states = vec![",
          "        State::ByteRange { trans: Default::default() },",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::Match { pattern_id: PatternID(Default::default()) },",
          "    ];",
          "",
          "    let mut inner = Inner {",
          "        states,",
          "        start_pattern,",
          "        ..Default::default()",
          "    };",
          "",
          "    inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    inner.start_pattern.push(StateID(Default::default()));",
          "    inner.states.push(State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) });",
          "    assert!(inner.states.len() > 0);",
          "    inner.states.push(State::Capture { next: StateID(Default::default()), pattern_id: PatternID(Default::default()), group_index: SmallIndex::default(), slot: SmallIndex::default() });",
          "    let result = inner.into_nfa();",
          "    assert!(result.0.has_empty);",
          "    assert!(!inner.look_set_prefix_any.is_empty());",
          "    assert_eq!(result.0.byte_classes, inner.byte_classes);",
          "    assert!(inner.states.contains(&State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) }));",
          "    assert!(inner.start_pattern.iter().any(|&id| id == StateID(Default::default())));"
        ],
        "code": [
          "{",
          "    let start_pattern = vec![StateID(Default::default())];",
          "    ",
          "    let states = vec![",
          "        State::ByteRange { trans: Default::default() },",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::Match { pattern_id: PatternID(Default::default()) },",
          "    ];",
          "",
          "    let mut inner = Inner {",
          "        states,",
          "        start_pattern,",
          "        ..Default::default()",
          "    };",
          "",
          "    inner.into_nfa();",
          "    inner.start_pattern.push(StateID(Default::default()));",
          "    inner.states.push(State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) });",
          "    assert!(inner.states.len() > 0);",
          "    inner.states.push(State::Capture { next: StateID(Default::default()), pattern_id: PatternID(Default::default()), group_index: SmallIndex::default(), slot: SmallIndex::default() });",
          "    let result = inner.into_nfa();",
          "    assert!(result.0.has_empty);",
          "    assert!(!inner.look_set_prefix_any.is_empty());",
          "    assert_eq!(result.0.byte_classes, inner.byte_classes);",
          "    assert!(inner.states.contains(&State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) }));",
          "    assert!(inner.start_pattern.iter().any(|&id| id == StateID(Default::default())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let start_pattern = vec![StateID(Default::default())];",
          "",
          "    let states = vec![",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::Match { pattern_id: PatternID(Default::default()) },",
          "    ];",
          "",
          "    let mut inner = Inner {",
          "        states,",
          "        start_pattern,",
          "        ..Default::default()",
          "    };",
          "",
          "    inner.into_nfa();",
          "}"
        ],
        "oracle": [
          "    inner.start_pattern.iter().next().is_some();",
          "    inner.states.len() > 0;",
          "    inner.states[0] == State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) };",
          "    inner.states[1] == State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) };",
          "    inner.states[2] == State::Match { pattern_id: PatternID(Default::default()) };",
          "    let nfa_result = inner.into_nfa();",
          "    nfa_result.0.has_capture == false;",
          "    nfa_result.0.has_empty == true;"
        ],
        "code": [
          "{",
          "    let start_pattern = vec![StateID(Default::default())];",
          "",
          "    let states = vec![",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::BinaryUnion {",
          "            alt1: StateID(Default::default()),",
          "            alt2: StateID(Default::default()),",
          "        },",
          "        State::Match { pattern_id: PatternID(Default::default()) },",
          "    ];",
          "",
          "    let mut inner = Inner {",
          "        states,",
          "        start_pattern,",
          "        ..Default::default()",
          "    };",
          "",
          "    inner.into_nfa();",
          "    inner.start_pattern.iter().next().is_some();",
          "    inner.states.len() > 0;",
          "    inner.states[0] == State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) };",
          "    inner.states[1] == State::BinaryUnion { alt1: StateID(Default::default()), alt2: StateID(Default::default()) };",
          "    inner.states[2] == State::Match { pattern_id: PatternID(Default::default()) };",
          "    let nfa_result = inner.into_nfa();",
          "    nfa_result.0.has_capture == false;",
          "    nfa_result.0.has_empty == true;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]