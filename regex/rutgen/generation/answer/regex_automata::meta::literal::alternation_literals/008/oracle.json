[
  {
    "uses": [
      "use regex_syntax::hir::Hir;",
      "use regex_syntax::hir::HirKind;",
      "use regex_syntax::hir::Literal;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Literal};",
          "",
          "    let config = Config::new()",
          "        .match_kind(MatchKind::LeftmostFirst)",
          "        .nfa_size_limit(None)",
          "        .onepass_size_limit(None);",
          "",
          "    let info = RegexInfo(Arc::new(RegexInfoI {",
          "        config,",
          "        props: vec![hir::Properties::new_empty()],",
          "    }));",
          "",
          "    let lit1 = Literal::from_bytes(b\"foo\");",
          "    let lit2 = Literal::from_bytes(b\"bar\");",
          "",
          "    let expr1 = Hir::from(HirKind::Literal(lit1));",
          "    let expr2 = Hir::from(HirKind::Literal(lit2));",
          "    let concat_expr = Hir::from(HirKind::Concat(vec![expr1.clone(), expr2.clone()]));",
          "",
          "    let alt_hir = Hir::from(HirKind::Alternation(vec![",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "    ]));",
          "",
          "    let hirs: Vec<&Hir> = vec![&alt_hir];",
          "",
          "    let result = alternation_literals(&info, &hirs);",
          "}"
        ],
        "oracle": [
          "    let config = Config::new().match_kind(MatchKind::LeftmostFirst).nfa_size_limit(None).onepass_size_limit(None);",
          "    let info = RegexInfo(Arc::new(RegexInfoI { config, props: vec![hir::Properties::new_empty()] }));",
          "    let lit1 = Literal::from_bytes(b\"literal1\");",
          "    let lit2 = Literal::from_bytes(b\"literal2\");",
          "    let expr1 = Hir::from(HirKind::Literal(lit1));",
          "    let expr2 = Hir::from(HirKind::Literal(lit2));",
          "    let concat_expr = Hir::from(HirKind::Concat(vec![expr1.clone(), expr2.clone()]));",
          "    let alt_hir = Hir::from(HirKind::Alternation(vec![concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone()]));",
          "    let hirs: Vec<&Hir> = vec![&alt_hir];",
          "    let result = alternation_literals(&info, &hirs);",
          "    assert!(result.is_some());",
          "    let literals = result.unwrap();",
          "    assert!(literals.len() == 10);",
          "    assert!(literals.iter().all(|l| l.len() >= 3));",
          "    assert!(literals.len() >= 3000);"
        ],
        "code": [
          "{",
          "    use regex_syntax::hir::{Hir, HirKind, Literal};",
          "",
          "    let config = Config::new()",
          "        .match_kind(MatchKind::LeftmostFirst)",
          "        .nfa_size_limit(None)",
          "        .onepass_size_limit(None);",
          "",
          "    let info = RegexInfo(Arc::new(RegexInfoI {",
          "        config,",
          "        props: vec![hir::Properties::new_empty()],",
          "    }));",
          "",
          "    let lit1 = Literal::from_bytes(b\"foo\");",
          "    let lit2 = Literal::from_bytes(b\"bar\");",
          "",
          "    let expr1 = Hir::from(HirKind::Literal(lit1));",
          "    let expr2 = Hir::from(HirKind::Literal(lit2));",
          "    let concat_expr = Hir::from(HirKind::Concat(vec![expr1.clone(), expr2.clone()]));",
          "",
          "    let alt_hir = Hir::from(HirKind::Alternation(vec![",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "        concat_expr.clone(),",
          "    ]));",
          "",
          "    let hirs: Vec<&Hir> = vec![&alt_hir];",
          "",
          "    let result = alternation_literals(&info, &hirs);",
          "    let config = Config::new().match_kind(MatchKind::LeftmostFirst).nfa_size_limit(None).onepass_size_limit(None);",
          "    let info = RegexInfo(Arc::new(RegexInfoI { config, props: vec![hir::Properties::new_empty()] }));",
          "    let lit1 = Literal::from_bytes(b\"literal1\");",
          "    let lit2 = Literal::from_bytes(b\"literal2\");",
          "    let expr1 = Hir::from(HirKind::Literal(lit1));",
          "    let expr2 = Hir::from(HirKind::Literal(lit2));",
          "    let concat_expr = Hir::from(HirKind::Concat(vec![expr1.clone(), expr2.clone()]));",
          "    let alt_hir = Hir::from(HirKind::Alternation(vec![concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone(), concat_expr.clone()]));",
          "    let hirs: Vec<&Hir> = vec![&alt_hir];",
          "    let result = alternation_literals(&info, &hirs);",
          "    assert!(result.is_some());",
          "    let literals = result.unwrap();",
          "    assert!(literals.len() == 10);",
          "    assert!(literals.iter().all(|l| l.len() >= 3));",
          "    assert!(literals.len() >= 3000);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]