[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
          "    let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";",
          "    let captures = re.captures(hay).unwrap();",
          "    let (full, [year, month, day]) = captures.extract::<3>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(full, \"2010-03-14\");",
          "    assert_eq!(year, \"2010\");",
          "    assert_eq!(month, \"03\");",
          "    assert_eq!(day, \"14\");",
          "    ",
          "    let invalid_re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})|(c)\").unwrap();",
          "    let invalid_captures = invalid_re.captures(hay).unwrap();",
          "    let result = std::panic::catch_unwind(|| {",
          "    invalid_captures.extract::<3>()",
          "    });",
          "    assert!(result.is_err());",
          "    ",
          "    let re_varied = Regex::new(r\"(a)(b)|(c)\").unwrap();",
          "    let hay_varied = \"ac\";",
          "    let captures_varied = re_varied.captures(hay_varied).unwrap();",
          "    let result_varied = std::panic::catch_unwind(|| {",
          "    captures_varied.extract::<2>()",
          "    });",
          "    assert!(result_varied.is_err());",
          "    ",
          "    let empty_hay = \"\";",
          "    let empty_captures = re.captures(empty_hay).unwrap();",
          "    let result_empty = std::panic::catch_unwind(|| {",
          "    empty_captures.extract::<3>()",
          "    });",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let no_capture_hay = \"Just some text.\";",
          "    let no_capture_captures = re.captures(no_capture_hay).unwrap();",
          "    let result_no_capture = std::panic::catch_unwind(|| {",
          "    no_capture_captures.extract::<3>()",
          "    });",
          "    assert!(result_no_capture.is_err());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
          "    let hay = \"On 2010-03-14, I became a Tenneessee lamb.\";",
          "    let captures = re.captures(hay).unwrap();",
          "    let (full, [year, month, day]) = captures.extract::<3>();",
          "    assert_eq!(full, \"2010-03-14\");",
          "    assert_eq!(year, \"2010\");",
          "    assert_eq!(month, \"03\");",
          "    assert_eq!(day, \"14\");",
          "    ",
          "    let invalid_re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})|(c)\").unwrap();",
          "    let invalid_captures = invalid_re.captures(hay).unwrap();",
          "    let result = std::panic::catch_unwind(|| {",
          "    invalid_captures.extract::<3>()",
          "    });",
          "    assert!(result.is_err());",
          "    ",
          "    let re_varied = Regex::new(r\"(a)(b)|(c)\").unwrap();",
          "    let hay_varied = \"ac\";",
          "    let captures_varied = re_varied.captures(hay_varied).unwrap();",
          "    let result_varied = std::panic::catch_unwind(|| {",
          "    captures_varied.extract::<2>()",
          "    });",
          "    assert!(result_varied.is_err());",
          "    ",
          "    let empty_hay = \"\";",
          "    let empty_captures = re.captures(empty_hay).unwrap();",
          "    let result_empty = std::panic::catch_unwind(|| {",
          "    empty_captures.extract::<3>()",
          "    });",
          "    assert!(result_empty.is_err());",
          "    ",
          "    let no_capture_hay = \"Just some text.\";",
          "    let no_capture_captures = re.captures(no_capture_hay).unwrap();",
          "    let result_no_capture = std::panic::catch_unwind(|| {",
          "    no_capture_captures.extract::<3>()",
          "    });",
          "    assert!(result_no_capture.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
          "    let hay = \"\";",
          "    let captures = re.captures(hay);",
          "    assert!(captures.is_none());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.extract::<3>(), (\"\", [\"\", \"\", \"\"]));",
          "    assert!(captures.is_none());",
          "    assert_eq!(captures.extract::<0>(), (\"\", []));",
          "    assert_eq!(captures.extract::<1>(), (\"\", [\"\"]));",
          "    assert_eq!(captures.extract::<2>(), (\"\", [\"\", \"\"]));",
          "    assert!(!captures.is_some());",
          "    assert!(captures.len() == 0);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
          "    let hay = \"\";",
          "    let captures = re.captures(hay);",
          "    assert!(captures.is_none());",
          "    assert_eq!(captures.extract::<3>(), (\"\", [\"\", \"\", \"\"]));",
          "    assert!(captures.is_none());",
          "    assert_eq!(captures.extract::<0>(), (\"\", []));",
          "    assert_eq!(captures.extract::<1>(), (\"\", [\"\"]));",
          "    assert_eq!(captures.extract::<2>(), (\"\", [\"\", \"\"]));",
          "    assert!(!captures.is_some());",
          "    assert!(captures.len() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
          "    let hay = \"xyz\";",
          "    let captures = re.captures(hay);",
          "    assert!(captures.is_none());",
          "}"
        ],
        "oracle": [
          "    assert!(captures.is_none());",
          "    ",
          "    let captures = re.captures(\"abc\");",
          "    let (whole_match, group_matches) = captures.extract::<3>();",
          "    assert_eq!(whole_match, \"abc\");",
          "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);",
          "    ",
          "    let captures = re.captures(\"a\");",
          "    assert!(captures.is_none());",
          "    ",
          "    let captures = re.captures(\"ab\");",
          "    assert!(captures.is_none());",
          "    ",
          "    let captures = re.captures(\"abcabc\");",
          "    let (whole_match, group_matches) = captures.extract::<3>();",
          "    assert_eq!(whole_match, \"abc\");",
          "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(a)(b)(c)\").unwrap();",
          "    let hay = \"xyz\";",
          "    let captures = re.captures(hay);",
          "    assert!(captures.is_none());",
          "    assert!(captures.is_none());",
          "    ",
          "    let captures = re.captures(\"abc\");",
          "    let (whole_match, group_matches) = captures.extract::<3>();",
          "    assert_eq!(whole_match, \"abc\");",
          "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);",
          "    ",
          "    let captures = re.captures(\"a\");",
          "    assert!(captures.is_none());",
          "    ",
          "    let captures = re.captures(\"ab\");",
          "    assert!(captures.is_none());",
          "    ",
          "    let captures = re.captures(\"abcabc\");",
          "    let (whole_match, group_matches) = captures.extract::<3>();",
          "    assert_eq!(whole_match, \"abc\");",
          "    assert_eq!(group_matches, [\"a\", \"b\", \"c\"]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
          "    let hay = \"1973-01-05, 1975-08-25 and 1980-10-18\";",
          "    let mut dates: Vec<(&str, &str, &str)> = vec![];",
          "    for captures in re.captures_iter(hay) {",
          "        let (full, [year, month, day]) = captures.extract::<3>();",
          "        dates.push((year, month, day));",
          "    }",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dates.len(), 3);",
          "    assert_eq!(dates[0].0, \"1973\");",
          "    assert_eq!(dates[0].1, \"01\");",
          "    assert_eq!(dates[0].2, \"05\");",
          "    assert_eq!(dates[1].0, \"1975\");",
          "    assert_eq!(dates[1].1, \"08\");",
          "    assert_eq!(dates[1].2, \"25\");",
          "    assert_eq!(dates[2].0, \"1980\");",
          "    assert_eq!(dates[2].1, \"10\");",
          "    assert_eq!(dates[2].2, \"18\");"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"([0-9]{4})-([0-9]{2})-([0-9]{2})\").unwrap();",
          "    let hay = \"1973-01-05, 1975-08-25 and 1980-10-18\";",
          "    let mut dates: Vec<(&str, &str, &str)> = vec![];",
          "    for captures in re.captures_iter(hay) {",
          "        let (full, [year, month, day]) = captures.extract::<3>();",
          "        dates.push((year, month, day));",
          "    }",
          "    assert_eq!(dates.len(), 3);",
          "    assert_eq!(dates[0].0, \"1973\");",
          "    assert_eq!(dates[0].1, \"01\");",
          "    assert_eq!(dates[0].2, \"05\");",
          "    assert_eq!(dates[1].0, \"1975\");",
          "    assert_eq!(dates[1].1, \"08\");",
          "    assert_eq!(dates[1].2, \"25\");",
          "    assert_eq!(dates[2].0, \"1980\");",
          "    assert_eq!(dates[2].1, \"10\");",
          "    assert_eq!(dates[2].2, \"18\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"(\\d+)\").unwrap();",
          "    let hay = \"There are 42 apples.\";",
          "    let captures = re.captures(hay).unwrap();",
          "    let (full, [number]) = captures.extract::<1>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(full, \"42\");",
          "    assert_eq!(number, \"42\");",
          "    assert_eq!(captures.len(), 1);",
          "    assert!(captures.get(0).is_some());",
          "    assert!(captures.name(\"0\").is_some());"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"(\\d+)\").unwrap();",
          "    let hay = \"There are 42 apples.\";",
          "    let captures = re.captures(hay).unwrap();",
          "    let (full, [number]) = captures.extract::<1>();",
          "    assert_eq!(full, \"42\");",
          "    assert_eq!(number, \"42\");",
          "    assert_eq!(captures.len(), 1);",
          "    assert!(captures.get(0).is_some());",
          "    assert!(captures.name(\"0\").is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let re = Regex::new(r\"([a-z]+)-([0-9]+)\").unwrap();",
          "    let hay = \"foo-42\";",
          "    let captures = re.captures(hay).unwrap();",
          "    let (_, [string]) = captures.extract::<1>(); // This should panic since N != number of groups",
          "}"
        ],
        "oracle": [
          "    assert_eq!(captures.extract::<1>(), Err(\"asked for 1 groups, but must ask for 2\"));",
          "    assert_eq!(captures.len(), 2);",
          "    assert!(captures.get(0).is_some());",
          "    assert!(captures.get(1).is_some());",
          "    assert!(captures.name(\"0\").is_some());",
          "    assert!(captures.name(\"1\").is_some());",
          "    assert!(captures.iter().count() == captures.len());",
          "    assert!(captures.extract::<2>().0 == \"foo-42\");",
          "    assert!(captures.extract::<2>().1[0] == \"foo\");",
          "    assert!(captures.extract::<2>().1[1] == \"42\");",
          "    assert!(captures.get(0).unwrap().is_empty() == false);",
          "    assert!(captures.get(1).unwrap().is_empty() == false);"
        ],
        "code": [
          "{",
          "    let re = Regex::new(r\"([a-z]+)-([0-9]+)\").unwrap();",
          "    let hay = \"foo-42\";",
          "    let captures = re.captures(hay).unwrap();",
          "    let (_, [string]) = captures.extract::<1>(); // This should panic since N != number of groups",
          "    assert_eq!(captures.extract::<1>(), Err(\"asked for 1 groups, but must ask for 2\"));",
          "    assert_eq!(captures.len(), 2);",
          "    assert!(captures.get(0).is_some());",
          "    assert!(captures.get(1).is_some());",
          "    assert!(captures.name(\"0\").is_some());",
          "    assert!(captures.name(\"1\").is_some());",
          "    assert!(captures.iter().count() == captures.len());",
          "    assert!(captures.extract::<2>().0 == \"foo-42\");",
          "    assert!(captures.extract::<2>().1[0] == \"foo\");",
          "    assert!(captures.extract::<2>().1[1] == \"42\");",
          "    assert!(captures.get(0).unwrap().is_empty() == false);",
          "    assert!(captures.get(1).unwrap().is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]