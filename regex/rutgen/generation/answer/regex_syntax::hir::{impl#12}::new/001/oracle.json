[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges: Vec<ClassUnicodeRange> = vec![];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "}"
        ],
        "oracle": [
          "    let ranges: Vec<ClassUnicodeRange> = vec![];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 0);",
          "    assert!(class_unicode.set.folded == false);",
          "    let ranges: Vec<ClassUnicodeRange> = vec![ClassUnicodeRange{ start: 'a', end: 'z' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0].start, 'a');",
          "    assert_eq!(class_unicode.set.ranges[0].end, 'z');",
          "    let ranges: Vec<ClassUnicodeRange> = vec![ClassUnicodeRange{ start: 'a', end: 'c' }, ClassUnicodeRange{ start: 'b', end: 'd' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0].start, 'a');",
          "    assert_eq!(class_unicode.set.ranges[0].end, 'd');",
          "    let ranges: Vec<ClassUnicodeRange> = vec![ClassUnicodeRange{ start: 'A', end: 'Z' }, ClassUnicodeRange{ start: 'a', end: 'z' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 2);",
          "    assert_eq!(class_unicode.set.ranges[0].start, 'A');",
          "    assert_eq!(class_unicode.set.ranges[1].start, 'a');"
        ],
        "code": [
          "{",
          "    let ranges: Vec<ClassUnicodeRange> = vec![];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    let ranges: Vec<ClassUnicodeRange> = vec![];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 0);",
          "    assert!(class_unicode.set.folded == false);",
          "    let ranges: Vec<ClassUnicodeRange> = vec![ClassUnicodeRange{ start: 'a', end: 'z' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0].start, 'a');",
          "    assert_eq!(class_unicode.set.ranges[0].end, 'z');",
          "    let ranges: Vec<ClassUnicodeRange> = vec![ClassUnicodeRange{ start: 'a', end: 'c' }, ClassUnicodeRange{ start: 'b', end: 'd' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0].start, 'a');",
          "    assert_eq!(class_unicode.set.ranges[0].end, 'd');",
          "    let ranges: Vec<ClassUnicodeRange> = vec![ClassUnicodeRange{ start: 'A', end: 'Z' }, ClassUnicodeRange{ start: 'a', end: 'z' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 2);",
          "    assert_eq!(class_unicode.set.ranges[0].start, 'A');",
          "    assert_eq!(class_unicode.set.ranges[1].start, 'a');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![ClassUnicodeRange { start: 'a', end: 'b' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0], ClassUnicodeRange { start: 'a', end: 'b' });",
          "    ",
          "    let empty_ranges: Vec<ClassUnicodeRange> = vec![];",
          "    let empty_class_unicode = ClassUnicode::new(empty_ranges);",
          "    assert_eq!(empty_class_unicode.set.ranges.len(), 0);",
          "    ",
          "    let overlapping_ranges = vec![",
          "    ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ClassUnicodeRange { start: 'b', end: 'd' }",
          "    ];",
          "    let overlapping_class_unicode = ClassUnicode::new(overlapping_ranges);",
          "    assert_eq!(overlapping_class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(overlapping_class_unicode.set.ranges[0], ClassUnicodeRange { start: 'a', end: 'd' });",
          "    ",
          "    let unordered_ranges = vec![",
          "    ClassUnicodeRange { start: 'z', end: 'z' },",
          "    ClassUnicodeRange { start: 'a', end: 'a' }",
          "    ];",
          "    let unordered_class_unicode = ClassUnicode::new(unordered_ranges);",
          "    assert_eq!(unordered_class_unicode.set.ranges.len(), 2);",
          "    assert_eq!(unordered_class_unicode.set.ranges[0], ClassUnicodeRange { start: 'a', end: 'a' });",
          "    assert_eq!(unordered_class_unicode.set.ranges[1], ClassUnicodeRange { start: 'z', end: 'z' });"
        ],
        "code": [
          "{",
          "    let ranges = vec![ClassUnicodeRange { start: 'a', end: 'b' }];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0], ClassUnicodeRange { start: 'a', end: 'b' });",
          "    ",
          "    let empty_ranges: Vec<ClassUnicodeRange> = vec![];",
          "    let empty_class_unicode = ClassUnicode::new(empty_ranges);",
          "    assert_eq!(empty_class_unicode.set.ranges.len(), 0);",
          "    ",
          "    let overlapping_ranges = vec![",
          "    ClassUnicodeRange { start: 'a', end: 'c' },",
          "    ClassUnicodeRange { start: 'b', end: 'd' }",
          "    ];",
          "    let overlapping_class_unicode = ClassUnicode::new(overlapping_ranges);",
          "    assert_eq!(overlapping_class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(overlapping_class_unicode.set.ranges[0], ClassUnicodeRange { start: 'a', end: 'd' });",
          "    ",
          "    let unordered_ranges = vec![",
          "    ClassUnicodeRange { start: 'z', end: 'z' },",
          "    ClassUnicodeRange { start: 'a', end: 'a' }",
          "    ];",
          "    let unordered_class_unicode = ClassUnicode::new(unordered_ranges);",
          "    assert_eq!(unordered_class_unicode.set.ranges.len(), 2);",
          "    assert_eq!(unordered_class_unicode.set.ranges[0], ClassUnicodeRange { start: 'a', end: 'a' });",
          "    assert_eq!(unordered_class_unicode.set.ranges[1], ClassUnicodeRange { start: 'z', end: 'z' });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'a', end: 'b' },",
          "        ClassUnicodeRange { start: 'd', end: 'e' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "}"
        ],
        "oracle": [
          "    assert!(class_unicode == ClassUnicode { set: IntervalSet::new(vec![ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'e' }]) });"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'a', end: 'b' },",
          "        ClassUnicodeRange { start: 'd', end: 'e' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert!(class_unicode == ClassUnicode { set: IntervalSet::new(vec![ClassUnicodeRange { start: 'a', end: 'b' }, ClassUnicodeRange { start: 'd', end: 'e' }]) });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "        ClassUnicodeRange { start: 'b', end: 'd' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges().len(), 2);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'a', end: 'd' });",
          "    assert!(class_unicode.set.folded == false);",
          "    assert_eq!(class_unicode.minimum_len(), Some(1));",
          "    assert_eq!(class_unicode.maximum_len(), Some(3));"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'a', end: 'c' },",
          "        ClassUnicodeRange { start: 'b', end: 'd' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.ranges().len(), 2);",
          "    assert_eq!(class_unicode.ranges()[0], ClassUnicodeRange { start: 'a', end: 'd' });",
          "    assert!(class_unicode.set.folded == false);",
          "    assert_eq!(class_unicode.minimum_len(), Some(1));",
          "    assert_eq!(class_unicode.maximum_len(), Some(3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: char::MIN, end: char::MAX },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0].start, char::MIN);",
          "    assert_eq!(class_unicode.set.ranges[0].end, char::MAX);",
          "    assert!(class_unicode.set.folded == false);"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: char::MIN, end: char::MAX },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 1);",
          "    assert_eq!(class_unicode.set.ranges[0].start, char::MIN);",
          "    assert_eq!(class_unicode.set.ranges[0].end, char::MAX);",
          "    assert!(class_unicode.set.folded == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'c', end: 'a' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.set.ranges.len(), 0);",
          "    assert!(class_unicode.set.folded == false);",
          "    assert!(class_unicode.set.ranges.is_empty());"
        ],
        "code": [
          "{",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'c', end: 'a' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "    assert_eq!(class_unicode.set.ranges.len(), 0);",
          "    assert!(class_unicode.set.folded == false);",
          "    assert!(class_unicode.set.ranges.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]