[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seq = Seq { literals: None };",
          "    let result = seq.literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    ",
          "    let seq = Seq { literals: Some(vec![]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[]));",
          "    ",
          "    let lit = Literal(vec![b'a']);",
          "    let seq = Seq { literals: Some(vec![lit.clone()]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[lit]));",
          "    ",
          "    let lit1 = Literal(vec![b'a']);",
          "    let lit2 = Literal(vec![b'b']);",
          "    let seq = Seq { literals: Some(vec![lit1.clone(), lit2.clone()]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[lit1, lit2]));"
        ],
        "code": [
          "{",
          "    let seq = Seq { literals: None };",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    ",
          "    let seq = Seq { literals: Some(vec![]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[]));",
          "    ",
          "    let lit = Literal(vec![b'a']);",
          "    let seq = Seq { literals: Some(vec![lit.clone()]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[lit]));",
          "    ",
          "    let lit1 = Literal(vec![b'a']);",
          "    let lit2 = Literal(vec![b'b']);",
          "    let seq = Seq { literals: Some(vec![lit1.clone(), lit2.clone()]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[lit1, lit2]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seq = Seq { literals: Some(vec![]) };",
          "    let result = seq.literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(&[]));",
          "    ",
          "    let seq = Seq { literals: None };",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    ",
          "    let lit1 = Literal { bytes: vec![b'a'], exact: true };",
          "    let lit2 = Literal { bytes: vec![b'b'], exact: false };",
          "    let seq = Seq { literals: Some(vec![lit1.clone(), lit2.clone()]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[lit1, lit2]));"
        ],
        "code": [
          "{",
          "    let seq = Seq { literals: Some(vec![]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[]));",
          "    ",
          "    let seq = Seq { literals: None };",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    ",
          "    let lit1 = Literal { bytes: vec![b'a'], exact: true };",
          "    let lit2 = Literal { bytes: vec![b'b'], exact: false };",
          "    let seq = Seq { literals: Some(vec![lit1.clone(), lit2.clone()]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[lit1, lit2]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Literal { bytes: vec![0], exact: true };",
          "    let seq = Seq { literals: Some(vec![literal]) };",
          "    let result = seq.literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(vec![Literal { bytes: vec![0], exact: true }].as_slice()));",
          "    seq.literals = None;",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    seq.literals = Some(vec![]);",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[]));"
        ],
        "code": [
          "{",
          "    let literal = Literal { bytes: vec![0], exact: true };",
          "    let seq = Seq { literals: Some(vec![literal]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(vec![Literal { bytes: vec![0], exact: true }].as_slice()));",
          "    seq.literals = None;",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    seq.literals = Some(vec![]);",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal1 = Literal { bytes: vec![0], exact: true };",
          "    let literal2 = Literal { bytes: vec![1], exact: false };",
          "    let seq = Seq { literals: Some(vec![literal1, literal2]) };",
          "    let result = seq.literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(&[literal1, literal2]));",
          "    seq.literals = None;",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    seq.literals = Some(vec![]);",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[]));"
        ],
        "code": [
          "{",
          "    let literal1 = Literal { bytes: vec![0], exact: true };",
          "    let literal2 = Literal { bytes: vec![1], exact: false };",
          "    let seq = Seq { literals: Some(vec![literal1, literal2]) };",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[literal1, literal2]));",
          "    seq.literals = None;",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    seq.literals = Some(vec![]);",
          "    let result = seq.literals();",
          "    assert_eq!(result, Some(&[]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seq = Seq::infinite();",
          "    let result = seq.literals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);",
          "    ",
          "    let seq_empty = Seq::empty();",
          "    let result_empty = seq_empty.literals();",
          "    assert_eq!(result_empty, None);",
          "    ",
          "    let lit = Literal(vec![b'a']);",
          "    let seq_singleton = Seq::singleton(lit.clone());",
          "    let result_singleton = seq_singleton.literals();",
          "    assert_eq!(result_singleton, Some(&[lit]));",
          "    ",
          "    let seq_new = Seq::new(vec![b'a', b'b']);",
          "    let result_new = seq_new.literals();",
          "    assert!(result_new.is_none() || result_new.unwrap().len() > 0);"
        ],
        "code": [
          "{",
          "    let seq = Seq::infinite();",
          "    let result = seq.literals();",
          "    assert_eq!(result, None);",
          "    ",
          "    let seq_empty = Seq::empty();",
          "    let result_empty = seq_empty.literals();",
          "    assert_eq!(result_empty, None);",
          "    ",
          "    let lit = Literal(vec![b'a']);",
          "    let seq_singleton = Seq::singleton(lit.clone());",
          "    let result_singleton = seq_singleton.literals();",
          "    assert_eq!(result_singleton, Some(&[lit]));",
          "    ",
          "    let seq_new = Seq::new(vec![b'a', b'b']);",
          "    let result_new = seq_new.literals();",
          "    assert!(result_new.is_none() || result_new.unwrap().len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]