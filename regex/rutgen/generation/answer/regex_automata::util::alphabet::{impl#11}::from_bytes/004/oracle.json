[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 32] = [",
          "        1, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        1, 0, 0, 0, 0, 0, 0, 0, // high bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0  // high bucket",
          "    ];",
          "    let result = ByteSet::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok((ByteSet { bits: BitSet([1, 1]) }, 16)));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.as_ref().unwrap().1, 16);",
          "    assert_eq!(result.as_ref().unwrap().0.bits.0[0], 1);",
          "    assert_eq!(result.as_ref().unwrap().0.bits.0[1], 1);",
          "    assert_eq!(result.is_err(), false);",
          "    assert!(result.as_ref().unwrap().0.contains(1));",
          "    assert!(result.as_ref().unwrap().0.contains_range(0, 255));",
          "    assert!(!result.as_ref().unwrap().0.is_empty());"
        ],
        "code": [
          "{",
          "    let slice: [u8; 32] = [",
          "        1, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        1, 0, 0, 0, 0, 0, 0, 0, // high bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0  // high bucket",
          "    ];",
          "    let result = ByteSet::from_bytes(&slice);",
          "    assert_eq!(result, Ok((ByteSet { bits: BitSet([1, 1]) }, 16)));",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.as_ref().unwrap().1, 16);",
          "    assert_eq!(result.as_ref().unwrap().0.bits.0[0], 1);",
          "    assert_eq!(result.as_ref().unwrap().0.bits.0[1], 1);",
          "    assert_eq!(result.is_err(), false);",
          "    assert!(result.as_ref().unwrap().0.contains(1));",
          "    assert!(result.as_ref().unwrap().0.contains_range(0, 255));",
          "    assert!(!result.as_ref().unwrap().0.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 32] = [",
          "        0, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        255, 255, 255, 255, 255, 255, 255, 255, // high bucket",
          "        255, 255, 255, 255, 255, 255, 255, 255  // high bucket",
          "    ];",
          "    let result = ByteSet::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (byte_set, nread) = result.unwrap();",
          "    assert_eq!(nread, 32);",
          "    assert!(byte_set.contains_range(0, 255));",
          "    assert!(byte_set.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let slice: [u8; 32] = [",
          "        0, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0, // low bucket",
          "        255, 255, 255, 255, 255, 255, 255, 255, // high bucket",
          "        255, 255, 255, 255, 255, 255, 255, 255  // high bucket",
          "    ];",
          "    let result = ByteSet::from_bytes(&slice);",
          "    assert!(result.is_ok());",
          "    let (byte_set, nread) = result.unwrap();",
          "    assert_eq!(nread, 32);",
          "    assert!(byte_set.contains_range(0, 255));",
          "    assert!(byte_set.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 32] = [",
          "        255, 255, 255, 255, 255, 255, 255, 255, // low bucket",
          "        255, 255, 255, 255, 255, 255, 255, 255, // low bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0, // high bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0  // high bucket",
          "    ];",
          "    let result = ByteSet::from_bytes(&slice);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let (byte_set, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, 32);",
          "    assert!(!byte_set.is_empty());",
          "    assert!(byte_set.contains(255));",
          "    assert!(!byte_set.contains(0));"
        ],
        "code": [
          "{",
          "    let slice: [u8; 32] = [",
          "        255, 255, 255, 255, 255, 255, 255, 255, // low bucket",
          "        255, 255, 255, 255, 255, 255, 255, 255, // low bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0, // high bucket",
          "        0, 0, 0, 0, 0, 0, 0, 0  // high bucket",
          "    ];",
          "    let result = ByteSet::from_bytes(&slice);",
          "    assert!(result.is_ok());",
          "    let (byte_set, bytes_read) = result.unwrap();",
          "    assert_eq!(bytes_read, 32);",
          "    assert!(!byte_set.is_empty());",
          "    assert!(byte_set.contains(255));",
          "    assert!(!byte_set.contains(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice1: [u8; 32] = [",
          "        1, 2, 3, 4, 5, 6, 7, 8, // low bucket",
          "        9, 10, 11, 12, 13, 14, 15, 16, // low bucket",
          "        17, 18, 19, 20, 21, 22, 23, 24, // high bucket",
          "        25, 26, 27, 28, 29, 30, 31, 32  // high bucket",
          "    ];",
          "    let result1 = ByteSet::from_bytes(&slice1);",
          "",
          "    let slice2: [u8; 32] = [",
          "        8, 7, 6, 5, 4, 3, 2, 1, // low bucket",
          "        16, 15, 14, 13, 12, 11, 10, 9, // low bucket",
          "        24, 23, 22, 21, 20, 19, 18, 17, // high bucket",
          "        32, 31, 30, 29, 28, 27, 26, 25  // high bucket",
          "    ];",
          "    let result2 = ByteSet::from_bytes(&slice2);",
          "}"
        ],
        "oracle": [
          "    assert!(result1.is_ok());",
          "    assert_eq!(result1.unwrap().1, 32);",
          "    assert_eq!(result1.unwrap().0.bits.0, 0x04030201_08070605);",
          "    assert_eq!(result1.unwrap().0.bits.1, 0x10111213_14151617);",
          "    assert!(result2.is_ok());",
          "    assert_eq!(result2.unwrap().1, 32);",
          "    assert_eq!(result2.unwrap().0.bits.0, 0x01020304_05060708);",
          "    assert_eq!(result2.unwrap().0.bits.1, 0x1718191A_1B1C1D1E);"
        ],
        "code": [
          "{",
          "    let slice1: [u8; 32] = [",
          "        1, 2, 3, 4, 5, 6, 7, 8, // low bucket",
          "        9, 10, 11, 12, 13, 14, 15, 16, // low bucket",
          "        17, 18, 19, 20, 21, 22, 23, 24, // high bucket",
          "        25, 26, 27, 28, 29, 30, 31, 32  // high bucket",
          "    ];",
          "    let result1 = ByteSet::from_bytes(&slice1);",
          "",
          "    let slice2: [u8; 32] = [",
          "        8, 7, 6, 5, 4, 3, 2, 1, // low bucket",
          "        16, 15, 14, 13, 12, 11, 10, 9, // low bucket",
          "        24, 23, 22, 21, 20, 19, 18, 17, // high bucket",
          "        32, 31, 30, 29, 28, 27, 26, 25  // high bucket",
          "    ];",
          "    let result2 = ByteSet::from_bytes(&slice2);",
          "    assert!(result1.is_ok());",
          "    assert_eq!(result1.unwrap().1, 32);",
          "    assert_eq!(result1.unwrap().0.bits.0, 0x04030201_08070605);",
          "    assert_eq!(result1.unwrap().0.bits.1, 0x10111213_14151617);",
          "    assert!(result2.is_ok());",
          "    assert_eq!(result2.unwrap().1, 32);",
          "    assert_eq!(result2.unwrap().0.bits.0, 0x01020304_05060708);",
          "    assert_eq!(result2.unwrap().0.bits.1, 0x1718191A_1B1C1D1E);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]