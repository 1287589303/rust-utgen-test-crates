[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd, Eq, Ord)]",
      "struct TestBound(u32);",
      "",
      "impl TestBound {",
      "    fn increment(self) -> Self {",
      "        TestBound(self.0 + 1)",
      "    }",
      "    fn decrement(self) -> Self {",
      "        TestBound(self.0 - 1)",
      "    }",
      "}",
      "",
      "#[derive(Clone, Debug, Default, PartialEq, PartialOrd, Eq, Ord)]",
      "struct TestInterval {",
      "    lower: TestBound,",
      "    upper: TestBound,",
      "}",
      "",
      "impl super::Interval for TestInterval {",
      "    type Bound = TestBound;",
      "",
      "    fn lower(&self) -> Self::Bound {",
      "        self.lower",
      "    }",
      "",
      "    fn upper(&self) -> Self::Bound {",
      "        self.upper",
      "    }",
      "",
      "    fn set_lower(&mut self, bound: Self::Bound) {",
      "        self.lower = bound;",
      "    }",
      "",
      "    fn set_upper(&mut self, bound: Self::Bound) {",
      "        self.upper = bound;",
      "    }",
      "",
      "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) -> Result<(), unicode::CaseFoldError> {",
      "        Ok(())",
      "    }",
      "",
      "    fn is_contiguous(&self, other: &Self) -> bool {",
      "        // Simple check assuming only direct bounds matter",
      "        self.upper >= other.lower && self.lower <= other.upper",
      "    }",
      "",
      "    fn is_intersection_empty(&self, other: &Self) -> bool {",
      "        self.upper < other.lower || other.upper < self.lower",
      "    }",
      "",
      "    fn is_subset(&self, other: &Self) -> bool {",
      "        self.lower >= other.lower && self.upper <= other.upper",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![]);",
          "    let _result = interval_set.intervals();",
          "}"
        ],
        "oracle": [
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![]);",
          "    assert_eq!(interval_set.intervals(), &[]);",
          "    ",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![TestInterval { lower: TestBound(1), upper: TestBound(5) }]);",
          "    assert_eq!(interval_set.intervals(), &[TestInterval { lower: TestBound(1), upper: TestBound(5) }]);",
          "    ",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![TestInterval { lower: TestBound(3), upper: TestBound(8) }, TestInterval { lower: TestBound(10), upper: TestBound(15) }]);",
          "    assert_eq!(interval_set.intervals(), &[TestInterval { lower: TestBound(3), upper: TestBound(8) }, TestInterval { lower: TestBound(10), upper: TestBound(15) }]);",
          "    ",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![TestInterval { lower: TestBound(5), upper: TestBound(10) }, TestInterval { lower: TestBound(2), upper: TestBound(3) }]);",
          "    let result = interval_set.intervals();",
          "    assert_eq!(result.len(), 2);",
          "    assert!(result.contains(&TestInterval { lower: TestBound(5), upper: TestBound(10) }));",
          "    assert!(result.contains(&TestInterval { lower: TestBound(2), upper: TestBound(3) }));"
        ],
        "code": [
          "{",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![]);",
          "    let _result = interval_set.intervals();",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![]);",
          "    assert_eq!(interval_set.intervals(), &[]);",
          "    ",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![TestInterval { lower: TestBound(1), upper: TestBound(5) }]);",
          "    assert_eq!(interval_set.intervals(), &[TestInterval { lower: TestBound(1), upper: TestBound(5) }]);",
          "    ",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![TestInterval { lower: TestBound(3), upper: TestBound(8) }, TestInterval { lower: TestBound(10), upper: TestBound(15) }]);",
          "    assert_eq!(interval_set.intervals(), &[TestInterval { lower: TestBound(3), upper: TestBound(8) }, TestInterval { lower: TestBound(10), upper: TestBound(15) }]);",
          "    ",
          "    let interval_set: super::IntervalSet<TestInterval> = super::IntervalSet::new(vec![TestInterval { lower: TestBound(5), upper: TestBound(10) }, TestInterval { lower: TestBound(2), upper: TestBound(3) }]);",
          "    let result = interval_set.intervals();",
          "    assert_eq!(result.len(), 2);",
          "    assert!(result.contains(&TestInterval { lower: TestBound(5), upper: TestBound(10) }));",
          "    assert!(result.contains(&TestInterval { lower: TestBound(2), upper: TestBound(3) }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![TestInterval { lower: TestBound(1), upper: TestBound(2) }]);",
          "    let _result = interval_set.intervals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(",
          "    interval_set.intervals(),",
          "    &[TestInterval { lower: TestBound(1), upper: TestBound(2) }]",
          "    );"
        ],
        "code": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![TestInterval { lower: TestBound(1), upper: TestBound(2) }]);",
          "    let _result = interval_set.intervals();",
          "    assert_eq!(",
          "    interval_set.intervals(),",
          "    &[TestInterval { lower: TestBound(1), upper: TestBound(2) }]",
          "    );",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(4) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(interval_set.intervals().len(), 2);",
          "    assert_eq!(interval_set.intervals()[0], TestInterval { lower: TestBound(1), upper: TestBound(2) });",
          "    assert_eq!(interval_set.intervals()[1], TestInterval { lower: TestBound(3), upper: TestBound(4) });",
          "    assert!(interval_set.intervals() as *const _ == &interval_set.ranges as *const _);",
          "    assert!(interval_set.intervals().is_empty() == false);"
        ],
        "code": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(4) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "    assert_eq!(interval_set.intervals().len(), 2);",
          "    assert_eq!(interval_set.intervals()[0], TestInterval { lower: TestBound(1), upper: TestBound(2) });",
          "    assert_eq!(interval_set.intervals()[1], TestInterval { lower: TestBound(3), upper: TestBound(4) });",
          "    assert!(interval_set.intervals() as *const _ == &interval_set.ranges as *const _);",
          "    assert!(interval_set.intervals().is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "        TestInterval { lower: TestBound(2), upper: TestBound(4) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(interval_set.intervals(), &vec![TestInterval { lower: TestBound(1), upper: TestBound(3) }, TestInterval { lower: TestBound(2), upper: TestBound(4) }]);",
          "    let empty_set = super::IntervalSet::new(vec![]);",
          "    assert_eq!(empty_set.intervals(), &vec![]);",
          "    let single_interval_set = super::IntervalSet::new(vec![TestInterval { lower: TestBound(5), upper: TestBound(5) }]);",
          "    assert_eq!(single_interval_set.intervals(), &vec![TestInterval { lower: TestBound(5), upper: TestBound(5) }]);"
        ],
        "code": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "        TestInterval { lower: TestBound(2), upper: TestBound(4) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "    assert_eq!(interval_set.intervals(), &vec![TestInterval { lower: TestBound(1), upper: TestBound(3) }, TestInterval { lower: TestBound(2), upper: TestBound(4) }]);",
          "    let empty_set = super::IntervalSet::new(vec![]);",
          "    assert_eq!(empty_set.intervals(), &vec![]);",
          "    let single_interval_set = super::IntervalSet::new(vec![TestInterval { lower: TestBound(5), upper: TestBound(5) }]);",
          "    assert_eq!(single_interval_set.intervals(), &vec![TestInterval { lower: TestBound(5), upper: TestBound(5) }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(1) },",
          "        TestInterval { lower: TestBound(1), upper: TestBound(1) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(interval_set.intervals(), &vec![TestInterval { lower: TestBound(1), upper: TestBound(1) }, TestInterval { lower: TestBound(1), upper: TestBound(1) }]);",
          "    let interval_set_empty = super::IntervalSet::new(vec![]);",
          "    assert_eq!(interval_set_empty.intervals(), &vec![]);",
          "    let interval_set_multiple = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(6) },",
          "    ]);",
          "    assert_eq!(interval_set_multiple.intervals(), &vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(6) },",
          "    ]);",
          "    let interval_set_with_overlap = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(4) },",
          "    ]);",
          "    assert_eq!(interval_set_with_overlap.intervals(), &vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(4) },",
          "    ]);",
          "    let interval_set_with_different_order = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    ]);",
          "    assert_eq!(interval_set_with_different_order.intervals(), &vec![",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    ]);"
        ],
        "code": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(1) },",
          "        TestInterval { lower: TestBound(1), upper: TestBound(1) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "    assert_eq!(interval_set.intervals(), &vec![TestInterval { lower: TestBound(1), upper: TestBound(1) }, TestInterval { lower: TestBound(1), upper: TestBound(1) }]);",
          "    let interval_set_empty = super::IntervalSet::new(vec![]);",
          "    assert_eq!(interval_set_empty.intervals(), &vec![]);",
          "    let interval_set_multiple = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(6) },",
          "    ]);",
          "    assert_eq!(interval_set_multiple.intervals(), &vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(6) },",
          "    ]);",
          "    let interval_set_with_overlap = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(4) },",
          "    ]);",
          "    assert_eq!(interval_set_with_overlap.intervals(), &vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(4) },",
          "    ]);",
          "    let interval_set_with_different_order = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    ]);",
          "    assert_eq!(interval_set_with_different_order.intervals(), &vec![",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    ]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "        TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(3) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "}"
        ],
        "oracle": [
          "    let interval_set = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(3) },",
          "    ]);",
          "    assert_eq!(_result, &vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    ]);"
        ],
        "code": [
          "{",
          "    let interval_set = super::IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "        TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(3) },",
          "    ]);",
          "    let _result = interval_set.intervals();",
          "    let interval_set = super::IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(3) },",
          "    ]);",
          "    assert_eq!(_result, &vec![",
          "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "    TestInterval { lower: TestBound(3), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(4), upper: TestBound(5) },",
          "    ]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]