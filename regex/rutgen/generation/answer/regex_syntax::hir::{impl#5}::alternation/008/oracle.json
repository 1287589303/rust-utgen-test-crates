[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.kind, HirKind::Class(Class::Unicode(ClassUnicode::new([ClassUnicodeRange::new('a', 'c')]))));",
          "    assert!(new.len() == 1);",
          "    assert!(new.is_empty() == false);",
          "    assert!(singleton_chars(&new).is_some());"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "    assert_eq!(_result.kind, HirKind::Class(Class::Unicode(ClassUnicode::new([ClassUnicodeRange::new('a', 'c')]))));",
          "    assert!(new.len() == 1);",
          "    assert!(new.is_empty() == false);",
          "    assert!(singleton_chars(&new).is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'z']),",
          "        Hir::literal([b'x']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "}"
        ],
        "oracle": [
          "    Hir::alternation(vec![Hir::literal([b'z']), Hir::literal([b'x'])]);",
          "    Hir::class(Class::Unicode(ClassUnicode::new([ClassUnicodeRange::new('x', 'z')])));",
          "    assert_eq!(expected, result);"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'z']),",
          "        Hir::literal([b'x']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "    Hir::alternation(vec![Hir::literal([b'z']), Hir::literal([b'x'])]);",
          "    Hir::class(Class::Unicode(ClassUnicode::new([ClassUnicodeRange::new('x', 'z')])));",
          "    assert_eq!(expected, result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'g']),",
          "        Hir::literal([b'h']),",
          "        Hir::literal([b'i']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.kind, HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'i')])));",
          "    assert!(!_result.props.is_empty());",
          "    assert_eq!(_result.props, Properties::class(&Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'i')])));",
          "    assert_eq!(_result, Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'i')])));",
          "    assert!(matches!(_result.kind, HirKind::Class(Class::Unicode(_))));"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'g']),",
          "        Hir::literal([b'h']),",
          "        Hir::literal([b'i']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "    assert_eq!(_result.kind, HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'i')])));",
          "    assert!(!_result.props.is_empty());",
          "    assert_eq!(_result.props, Properties::class(&Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'i')])));",
          "    assert_eq!(_result, Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'i')])));",
          "    assert!(matches!(_result.kind, HirKind::Class(Class::Unicode(_))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'1']),",
          "        Hir::literal([b'2']),",
          "        Hir::literal([b'3']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "}"
        ],
        "oracle": [
          "    Hir::alternation(vec![Hir::literal([b'1']), Hir::literal([b'2']), Hir::literal([b'3'])]);",
          "    Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('1', '3')])))",
          "    assert_eq!(expected, hir);",
          "    expected;"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'1']),",
          "        Hir::literal([b'2']),",
          "        Hir::literal([b'3']),",
          "    ]);",
          "    let _result = hir; // Call the function under test with the generated input",
          "    Hir::alternation(vec![Hir::literal([b'1']), Hir::literal([b'2']), Hir::literal([b'3'])]);",
          "    Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('1', '3')])))",
          "    assert_eq!(expected, hir);",
          "    expected;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]