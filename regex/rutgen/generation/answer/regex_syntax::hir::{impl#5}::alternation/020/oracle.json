[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    // Expected behavior is that this should simplify to a class:",
          "    let _ = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![",
          "    Hir::literal([b'a']),",
          "    Hir::literal([b'b']),",
          "    Hir::literal([b'c']),",
          "    ]);",
          "    let expected = Hir::class(Class::Unicode(ClassUnicode::new([",
          "    ClassUnicodeRange::new('a', 'c'),",
          "    ])));",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'a']),",
          "        Hir::literal([b'b']),",
          "        Hir::literal([b'c']),",
          "    ]);",
          "    // Expected behavior is that this should simplify to a class:",
          "    let _ = hir;",
          "    let hir = Hir::alternation(vec![",
          "    Hir::literal([b'a']),",
          "    Hir::literal([b'b']),",
          "    Hir::literal([b'c']),",
          "    ]);",
          "    let expected = Hir::class(Class::Unicode(ClassUnicode::new([",
          "    ClassUnicodeRange::new('a', 'c'),",
          "    ])));",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'x']),",
          "        Hir::literal([b'y']),",
          "        Hir::literal([b'z']),",
          "    ]);",
          "    // Expected behavior is that this should simplify to a bytes class:",
          "    let _ = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![Hir::literal([b'x']), Hir::literal([b'y']), Hir::literal([b'z'])]);",
          "    let expected = Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(b'x', b'z')])));",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::literal([b'x']),",
          "        Hir::literal([b'y']),",
          "        Hir::literal([b'z']),",
          "    ]);",
          "    // Expected behavior is that this should simplify to a bytes class:",
          "    let _ = hir;",
          "    let hir = Hir::alternation(vec![Hir::literal([b'x']), Hir::literal([b'y']), Hir::literal([b'z'])]);",
          "    let expected = Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(b'x', b'z')])));",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "            ClassUnicodeRange::new('d', 'f'),",
          "        ]))),",
          "        Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "            ClassUnicodeRange::new('a', 'c'),",
          "        ]))),",
          "    ]);",
          "    // Expected behavior is that this should simplify into a character class:",
          "    let _ = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![",
          "    Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "    ClassUnicodeRange::new('d', 'f'),",
          "    ]))),",
          "    Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "    ClassUnicodeRange::new('a', 'c'),",
          "    ]))),",
          "    ]);",
          "    let expected = Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "    ClassUnicodeRange::new('a', 'f'),",
          "    ])));",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "            ClassUnicodeRange::new('d', 'f'),",
          "        ]))),",
          "        Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "            ClassUnicodeRange::new('a', 'c'),",
          "        ]))),",
          "    ]);",
          "    // Expected behavior is that this should simplify into a character class:",
          "    let _ = hir;",
          "    let hir = Hir::alternation(vec![",
          "    Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "    ClassUnicodeRange::new('d', 'f'),",
          "    ]))),",
          "    Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "    ClassUnicodeRange::new('a', 'c'),",
          "    ]))),",
          "    ]);",
          "    let expected = Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "    ClassUnicodeRange::new('a', 'f'),",
          "    ])));",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange::new(120, 122),",
          "        ]))),",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange::new(97, 99),",
          "        ]))),",
          "    ]);",
          "    // Expected behavior is that this should simplify into a bytes class:",
          "    let _ = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![",
          "    Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "    ClassBytesRange::new(120, 122),",
          "    ]))),",
          "    Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "    ClassBytesRange::new(97, 99),",
          "    ]))),",
          "    ]);",
          "    assert!(hir.kind == HirKind::Class(Class::Bytes(ClassBytes::new(vec![",
          "    ClassBytesRange::new(97, 122),",
          "    ]))));",
          "    assert!(!hir.props.is_empty());",
          "    assert!(hir.props.contains_bytes());",
          "    assert!(hir.props.is_simplified());",
          "    assert_eq!(hir.kind().as_class().unwrap().length(), 2);",
          "    assert!(lift_common_prefix(hir).is_ok());"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange::new(120, 122),",
          "        ]))),",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange::new(97, 99),",
          "        ]))),",
          "    ]);",
          "    // Expected behavior is that this should simplify into a bytes class:",
          "    let _ = hir;",
          "    let hir = Hir::alternation(vec![",
          "    Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "    ClassBytesRange::new(120, 122),",
          "    ]))),",
          "    Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "    ClassBytesRange::new(97, 99),",
          "    ]))),",
          "    ]);",
          "    assert!(hir.kind == HirKind::Class(Class::Bytes(ClassBytes::new(vec![",
          "    ClassBytesRange::new(97, 122),",
          "    ]))));",
          "    assert!(!hir.props.is_empty());",
          "    assert!(hir.props.contains_bytes());",
          "    assert!(hir.props.is_simplified());",
          "    assert_eq!(hir.kind().as_class().unwrap().length(), 2);",
          "    assert!(lift_common_prefix(hir).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal(b\"xyz\"),",
          "            Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "                ClassUnicodeRange::new('G', 'Z'),",
          "            ]))),",
          "        ]),",
          "        Hir::concat(vec![",
          "            Hir::literal(b\"xyz\"),",
          "            Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "                ClassUnicodeRange::new('g', 'z'),",
          "            ]))),",
          "        ]),",
          "    ]);",
          "    // Expected behavior is that this should factor out the common \"xyz\":",
          "    let _ = hir;",
          "}"
        ],
        "oracle": [
          "    let hir = Hir::alternation(vec![Hir::concat(vec![Hir::literal(b\"xyz\"), Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('G', 'Z')])))]), Hir::concat(vec![Hir::literal(b\"xyz\"), Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'z')])))]),]);",
          "    ",
          "    let expected = Hir::concat(vec![Hir::literal(b\"xyz\"), Hir::alternation(vec![Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('G', 'Z')]))) , Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'z')])))]),]);",
          "    ",
          "    assert_eq!(expected, hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir::alternation(vec![",
          "        Hir::concat(vec![",
          "            Hir::literal(b\"xyz\"),",
          "            Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "                ClassUnicodeRange::new('G', 'Z'),",
          "            ]))),",
          "        ]),",
          "        Hir::concat(vec![",
          "            Hir::literal(b\"xyz\"),",
          "            Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "                ClassUnicodeRange::new('g', 'z'),",
          "            ]))),",
          "        ]),",
          "    ]);",
          "    // Expected behavior is that this should factor out the common \"xyz\":",
          "    let _ = hir;",
          "    let hir = Hir::alternation(vec![Hir::concat(vec![Hir::literal(b\"xyz\"), Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('G', 'Z')])))]), Hir::concat(vec![Hir::literal(b\"xyz\"), Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'z')])))]),]);",
          "    ",
          "    let expected = Hir::concat(vec![Hir::literal(b\"xyz\"), Hir::alternation(vec![Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('G', 'Z')]))) , Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'z')])))]),]);",
          "    ",
          "    assert_eq!(expected, hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]