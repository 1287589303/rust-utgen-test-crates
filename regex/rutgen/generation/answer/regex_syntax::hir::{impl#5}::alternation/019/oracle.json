[
  {
    "uses": [
      "use crate::hir::ClassUnicodeRange;",
      "use crate::hir::ClassUnicode;",
      "use crate::hir::Class;",
      "use crate::hir::Hir;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};",
          "",
          "    let hir1 = Hir::literal(b'x'.to_vec().into_boxed_slice());",
          "    let hir2 = Hir::literal(b'y'.to_vec().into_boxed_slice());",
          "    let hir3 = Hir::literal(b'z'.to_vec().into_boxed_slice());",
          "    let hir4 = Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'a' },",
          "        ClassUnicodeRange { start: 'b', end: 'b' },",
          "    ])));",
          "    ",
          "    let result = Hir::alternation(vec![hir1, hir2, hir3, hir4]);",
          "",
          "    // Invoke to potentially trigger alternation characteristics",
          "    let _ = Hir::alternation(vec![",
          "        result,",
          "        Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "            ClassUnicodeRange { start: 'c', end: 'c' },",
          "        ]))),",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.kind, HirKind::Alternation(vec![hir1, hir2, hir3, hir4]));",
          "    ",
          "    assert_eq!(result.props, Properties::alternation(&vec![hir1, hir2, hir3, hir4]));",
          "    ",
          "    let singletons = singleton_chars(&result);",
          "    assert!(singletons.is_some());",
          "    ",
          "    let singletons_bytes = singleton_bytes(&result);",
          "    assert!(singletons_bytes.is_none()); // Expect no singletons of bytes to avoid confusion with character class",
          "    ",
          "    let class_result = class_chars(&result);",
          "    assert!(class_result.is_some());",
          "    ",
          "    let class_bytes_result = class_bytes(&result);",
          "    assert!(class_bytes_result.is_none()); // Expect no byte class conversions",
          "    ",
          "    let lift_result = lift_common_prefix(vec![result]);",
          "    assert!(lift_result.is_err()); // Must match Err(unchanged)",
          "    ",
          "    assert_eq!(lift_result.unwrap_err(), vec![result]); // Ensure it returned the unchanged state",
          "    ",
          "    let props_result = Properties::alternation(&vec![hir1, hir2, hir3, hir4]);",
          "    assert_eq!(result.props, props_result);"
        ],
        "code": [
          "{",
          "    use crate::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};",
          "",
          "    let hir1 = Hir::literal(b'x'.to_vec().into_boxed_slice());",
          "    let hir2 = Hir::literal(b'y'.to_vec().into_boxed_slice());",
          "    let hir3 = Hir::literal(b'z'.to_vec().into_boxed_slice());",
          "    let hir4 = Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'a', end: 'a' },",
          "        ClassUnicodeRange { start: 'b', end: 'b' },",
          "    ])));",
          "    ",
          "    let result = Hir::alternation(vec![hir1, hir2, hir3, hir4]);",
          "",
          "    // Invoke to potentially trigger alternation characteristics",
          "    let _ = Hir::alternation(vec![",
          "        result,",
          "        Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "            ClassUnicodeRange { start: 'c', end: 'c' },",
          "        ]))),",
          "    ]);",
          "    assert_eq!(result.kind, HirKind::Alternation(vec![hir1, hir2, hir3, hir4]));",
          "    ",
          "    assert_eq!(result.props, Properties::alternation(&vec![hir1, hir2, hir3, hir4]));",
          "    ",
          "    let singletons = singleton_chars(&result);",
          "    assert!(singletons.is_some());",
          "    ",
          "    let singletons_bytes = singleton_bytes(&result);",
          "    assert!(singletons_bytes.is_none()); // Expect no singletons of bytes to avoid confusion with character class",
          "    ",
          "    let class_result = class_chars(&result);",
          "    assert!(class_result.is_some());",
          "    ",
          "    let class_bytes_result = class_bytes(&result);",
          "    assert!(class_bytes_result.is_none()); // Expect no byte class conversions",
          "    ",
          "    let lift_result = lift_common_prefix(vec![result]);",
          "    assert!(lift_result.is_err()); // Must match Err(unchanged)",
          "    ",
          "    assert_eq!(lift_result.unwrap_err(), vec![result]); // Ensure it returned the unchanged state",
          "    ",
          "    let props_result = Properties::alternation(&vec![hir1, hir2, hir3, hir4]);",
          "    assert_eq!(result.props, props_result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};",
          "",
          "    let hir1 = Hir::literal(b'1'.to_vec().into_boxed_slice());",
          "    let hir2 = Hir::literal(b'2'.to_vec().into_boxed_slice());",
          "    let hir3 = Hir::literal(b'3'.to_vec().into_boxed_slice());",
          "    let unicode_class = Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'd', end: 'd' },",
          "        ClassUnicodeRange { start: 'e', end: 'e' },",
          "    ])));",
          "    ",
          "    let result = Hir::alternation(vec![hir1, hir2, hir3, unicode_class]);",
          "",
          "    // Trigger more processing by creating a nested alternation",
          "    let _ = Hir::alternation(vec![",
          "        result,",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange { start: 0u8, end: 0u8 },",
          "        ]))),",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange { start: 1u8, end: 1u8 },",
          "        ]))),",
          "    ]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Hir::fail(), Hir::alternation(vec![]));",
          "    assert_eq!(Hir::literal(b'1'.to_vec().into_boxed_slice()), Hir::alternation(vec![Hir::literal(b'1'.to_vec().into_boxed_slice())]));",
          "    assert_eq!(Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'd', end: 'd' }, ClassUnicodeRange { start: 'e', end: 'e' }])), Hir::alternation(vec![Hir::literal(b'1'.to_vec().into_boxed_slice()), Hir::literal(b'2'.to_vec().into_boxed_slice()), Hir::literal(b'3'.to_vec().into_boxed_slice()), Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'd', end: 'd' }, ClassUnicodeRange { start: 'e', end: 'e' }])))]));",
          "    let nested_result = Hir::alternation(vec![result, Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0u8, end: 0u8 }])), Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 1u8, end: 1u8 }])))]));",
          "    let expected_nested = Hir::alternation(vec![Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0u8, end: 0u8 }])), Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 1u8, end: 1u8 }]))))));",
          "    assert_eq!(expected_nested, nested_result);"
        ],
        "code": [
          "{",
          "    use crate::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};",
          "",
          "    let hir1 = Hir::literal(b'1'.to_vec().into_boxed_slice());",
          "    let hir2 = Hir::literal(b'2'.to_vec().into_boxed_slice());",
          "    let hir3 = Hir::literal(b'3'.to_vec().into_boxed_slice());",
          "    let unicode_class = Hir::class(Class::Unicode(ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: 'd', end: 'd' },",
          "        ClassUnicodeRange { start: 'e', end: 'e' },",
          "    ])));",
          "    ",
          "    let result = Hir::alternation(vec![hir1, hir2, hir3, unicode_class]);",
          "",
          "    // Trigger more processing by creating a nested alternation",
          "    let _ = Hir::alternation(vec![",
          "        result,",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange { start: 0u8, end: 0u8 },",
          "        ]))),",
          "        Hir::class(Class::Bytes(ClassBytes::new(vec![",
          "            ClassBytesRange { start: 1u8, end: 1u8 },",
          "        ]))),",
          "    ]);",
          "    assert_eq!(Hir::fail(), Hir::alternation(vec![]));",
          "    assert_eq!(Hir::literal(b'1'.to_vec().into_boxed_slice()), Hir::alternation(vec![Hir::literal(b'1'.to_vec().into_boxed_slice())]));",
          "    assert_eq!(Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'd', end: 'd' }, ClassUnicodeRange { start: 'e', end: 'e' }])), Hir::alternation(vec![Hir::literal(b'1'.to_vec().into_boxed_slice()), Hir::literal(b'2'.to_vec().into_boxed_slice()), Hir::literal(b'3'.to_vec().into_boxed_slice()), Hir::class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'd', end: 'd' }, ClassUnicodeRange { start: 'e', end: 'e' }])))]));",
          "    let nested_result = Hir::alternation(vec![result, Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0u8, end: 0u8 }])), Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 1u8, end: 1u8 }])))]));",
          "    let expected_nested = Hir::alternation(vec![Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0u8, end: 0u8 }])), Hir::class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 1u8, end: 1u8 }]))))));",
          "    assert_eq!(expected_nested, nested_result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]