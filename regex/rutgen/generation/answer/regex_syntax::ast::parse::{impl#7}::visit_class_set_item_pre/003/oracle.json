[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = ast::ClassSetItem::Literal(Literal {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&literal).unwrap();",
          "}"
        ],
        "oracle": [
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: Position::default(), end: Position::default() })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii { /* relevant fields */ })).unwrap();"
        ],
        "code": [
          "{",
          "    let literal = ast::ClassSetItem::Literal(Literal {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&literal).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode { /* relevant fields */ })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: Position::default(), end: Position::default() })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii { /* relevant fields */ })).unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_set_range = ast::ClassSetItem::Range(ClassSetRange {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&class_set_range).unwrap();",
          "}"
        ],
        "oracle": [
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: Position {}, end: Position {} })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii {})).unwrap();"
        ],
        "code": [
          "{",
          "    let class_set_range = ast::ClassSetItem::Range(ClassSetRange {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&class_set_range).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: Position {}, end: Position {} })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii {})).unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ascii = ast::ClassSetItem::Ascii(ClassAscii {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&ascii).unwrap();",
          "}"
        ],
        "oracle": [
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: 0, end: 1 })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii {})).unwrap();"
        ],
        "code": [
          "{",
          "    let ascii = ast::ClassSetItem::Ascii(ClassAscii {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&ascii).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode {})).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: 0, end: 1 })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii {})).unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&unicode).unwrap();",
          "}"
        ],
        "oracle": [
          "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&unicode), Ok(()));",
          "    let literal = ast::ClassSetItem::Literal(Literal {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&literal), Ok(()));",
          "    let range = ast::ClassSetItem::Range(ClassSetRange {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&range), Ok(()));",
          "    let empty = ast::ClassSetItem::Empty(Span { start: Position::default(), end: Position::default() });",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&empty), Ok(()));",
          "    let ascii = ast::ClassSetItem::Ascii(ClassAscii {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ascii), Ok(()));",
          "    let perl = ast::ClassSetItem::Perl(ClassPerl {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&perl), Ok(()));"
        ],
        "code": [
          "{",
          "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&unicode).unwrap();",
          "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&unicode), Ok(()));",
          "    let literal = ast::ClassSetItem::Literal(Literal {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&literal), Ok(()));",
          "    let range = ast::ClassSetItem::Range(ClassSetRange {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&range), Ok(()));",
          "    let empty = ast::ClassSetItem::Empty(Span { start: Position::default(), end: Position::default() });",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&empty), Ok(()));",
          "    let ascii = ast::ClassSetItem::Ascii(ClassAscii {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ascii), Ok(()));",
          "    let perl = ast::ClassSetItem::Perl(ClassPerl {});",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&perl), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let perl = ast::ClassSetItem::Perl(ClassPerl {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&perl).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl {})), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal::new('a'))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode::new('L'))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span::new(0, 1))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii::new('a'))), Ok(()));"
        ],
        "code": [
          "{",
          "    let perl = ast::ClassSetItem::Perl(ClassPerl {});",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&perl).unwrap();",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(ClassPerl {})), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal::new('a'))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode::new('L'))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span::new(0, 1))), Ok(()));",
          "    assert_eq!(nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii::new('a'))), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&empty).unwrap();",
          "}"
        ],
        "oracle": [
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(Literal)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: 0, end: 0 })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii)).unwrap();"
        ],
        "code": [
          "{",
          "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
          "    let mut nest_limiter = NestLimiter::new(&ParserI { parser: &Parser { nest_limit: 10 }, pattern: \"\" });",
          "    nest_limiter.visit_class_set_item_pre(&empty).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Perl(Literal)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Literal(Literal)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Range(ClassSetRange)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Unicode(ClassUnicode)).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Empty(Span { start: 0, end: 0 })).unwrap();",
          "    nest_limiter.visit_class_set_item_pre(&ast::ClassSetItem::Ascii(ClassAscii)).unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]