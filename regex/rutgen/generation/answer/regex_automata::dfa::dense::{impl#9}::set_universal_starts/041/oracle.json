[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestDFA {",
          "        st: StartKind,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn start(&self, _anchored: Anchored, start: Start) -> Result<StateID, StartError> {",
          "            match start {",
          "                Start::NonWordByte => Ok(StateID(0)),",
          "                Start::WordByte => Err(StartError),",
          "                Start::Text => Ok(StateID(0)),",
          "                Start::LineLF => Ok(StateID(0)),",
          "                Start::LineCR => Ok(StateID(0)),",
          "                Start::CustomLineTerminator => Ok(StateID(0)),",
          "            }",
          "        }",
          "        fn start_kind(&self) -> &StartKind {",
          "            &self.st",
          "        }",
          "",
          "        fn set_universal_starts(&mut self) {",
          "            assert_eq!(6, Start::len(), \"expected 6 start configurations\");",
          "",
          "            let start_id = |dfa: &mut TestDFA,",
          "                            anchored: Anchored,",
          "                            start: Start| {",
          "                dfa.start(anchored, start).expect(\"valid Input configuration\")",
          "            };",
          "",
          "            if self.start_kind().has_unanchored() {",
          "                let anchor = Anchored::No;",
          "                let sid = start_id(self, anchor, Start::NonWordByte);",
          "                if sid == start_id(self, anchor, Start::WordByte)",
          "                    && sid == start_id(self, anchor, Start::Text)",
          "                    && sid == start_id(self, anchor, Start::LineLF)",
          "                    && sid == start_id(self, anchor, Start::LineCR)",
          "                    && sid == start_id(self, anchor, Start::CustomLineTerminator)",
          "                {",
          "                    // set start state logic",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut dfa = TestDFA { st: StartKind::Both };",
          "    dfa.set_universal_starts();",
          "}"
        ],
        "oracle": [
          "    let mut dfa = TestDFA { st: StartKind::Both };",
          "    dfa.set_universal_starts();",
          "    assert!(dfa.st.universal_start_unanchored.is_none());",
          "    assert!(dfa.st.universal_start_anchored.is_none());",
          "    assert_eq!(6, Start::len());",
          "    assert!(dfa.start_kind().has_unanchored());",
          "    assert!(!dfa.start(Start::WordByte).is_ok());",
          "    assert!(dfa.start_kind().has_anchored());",
          "    assert!(!dfa.start(Start::WordByte).is_ok());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::NonWordByte).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::Text).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::LineLF).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::LineCR).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::CustomLineTerminator).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::NonWordByte).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::Text).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::LineLF).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::LineCR).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::CustomLineTerminator).unwrap());"
        ],
        "code": [
          "{",
          "    struct TestDFA {",
          "        st: StartKind,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn start(&self, _anchored: Anchored, start: Start) -> Result<StateID, StartError> {",
          "            match start {",
          "                Start::NonWordByte => Ok(StateID(0)),",
          "                Start::WordByte => Err(StartError),",
          "                Start::Text => Ok(StateID(0)),",
          "                Start::LineLF => Ok(StateID(0)),",
          "                Start::LineCR => Ok(StateID(0)),",
          "                Start::CustomLineTerminator => Ok(StateID(0)),",
          "            }",
          "        }",
          "        fn start_kind(&self) -> &StartKind {",
          "            &self.st",
          "        }",
          "",
          "        fn set_universal_starts(&mut self) {",
          "            assert_eq!(6, Start::len(), \"expected 6 start configurations\");",
          "",
          "            let start_id = |dfa: &mut TestDFA,",
          "                            anchored: Anchored,",
          "                            start: Start| {",
          "                dfa.start(anchored, start).expect(\"valid Input configuration\")",
          "            };",
          "",
          "            if self.start_kind().has_unanchored() {",
          "                let anchor = Anchored::No;",
          "                let sid = start_id(self, anchor, Start::NonWordByte);",
          "                if sid == start_id(self, anchor, Start::WordByte)",
          "                    && sid == start_id(self, anchor, Start::Text)",
          "                    && sid == start_id(self, anchor, Start::LineLF)",
          "                    && sid == start_id(self, anchor, Start::LineCR)",
          "                    && sid == start_id(self, anchor, Start::CustomLineTerminator)",
          "                {",
          "                    // set start state logic",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut dfa = TestDFA { st: StartKind::Both };",
          "    dfa.set_universal_starts();",
          "    let mut dfa = TestDFA { st: StartKind::Both };",
          "    dfa.set_universal_starts();",
          "    assert!(dfa.st.universal_start_unanchored.is_none());",
          "    assert!(dfa.st.universal_start_anchored.is_none());",
          "    assert_eq!(6, Start::len());",
          "    assert!(dfa.start_kind().has_unanchored());",
          "    assert!(!dfa.start(Start::WordByte).is_ok());",
          "    assert!(dfa.start_kind().has_anchored());",
          "    assert!(!dfa.start(Start::WordByte).is_ok());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::NonWordByte).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::Text).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::LineLF).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::LineCR).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::No, Start::CustomLineTerminator).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::NonWordByte).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::Text).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::LineLF).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::LineCR).unwrap());",
          "    assert_eq!(StateID(0), dfa.start(Anchored::Yes, Start::CustomLineTerminator).unwrap());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestDFA {",
          "        st: StartKind,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn start(&self, _anchored: Anchored, start: Start) -> Result<StateID, StartError> {",
          "            match start {",
          "                Start::NonWordByte => Ok(StateID(0)),",
          "                Start::WordByte => Err(StartError),",
          "                Start::Text => Ok(StateID(0)),",
          "                Start::LineLF => Ok(StateID(0)),",
          "                Start::LineCR => Ok(StateID(0)),",
          "                Start::CustomLineTerminator => Ok(StateID(0)),",
          "            }",
          "        }",
          "        fn start_kind(&self) -> &StartKind {",
          "            &self.st",
          "        }",
          "",
          "        fn set_universal_starts(&mut self) {",
          "            assert_eq!(6, Start::len(), \"expected 6 start configurations\");",
          "",
          "            let start_id = |dfa: &mut TestDFA,",
          "                            anchored: Anchored,",
          "                            start: Start| {",
          "                dfa.start(anchored, start).expect(\"valid Input configuration\")",
          "            };",
          "",
          "            if self.start_kind().has_anchored() {",
          "                let anchor = Anchored::Yes;",
          "                let sid = start_id(self, anchor, Start::NonWordByte);",
          "                if sid == start_id(self, anchor, Start::WordByte)",
          "                    && sid == start_id(self, anchor, Start::Text)",
          "                    && sid == start_id(self, anchor, Start::LineLF)",
          "                    && sid == start_id(self, anchor, Start::LineCR)",
          "                    && sid == start_id(self, anchor, Start::CustomLineTerminator)",
          "                {",
          "                    // set start state logic",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut dfa = TestDFA { st: StartKind::Both };",
          "    dfa.set_universal_starts();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(self.start_kind().has_unanchored(), true);",
          "    assert_eq!(self.start_kind().has_anchored(), true);",
          "    let sid_non_word = start_id(self, Anchored::No, Start::NonWordByte);",
          "    let sid_word = start_id(self, Anchored::No, Start::WordByte);",
          "    let sid_text = start_id(self, Anchored::No, Start::Text);",
          "    let sid_line_lf = start_id(self, Anchored::No, Start::LineLF);",
          "    let sid_line_cr = start_id(self, Anchored::No, Start::LineCR);",
          "    let sid_custom = start_id(self, Anchored::No, Start::CustomLineTerminator);",
          "    assert!(sid_non_word != sid_word);",
          "    assert_eq!(sid_non_word, sid_text);",
          "    assert_eq!(sid_non_word, sid_line_lf);",
          "    assert_eq!(sid_non_word, sid_line_cr);",
          "    assert_eq!(sid_non_word, sid_custom);",
          "    let sid_anchored_non_word = start_id(self, Anchored::Yes, Start::NonWordByte);",
          "    let sid_anchored_word = start_id(self, Anchored::Yes, Start::WordByte);",
          "    let sid_anchored_text = start_id(self, Anchored::Yes, Start::Text);",
          "    let sid_anchored_line_lf = start_id(self, Anchored::Yes, Start::LineLF);",
          "    let sid_anchored_line_cr = start_id(self, Anchored::Yes, Start::LineCR);",
          "    let sid_anchored_custom = start_id(self, Anchored::Yes, Start::CustomLineTerminator);",
          "    assert!(sid_anchored_non_word != sid_anchored_word);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_text);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_line_lf);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_line_cr);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_custom);"
        ],
        "code": [
          "{",
          "    struct TestDFA {",
          "        st: StartKind,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn start(&self, _anchored: Anchored, start: Start) -> Result<StateID, StartError> {",
          "            match start {",
          "                Start::NonWordByte => Ok(StateID(0)),",
          "                Start::WordByte => Err(StartError),",
          "                Start::Text => Ok(StateID(0)),",
          "                Start::LineLF => Ok(StateID(0)),",
          "                Start::LineCR => Ok(StateID(0)),",
          "                Start::CustomLineTerminator => Ok(StateID(0)),",
          "            }",
          "        }",
          "        fn start_kind(&self) -> &StartKind {",
          "            &self.st",
          "        }",
          "",
          "        fn set_universal_starts(&mut self) {",
          "            assert_eq!(6, Start::len(), \"expected 6 start configurations\");",
          "",
          "            let start_id = |dfa: &mut TestDFA,",
          "                            anchored: Anchored,",
          "                            start: Start| {",
          "                dfa.start(anchored, start).expect(\"valid Input configuration\")",
          "            };",
          "",
          "            if self.start_kind().has_anchored() {",
          "                let anchor = Anchored::Yes;",
          "                let sid = start_id(self, anchor, Start::NonWordByte);",
          "                if sid == start_id(self, anchor, Start::WordByte)",
          "                    && sid == start_id(self, anchor, Start::Text)",
          "                    && sid == start_id(self, anchor, Start::LineLF)",
          "                    && sid == start_id(self, anchor, Start::LineCR)",
          "                    && sid == start_id(self, anchor, Start::CustomLineTerminator)",
          "                {",
          "                    // set start state logic",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut dfa = TestDFA { st: StartKind::Both };",
          "    dfa.set_universal_starts();",
          "    assert_eq!(self.start_kind().has_unanchored(), true);",
          "    assert_eq!(self.start_kind().has_anchored(), true);",
          "    let sid_non_word = start_id(self, Anchored::No, Start::NonWordByte);",
          "    let sid_word = start_id(self, Anchored::No, Start::WordByte);",
          "    let sid_text = start_id(self, Anchored::No, Start::Text);",
          "    let sid_line_lf = start_id(self, Anchored::No, Start::LineLF);",
          "    let sid_line_cr = start_id(self, Anchored::No, Start::LineCR);",
          "    let sid_custom = start_id(self, Anchored::No, Start::CustomLineTerminator);",
          "    assert!(sid_non_word != sid_word);",
          "    assert_eq!(sid_non_word, sid_text);",
          "    assert_eq!(sid_non_word, sid_line_lf);",
          "    assert_eq!(sid_non_word, sid_line_cr);",
          "    assert_eq!(sid_non_word, sid_custom);",
          "    let sid_anchored_non_word = start_id(self, Anchored::Yes, Start::NonWordByte);",
          "    let sid_anchored_word = start_id(self, Anchored::Yes, Start::WordByte);",
          "    let sid_anchored_text = start_id(self, Anchored::Yes, Start::Text);",
          "    let sid_anchored_line_lf = start_id(self, Anchored::Yes, Start::LineLF);",
          "    let sid_anchored_line_cr = start_id(self, Anchored::Yes, Start::LineCR);",
          "    let sid_anchored_custom = start_id(self, Anchored::Yes, Start::CustomLineTerminator);",
          "    assert!(sid_anchored_non_word != sid_anchored_word);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_text);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_line_lf);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_line_cr);",
          "    assert_eq!(sid_anchored_non_word, sid_anchored_custom);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]