[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'a'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(5);",
          "    extractor.extract_repetition(&rev);",
          "}"
        ],
        "oracle": [
          "    assert!(rep.min == 1);",
          "    assert!(rep.max == Some(3));",
          "    assert!(rep.greedy == true);",
          "    assert!(extractor.limit_repeat == 5);",
          "    let result = extractor.extract_repetition(&rev);",
          "    assert!(result.is_inexact());",
          "    assert!(result.len().unwrap() > 0);",
          "    assert_eq!(result.literals().unwrap()[0].exact, false);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'a']);",
          "    assert!(result.len().unwrap() <= extractor.limit_total);"
        ],
        "code": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'a'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(5);",
          "    extractor.extract_repetition(&rev);",
          "    assert!(rep.min == 1);",
          "    assert!(rep.max == Some(3));",
          "    assert!(rep.greedy == true);",
          "    assert!(extractor.limit_repeat == 5);",
          "    let result = extractor.extract_repetition(&rev);",
          "    assert!(result.is_inexact());",
          "    assert!(result.len().unwrap() > 0);",
          "    assert_eq!(result.literals().unwrap()[0].exact, false);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'a']);",
          "    assert!(result.len().unwrap() <= extractor.limit_total);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 2,",
          "        max: Some(4),",
          "        greedy: false,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'b'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(5);",
          "    extractor.extract_repetition(&rev);",
          "}"
        ],
        "oracle": [
          "    assert!(seq.is_inexact() == false);",
          "    assert!(seq.len().is_some());",
          "    assert!(seq.len().unwrap() > 0);",
          "    assert!(seq.literals().unwrap().iter().all(|lit| lit.is_exact() == false));",
          "    assert!(seq.max_cross_len(&subseq) < Some(5));",
          "    assert!(min > 0);",
          "    assert!(seq.literals().map_or(true, |lits| lits.len() <= 4));"
        ],
        "code": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 2,",
          "        max: Some(4),",
          "        greedy: false,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'b'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(5);",
          "    extractor.extract_repetition(&rev);",
          "    assert!(seq.is_inexact() == false);",
          "    assert!(seq.len().is_some());",
          "    assert!(seq.len().unwrap() > 0);",
          "    assert!(seq.literals().unwrap().iter().all(|lit| lit.is_exact() == false));",
          "    assert!(seq.max_cross_len(&subseq) < Some(5));",
          "    assert!(min > 0);",
          "    assert!(seq.literals().map_or(true, |lits| lits.len() <= 4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 1,",
          "        max: Some(5),",
          "        greedy: true,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'c'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(10);",
          "    extractor.extract_repetition(&rev);",
          "}"
        ],
        "oracle": [
          "    Seq::singleton(Literal::exact(vec![]));",
          "    seq.is_inexact();",
          "    seq.make_inexact();",
          "    assert!(min > 0);",
          "    assert!(min != max);",
          "    _ in 0..cmp::min(min, limit);",
          "    subseq.make_inexact();",
          "    extractor.extract_repetition(&rev);",
          "    let limit = u32::try_from(extractor.limit_repeat).unwrap_or(u32::MAX);",
          "    seq.len().map_or(true, |x| x <= extractor.limit_total);",
          "    assert!(seq.is_inexact() == false);"
        ],
        "code": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 1,",
          "        max: Some(5),",
          "        greedy: true,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'c'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(10);",
          "    extractor.extract_repetition(&rev);",
          "    Seq::singleton(Literal::exact(vec![]));",
          "    seq.is_inexact();",
          "    seq.make_inexact();",
          "    assert!(min > 0);",
          "    assert!(min != max);",
          "    _ in 0..cmp::min(min, limit);",
          "    subseq.make_inexact();",
          "    extractor.extract_repetition(&rev);",
          "    let limit = u32::try_from(extractor.limit_repeat).unwrap_or(u32::MAX);",
          "    seq.len().map_or(true, |x| x <= extractor.limit_total);",
          "    assert!(seq.is_inexact() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 3,",
          "        max: Some(6),",
          "        greedy: false,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'd'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(10);",
          "    extractor.extract_repetition(&rev);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.extract_repetition(&rev).is_inexact(), false);",
          "    assert!(extractor.extract_repetition(&rev).len().is_some());",
          "    assert_eq!(extractor.extract_repetition(&rev).min_literal_len(), Some(3));",
          "    assert_eq!(extractor.extract_repetition(&rev).max_literal_len(), Some(6));",
          "    assert_eq!(extractor.extract_repetition(&rev).literals().unwrap().len(), 1);",
          "    assert!(extractor.extract_repetition(&rev).literals().unwrap()[0].is_exact());"
        ],
        "code": [
          "{",
          "    let rev = hir::Repetition {",
          "        min: 3,",
          "        max: Some(6),",
          "        greedy: false,",
          "        sub: Box::new(hir::Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'd'])),",
          "            props: Default::default(),",
          "        }),",
          "    };",
          "    let extractor = Extractor::new()",
          "        .limit_repeat(10);",
          "    extractor.extract_repetition(&rev);",
          "    assert_eq!(extractor.extract_repetition(&rev).is_inexact(), false);",
          "    assert!(extractor.extract_repetition(&rev).len().is_some());",
          "    assert_eq!(extractor.extract_repetition(&rev).min_literal_len(), Some(3));",
          "    assert_eq!(extractor.extract_repetition(&rev).max_literal_len(), Some(6));",
          "    assert_eq!(extractor.extract_repetition(&rev).literals().unwrap().len(), 1);",
          "    assert!(extractor.extract_repetition(&rev).literals().unwrap()[0].is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]