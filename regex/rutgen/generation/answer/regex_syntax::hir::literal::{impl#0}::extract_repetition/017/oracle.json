[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.limit_repeat(0);",
          "    extractor.limit_total(10);",
          "",
          "    let rep = hir::Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![b'a'])), props: Properties::default() }),",
          "    };",
          "    ",
          "    let result = extractor.extract_repetition(&rep);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len(), Some(2));",
          "    assert!(result.is_inexact());",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'a']);",
          "    assert!(result.literals().unwrap()[0].is_inexact());",
          "    assert!(result.literals().unwrap()[1].bytes.is_empty());",
          "    assert!(result.literals().unwrap()[1].is_exact());"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.limit_repeat(0);",
          "    extractor.limit_total(10);",
          "",
          "    let rep = hir::Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![b'a'])), props: Properties::default() }),",
          "    };",
          "    ",
          "    let result = extractor.extract_repetition(&rep);",
          "    assert_eq!(result.len(), Some(2));",
          "    assert!(result.is_inexact());",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'a']);",
          "    assert!(result.literals().unwrap()[0].is_inexact());",
          "    assert!(result.literals().unwrap()[1].bytes.is_empty());",
          "    assert!(result.literals().unwrap()[1].is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.limit_repeat(0);",
          "    extractor.limit_total(10);",
          "",
          "    let rep = hir::Repetition {",
          "        min: 1,",
          "        max: Some(2),",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![b'b'])), props: Properties::default() }),",
          "    };",
          "",
          "    let result = extractor.extract_repetition(&rep);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_inexact());",
          "    assert!(result.len().unwrap() > 0);",
          "    assert!(result.literals().unwrap()[0].is_exact() == false);",
          "    assert!(result.literals().unwrap()[1].is_exact() == true);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'b']);",
          "    assert_eq!(result.literals().unwrap()[1].bytes, vec![]);",
          "    assert!(result.len().unwrap() <= 10);",
          "    assert!(result.literals().unwrap().len() <= 2);"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.limit_repeat(0);",
          "    extractor.limit_total(10);",
          "",
          "    let rep = hir::Repetition {",
          "        min: 1,",
          "        max: Some(2),",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![b'b'])), props: Properties::default() }),",
          "    };",
          "",
          "    let result = extractor.extract_repetition(&rep);",
          "    assert!(result.is_inexact());",
          "    assert!(result.len().unwrap() > 0);",
          "    assert!(result.literals().unwrap()[0].is_exact() == false);",
          "    assert!(result.literals().unwrap()[1].is_exact() == true);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'b']);",
          "    assert_eq!(result.literals().unwrap()[1].bytes, vec![]);",
          "    assert!(result.len().unwrap() <= 10);",
          "    assert!(result.literals().unwrap().len() <= 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.limit_repeat(10);",
          "    extractor.limit_total(5);",
          "",
          "    let rep = hir::Repetition {",
          "        min: 10,",
          "        max: Some(20),",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![b'c'])), props: Properties::default() }),",
          "    };",
          "",
          "    let result = extractor.extract_repetition(&rep);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_inexact(), true);",
          "    assert_eq!(result.len().unwrap(), 1);",
          "    assert_eq!(result.literals().unwrap()[0].is_exact(), false);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'c']);",
          "    assert!(result.literals().unwrap()[0].is_inexact());",
          "    assert_eq!(result.literals().unwrap()[0].min_literal_len().unwrap(), 1);",
          "    assert_eq!(result.literals().unwrap()[0].max_literal_len().unwrap(), 1);",
          "    assert!(result.len().unwrap() <= extractor.limit_total);",
          "    assert!(result.max_cross_len(&Seq::infinite()).is_some());",
          "    assert!(result.max_union_len(&Seq::infinite()).is_some());"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new();",
          "    extractor.limit_repeat(10);",
          "    extractor.limit_total(5);",
          "",
          "    let rep = hir::Repetition {",
          "        min: 10,",
          "        max: Some(20),",
          "        greedy: false,",
          "        sub: Box::new(Hir { kind: HirKind::Literal(hir::Literal(vec![b'c'])), props: Properties::default() }),",
          "    };",
          "",
          "    let result = extractor.extract_repetition(&rep);",
          "    assert_eq!(result.is_inexact(), true);",
          "    assert_eq!(result.len().unwrap(), 1);",
          "    assert_eq!(result.literals().unwrap()[0].is_exact(), false);",
          "    assert_eq!(result.literals().unwrap()[0].bytes, vec![b'c']);",
          "    assert!(result.literals().unwrap()[0].is_inexact());",
          "    assert_eq!(result.literals().unwrap()[0].min_literal_len().unwrap(), 1);",
          "    assert_eq!(result.literals().unwrap()[0].max_literal_len().unwrap(), 1);",
          "    assert!(result.len().unwrap() <= extractor.limit_total);",
          "    assert!(result.max_cross_len(&Seq::infinite()).is_some());",
          "    assert!(result.max_union_len(&Seq::infinite()).is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]