[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Prefix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'a'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "}"
        ],
        "oracle": [
          "    Seq::singleton(Literal::exact(vec![]));",
          "    seq.make_inexact();",
          "    assert_eq!(result.literals().unwrap(), &[Literal::exact(vec![]), Literal::inexact(vec![b'a'])]);",
          "    assert!(result.is_inexact());",
          "    assert!(result.len().unwrap() <= extractor.limit_total);",
          "    extractor.limit_total(10);",
          "    assert!(extractor.limit_repeat == 0);"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Prefix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'a'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "    Seq::singleton(Literal::exact(vec![]));",
          "    seq.make_inexact();",
          "    assert_eq!(result.literals().unwrap(), &[Literal::exact(vec![]), Literal::inexact(vec![b'a'])]);",
          "    assert!(result.is_inexact());",
          "    assert!(result.len().unwrap() <= extractor.limit_total);",
          "    extractor.limit_total(10);",
          "    assert!(extractor.limit_repeat == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'b'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.extract_repetition(&repetition).literals(), Some(vec![Literal::exact(vec![]), Literal::inexact(vec![b'b'])].as_slice()));",
          "    assert!(extractor.extract_repetition(&repetition).is_inexact());",
          "    assert!(!extractor.extract_repetition(&repetition).is_empty());",
          "    assert_eq!(extractor.extract_repetition(&repetition).len(), Some(2));",
          "    assert!(extractor.extract_repetition(&repetition).max_cross_len(&Seq::empty()).is_none());"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'b'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "    assert_eq!(extractor.extract_repetition(&repetition).literals(), Some(vec![Literal::exact(vec![]), Literal::inexact(vec![b'b'])].as_slice()));",
          "    assert!(extractor.extract_repetition(&repetition).is_inexact());",
          "    assert!(!extractor.extract_repetition(&repetition).is_empty());",
          "    assert_eq!(extractor.extract_repetition(&repetition).len(), Some(2));",
          "    assert!(extractor.extract_repetition(&repetition).max_cross_len(&Seq::empty()).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Prefix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'c'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.extract_repetition(&repetition).literals(), Some(&[Literal::exact(vec![])]));",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).is_inexact(), true);",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).len(), Some(1));",
          "    ",
          "    assert!(extractor.extract_repetition(&repetition).max_union_len(&Seq::empty()).is_none());",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).max_cross_len(&Seq::singleton(Literal::exact(vec![b'c']))), Some(1));",
          "    ",
          "    assert!(extractor.extract_repetition(&repetition).is_exact());",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).longest_common_prefix(), Some(&[] as &[u8]));",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).longest_common_suffix(), Some(&[] as &[u8]));",
          "    ",
          "    assert!(extractor.extract_repetition(&repetition).is_finite());"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Prefix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'c'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "    assert_eq!(extractor.extract_repetition(&repetition).literals(), Some(&[Literal::exact(vec![])]));",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).is_inexact(), true);",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).len(), Some(1));",
          "    ",
          "    assert!(extractor.extract_repetition(&repetition).max_union_len(&Seq::empty()).is_none());",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).max_cross_len(&Seq::singleton(Literal::exact(vec![b'c']))), Some(1));",
          "    ",
          "    assert!(extractor.extract_repetition(&repetition).is_exact());",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).longest_common_prefix(), Some(&[] as &[u8]));",
          "    ",
          "    assert_eq!(extractor.extract_repetition(&repetition).longest_common_suffix(), Some(&[] as &[u8]));",
          "    ",
          "    assert!(extractor.extract_repetition(&repetition).is_finite());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'd'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(extractor.extract_repetition(&repetition).literals().unwrap(), vec![Literal::exact(vec![]), Literal::inexact(vec![b'd'])]);"
        ],
        "code": [
          "{",
          "    let extractor = Extractor::new().kind(ExtractKind::Suffix);",
          "    let repetition = hir::Repetition {",
          "        min: 0,",
          "        max: Some(1),",
          "        greedy: false,",
          "        sub: Box::new(Hir {",
          "            kind: hir::HirKind::Literal(hir::Literal(vec![b'd'])),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    extractor.extract_repetition(&repetition);",
          "    assert_eq!(extractor.extract_repetition(&repetition).literals().unwrap(), vec![Literal::exact(vec![]), Literal::inexact(vec![b'd'])]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]