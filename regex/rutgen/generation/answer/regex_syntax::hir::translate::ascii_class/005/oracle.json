[
  {
    "uses": [
      "use crate::ast::ClassAsciiKind;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Alnum;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let expected_result_alnum = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
          "    assert_eq!(result, expected_result_alnum);",
          "    ",
          "    let kind = ClassAsciiKind::Alpha;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_alpha = vec![(b'A', b'Z'), (b'a', b'z')];",
          "    assert_eq!(result, expected_result_alpha);",
          "    ",
          "    let kind = ClassAsciiKind::Ascii;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_ascii = vec![(b'\\x00', b'\\x7F')];",
          "    assert_eq!(result, expected_result_ascii);",
          "    ",
          "    let kind = ClassAsciiKind::Blank;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_blank = vec![(b'\\t', b'\\t'), (b' ', b' ')];",
          "    assert_eq!(result, expected_result_blank);",
          "    ",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_cntrl = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
          "    assert_eq!(result, expected_result_cntrl);",
          "    ",
          "    let kind = ClassAsciiKind::Digit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_digit = vec![(b'0', b'9')];",
          "    assert_eq!(result, expected_result_digit);",
          "    ",
          "    let kind = ClassAsciiKind::Graph;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_graph = vec![(b'!', b'~')];",
          "    assert_eq!(result, expected_result_graph);",
          "    ",
          "    let kind = ClassAsciiKind::Lower;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_lower = vec![(b'a', b'z')];",
          "    assert_eq!(result, expected_result_lower);",
          "    ",
          "    let kind = ClassAsciiKind::Print;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_print = vec![(b' ', b'~')];",
          "    assert_eq!(result, expected_result_print);",
          "    ",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_punct = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
          "    assert_eq!(result, expected_result_punct);",
          "    ",
          "    let kind = ClassAsciiKind::Space;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_space = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
          "    assert_eq!(result, expected_result_space);",
          "    ",
          "    let kind = ClassAsciiKind::Upper;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_upper = vec![(b'A', b'Z')];",
          "    assert_eq!(result, expected_result_upper);",
          "    ",
          "    let kind = ClassAsciiKind::Word;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_word = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
          "    assert_eq!(result, expected_result_word);",
          "    ",
          "    let kind = ClassAsciiKind::Xdigit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_xdigit = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
          "    assert_eq!(result, expected_result_xdigit);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Alnum;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_alnum = vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')];",
          "    assert_eq!(result, expected_result_alnum);",
          "    ",
          "    let kind = ClassAsciiKind::Alpha;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_alpha = vec![(b'A', b'Z'), (b'a', b'z')];",
          "    assert_eq!(result, expected_result_alpha);",
          "    ",
          "    let kind = ClassAsciiKind::Ascii;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_ascii = vec![(b'\\x00', b'\\x7F')];",
          "    assert_eq!(result, expected_result_ascii);",
          "    ",
          "    let kind = ClassAsciiKind::Blank;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_blank = vec![(b'\\t', b'\\t'), (b' ', b' ')];",
          "    assert_eq!(result, expected_result_blank);",
          "    ",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_cntrl = vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')];",
          "    assert_eq!(result, expected_result_cntrl);",
          "    ",
          "    let kind = ClassAsciiKind::Digit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_digit = vec![(b'0', b'9')];",
          "    assert_eq!(result, expected_result_digit);",
          "    ",
          "    let kind = ClassAsciiKind::Graph;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_graph = vec![(b'!', b'~')];",
          "    assert_eq!(result, expected_result_graph);",
          "    ",
          "    let kind = ClassAsciiKind::Lower;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_lower = vec![(b'a', b'z')];",
          "    assert_eq!(result, expected_result_lower);",
          "    ",
          "    let kind = ClassAsciiKind::Print;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_print = vec![(b' ', b'~')];",
          "    assert_eq!(result, expected_result_print);",
          "    ",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_punct = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
          "    assert_eq!(result, expected_result_punct);",
          "    ",
          "    let kind = ClassAsciiKind::Space;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_space = vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')];",
          "    assert_eq!(result, expected_result_space);",
          "    ",
          "    let kind = ClassAsciiKind::Upper;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_upper = vec![(b'A', b'Z')];",
          "    assert_eq!(result, expected_result_upper);",
          "    ",
          "    let kind = ClassAsciiKind::Word;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_word = vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')];",
          "    assert_eq!(result, expected_result_word);",
          "    ",
          "    let kind = ClassAsciiKind::Xdigit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected_result_xdigit = vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')];",
          "    assert_eq!(result, expected_result_xdigit);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Alpha;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    ",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert!(result.len() > 0);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Alpha;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    ",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert!(result.len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Ascii;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Ascii;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Blank;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Blank;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let kind = ClassAsciiKind::Punct;",
          "    let expected = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let kind = ClassAsciiKind::Punct;",
          "    let expected = vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')];",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Digit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Digit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Graph;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, vec![(b'!', b'~')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Graph;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'~')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Lower;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result.len(), 4);",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.iter().all(|&(start, end)| start <= end));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'!', b'/')));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b':', b'@')));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'[', b'`')));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'{', b'~')));"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Lower;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert_eq!(result.len(), 4);",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.iter().all(|&(start, end)| start <= end));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'!', b'/')));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b':', b'@')));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'[', b'`')));",
          "    let kind = ClassAsciiKind::Punct; let result: Vec<(u8, u8)> = ascii_class(&kind).collect(); assert!(result.contains(&(b'{', b'~')));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Print;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, vec![(b' ', b'~')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Punct;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Digit;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Lower;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Upper;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'A', b'Z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Word;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Xdigit;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Alnum;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Alpha;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Blank;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Graph;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'~')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Space;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Print;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b' ', b'~')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Punct;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Digit;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Lower;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Upper;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'A', b'Z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Word;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Xdigit;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Alnum;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Alpha;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Blank;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Graph;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'~')]);",
          "    ",
          "    ",
          "    let kind = ClassAsciiKind::Space;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Space;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let expected = vec![",
          "    (b'\\t', b'\\t'),",
          "    (b'\\n', b'\\n'),",
          "    (b'\\x0B', b'\\x0B'),",
          "    (b'\\x0C', b'\\x0C'),",
          "    (b'\\r', b'\\r'),",
          "    (b' ', b' ')",
          "    ];",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Space;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let expected = vec![",
          "    (b'\\t', b'\\t'),",
          "    (b'\\n', b'\\n'),",
          "    (b'\\x0B', b'\\x0B'),",
          "    (b'\\x0C', b'\\x0C'),",
          "    (b'\\r', b'\\r'),",
          "    (b' ', b' ')",
          "    ];",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Upper;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, vec![(b'A', b'Z')]);",
          "    let kind = ClassAsciiKind::Alpha;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ClassAsciiKind::Digit;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9')]);",
          "    let kind = ClassAsciiKind::Punct;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ClassAsciiKind::Space;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Upper;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'A', b'Z')]);",
          "    let kind = ClassAsciiKind::Alpha;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ClassAsciiKind::Digit;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9')]);",
          "    let kind = ClassAsciiKind::Punct;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ClassAsciiKind::Space;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    let kind = ClassAsciiKind::Cntrl;",
          "    result = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Word;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Word;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Xdigit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "}"
        ],
        "oracle": [
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);"
        ],
        "code": [
          "{",
          "    use crate::ast::ClassAsciiKind;",
          "",
          "    let kind = ClassAsciiKind::Xdigit;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    let kind = ClassAsciiKind::Punct;",
          "    let result: Vec<(u8, u8)> = ascii_class(&kind).collect();",
          "    assert_eq!(result, vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]