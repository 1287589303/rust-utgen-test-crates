[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alnum;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Alpha;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(result, vec![(b'\\x00', b'\\x7F')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let expected = vec![(b'\\x00', b'\\x7F')];",
          "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    let kind = ast::ClassAsciiKind::Ascii;",
          "    let expected = vec![(b'\\x00', b'\\x7F')];",
          "    let result = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Blank;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Blank;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Cntrl;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Cntrl;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Digit;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Graph;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Lower;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Print;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Punct;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Space;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Upper;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Word;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Word;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    let kind = ast::ClassAsciiKind::Alnum; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Alpha; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Ascii; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Blank; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Cntrl; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    let kind = ast::ClassAsciiKind::Digit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    let kind = ast::ClassAsciiKind::Graph; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Lower; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Print; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Punct; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    let kind = ast::ClassAsciiKind::Space; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    let kind = ast::ClassAsciiKind::Upper; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    let kind = ast::ClassAsciiKind::Word; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    let kind = ast::ClassAsciiKind::Xdigit; assert_eq!(ascii_class(&kind).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);"
        ],
        "code": [
          "{",
          "    let kind = ast::ClassAsciiKind::Xdigit;",
          "    let _ = ascii_class(&kind).collect::<Vec<(u8, u8)>>();",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alnum).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Alpha).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Ascii).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Blank).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Cntrl).collect::<Vec<(u8, u8)>>(), vec![(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Digit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Graph).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Lower).collect::<Vec<(u8, u8)>>(), vec![(b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Print).collect::<Vec<(u8, u8)>>(), vec![(b' ', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Punct).collect::<Vec<(u8, u8)>>(), vec![(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Space).collect::<Vec<(u8, u8)>>(), vec![(b'\\t', b'\\t'), (b'\\n', b'\\n'), (b'\\x0B', b'\\x0B'), (b'\\x0C', b'\\x0C'), (b'\\r', b'\\r'), (b' ', b' ')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Upper).collect::<Vec<(u8, u8)>>(), vec![(b'A', b'Z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Word).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')]);",
          "    assert_eq!(ascii_class(&ast::ClassAsciiKind::Xdigit).collect::<Vec<(u8, u8)>>(), vec![(b'0', b'9'), (b'A', b'F'), (b'a', b'f')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]