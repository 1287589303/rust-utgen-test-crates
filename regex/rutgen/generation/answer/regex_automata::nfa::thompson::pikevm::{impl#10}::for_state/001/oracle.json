[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots_per_state = 2;",
          "    let slots_for_captures = 1;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(1));",
          "    let result = slot_table.for_state(state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len(), slots_for_captures);",
          "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
          "    assert_eq!(result.as_ptr(), &slot_table.table[slots_per_state * state_id.0.as_usize()] as *const _);",
          "    assert!(result.iter().all(|&slot| slot.is_some()));",
          "    let empty_state_id = StateID(SmallIndex::new(3));",
          "    let result_empty = slot_table.for_state(empty_state_id);",
          "    assert_eq!(result_empty.len(), slots_for_captures);",
          "    assert!(result_empty.iter().all(|&slot| slot.is_none()));"
        ],
        "code": [
          "{",
          "    let slots_per_state = 2;",
          "    let slots_for_captures = 1;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(1));",
          "    let result = slot_table.for_state(state_id);",
          "    assert_eq!(result.len(), slots_for_captures);",
          "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
          "    assert_eq!(result.as_ptr(), &slot_table.table[slots_per_state * state_id.0.as_usize()] as *const _);",
          "    assert!(result.iter().all(|&slot| slot.is_some()));",
          "    let empty_state_id = StateID(SmallIndex::new(3));",
          "    let result_empty = slot_table.for_state(empty_state_id);",
          "    assert_eq!(result_empty.len(), slots_for_captures);",
          "    assert!(result_empty.iter().all(|&slot| slot.is_none()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots_per_state = 3;",
          "    let slots_for_captures = 2;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 9],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let result = slot_table.for_state(state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len(), slots_for_captures);",
          "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
          "    assert_eq!(result[1], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
          "    assert_eq!(result.as_ptr() as usize % std::mem::size_of::<Option<NonMaxUsize>>() == 0, true);",
          "    assert!(std::ptr::eq(result, &mut slot_table.table[0..slots_for_captures]));",
          "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(1))).len(), slots_for_captures);",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).is_empty());"
        ],
        "code": [
          "{",
          "    let slots_per_state = 3;",
          "    let slots_for_captures = 2;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 9],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(0));",
          "    let result = slot_table.for_state(state_id);",
          "    assert_eq!(result.len(), slots_for_captures);",
          "    assert_eq!(result[0], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
          "    assert_eq!(result[1], Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())));",
          "    assert_eq!(result.as_ptr() as usize % std::mem::size_of::<Option<NonMaxUsize>>() == 0, true);",
          "    assert!(std::ptr::eq(result, &mut slot_table.table[0..slots_for_captures]));",
          "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(1))).len(), slots_for_captures);",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots_per_state = 4;",
          "    let slots_for_captures = 3;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(3));",
          "    let result = slot_table.for_state(state_id);",
          "}"
        ],
        "oracle": [
          "    let slots_per_state = 4;",
          "    let slots_for_captures = 3;",
          "    let mut slot_table = SlotTable { table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16], slots_per_state, slots_for_captures };",
          "    let state_id = StateID(SmallIndex::new(3));",
          "    let expected_length = slots_for_captures;",
          "    assert_eq!(result.len(), expected_length);",
          "    let expected_slice = &mut slot_table.table[state_id.as_usize() * slots_per_state..state_id.as_usize() * slots_per_state + slots_for_captures];",
          "    assert_eq!(result.as_mut_ptr(), expected_slice.as_mut_ptr());",
          "    assert_eq!(result, expected_slice);"
        ],
        "code": [
          "{",
          "    let slots_per_state = 4;",
          "    let slots_for_captures = 3;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(3));",
          "    let result = slot_table.for_state(state_id);",
          "    let slots_per_state = 4;",
          "    let slots_for_captures = 3;",
          "    let mut slot_table = SlotTable { table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 16], slots_per_state, slots_for_captures };",
          "    let state_id = StateID(SmallIndex::new(3));",
          "    let expected_length = slots_for_captures;",
          "    assert_eq!(result.len(), expected_length);",
          "    let expected_slice = &mut slot_table.table[state_id.as_usize() * slots_per_state..state_id.as_usize() * slots_per_state + slots_for_captures];",
          "    assert_eq!(result.as_mut_ptr(), expected_slice.as_mut_ptr());",
          "    assert_eq!(result, expected_slice);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slots_per_state = 2;",
          "    let slots_for_captures = 1;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(2)); // Out of range",
          "    let result = slot_table.for_state(state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.len(), slots_for_captures);",
          "    assert!(result.iter().all(|&slot| slot.is_some()));",
          "    slot_table.for_state(StateID(SmallIndex::new(0)));",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(0))).len() == slots_for_captures);",
          "    slot_table.for_state(StateID(SmallIndex::new(1)));",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(1))).len() == slots_for_captures);",
          "    slot_table.for_state(StateID(SmallIndex::new(2)));",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).len() == slots_for_captures);",
          "    slot_table.table[4] = Some(NonMaxUsize(NonZeroUsize::new(2).unwrap()));",
          "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(2)))[0], Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())));"
        ],
        "code": [
          "{",
          "    let slots_per_state = 2;",
          "    let slots_for_captures = 1;",
          "    let mut slot_table = SlotTable {",
          "        table: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 6],",
          "        slots_per_state,",
          "        slots_for_captures,",
          "    };",
          "    let state_id = StateID(SmallIndex::new(2)); // Out of range",
          "    let result = slot_table.for_state(state_id);",
          "    assert_eq!(result.len(), slots_for_captures);",
          "    assert!(result.iter().all(|&slot| slot.is_some()));",
          "    slot_table.for_state(StateID(SmallIndex::new(0)));",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(0))).len() == slots_for_captures);",
          "    slot_table.for_state(StateID(SmallIndex::new(1)));",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(1))).len() == slots_for_captures);",
          "    slot_table.for_state(StateID(SmallIndex::new(2)));",
          "    assert!(slot_table.for_state(StateID(SmallIndex::new(2))).len() == slots_for_captures);",
          "    slot_table.table[4] = Some(NonMaxUsize(NonZeroUsize::new(2).unwrap()));",
          "    assert_eq!(slot_table.for_state(StateID(SmallIndex::new(2)))[0], Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]