[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"blank\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"alnum\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"alpha\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"ascii\");",
          "    let expected = Ok(vec![hir::ClassRange { start: '\\x00', end: '\\x7F' }].into_iter());",
          "    assert_eq!(result, expected);",
          "    let result = posix_class(\"digit\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"space\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"upper\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"word\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"xdigit\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"blank\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"alnum\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"alpha\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"ascii\");",
          "    let expected = Ok(vec![hir::ClassRange { start: '\\x00', end: '\\x7F' }].into_iter());",
          "    assert_eq!(result, expected);",
          "    let result = posix_class(\"digit\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"space\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"upper\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"word\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result = posix_class(\"xdigit\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"cntrl\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"cntrl\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"digit\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 1);",
          "    assert_eq!(ranges[0].start, '0');",
          "    assert_eq!(ranges[0].end, '9');"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"digit\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 1);",
          "    assert_eq!(ranges[0].start, '0');",
          "    assert_eq!(ranges[0].end, '9');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"graph\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(class_ranges.len(), 1);",
          "    assert_eq!(class_ranges[0].start, '!');",
          "    assert_eq!(class_ranges[0].end, '~');"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"graph\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(class_ranges.len(), 1);",
          "    assert_eq!(class_ranges[0].start, '!');",
          "    assert_eq!(class_ranges[0].end, '~');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"lower\");",
          "}"
        ],
        "oracle": [
          "    let result = posix_class(\"ascii\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start, '\\u{0}');",
          "    assert_eq!(ranges[0].end, '\\u{7F}');"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"lower\");",
          "    let result = posix_class(\"ascii\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start, '\\u{0}');",
          "    assert_eq!(ranges[0].end, '\\u{7F}');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"print\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: ' ', end: '~' }]);",
          "    ",
          "    let result_ascii = posix_class(\"ascii\");",
          "    assert_eq!(result_ascii.is_ok(), true);",
          "    let ranges_ascii: Vec<hir::ClassRange> = result_ascii.unwrap().collect();",
          "    assert_eq!(ranges_ascii, vec![hir::ClassRange { start: '\\u{0}', end: '\\u{7F}' }]);",
          "    ",
          "    let result_invalid = posix_class(\"invalid_class\");",
          "    assert_eq!(result_invalid.is_err(), true);",
          "    assert_eq!(result_invalid.unwrap_err().msg, ERR_POSIX_CLASS_UNRECOGNIZED);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"print\");",
          "    assert_eq!(result.is_ok(), true);",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: ' ', end: '~' }]);",
          "    ",
          "    let result_ascii = posix_class(\"ascii\");",
          "    assert_eq!(result_ascii.is_ok(), true);",
          "    let ranges_ascii: Vec<hir::ClassRange> = result_ascii.unwrap().collect();",
          "    assert_eq!(ranges_ascii, vec![hir::ClassRange { start: '\\u{0}', end: '\\u{7F}' }]);",
          "    ",
          "    let result_invalid = posix_class(\"invalid_class\");",
          "    assert_eq!(result_invalid.is_err(), true);",
          "    assert_eq!(result_invalid.unwrap_err().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"punct\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![",
          "    hir::ClassRange { start: '!', end: '/' },",
          "    hir::ClassRange { start: ':', end: '@' },",
          "    hir::ClassRange { start: '[', end: '`' },",
          "    hir::ClassRange { start: '{', end: '~' }",
          "    ]);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"punct\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![",
          "    hir::ClassRange { start: '!', end: '/' },",
          "    hir::ClassRange { start: ':', end: '@' },",
          "    hir::ClassRange { start: '[', end: '`' },",
          "    hir::ClassRange { start: '{', end: '~' }",
          "    ]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"space\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap().collect::<Vec<_>>(), vec![hir::ClassRange { start: '\\t', end: '\\t' }, hir::ClassRange { start: '\\n', end: '\\n' }, hir::ClassRange { start: '\\x0B', end: '\\x0B' }, hir::ClassRange { start: '\\x0C', end: '\\x0C' }, hir::ClassRange { start: '\\r', end: '\\r' }, hir::ClassRange { start: ' ', end: ' ' }]);",
          "    let result_invalid = posix_class(\"invalid_class\");",
          "    assert_eq!(result_invalid, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result_ascii = posix_class(\"ascii\");",
          "    assert_eq!(result_ascii.is_ok(), true);",
          "    assert_eq!(result_ascii.unwrap().collect::<Vec<_>>(), vec![hir::ClassRange { start: '\\u{0}', end: '~' }]);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"space\");",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap().collect::<Vec<_>>(), vec![hir::ClassRange { start: '\\t', end: '\\t' }, hir::ClassRange { start: '\\n', end: '\\n' }, hir::ClassRange { start: '\\x0B', end: '\\x0B' }, hir::ClassRange { start: '\\x0C', end: '\\x0C' }, hir::ClassRange { start: '\\r', end: '\\r' }, hir::ClassRange { start: ' ', end: ' ' }]);",
          "    let result_invalid = posix_class(\"invalid_class\");",
          "    assert_eq!(result_invalid, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "    let result_ascii = posix_class(\"ascii\");",
          "    assert_eq!(result_ascii.is_ok(), true);",
          "    assert_eq!(result_ascii.unwrap().collect::<Vec<_>>(), vec![hir::ClassRange { start: '\\u{0}', end: '~' }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"upper\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"upper\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"word\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "    ",
          "    let result = posix_class(\"ascii\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 1);",
          "    assert_eq!(ranges[0].start, '\\x00');",
          "    assert_eq!(ranges[0].end, '\\x7F');"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"word\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "    ",
          "    let result = posix_class(\"ascii\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 1);",
          "    assert_eq!(ranges[0].start, '\\x00');",
          "    assert_eq!(ranges[0].end, '\\x7F');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"xdigit\");",
          "}"
        ],
        "oracle": [
          "    let expected = Ok(vec![",
          "    hir::ClassRange { start: char::from(b'0'), end: char::from(b'9') },",
          "    hir::ClassRange { start: char::from(b'A'), end: char::from(b'F') },",
          "    hir::ClassRange { start: char::from(b'a'), end: char::from(b'f') },",
          "    ].into_iter());",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"xdigit\");",
          "    let expected = Ok(vec![",
          "    hir::ClassRange { start: char::from(b'0'), end: char::from(b'9') },",
          "    hir::ClassRange { start: char::from(b'A'), end: char::from(b'F') },",
          "    hir::ClassRange { start: char::from(b'a'), end: char::from(b'f') },",
          "    ].into_iter());",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"custom\");",
          "}"
        ],
        "oracle": [
          "    let result = posix_class(\"custom\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "    let result = posix_class(\"ascii\");",
          "    assert!(result.is_ok());",
          "    let class_ranges = result.unwrap();",
          "    // Check the class_ranges to validate they match ascii ranges",
          "    let expected_ranges = vec![hir::ClassRange { start: '\\x00', end: '\\x7F' }];",
          "    let actual_ranges: Vec<_> = class_ranges.collect();",
          "    assert_eq!(actual_ranges, expected_ranges);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"custom\");",
          "    let result = posix_class(\"custom\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "    let result = posix_class(\"ascii\");",
          "    assert!(result.is_ok());",
          "    let class_ranges = result.unwrap();",
          "    // Check the class_ranges to validate they match ascii ranges",
          "    let expected_ranges = vec![hir::ClassRange { start: '\\x00', end: '\\x7F' }];",
          "    let actual_ranges: Vec<_> = class_ranges.collect();",
          "    assert_eq!(actual_ranges, expected_ranges);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]