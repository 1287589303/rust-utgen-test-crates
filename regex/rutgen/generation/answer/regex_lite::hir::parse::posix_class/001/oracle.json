[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"alnum\");",
          "}"
        ],
        "oracle": [
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ]);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"alnum\");",
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"alpha\");",
          "}"
        ],
        "oracle": [
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"alpha\");",
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"ascii\");",
          "}"
        ],
        "oracle": [
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"ascii\");",
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"blank\");",
          "}"
        ],
        "oracle": [
          "    let kind_input = \"blank\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '\\t', end: '\\t' },",
          "    hir::ClassRange { start: ' ', end: ' ' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"alnum\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"alpha\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"ascii\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '\\u{0}', end: '\\u{7F}' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"xdigit\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'F' },",
          "    hir::ClassRange { start: 'a', end: 'f' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"unknown\";",
          "    let expected_output = Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED));",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"\";",
          "    let expected_output = Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED));",
          "    assert_eq!(posix_class(kind_input), expected_output);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"blank\");",
          "    let kind_input = \"blank\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '\\t', end: '\\t' },",
          "    hir::ClassRange { start: ' ', end: ' ' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"alnum\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"alpha\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"ascii\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '\\u{0}', end: '\\u{7F}' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"xdigit\";",
          "    let expected_output = Ok(vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'F' },",
          "    hir::ClassRange { start: 'a', end: 'f' },",
          "    ].into_iter());",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"unknown\";",
          "    let expected_output = Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED));",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "    ",
          "    let kind_input = \"\";",
          "    let expected_output = Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED));",
          "    assert_eq!(posix_class(kind_input), expected_output);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"cntrl\");",
          "}"
        ],
        "oracle": [
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let class_ranges = result.unwrap();",
          "    let expected_ranges = vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ];",
          "    assert_eq!(class_ranges.collect::<Vec<_>>(), expected_ranges);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"cntrl\");",
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let class_ranges = result.unwrap();",
          "    let expected_ranges = vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ];",
          "    assert_eq!(class_ranges.collect::<Vec<_>>(), expected_ranges);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"digit\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }]);",
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    let result = posix_class(\"unknown\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"digit\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }]);",
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges, vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    let result = posix_class(\"unknown\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"graph\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: '!', end: '~' }]);",
          "    ",
          "    let result = posix_class(\"digit\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: '0', end: '9' }]);",
          "    ",
          "    let result = posix_class(\"space\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: '\\t', end: '\\t' }, hir::ClassRange { start: '\\n', end: '\\n' }, hir::ClassRange { start: '\\x0B', end: '\\x0B' }, hir::ClassRange { start: '\\x0C', end: '\\x0C' }, hir::ClassRange { start: '\\r', end: '\\r' }, hir::ClassRange { start: ' ', end: ' ' }]);",
          "    ",
          "    let result = posix_class(\"alpha\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    ",
          "    let result = posix_class(\"invalid\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"graph\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: '!', end: '~' }]);",
          "    ",
          "    let result = posix_class(\"digit\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: '0', end: '9' }]);",
          "    ",
          "    let result = posix_class(\"space\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: '\\t', end: '\\t' }, hir::ClassRange { start: '\\n', end: '\\n' }, hir::ClassRange { start: '\\x0B', end: '\\x0B' }, hir::ClassRange { start: '\\x0C', end: '\\x0C' }, hir::ClassRange { start: '\\r', end: '\\r' }, hir::ClassRange { start: ' ', end: ' ' }]);",
          "    ",
          "    let result = posix_class(\"alpha\");",
          "    assert!(result.is_ok());",
          "    let class_ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(class_ranges, vec![hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    ",
          "    let result = posix_class(\"invalid\");",
          "    assert!(result.is_err());",
          "    assert_eq!(result.err().unwrap().msg, ERR_POSIX_CLASS_UNRECOGNIZED);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"lower\");",
          "}"
        ],
        "oracle": [
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges = result.unwrap();",
          "    let expected_ranges: Vec<hir::ClassRange> = vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ];",
          "    let actual_ranges: Vec<hir::ClassRange> = ranges.collect();",
          "    assert_eq!(actual_ranges, expected_ranges);"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"lower\");",
          "    let result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges = result.unwrap();",
          "    let expected_ranges: Vec<hir::ClassRange> = vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'Z' },",
          "    hir::ClassRange { start: 'a', end: 'z' },",
          "    ];",
          "    let actual_ranges: Vec<hir::ClassRange> = ranges.collect();",
          "    assert_eq!(actual_ranges, expected_ranges);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"print\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start, ' ');",
          "    assert_eq!(ranges[0].end, '~');",
          "    assert_eq!(ranges[1].start, '!',);",
          "    assert_eq!(ranges[1].end, '~');"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"print\");",
          "    assert_eq!(result.is_ok(), true);",
          "    let ranges: Vec<_> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 2);",
          "    assert_eq!(ranges[0].start, ' ');",
          "    assert_eq!(ranges[0].end, '~');",
          "    assert_eq!(ranges[1].start, '!',);",
          "    assert_eq!(ranges[1].end, '~');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"punct\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(vec![hir::ClassRange { start: '!', end: '/' }, hir::ClassRange { start: ':', end: '@' }, hir::ClassRange { start: '[', end: '`' }, hir::ClassRange { start: '{', end: '~' }].into_iter()));",
          "    result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges = result.unwrap();",
          "    assert_eq!(ranges.collect::<Vec<_>>(), vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    result = posix_class(\"alpha\");",
          "    assert!(result.is_ok());",
          "    let ranges = result.unwrap();",
          "    assert_eq!(ranges.collect::<Vec<_>>(), vec![hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    result = posix_class(\"nonexistent\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"punct\");",
          "    assert_eq!(result, Ok(vec![hir::ClassRange { start: '!', end: '/' }, hir::ClassRange { start: ':', end: '@' }, hir::ClassRange { start: '[', end: '`' }, hir::ClassRange { start: '{', end: '~' }].into_iter()));",
          "    result = posix_class(\"alnum\");",
          "    assert!(result.is_ok());",
          "    let ranges = result.unwrap();",
          "    assert_eq!(ranges.collect::<Vec<_>>(), vec![hir::ClassRange { start: '0', end: '9' }, hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    result = posix_class(\"alpha\");",
          "    assert!(result.is_ok());",
          "    let ranges = result.unwrap();",
          "    assert_eq!(ranges.collect::<Vec<_>>(), vec![hir::ClassRange { start: 'A', end: 'Z' }, hir::ClassRange { start: 'a', end: 'z' }]);",
          "    result = posix_class(\"nonexistent\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"space\");",
          "}"
        ],
        "oracle": [
          "    let expected_result = Ok(vec![",
          "    hir::ClassRange { start: ' ', end: '~' },",
          "    ].into_iter());",
          "    assert_eq!(result, expected_result);",
          "    result.is_ok();",
          "    result.unwrap();",
          "    result.unwrap().count();"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"space\");",
          "    let expected_result = Ok(vec![",
          "    hir::ClassRange { start: ' ', end: '~' },",
          "    ].into_iter());",
          "    assert_eq!(result, expected_result);",
          "    result.is_ok();",
          "    result.unwrap();",
          "    result.unwrap().count();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"upper\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"upper\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"word\");",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 4);",
          "    assert_eq!(ranges[0].start, '0');",
          "    assert_eq!(ranges[0].end, '9');",
          "    assert_eq!(ranges[1].start, 'A');",
          "    assert_eq!(ranges[1].end, 'Z');",
          "    assert_eq!(ranges[2].start, '_');",
          "    assert_eq!(ranges[2].end, '_');",
          "    assert_eq!(ranges[3].start, 'a');",
          "    assert_eq!(ranges[3].end, 'z');"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"word\");",
          "    assert!(result.is_ok());",
          "    let ranges: Vec<hir::ClassRange> = result.unwrap().collect();",
          "    assert_eq!(ranges.len(), 4);",
          "    assert_eq!(ranges[0].start, '0');",
          "    assert_eq!(ranges[0].end, '9');",
          "    assert_eq!(ranges[1].start, 'A');",
          "    assert_eq!(ranges[1].end, 'Z');",
          "    assert_eq!(ranges[2].start, '_');",
          "    assert_eq!(ranges[2].end, '_');",
          "    assert_eq!(ranges[3].start, 'a');",
          "    assert_eq!(ranges[3].end, 'z');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"xdigit\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'F' },",
          "    hir::ClassRange { start: 'a', end: 'f' }",
          "    ]).into_iter());"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"xdigit\");",
          "    assert_eq!(result, Ok(vec![",
          "    hir::ClassRange { start: '0', end: '9' },",
          "    hir::ClassRange { start: 'A', end: 'F' },",
          "    hir::ClassRange { start: 'a', end: 'f' }",
          "    ]).into_iter());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let result = posix_class(\"invalid_class\");",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));"
        ],
        "code": [
          "{",
          "    let result = posix_class(\"invalid_class\");",
          "    assert_eq!(result, Err(Error::new(ERR_POSIX_CLASS_UNRECOGNIZED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]