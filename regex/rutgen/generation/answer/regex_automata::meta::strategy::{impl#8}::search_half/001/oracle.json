[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"test haystack\";",
          "    let span = Span::new(0, haystack.len());",
          "    let anchored = Anchored::Yes;",
          "",
          "    let input = Input::new(haystack)",
          "        .span(span)",
          "        .anchored(anchored);",
          "",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::new(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::new(),",
          "        onepass: wrappers::OnePassCache::new(),",
          "        hybrid: wrappers::HybridCache::new(),",
          "        revhybrid: wrappers::ReverseHybridCache::new(),",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), None, &[]).unwrap();",
          "    let reverse_suffix = ReverseSuffix {",
          "        core,",
          "        pre: Prefilter::default(),",
          "    };",
          "",
          "    let _ = reverse_suffix.search_half(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert!(input.get_anchored().is_anchored() == true);",
          "    assert!(reverse_suffix.core.search_half(&mut cache, &input).is_some());",
          "    assert!(reverse_suffix.try_search_half_start(&mut cache, &input).is_ok());",
          "    assert!(reverse_suffix.try_search_half_fwd(&mut cache, &input).is_some());",
          "    assert!(cache.captures.len() > 0);",
          "    assert!(cache.haystack.len() == haystack.len());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"test haystack\";",
          "    let span = Span::new(0, haystack.len());",
          "    let anchored = Anchored::Yes;",
          "",
          "    let input = Input::new(haystack)",
          "        .span(span)",
          "        .anchored(anchored);",
          "",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::new(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::new(),",
          "        onepass: wrappers::OnePassCache::new(),",
          "        hybrid: wrappers::HybridCache::new(),",
          "        revhybrid: wrappers::ReverseHybridCache::new(),",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), None, &[]).unwrap();",
          "    let reverse_suffix = ReverseSuffix {",
          "        core,",
          "        pre: Prefilter::default(),",
          "    };",
          "",
          "    let _ = reverse_suffix.search_half(&mut cache, &input);",
          "    assert!(input.get_anchored().is_anchored() == true);",
          "    assert!(reverse_suffix.core.search_half(&mut cache, &input).is_some());",
          "    assert!(reverse_suffix.try_search_half_start(&mut cache, &input).is_ok());",
          "    assert!(reverse_suffix.try_search_half_fwd(&mut cache, &input).is_some());",
          "    assert!(cache.captures.len() > 0);",
          "    assert!(cache.haystack.len() == haystack.len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"example input\";",
          "    let span = Span::new(0, haystack.len());",
          "    let pattern_id = PatternID::default();",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "",
          "    let input = Input::new(haystack)",
          "        .span(span)",
          "        .anchored(anchored);",
          "",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::new(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::new(),",
          "        onepass: wrappers::OnePassCache::new(),",
          "        hybrid: wrappers::HybridCache::new(),",
          "        revhybrid: wrappers::ReverseHybridCache::new(),",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), None, &[]).unwrap();",
          "    let reverse_suffix = ReverseSuffix {",
          "        core,",
          "        pre: Prefilter::default(),",
          "    };",
          "",
          "    let _ = reverse_suffix.search_half(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert!(input.get_anchored().is_anchored());",
          "    assert_eq!(cache.captures.len(), 0);",
          "    let result = reverse_suffix.search_half(&mut cache, &input);",
          "    assert!(result.is_some());",
          "    let half_match = result.unwrap();",
          "    assert_eq!(half_match.pattern(), input.get_anchored().pattern().unwrap());",
          "    assert!(half_match.offset() >= 0);",
          "    assert!(half_match.offset() < input.end());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"example input\";",
          "    let span = Span::new(0, haystack.len());",
          "    let pattern_id = PatternID::default();",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "",
          "    let input = Input::new(haystack)",
          "        .span(span)",
          "        .anchored(anchored);",
          "",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::new(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::new(),",
          "        onepass: wrappers::OnePassCache::new(),",
          "        hybrid: wrappers::HybridCache::new(),",
          "        revhybrid: wrappers::ReverseHybridCache::new(),",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), None, &[]).unwrap();",
          "    let reverse_suffix = ReverseSuffix {",
          "        core,",
          "        pre: Prefilter::default(),",
          "    };",
          "",
          "    let _ = reverse_suffix.search_half(&mut cache, &input);",
          "    assert!(input.get_anchored().is_anchored());",
          "    assert_eq!(cache.captures.len(), 0);",
          "    let result = reverse_suffix.search_half(&mut cache, &input);",
          "    assert!(result.is_some());",
          "    let half_match = result.unwrap();",
          "    assert_eq!(half_match.pattern(), input.get_anchored().pattern().unwrap());",
          "    assert!(half_match.offset() >= 0);",
          "    assert!(half_match.offset() < input.end());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"searching for a match\";",
          "    let span = Span::new(0, haystack.len());",
          "    let pattern_id = PatternID::default();",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "",
          "    let input = Input::new(haystack)",
          "        .span(span)",
          "        .anchored(anchored);",
          "",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::new(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::new(),",
          "        onepass: wrappers::OnePassCache::new(),",
          "        hybrid: wrappers::HybridCache::new(),",
          "        revhybrid: wrappers::ReverseHybridCache::new(),",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), None, &[]).unwrap();",
          "    let reverse_suffix = ReverseSuffix {",
          "        core,",
          "        pre: Prefilter::default(),",
          "    };",
          "",
          "    let _ = reverse_suffix.search_half(&mut cache, &input);",
          "}"
        ],
        "oracle": [
          "    assert!(reverse_suffix.search_half(&mut cache, &input).is_some());",
          "    let half_match = reverse_suffix.search_half(&mut cache, &input).unwrap();",
          "    assert_eq!(half_match.pattern(), pattern_id);",
          "    assert!(half_match.offset() < input.end());"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"searching for a match\";",
          "    let span = Span::new(0, haystack.len());",
          "    let pattern_id = PatternID::default();",
          "    let anchored = Anchored::Pattern(pattern_id);",
          "",
          "    let input = Input::new(haystack)",
          "        .span(span)",
          "        .anchored(anchored);",
          "",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache::new(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::new(),",
          "        onepass: wrappers::OnePassCache::new(),",
          "        hybrid: wrappers::HybridCache::new(),",
          "        revhybrid: wrappers::ReverseHybridCache::new(),",
          "    };",
          "",
          "    let core = Core::new(RegexInfo::default(), None, &[]).unwrap();",
          "    let reverse_suffix = ReverseSuffix {",
          "        core,",
          "        pre: Prefilter::default(),",
          "    };",
          "",
          "    let _ = reverse_suffix.search_half(&mut cache, &input);",
          "    assert!(reverse_suffix.search_half(&mut cache, &input).is_some());",
          "    let half_match = reverse_suffix.search_half(&mut cache, &input).unwrap();",
          "    assert_eq!(half_match.pattern(), pattern_id);",
          "    assert!(half_match.offset() < input.end());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]