[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Empty",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    let hir_empty = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_empty);",
          "    ",
          "    let hir_literal = Hir { kind: HirKind::Literal(Literal::new(\"test\")), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_literal);",
          "    ",
          "    let hir_class = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_class);",
          "    ",
          "    let hir_look = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_look);",
          "    ",
          "    let hir_capture_empty = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_capture_empty);",
          "    ",
          "    let hir_repetition_empty = Hir { kind: HirKind::Repetition(Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_repetition_empty);",
          "    ",
          "    let hir_concat_empty = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_concat_empty);",
          "    ",
          "    let hir_alternation_empty = Hir { kind: HirKind::Alternation(vec![]), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_alternation_empty);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Empty",
          "    drop(hir);",
          "    let hir_empty = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_empty);",
          "    ",
          "    let hir_literal = Hir { kind: HirKind::Literal(Literal::new(\"test\")), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_literal);",
          "    ",
          "    let hir_class = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_class);",
          "    ",
          "    let hir_look = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_look);",
          "    ",
          "    let hir_capture_empty = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_capture_empty);",
          "    ",
          "    let hir_repetition_empty = Hir { kind: HirKind::Repetition(Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_repetition_empty);",
          "    ",
          "    let hir_concat_empty = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_concat_empty);",
          "    ",
          "    let hir_alternation_empty = Hir { kind: HirKind::Alternation(vec![]), props: Properties(Box::new(PropertiesI)); };",
          "    drop(hir_alternation_empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Literal(Literal::from(\"test\")),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Literal",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    let hir_empty = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)) };",
          "    let hir_literal = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)) };",
          "    let hir_class = Hir { kind: HirKind::Class(Class::new()), props: Properties(Box::new(PropertiesI)) };",
          "    let hir_look = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_empty);",
          "    drop(hir_literal);",
          "    drop(hir_class);",
          "    drop(hir_look);",
          "    let hir_capture_empty_sub = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_capture_empty_sub);",
          "    let hir_repetition_empty_sub = Hir { kind: HirKind::Repetition(Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_repetition_empty_sub);",
          "    let hir_concat_empty = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_concat_empty);",
          "    let hir_alternation_empty = Hir { kind: HirKind::Alternation(vec![]), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_alternation_empty);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Literal(Literal::from(\"test\")),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Literal",
          "    drop(hir);",
          "    let hir_empty = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)) };",
          "    let hir_literal = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)) };",
          "    let hir_class = Hir { kind: HirKind::Class(Class::new()), props: Properties(Box::new(PropertiesI)) };",
          "    let hir_look = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_empty);",
          "    drop(hir_literal);",
          "    drop(hir_class);",
          "    drop(hir_look);",
          "    let hir_capture_empty_sub = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_capture_empty_sub);",
          "    let hir_repetition_empty_sub = Hir { kind: HirKind::Repetition(Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_repetition_empty_sub);",
          "    let hir_concat_empty = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_concat_empty);",
          "    let hir_alternation_empty = Hir { kind: HirKind::Alternation(vec![]), props: Properties(Box::new(PropertiesI)) };",
          "    drop(hir_alternation_empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Class",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir.kind(), HirKind::Class(Class::new(vec!['a', 'b', 'c'])));",
          "    let initial_props = hir.properties();",
          "    assert!(initial_props.0.is_some());",
          "    let initial_kind = hir.kind();",
          "    assert!(matches!(initial_kind, HirKind::Class(_)));",
          "    assert!(matches!(initial_kind, HirKind::Literal(_) | HirKind::Class(_) | HirKind::Look(_) | HirKind::Empty));",
          "    assert!(drop(hir).is_none());"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Class",
          "    drop(hir);",
          "    assert_eq!(hir.kind(), HirKind::Class(Class::new(vec!['a', 'b', 'c'])));",
          "    let initial_props = hir.properties();",
          "    assert!(initial_props.0.is_some());",
          "    let initial_kind = hir.kind();",
          "    assert!(matches!(initial_kind, HirKind::Class(_)));",
          "    assert!(matches!(initial_kind, HirKind::Literal(_) | HirKind::Class(_) | HirKind::Look(_) | HirKind::Empty));",
          "    assert!(drop(hir).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(Look::new()),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Look",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    let hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Class(Class::new()), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Repetition(Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Alternation(vec![]), props: Properties(Box::new(PropertiesI)) }; drop(hir);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(Look::new()),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Look",
          "    drop(hir);",
          "    let hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Class(Class::new()), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Repetition(Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "    let hir = Hir { kind: HirKind::Alternation(vec![]), props: Properties(Box::new(PropertiesI)) }; drop(hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capture = Capture {",
          "        index: 0,",
          "        name: None,",
          "        sub: Box::new(Hir {",
          "            kind: HirKind::Empty,",
          "            props: Properties(Box::new(PropertiesI)),",
          "        }),",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(capture),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Capture with an empty sub",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    drop(hir); // Ensure dropping Hir with HirKind::Capture and empty sub does not panic or cause issues",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Empty",
          "    drop(empty_hir); // Ensure dropping Hir with HirKind::Empty does not panic or cause issues",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Literal",
          "    drop(literal_hir); // Ensure dropping Hir with HirKind::Literal does not panic or cause issues",
          "    let class_hir = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Class",
          "    drop(class_hir); // Ensure dropping Hir with HirKind::Class does not panic or cause issues",
          "    let look_hir = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Look",
          "    drop(look_hir); // Ensure dropping Hir with HirKind::Look does not panic or cause issues",
          "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) }; // Test for non-empty Repetition",
          "    drop(repetition_hir); // Ensure dropping Hir with non-empty HirKind::Repetition does not panic or cause issues",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![Hir::empty(), Hir::empty()]), props: Properties(Box::new(PropertiesI)) }; // Test for non-empty Concat",
          "    drop(concat_hir); // Ensure dropping Hir with non-empty HirKind::Concat does not panic or cause issues",
          "    let alternation_hir = Hir { kind: HirKind::Alternation(vec![Hir::empty(), Hir::empty()]), props: Properties(Box::new(PropertiesI)) }; // Test for non-empty Alternation",
          "    drop(alternation_hir); // Ensure dropping Hir with non-empty HirKind::Alternation does not panic or cause issues"
        ],
        "code": [
          "{",
          "    let capture = Capture {",
          "        index: 0,",
          "        name: None,",
          "        sub: Box::new(Hir {",
          "            kind: HirKind::Empty,",
          "            props: Properties(Box::new(PropertiesI)),",
          "        }),",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Capture(capture),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Capture with an empty sub",
          "    drop(hir);",
          "    drop(hir); // Ensure dropping Hir with HirKind::Capture and empty sub does not panic or cause issues",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Empty",
          "    drop(empty_hir); // Ensure dropping Hir with HirKind::Empty does not panic or cause issues",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Literal",
          "    drop(literal_hir); // Ensure dropping Hir with HirKind::Literal does not panic or cause issues",
          "    let class_hir = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Class",
          "    drop(class_hir); // Ensure dropping Hir with HirKind::Class does not panic or cause issues",
          "    let look_hir = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)) }; // Test for HirKind::Look",
          "    drop(look_hir); // Ensure dropping Hir with HirKind::Look does not panic or cause issues",
          "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: None, greedy: true, sub: Box::new(Hir::empty()) }), props: Properties(Box::new(PropertiesI)) }; // Test for non-empty Repetition",
          "    drop(repetition_hir); // Ensure dropping Hir with non-empty HirKind::Repetition does not panic or cause issues",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![Hir::empty(), Hir::empty()]), props: Properties(Box::new(PropertiesI)) }; // Test for non-empty Concat",
          "    drop(concat_hir); // Ensure dropping Hir with non-empty HirKind::Concat does not panic or cause issues",
          "    let alternation_hir = Hir { kind: HirKind::Alternation(vec![Hir::empty(), Hir::empty()]), props: Properties(Box::new(PropertiesI)) }; // Test for non-empty Alternation",
          "    drop(alternation_hir); // Ensure dropping Hir with non-empty HirKind::Alternation does not panic or cause issues",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let repetition = Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir {",
          "            kind: HirKind::Empty,",
          "            props: Properties(Box::new(PropertiesI)),",
          "        }),",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Repetition with an empty sub",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    let repetition = Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), }) };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI)), };",
          "    drop(hir);",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), };",
          "    drop(empty_hir);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)), };",
          "    drop(literal_hir);",
          "    let class_hir = Hir { kind: HirKind::Class(Class::from(\"a-z\")), props: Properties(Box::new(PropertiesI)), };",
          "    drop(class_hir);",
          "    let look_hir = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)), };",
          "    drop(look_hir);",
          "    let capture_with_empty_sub = Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), }) };",
          "    let capture_hir = Hir { kind: HirKind::Capture(capture_with_empty_sub), props: Properties(Box::new(PropertiesI)), };",
          "    drop(capture_hir);",
          "    let repetition_with_empty_sub = Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), }) };",
          "    let repetition_hir = Hir { kind: HirKind::Repetition(repetition_with_empty_sub), props: Properties(Box::new(PropertiesI)), };",
          "    drop(repetition_hir);"
        ],
        "code": [
          "{",
          "    let repetition = Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir {",
          "            kind: HirKind::Empty,",
          "            props: Properties(Box::new(PropertiesI)),",
          "        }),",
          "    };",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Repetition with an empty sub",
          "    drop(hir);",
          "    let repetition = Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), }) };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI)), };",
          "    drop(hir);",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), };",
          "    drop(empty_hir);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI)), };",
          "    drop(literal_hir);",
          "    let class_hir = Hir { kind: HirKind::Class(Class::from(\"a-z\")), props: Properties(Box::new(PropertiesI)), };",
          "    drop(class_hir);",
          "    let look_hir = Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI)), };",
          "    drop(look_hir);",
          "    let capture_with_empty_sub = Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), }) };",
          "    let capture_hir = Hir { kind: HirKind::Capture(capture_with_empty_sub), props: Properties(Box::new(PropertiesI)), };",
          "    drop(capture_hir);",
          "    let repetition_with_empty_sub = Repetition { min: 0, max: None, greedy: true, sub: Box::new(Hir { kind: HirKind::Empty, props: Properties(Box::new(PropertiesI)), }) };",
          "    let repetition_hir = Hir { kind: HirKind::Repetition(repetition_with_empty_sub), props: Properties(Box::new(PropertiesI)), };",
          "    drop(repetition_hir);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Concat(vec![]),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Concat that is empty",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    let hir_empty = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_empty);",
          "    ",
          "    let hir_literal = Hir {",
          "    kind: HirKind::Literal(Literal),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_literal);",
          "    ",
          "    let hir_class = Hir {",
          "    kind: HirKind::Class(Class),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_class);",
          "    ",
          "    let hir_look = Hir {",
          "    kind: HirKind::Look(Look),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_look);",
          "    ",
          "    let capture_empty = Capture {",
          "    index: 0,",
          "    name: None,",
          "    sub: Box::new(Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI)),",
          "    }),",
          "    };",
          "    ",
          "    let hir_capture_empty = Hir {",
          "    kind: HirKind::Capture(capture_empty),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_capture_empty);",
          "    ",
          "    let repetition_empty = Repetition {",
          "    min: 0,",
          "    max: Some(0),",
          "    greedy: true,",
          "    sub: Box::new(Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI)),",
          "    }),",
          "    };",
          "    ",
          "    let hir_repetition_empty = Hir {",
          "    kind: HirKind::Repetition(repetition_empty),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_repetition_empty);",
          "    ",
          "    let hir_concat_empty = Hir {",
          "    kind: HirKind::Concat(vec![]),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_concat_empty);",
          "    ",
          "    let hir_alternation_empty = Hir {",
          "    kind: HirKind::Alternation(vec![]),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_alternation_empty);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Concat(vec![]),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Concat that is empty",
          "    drop(hir);",
          "    let hir_empty = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_empty);",
          "    ",
          "    let hir_literal = Hir {",
          "    kind: HirKind::Literal(Literal),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_literal);",
          "    ",
          "    let hir_class = Hir {",
          "    kind: HirKind::Class(Class),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_class);",
          "    ",
          "    let hir_look = Hir {",
          "    kind: HirKind::Look(Look),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_look);",
          "    ",
          "    let capture_empty = Capture {",
          "    index: 0,",
          "    name: None,",
          "    sub: Box::new(Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI)),",
          "    }),",
          "    };",
          "    ",
          "    let hir_capture_empty = Hir {",
          "    kind: HirKind::Capture(capture_empty),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_capture_empty);",
          "    ",
          "    let repetition_empty = Repetition {",
          "    min: 0,",
          "    max: Some(0),",
          "    greedy: true,",
          "    sub: Box::new(Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties(Box::new(PropertiesI)),",
          "    }),",
          "    };",
          "    ",
          "    let hir_repetition_empty = Hir {",
          "    kind: HirKind::Repetition(repetition_empty),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_repetition_empty);",
          "    ",
          "    let hir_concat_empty = Hir {",
          "    kind: HirKind::Concat(vec![]),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_concat_empty);",
          "    ",
          "    let hir_alternation_empty = Hir {",
          "    kind: HirKind::Alternation(vec![]),",
          "    props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    drop(hir_alternation_empty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![]),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Alternation that is empty",
          "    drop(hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir.kind(), HirKind::Alternation(vec![]));",
          "    assert!(hir.props.0.is_empty());",
          "    assert!(hir.kind().subs().is_empty());"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Alternation(vec![]),",
          "        props: Properties(Box::new(PropertiesI)),",
          "    };",
          "    // This will call drop on an HirKind::Alternation that is empty",
          "    drop(hir);",
          "    assert_eq!(hir.kind(), HirKind::Alternation(vec![]));",
          "    assert!(hir.props.0.is_empty());",
          "    assert!(hir.kind().subs().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]