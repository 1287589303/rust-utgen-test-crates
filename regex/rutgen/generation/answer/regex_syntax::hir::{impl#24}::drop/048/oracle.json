[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_expression = Box::new(Hir {",
          "        kind: HirKind::Literal(Literal::from(\"test\")),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    });",
          "",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(5),",
          "        greedy: true,",
          "        sub: sub_expression,",
          "    };",
          "",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    };",
          "",
          "    let _ = hir; // Function under test",
          "}"
        ],
        "oracle": [
          "    let sub_expression = Box::new(Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI::new())) });",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: sub_expression };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI::new())) };",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(repetition));",
          "    assert!(!hir.kind().subs().is_empty());",
          "    assert!(matches!(hir.kind().subs()[0].kind, HirKind::Literal(_)));"
        ],
        "code": [
          "{",
          "    let sub_expression = Box::new(Hir {",
          "        kind: HirKind::Literal(Literal::from(\"test\")),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    });",
          "",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(5),",
          "        greedy: true,",
          "        sub: sub_expression,",
          "    };",
          "",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    };",
          "",
          "    let _ = hir; // Function under test",
          "    let sub_expression = Box::new(Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI::new())) });",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: sub_expression };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI::new())) };",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(repetition));",
          "    assert!(!hir.kind().subs().is_empty());",
          "    assert!(matches!(hir.kind().subs()[0].kind, HirKind::Literal(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_expression = Box::new(Hir {",
          "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    });",
          "",
          "    let repetition = Repetition {",
          "        min: 2,",
          "        max: None,",
          "        greedy: false,",
          "        sub: sub_expression,",
          "    };",
          "",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    };",
          "",
          "    let _ = hir; // Function under test",
          "}"
        ],
        "oracle": [
          "    let sub_expression = Box::new(Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI::new())), });",
          "    let repetition = Repetition { min: 2, max: None, greedy: false, sub: sub_expression, };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI::new())), };",
          "    assert!(matches!(hir.kind(), HirKind::Repetition(ref x) if !x.sub.kind.subs().is_empty()));",
          "    let mut stack = vec![mem::replace(hir, Hir::empty())];",
          "    assert!(!stack.is_empty());",
          "    let expr = stack.pop().unwrap();",
          "    assert!(matches!(expr.kind, HirKind::Literal(_)));",
          "    assert!(matches!(expr.kind, HirKind::Class(_) | HirKind::Look(_) | HirKind::Literal(_) | HirKind::Empty));",
          "    let expr = stack.pop().unwrap();",
          "    assert!(matches!(expr.kind, HirKind::Literal(_)));"
        ],
        "code": [
          "{",
          "    let sub_expression = Box::new(Hir {",
          "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    });",
          "",
          "    let repetition = Repetition {",
          "        min: 2,",
          "        max: None,",
          "        greedy: false,",
          "        sub: sub_expression,",
          "    };",
          "",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    };",
          "",
          "    let _ = hir; // Function under test",
          "    let sub_expression = Box::new(Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), props: Properties(Box::new(PropertiesI::new())), });",
          "    let repetition = Repetition { min: 2, max: None, greedy: false, sub: sub_expression, };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI::new())), };",
          "    assert!(matches!(hir.kind(), HirKind::Repetition(ref x) if !x.sub.kind.subs().is_empty()));",
          "    let mut stack = vec![mem::replace(hir, Hir::empty())];",
          "    assert!(!stack.is_empty());",
          "    let expr = stack.pop().unwrap();",
          "    assert!(matches!(expr.kind, HirKind::Literal(_)));",
          "    assert!(matches!(expr.kind, HirKind::Class(_) | HirKind::Look(_) | HirKind::Literal(_) | HirKind::Empty));",
          "    let expr = stack.pop().unwrap();",
          "    assert!(matches!(expr.kind, HirKind::Literal(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_expression = Box::new(Hir {",
          "        kind: HirKind::Look(Look::new()),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    });",
          "",
          "    let repetition = Repetition {",
          "        min: 0,",
          "        max: Some(10),",
          "        greedy: true,",
          "        sub: sub_expression,",
          "    };",
          "",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    };",
          "",
          "    let _ = hir; // Function under test",
          "}"
        ],
        "oracle": [
          "    let sub_expression = Box::new(Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI::new())) });",
          "    let repetition = Repetition { min: 0, max: Some(10), greedy: true, sub: sub_expression };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI::new())) };",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(repetition));",
          "    assert!(!hir.kind.subs().is_empty());",
          "    let mut stack = vec![mem::replace(&hir, Hir::empty())];",
          "    assert!(stack.len() > 0);",
          "    let expr = stack.pop().unwrap();",
          "    match expr.kind {",
          "    HirKind::Literal(_) => assert!(true),",
          "    HirKind::Class(_) | HirKind::Look(_) | HirKind::Empty => assert!(true),",
          "    _ => assert!(false),",
          "    }"
        ],
        "code": [
          "{",
          "    let sub_expression = Box::new(Hir {",
          "        kind: HirKind::Look(Look::new()),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    });",
          "",
          "    let repetition = Repetition {",
          "        min: 0,",
          "        max: Some(10),",
          "        greedy: true,",
          "        sub: sub_expression,",
          "    };",
          "",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties(Box::new(PropertiesI::new())),",
          "    };",
          "",
          "    let _ = hir; // Function under test",
          "    let sub_expression = Box::new(Hir { kind: HirKind::Look(Look::new()), props: Properties(Box::new(PropertiesI::new())) });",
          "    let repetition = Repetition { min: 0, max: Some(10), greedy: true, sub: sub_expression };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties(Box::new(PropertiesI::new())) };",
          "    assert_eq!(hir.kind(), &HirKind::Repetition(repetition));",
          "    assert!(!hir.kind.subs().is_empty());",
          "    let mut stack = vec![mem::replace(&hir, Hir::empty())];",
          "    assert!(stack.len() > 0);",
          "    let expr = stack.pop().unwrap();",
          "    match expr.kind {",
          "    HirKind::Literal(_) => assert!(true),",
          "    HirKind::Class(_) | HirKind::Look(_) | HirKind::Empty => assert!(true),",
          "    _ => assert!(false),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]