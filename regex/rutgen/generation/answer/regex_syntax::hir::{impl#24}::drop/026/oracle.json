[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let _ = {",
          "        let inner_hir = Hir {",
          "            kind: HirKind::Look,",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "}"
        ],
        "oracle": [
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI {})) };",
          "    assert_eq!(concat_hir.kind(), &HirKind::Concat(vec![]));",
          "    let non_empty_concat_hir = Hir { kind: HirKind::Concat(vec![inner_hir]), props: Properties(Box::new(PropertiesI {})) };",
          "    assert!(!non_empty_concat_hir.kind.subs().is_empty());",
          "    let expr_kind_look = HirKind::Look;",
          "    let expr = Hir { kind: expr_kind_look, props: Properties(Box::new(PropertiesI {})) };",
          "    let mut stack = vec![expr];",
          "    assert!(stack.pop().is_some());",
          "    let popped_expr = stack.pop().unwrap();",
          "    assert!(matches!(popped_expr.kind, HirKind::Look(_)));",
          "    assert!(matches!(popped_expr.kind, HirKind::Class(_) | HirKind::Look(_) | HirKind::Literal(_) | HirKind::Empty));"
        ],
        "code": [
          "{",
          "    let _ = {",
          "        let inner_hir = Hir {",
          "            kind: HirKind::Look,",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![]), props: Properties(Box::new(PropertiesI {})) };",
          "    assert_eq!(concat_hir.kind(), &HirKind::Concat(vec![]));",
          "    let non_empty_concat_hir = Hir { kind: HirKind::Concat(vec![inner_hir]), props: Properties(Box::new(PropertiesI {})) };",
          "    assert!(!non_empty_concat_hir.kind.subs().is_empty());",
          "    let expr_kind_look = HirKind::Look;",
          "    let expr = Hir { kind: expr_kind_look, props: Properties(Box::new(PropertiesI {})) };",
          "    let mut stack = vec![expr];",
          "    assert!(stack.pop().is_some());",
          "    let popped_expr = stack.pop().unwrap();",
          "    assert!(matches!(popped_expr.kind, HirKind::Look(_)));",
          "    assert!(matches!(popped_expr.kind, HirKind::Class(_) | HirKind::Look(_) | HirKind::Literal(_) | HirKind::Empty));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let _ = {",
          "        let inner_hir = Hir {",
          "            kind: HirKind::Literal(Literal::from(\"test\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "}"
        ],
        "oracle": [
          "    let inner_hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI {})) };",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![inner_hir]), props: Properties(Box::new(PropertiesI {})) };",
          "    let mut result = concat_hir;",
          "    assert_eq!(result.kind(), &HirKind::Concat(vec![HirKind::Literal(Literal::from(\"test\"))]));",
          "    assert!(!result.kind().subs().is_empty());",
          "    result.drop();",
          "    assert_eq!(result.kind(), &HirKind::Concat(vec![]));"
        ],
        "code": [
          "{",
          "    let _ = {",
          "        let inner_hir = Hir {",
          "            kind: HirKind::Literal(Literal::from(\"test\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "    let inner_hir = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI {})) };",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![inner_hir]), props: Properties(Box::new(PropertiesI {})) };",
          "    let mut result = concat_hir;",
          "    assert_eq!(result.kind(), &HirKind::Concat(vec![HirKind::Literal(Literal::from(\"test\"))]));",
          "    assert!(!result.kind().subs().is_empty());",
          "    result.drop();",
          "    assert_eq!(result.kind(), &HirKind::Concat(vec![]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let _ = {",
          "        let inner_hir = Hir {",
          "            kind: HirKind::Class(Class::from('a')),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "}"
        ],
        "oracle": [
          "    HirKind::Concat(ref x) at line 1917 is true",
          "    x.is_empty() at line 1926 is false",
          "    let Some(mut expr) = stack.pop() at line 1932 is true",
          "    expr.kind matches HirKind::Look(_) at line 1933 is true",
          "    expr.kind matches HirKind::Class(_) or HirKind::Look(_) or HirKind::Literal(_) or HirKind::Empty at line 1933 is true",
          "    let Some(mut expr) = stack.pop() at line 1932 is true"
        ],
        "code": [
          "{",
          "    let _ = {",
          "        let inner_hir = Hir {",
          "            kind: HirKind::Class(Class::from('a')),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "    HirKind::Concat(ref x) at line 1917 is true",
          "    x.is_empty() at line 1926 is false",
          "    let Some(mut expr) = stack.pop() at line 1932 is true",
          "    expr.kind matches HirKind::Look(_) at line 1933 is true",
          "    expr.kind matches HirKind::Class(_) or HirKind::Look(_) or HirKind::Literal(_) or HirKind::Empty at line 1933 is true",
          "    let Some(mut expr) = stack.pop() at line 1932 is true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let _ = {",
          "        let inner_hir1 = Hir {",
          "            kind: HirKind::Look,",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let inner_hir2 = Hir {",
          "            kind: HirKind::Literal(Literal::from(\"test\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir1, inner_hir2]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "}"
        ],
        "oracle": [
          "    let inner_hir1 = Hir { kind: HirKind::Look, props: Properties(Box::new(PropertiesI {})) };",
          "    let inner_hir2 = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI {})) };",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![inner_hir1, inner_hir2]), props: Properties(Box::new(PropertiesI {})) };",
          "    let expr = concat_hir.kind();",
          "    let is_empty = matches!(expr, HirKind::Concat(ref x) if !x.is_empty());",
          "    let stack = vec![concat_hir];",
          "    let mut expr = stack.pop().unwrap();",
          "    assert!(matches!(expr.kind, HirKind::Look(_)));",
          "    assert!(matches!(expr.kind, HirKind::Class(_) | HirKind::Look(_) | HirKind::Literal(_) | HirKind::Empty));",
          "    let mut expr = stack.pop().unwrap();"
        ],
        "code": [
          "{",
          "    let _ = {",
          "        let inner_hir1 = Hir {",
          "            kind: HirKind::Look,",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let inner_hir2 = Hir {",
          "            kind: HirKind::Literal(Literal::from(\"test\")),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        let concat_hir = Hir {",
          "            kind: HirKind::Concat(vec![inner_hir1, inner_hir2]),",
          "            props: Properties(Box::new(PropertiesI {})),",
          "        };",
          "        concat_hir",
          "    };",
          "    let inner_hir1 = Hir { kind: HirKind::Look, props: Properties(Box::new(PropertiesI {})) };",
          "    let inner_hir2 = Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties(Box::new(PropertiesI {})) };",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![inner_hir1, inner_hir2]), props: Properties(Box::new(PropertiesI {})) };",
          "    let expr = concat_hir.kind();",
          "    let is_empty = matches!(expr, HirKind::Concat(ref x) if !x.is_empty());",
          "    let stack = vec![concat_hir];",
          "    let mut expr = stack.pop().unwrap();",
          "    assert!(matches!(expr.kind, HirKind::Look(_)));",
          "    assert!(matches!(expr.kind, HirKind::Class(_) | HirKind::Look(_) | HirKind::Literal(_) | HirKind::Empty));",
          "    let mut expr = stack.pop().unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]