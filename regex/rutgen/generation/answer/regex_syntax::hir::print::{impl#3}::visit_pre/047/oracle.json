[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes: Vec<u8> = vec![72, 101, 108, 108, 111]; // \"Hello\"",
          "    let literal = hir::Literal(bytes);",
          "    let hir_instance = Hir {",
          "        kind: HirKind::Literal(literal),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let mut writer = String::new();",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    ",
          "    let _result = visitor.visit_pre(&hir_instance);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(visitor.wtr.as_str(), r\"(?:)\");",
          "    assert!(visitor.wtr.is_empty());",
          "    assert!(writer.is_empty());",
          "    assert!(matches!(visitor.visit_pre(&hir_instance), Ok(())));",
          "    assert!(matches!(visitor.finish(), Ok(())));",
          "    assert!(matches!(visitor.visit_post(&hir_instance), Ok(())));",
          "    assert!(cls.ranges().is_empty() == false);",
          "    assert!(self.wtr.write_str(\"(?-u:[\")?.is_err());",
          "    assert!(matches!(cls.ranges().is_empty(), false));",
          "    assert_eq!(visitor.wtr.as_str(), \"Hello\");"
        ],
        "code": [
          "{",
          "    let bytes: Vec<u8> = vec![72, 101, 108, 108, 111]; // \"Hello\"",
          "    let literal = hir::Literal(bytes);",
          "    let hir_instance = Hir {",
          "        kind: HirKind::Literal(literal),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let mut writer = String::new();",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    ",
          "    let _result = visitor.visit_pre(&hir_instance);",
          "    assert_eq!(visitor.wtr.as_str(), r\"(?:)\");",
          "    assert!(visitor.wtr.is_empty());",
          "    assert!(writer.is_empty());",
          "    assert!(matches!(visitor.visit_pre(&hir_instance), Ok(())));",
          "    assert!(matches!(visitor.finish(), Ok(())));",
          "    assert!(matches!(visitor.visit_post(&hir_instance), Ok(())));",
          "    assert!(cls.ranges().is_empty() == false);",
          "    assert!(self.wtr.write_str(\"(?-u:[\")?.is_err());",
          "    assert!(matches!(cls.ranges().is_empty(), false));",
          "    assert_eq!(visitor.wtr.as_str(), \"Hello\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_range = ClassUnicodeRange::new('a', 'z');",
          "    let unicode_class = ClassUnicode::new(vec![unicode_range]);",
          "    let hir_instance = Hir {",
          "        kind: HirKind::Class(hir::Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let mut writer = String::new();",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    ",
          "    let _result = visitor.visit_pre(&hir_instance);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, \"[\");",
          "    ",
          "    unicode_range = ClassBytesRange::new(0, 255);",
          "    bytes_class = ClassBytes::new(vec![unicode_range]);",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(bytes_class)),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"(?-u:[\\x00-\\xFF])\");",
          "    ",
          "    bytes_class_empty = ClassBytes::empty();",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(bytes_class_empty)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    assert!(visitor.finish().is_ok());",
          "    ",
          "    bytes_class_single = ClassBytes::new(vec![ClassBytesRange::new(100, 100)]);",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(bytes_class_single)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"d\");",
          "    ",
          "    unicode_class_empty = ClassUnicode::empty();",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(unicode_class_empty)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    assert!(visitor.finish().is_ok());",
          "    ",
          "    unicode_range_invalid = ClassUnicodeRange::new('y', 'x');",
          "    unicode_class_invalid = ClassUnicode::new(vec![unicode_range_invalid]);",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(unicode_class_invalid)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"YX\");",
          "    ",
          "    assert!(visitor.finish().is_ok());"
        ],
        "code": [
          "{",
          "    let unicode_range = ClassUnicodeRange::new('a', 'z');",
          "    let unicode_class = ClassUnicode::new(vec![unicode_range]);",
          "    let hir_instance = Hir {",
          "        kind: HirKind::Class(hir::Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let mut writer = String::new();",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    ",
          "    let _result = visitor.visit_pre(&hir_instance);",
          "    assert_eq!(writer, \"[\");",
          "    ",
          "    unicode_range = ClassBytesRange::new(0, 255);",
          "    bytes_class = ClassBytes::new(vec![unicode_range]);",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(bytes_class)),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"(?-u:[\\x00-\\xFF])\");",
          "    ",
          "    bytes_class_empty = ClassBytes::empty();",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(bytes_class_empty)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    assert!(visitor.finish().is_ok());",
          "    ",
          "    bytes_class_single = ClassBytes::new(vec![ClassBytesRange::new(100, 100)]);",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(bytes_class_single)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"d\");",
          "    ",
          "    unicode_class_empty = ClassUnicode::empty();",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(unicode_class_empty)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    assert!(visitor.finish().is_ok());",
          "    ",
          "    unicode_range_invalid = ClassUnicodeRange::new('y', 'x');",
          "    unicode_class_invalid = ClassUnicode::new(vec![unicode_range_invalid]);",
          "    hir_instance = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(unicode_class_invalid)),",
          "    props: Properties::default(),",
          "    };",
          "    assert!(visitor.visit_pre(&hir_instance).is_ok());",
          "    assert_eq!(writer, \"YX\");",
          "    ",
          "    assert!(visitor.finish().is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_range = ClassBytesRange::new(65, 90); // A-Z",
          "    let byte_class = ClassBytes::new(vec![byte_range]);",
          "    let hir_instance = Hir {",
          "        kind: HirKind::Class(hir::Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let mut writer = String::new();",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    ",
          "    let _result = visitor.visit_pre(&hir_instance);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer, \"(?-u:[A-Z])\");",
          "    assert!(writer.contains(\"(?-u:[\"));",
          "    assert!(writer.contains(\"A\"));",
          "    assert!(writer.contains(\"Z\"));",
          "    assert!(writer.starts_with(\"(?-u:\"));",
          "    assert!(writer.ends_with(\"])\"));"
        ],
        "code": [
          "{",
          "    let byte_range = ClassBytesRange::new(65, 90); // A-Z",
          "    let byte_class = ClassBytes::new(vec![byte_range]);",
          "    let hir_instance = Hir {",
          "        kind: HirKind::Class(hir::Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let mut writer = String::new();",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    ",
          "    let _result = visitor.visit_pre(&hir_instance);",
          "    assert_eq!(writer, \"(?-u:[A-Z])\");",
          "    assert!(writer.contains(\"(?-u:[\"));",
          "    assert!(writer.contains(\"A\"));",
          "    assert!(writer.contains(\"Z\"));",
          "    assert!(writer.starts_with(\"(?-u:\"));",
          "    assert!(writer.ends_with(\"])\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]