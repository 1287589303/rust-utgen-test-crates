[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter(String);",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.0.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter(String::new());",
          "",
          "    let class_byte_range_1 = ClassBytesRange::new(1, 2);",
          "    let class_byte_range_2 = ClassBytesRange::new(4, 5);",
          "    let class_bytes = ClassBytes::new(vec![class_byte_range_1, class_byte_range_2]);",
          "    let hir_literal = hir::Literal(b\"abc\");",
          "    let hir = Hir { ",
          "        kind: HirKind::Class(hir::Class::Bytes(class_bytes)), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let mut visitor = Writer { wtr: writer };",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracle": [
          "    let class_byte_range_1 = ClassBytesRange::new(1, 2);",
          "    let class_byte_range_2 = ClassBytesRange::new(4, 5);",
          "    let class_bytes = ClassBytes::new(vec![class_byte_range_1, class_byte_range_2]);",
          "    let hir_literal = hir::Literal(b\"abc\");",
          "    let hir = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(class_bytes)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir).is_ok());",
          "    ",
          "    let empty_class_bytes = ClassBytes::empty();",
          "    let hir_empty = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(empty_class_bytes)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_empty).is_ok());",
          "    ",
          "    let class_unicode_range_1 = ClassUnicodeRange::new('a', 'b');",
          "    let class_unicode = ClassUnicode::new(vec![class_unicode_range_1]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(class_unicode)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_unicode).is_ok());",
          "    ",
          "    let multiple_ranges_class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 3), ClassBytesRange::new(5, 6)]);",
          "    let hir_multiple_bytes = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(multiple_ranges_class_bytes)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_multiple_bytes).is_ok());"
        ],
        "code": [
          "{",
          "    struct MockWriter(String);",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.0.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter(String::new());",
          "",
          "    let class_byte_range_1 = ClassBytesRange::new(1, 2);",
          "    let class_byte_range_2 = ClassBytesRange::new(4, 5);",
          "    let class_bytes = ClassBytes::new(vec![class_byte_range_1, class_byte_range_2]);",
          "    let hir_literal = hir::Literal(b\"abc\");",
          "    let hir = Hir { ",
          "        kind: HirKind::Class(hir::Class::Bytes(class_bytes)), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let mut visitor = Writer { wtr: writer };",
          "    let _ = visitor.visit_pre(&hir);",
          "    let class_byte_range_1 = ClassBytesRange::new(1, 2);",
          "    let class_byte_range_2 = ClassBytesRange::new(4, 5);",
          "    let class_bytes = ClassBytes::new(vec![class_byte_range_1, class_byte_range_2]);",
          "    let hir_literal = hir::Literal(b\"abc\");",
          "    let hir = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(class_bytes)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir).is_ok());",
          "    ",
          "    let empty_class_bytes = ClassBytes::empty();",
          "    let hir_empty = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(empty_class_bytes)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_empty).is_ok());",
          "    ",
          "    let class_unicode_range_1 = ClassUnicodeRange::new('a', 'b');",
          "    let class_unicode = ClassUnicode::new(vec![class_unicode_range_1]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(class_unicode)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_unicode).is_ok());",
          "    ",
          "    let multiple_ranges_class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 3), ClassBytesRange::new(5, 6)]);",
          "    let hir_multiple_bytes = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(multiple_ranges_class_bytes)),",
          "    props: Properties::default()",
          "    };",
          "    ",
          "    assert!(visitor.visit_pre(&hir_multiple_bytes).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter(String);",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.0.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter(String::new());",
          "",
          "    let unicode_range_1 = ClassUnicodeRange::new('a', 'b');",
          "    let unicode_range_2 = ClassUnicodeRange::new('d', 'e');",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
          "    let hir_literal = hir::Literal(b\"abc\");",
          "    let hir = Hir { ",
          "        kind: HirKind::Class(hir::Class::Unicode(class_unicode)), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let mut visitor = Writer { wtr: writer };",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracle": [
          "    visitor.visit_pre(&hir);",
          "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
          "    let unicode_range_2 = ClassUnicodeRange::new('b', 'b');",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let bytes_range_1 = ClassBytesRange::new(1, 2);",
          "    let bytes_range_2 = ClassBytesRange::new(4, 5);",
          "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let empty_class = ClassBytes::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_class)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(b\"ab\")), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let bytes_range_3 = ClassBytesRange::new(3, 4);",
          "    let class_bytes = ClassBytes::new(vec![bytes_range_3]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let empty_unicode_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_unicode_class)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let single_range_unicode = ClassUnicodeRange::new('a', 'a');",
          "    let class_unicode = ClassUnicode::new(vec![single_range_unicode]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));"
        ],
        "code": [
          "{",
          "    struct MockWriter(String);",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.0.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter(String::new());",
          "",
          "    let unicode_range_1 = ClassUnicodeRange::new('a', 'b');",
          "    let unicode_range_2 = ClassUnicodeRange::new('d', 'e');",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
          "    let hir_literal = hir::Literal(b\"abc\");",
          "    let hir = Hir { ",
          "        kind: HirKind::Class(hir::Class::Unicode(class_unicode)), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let mut visitor = Writer { wtr: writer };",
          "    let _ = visitor.visit_pre(&hir);",
          "    visitor.visit_pre(&hir);",
          "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
          "    let unicode_range_2 = ClassUnicodeRange::new('b', 'b');",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let bytes_range_1 = ClassBytesRange::new(1, 2);",
          "    let bytes_range_2 = ClassBytesRange::new(4, 5);",
          "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let empty_class = ClassBytes::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_class)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(b\"ab\")), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let bytes_range_3 = ClassBytesRange::new(3, 4);",
          "    let class_bytes = ClassBytes::new(vec![bytes_range_3]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let empty_unicode_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_unicode_class)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "    let single_range_unicode = ClassUnicodeRange::new('a', 'a');",
          "    let class_unicode = ClassUnicode::new(vec![single_range_unicode]);",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), props: Properties::default() };",
          "    assert_eq!(visitor.visit_pre(&hir), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter(String);",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.0.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter(String::new());",
          "    let bytes_literal = hir::Literal(b\"hello\");",
          "    let hir = Hir { ",
          "        kind: HirKind::Literal(bytes_literal), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let mut visitor = Writer { wtr: writer };",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracle": [
          "    visitor.visit_pre(&hir).is_ok();",
          "    writer.0 == \"(?:\";",
          "    writer.0.contains(\"hello\");",
          "    writer.0.contains(\"(?-u:[\");",
          "    writer.0.ends_with(\"])\");",
          "    visitor.visit_pre(&hir).expect(\"Expected visit_pre to succeed.\");",
          "    let cls = ClassBytes::new(vec![ClassBytesRange::new(65, 90), ClassBytesRange::new(95, 122)]);",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&hir_bytes).is_ok();",
          "    writer.0.contains(\"-\");",
          "    writer.0.contains(\"65\");",
          "    writer.0.contains(\"90\");",
          "    writer.0.contains(\"95\");",
          "    writer.0.contains(\"122\");",
          "    let unicode_cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(unicode_cls)),",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&hir_unicode).is_ok();",
          "    writer.0.contains(\"[\");",
          "    writer.0.contains(\"a\");",
          "    writer.0.contains(\"z\");",
          "    writer.0.ends_with(\"]\");",
          "    let empty_cls_unicode = ClassUnicode::empty();",
          "    let hir_empty_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(empty_cls_unicode)),",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&hir_empty_unicode).is_ok();",
          "    writer.0.contains(\"[a&&b]\");",
          "    let empty_hir = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&empty_hir).is_ok();",
          "    writer.0 == \"(?:\";"
        ],
        "code": [
          "{",
          "    struct MockWriter(String);",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.0.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter(String::new());",
          "    let bytes_literal = hir::Literal(b\"hello\");",
          "    let hir = Hir { ",
          "        kind: HirKind::Literal(bytes_literal), ",
          "        props: Properties::default() ",
          "    };",
          "",
          "    let mut visitor = Writer { wtr: writer };",
          "    let _ = visitor.visit_pre(&hir);",
          "    visitor.visit_pre(&hir).is_ok();",
          "    writer.0 == \"(?:\";",
          "    writer.0.contains(\"hello\");",
          "    writer.0.contains(\"(?-u:[\");",
          "    writer.0.ends_with(\"])\");",
          "    visitor.visit_pre(&hir).expect(\"Expected visit_pre to succeed.\");",
          "    let cls = ClassBytes::new(vec![ClassBytesRange::new(65, 90), ClassBytesRange::new(95, 122)]);",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&hir_bytes).is_ok();",
          "    writer.0.contains(\"-\");",
          "    writer.0.contains(\"65\");",
          "    writer.0.contains(\"90\");",
          "    writer.0.contains(\"95\");",
          "    writer.0.contains(\"122\");",
          "    let unicode_cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(unicode_cls)),",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&hir_unicode).is_ok();",
          "    writer.0.contains(\"[\");",
          "    writer.0.contains(\"a\");",
          "    writer.0.contains(\"z\");",
          "    writer.0.ends_with(\"]\");",
          "    let empty_cls_unicode = ClassUnicode::empty();",
          "    let hir_empty_unicode = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(empty_cls_unicode)),",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&hir_empty_unicode).is_ok();",
          "    writer.0.contains(\"[a&&b]\");",
          "    let empty_hir = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default()",
          "    };",
          "    visitor.visit_pre(&empty_hir).is_ok();",
          "    writer.0 == \"(?:\";",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]