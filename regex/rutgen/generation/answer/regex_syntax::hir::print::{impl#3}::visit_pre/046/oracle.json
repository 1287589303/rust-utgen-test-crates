[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let empty_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_class)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    let empty_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_class)), props: Properties::default() };",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    let empty_bytes_class = ClassBytes::empty();",
          "    let hir_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_bytes_class)), props: Properties::default() };",
          "    assert_eq!(writer, \"(?-u:[a&&b])\");",
          "    ",
          "    let literal_bytes = b\"abc\";",
          "    let hir_literal = Hir { kind: HirKind::Literal(hir::Literal(literal_bytes.to_vec())), props: Properties::default() };",
          "    let result = wtr.visit_pre(&hir_literal);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer, \"(?:(?:a)(?:b)(?:c))\");",
          "    ",
          "    let non_empty_class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a'), ClassUnicodeRange::new('b', 'b')]);",
          "    let hir_non_empty_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(non_empty_class_unicode)), props: Properties::default() };",
          "    let result_unicode = wtr.visit_pre(&hir_non_empty_unicode);",
          "    assert!(result_unicode.is_ok());",
          "    assert_eq!(writer, \"[ab]\");",
          "    ",
          "    let non_empty_class_bytes = ClassBytes::new(vec![ClassBytesRange::new(0x61, 0x61), ClassBytesRange::new(0x62, 0x62)]);",
          "    let hir_non_empty_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(non_empty_class_bytes)), props: Properties::default() };",
          "    let result_bytes = wtr.visit_pre(&hir_non_empty_bytes);",
          "    assert!(result_bytes.is_ok());",
          "    assert_eq!(writer, \"(?-u:[ab])\");"
        ],
        "code": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let empty_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_class)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "    let empty_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_class)), props: Properties::default() };",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    let empty_bytes_class = ClassBytes::empty();",
          "    let hir_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_bytes_class)), props: Properties::default() };",
          "    assert_eq!(writer, \"(?-u:[a&&b])\");",
          "    ",
          "    let literal_bytes = b\"abc\";",
          "    let hir_literal = Hir { kind: HirKind::Literal(hir::Literal(literal_bytes.to_vec())), props: Properties::default() };",
          "    let result = wtr.visit_pre(&hir_literal);",
          "    assert!(result.is_ok());",
          "    assert_eq!(writer, \"(?:(?:a)(?:b)(?:c))\");",
          "    ",
          "    let non_empty_class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a'), ClassUnicodeRange::new('b', 'b')]);",
          "    let hir_non_empty_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(non_empty_class_unicode)), props: Properties::default() };",
          "    let result_unicode = wtr.visit_pre(&hir_non_empty_unicode);",
          "    assert!(result_unicode.is_ok());",
          "    assert_eq!(writer, \"[ab]\");",
          "    ",
          "    let non_empty_class_bytes = ClassBytes::new(vec![ClassBytesRange::new(0x61, 0x61), ClassBytesRange::new(0x62, 0x62)]);",
          "    let hir_non_empty_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(non_empty_class_bytes)), props: Properties::default() };",
          "    let result_bytes = wtr.visit_pre(&hir_non_empty_bytes);",
          "    assert!(result_bytes.is_ok());",
          "    assert_eq!(writer, \"(?-u:[ab])\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let empty_class = ClassBytes::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_class)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    wtr.visit_pre(&hir).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    let empty_unicode_class = ClassUnicode::empty();",
          "    let hir_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_unicode_class)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_unicode).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    let literal_bytes = b\"abc\";",
          "    let hir_literal = Hir { kind: HirKind::Literal(hir::Literal(literal_bytes.to_vec())), props: Properties::default() };",
          "    wtr.visit_pre(&hir_literal).unwrap();",
          "    assert_eq!(writer, \"(?:abc)\");",
          "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(97, 99)]);",
          "    let hir_cls_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(cls_bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_cls_bytes).unwrap();",
          "    assert_eq!(writer, \"(?-u:[a-c])\");"
        ],
        "code": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let empty_class = ClassBytes::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_class)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "    wtr.visit_pre(&hir).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    let empty_unicode_class = ClassUnicode::empty();",
          "    let hir_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_unicode_class)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_unicode).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    let literal_bytes = b\"abc\";",
          "    let hir_literal = Hir { kind: HirKind::Literal(hir::Literal(literal_bytes.to_vec())), props: Properties::default() };",
          "    wtr.visit_pre(&hir_literal).unwrap();",
          "    assert_eq!(writer, \"(?:abc)\");",
          "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(97, 99)]);",
          "    let hir_cls_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(cls_bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_cls_bytes).unwrap();",
          "    assert_eq!(writer, \"(?-u:[a-c])\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let bytes: [u8; 1] = [b'a'];",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(&bytes)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    wtr.visit_pre(&hir).unwrap() => assert_eq!(writer, r\"(?:)\")",
          "    ",
          "    let cls_unicode = ClassUnicode::new(vec![]);",
          "    let hir_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(cls_unicode)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_unicode).unwrap() => assert_eq!(writer, \"[a&&b]\")",
          "    ",
          "    let cls_bytes = ClassBytes::new(vec![]);",
          "    let hir_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(cls_bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_bytes).unwrap() => assert_eq!(writer, \"(?-u:[a&&b])\")",
          "    ",
          "    let bytes_literal: [u8; 1] = [b'a'];",
          "    let hir_literal = Hir { kind: HirKind::Literal(hir::Literal(&bytes_literal)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_literal).unwrap() => assert_eq!(writer, \"a\")",
          "    ",
          "    let bytes_multiple: [u8; 2] = [b'a', b'b'];",
          "    let hir_literal_multiple = Hir { kind: HirKind::Literal(hir::Literal(&bytes_multiple)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_literal_multiple).unwrap() => assert_eq!(writer, r\"(?:ab)\")",
          "    ",
          "    let empty_class_unicode = ClassUnicode::empty();",
          "    let hir_empty_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_class_unicode)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_unicode).unwrap() => assert_eq!(writer, \"[a&&b]\")",
          "    ",
          "    let empty_class_bytes = ClassBytes::empty();",
          "    let hir_empty_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_class_bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_bytes).unwrap() => assert_eq!(writer, \"(?-u:[a&&b])\")"
        ],
        "code": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let bytes: [u8; 1] = [b'a'];",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(&bytes)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "    wtr.visit_pre(&hir).unwrap() => assert_eq!(writer, r\"(?:)\")",
          "    ",
          "    let cls_unicode = ClassUnicode::new(vec![]);",
          "    let hir_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(cls_unicode)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_unicode).unwrap() => assert_eq!(writer, \"[a&&b]\")",
          "    ",
          "    let cls_bytes = ClassBytes::new(vec![]);",
          "    let hir_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(cls_bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_bytes).unwrap() => assert_eq!(writer, \"(?-u:[a&&b])\")",
          "    ",
          "    let bytes_literal: [u8; 1] = [b'a'];",
          "    let hir_literal = Hir { kind: HirKind::Literal(hir::Literal(&bytes_literal)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_literal).unwrap() => assert_eq!(writer, \"a\")",
          "    ",
          "    let bytes_multiple: [u8; 2] = [b'a', b'b'];",
          "    let hir_literal_multiple = Hir { kind: HirKind::Literal(hir::Literal(&bytes_multiple)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_literal_multiple).unwrap() => assert_eq!(writer, r\"(?:ab)\")",
          "    ",
          "    let empty_class_unicode = ClassUnicode::empty();",
          "    let hir_empty_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_class_unicode)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_unicode).unwrap() => assert_eq!(writer, \"[a&&b]\")",
          "    ",
          "    let empty_class_bytes = ClassBytes::empty();",
          "    let hir_empty_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_class_bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_bytes).unwrap() => assert_eq!(writer, \"(?-u:[a&&b])\")",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let bytes: [u8; 3] = [b'a', b'b', b'c'];",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(&bytes)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    wtr.visit_pre(&hir).unwrap();",
          "    assert_eq!(writer, \"(?:)\");",
          "    ",
          "    let empty_cls = ClassBytes::empty();",
          "    let hir_empty_class = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_cls)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_class).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    let empty_unicode_cls = ClassUnicode::empty();",
          "    let hir_empty_unicode_class = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_unicode_cls)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_unicode_class).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");"
        ],
        "code": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let bytes: [u8; 3] = [b'a', b'b', b'c'];",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(&bytes)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "    wtr.visit_pre(&hir).unwrap();",
          "    assert_eq!(writer, \"(?:)\");",
          "    ",
          "    let empty_cls = ClassBytes::empty();",
          "    let hir_empty_class = Hir { kind: HirKind::Class(hir::Class::Bytes(empty_cls)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_class).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");",
          "    ",
          "    let empty_unicode_cls = ClassUnicode::empty();",
          "    let hir_empty_unicode_class = Hir { kind: HirKind::Class(hir::Class::Unicode(empty_unicode_cls)), props: Properties::default() };",
          "    wtr.visit_pre(&hir_empty_unicode_class).unwrap();",
          "    assert_eq!(writer, \"[a&&b]\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let unicode_empty_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_empty_class)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    writer.is_empty()",
          "    writer == \"[a&&b]\"",
          "    let bytes = &[];",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir).unwrap();",
          "    writer.is_empty()",
          "    let cls = ClassBytes::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(cls)), props: Properties::default() };",
          "    wtr.visit_pre(&hir).unwrap();",
          "    writer == \"[a&&b]\""
        ],
        "code": [
          "{",
          "    let mut writer = String::new();",
          "    let mut wtr = Writer { wtr: &mut writer };",
          "    ",
          "    let unicode_empty_class = ClassUnicode::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_empty_class)), props: Properties::default() };",
          "    ",
          "    wtr.visit_pre(&hir).unwrap();",
          "    writer.is_empty()",
          "    writer == \"[a&&b]\"",
          "    let bytes = &[];",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal(bytes)), props: Properties::default() };",
          "    wtr.visit_pre(&hir).unwrap();",
          "    writer.is_empty()",
          "    let cls = ClassBytes::empty();",
          "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(cls)), props: Properties::default() };",
          "    wtr.visit_pre(&hir).unwrap();",
          "    writer == \"[a&&b]\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]