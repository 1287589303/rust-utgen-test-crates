[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { wtr: &mut output };",
          "    let bytes = b\"hello\";",
          "    let hir = Hir {",
          "        kind: HirKind::Literal(hir::Literal(bytes.to_vec())),",
          "        props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.wtr.write_str(r\"(?:)\")?;",
          "    self.wtr.write_str(\"[a&&b]\")?;",
          "    self.wtr.write_str(\"])\")?;",
          "    self.wtr.write_str(\"(?-u:[\")?;",
          "    self.wtr.write_str(\"]\")?;",
          "    self.write_literal_byte(0x68)?; // 'h'",
          "    self.write_literal_byte(0x65)?; // 'e'",
          "    self.write_literal_byte(0x6C)?; // 'l'",
          "    self.write_literal_byte(0x6C)?; // 'l'",
          "    self.write_literal_byte(0x6F)?; // 'o'",
          "    self.wtr.write_str(r\"(?m:^)\")?;",
          "    self.wtr.write_str(r\"\\z\")?;"
        ],
        "code": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { wtr: &mut output };",
          "    let bytes = b\"hello\";",
          "    let hir = Hir {",
          "        kind: HirKind::Literal(hir::Literal(bytes.to_vec())),",
          "        props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "    self.wtr.write_str(r\"(?:)\")?;",
          "    self.wtr.write_str(\"[a&&b]\")?;",
          "    self.wtr.write_str(\"])\")?;",
          "    self.wtr.write_str(\"(?-u:[\")?;",
          "    self.wtr.write_str(\"]\")?;",
          "    self.write_literal_byte(0x68)?; // 'h'",
          "    self.write_literal_byte(0x65)?; // 'e'",
          "    self.write_literal_byte(0x6C)?; // 'l'",
          "    self.write_literal_byte(0x6C)?; // 'l'",
          "    self.write_literal_byte(0x6F)?; // 'o'",
          "    self.wtr.write_str(r\"(?m:^)\")?;",
          "    self.wtr.write_str(r\"\\z\")?;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { wtr: &mut output };",
          "    let ranges = vec![ClassUnicodeRange::new('a', 'z')];",
          "    let cls = ClassUnicode::new(ranges);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Unicode(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.wtr.write_str(\"[\")?;",
          "    let ranges = vec![ClassUnicodeRange::new('a', 'z')];",
          "    let cls = ClassUnicode::new(ranges);",
          "    let hir = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(cls)),",
          "    props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "    self.wtr.write_str(\"])\")?;",
          "    self.wtr.write_str(\"(?-u:[\")?;",
          "    self.wtr.write_str(\"[\")?;",
          "    self.wtr.write_str(\"[a&&b]\")?;",
          "    self.wtr.write_str(\"(?-u:[])\")?;",
          "    self.wtr.write_str(\"(?-u:[\\x{61}-\\x{7A}])\")?;",
          "    self.wtr.write_str(\"(?-u:[])\")?;",
          "    self.wtr.write_str(\"(?-u:[\\\\x61-\\\\x7A])\")?;",
          "    self.wtr.write_str(\"(?-u:[{}])\")?;",
          "    self.wtr.write_str(\"(?-u:[a&&b])\")?;",
          "    Ok(())",
          "    self.wtr.write_str(r\"(?:)\")?;",
          "    self.wtr.write_str(\"[a-z]\")?;",
          "    self.wtr.write_str(\"(?-u:[a-z])\")?;",
          "    self.wtr.write_str(\"[\")?;"
        ],
        "code": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { wtr: &mut output };",
          "    let ranges = vec![ClassUnicodeRange::new('a', 'z')];",
          "    let cls = ClassUnicode::new(ranges);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Unicode(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "    self.wtr.write_str(\"[\")?;",
          "    let ranges = vec![ClassUnicodeRange::new('a', 'z')];",
          "    let cls = ClassUnicode::new(ranges);",
          "    let hir = Hir {",
          "    kind: HirKind::Class(hir::Class::Unicode(cls)),",
          "    props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "    self.wtr.write_str(\"])\")?;",
          "    self.wtr.write_str(\"(?-u:[\")?;",
          "    self.wtr.write_str(\"[\")?;",
          "    self.wtr.write_str(\"[a&&b]\")?;",
          "    self.wtr.write_str(\"(?-u:[])\")?;",
          "    self.wtr.write_str(\"(?-u:[\\x{61}-\\x{7A}])\")?;",
          "    self.wtr.write_str(\"(?-u:[])\")?;",
          "    self.wtr.write_str(\"(?-u:[\\\\x61-\\\\x7A])\")?;",
          "    self.wtr.write_str(\"(?-u:[{}])\")?;",
          "    self.wtr.write_str(\"(?-u:[a&&b])\")?;",
          "    Ok(())",
          "    self.wtr.write_str(r\"(?:)\")?;",
          "    self.wtr.write_str(\"[a-z]\")?;",
          "    self.wtr.write_str(\"(?-u:[a-z])\")?;",
          "    self.wtr.write_str(\"[\")?;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { wtr: &mut output };",
          "    let ranges = vec![ClassBytesRange::new(1, 5)];",
          "    let cls = ClassBytes::new(ranges);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.wtr.write_str(\"(?-u:[\")?;",
          "    self.wtr.write_str(\"])\")?;",
          "    let ranges = vec![ClassBytesRange::new(1, 5)];",
          "    cls.ranges().is_empty() is false;",
          "    range in cls.iter() is false;",
          "    *hir.kind() matches HirKind::Class(hir::Class::Bytes(ref cls));",
          "    *hir.kind() matches HirKind::Literal(hir::Literal(ref bytes));",
          "    self.wtr.write_str(r\"(?:)\")?;",
          "    Ok(())"
        ],
        "code": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { wtr: &mut output };",
          "    let ranges = vec![ClassBytesRange::new(1, 5)];",
          "    let cls = ClassBytes::new(ranges);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(hir::Class::Bytes(cls)),",
          "        props: Properties::default(),",
          "    };",
          "    writer.visit_pre(&hir).unwrap();",
          "    self.wtr.write_str(\"(?-u:[\")?;",
          "    self.wtr.write_str(\"])\")?;",
          "    let ranges = vec![ClassBytesRange::new(1, 5)];",
          "    cls.ranges().is_empty() is false;",
          "    range in cls.iter() is false;",
          "    *hir.kind() matches HirKind::Class(hir::Class::Bytes(ref cls));",
          "    *hir.kind() matches HirKind::Literal(hir::Literal(ref bytes));",
          "    self.wtr.write_str(r\"(?:)\")?;",
          "    Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]