[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"d\",",
          "    };",
          "    parser.parse_perl_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Digit, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Word, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Space, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Digit, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Space, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Word, negated: true });"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"d\",",
          "    };",
          "    parser.parse_perl_class();",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Digit, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Word, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Space, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Digit, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Space, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: ast::ClassPerlKind::Word, negated: true });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"D\",",
          "    };",
          "    parser.parse_perl_class();",
          "}"
        ],
        "oracle": [
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"d\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"D\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"s\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"S\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"w\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"W\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: true });"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"D\",",
          "    };",
          "    parser.parse_perl_class();",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"d\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"D\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"s\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"S\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"w\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"W\" }; assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: true });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"s\",",
          "    };",
          "    parser.parse_perl_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false }); // precondition: c matches 's' at line 2253 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false }); // precondition: c matches 'w' at line 2255 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: true }); // precondition: c matches 'W' at line 2256 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }); // precondition: c matches 'd' at line 2251 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }); // precondition: c matches 'D' at line 2252 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true }); // precondition: c matches 'S' at line 2254 is true"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"s\",",
          "    };",
          "    parser.parse_perl_class();",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false }); // precondition: c matches 's' at line 2253 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false }); // precondition: c matches 'w' at line 2255 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: true }); // precondition: c matches 'W' at line 2256 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }); // precondition: c matches 'd' at line 2251 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }); // precondition: c matches 'D' at line 2252 is true",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true }); // precondition: c matches 'S' at line 2254 is true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"S\",",
          "    };",
          "    parser.parse_perl_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Space, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Word, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Digit, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Digit, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Space, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Word, negated: true });"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"S\",",
          "    };",
          "    parser.parse_perl_class();",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Space, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Word, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Digit, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Digit, negated: true });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Space, negated: false });",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* expected span */, kind: ClassPerlKind::Word, negated: true });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"w\",",
          "    };",
          "    parser.parse_perl_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Word, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'D' */ }, pattern: \"D\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Digit, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'S' */ }, pattern: \"S\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Space, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'd' */ }, pattern: \"d\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Digit, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 's' */ }, pattern: \"s\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Space, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'w' */ }, pattern: \"w\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Word, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'W' */ }, pattern: \"W\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Word, negated: true });"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"w\",",
          "    };",
          "    parser.parse_perl_class();",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Word, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'D' */ }, pattern: \"D\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Digit, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'S' */ }, pattern: \"S\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Space, negated: true });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'd' */ }, pattern: \"d\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Digit, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 's' */ }, pattern: \"s\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Space, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'w' */ }, pattern: \"w\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Word, negated: false });",
          "    ",
          "    let parser = ParserI { parser: Parser { /* initialize with 'W' */ }, pattern: \"W\" };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: /* valid span */, kind: ast::ClassPerlKind::Word, negated: true });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"W\",",
          "    };",
          "    parser.parse_perl_class();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: true });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'd' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: false });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'D' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: true });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 's' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: false });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'S' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: true });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'w' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: false });"
        ],
        "code": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, empty_min_range: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
          "        pattern: \"W\",",
          "    };",
          "    parser.parse_perl_class();",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: true });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'd' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: false });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'D' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Digit, negated: true });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 's' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: false });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'S' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Space, negated: true });",
          "    ",
          "    let parser = ParserI { /* ... initialize for 'w' ... */ };",
          "    assert_eq!(parser.parse_perl_class(), ast::ClassPerl { span: parser.span_char(), kind: ast::ClassPerlKind::Word, negated: false });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]