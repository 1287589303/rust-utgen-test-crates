[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"abc123\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(0); // start at beginning",
          "    let prefix = \"abc\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos(), 3);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"abc123\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(0); // start at beginning",
          "    let prefix = \"abc\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"hello_world\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(6); // position after \"hello_\"",
          "    let prefix = \"world\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 11);",
          "    assert_eq!(parser.char.get(), None);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"hello_world\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(6); // position after \"hello_\"",
          "    let prefix = \"world\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 11);",
          "    assert_eq!(parser.char.get(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"rust_is_awesome\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(0); // start at beginning",
          "    let prefix = \"rust\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 4);",
          "    assert_eq!(parser.char.get(), Some('i'));",
          "    assert!(parser.pattern().starts_with(\"is_awesome\", parser.pos.get()));",
          "    parser.pos.set(4);",
          "    let prefix = \"i\";",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 5);",
          "    assert_eq!(parser.char.get(), Some('s'));",
          "    parser.pos.set(5);",
          "    let prefix = \"s\";",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 6);",
          "    assert_eq!(parser.char.get(), Some('_'));",
          "    parser.pos.set(6);",
          "    let prefix = \"_\";",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 7);",
          "    assert_eq!(parser.char.get(), Some('a'));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"rust_is_awesome\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(0); // start at beginning",
          "    let prefix = \"rust\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 4);",
          "    assert_eq!(parser.char.get(), Some('i'));",
          "    assert!(parser.pattern().starts_with(\"is_awesome\", parser.pos.get()));",
          "    parser.pos.set(4);",
          "    let prefix = \"i\";",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 5);",
          "    assert_eq!(parser.char.get(), Some('s'));",
          "    parser.pos.set(5);",
          "    let prefix = \"s\";",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 6);",
          "    assert_eq!(parser.char.get(), Some('_'));",
          "    parser.pos.set(6);",
          "    let prefix = \"_\";",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos.get(), 7);",
          "    assert_eq!(parser.char.get(), Some('a'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"test\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(1); // position at 'e'",
          "    let prefix = \"t\"; // prefix at least 1 character long",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos(), 2);",
          "    assert_eq!(parser.char(), 's');",
          "    assert!(parser.bump_if(\"te\"));",
          "    assert_eq!(parser.pos(), 4);",
          "    assert_eq!(parser.char(), None);",
          "    assert!(!parser.bump_if(\"test\"));",
          "    assert_eq!(parser.pos(), 4);",
          "    assert_eq!(parser.char(), None);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"test\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(1); // position at 'e'",
          "    let prefix = \"t\"; // prefix at least 1 character long",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(result, true);",
          "    assert_eq!(parser.pos(), 2);",
          "    assert_eq!(parser.char(), 's');",
          "    assert!(parser.bump_if(\"te\"));",
          "    assert_eq!(parser.pos(), 4);",
          "    assert_eq!(parser.char(), None);",
          "    assert!(!parser.bump_if(\"test\"));",
          "    assert_eq!(parser.pos(), 4);",
          "    assert_eq!(parser.char(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"aaaaabbbbb\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(0); // start at beginning",
          "    let prefix = \"aaaaa\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.pos(), 0); // Ensure initial position is 0",
          "    assert!(parser.pattern()[parser.pos()..].starts_with(prefix)); // Verify precondition for bump_if",
          "    assert_eq!(parser.bump_if(prefix), true); // Call bump_if and expect true",
          "    assert_eq!(parser.pos(), 5); // Verify parser position should be 5 after bump_if",
          "    assert!(parser.pattern()[parser.pos()..].starts_with(\"bbbbb\")); // Validate remaining pattern starts correctly after bumping",
          "    assert_eq!(parser.bump_if(\"bb\"), true); // Further validate bump_if with new prefix",
          "    assert_eq!(parser.pos(), 7); // Check position after second bump_if",
          "    assert_eq!(parser.bump_if(\"bbbb\"), false); // Call bump_if with prefix that cannot match and expect false",
          "    assert_eq!(parser.pos(), 7); // Ensure position remains unchanged after false bump_if"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"aaaaabbbbb\";",
          "    let mut parser = Parser::new(config, pattern);",
          "    ",
          "    parser.pos.set(0); // start at beginning",
          "    let prefix = \"aaaaa\";",
          "    ",
          "    let result = parser.bump_if(prefix);",
          "    assert_eq!(parser.pos(), 0); // Ensure initial position is 0",
          "    assert!(parser.pattern()[parser.pos()..].starts_with(prefix)); // Verify precondition for bump_if",
          "    assert_eq!(parser.bump_if(prefix), true); // Call bump_if and expect true",
          "    assert_eq!(parser.pos(), 5); // Verify parser position should be 5 after bump_if",
          "    assert!(parser.pattern()[parser.pos()..].starts_with(\"bbbbb\")); // Validate remaining pattern starts correctly after bumping",
          "    assert_eq!(parser.bump_if(\"bb\"), true); // Further validate bump_if with new prefix",
          "    assert_eq!(parser.pos(), 7); // Check position after second bump_if",
          "    assert_eq!(parser.bump_if(\"bbbb\"), false); // Call bump_if with prefix that cannot match and expect false",
          "    assert_eq!(parser.pos(), 7); // Ensure position remains unchanged after false bump_if",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]