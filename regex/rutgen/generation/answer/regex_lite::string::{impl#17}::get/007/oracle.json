[
  {
    "uses": [
      "use core::num::NonZeroUsize;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::num::NonZeroUsize;",
          "",
          "    struct MockCaptureLocations {",
          "        data: Vec<Option<NonMaxUsize>>,",
          "    }",
          "",
          "    impl CaptureLocations {",
          "        fn new(data: Vec<Option<NonMaxUsize>>) -> Self {",
          "            CaptureLocations(data)",
          "        }",
          "    }",
          "",
          "    let locs = MockCaptureLocations {",
          "        data: vec![",
          "            NonMaxUsize::new(1), // start for index 0",
          "            NonMaxUsize::new(18), // end for index 0",
          "            NonMaxUsize::new(7), // start for index 1",
          "            NonMaxUsize::new(18), // end for index 1",
          "        ].into_iter().collect(),",
          "    };",
          "",
          "    let result = locs.get(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Some((0, 17)), locs.get(0));",
          "    assert_eq!(Some((6, 17)), locs.get(1));",
          "    assert_eq!(None, locs.get(2));",
          "    assert_eq!(None, locs.get(3));",
          "    assert_eq!(None, locs.get(usize::MAX));",
          "    let empty_locs = MockCaptureLocations { data: vec![] };",
          "    assert_eq!(None, empty_locs.get(0));"
        ],
        "code": [
          "{",
          "    use core::num::NonZeroUsize;",
          "",
          "    struct MockCaptureLocations {",
          "        data: Vec<Option<NonMaxUsize>>,",
          "    }",
          "",
          "    impl CaptureLocations {",
          "        fn new(data: Vec<Option<NonMaxUsize>>) -> Self {",
          "            CaptureLocations(data)",
          "        }",
          "    }",
          "",
          "    let locs = MockCaptureLocations {",
          "        data: vec![",
          "            NonMaxUsize::new(1), // start for index 0",
          "            NonMaxUsize::new(18), // end for index 0",
          "            NonMaxUsize::new(7), // start for index 1",
          "            NonMaxUsize::new(18), // end for index 1",
          "        ].into_iter().collect(),",
          "    };",
          "",
          "    let result = locs.get(0);",
          "    assert_eq!(Some((0, 17)), locs.get(0));",
          "    assert_eq!(Some((6, 17)), locs.get(1));",
          "    assert_eq!(None, locs.get(2));",
          "    assert_eq!(None, locs.get(3));",
          "    assert_eq!(None, locs.get(usize::MAX));",
          "    let empty_locs = MockCaptureLocations { data: vec![] };",
          "    assert_eq!(None, empty_locs.get(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::num::NonZeroUsize;",
          "",
          "    struct MockCaptureLocations {",
          "        data: Vec<Option<NonMaxUsize>>,",
          "    }",
          "",
          "    impl CaptureLocations {",
          "        fn new(data: Vec<Option<NonMaxUsize>>) -> Self {",
          "            CaptureLocations(data)",
          "        }",
          "    }",
          "",
          "    let locs = MockCaptureLocations {",
          "        data: vec![",
          "            NonMaxUsize::new(1),",
          "            NonMaxUsize::new(18),",
          "            NonMaxUsize::new(7),",
          "            NonMaxUsize::new(18),",
          "        ].into_iter().collect(),",
          "    };",
          "",
          "    let result = locs.get(1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Some((0, 17)), locs.get(0));",
          "    assert_eq!(Some((0, 5)), locs.get(1));",
          "    assert_eq!(Some((6, 17)), locs.get(2));",
          "    assert_eq!(None, locs.get(3));"
        ],
        "code": [
          "{",
          "    use core::num::NonZeroUsize;",
          "",
          "    struct MockCaptureLocations {",
          "        data: Vec<Option<NonMaxUsize>>,",
          "    }",
          "",
          "    impl CaptureLocations {",
          "        fn new(data: Vec<Option<NonMaxUsize>>) -> Self {",
          "            CaptureLocations(data)",
          "        }",
          "    }",
          "",
          "    let locs = MockCaptureLocations {",
          "        data: vec![",
          "            NonMaxUsize::new(1),",
          "            NonMaxUsize::new(18),",
          "            NonMaxUsize::new(7),",
          "            NonMaxUsize::new(18),",
          "        ].into_iter().collect(),",
          "    };",
          "",
          "    let result = locs.get(1);",
          "    assert_eq!(Some((0, 17)), locs.get(0));",
          "    assert_eq!(Some((0, 5)), locs.get(1));",
          "    assert_eq!(Some((6, 17)), locs.get(2));",
          "    assert_eq!(None, locs.get(3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::num::NonZeroUsize;",
          "",
          "    struct MockCaptureLocations {",
          "        data: Vec<Option<NonMaxUsize>>,",
          "    }",
          "",
          "    impl CaptureLocations {",
          "        fn new(data: Vec<Option<NonMaxUsize>>) -> Self {",
          "            CaptureLocations(data)",
          "        }",
          "    }",
          "",
          "    let locs = MockCaptureLocations {",
          "        data: vec![",
          "            NonMaxUsize::new(1),",
          "            NonMaxUsize::new(18),",
          "            NonMaxUsize::new(7),",
          "            NonMaxUsize::new(18),",
          "        ].into_iter().collect(),",
          "    };",
          "",
          "    let result = locs.get(2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Some((6, 17)), locs.get(2));",
          "    assert_eq!(Some((0, 17)), locs.get(0));",
          "    assert_eq!(Some((0, 5)), locs.get(1));",
          "    assert_eq!(None, locs.get(3));",
          "    assert_eq!(None, locs.get(4));"
        ],
        "code": [
          "{",
          "    use core::num::NonZeroUsize;",
          "",
          "    struct MockCaptureLocations {",
          "        data: Vec<Option<NonMaxUsize>>,",
          "    }",
          "",
          "    impl CaptureLocations {",
          "        fn new(data: Vec<Option<NonMaxUsize>>) -> Self {",
          "            CaptureLocations(data)",
          "        }",
          "    }",
          "",
          "    let locs = MockCaptureLocations {",
          "        data: vec![",
          "            NonMaxUsize::new(1),",
          "            NonMaxUsize::new(18),",
          "            NonMaxUsize::new(7),",
          "            NonMaxUsize::new(18),",
          "        ].into_iter().collect(),",
          "    };",
          "",
          "    let result = locs.get(2);",
          "    assert_eq!(Some((6, 17)), locs.get(2));",
          "    assert_eq!(Some((0, 17)), locs.get(0));",
          "    assert_eq!(Some((0, 5)), locs.get(1));",
          "    assert_eq!(None, locs.get(3));",
          "    assert_eq!(None, locs.get(4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]