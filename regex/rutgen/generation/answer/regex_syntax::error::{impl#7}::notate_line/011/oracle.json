[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter<'e, E> {",
          "        _marker: std::marker::PhantomData<&'e E>,",
          "    }",
          "",
          "    let pattern = \"a(b+c)d\";",
          "    let line_number_width = 2;",
          "    let spans = vec![",
          "        ast::Span {",
          "            start: Position { column: 2 },",
          "            end: Position { column: 4 },",
          "        },",
          "    ];",
          "    let by_line = vec![spans];",
          "    let multi_line = vec![];",
          "",
          "    let mut test_spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    let result = test_spans.notate_line(0);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), \"  ^ \");",
          "    assert_eq!(test_spans.line_number_padding(), 4);",
          "    assert_eq!(test_spans.by_line.len(), 1);",
          "    assert_eq!(test_spans.by_line[0].len(), 1);",
          "    assert_eq!(test_spans.by_line[0][0].start.column, 2);",
          "    assert_eq!(test_spans.by_line[0][0].end.column, 4);",
          "    assert_eq!(test_spans.multi_line.len(), 0);"
        ],
        "code": [
          "{",
          "    struct TestFormatter<'e, E> {",
          "        _marker: std::marker::PhantomData<&'e E>,",
          "    }",
          "",
          "    let pattern = \"a(b+c)d\";",
          "    let line_number_width = 2;",
          "    let spans = vec![",
          "        ast::Span {",
          "            start: Position { column: 2 },",
          "            end: Position { column: 4 },",
          "        },",
          "    ];",
          "    let by_line = vec![spans];",
          "    let multi_line = vec![];",
          "",
          "    let mut test_spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    let result = test_spans.notate_line(0);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), \"  ^ \");",
          "    assert_eq!(test_spans.line_number_padding(), 4);",
          "    assert_eq!(test_spans.by_line.len(), 1);",
          "    assert_eq!(test_spans.by_line[0].len(), 1);",
          "    assert_eq!(test_spans.by_line[0][0].start.column, 2);",
          "    assert_eq!(test_spans.by_line[0][0].end.column, 4);",
          "    assert_eq!(test_spans.multi_line.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter<'e, E> {",
          "        _marker: std::marker::PhantomData<&'e E>,",
          "    }",
          "",
          "    let pattern = \"hello(world)!\";",
          "    let line_number_width = 3;",
          "    let spans = vec![",
          "        ast::Span {",
          "            start: Position { column: 6 },",
          "            end: Position { column: 11 },",
          "        },",
          "        ast::Span {",
          "            start: Position { column: 1 },",
          "            end: Position { column: 2 },",
          "        },",
          "    ];",
          "    let by_line = vec![spans];",
          "    let multi_line = vec![];",
          "",
          "    let mut test_spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    let result = test_spans.notate_line(0);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    let notes = result.unwrap();",
          "    assert_eq!(notes.len(), 8);",
          "    assert_eq!(notes.chars().nth(0).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(1).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(2).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(3).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(4).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(5).unwrap(), '^');",
          "    assert_eq!(notes.chars().nth(6).unwrap(), '^');",
          "    assert_eq!(notes.chars().nth(7).unwrap(), '^');"
        ],
        "code": [
          "{",
          "    struct TestFormatter<'e, E> {",
          "        _marker: std::marker::PhantomData<&'e E>,",
          "    }",
          "",
          "    let pattern = \"hello(world)!\";",
          "    let line_number_width = 3;",
          "    let spans = vec![",
          "        ast::Span {",
          "            start: Position { column: 6 },",
          "            end: Position { column: 11 },",
          "        },",
          "        ast::Span {",
          "            start: Position { column: 1 },",
          "            end: Position { column: 2 },",
          "        },",
          "    ];",
          "    let by_line = vec![spans];",
          "    let multi_line = vec![];",
          "",
          "    let mut test_spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    let result = test_spans.notate_line(0);",
          "    assert!(result.is_some());",
          "    let notes = result.unwrap();",
          "    assert_eq!(notes.len(), 8);",
          "    assert_eq!(notes.chars().nth(0).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(1).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(2).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(3).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(4).unwrap(), ' ');",
          "    assert_eq!(notes.chars().nth(5).unwrap(), '^');",
          "    assert_eq!(notes.chars().nth(6).unwrap(), '^');",
          "    assert_eq!(notes.chars().nth(7).unwrap(), '^');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestFormatter<'e, E> {",
          "        _marker: std::marker::PhantomData<&'e E>,",
          "    }",
          "",
          "    let pattern = \"example test\";",
          "    let line_number_width = 5;",
          "    let spans = vec![",
          "        ast::Span {",
          "            start: Position { column: 3 },",
          "            end: Position { column: 6 },",
          "        },",
          "    ];",
          "    let by_line = vec![spans];",
          "    let multi_line = vec![];",
          "",
          "    let mut test_spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    let result = test_spans.notate_line(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(\"     ^^^\".to_string()));",
          "    assert!(test_spans.line_number_padding() > 0);",
          "    assert!(!test_spans.by_line[0].is_empty());",
          "    assert!(!test_spans.by_line[0].is_empty());",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), \"     ^^^\".to_string());",
          "    assert!(result.unwrap().contains('^'));"
        ],
        "code": [
          "{",
          "    struct TestFormatter<'e, E> {",
          "        _marker: std::marker::PhantomData<&'e E>,",
          "    }",
          "",
          "    let pattern = \"example test\";",
          "    let line_number_width = 5;",
          "    let spans = vec![",
          "        ast::Span {",
          "            start: Position { column: 3 },",
          "            end: Position { column: 6 },",
          "        },",
          "    ];",
          "    let by_line = vec![spans];",
          "    let multi_line = vec![];",
          "",
          "    let mut test_spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    let result = test_spans.notate_line(0);",
          "    assert_eq!(result, Some(\"     ^^^\".to_string()));",
          "    assert!(test_spans.line_number_padding() > 0);",
          "    assert!(!test_spans.by_line[0].is_empty());",
          "    assert!(!test_spans.by_line[0].is_empty());",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), \"     ^^^\".to_string());",
          "    assert!(result.unwrap().contains('^'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]