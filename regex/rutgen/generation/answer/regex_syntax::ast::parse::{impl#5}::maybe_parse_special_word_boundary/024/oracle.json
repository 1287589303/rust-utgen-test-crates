[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"\\b{!invalid}\"; // Invalid character inside braces",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnrecognized, .. }));",
          "    ",
          "    let pattern = r\"\\b{start}\"; // Valid start boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryStart)));",
          "    ",
          "    let pattern = r\"\\b{end}\"; // Valid end boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryEnd)));",
          "    ",
          "    let pattern = r\"\\b{start-half}\"; // Valid start-half boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryStartHalf)));",
          "    ",
          "    let pattern = r\"\\b{end-half}\"; // Valid end-half boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryEndHalf)));",
          "    ",
          "    let pattern = r\"\\b{invalid}\"; // Invalid but valid escape sequence",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnrecognized, .. }));",
          "    ",
          "    let pattern = r\"\\b{start-whitespace}\"; // Valid but not recognized",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnrecognized, .. }));",
          "    ",
          "    let pattern = r\"\\b{\"; // Unclosed boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnclosed, .. }));"
        ],
        "code": [
          "{",
          "    let pattern = r\"\\b{!invalid}\"; // Invalid character inside braces",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnrecognized, .. }));",
          "    ",
          "    let pattern = r\"\\b{start}\"; // Valid start boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryStart)));",
          "    ",
          "    let pattern = r\"\\b{end}\"; // Valid end boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryEnd)));",
          "    ",
          "    let pattern = r\"\\b{start-half}\"; // Valid start-half boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryStartHalf)));",
          "    ",
          "    let pattern = r\"\\b{end-half}\"; // Valid end-half boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Ok(Some(AssertionKind::WordBoundaryEndHalf)));",
          "    ",
          "    let pattern = r\"\\b{invalid}\"; // Invalid but valid escape sequence",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnrecognized, .. }));",
          "    ",
          "    let pattern = r\"\\b{start-whitespace}\"; // Valid but not recognized",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnrecognized, .. }));",
          "    ",
          "    let pattern = r\"\\b{\"; // Unclosed boundary",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "    parser: Parser { /* initialize fields */ },",
          "    pattern,",
          "    };",
          "    let _result = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_result, Err(Error { kind: ErrorKind::SpecialWordBoundaryUnclosed, .. }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"\\b{    }\"; // Only whitespace within braces",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_?.is_none(), true);",
          "    assert_eq!(self.pos().offset, 0);",
          "    assert_eq!(self.pos().line, 1);",
          "    assert_eq!(self.pos().column, 1);",
          "    assert!(self.is_eof());",
          "    assert_eq!(self.char(), '}');",
          "    assert_eq!(self.parser().scratch.borrow().len(), 0);"
        ],
        "code": [
          "{",
          "    let pattern = r\"\\b{    }\"; // Only whitespace within braces",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_?.is_none(), true);",
          "    assert_eq!(self.pos().offset, 0);",
          "    assert_eq!(self.pos().line, 1);",
          "    assert_eq!(self.pos().column, 1);",
          "    assert!(self.is_eof());",
          "    assert_eq!(self.char(), '}');",
          "    assert_eq!(self.parser().scratch.borrow().len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"\\b{start\"; // Missing closing brace",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.maybe_parse_special_word_boundary(wb_start).unwrap_err().kind, ast::ErrorKind::SpecialWordBoundaryUnclosed);"
        ],
        "code": [
          "{",
          "    let pattern = r\"\\b{start\"; // Missing closing brace",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(parser.maybe_parse_special_word_boundary(wb_start).unwrap_err().kind, ast::ErrorKind::SpecialWordBoundaryUnclosed);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"\\b{start}\"; // Valid input",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), Some(ast::AssertionKind::WordBoundaryStart));"
        ],
        "code": [
          "{",
          "    let pattern = r\"\\b{start}\"; // Valid input",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), Some(ast::AssertionKind::WordBoundaryStart));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"\\b{not-valid}\"; // Invalid keyword in braces",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_is_err, true);",
          "    assert_matches!(_error.kind, ast::ErrorKind::SpecialWordBoundaryUnrecognized);",
          "    assert_eq!(_error.pattern, r\"\\b{not-valid}\");",
          "    assert_eq!(_error.span.start, Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(_error.span.end, Position { offset: 10, line: 1, column: 11 });"
        ],
        "code": [
          "{",
          "    let pattern = r\"\\b{not-valid}\"; // Invalid keyword in braces",
          "    let wb_start = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize fields */ },",
          "        pattern,",
          "    };",
          "    let _ = parser.maybe_parse_special_word_boundary(wb_start);",
          "    assert_eq!(_is_err, true);",
          "    assert_matches!(_error.kind, ast::ErrorKind::SpecialWordBoundaryUnrecognized);",
          "    assert_eq!(_error.pattern, r\"\\b{not-valid}\");",
          "    assert_eq!(_error.span.start, Position { offset: 0, line: 1, column: 1 });",
          "    assert_eq!(_error.span.end, Position { offset: 10, line: 1, column: 11 });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]