[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::Start.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::Start.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::End.as_repr() };",
          "    let result = look_set.contains(Look::End);",
          "}"
        ],
        "oracle": [
          "    let look_set = LookSet { bits: Look::End.as_repr() };",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::End.as_repr() };",
          "    let result = look_set.contains(Look::End);",
          "    let look_set = LookSet { bits: Look::End.as_repr() };",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::StartLF.as_repr() };",
          "    let result = look_set.contains(Look::StartLF);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::StartLF);",
          "    assert_eq!(result_empty, false);",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::StartLF);",
          "    assert_eq!(result_full, true);",
          "    let result_not_contained = look_set.contains(Look::End);",
          "    assert_eq!(result_not_contained, false);",
          "    let look_set_singleton = LookSet::singleton(Look::EndLF);",
          "    let result_singleton = look_set_singleton.contains(Look::EndLF);",
          "    assert_eq!(result_singleton, true);",
          "    let result_singleton_not = look_set_singleton.contains(Look::StartLF);",
          "    assert_eq!(result_singleton_not, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::StartLF.as_repr() };",
          "    let result = look_set.contains(Look::StartLF);",
          "    assert_eq!(result, true);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::StartLF);",
          "    assert_eq!(result_empty, false);",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::StartLF);",
          "    assert_eq!(result_full, true);",
          "    let result_not_contained = look_set.contains(Look::End);",
          "    assert_eq!(result_not_contained, false);",
          "    let look_set_singleton = LookSet::singleton(Look::EndLF);",
          "    let result_singleton = look_set_singleton.contains(Look::EndLF);",
          "    assert_eq!(result_singleton, true);",
          "    let result_singleton_not = look_set_singleton.contains(Look::StartLF);",
          "    assert_eq!(result_singleton_not, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::EndLF.as_repr() };",
          "    let result = look_set.contains(Look::EndLF);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::EndLF);",
          "    assert_eq!(result_empty, false);",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::EndLF);",
          "    assert_eq!(result_full, true);",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::WordAscii.as_repr() };",
          "    let result_partial = look_set_partial.contains(Look::EndLF);",
          "    assert_eq!(result_partial, false);",
          "    let look_set_mixed = LookSet { bits: Look::Start.as_repr() | Look::EndLF.as_repr() };",
          "    let result_mixed = look_set_mixed.contains(Look::EndLF);",
          "    assert_eq!(result_mixed, true);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::EndLF.as_repr() };",
          "    let result = look_set.contains(Look::EndLF);",
          "    assert_eq!(result, true);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::EndLF);",
          "    assert_eq!(result_empty, false);",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::EndLF);",
          "    assert_eq!(result_full, true);",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::WordAscii.as_repr() };",
          "    let result_partial = look_set_partial.contains(Look::EndLF);",
          "    assert_eq!(result_partial, false);",
          "    let look_set_mixed = LookSet { bits: Look::Start.as_repr() | Look::EndLF.as_repr() };",
          "    let result_mixed = look_set_mixed.contains(Look::EndLF);",
          "    assert_eq!(result_mixed, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::StartCRLF.as_repr() };",
          "    let result = look_set.contains(Look::StartCRLF);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::StartCRLF);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: !0 };",
          "    let result_full = look_set_full.contains(Look::End);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_partial_start = look_set_partial.contains(Look::Start);",
          "    assert_eq!(result_partial_start, true);",
          "    let result_partial_end = look_set_partial.contains(Look::EndLF);",
          "    assert_eq!(result_partial_end, false);",
          "    ",
          "    let look_set_singleton = LookSet::singleton(Look::WordAscii);",
          "    let result_singleton = look_set_singleton.contains(Look::WordAscii);",
          "    assert_eq!(result_singleton, true);",
          "    ",
          "    let look_set_reversed = LookSet { bits: Look::WordAscii.as_repr() | Look::WordAsciiNegate.as_repr() };",
          "    let result_reversed = look_set_reversed.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result_reversed, true);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::StartCRLF.as_repr() };",
          "    let result = look_set.contains(Look::StartCRLF);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::StartCRLF);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: !0 };",
          "    let result_full = look_set_full.contains(Look::End);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_partial_start = look_set_partial.contains(Look::Start);",
          "    assert_eq!(result_partial_start, true);",
          "    let result_partial_end = look_set_partial.contains(Look::EndLF);",
          "    assert_eq!(result_partial_end, false);",
          "    ",
          "    let look_set_singleton = LookSet::singleton(Look::WordAscii);",
          "    let result_singleton = look_set_singleton.contains(Look::WordAscii);",
          "    assert_eq!(result_singleton, true);",
          "    ",
          "    let look_set_reversed = LookSet { bits: Look::WordAscii.as_repr() | Look::WordAsciiNegate.as_repr() };",
          "    let result_reversed = look_set_reversed.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result_reversed, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::EndCRLF.as_repr() };",
          "    let result = look_set.contains(Look::EndCRLF);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::EndCRLF);",
          "    assert_eq!(result_empty, false);",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::Start);",
          "    assert_eq!(result_full, true);",
          "    let result_word_ascii = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result_word_ascii, false);",
          "    let look_set_single = LookSet::singleton(Look::WordUnicode);",
          "    let result_single = look_set_single.contains(Look::WordUnicode);",
          "    assert_eq!(result_single, true);",
          "    let result_not_in_set = look_set_single.contains(Look::End);",
          "    assert_eq!(result_not_in_set, false);",
          "    let look_set_multiple = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_multiple_start = look_set_multiple.contains(Look::Start);",
          "    assert_eq!(result_multiple_start, true);",
          "    let result_multiple_end = look_set_multiple.contains(Look::End);",
          "    assert_eq!(result_multiple_end, true);",
          "    let result_multiple_word = look_set_multiple.contains(Look::WordStartAscii);",
          "    assert_eq!(result_multiple_word, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::EndCRLF.as_repr() };",
          "    let result = look_set.contains(Look::EndCRLF);",
          "    assert_eq!(result, true);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::EndCRLF);",
          "    assert_eq!(result_empty, false);",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::Start);",
          "    assert_eq!(result_full, true);",
          "    let result_word_ascii = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result_word_ascii, false);",
          "    let look_set_single = LookSet::singleton(Look::WordUnicode);",
          "    let result_single = look_set_single.contains(Look::WordUnicode);",
          "    assert_eq!(result_single, true);",
          "    let result_not_in_set = look_set_single.contains(Look::End);",
          "    assert_eq!(result_not_in_set, false);",
          "    let look_set_multiple = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_multiple_start = look_set_multiple.contains(Look::Start);",
          "    assert_eq!(result_multiple_start, true);",
          "    let result_multiple_end = look_set_multiple.contains(Look::End);",
          "    assert_eq!(result_multiple_end, true);",
          "    let result_multiple_word = look_set_multiple.contains(Look::WordStartAscii);",
          "    assert_eq!(result_multiple_word, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    assert_eq!(look_set.contains(Look::WordUnicode), false);",
          "    assert_eq!(look_set.contains(Look::Start), false);",
          "    assert_eq!(look_set.contains(Look::End), false);",
          "    assert_eq!(look_set.contains(Look::WordAsciiNegate), false);",
          "    assert_eq!(look_set.contains(Look::WordEndAscii), false);",
          "    assert_eq!(look_set.contains(Look::WordStartAscii), true);",
          "    assert_eq!(look_set.contains(Look::WordEndHalfAscii), false);",
          "    assert_eq!(look_set.contains(Look::WordStartHalfAscii), true);",
          "    look_set.bits = Look::Start.as_repr() | Look::End.as_repr();",
          "    result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    assert_eq!(look_set.contains(Look::WordUnicode), false);",
          "    assert_eq!(look_set.contains(Look::Start), false);",
          "    assert_eq!(look_set.contains(Look::End), false);",
          "    assert_eq!(look_set.contains(Look::WordAsciiNegate), false);",
          "    assert_eq!(look_set.contains(Look::WordEndAscii), false);",
          "    assert_eq!(look_set.contains(Look::WordStartAscii), true);",
          "    assert_eq!(look_set.contains(Look::WordEndHalfAscii), false);",
          "    assert_eq!(look_set.contains(Look::WordStartHalfAscii), true);",
          "    look_set.bits = Look::Start.as_repr() | Look::End.as_repr();",
          "    result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordAsciiNegate.as_repr() };",
          "    let result = look_set.contains(Look::WordAsciiNegate);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::Start);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_partial_start = look_set_partial.contains(Look::Start);",
          "    assert_eq!(result_partial_start, true);",
          "    let result_partial_end = look_set_partial.contains(Look::End);",
          "    assert_eq!(result_partial_end, true);",
          "    let result_partial_word_ascii_negate = look_set_partial.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result_partial_word_ascii_negate, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordAsciiNegate.as_repr() };",
          "    let result = look_set.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::Start);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_partial_start = look_set_partial.contains(Look::Start);",
          "    assert_eq!(result_partial_start, true);",
          "    let result_partial_end = look_set_partial.contains(Look::End);",
          "    assert_eq!(result_partial_end, true);",
          "    let result_partial_word_ascii_negate = look_set_partial.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result_partial_word_ascii_negate, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicode);",
          "}"
        ],
        "oracle": [
          "    let look_set = LookSet { bits: Look::WordUnicode.as_repr() };",
          "    assert_eq!(look_set.contains(Look::WordUnicode), true);",
          "    assert_eq!(look_set.contains(Look::WordAscii), false);",
          "    assert_eq!(look_set.contains(Look::Start), false);",
          "    assert_eq!(look_set.contains(Look::End), false);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    assert_eq!(look_set_empty.contains(Look::WordUnicode), false);",
          "    assert_eq!(look_set_empty.contains(Look::WordAscii), false);",
          "    assert_eq!(look_set_empty.contains(Look::Start), false);",
          "    assert_eq!(look_set_empty.contains(Look::End), false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    let look_set = LookSet { bits: Look::WordUnicode.as_repr() };",
          "    assert_eq!(look_set.contains(Look::WordUnicode), true);",
          "    assert_eq!(look_set.contains(Look::WordAscii), false);",
          "    assert_eq!(look_set.contains(Look::Start), false);",
          "    assert_eq!(look_set.contains(Look::End), false);",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    assert_eq!(look_set_empty.contains(Look::WordUnicode), false);",
          "    assert_eq!(look_set_empty.contains(Look::WordAscii), false);",
          "    assert_eq!(look_set_empty.contains(Look::Start), false);",
          "    assert_eq!(look_set_empty.contains(Look::End), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordUnicodeNegate.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicodeNegate);",
          "}"
        ],
        "oracle": [
          "    assert!(result);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordUnicodeNegate.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicodeNegate);",
          "    assert!(result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordStartAscii);",
          "}"
        ],
        "oracle": [
          "    assert!(result);",
          "    assert!(!look_set.contains(Look::WordEndAscii));",
          "    let look_set_full = LookSet { bits: 0xFFFF };",
          "    assert!(look_set_full.contains(Look::WordStartAscii));",
          "    assert!(look_set_full.contains(Look::WordEndAscii));",
          "    assert!(look_set_full.contains(Look::Start));",
          "    let look_set_empty = LookSet::empty();",
          "    assert!(!look_set_empty.contains(Look::WordStartAscii));",
          "    assert!(!look_set_empty.contains(Look::End));",
          "    assert!(look_set_empty.is_empty());",
          "    assert_eq!(look_set.len(), 1);",
          "    assert!(look_set.contains(Look::WordStartAscii));",
          "    let look_set_single = LookSet::singleton(Look::End);",
          "    assert!(look_set_single.contains(Look::End));",
          "    assert!(!look_set_single.contains(Look::Start));"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordStartAscii);",
          "    assert!(result);",
          "    assert!(!look_set.contains(Look::WordEndAscii));",
          "    let look_set_full = LookSet { bits: 0xFFFF };",
          "    assert!(look_set_full.contains(Look::WordStartAscii));",
          "    assert!(look_set_full.contains(Look::WordEndAscii));",
          "    assert!(look_set_full.contains(Look::Start));",
          "    let look_set_empty = LookSet::empty();",
          "    assert!(!look_set_empty.contains(Look::WordStartAscii));",
          "    assert!(!look_set_empty.contains(Look::End));",
          "    assert!(look_set_empty.is_empty());",
          "    assert_eq!(look_set.len(), 1);",
          "    assert!(look_set.contains(Look::WordStartAscii));",
          "    let look_set_single = LookSet::singleton(Look::End);",
          "    assert!(look_set_single.contains(Look::End));",
          "    assert!(!look_set_single.contains(Look::Start));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordEndAscii);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::WordEndAscii);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::WordAscii);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_partial_start = look_set_partial.contains(Look::Start);",
          "    assert_eq!(result_partial_start, true);",
          "    let result_partial_word_end = look_set_partial.contains(Look::WordEndAscii);",
          "    assert_eq!(result_partial_word_end, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordEndAscii);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::WordEndAscii);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: u32::MAX };",
          "    let result_full = look_set_full.contains(Look::WordAscii);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result_partial_start = look_set_partial.contains(Look::Start);",
          "    assert_eq!(result_partial_start, true);",
          "    let result_partial_word_end = look_set_partial.contains(Look::WordEndAscii);",
          "    assert_eq!(result_partial_word_end, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordStartUnicode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result_neg = look_set.contains(Look::WordStartUnicode);",
          "    assert_eq!(result_neg, false);",
          "    let look_set_full = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    assert!(look_set_full.contains(Look::Start));",
          "    assert!(look_set_full.contains(Look::End));",
          "    assert!(!look_set_full.contains(Look::WordStartUnicode));",
          "    let look_set_combined = LookSet { bits: Look::Start.as_repr() | Look::WordStartUnicode.as_repr() };",
          "    assert!(look_set_combined.contains(Look::WordStartUnicode));",
          "    let look_set_word_boundary = LookSet { bits: Look::WordAscii.as_repr() | Look::WordUnicode.as_repr() };",
          "    assert!(look_set_word_boundary.contains(Look::WordAscii));",
          "    assert!(look_set_word_boundary.contains(Look::WordUnicode));",
          "    assert!(!look_set_word_boundary.contains(Look::WordAsciiNegate));",
          "    let look_set_empty = LookSet::empty();",
          "    assert!(look_set_empty.is_empty());",
          "    assert!(!look_set_empty.contains(Look::Start));"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordStartUnicode);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result_neg = look_set.contains(Look::WordStartUnicode);",
          "    assert_eq!(result_neg, false);",
          "    let look_set_full = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    assert!(look_set_full.contains(Look::Start));",
          "    assert!(look_set_full.contains(Look::End));",
          "    assert!(!look_set_full.contains(Look::WordStartUnicode));",
          "    let look_set_combined = LookSet { bits: Look::Start.as_repr() | Look::WordStartUnicode.as_repr() };",
          "    assert!(look_set_combined.contains(Look::WordStartUnicode));",
          "    let look_set_word_boundary = LookSet { bits: Look::WordAscii.as_repr() | Look::WordUnicode.as_repr() };",
          "    assert!(look_set_word_boundary.contains(Look::WordAscii));",
          "    assert!(look_set_word_boundary.contains(Look::WordUnicode));",
          "    assert!(!look_set_word_boundary.contains(Look::WordAsciiNegate));",
          "    let look_set_empty = LookSet::empty();",
          "    assert!(look_set_empty.is_empty());",
          "    assert!(!look_set_empty.contains(Look::Start));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "}"
        ],
        "oracle": [
          "    let look_set = LookSet { bits: Look::WordEndUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "    let look_set = LookSet { bits: Look::WordEndUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordEndUnicode);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartHalfAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordStartHalfAscii);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::WordStartHalfAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordStartHalfAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() | Look::WordUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, true);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartHalfAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordStartHalfAscii);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::WordStartHalfAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordStartHalfAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: Look::WordAscii.as_repr() | Look::WordUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, true);",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndHalfAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordEndHalfAscii);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::WordEndHalfAscii);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::StartLF.as_repr() | Look::WordStartAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordStartAscii);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::StartLF);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: Look::WordUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndHalfAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordEndHalfAscii);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::WordEndHalfAscii);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::Start.as_repr() | Look::End.as_repr() };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);",
          "    ",
          "    let look_set = LookSet { bits: Look::StartLF.as_repr() | Look::WordStartAscii.as_repr() };",
          "    let result = look_set.contains(Look::WordStartAscii);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::StartLF);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set = LookSet { bits: Look::WordUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordUnicode);",
          "    assert_eq!(result, true);",
          "    ",
          "    let result = look_set.contains(Look::WordAsciiNegate);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartHalfUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordStartHalfUnicode);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::WordStartHalfUnicode);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: !0 };",
          "    let result_full = look_set_full.contains(Look::Start);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::WordEndAscii.as_repr() | Look::Start.as_repr() };",
          "    let result_partial = look_set_partial.contains(Look::WordEndAscii);",
          "    assert_eq!(result_partial, true);",
          "    ",
          "    let result_not_in_set = look_set_partial.contains(Look::WordStartAscii);",
          "    assert_eq!(result_not_in_set, false);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordStartHalfUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordStartHalfUnicode);",
          "    assert_eq!(result, true);",
          "    ",
          "    let look_set_empty = LookSet { bits: 0 };",
          "    let result_empty = look_set_empty.contains(Look::WordStartHalfUnicode);",
          "    assert_eq!(result_empty, false);",
          "    ",
          "    let look_set_full = LookSet { bits: !0 };",
          "    let result_full = look_set_full.contains(Look::Start);",
          "    assert_eq!(result_full, true);",
          "    ",
          "    let look_set_partial = LookSet { bits: Look::WordEndAscii.as_repr() | Look::Start.as_repr() };",
          "    let result_partial = look_set_partial.contains(Look::WordEndAscii);",
          "    assert_eq!(result_partial, true);",
          "    ",
          "    let result_not_in_set = look_set_partial.contains(Look::WordStartAscii);",
          "    assert_eq!(result_not_in_set, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndHalfUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordEndHalfUnicode);",
          "}"
        ],
        "oracle": [
          "    assert!(result);",
          "    assert_eq!(look_set.len(), 1);",
          "    assert!(!look_set.is_empty());",
          "    assert!(look_set.contains(Look::WordEndHalfUnicode));",
          "    assert!(!look_set.contains(Look::Start));"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: Look::WordEndHalfUnicode.as_repr() };",
          "    let result = look_set.contains(Look::WordEndHalfUnicode);",
          "    assert!(result);",
          "    assert_eq!(look_set.len(), 1);",
          "    assert!(!look_set.is_empty());",
          "    assert!(look_set.contains(Look::WordEndHalfUnicode));",
          "    assert!(!look_set.contains(Look::Start));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::Start);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 1 }; // Contains Look::Start",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 2 }; // Contains Look::End",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 3 }; // Contains Look::Start and Look::End",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 16 }; // Contains Look::WordStartHalfUnicode",
          "    let result = look_set.contains(Look::WordStartHalfUnicode);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0b101010}; // Contains multiple Look enums",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 0xFFFF }; // All bits set",
          "    let result = look_set.contains(Look::WordEndHalfAscii);",
          "    assert_eq!(result, true);"
        ],
        "code": [
          "{",
          "    let look_set = LookSet { bits: 0 };",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 1 }; // Contains Look::Start",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 2 }; // Contains Look::End",
          "    let result = look_set.contains(Look::Start);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 3 }; // Contains Look::Start and Look::End",
          "    let result = look_set.contains(Look::End);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 16 }; // Contains Look::WordStartHalfUnicode",
          "    let result = look_set.contains(Look::WordStartHalfUnicode);",
          "    assert_eq!(result, true);",
          "    let look_set = LookSet { bits: 0b101010}; // Contains multiple Look enums",
          "    let result = look_set.contains(Look::WordAscii);",
          "    assert_eq!(result, false);",
          "    let look_set = LookSet { bits: 0xFFFF }; // All bits set",
          "    let result = look_set.contains(Look::WordEndHalfAscii);",
          "    assert_eq!(result, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]