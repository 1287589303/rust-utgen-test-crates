[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'z' as u32 }]));",
          "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(unicode_class.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(byte_class.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]))));",
          "    let hirs = vec![];",
          "    assert_eq!(class_bytes(&hirs), None);",
          "    let unicode_class_empty = Class::Unicode(ClassUnicode::empty());",
          "    let byte_class_empty = Class::Bytes(ClassBytes::empty());",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class_empty), props: Properties::default() },",
          "    Hir { kind: HirKind::Class(byte_class_empty), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::empty())));",
          "    let unicode_class_empty = Class::Unicode(ClassUnicode::new(vec![]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class_empty), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), None);",
          "    let unicode_class_large = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'A' as u32, end: 'Z' as u32 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class_large), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]))));",
          "    let byte_class_non_ascii = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 128, end: 255 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(byte_class_non_ascii), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 128, end: 255 }]))));",
          "    let invalid_hir = Hir { kind: HirKind::Empty, props: Properties::default() };",
          "    let hirs = vec![invalid_hir];",
          "    assert_eq!(class_bytes(&hirs), None);"
        ],
        "code": [
          "{",
          "    let unicode_class = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'z' as u32 }]));",
          "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(unicode_class.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(byte_class.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]))));",
          "    let hirs = vec![];",
          "    assert_eq!(class_bytes(&hirs), None);",
          "    let unicode_class_empty = Class::Unicode(ClassUnicode::empty());",
          "    let byte_class_empty = Class::Bytes(ClassBytes::empty());",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class_empty), props: Properties::default() },",
          "    Hir { kind: HirKind::Class(byte_class_empty), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::empty())));",
          "    let unicode_class_empty = Class::Unicode(ClassUnicode::new(vec![]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class_empty), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), None);",
          "    let unicode_class_large = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'A' as u32, end: 'Z' as u32 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class_large), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]))));",
          "    let byte_class_non_ascii = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 128, end: 255 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(byte_class_non_ascii), props: Properties::default() },",
          "    ];",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 128, end: 255 }]))));",
          "    let invalid_hir = Hir { kind: HirKind::Empty, props: Properties::default() };",
          "    let hirs = vec![invalid_hir];",
          "    assert_eq!(class_bytes(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class1 = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'A' as u32, end: 'Z' as u32 }]));",
          "    let unicode_class2 = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'z' as u32 }]));",
          "    let byte_class1 = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 63 }]));",
          "    let byte_class2 = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 64, end: 127 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(unicode_class1.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(unicode_class2.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(byte_class1.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(byte_class2.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]))));",
          "    assert!(matches!(_result, Some(Class::Bytes(_))));",
          "    assert!(matches!(_result, Some(Class::Bytes(ref cls)) if cls.ranges().len() == 1));",
          "    assert!(matches!(_result, Some(Class::Bytes(ref cls)) if cls.ranges()[0] == ClassBytesRange { start: 0, end: 127 }));"
        ],
        "code": [
          "{",
          "    let unicode_class1 = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'A' as u32, end: 'Z' as u32 }]));",
          "    let unicode_class2 = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'z' as u32 }]));",
          "    let byte_class1 = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 63 }]));",
          "    let byte_class2 = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 64, end: 127 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(unicode_class1.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(unicode_class2.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(byte_class1.clone()), props: Properties::default() },",
          "        Hir { kind: HirKind::Class(byte_class2.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "    assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]))));",
          "    assert!(matches!(_result, Some(Class::Bytes(_))));",
          "    assert!(matches!(_result, Some(Class::Bytes(ref cls)) if cls.ranges().len() == 1));",
          "    assert!(matches!(_result, Some(Class::Bytes(ref cls)) if cls.ranges()[0] == ClassBytesRange { start: 0, end: 127 }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: '0' as u32, end: '9' as u32 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(unicode_class.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    let unicode_class = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: '0' as u32, end: '9' as u32 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class.clone()), props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&hirs);",
          "    assert_eq!(result, Some(Class::Bytes(ClassBytes::new(vec![]))));",
          "    ",
          "    let bytes_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(bytes_class.clone()), props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&hirs);",
          "    assert_eq!(result, Some(Class::Bytes(bytes_class)));",
          "    ",
          "    let mixed_class = vec![",
          "    Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'z' as u32 }])), props: Properties::default() },",
          "    Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 65, end: 90 }])), props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&mixed_class);",
          "    assert!(result.is_some());",
          "    ",
          "    let empty_class = vec![];",
          "    let result = class_bytes(&empty_class);",
          "    assert_eq!(result, Some(Class::Bytes(ClassBytes::new(vec![]))));",
          "    ",
          "    let invalid_class = vec![",
          "    Hir { kind: HirKind::Empty, props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&invalid_class);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let unicode_class = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: '0' as u32, end: '9' as u32 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(unicode_class.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "    let unicode_class = Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: '0' as u32, end: '9' as u32 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(unicode_class.clone()), props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&hirs);",
          "    assert_eq!(result, Some(Class::Bytes(ClassBytes::new(vec![]))));",
          "    ",
          "    let bytes_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]));",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Class(bytes_class.clone()), props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&hirs);",
          "    assert_eq!(result, Some(Class::Bytes(bytes_class)));",
          "    ",
          "    let mixed_class = vec![",
          "    Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'z' as u32 }])), props: Properties::default() },",
          "    Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 65, end: 90 }])), props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&mixed_class);",
          "    assert!(result.is_some());",
          "    ",
          "    let empty_class = vec![];",
          "    let result = class_bytes(&empty_class);",
          "    assert_eq!(result, Some(Class::Bytes(ClassBytes::new(vec![]))));",
          "    ",
          "    let invalid_class = vec![",
          "    Hir { kind: HirKind::Empty, props: Properties::default() },",
          "    ];",
          "    let result = class_bytes(&invalid_class);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 200, end: 255 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(byte_class.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 200, end: 255 }]))));"
        ],
        "code": [
          "{",
          "    let byte_class = Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 200, end: 255 }]));",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Class(byte_class.clone()), props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "    assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 200, end: 255 }]))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Empty, props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new(0x0000, 0x007F)]))), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0x7F }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }])), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }])), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new(0x61, 0x7A)]))), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x7A }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0xFF }])), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0xFF }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::empty()), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, None);"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Empty, props: Properties::default() },",
          "    ];",
          "    let _result = class_bytes(&hirs);",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new(0x0000, 0x007F)]))), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0x7F }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }])), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }])), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new(0x61, 0x7A)]))), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x7A }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0xFF }])), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0xFF }]))));",
          "    let hirs = vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::empty()), props: Properties::default() }]; let _result = class_bytes(&hirs); assert_eq!(_result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]