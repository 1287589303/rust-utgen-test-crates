[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class_empty = ClassUnicode::empty();",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class_empty)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_unicode];",
          "",
          "    let result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let unicode_class_empty = ClassUnicode::empty();",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class_empty)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_unicode];",
          "",
          "    let result = class_bytes(&hirs);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_range = ClassBytesRange { start: 0x41, end: 0x5A }; // A-Z",
          "    let cls_bytes = ClassBytes::new(vec![byte_range]);",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_bytes];",
          "",
          "    let result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]))));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Bytes(_))));",
          "    assert!(matches!(result.unwrap(), Class::Bytes(ref bytes_class) if bytes_class.ranges() == &[ClassBytesRange { start: 0x41, end: 0x5A }]));",
          "    assert!(result.unwrap().minimum_len().is_none());",
          "    assert!(result.unwrap().maximum_len().is_none());"
        ],
        "code": [
          "{",
          "    let byte_range = ClassBytesRange { start: 0x41, end: 0x5A }; // A-Z",
          "    let cls_bytes = ClassBytes::new(vec![byte_range]);",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_bytes];",
          "",
          "    let result = class_bytes(&hirs);",
          "    assert_eq!(result, Some(Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]))));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Bytes(_))));",
          "    assert!(matches!(result.unwrap(), Class::Bytes(ref bytes_class) if bytes_class.ranges() == &[ClassBytesRange { start: 0x41, end: 0x5A }]));",
          "    assert!(result.unwrap().minimum_len().is_none());",
          "    assert!(result.unwrap().maximum_len().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class_ascii = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x41', end: '\\x5A' }]); // A-Z",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class_ascii)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let byte_range = ClassBytesRange { start: 0x41, end: 0x5A }; // A-Z",
          "    let cls_bytes = ClassBytes::new(vec![byte_range]);",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_unicode, hir_bytes];",
          "",
          "    let result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    match result.unwrap() {",
          "    Class::Bytes(ref cls) => {",
          "    assert_eq!(cls.ranges().len(), 1);",
          "    assert_eq!(cls.ranges()[0].start, 0x41);",
          "    assert_eq!(cls.ranges()[0].end, 0x5A);",
          "    },",
          "    _ => panic!(\"Expected Class::Bytes\"),",
          "    }"
        ],
        "code": [
          "{",
          "    let unicode_class_ascii = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x41', end: '\\x5A' }]); // A-Z",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class_ascii)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let byte_range = ClassBytesRange { start: 0x41, end: 0x5A }; // A-Z",
          "    let cls_bytes = ClassBytes::new(vec![byte_range]);",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_unicode, hir_bytes];",
          "",
          "    let result = class_bytes(&hirs);",
          "    assert!(result.is_some());",
          "    match result.unwrap() {",
          "    Class::Bytes(ref cls) => {",
          "    assert_eq!(cls.ranges().len(), 1);",
          "    assert_eq!(cls.ranges()[0].start, 0x41);",
          "    assert_eq!(cls.ranges()[0].end, 0x5A);",
          "    },",
          "    _ => panic!(\"Expected Class::Bytes\"),",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class_non_ascii = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\u{0400}', end: '\\u{04FF}' }]); // Cyrillic",
          "    let hir_non_ascii = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class_non_ascii)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_non_ascii];",
          "",
          "    let result = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let unicode_class_non_ascii = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\u{0400}', end: '\\u{04FF}' }]); // Cyrillic",
          "    let hir_non_ascii = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class_non_ascii)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs: Vec<Hir> = vec![hir_non_ascii];",
          "",
          "    let result = class_bytes(&hirs);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]