[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs: Vec<Hir> = vec![];",
          "    let _ = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes(&Vec::<Hir>::new()), None);",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Empty, props: Properties::default() }]), None);",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::empty())), props: Properties::default() }]), Some(Class::Bytes(ClassBytes::new(vec![]))));",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::empty())), props: Properties::default() }]), None);",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![]))), props: Properties::default() }]), None);"
        ],
        "code": [
          "{",
          "    let hirs: Vec<Hir> = vec![];",
          "    let _ = class_bytes(&hirs);",
          "    assert_eq!(class_bytes(&Vec::<Hir>::new()), None);",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Empty, props: Properties::default() }]), None);",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Class(Class::Bytes(ClassBytes::empty())), props: Properties::default() }]), Some(Class::Bytes(ClassBytes::new(vec![]))));",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::empty())), props: Properties::default() }]), None);",
          "    assert_eq!(class_bytes(&vec![Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec![]))), props: Properties::default() }]), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x66 }]);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class.clone())),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir];",
          "    let _ = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(bytes_class)));"
        ],
        "code": [
          "{",
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x66 }]);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class.clone())),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir];",
          "    let _ = class_bytes(&hirs);",
          "    assert_eq!(class_bytes(&hirs), Some(Class::Bytes(bytes_class)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir];",
          "    let _ = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let hir = Hir { kind: HirKind::Class(Class::Unicode(unicode_class)), props: Properties::default() };",
          "    let hirs = vec![hir];",
          "    let result = class_bytes(&hirs);",
          "    assert!(result.is_some());",
          "    if let Some(Class::Bytes(cls)) = result { assert_eq!(cls.ranges().len(), expected_length); }"
        ],
        "code": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir];",
          "    let _ = class_bytes(&hirs);",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let hir = Hir { kind: HirKind::Class(Class::Unicode(unicode_class)), props: Properties::default() };",
          "    let hirs = vec![hir];",
          "    let result = class_bytes(&hirs);",
          "    assert!(result.is_some());",
          "    if let Some(Class::Bytes(cls)) = result { assert_eq!(cls.ranges().len(), expected_length); }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'g', end: 'l' }]);",
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x67, end: 0x6C }]);",
          "    ",
          "    let hir1 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    let hir2 = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir1, hir2];",
          "    let _ = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'g', end: 'l' }]);",
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x67, end: 0x6C }]);",
          "    let hir1 = Hir { kind: HirKind::Class(Class::Unicode(unicode_class)), props: Properties::default() };",
          "    let hir2 = Hir { kind: HirKind::Class(Class::Bytes(bytes_class)), props: Properties::default() };",
          "    let hirs = vec![hir1, hir2];",
          "    let result = class_bytes(&hirs);",
          "    assert!(result.is_some());",
          "    if let Some(Class::Bytes(_)) = result { assert!(true); } else { assert!(false); }"
        ],
        "code": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'g', end: 'l' }]);",
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x67, end: 0x6C }]);",
          "    ",
          "    let hir1 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    let hir2 = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir1, hir2];",
          "    let _ = class_bytes(&hirs);",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'g', end: 'l' }]);",
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x67, end: 0x6C }]);",
          "    let hir1 = Hir { kind: HirKind::Class(Class::Unicode(unicode_class)), props: Properties::default() };",
          "    let hir2 = Hir { kind: HirKind::Class(Class::Bytes(bytes_class)), props: Properties::default() };",
          "    let hirs = vec![hir1, hir2];",
          "    let result = class_bytes(&hirs);",
          "    assert!(result.is_some());",
          "    if let Some(Class::Bytes(_)) = result { assert!(true); } else { assert!(false); }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes_class1 = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }]);",
          "    let bytes_class2 = ClassBytes::new(vec![ClassBytesRange { start: 0x62, end: 0x62 }]);",
          "    ",
          "    let hir1 = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class1)),",
          "        props: Properties::default(),",
          "    };",
          "    let hir2 = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class2)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir1, hir2];",
          "    let _ = class_bytes(&hirs);",
          "}"
        ],
        "oracle": [
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }]);",
          "    let hir = Hir {",
          "    kind: HirKind::Class(Class::Bytes(bytes_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir];",
          "    let result = class_bytes(&hirs);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }])));",
          "    ",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'a' as u32 }]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs_unicode = vec![hir_unicode];",
          "    let result_unicode = class_bytes(&hirs_unicode);",
          "    assert!(result_unicode.is_some());",
          "    assert_eq!(result_unicode.unwrap(), Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }])));",
          "    ",
          "    let empty_hirs: Vec<Hir> = vec![];",
          "    let result_empty = class_bytes(&empty_hirs);",
          "    assert!(result_empty.is_none());"
        ],
        "code": [
          "{",
          "    let bytes_class1 = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }]);",
          "    let bytes_class2 = ClassBytes::new(vec![ClassBytesRange { start: 0x62, end: 0x62 }]);",
          "    ",
          "    let hir1 = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class1)),",
          "        props: Properties::default(),",
          "    };",
          "    let hir2 = Hir {",
          "        kind: HirKind::Class(Class::Bytes(bytes_class2)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir1, hir2];",
          "    let _ = class_bytes(&hirs);",
          "    let bytes_class = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }]);",
          "    let hir = Hir {",
          "    kind: HirKind::Class(Class::Bytes(bytes_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir];",
          "    let result = class_bytes(&hirs);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }])));",
          "    ",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a' as u32, end: 'a' as u32 }]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs_unicode = vec![hir_unicode];",
          "    let result_unicode = class_bytes(&hirs_unicode);",
          "    assert!(result_unicode.is_some());",
          "    assert_eq!(result_unicode.unwrap(), Class::Bytes(ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x61 }])));",
          "    ",
          "    let empty_hirs: Vec<Hir> = vec![];",
          "    let result_empty = class_bytes(&empty_hirs);",
          "    assert!(result_empty.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]