[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::singletons();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.len(), transitions.write_to_len());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert_eq!(buffer[0..4], (transitions.state_len as u32).to_be_bytes());",
          "    assert_eq!(buffer[4..8], (transitions.pattern_len as u32).to_be_bytes());",
          "    assert!(transitions.classes.write_to(&mut buffer[8..]).is_ok());",
          "    assert_eq!(buffer[8 + transitions.classes.write_to_len()..12 + transitions.classes.write_to_len()], (transitions.sparse.len() as u32).to_be_bytes());",
          "    assert!(transitions.sparse.len() > 0);",
          "    assert!(transitions.state(StateID::new(0).unwrap()).ntrans > 0);"
        ],
        "code": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::singletons();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "    assert_eq!(buffer.len(), transitions.write_to_len());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert_eq!(buffer[0..4], (transitions.state_len as u32).to_be_bytes());",
          "    assert_eq!(buffer[4..8], (transitions.pattern_len as u32).to_be_bytes());",
          "    assert!(transitions.classes.write_to(&mut buffer[8..]).is_ok());",
          "    assert_eq!(buffer[8 + transitions.classes.write_to_len()..12 + transitions.classes.write_to_len()], (transitions.sparse.len() as u32).to_be_bytes());",
          "    assert!(transitions.sparse.len() > 0);",
          "    assert!(transitions.state(StateID::new(0).unwrap()).ntrans > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::singletons();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 2,",
          "    };",
          "",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.len(), transitions.write_to_len());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_err());",
          "    assert!(transitions.sparse().len() > 0);",
          "    assert!(transitions.state_len > 0);",
          "    assert!(transitions.pattern_len > 0);",
          "    assert!(transitions.classes.write_to(&mut buffer).is_ok());"
        ],
        "code": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::singletons();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 2,",
          "    };",
          "",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "    assert_eq!(buffer.len(), transitions.write_to_len());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_err());",
          "    assert!(transitions.sparse().len() > 0);",
          "    assert!(transitions.state_len > 0);",
          "    assert!(transitions.pattern_len > 0);",
          "    assert!(transitions.classes.write_to(&mut buffer).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::empty();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 3,",
          "        pattern_len: 1,",
          "    };",
          "",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer.len(), transitions.write_to_len());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert!(transitions.classes.write_to(&mut buffer).is_ok());",
          "    assert!(transitions.sparse.len() > 0);",
          "    assert!(transitions.state_len == 3);",
          "    assert!(transitions.pattern_len == 1);"
        ],
        "code": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::empty();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 3,",
          "        pattern_len: 1,",
          "    };",
          "",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "    assert_eq!(buffer.len(), transitions.write_to_len());",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert!(transitions.classes.write_to(&mut buffer).is_ok());",
          "    assert!(transitions.sparse.len() > 0);",
          "    assert!(transitions.state_len == 3);",
          "    assert!(transitions.pattern_len == 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::singletons();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 4,",
          "        pattern_len: 0,",
          "    };",
          "",
          "    let mut buffer = vec![0; transitions.write_to_len() - 1];  // Insufficient buffer size",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transitions.write_to_len(), 40);",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert!(transitions.classes.write_to(&mut buffer[8..]).is_ok());",
          "    assert!(transitions.sparse().len() > 0);",
          "    assert!(transitions.sparse().len() == transitions.state_len);",
          "    assert!(transitions.state(StateID::new(0).unwrap()).write_to::<crate::util::EndianBig>(&mut buffer[12..]).is_err());"
        ],
        "code": [
          "{",
          "    let sparse_data = vec![1, 2, 3, 4, 5, 6];",
          "    let classes = ByteClasses::singletons();",
          "    let transitions = Transitions {",
          "        sparse: &sparse_data,",
          "        classes,",
          "        state_len: 4,",
          "        pattern_len: 0,",
          "    };",
          "",
          "    let mut buffer = vec![0; transitions.write_to_len() - 1];  // Insufficient buffer size",
          "    let _ = transitions.write_to::<crate::util::EndianBig>(&mut buffer);",
          "    assert_eq!(transitions.write_to_len(), 40);",
          "    let mut buffer = vec![0; transitions.write_to_len()];",
          "    assert!(transitions.write_to::<crate::util::EndianBig>(&mut buffer).is_ok());",
          "    assert!(transitions.classes.write_to(&mut buffer[8..]).is_ok());",
          "    assert!(transitions.sparse().len() > 0);",
          "    assert!(transitions.sparse().len() == transitions.state_len);",
          "    assert!(transitions.state(StateID::new(0).unwrap()).write_to::<crate::util::EndianBig>(&mut buffer[12..]).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]