[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0);",
          "}"
        ],
        "oracle": [
          "    data.push(0);",
          "    data.push(0b1000_0000);",
          "    data.push(0b0000_0001);",
          "    data.push(0b0000_0010);",
          "    data.push(0b0000_0000);"
        ],
        "code": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0);",
          "    data.push(0);",
          "    data.push(0b1000_0000);",
          "    data.push(0b0000_0001);",
          "    data.push(0b0000_0010);",
          "    data.push(0b0000_0000);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 127);",
          "}"
        ],
        "oracle": [
          "    data.push(0b01111111);",
          "    data.clear();",
          "    write_varu32(&mut data, 128);",
          "    assert_eq!(data, vec![0b10000000, 0b00000001]);",
          "    data.clear();",
          "    write_varu32(&mut data, 16384);",
          "    assert_eq!(data, vec![0b10000010, 0b00000000, 0b00000001]);",
          "    data.clear();",
          "    write_varu32(&mut data, 0b1000_0000);",
          "    assert_eq!(data, vec![0b10000000, 0b00000000, 0b00000001]);",
          "    data.clear();",
          "    write_varu32(&mut data, 0);",
          "    assert_eq!(data, vec![0]);"
        ],
        "code": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 127);",
          "    data.push(0b01111111);",
          "    data.clear();",
          "    write_varu32(&mut data, 128);",
          "    assert_eq!(data, vec![0b10000000, 0b00000001]);",
          "    data.clear();",
          "    write_varu32(&mut data, 16384);",
          "    assert_eq!(data, vec![0b10000010, 0b00000000, 0b00000001]);",
          "    data.clear();",
          "    write_varu32(&mut data, 0b1000_0000);",
          "    assert_eq!(data, vec![0b10000000, 0b00000000, 0b00000001]);",
          "    data.clear();",
          "    write_varu32(&mut data, 0);",
          "    assert_eq!(data, vec![0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 128);",
          "}"
        ],
        "oracle": [
          "    data.push(0b1000_0000 | 0b00000000); // Check for n = 128, the first byte should be 0b10000000",
          "    data.push(0b00000000);               // Check for n = 0 after shifting, the second byte should be 0b00000000",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0b1000_0000); // Check for n = 128, the first byte should be 0b10000000",
          "    assert_eq!(data.len(), 1);             // Verify only one byte is written in this case",
          "    assert_eq!(data[0], 0b10000000);       // Verify the actual byte value is correct",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0);            // Check for n = 0, expect one byte output",
          "    assert_eq!(data.len(), 1);             // Verify exactly one byte is written",
          "    assert_eq!(data[0], 0);                 // Verify byte is zero",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 255);          // Check for n = 255",
          "    assert_eq!(data.len(), 1);             // Only one byte should be written",
          "    assert_eq!(data[0], 0b11111111);       // Verify the byte output is correct",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 256);          // Check for n = 256",
          "    assert_eq!(data.len(), 2);             // Two bytes should be written",
          "    assert_eq!(data[0], 0b10000000 | 0b00000001); // Verify first byte",
          "    assert_eq!(data[1], 0b00000000);       // Verify second byte",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0b01111111);   // Check for maximum value in the first byte",
          "    assert_eq!(data.len(), 1);             // Only one byte should be written",
          "    assert_eq!(data[0], 0b01111111);       // Verify the byte output is correct"
        ],
        "code": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 128);",
          "    data.push(0b1000_0000 | 0b00000000); // Check for n = 128, the first byte should be 0b10000000",
          "    data.push(0b00000000);               // Check for n = 0 after shifting, the second byte should be 0b00000000",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0b1000_0000); // Check for n = 128, the first byte should be 0b10000000",
          "    assert_eq!(data.len(), 1);             // Verify only one byte is written in this case",
          "    assert_eq!(data[0], 0b10000000);       // Verify the actual byte value is correct",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0);            // Check for n = 0, expect one byte output",
          "    assert_eq!(data.len(), 1);             // Verify exactly one byte is written",
          "    assert_eq!(data[0], 0);                 // Verify byte is zero",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 255);          // Check for n = 255",
          "    assert_eq!(data.len(), 1);             // Only one byte should be written",
          "    assert_eq!(data[0], 0b11111111);       // Verify the byte output is correct",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 256);          // Check for n = 256",
          "    assert_eq!(data.len(), 2);             // Two bytes should be written",
          "    assert_eq!(data[0], 0b10000000 | 0b00000001); // Verify first byte",
          "    assert_eq!(data[1], 0b00000000);       // Verify second byte",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0b01111111);   // Check for maximum value in the first byte",
          "    assert_eq!(data.len(), 1);             // Only one byte should be written",
          "    assert_eq!(data[0], 0b01111111);       // Verify the byte output is correct",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 16383);",
          "}"
        ],
        "oracle": [
          "    data.push(0b1000_0000 | (16383 & 0b01111111) as u8);",
          "    data.push((16383 >> 7) as u8);",
          "    data.push(0b0000_1111);",
          "    data.push(0b0000_0011);",
          "    assert_eq!(data, vec![0b1000_0000 | 0b1111111, 0b0000_1111, 0b0000_0011]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0b1000_0000);",
          "    assert_eq!(data, vec![0b1000_0000, 0]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0);",
          "    assert_eq!(data, vec![0]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 1);",
          "    assert_eq!(data, vec![1]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 127);",
          "    assert_eq!(data, vec![127]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 128);",
          "    assert_eq!(data, vec![0b1000_0000 | 0b0000_0000, 1]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 16384);",
          "    assert_eq!(data, vec![0b1000_0000 | (16384 & 0b01111111) as u8, (16384 >> 7) as u8]);"
        ],
        "code": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 16383);",
          "    data.push(0b1000_0000 | (16383 & 0b01111111) as u8);",
          "    data.push((16383 >> 7) as u8);",
          "    data.push(0b0000_1111);",
          "    data.push(0b0000_0011);",
          "    assert_eq!(data, vec![0b1000_0000 | 0b1111111, 0b0000_1111, 0b0000_0011]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0b1000_0000);",
          "    assert_eq!(data, vec![0b1000_0000, 0]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 0);",
          "    assert_eq!(data, vec![0]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 1);",
          "    assert_eq!(data, vec![1]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 127);",
          "    assert_eq!(data, vec![127]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 128);",
          "    assert_eq!(data, vec![0b1000_0000 | 0b0000_0000, 1]);",
          "    ",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 16384);",
          "    assert_eq!(data, vec![0b1000_0000 | (16384 & 0b01111111) as u8, (16384 >> 7) as u8]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 16384);",
          "}"
        ],
        "oracle": [
          "    data.push(0b1000_0000 | 0b1000_0000);  // Expected byte for n = 16384, first write",
          "    data.push(0b0000_0001);                  // Expected byte for n = 16384, second write",
          "    assert_eq!(data, vec![0b1000_0000 | 0b1000_0000, 0b0000_0001]); // Validate final output"
        ],
        "code": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 16384);",
          "    data.push(0b1000_0000 | 0b1000_0000);  // Expected byte for n = 16384, first write",
          "    data.push(0b0000_0001);                  // Expected byte for n = 16384, second write",
          "    assert_eq!(data, vec![0b1000_0000 | 0b1000_0000, 0b0000_0001]); // Validate final output",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 2147483647);",
          "}"
        ],
        "oracle": [
          "    let mut data = Vec::new(); write_varu32(&mut data, 0b1000_0000); assert_eq!(data, vec![0b1000_0000]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 0b1000_0001); assert_eq!(data, vec![0b1000_0001, 0]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 0u32); assert_eq!(data, vec![0]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 127); assert_eq!(data, vec![127]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 128); assert_eq!(data, vec![0b1000_0000, 0]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 255); assert_eq!(data, vec![0b1000_0000 | 0b01111111, 0b11111111]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 2147483647); assert_eq!(data.len(), 5);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 1); assert_eq!(data, vec![1]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 100000); assert_eq!(data,[178, 147]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 0b01111111); assert_eq!(data, vec![0b01111111]);"
        ],
        "code": [
          "{",
          "    let mut data = Vec::new();",
          "    write_varu32(&mut data, 2147483647);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 0b1000_0000); assert_eq!(data, vec![0b1000_0000]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 0b1000_0001); assert_eq!(data, vec![0b1000_0001, 0]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 0u32); assert_eq!(data, vec![0]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 127); assert_eq!(data, vec![127]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 128); assert_eq!(data, vec![0b1000_0000, 0]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 255); assert_eq!(data, vec![0b1000_0000 | 0b01111111, 0b11111111]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 2147483647); assert_eq!(data.len(), 5);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 1); assert_eq!(data, vec![1]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 100000); assert_eq!(data,[178, 147]);",
          "    let mut data = Vec::new(); write_varu32(&mut data, 0b01111111); assert_eq!(data, vec![0b01111111]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]