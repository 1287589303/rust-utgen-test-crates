[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(1)",
          "        .limit_repeat(2)",
          "        .limit_literal_len(3)",
          "        .limit_total(4);",
          "",
          "    let mut seq1 = Seq::new(vec![b\"abc\", b\"def\", b\"ghi\"]);",
          "    let mut seq2 = Seq::new(vec![b\"jkl\", b\"mno\", b\"pqr\"]);",
          "",
          "    extractor.union(seq1.clone(), &mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq1.len(), Some(3));",
          "    assert!(seq1.max_union_len(&seq2).is_some() && seq1.max_union_len(&seq2).unwrap() <= extractor.limit_total);",
          "    assert!(seq2.len().map_or(true, |x| x <= extractor.limit_total));",
          "    assert!(seq2.literals().is_some() && seq2.literals().unwrap().len() == 3);",
          "    assert!(seq2.literals().unwrap().iter().all(|lit| lit.as_bytes().len() <= 3));",
          "    assert!(seq1.literals().is_some() && seq1.literals().unwrap().len() == 3);",
          "    assert!(seq1.literals().unwrap().iter().all(|lit| lit.as_bytes().len() <= 3));"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Prefix)",
          "        .limit_class(1)",
          "        .limit_repeat(2)",
          "        .limit_literal_len(3)",
          "        .limit_total(4);",
          "",
          "    let mut seq1 = Seq::new(vec![b\"abc\", b\"def\", b\"ghi\"]);",
          "    let mut seq2 = Seq::new(vec![b\"jkl\", b\"mno\", b\"pqr\"]);",
          "",
          "    extractor.union(seq1.clone(), &mut seq2);",
          "    assert_eq!(seq1.len(), Some(3));",
          "    assert!(seq1.max_union_len(&seq2).is_some() && seq1.max_union_len(&seq2).unwrap() <= extractor.limit_total);",
          "    assert!(seq2.len().map_or(true, |x| x <= extractor.limit_total));",
          "    assert!(seq2.literals().is_some() && seq2.literals().unwrap().len() == 3);",
          "    assert!(seq2.literals().unwrap().iter().all(|lit| lit.as_bytes().len() <= 3));",
          "    assert!(seq1.literals().is_some() && seq1.literals().unwrap().len() == 3);",
          "    assert!(seq1.literals().unwrap().iter().all(|lit| lit.as_bytes().len() <= 3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Suffix)",
          "        .limit_class(1)",
          "        .limit_repeat(2)",
          "        .limit_literal_len(3)",
          "        .limit_total(2);",
          "",
          "    let mut seq1 = Seq::new(vec![b\"abcd\", b\"efgh\"]);",
          "    let mut seq2 = Seq::new(vec![b\"ijkl\"]);",
          "",
          "    extractor.union(seq1.clone(), &mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq1.len(), Some(2));",
          "    assert!(seq1.max_union_len(&seq2).map_or(true, |len| len <= extractor.limit_total));",
          "    assert!(extractor.limit_total == 2);",
          "    assert!(seq2.len().map_or(true, |x| x <= extractor.limit_total));",
          "    assert!(seq2.is_finite());",
          "    assert!(seq1.is_finite());",
          "    seq1.dedup();",
          "    seq2.dedup();"
        ],
        "code": [
          "{",
          "    let mut extractor = Extractor::new()",
          "        .kind(ExtractKind::Suffix)",
          "        .limit_class(1)",
          "        .limit_repeat(2)",
          "        .limit_literal_len(3)",
          "        .limit_total(2);",
          "",
          "    let mut seq1 = Seq::new(vec![b\"abcd\", b\"efgh\"]);",
          "    let mut seq2 = Seq::new(vec![b\"ijkl\"]);",
          "",
          "    extractor.union(seq1.clone(), &mut seq2);",
          "    assert_eq!(seq1.len(), Some(2));",
          "    assert!(seq1.max_union_len(&seq2).map_or(true, |len| len <= extractor.limit_total));",
          "    assert!(extractor.limit_total == 2);",
          "    assert!(seq2.len().map_or(true, |x| x <= extractor.limit_total));",
          "    assert!(seq2.is_finite());",
          "    assert!(seq1.is_finite());",
          "    seq1.dedup();",
          "    seq2.dedup();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]