[
  {
    "uses": [
      "use crate::ErrorKind;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::CaptureLimitExceeded;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"exceeded the maximum number of capturing groups ({})\", u32::MAX) == output;",
          "    write!(f, \"invalid escape sequence found in character class\") == output;",
          "    write!(f, \"invalid character class range, the start must be <= the end\") == output;",
          "    write!(f, \"invalid range boundary, must be a literal\") == output;",
          "    write!(f, \"unclosed character class\") == output;",
          "    write!(f, \"decimal literal empty\") == output;",
          "    write!(f, \"decimal literal invalid\") == output;",
          "    write!(f, \"hexadecimal literal empty\") == output;",
          "    write!(f, \"hexadecimal literal is not a Unicode scalar value\") == output;",
          "    write!(f, \"invalid hexadecimal digit\") == output;",
          "    write!(f, \"incomplete escape sequence, reached end of pattern prematurely\") == output;",
          "    write!(f, \"unrecognized escape sequence\") == output;",
          "    write!(f, \"dangling flag negation operator\") == output;",
          "    write!(f, \"duplicate flag\") == output;",
          "    write!(f, \"flag negation operator repeated\") == output;",
          "    write!(f, \"expected flag but got end of regex\") == output;",
          "    write!(f, \"unrecognized flag\") == output;",
          "    write!(f, \"duplicate capture group name\") == output;",
          "    write!(f, \"empty capture group name\") == output;",
          "    write!(f, \"invalid capture group character\") == output;",
          "    write!(f, \"unclosed capture group name\") == output;",
          "    write!(f, \"unclosed group\") == output;",
          "    write!(f, \"unopened group\") == output;",
          "    write!(f, \"exceed the maximum number of nested parentheses/brackets ({})\", limit) == output;",
          "    write!(f, \"invalid repetition count range, the start must be <= the end\") == output;",
          "    write!(f, \"repetition quantifier expects a valid decimal\") == output;",
          "    write!(f, \"unclosed counted repetition\") == output;",
          "    write!(f, \"repetition operator missing expression\") == output;",
          "    write!(f, \"special word boundary assertion is either unclosed or contains an invalid character\") == output;",
          "    write!(f, \"unrecognized special word boundary assertion, valid choices are: start, end, start-half or end-half\") == output;",
          "    write!(f, \"found either the beginning of a special word boundary or a bounded repetition on a \\\\b with an opening brace, but no closing brace\") == output;",
          "    write!(f, \"invalid Unicode character class\") == output;",
          "    write!(f, \"backreferences are not supported\") == output;",
          "    write!(f, \"look-around, including look-ahead and look-behind, is not supported\") == output;"
        ],
        "code": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::CaptureLimitExceeded;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    write!(f, \"exceeded the maximum number of capturing groups ({})\", u32::MAX) == output;",
          "    write!(f, \"invalid escape sequence found in character class\") == output;",
          "    write!(f, \"invalid character class range, the start must be <= the end\") == output;",
          "    write!(f, \"invalid range boundary, must be a literal\") == output;",
          "    write!(f, \"unclosed character class\") == output;",
          "    write!(f, \"decimal literal empty\") == output;",
          "    write!(f, \"decimal literal invalid\") == output;",
          "    write!(f, \"hexadecimal literal empty\") == output;",
          "    write!(f, \"hexadecimal literal is not a Unicode scalar value\") == output;",
          "    write!(f, \"invalid hexadecimal digit\") == output;",
          "    write!(f, \"incomplete escape sequence, reached end of pattern prematurely\") == output;",
          "    write!(f, \"unrecognized escape sequence\") == output;",
          "    write!(f, \"dangling flag negation operator\") == output;",
          "    write!(f, \"duplicate flag\") == output;",
          "    write!(f, \"flag negation operator repeated\") == output;",
          "    write!(f, \"expected flag but got end of regex\") == output;",
          "    write!(f, \"unrecognized flag\") == output;",
          "    write!(f, \"duplicate capture group name\") == output;",
          "    write!(f, \"empty capture group name\") == output;",
          "    write!(f, \"invalid capture group character\") == output;",
          "    write!(f, \"unclosed capture group name\") == output;",
          "    write!(f, \"unclosed group\") == output;",
          "    write!(f, \"unopened group\") == output;",
          "    write!(f, \"exceed the maximum number of nested parentheses/brackets ({})\", limit) == output;",
          "    write!(f, \"invalid repetition count range, the start must be <= the end\") == output;",
          "    write!(f, \"repetition quantifier expects a valid decimal\") == output;",
          "    write!(f, \"unclosed counted repetition\") == output;",
          "    write!(f, \"repetition operator missing expression\") == output;",
          "    write!(f, \"special word boundary assertion is either unclosed or contains an invalid character\") == output;",
          "    write!(f, \"unrecognized special word boundary assertion, valid choices are: start, end, start-half or end-half\") == output;",
          "    write!(f, \"found either the beginning of a special word boundary or a bounded repetition on a \\\\b with an opening brace, but no closing brace\") == output;",
          "    write!(f, \"invalid Unicode character class\") == output;",
          "    write!(f, \"backreferences are not supported\") == output;",
          "    write!(f, \"look-around, including look-ahead and look-behind, is not supported\") == output;",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassEscapeInvalid;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"invalid escape sequence found in character class\") == output.to_string();",
          "    write!(f, \"exceeded the maximum number of capturing groups ({})\", u32::MAX) == output.to_string();"
        ],
        "code": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassEscapeInvalid;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    write!(f, \"invalid escape sequence found in character class\") == output.to_string();",
          "    write!(f, \"exceeded the maximum number of capturing groups ({})\", u32::MAX) == output.to_string();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassRangeInvalid;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"exceeded the maximum number of capturing groups ({})\", u32::MAX);",
          "    write!(f, \"invalid capture group character\");",
          "    write!(f, \"unrecognized special word boundary assertion, valid choices are: start, end, start-half or end-half\");",
          "    write!(f, \"bad number of capture groups\");",
          "    write!(f, \"invalid escape sequence found in character class\");",
          "    write!(f, \"unclosed counted repetition\");",
          "    write!(f, \"ungrouped repetition operator missing expression\");",
          "    write!(f, \"repetition quantifier expects a valid decimal\");",
          "    write!(f, \"flag negation operator repeated\");",
          "    write!(f, \"duplicate flag\");",
          "    write!(f, \"flag was used twice, e.g., -i-i\");",
          "    write!(f, \"dangling flag negation operator\");",
          "    write!(f, \"expected flag but got end of regex\");",
          "    write!(f, \"unclosed character class\");",
          "    write!(f, \"invalid character class range, the start must be <= the end\");",
          "    write!(f, \"unclosed group\");",
          "    write!(f, \"unopened group\");",
          "    write!(f, \"invalid repetition count range, the start must be <= the end\");",
          "    write!(f, \"special word boundary assertion is either unclosed or contains an invalid character\");"
        ],
        "code": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassRangeInvalid;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    write!(f, \"exceeded the maximum number of capturing groups ({})\", u32::MAX);",
          "    write!(f, \"invalid capture group character\");",
          "    write!(f, \"unrecognized special word boundary assertion, valid choices are: start, end, start-half or end-half\");",
          "    write!(f, \"bad number of capture groups\");",
          "    write!(f, \"invalid escape sequence found in character class\");",
          "    write!(f, \"unclosed counted repetition\");",
          "    write!(f, \"ungrouped repetition operator missing expression\");",
          "    write!(f, \"repetition quantifier expects a valid decimal\");",
          "    write!(f, \"flag negation operator repeated\");",
          "    write!(f, \"duplicate flag\");",
          "    write!(f, \"flag was used twice, e.g., -i-i\");",
          "    write!(f, \"dangling flag negation operator\");",
          "    write!(f, \"expected flag but got end of regex\");",
          "    write!(f, \"unclosed character class\");",
          "    write!(f, \"invalid character class range, the start must be <= the end\");",
          "    write!(f, \"unclosed group\");",
          "    write!(f, \"unopened group\");",
          "    write!(f, \"invalid repetition count range, the start must be <= the end\");",
          "    write!(f, \"special word boundary assertion is either unclosed or contains an invalid character\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassRangeLiteral;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    let error = ErrorKind::CaptureLimitExceeded;",
          "    let expected_output = \"exceeded the maximum number of \\",
          "    capturing groups (4294967295)\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::ClassEscapeInvalid;",
          "    let expected_output = \"invalid escape sequence found in character class\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::ClassRangeInvalid;",
          "    let expected_output = \"invalid character class range, \\",
          "    the start must be <= the end\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::ClassUnclosed;",
          "    let expected_output = \"unclosed character class\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::EscapeUnrecognized;",
          "    let expected_output = \"unrecognized escape sequence\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::GroupNameEmpty;",
          "    let expected_output = \"empty capture group name\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::NestLimitExceeded(5);",
          "    let expected_output = \"exceed the maximum number of \\",
          "    nested parentheses/brackets (5)\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);"
        ],
        "code": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassRangeLiteral;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    let error = ErrorKind::CaptureLimitExceeded;",
          "    let expected_output = \"exceeded the maximum number of \\",
          "    capturing groups (4294967295)\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::ClassEscapeInvalid;",
          "    let expected_output = \"invalid escape sequence found in character class\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::ClassRangeInvalid;",
          "    let expected_output = \"invalid character class range, \\",
          "    the start must be <= the end\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::ClassUnclosed;",
          "    let expected_output = \"unclosed character class\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::EscapeUnrecognized;",
          "    let expected_output = \"unrecognized escape sequence\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::GroupNameEmpty;",
          "    let expected_output = \"empty capture group name\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "    let error = ErrorKind::NestLimitExceeded(5);",
          "    let expected_output = \"exceed the maximum number of \\",
          "    nested parentheses/brackets (5)\";",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    assert_eq!(output.to_string(), expected_output);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassUnclosed;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    let error = ErrorKind::CaptureLimitExceeded;",
          "    assert_eq!(format!(\"{:?}\", error), \"exceeded the maximum number of capturing groups (4294967295)\");",
          "    let error = ErrorKind::ClassEscapeInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid escape sequence found in character class\");",
          "    let error = ErrorKind::ClassRangeInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid character class range, the start must be <= the end\");",
          "    let error = ErrorKind::ClassRangeLiteral;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid range boundary, must be a literal\");",
          "    let error = ErrorKind::ClassUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed character class\");",
          "    let error = ErrorKind::DecimalEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"decimal literal empty\");",
          "    let error = ErrorKind::DecimalInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"decimal literal invalid\");",
          "    let error = ErrorKind::EscapeHexEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"hexadecimal literal empty\");",
          "    let error = ErrorKind::EscapeHexInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"hexadecimal literal is not a Unicode scalar value\");",
          "    let error = ErrorKind::EscapeHexInvalidDigit;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid hexadecimal digit\");",
          "    let error = ErrorKind::EscapeUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"incomplete escape sequence, reached end of pattern prematurely\");",
          "    let error = ErrorKind::EscapeUnrecognized;",
          "    assert_eq!(format!(\"{:?}\", error), \"unrecognized escape sequence\");",
          "    let error = ErrorKind::FlagDanglingNegation;",
          "    assert_eq!(format!(\"{:?}\", error), \"dangling flag negation operator\");",
          "    let error = ErrorKind::FlagDuplicate { original: Span { start: 0, end: 0 }};",
          "    assert_eq!(format!(\"{:?}\", error), \"duplicate flag\");",
          "    let error = ErrorKind::FlagRepeatedNegation { original: Span { start: 0, end: 0 }};",
          "    assert_eq!(format!(\"{:?}\", error), \"flag negation operator repeated\");",
          "    let error = ErrorKind::FlagUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"expected flag but got end of regex\");",
          "    let error = ErrorKind::FlagUnrecognized;",
          "    assert_eq!(format!(\"{:?}\", error), \"unrecognized flag\");",
          "    let error = ErrorKind::GroupNameDuplicate { original: Span { start: 0, end: 0 }};",
          "    assert_eq!(format!(\"{:?}\", error), \"duplicate capture group name\");",
          "    let error = ErrorKind::GroupNameEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"empty capture group name\");",
          "    let error = ErrorKind::GroupNameInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid capture group character\");",
          "    let error = ErrorKind::GroupNameUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed capture group name\");",
          "    let error = ErrorKind::GroupUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed group\");",
          "    let error = ErrorKind::GroupUnopened;",
          "    assert_eq!(format!(\"{:?}\", error), \"unopened group\");",
          "    let error = ErrorKind::NestLimitExceeded(10);",
          "    assert_eq!(format!(\"{:?}\", error), \"exceed the maximum number of nested parentheses/brackets (10)\");",
          "    let error = ErrorKind::RepetitionCountInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid repetition count range, the start must be <= the end\");",
          "    let error = ErrorKind::RepetitionCountDecimalEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"repetition quantifier expects a valid decimal\");",
          "    let error = ErrorKind::RepetitionCountUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed counted repetition\");",
          "    let error = ErrorKind::RepetitionMissing;",
          "    assert_eq!(format!(\"{:?}\", error), \"repetition operator missing expression\");",
          "    let error = ErrorKind::SpecialWordBoundaryUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"special word boundary assertion is either unclosed or contains an invalid character\");",
          "    let error = ErrorKind::SpecialWordBoundaryUnrecognized;",
          "    assert_eq!(format!(\"{:?}\", error), \"unrecognized special word boundary assertion, valid choices are: start, end, start-half or end-half\");",
          "    let error = ErrorKind::SpecialWordOrRepetitionUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"found either the beginning of a special word boundary or a bounded repetition on a \\\\b with an opening brace, but no closing brace\");",
          "    let error = ErrorKind::UnicodeClassInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid Unicode character class\");",
          "    let error = ErrorKind::UnsupportedBackreference;",
          "    assert_eq!(format!(\"{:?}\", error), \"backreferences are not supported\");",
          "    let error = ErrorKind::UnsupportedLookAround;",
          "    assert_eq!(format!(\"{:?}\", error), \"look-around, including look-ahead and look-behind, is not supported\");"
        ],
        "code": [
          "{",
          "    use crate::ErrorKind;",
          "",
          "    let error = ErrorKind::ClassUnclosed;",
          "    let mut output = core::fmt::Formatter::new();",
          "    let _ = error.fmt(&mut output);",
          "    let error = ErrorKind::CaptureLimitExceeded;",
          "    assert_eq!(format!(\"{:?}\", error), \"exceeded the maximum number of capturing groups (4294967295)\");",
          "    let error = ErrorKind::ClassEscapeInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid escape sequence found in character class\");",
          "    let error = ErrorKind::ClassRangeInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid character class range, the start must be <= the end\");",
          "    let error = ErrorKind::ClassRangeLiteral;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid range boundary, must be a literal\");",
          "    let error = ErrorKind::ClassUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed character class\");",
          "    let error = ErrorKind::DecimalEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"decimal literal empty\");",
          "    let error = ErrorKind::DecimalInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"decimal literal invalid\");",
          "    let error = ErrorKind::EscapeHexEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"hexadecimal literal empty\");",
          "    let error = ErrorKind::EscapeHexInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"hexadecimal literal is not a Unicode scalar value\");",
          "    let error = ErrorKind::EscapeHexInvalidDigit;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid hexadecimal digit\");",
          "    let error = ErrorKind::EscapeUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"incomplete escape sequence, reached end of pattern prematurely\");",
          "    let error = ErrorKind::EscapeUnrecognized;",
          "    assert_eq!(format!(\"{:?}\", error), \"unrecognized escape sequence\");",
          "    let error = ErrorKind::FlagDanglingNegation;",
          "    assert_eq!(format!(\"{:?}\", error), \"dangling flag negation operator\");",
          "    let error = ErrorKind::FlagDuplicate { original: Span { start: 0, end: 0 }};",
          "    assert_eq!(format!(\"{:?}\", error), \"duplicate flag\");",
          "    let error = ErrorKind::FlagRepeatedNegation { original: Span { start: 0, end: 0 }};",
          "    assert_eq!(format!(\"{:?}\", error), \"flag negation operator repeated\");",
          "    let error = ErrorKind::FlagUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"expected flag but got end of regex\");",
          "    let error = ErrorKind::FlagUnrecognized;",
          "    assert_eq!(format!(\"{:?}\", error), \"unrecognized flag\");",
          "    let error = ErrorKind::GroupNameDuplicate { original: Span { start: 0, end: 0 }};",
          "    assert_eq!(format!(\"{:?}\", error), \"duplicate capture group name\");",
          "    let error = ErrorKind::GroupNameEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"empty capture group name\");",
          "    let error = ErrorKind::GroupNameInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid capture group character\");",
          "    let error = ErrorKind::GroupNameUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed capture group name\");",
          "    let error = ErrorKind::GroupUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed group\");",
          "    let error = ErrorKind::GroupUnopened;",
          "    assert_eq!(format!(\"{:?}\", error), \"unopened group\");",
          "    let error = ErrorKind::NestLimitExceeded(10);",
          "    assert_eq!(format!(\"{:?}\", error), \"exceed the maximum number of nested parentheses/brackets (10)\");",
          "    let error = ErrorKind::RepetitionCountInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid repetition count range, the start must be <= the end\");",
          "    let error = ErrorKind::RepetitionCountDecimalEmpty;",
          "    assert_eq!(format!(\"{:?}\", error), \"repetition quantifier expects a valid decimal\");",
          "    let error = ErrorKind::RepetitionCountUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"unclosed counted repetition\");",
          "    let error = ErrorKind::RepetitionMissing;",
          "    assert_eq!(format!(\"{:?}\", error), \"repetition operator missing expression\");",
          "    let error = ErrorKind::SpecialWordBoundaryUnclosed;",
          "    assert_eq!(format!(\"{:?}\", error), \"special word boundary assertion is either unclosed or contains an invalid character\");",
          "    let error = ErrorKind::SpecialWordBoundaryUnrecognized;",
          "    assert_eq!(format!(\"{:?}\", error), \"unrecognized special word boundary assertion, valid choices are: start, end, start-half or end-half\");",
          "    let error = ErrorKind::SpecialWordOrRepetitionUnexpectedEof;",
          "    assert_eq!(format!(\"{:?}\", error), \"found either the beginning of a special word boundary or a bounded repetition on a \\\\b with an opening brace, but no closing brace\");",
          "    let error = ErrorKind::UnicodeClassInvalid;",
          "    assert_eq!(format!(\"{:?}\", error), \"invalid Unicode character class\");",
          "    let error = ErrorKind::UnsupportedBackreference;",
          "    assert_eq!(format!(\"{:?}\", error), \"backreferences are not supported\");",
          "    let error = ErrorKind::UnsupportedLookAround;",
          "    assert_eq!(format!(\"{:?}\", error), \"look-around, including look-ahead and look-behind, is not supported\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]