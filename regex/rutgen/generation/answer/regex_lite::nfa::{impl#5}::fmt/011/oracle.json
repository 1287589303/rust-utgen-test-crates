[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let targets: Vec<u32> = vec![];",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "    let _ = core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    let targets: Vec<u32> = vec![1, 2, 3];",
          "    let reverse = false;",
          "    let state = State::Splits { targets: targets.clone(), reverse };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let state = State::Splits { targets: targets.clone(), reverse: true };",
          "    assert!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()).is_ok());",
          "    let targets: Vec<u32> = vec![5];",
          "    let state = State::Splits { targets, reverse };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let targets: Vec<u32> = vec![4];",
          "    let state = State::Splits { targets, reverse: true };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let targets: Vec<u32> = vec![];",
          "    let reverse = true;",
          "    let state = State::Splits { targets, reverse };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));"
        ],
        "code": [
          "{",
          "    let targets: Vec<u32> = vec![];",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "    let _ = core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new());",
          "    let targets: Vec<u32> = vec![1, 2, 3];",
          "    let reverse = false;",
          "    let state = State::Splits { targets: targets.clone(), reverse };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let state = State::Splits { targets: targets.clone(), reverse: true };",
          "    assert!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()).is_ok());",
          "    let targets: Vec<u32> = vec![5];",
          "    let state = State::Splits { targets, reverse };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let targets: Vec<u32> = vec![4];",
          "    let state = State::Splits { targets, reverse: true };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));",
          "    let targets: Vec<u32> = vec![];",
          "    let reverse = true;",
          "    let state = State::Splits { targets, reverse };",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let targets: Vec<u32> = vec![1];",
          "    let reverse = true;",
          "    let state = State::Splits { targets, reverse };",
          "    let _ = core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"splits(\")? == Ok(())",
          "    (i, sid) in State::iter_splits(targets, reverse).enumerate() is true",
          "    i == 0",
          "    write!(f, \"{:?}\", sid)? == Ok(())",
          "    (i, sid) in State::iter_splits(targets, reverse).enumerate() is false"
        ],
        "code": [
          "{",
          "    let targets: Vec<u32> = vec![1];",
          "    let reverse = true;",
          "    let state = State::Splits { targets, reverse };",
          "    let _ = core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new());",
          "    write!(f, \"splits(\")? == Ok(())",
          "    (i, sid) in State::iter_splits(targets, reverse).enumerate() is true",
          "    i == 0",
          "    write!(f, \"{:?}\", sid)? == Ok(())",
          "    (i, sid) in State::iter_splits(targets, reverse).enumerate() is false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let targets: Vec<u32> = vec![1, 2];",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "    let _ = core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()).is_ok(), true);",
          "    assert!(matches!(state, State::Splits { ref targets, reverse }));",
          "    let (i, sid) = (0, targets[0]);",
          "    assert_eq!(i, 0);",
          "    assert_eq!(core::fmt::Debug::fmt(&sid, &mut core::fmt::Formatter::new()).is_ok(), true);",
          "    let empty_target: Vec<u32> = vec![];",
          "    assert!(State::iter_splits(&empty_target, reverse).enumerate().count() == 0);"
        ],
        "code": [
          "{",
          "    let targets: Vec<u32> = vec![1, 2];",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "    let _ = core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new());",
          "    assert_eq!(core::fmt::Debug::fmt(&state, &mut core::fmt::Formatter::new()).is_ok(), true);",
          "    assert!(matches!(state, State::Splits { ref targets, reverse }));",
          "    let (i, sid) = (0, targets[0]);",
          "    assert_eq!(i, 0);",
          "    assert_eq!(core::fmt::Debug::fmt(&sid, &mut core::fmt::Formatter::new()).is_ok(), true);",
          "    let empty_target: Vec<u32> = vec![];",
          "    assert!(State::iter_splits(&empty_target, reverse).enumerate().count() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]