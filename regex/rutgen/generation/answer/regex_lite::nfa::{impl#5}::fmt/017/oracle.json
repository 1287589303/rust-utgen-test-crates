[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let target: StateID = 1;",
          "    let ranges: Vec<(char, char)> = vec![('a', 'z')];",
          "    let state = State::Ranges { target, ranges };",
          "    ",
          "    let mut output = String::new();",
          "    let _ = write!(&mut output, \"{:?}\", state); // Call fmt indirectly for testing",
          "}"
        ],
        "oracle": [
          "    write!(f, \"{:?}-{:?} => {:?}\", 'a', 'z', target)?;",
          "    assert_eq!(output, \"a-z => 1\");",
          "    assert!(matches!(state, State::Ranges { .. }));",
          "    assert_eq!(state.memory_usage(), size_of::<State>());",
          "    assert!(state == State::Ranges { target: 1, ranges: vec![('a', 'z')] });",
          "    assert!(output.contains(\"a-z => 1\"));",
          "    assert_eq!(output.len(), 12);"
        ],
        "code": [
          "{",
          "    let target: StateID = 1;",
          "    let ranges: Vec<(char, char)> = vec![('a', 'z')];",
          "    let state = State::Ranges { target, ranges };",
          "    ",
          "    let mut output = String::new();",
          "    let _ = write!(&mut output, \"{:?}\", state); // Call fmt indirectly for testing",
          "    write!(f, \"{:?}-{:?} => {:?}\", 'a', 'z', target)?;",
          "    assert_eq!(output, \"a-z => 1\");",
          "    assert!(matches!(state, State::Ranges { .. }));",
          "    assert_eq!(state.memory_usage(), size_of::<State>());",
          "    assert!(state == State::Ranges { target: 1, ranges: vec![('a', 'z')] });",
          "    assert!(output.contains(\"a-z => 1\"));",
          "    assert_eq!(output.len(), 12);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let target: StateID = 2;",
          "    let ranges: Vec<(char, char)> = vec![('a', 'm'), ('n', 'z')];",
          "    let state = State::Ranges { target, ranges };",
          "    ",
          "    let mut output = String::new();",
          "    let _ = write!(&mut output, \"{:?}\", state); // Call fmt indirectly for testing",
          "}"
        ],
        "oracle": [
          "    write!(f, \"{:?} => {:?}\", 'a', target)?;",
          "    write!(f, \"{:?}-{:?} => {:?}\", 'a', 'm', target)?;",
          "    write!(f, \"{:?}-{:?} => {:?}\", 'n', 'z', target)?;",
          "    write!(f, \"splits(\")?;",
          "    write!(f, \"{:?}\", 2)?;",
          "    write!(f, \")\")?;",
          "    write!(f, \"FAIL\")?;",
          "    write!(f, \"MATCH\")?;",
          "    Ok(())"
        ],
        "code": [
          "{",
          "    let target: StateID = 2;",
          "    let ranges: Vec<(char, char)> = vec![('a', 'm'), ('n', 'z')];",
          "    let state = State::Ranges { target, ranges };",
          "    ",
          "    let mut output = String::new();",
          "    let _ = write!(&mut output, \"{:?}\", state); // Call fmt indirectly for testing",
          "    write!(f, \"{:?} => {:?}\", 'a', target)?;",
          "    write!(f, \"{:?}-{:?} => {:?}\", 'a', 'm', target)?;",
          "    write!(f, \"{:?}-{:?} => {:?}\", 'n', 'z', target)?;",
          "    write!(f, \"splits(\")?;",
          "    write!(f, \"{:?}\", 2)?;",
          "    write!(f, \")\")?;",
          "    write!(f, \"FAIL\")?;",
          "    write!(f, \"MATCH\")?;",
          "    Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let target: StateID = 3;",
          "    let ranges: Vec<(char, char)> = vec![];",
          "    let state = State::Ranges { target, ranges };",
          "    ",
          "    let mut output = String::new();",
          "    let _ = write!(&mut output, \"{:?}\", state); // Call fmt indirectly for testing",
          "}"
        ],
        "oracle": [
          "    write!(f, \"{:?}-{:?} => {:?}\", start, end, target)?; // Ensure formatted write succeeds for first range (empty case)",
          "    assert_eq!(output, \"\"); // Output should be empty as ranges is empty and i == 0",
          "    Ok(()) // Verify expected return value from fmt is Ok(()) for the empty ranges case"
        ],
        "code": [
          "{",
          "    let target: StateID = 3;",
          "    let ranges: Vec<(char, char)> = vec![];",
          "    let state = State::Ranges { target, ranges };",
          "    ",
          "    let mut output = String::new();",
          "    let _ = write!(&mut output, \"{:?}\", state); // Call fmt indirectly for testing",
          "    write!(f, \"{:?}-{:?} => {:?}\", start, end, target)?; // Ensure formatted write succeeds for first range (empty case)",
          "    assert_eq!(output, \"\"); // Output should be empty as ranges is empty and i == 0",
          "    Ok(()) // Verify expected return value from fmt is Ok(()) for the empty ranges case",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]