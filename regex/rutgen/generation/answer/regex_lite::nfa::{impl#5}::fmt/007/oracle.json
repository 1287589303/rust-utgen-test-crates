[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let targets: Vec<u32> = vec![1, 2, 3];",
          "    let reverse = true;",
          "    let state = State::Splits { targets, reverse };",
          "",
          "    let mut buffer = String::new();",
          "    let f = &mut core::fmt::Formatter::new(&mut buffer);",
          "    let _ = state.fmt(f);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"splits(\")? == Ok",
          "    ",
          "    let targets = vec![1, 2, 3];",
          "    ",
          "    let reverse = true;",
          "    ",
          "    let state = State::Splits { targets, reverse };",
          "    ",
          "    State::iter_splits(&targets, reverse).enumerate() == true",
          "    ",
          "    i > 0 == true",
          "    ",
          "    write!(f, \", \")? == Err",
          "    ",
          "    buffer.is_empty() == false",
          "    ",
          "    buffer.contains(\"splits\") == true",
          "    ",
          "    buffer.contains(\", \") == true",
          "    ",
          "    buffer.contains(\"1\") == true",
          "    ",
          "    buffer.contains(\"2\") == true",
          "    ",
          "    buffer.contains(\"3\") == true"
        ],
        "code": [
          "{",
          "    let targets: Vec<u32> = vec![1, 2, 3];",
          "    let reverse = true;",
          "    let state = State::Splits { targets, reverse };",
          "",
          "    let mut buffer = String::new();",
          "    let f = &mut core::fmt::Formatter::new(&mut buffer);",
          "    let _ = state.fmt(f);",
          "    write!(f, \"splits(\")? == Ok",
          "    ",
          "    let targets = vec![1, 2, 3];",
          "    ",
          "    let reverse = true;",
          "    ",
          "    let state = State::Splits { targets, reverse };",
          "    ",
          "    State::iter_splits(&targets, reverse).enumerate() == true",
          "    ",
          "    i > 0 == true",
          "    ",
          "    write!(f, \", \")? == Err",
          "    ",
          "    buffer.is_empty() == false",
          "    ",
          "    buffer.contains(\"splits\") == true",
          "    ",
          "    buffer.contains(\", \") == true",
          "    ",
          "    buffer.contains(\"1\") == true",
          "    ",
          "    buffer.contains(\"2\") == true",
          "    ",
          "    buffer.contains(\"3\") == true",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let targets: Vec<u32> = vec![4, 5];",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "",
          "    let mut buffer = String::new();",
          "    let f = &mut core::fmt::Formatter::new(&mut buffer);",
          "    let _ = state.fmt(f);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state, State::Splits { targets: vec![4, 5], reverse: false });",
          "    assert!(write!(f, \"splits(\").is_ok());",
          "    assert!(State::iter_splits(&targets, reverse).enumerate().next().is_some());",
          "    assert!(i > 0);",
          "    assert!(write!(f, \", \").is_err());"
        ],
        "code": [
          "{",
          "    let targets: Vec<u32> = vec![4, 5];",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "",
          "    let mut buffer = String::new();",
          "    let f = &mut core::fmt::Formatter::new(&mut buffer);",
          "    let _ = state.fmt(f);",
          "    assert_eq!(state, State::Splits { targets: vec![4, 5], reverse: false });",
          "    assert!(write!(f, \"splits(\").is_ok());",
          "    assert!(State::iter_splits(&targets, reverse).enumerate().next().is_some());",
          "    assert!(i > 0);",
          "    assert!(write!(f, \", \").is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let targets: Vec<u32> = vec![]; ",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "",
          "    let mut buffer = String::new();",
          "    let f = &mut core::fmt::Formatter::new(&mut buffer);",
          "    let _ = state.fmt(f);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state, State::Splits { targets, reverse });",
          "    assert!(matches!(f.write_str(\"splits(\"), Ok(_)));",
          "    assert!(state.iter_splits(&targets, reverse).enumerate().count() > 0);",
          "    assert!(i > 0);",
          "    assert!(matches!(f.write_str(\", \"), Err(_)));"
        ],
        "code": [
          "{",
          "    let targets: Vec<u32> = vec![]; ",
          "    let reverse = false;",
          "    let state = State::Splits { targets, reverse };",
          "",
          "    let mut buffer = String::new();",
          "    let f = &mut core::fmt::Formatter::new(&mut buffer);",
          "    let _ = state.fmt(f);",
          "    assert_eq!(state, State::Splits { targets, reverse });",
          "    assert!(matches!(f.write_str(\"splits(\"), Ok(_)));",
          "    assert!(state.iter_splits(&targets, reverse).enumerate().count() > 0);",
          "    assert!(i > 0);",
          "    assert!(matches!(f.write_str(\", \"), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]