[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Match;",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    write!(formatter, \"MATCH\").unwrap();",
          "    assert_eq!(buffer, \"MATCH\");"
        ],
        "code": [
          "{",
          "    let state = State::Match;",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    write!(formatter, \"MATCH\").unwrap();",
          "    assert_eq!(buffer, \"MATCH\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Fail;",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    write!(formatter, \"FAIL\").unwrap();",
          "    assert_eq!(buffer, \"FAIL\");"
        ],
        "code": [
          "{",
          "    let state = State::Fail;",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    write!(formatter, \"FAIL\").unwrap();",
          "    assert_eq!(buffer, \"FAIL\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Char { target: 1, ch: 'a' };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    let state = State::Match;",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    assert_eq!(state.fmt(formatter).unwrap(), Ok(()));",
          "    assert_eq!(buffer, \"MATCH\");"
        ],
        "code": [
          "{",
          "    let state = State::Char { target: 1, ch: 'a' };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    let state = State::Match;",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    assert_eq!(state.fmt(formatter).unwrap(), Ok(()));",
          "    assert_eq!(buffer, \"MATCH\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Ranges { target: 1, ranges: vec![('a', 'c'), ('d', 'f')] };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    write!(formatter, \"splits(\")?;",
          "    write!(formatter, \"{:?}-{:?} => {:?}\", 'a', 'c', 1)?;",
          "    write!(formatter, \"{:?}-{:?} => {:?}\", 'd', 'f', 1)?;",
          "    write!(formatter, \")\")"
        ],
        "code": [
          "{",
          "    let state = State::Ranges { target: 1, ranges: vec![('a', 'c'), ('d', 'f')] };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    write!(formatter, \"splits(\")?;",
          "    write!(formatter, \"{:?}-{:?} => {:?}\", 'a', 'c', 1)?;",
          "    write!(formatter, \"{:?}-{:?} => {:?}\", 'd', 'f', 1)?;",
          "    write!(formatter, \")\")",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Splits { targets: vec![1, 2, 3], reverse: false };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    write!(formatter, \"splits(1, 2, 3)\") == Ok(())",
          "    write!(formatter, \"goto(2)\") == Ok(())",
          "    write!(formatter, \"capture(slot=0) => 1\") == Ok(())",
          "    write!(formatter, \"FAIL\") == Ok(())",
          "    write!(formatter, \"MATCH\") == Ok(())"
        ],
        "code": [
          "{",
          "    let state = State::Splits { targets: vec![1, 2, 3], reverse: false };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    write!(formatter, \"splits(1, 2, 3)\") == Ok(())",
          "    write!(formatter, \"goto(2)\") == Ok(())",
          "    write!(formatter, \"capture(slot=0) => 1\") == Ok(())",
          "    write!(formatter, \"FAIL\") == Ok(())",
          "    write!(formatter, \"MATCH\") == Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Goto { target: 1, look: None };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(buffer, \"goto(1)\");",
          "    assert!(buffer.contains(\"goto\"));",
          "    assert!(buffer.ends_with(\")\"));",
          "    assert!(buffer.len() > 0);",
          "    assert!(buffer.contains(\", \") == false);"
        ],
        "code": [
          "{",
          "    let state = State::Goto { target: 1, look: None };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    assert_eq!(buffer, \"goto(1)\");",
          "    assert!(buffer.contains(\"goto\"));",
          "    assert!(buffer.ends_with(\")\"));",
          "    assert!(buffer.len() > 0);",
          "    assert!(buffer.contains(\", \") == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Goto { target: 1, look: Some(Look::Start) };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    write!(formatter, \"goto({:?})\", 1).unwrap();",
          "    write!(formatter, \"{:?} => {:?}\", Look::Start, 1).unwrap();",
          "    assert_eq!(buffer, \"goto(1)\");",
          "    buffer.clear();",
          "    state = State::Match;",
          "    state.fmt(formatter).unwrap();",
          "    assert_eq!(buffer, \"MATCH\");",
          "    buffer.clear();",
          "    state = State::Fail;",
          "    state.fmt(formatter).unwrap();",
          "    assert_eq!(buffer, \"FAIL\");"
        ],
        "code": [
          "{",
          "    let state = State::Goto { target: 1, look: Some(Look::Start) };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    write!(formatter, \"goto({:?})\", 1).unwrap();",
          "    write!(formatter, \"{:?} => {:?}\", Look::Start, 1).unwrap();",
          "    assert_eq!(buffer, \"goto(1)\");",
          "    buffer.clear();",
          "    state = State::Match;",
          "    state.fmt(formatter).unwrap();",
          "    assert_eq!(buffer, \"MATCH\");",
          "    buffer.clear();",
          "    state = State::Fail;",
          "    state.fmt(formatter).unwrap();",
          "    assert_eq!(buffer, \"FAIL\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State::Capture { target: 1, slot: 0 };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "}"
        ],
        "oracle": [
          "    write!(f, \"capture(slot={:?}) => {:?}\", 0, 1)",
          "    write!(f, \"MATCH\")",
          "    write!(f, \"FAIL\")",
          "    write!(f, \"{:?} => {:?}\", look_value, target_value)",
          "    write!(f, \"{:?}-{:?} => {:?}\", start_value, end_value, target_value)",
          "    write!(f, \"splits({:?})\", sid_value)",
          "    write!(f, \"goto({:?})\", target_value)"
        ],
        "code": [
          "{",
          "    let state = State::Capture { target: 1, slot: 0 };",
          "    let mut buffer = String::new();",
          "    let formatter = &mut core::fmt::Formatter::new(&mut buffer);",
          "    state.fmt(formatter).unwrap();",
          "    write!(f, \"capture(slot={:?}) => {:?}\", 0, 1)",
          "    write!(f, \"MATCH\")",
          "    write!(f, \"FAIL\")",
          "    write!(f, \"{:?} => {:?}\", look_value, target_value)",
          "    write!(f, \"{:?}-{:?} => {:?}\", start_value, end_value, target_value)",
          "    write!(f, \"splits({:?})\", sid_value)",
          "    write!(f, \"goto({:?})\", target_value)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]