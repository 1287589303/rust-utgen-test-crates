[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class.clone())),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_unicode];",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Class::Unicode(unicode_class)));"
        ],
        "code": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class.clone())),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_unicode];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(unicode_class)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x7A }]); ",
          "    let unicode_class = byte_class.to_unicode_class().unwrap();",
          "    ",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_bytes];",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Class::Unicode(unicode_class)));"
        ],
        "code": [
          "{",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x61, end: 0x7A }]); ",
          "    let unicode_class = byte_class.to_unicode_class().unwrap();",
          "    ",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(unicode_class)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]); ",
          "    let unicode_from_bytes = byte_class.to_unicode_class().unwrap();",
          "    ",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_unicode, hir_bytes];",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]);",
          "    let unicode_from_bytes = byte_class.to_unicode_class().unwrap();",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(byte_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode, hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]))));",
          "    ",
          "    let empty_hirs = vec![];",
          "    let empty_result = class_chars(&empty_hirs);",
          "    assert_eq!(empty_result, Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    ",
          "    let invalid_hir = Hir {",
          "    kind: HirKind::Literal(Literal::new(\"test\")),",
          "    props: Properties::default(),",
          "    };",
          "    let invalid_hirs = vec![hir_unicode, invalid_hir];",
          "    let invalid_result = class_chars(&invalid_hirs);",
          "    assert_eq!(invalid_result, None);",
          "    ",
          "    let non_ascii_byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x80, end: 0xFF }]);",
          "    let non_ascii_hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(non_ascii_byte_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let non_ascii_hirs = vec![hir_unicode, non_ascii_hir_bytes];",
          "    let non_ascii_result = class_chars(&non_ascii_hirs);",
          "    assert_eq!(non_ascii_result, None);",
          "    ",
          "    let complex_hirs = vec![hir_unicode, hir_bytes.clone(), invalid_hir.clone()];",
          "    let complex_result = class_chars(&complex_hirs);",
          "    assert_eq!(complex_result, None);"
        ],
        "code": [
          "{",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]); ",
          "    let unicode_from_bytes = byte_class.to_unicode_class().unwrap();",
          "    ",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_unicode, hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x41, end: 0x5A }]);",
          "    let unicode_from_bytes = byte_class.to_unicode_class().unwrap();",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(Class::Unicode(unicode_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(byte_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode, hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]))));",
          "    ",
          "    let empty_hirs = vec![];",
          "    let empty_result = class_chars(&empty_hirs);",
          "    assert_eq!(empty_result, Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    ",
          "    let invalid_hir = Hir {",
          "    kind: HirKind::Literal(Literal::new(\"test\")),",
          "    props: Properties::default(),",
          "    };",
          "    let invalid_hirs = vec![hir_unicode, invalid_hir];",
          "    let invalid_result = class_chars(&invalid_hirs);",
          "    assert_eq!(invalid_result, None);",
          "    ",
          "    let non_ascii_byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x80, end: 0xFF }]);",
          "    let non_ascii_hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(non_ascii_byte_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let non_ascii_hirs = vec![hir_unicode, non_ascii_hir_bytes];",
          "    let non_ascii_result = class_chars(&non_ascii_hirs);",
          "    assert_eq!(non_ascii_result, None);",
          "    ",
          "    let complex_hirs = vec![hir_unicode, hir_bytes.clone(), invalid_hir.clone()];",
          "    let complex_result = class_chars(&complex_hirs);",
          "    assert_eq!(complex_result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_class1 = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let unicode_class2 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]);",
          "    let unicode_from_byte_class = byte_class.to_unicode_class().unwrap();",
          "    ",
          "    let hir_unicode1 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class1)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir_unicode2 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class2)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_unicode1, hir_unicode2, hir_bytes];",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let unicode_class1 = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let unicode_class2 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]);",
          "    let unicode_from_byte_class = byte_class.to_unicode_class().unwrap();",
          "    let hir_unicode1 = Hir { kind: HirKind::Class(Class::Unicode(unicode_class1)), props: Properties::default(), };",
          "    let hir_unicode2 = Hir { kind: HirKind::Class(Class::Unicode(unicode_class2)), props: Properties::default(), };",
          "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(byte_class)), props: Properties::default(), };",
          "    let hirs = vec![hir_unicode1, hir_unicode2, hir_bytes];",
          "    assert_eq!(class_chars(&hirs), Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }, ClassUnicodeRange { start: 'a', end: 'f' }]))));"
        ],
        "code": [
          "{",
          "    let unicode_class1 = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let unicode_class2 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]);",
          "    let unicode_from_byte_class = byte_class.to_unicode_class().unwrap();",
          "    ",
          "    let hir_unicode1 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class1)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir_unicode2 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(unicode_class2)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(byte_class)),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let hirs = vec![hir_unicode1, hir_unicode2, hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    let unicode_class1 = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let unicode_class2 = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'f' }]);",
          "    let byte_class = ClassBytes::new(vec![ClassBytesRange { start: 0x30, end: 0x39 }]);",
          "    let unicode_from_byte_class = byte_class.to_unicode_class().unwrap();",
          "    let hir_unicode1 = Hir { kind: HirKind::Class(Class::Unicode(unicode_class1)), props: Properties::default(), };",
          "    let hir_unicode2 = Hir { kind: HirKind::Class(Class::Unicode(unicode_class2)), props: Properties::default(), };",
          "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(byte_class)), props: Properties::default(), };",
          "    let hirs = vec![hir_unicode1, hir_unicode2, hir_bytes];",
          "    assert_eq!(class_chars(&hirs), Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }, ClassUnicodeRange { start: 'a', end: 'f' }]))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]