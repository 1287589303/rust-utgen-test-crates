[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_range = ClassUnicodeRange { start: 'a', end: 'z' };",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(class_unicode)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode];",
          "    let _ = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let unicode_range = ClassUnicodeRange { start: 'a', end: 'z' };",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(Class::Unicode(class_unicode)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), Class::Unicode(class_unicode));",
          "    ",
          "    let empty_bytes_class = ClassBytes::empty();",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(empty_bytes_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_none());",
          "    ",
          "    let unicode_range_invalid = ClassUnicodeRange { start: 'z', end: 'a' };",
          "    let class_unicode_invalid = ClassUnicode::new(vec![unicode_range_invalid]);",
          "    let hir_unicode_invalid = Hir {",
          "    kind: HirKind::Class(Class::Unicode(class_unicode_invalid)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode_invalid];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_some());",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
          "    let hir_bytes_invalid = Hir {",
          "    kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes_invalid];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_some());"
        ],
        "code": [
          "{",
          "    let unicode_range = ClassUnicodeRange { start: 'a', end: 'z' };",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
          "    let hir_unicode = Hir {",
          "        kind: HirKind::Class(Class::Unicode(class_unicode)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode];",
          "    let _ = class_chars(&hirs);",
          "    let unicode_range = ClassUnicodeRange { start: 'a', end: 'z' };",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
          "    let hir_unicode = Hir {",
          "    kind: HirKind::Class(Class::Unicode(class_unicode)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap(), Class::Unicode(class_unicode));",
          "    ",
          "    let empty_bytes_class = ClassBytes::empty();",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(empty_bytes_class)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_none());",
          "    ",
          "    let unicode_range_invalid = ClassUnicodeRange { start: 'z', end: 'a' };",
          "    let class_unicode_invalid = ClassUnicode::new(vec![unicode_range_invalid]);",
          "    let hir_unicode_invalid = Hir {",
          "    kind: HirKind::Class(Class::Unicode(class_unicode_invalid)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_unicode_invalid];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_some());",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
          "    let hir_bytes_invalid = Hir {",
          "    kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes_invalid];",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_bytes = ClassBytes::empty();",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    let _ = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_chars(&hirs), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert!(class_chars(&hirs).is_some());",
          "    assert!(class_chars(&hirs).unwrap().is_unicode());",
          "    assert_eq!(class_chars(&hirs).unwrap().minimum_len(), None);",
          "    assert_eq!(class_chars(&hirs).unwrap().maximum_len(), None);",
          "    assert!(class_chars(&hirs).unwrap().literal().is_none());",
          "    assert!(class_chars(&hirs).unwrap().ranges().is_empty());"
        ],
        "code": [
          "{",
          "    let class_bytes = ClassBytes::empty();",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    let _ = class_chars(&hirs);",
          "    assert_eq!(class_chars(&hirs), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert!(class_chars(&hirs).is_some());",
          "    assert!(class_chars(&hirs).unwrap().is_unicode());",
          "    assert_eq!(class_chars(&hirs).unwrap().minimum_len(), None);",
          "    assert_eq!(class_chars(&hirs).unwrap().maximum_len(), None);",
          "    assert!(class_chars(&hirs).unwrap().literal().is_none());",
          "    assert!(class_chars(&hirs).unwrap().ranges().is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let unicode_range1 = ClassUnicodeRange { start: 'a', end: 'f' };",
          "    let class_unicode1 = ClassUnicode::new(vec![unicode_range1]);",
          "",
          "    let unicode_range2 = ClassUnicodeRange { start: 'g', end: 'z' };",
          "    let class_unicode2 = ClassUnicode::new(vec![unicode_range2]);",
          "",
          "    let hir_unicode1 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(class_unicode1)),",
          "        props: Properties::default(),",
          "    };",
          "    let hir_unicode2 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(class_unicode2)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs = vec![hir_unicode1, hir_unicode2];",
          "    let _ = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let unicode_range1 = ClassUnicodeRange { start: 'a', end: 'f' };",
          "    let class_unicode1 = ClassUnicode::new(vec![unicode_range1]);",
          "    let unicode_range2 = ClassUnicodeRange { start: 'g', end: 'z' };",
          "    let class_unicode2 = ClassUnicode::new(vec![unicode_range2]);",
          "    let hir_unicode1 = Hir { kind: HirKind::Class(Class::Unicode(class_unicode1)), props: Properties::default() };",
          "    let hir_unicode2 = Hir { kind: HirKind::Class(Class::Unicode(class_unicode2)), props: Properties::default() };",
          "    let hirs = vec![hir_unicode1, hir_unicode2];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]))));",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
          "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), props: Properties::default() };",
          "    let hirs = vec![hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let class_bytes_no_unicode = ClassBytes::new(vec![ClassBytesRange { start: 256, end: 300 }]);",
          "    let hir_bytes_no_unicode = Hir { kind: HirKind::Class(Class::Bytes(class_bytes_no_unicode)), props: Properties::default() };",
          "    let hirs = vec![hir_bytes_no_unicode];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() };",
          "    let hirs = vec![empty_hir];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let class_bytes_invalid = ClassBytes::new(vec![]);",
          "    let hir_invalid_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes_invalid)), props: Properties::default() };",
          "    let hirs = vec![hir_invalid_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);"
        ],
        "code": [
          "{",
          "    let unicode_range1 = ClassUnicodeRange { start: 'a', end: 'f' };",
          "    let class_unicode1 = ClassUnicode::new(vec![unicode_range1]);",
          "",
          "    let unicode_range2 = ClassUnicodeRange { start: 'g', end: 'z' };",
          "    let class_unicode2 = ClassUnicode::new(vec![unicode_range2]);",
          "",
          "    let hir_unicode1 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(class_unicode1)),",
          "        props: Properties::default(),",
          "    };",
          "    let hir_unicode2 = Hir {",
          "        kind: HirKind::Class(Class::Unicode(class_unicode2)),",
          "        props: Properties::default(),",
          "    };",
          "",
          "    let hirs = vec![hir_unicode1, hir_unicode2];",
          "    let _ = class_chars(&hirs);",
          "    let unicode_range1 = ClassUnicodeRange { start: 'a', end: 'f' };",
          "    let class_unicode1 = ClassUnicode::new(vec![unicode_range1]);",
          "    let unicode_range2 = ClassUnicodeRange { start: 'g', end: 'z' };",
          "    let class_unicode2 = ClassUnicode::new(vec![unicode_range2]);",
          "    let hir_unicode1 = Hir { kind: HirKind::Class(Class::Unicode(class_unicode1)), props: Properties::default() };",
          "    let hir_unicode2 = Hir { kind: HirKind::Class(Class::Unicode(class_unicode2)), props: Properties::default() };",
          "    let hirs = vec![hir_unicode1, hir_unicode2];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]))));",
          "    ",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
          "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), props: Properties::default() };",
          "    let hirs = vec![hir_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let class_bytes_no_unicode = ClassBytes::new(vec![ClassBytesRange { start: 256, end: 300 }]);",
          "    let hir_bytes_no_unicode = Hir { kind: HirKind::Class(Class::Bytes(class_bytes_no_unicode)), props: Properties::default() };",
          "    let hirs = vec![hir_bytes_no_unicode];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() };",
          "    let hirs = vec![empty_hir];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);",
          "    ",
          "    let class_bytes_invalid = ClassBytes::new(vec![]);",
          "    let hir_invalid_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes_invalid)), props: Properties::default() };",
          "    let hirs = vec![hir_invalid_bytes];",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 256, end: 255 }]);",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    let _ = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 256, end: 255 }]);",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    assert_eq!(class_chars(&hirs), None);"
        ],
        "code": [
          "{",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 256, end: 255 }]);",
          "    let hir_bytes = Hir {",
          "        kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "        props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    let _ = class_chars(&hirs);",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 256, end: 255 }]);",
          "    let hir_bytes = Hir {",
          "    kind: HirKind::Class(Class::Bytes(class_bytes)),",
          "    props: Properties::default(),",
          "    };",
          "    let hirs = vec![hir_bytes];",
          "    assert_eq!(class_chars(&hirs), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]