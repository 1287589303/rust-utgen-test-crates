[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_unicode_class(ranges: Vec<ClassUnicodeRange>) -> Hir {",
          "            let cls_unicode = ClassUnicode::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_bytes_class(ranges: Vec<ClassBytesRange>) -> Hir {",
          "            let cls_bytes = ClassBytes::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'a', end: 'z' }]),",
          "        TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x61, end: 0x7A }]), // ASCII for 'a' to 'z'",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]))));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    assert!(matches!(result, Some(Class::Bytes(_))));",
          "    assert!(result.unwrap().is_ascii());",
          "    assert!(matches!(result, Some(Class::Unicode(cls)) if cls.minimum_len().is_some()));",
          "    assert!(matches!(result, Some(Class::Unicode(cls)) if cls.maximum_len().is_some()));",
          "    assert!(result.unwrap().literal().is_none());",
          "    assert!(result.unwrap().iter().count() > 0);",
          "    assert!(result.unwrap().ranges().len() > 0);"
        ],
        "code": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_unicode_class(ranges: Vec<ClassUnicodeRange>) -> Hir {",
          "            let cls_unicode = ClassUnicode::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_bytes_class(ranges: Vec<ClassBytesRange>) -> Hir {",
          "            let cls_bytes = ClassBytes::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'a', end: 'z' }]),",
          "        TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x61, end: 0x7A }]), // ASCII for 'a' to 'z'",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]))));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    assert!(matches!(result, Some(Class::Bytes(_))));",
          "    assert!(result.unwrap().is_ascii());",
          "    assert!(matches!(result, Some(Class::Unicode(cls)) if cls.minimum_len().is_some()));",
          "    assert!(matches!(result, Some(Class::Unicode(cls)) if cls.maximum_len().is_some()));",
          "    assert!(result.unwrap().literal().is_none());",
          "    assert!(result.unwrap().iter().count() > 0);",
          "    assert!(result.unwrap().ranges().len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_bytes_class(ranges: Vec<ClassBytesRange>) -> Hir {",
          "            let cls_bytes = ClassBytes::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x20, end: 0x7E }]), // ASCII printable characters",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: '0', end: '9' }]), // Unicode range",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode { /* expected properties */ })));",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges().len(), 2);",
          "    assert!(result.unwrap().is_ascii());",
          "    assert_eq!(result.unwrap().minimum_len(), Some(1));",
          "    assert_eq!(result.unwrap().maximum_len(), Some(2));",
          "    assert!(result.unwrap().literal().is_none());"
        ],
        "code": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_bytes_class(ranges: Vec<ClassBytesRange>) -> Hir {",
          "            let cls_bytes = ClassBytes::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x20, end: 0x7E }]), // ASCII printable characters",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: '0', end: '9' }]), // Unicode range",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode { /* expected properties */ })));",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges().len(), 2);",
          "    assert!(result.unwrap().is_ascii());",
          "    assert_eq!(result.unwrap().minimum_len(), Some(1));",
          "    assert_eq!(result.unwrap().maximum_len(), Some(2));",
          "    assert!(result.unwrap().literal().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_unicode_class(ranges: Vec<ClassUnicodeRange>) -> Hir {",
          "            let cls_unicode = ClassUnicode::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_bytes_class(ranges: Vec<ClassBytesRange>) -> Hir {",
          "            let cls_bytes = ClassBytes::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "        TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x41, end: 0x5A }]), // ASCII for 'A' to 'Z'",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: '!', end: '/' }]),",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs_empty: Vec<Hir> = vec![];",
          "    let result_empty = class_chars(&hirs_empty);",
          "    assert_eq!(result_empty, None);",
          "    ",
          "    let hirs_missing: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "    Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result_missing = class_chars(&hirs_missing);",
          "    assert_eq!(result_missing, None);",
          "    ",
          "    let hirs_unicode_only: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'a', end: 'z' }]),",
          "    ];",
          "    let result_unicode_only = class_chars(&hirs_unicode_only);",
          "    assert!(result_unicode_only.is_some());",
          "    if let Some(Class::Unicode(cls)) = result_unicode_only {",
          "    assert_eq!(cls.ranges().len(), 2);",
          "    }",
          "    ",
          "    let hirs_mixed: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "    TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x41, end: 0x5A }]),",
          "    ];",
          "    let result_mixed = class_chars(&hirs_mixed);",
          "    assert!(result_mixed.is_some());",
          "    if let Some(Class::Unicode(cls)) = result_mixed {",
          "    assert!(cls.is_ascii());",
          "    }",
          "    ",
          "    let hirs_unicode_and_empty_bytes: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: '0', end: '9' }]),",
          "    TestHir::new_bytes_class(vec![]),",
          "    ];",
          "    let result_unicode_and_empty_bytes = class_chars(&hirs_unicode_and_empty_bytes);",
          "    assert!(result_unicode_and_empty_bytes.is_some());",
          "    if let Some(Class::Unicode(cls)) = result_unicode_and_empty_bytes {",
          "    assert_eq!(cls.ranges().len(), 1);",
          "    }"
        ],
        "code": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_unicode_class(ranges: Vec<ClassUnicodeRange>) -> Hir {",
          "            let cls_unicode = ClassUnicode::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_bytes_class(ranges: Vec<ClassBytesRange>) -> Hir {",
          "            let cls_bytes = ClassBytes::new(ranges);",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "        TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x41, end: 0x5A }]), // ASCII for 'A' to 'Z'",
          "        TestHir::new_unicode_class(vec![ClassUnicodeRange { start: '!', end: '/' }]),",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "    let hirs_empty: Vec<Hir> = vec![];",
          "    let result_empty = class_chars(&hirs_empty);",
          "    assert_eq!(result_empty, None);",
          "    ",
          "    let hirs_missing: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "    Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result_missing = class_chars(&hirs_missing);",
          "    assert_eq!(result_missing, None);",
          "    ",
          "    let hirs_unicode_only: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'a', end: 'z' }]),",
          "    ];",
          "    let result_unicode_only = class_chars(&hirs_unicode_only);",
          "    assert!(result_unicode_only.is_some());",
          "    if let Some(Class::Unicode(cls)) = result_unicode_only {",
          "    assert_eq!(cls.ranges().len(), 2);",
          "    }",
          "    ",
          "    let hirs_mixed: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]),",
          "    TestHir::new_bytes_class(vec![ClassBytesRange { start: 0x41, end: 0x5A }]),",
          "    ];",
          "    let result_mixed = class_chars(&hirs_mixed);",
          "    assert!(result_mixed.is_some());",
          "    if let Some(Class::Unicode(cls)) = result_mixed {",
          "    assert!(cls.is_ascii());",
          "    }",
          "    ",
          "    let hirs_unicode_and_empty_bytes: Vec<Hir> = vec![",
          "    TestHir::new_unicode_class(vec![ClassUnicodeRange { start: '0', end: '9' }]),",
          "    TestHir::new_bytes_class(vec![]),",
          "    ];",
          "    let result_unicode_and_empty_bytes = class_chars(&hirs_unicode_and_empty_bytes);",
          "    assert!(result_unicode_and_empty_bytes.is_some());",
          "    if let Some(Class::Unicode(cls)) = result_unicode_and_empty_bytes {",
          "    assert_eq!(cls.ranges().len(), 1);",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_empty_unicode_class() -> Hir {",
          "            let cls_unicode = ClassUnicode::empty();",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_empty_bytes_class() -> Hir {",
          "            let cls_bytes = ClassBytes::empty();",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_empty_unicode_class(),",
          "        TestHir::new_empty_bytes_class(),",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    assert_eq!(class_chars(&vec![TestHir::new_empty_unicode_class()]), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert_eq!(class_chars(&vec![TestHir::new_empty_bytes_class()]), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert_eq!(class_chars(&vec![TestHir::new_empty_unicode_class(), TestHir::new_empty_bytes_class()]), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert!(class_chars(&Vec::<Hir>::new()).is_none());"
        ],
        "code": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_empty_unicode_class() -> Hir {",
          "            let cls_unicode = ClassUnicode::empty();",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_empty_bytes_class() -> Hir {",
          "            let cls_bytes = ClassBytes::empty();",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_empty_unicode_class(),",
          "        TestHir::new_empty_bytes_class(),",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "    assert_eq!(result, Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    assert_eq!(class_chars(&vec![TestHir::new_empty_unicode_class()]), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert_eq!(class_chars(&vec![TestHir::new_empty_bytes_class()]), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert_eq!(class_chars(&vec![TestHir::new_empty_unicode_class(), TestHir::new_empty_bytes_class()]), Some(Class::Unicode(ClassUnicode::new(vec![]))));",
          "    assert!(class_chars(&Vec::<Hir>::new()).is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_full_unicode_class() -> Hir {",
          "            let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\u{0000}', end: '\\u{10FFFF}' }]); // Full Unicode range",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_full_bytes_class() -> Hir {",
          "            let cls_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0xFF }]); // All byte values",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_full_unicode_class(),",
          "        TestHir::new_full_bytes_class(),",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    let unicode_class = if let Some(Class::Unicode(ref cls)) = result { cls } else { panic!(\"Expected a Unicode class\") };",
          "    assert_eq!(unicode_class.ranges().len(), 1);",
          "    assert_eq!(unicode_class.ranges()[0].start, '\\u{0000}');",
          "    assert_eq!(unicode_class.ranges()[0].end, '\\u{10FFFF}');",
          "    assert!(unicode_class.is_ascii() == false);"
        ],
        "code": [
          "{",
          "    struct TestHir {",
          "        kind: HirKind,",
          "    }",
          "",
          "    impl TestHir {",
          "        fn new_full_unicode_class() -> Hir {",
          "            let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\u{0000}', end: '\\u{10FFFF}' }]); // Full Unicode range",
          "            Hir {",
          "                kind: HirKind::Class(Class::Unicode(cls_unicode)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "",
          "        fn new_full_bytes_class() -> Hir {",
          "            let cls_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0x00, end: 0xFF }]); // All byte values",
          "            Hir {",
          "                kind: HirKind::Class(Class::Bytes(cls_bytes)),",
          "                props: Properties::default(),",
          "            }",
          "        }",
          "    }",
          "",
          "    let hirs: Vec<Hir> = vec![",
          "        TestHir::new_full_unicode_class(),",
          "        TestHir::new_full_bytes_class(),",
          "    ];",
          "",
          "    let result = class_chars(&hirs);",
          "    assert!(result.is_some());",
          "    assert!(matches!(result, Some(Class::Unicode(_))));",
          "    let unicode_class = if let Some(Class::Unicode(ref cls)) = result { cls } else { panic!(\"Expected a Unicode class\") };",
          "    assert_eq!(unicode_class.ranges().len(), 1);",
          "    assert_eq!(unicode_class.ranges()[0].start, '\\u{0000}');",
          "    assert_eq!(unicode_class.ranges()[0].end, '\\u{10FFFF}');",
          "    assert!(unicode_class.is_ascii() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]