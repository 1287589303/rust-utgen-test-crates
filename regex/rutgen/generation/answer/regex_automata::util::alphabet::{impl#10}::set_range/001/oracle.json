[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(1, 1);",
          "}"
        ],
        "oracle": [
          "    byte_class_set.set_range(1, 1);",
          "    assert_eq!(byte_class_set.0.contains(0), true);",
          "    assert_eq!(byte_class_set.0.contains(1), true);",
          "    assert_eq!(byte_class_set.0.contains(2), false);",
          "    assert_eq!(byte_class_set.0.is_empty(), false);",
          "    byte_class_set.set_range(2, 3);",
          "    assert_eq!(byte_class_set.0.contains(2), true);",
          "    assert_eq!(byte_class_set.0.contains(3), true);",
          "    assert_eq!(byte_class_set.0.contains(1), true);",
          "    assert_eq!(byte_class_set.0.contains(4), false);"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(1, 1);",
          "    byte_class_set.set_range(1, 1);",
          "    assert_eq!(byte_class_set.0.contains(0), true);",
          "    assert_eq!(byte_class_set.0.contains(1), true);",
          "    assert_eq!(byte_class_set.0.contains(2), false);",
          "    assert_eq!(byte_class_set.0.is_empty(), false);",
          "    byte_class_set.set_range(2, 3);",
          "    assert_eq!(byte_class_set.0.contains(2), true);",
          "    assert_eq!(byte_class_set.0.contains(3), true);",
          "    assert_eq!(byte_class_set.0.contains(1), true);",
          "    assert_eq!(byte_class_set.0.contains(4), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(100, 100);",
          "}"
        ],
        "oracle": [
          "    assert!(byte_class_set.0.contains(100));",
          "    assert!(byte_class_set.0.contains(99));",
          "    assert!(!byte_class_set.0.contains(101));",
          "    assert!(byte_class_set.0.is_empty() == false);",
          "    assert!(byte_class_set.0.contains_range(100, 100));",
          "    assert!(byte_class_set.0.contains_range(99, 101));",
          "    assert!(byte_class_set.0.contains_range(98, 101));",
          "    assert!(byte_class_set.0.contains_range(100, 99) == false);"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(100, 100);",
          "    assert!(byte_class_set.0.contains(100));",
          "    assert!(byte_class_set.0.contains(99));",
          "    assert!(!byte_class_set.0.contains(101));",
          "    assert!(byte_class_set.0.is_empty() == false);",
          "    assert!(byte_class_set.0.contains_range(100, 100));",
          "    assert!(byte_class_set.0.contains_range(99, 101));",
          "    assert!(byte_class_set.0.contains_range(98, 101));",
          "    assert!(byte_class_set.0.contains_range(100, 99) == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(255, 255);",
          "}"
        ],
        "oracle": [
          "    byte_class_set.is_empty() == false",
          "    byte_class_set.0.contains(255) == true",
          "    byte_class_set.0.iter_ranges().count() == 1",
          "    byte_class_set.0.contains_range(255, 255) == true",
          "    byte_class_set.0.contains(254) == false"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(255, 255);",
          "    byte_class_set.is_empty() == false",
          "    byte_class_set.0.contains(255) == true",
          "    byte_class_set.0.iter_ranges().count() == 1",
          "    byte_class_set.0.contains_range(255, 255) == true",
          "    byte_class_set.0.contains(254) == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(20, 100);",
          "}"
        ],
        "oracle": [
          "    assert!(byte_class_set.0.contains(19));",
          "    assert!(byte_class_set.0.contains(100));",
          "    assert!(!byte_class_set.0.contains(18));",
          "    assert!(!byte_class_set.0.contains(101));",
          "    assert!(byte_class_set.0.contains_range(20, 100));",
          "    assert!(!byte_class_set.0.contains_range(19, 101));"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(20, 100);",
          "    assert!(byte_class_set.0.contains(19));",
          "    assert!(byte_class_set.0.contains(100));",
          "    assert!(!byte_class_set.0.contains(18));",
          "    assert!(!byte_class_set.0.contains(101));",
          "    assert!(byte_class_set.0.contains_range(20, 100));",
          "    assert!(!byte_class_set.0.contains_range(19, 101));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(1, 255);",
          "}"
        ],
        "oracle": [
          "    byte_class_set.set_range(1, 1); // precondition: start == end",
          "    byte_class_set.set_range(2, 2); // precondition: start > 0, start == end",
          "    byte_class_set.set_range(1, 255); // precondition: valid range, start > 0",
          "    byte_class_set.set_range(100, 200); // precondition: valid range, start > 0",
          "    byte_class_set.set_range(5, 10); // precondition: valid range, start > 0",
          "    byte_class_set.set_range(10, 10); // precondition: start == end, start > 0"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(1, 255);",
          "    byte_class_set.set_range(1, 1); // precondition: start == end",
          "    byte_class_set.set_range(2, 2); // precondition: start > 0, start == end",
          "    byte_class_set.set_range(1, 255); // precondition: valid range, start > 0",
          "    byte_class_set.set_range(100, 200); // precondition: valid range, start > 0",
          "    byte_class_set.set_range(5, 10); // precondition: valid range, start > 0",
          "    byte_class_set.set_range(10, 10); // precondition: start == end, start > 0",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]