[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(0, 0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(byte_class_set.is_empty(), true);",
          "    assert_eq!(byte_class_set.0.contains(0), false);",
          "    assert_eq!(byte_class_set.0.contains(1), false);",
          "    assert_eq!(byte_class_set.0.contains_range(0, 0), false);",
          "    assert_eq!(byte_class_set.0.contains_range(1, 1), false);"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(0, 0);",
          "    assert_eq!(byte_class_set.is_empty(), true);",
          "    assert_eq!(byte_class_set.0.contains(0), false);",
          "    assert_eq!(byte_class_set.0.contains(1), false);",
          "    assert_eq!(byte_class_set.0.contains_range(0, 0), false);",
          "    assert_eq!(byte_class_set.0.contains_range(1, 1), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(10, 10);",
          "}"
        ],
        "oracle": [
          "    byte_class_set.set_range(0, 0);  // Start and end are equal and start == 0, should not panic",
          "    byte_class_set.set_range(5, 5);  // Valid range, should add bytes correctly",
          "    byte_class_set.set_range(1, 5);  // Valid range, should add start-1 and end correctly",
          "    byte_class_set.set_range(255, 255);  // Edge case, should handle maximum value",
          "    byte_class_set.set_range(0, 255);  // Should handle full range, should add 0 and 255",
          "    byte_class_set.set_range(10, 5);  // Invalid range, should panic due to precondition failure",
          "    byte_class_set.set_range(10, 10);  // Single byte case, should add only byte 10"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(10, 10);",
          "    byte_class_set.set_range(0, 0);  // Start and end are equal and start == 0, should not panic",
          "    byte_class_set.set_range(5, 5);  // Valid range, should add bytes correctly",
          "    byte_class_set.set_range(1, 5);  // Valid range, should add start-1 and end correctly",
          "    byte_class_set.set_range(255, 255);  // Edge case, should handle maximum value",
          "    byte_class_set.set_range(0, 255);  // Should handle full range, should add 0 and 255",
          "    byte_class_set.set_range(10, 5);  // Invalid range, should panic due to precondition failure",
          "    byte_class_set.set_range(10, 10);  // Single byte case, should add only byte 10",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(255, 255);",
          "}"
        ],
        "oracle": [
          "    byte_class_set.set_range(0, 0);",
          "    byte_class_set.set_range(1, 1);",
          "    byte_class_set.set_range(1, 255);",
          "    byte_class_set.set_range(127, 127);",
          "    byte_class_set.set_range(2, 2);"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(255, 255);",
          "    byte_class_set.set_range(0, 0);",
          "    byte_class_set.set_range(1, 1);",
          "    byte_class_set.set_range(1, 255);",
          "    byte_class_set.set_range(127, 127);",
          "    byte_class_set.set_range(2, 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(0, 1);",
          "}"
        ],
        "oracle": [
          "    assert!(byte_class_set.0.contains(1));",
          "    assert!(!byte_class_set.0.contains(0));",
          "    assert!(byte_class_set.0.bits.0.iter().any(|&bit| bit));",
          "    assert_eq!(byte_class_set.0.bits.0[0], 0b00000010);",
          "    assert!(byte_class_set.0.is_empty() == false);",
          "    assert!(byte_class_set.0.contains_range(0, 1));",
          "    assert!(!byte_class_set.0.contains_range(1, 2));"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(0, 1);",
          "    assert!(byte_class_set.0.contains(1));",
          "    assert!(!byte_class_set.0.contains(0));",
          "    assert!(byte_class_set.0.bits.0.iter().any(|&bit| bit));",
          "    assert_eq!(byte_class_set.0.bits.0[0], 0b00000010);",
          "    assert!(byte_class_set.0.is_empty() == false);",
          "    assert!(byte_class_set.0.contains_range(0, 1));",
          "    assert!(!byte_class_set.0.contains_range(1, 2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(0, 255);",
          "}"
        ],
        "oracle": [
          "    byte_class_set.set_range(0, 0); // Test with start and end equal to 0, validating no assertions are triggered",
          "    byte_class_set.set_range(1, 1); // Test with start and end equal, validating the addition of byte 0",
          "    byte_class_set.set_range(2, 2); // Test with start and end equal to 2, ensuring byte 1 is added",
          "    byte_class_set.set_range(100, 100); // Test with start and end equal to 100, ensuring byte 99 is added",
          "    byte_class_set.set_range(255, 255); // Test with start and end equal to 255, ensuring byte 254 is added",
          "    byte_class_set.set_range(0, 255); // Test with full range, ensuring all bytes are added",
          "    byte_class_set.set_range(u8::MAX, u8::MAX); // Test with max value input, ensuring proper bounds handling"
        ],
        "code": [
          "{",
          "    let mut byte_class_set = ByteClassSet::empty();",
          "    byte_class_set.set_range(0, 255);",
          "    byte_class_set.set_range(0, 0); // Test with start and end equal to 0, validating no assertions are triggered",
          "    byte_class_set.set_range(1, 1); // Test with start and end equal, validating the addition of byte 0",
          "    byte_class_set.set_range(2, 2); // Test with start and end equal to 2, ensuring byte 1 is added",
          "    byte_class_set.set_range(100, 100); // Test with start and end equal to 100, ensuring byte 99 is added",
          "    byte_class_set.set_range(255, 255); // Test with start and end equal to 255, ensuring byte 254 is added",
          "    byte_class_set.set_range(0, 255); // Test with full range, ensuring all bytes are added",
          "    byte_class_set.set_range(u8::MAX, u8::MAX); // Test with max value input, ensuring proper bounds handling",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]