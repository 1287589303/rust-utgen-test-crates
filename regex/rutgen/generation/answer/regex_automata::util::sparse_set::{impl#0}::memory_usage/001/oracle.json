[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_sets = SparseSets::new(0);",
          "    let usage = sparse_sets.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let sparse_sets = SparseSets::new(0);",
          "    assert_eq!(usage, 0);",
          "    let sparse_sets = SparseSets::new(10);",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "    sparse_sets.set1.insert(StateID::from(1));",
          "    assert!(sparse_sets.memory_usage() > 0);",
          "    sparse_sets.set2.insert(StateID::from(2));",
          "    assert!(sparse_sets.memory_usage() > sparse_sets.set1.memory_usage());",
          "    sparse_sets.set1.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set2.memory_usage());",
          "    sparse_sets.swap();",
          "    let usage_after_swap = sparse_sets.memory_usage();",
          "    assert_eq!(usage_after_swap, sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());"
        ],
        "code": [
          "{",
          "    let sparse_sets = SparseSets::new(0);",
          "    let usage = sparse_sets.memory_usage();",
          "    let sparse_sets = SparseSets::new(0);",
          "    assert_eq!(usage, 0);",
          "    let sparse_sets = SparseSets::new(10);",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "    sparse_sets.set1.insert(StateID::from(1));",
          "    assert!(sparse_sets.memory_usage() > 0);",
          "    sparse_sets.set2.insert(StateID::from(2));",
          "    assert!(sparse_sets.memory_usage() > sparse_sets.set1.memory_usage());",
          "    sparse_sets.set1.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set2.memory_usage());",
          "    sparse_sets.swap();",
          "    let usage_after_swap = sparse_sets.memory_usage();",
          "    assert_eq!(usage_after_swap, sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(1);",
          "    sparse_sets.set1.insert(0);",
          "    let usage = sparse_sets.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_sets.set1.memory_usage(), expected_usage_set1);",
          "    assert_eq!(sparse_sets.set2.memory_usage(), expected_usage_set2);",
          "    assert_eq!(usage, expected_usage_set1 + expected_usage_set2);",
          "    assert!(usage >= 0);",
          "    assert!(usage.is::<usize>());"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(1);",
          "    sparse_sets.set1.insert(0);",
          "    let usage = sparse_sets.memory_usage();",
          "    assert_eq!(sparse_sets.set1.memory_usage(), expected_usage_set1);",
          "    assert_eq!(sparse_sets.set2.memory_usage(), expected_usage_set2);",
          "    assert_eq!(usage, expected_usage_set1 + expected_usage_set2);",
          "    assert!(usage >= 0);",
          "    assert!(usage.is::<usize>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(1);",
          "    sparse_sets.set2.insert(0);",
          "    let usage = sparse_sets.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let mut sparse_sets = SparseSets::new(1);",
          "    assert_eq!(sparse_sets.memory_usage(), 0);",
          "    sparse_sets.set1.insert(0);",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage());",
          "    sparse_sets.set2.insert(0);",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "    sparse_sets.set2.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage());",
          "    sparse_sets.set1.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), 0);"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(1);",
          "    sparse_sets.set2.insert(0);",
          "    let usage = sparse_sets.memory_usage();",
          "    let mut sparse_sets = SparseSets::new(1);",
          "    assert_eq!(sparse_sets.memory_usage(), 0);",
          "    sparse_sets.set1.insert(0);",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage());",
          "    sparse_sets.set2.insert(0);",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "    sparse_sets.set2.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), sparse_sets.set1.memory_usage());",
          "    sparse_sets.set1.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    for i in 0..5 {",
          "        sparse_sets.set1.insert(i);",
          "    }",
          "    let usage = sparse_sets.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_sets.set1.memory_usage(), sparse_sets.set1.dense.len() * StateID::SIZE + sparse_sets.set1.sparse.len() * StateID::SIZE);",
          "    assert_eq!(sparse_sets.set2.memory_usage(), 0);  // since set2 is empty after initialization",
          "    assert_eq!(usage, sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    for i in 0..5 {",
          "        sparse_sets.set1.insert(i);",
          "    }",
          "    let usage = sparse_sets.memory_usage();",
          "    assert_eq!(sparse_sets.set1.memory_usage(), sparse_sets.set1.dense.len() * StateID::SIZE + sparse_sets.set1.sparse.len() * StateID::SIZE);",
          "    assert_eq!(sparse_sets.set2.memory_usage(), 0);  // since set2 is empty after initialization",
          "    assert_eq!(usage, sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    for i in 5..10 {",
          "        sparse_sets.set2.insert(i);",
          "    }",
          "    let usage = sparse_sets.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let mut sparse_sets = SparseSets::new(10);",
          "    assert_eq!(sparse_sets.memory_usage(), 0);",
          "    for i in 5..10 {",
          "    sparse_sets.set2.insert(i);",
          "    }",
          "    assert_eq!(sparse_sets.set2.len(), 5);",
          "    assert!(sparse_sets.set2.contains(5));",
          "    assert!(sparse_sets.set2.contains(6));",
          "    assert!(sparse_sets.set2.contains(7));",
          "    assert!(sparse_sets.set2.contains(8));",
          "    assert!(sparse_sets.set2.contains(9));",
          "    let usage = sparse_sets.memory_usage();",
          "    assert!(usage > 0);"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    for i in 5..10 {",
          "        sparse_sets.set2.insert(i);",
          "    }",
          "    let usage = sparse_sets.memory_usage();",
          "    let mut sparse_sets = SparseSets::new(10);",
          "    assert_eq!(sparse_sets.memory_usage(), 0);",
          "    for i in 5..10 {",
          "    sparse_sets.set2.insert(i);",
          "    }",
          "    assert_eq!(sparse_sets.set2.len(), 5);",
          "    assert!(sparse_sets.set2.contains(5));",
          "    assert!(sparse_sets.set2.contains(6));",
          "    assert!(sparse_sets.set2.contains(7));",
          "    assert!(sparse_sets.set2.contains(8));",
          "    assert!(sparse_sets.set2.contains(9));",
          "    let usage = sparse_sets.memory_usage();",
          "    assert!(usage > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_sets = SparseSets::new(1000);",
          "    for i in 0..1000 {",
          "        sparse_sets.set1.insert(i);",
          "        sparse_sets.set2.insert(i);",
          "    }",
          "    let usage = sparse_sets.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(usage, sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "    assert!(usage > 0);",
          "    sparse_sets.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), 0);",
          "    sparse_sets.resize(2000);",
          "    assert!(sparse_sets.memory_usage() > 0);"
        ],
        "code": [
          "{",
          "    let mut sparse_sets = SparseSets::new(1000);",
          "    for i in 0..1000 {",
          "        sparse_sets.set1.insert(i);",
          "        sparse_sets.set2.insert(i);",
          "    }",
          "    let usage = sparse_sets.memory_usage();",
          "    assert_eq!(usage, sparse_sets.set1.memory_usage() + sparse_sets.set2.memory_usage());",
          "    assert!(usage > 0);",
          "    sparse_sets.clear();",
          "    assert_eq!(sparse_sets.memory_usage(), 0);",
          "    sparse_sets.resize(2000);",
          "    assert!(sparse_sets.memory_usage() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]