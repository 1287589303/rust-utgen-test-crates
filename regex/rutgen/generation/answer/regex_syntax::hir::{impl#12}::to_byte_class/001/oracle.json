[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![]);",
          "    let result = class_unicode.to_byte_class();",
          "}"
        ],
        "oracle": [
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 97, end: 122 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 65, end: 90 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 48, end: 57 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: ' ', end: ' ' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 32, end: 32 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 0, end: 127 }]);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![]);",
          "    let result = class_unicode.to_byte_class();",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 97, end: 122 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'A', end: 'Z' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 65, end: 90 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '0', end: '9' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 48, end: 57 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: ' ', end: ' ' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 32, end: 32 }]);",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    assert_eq!(result.unwrap().ranges(), vec![ClassBytesRange { start: 0, end: 127 }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
          "    let result = class_unicode.to_byte_class();",
          "}"
        ],
        "oracle": [
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
          "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]));",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
          "    let result = class_unicode.to_byte_class();",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x7F' }]);",
          "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 127 }]));",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: '\\x21', end: '\\x7E' },",
          "        ClassUnicodeRange { start: '\\x00', end: '\\x20' },",
          "    ]);",
          "    let result = class_unicode.to_byte_class();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    let class_bytes = result.unwrap();",
          "    assert_eq!(class_bytes.ranges().len(), 2);",
          "    assert_eq!(class_bytes.ranges()[0].start, 33);",
          "    assert_eq!(class_bytes.ranges()[0].end, 126);",
          "    assert_eq!(class_bytes.ranges()[1].start, 0);",
          "    assert_eq!(class_bytes.ranges()[1].end, 32);",
          "    assert!(class_bytes.is_ascii());"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: '\\x21', end: '\\x7E' },",
          "        ClassUnicodeRange { start: '\\x00', end: '\\x20' },",
          "    ]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    let class_bytes = result.unwrap();",
          "    assert_eq!(class_bytes.ranges().len(), 2);",
          "    assert_eq!(class_bytes.ranges()[0].start, 33);",
          "    assert_eq!(class_bytes.ranges()[0].end, 126);",
          "    assert_eq!(class_bytes.ranges()[1].start, 0);",
          "    assert_eq!(class_bytes.ranges()[1].end, 32);",
          "    assert!(class_bytes.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: '\\x30', end: '\\x39' }, // 0-9",
          "        ClassUnicodeRange { start: '\\x41', end: '\\x5A' }, // A-Z",
          "        ClassUnicodeRange { start: '\\x61', end: '\\x7A' }, // a-z",
          "    ]);",
          "    let result = class_unicode.to_byte_class();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    let class_bytes = result.unwrap();",
          "    let expected_ranges = vec![",
          "    ClassBytesRange { start: 0x30u8, end: 0x39u8 }, // 0-9",
          "    ClassBytesRange { start: 0x41u8, end: 0x5Au8 }, // A-Z",
          "    ClassBytesRange { start: 0x61u8, end: 0x7Au8 }, // a-z",
          "    ];",
          "    assert_eq!(class_bytes.set.intervals(), expected_ranges);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: '\\x30', end: '\\x39' }, // 0-9",
          "        ClassUnicodeRange { start: '\\x41', end: '\\x5A' }, // A-Z",
          "        ClassUnicodeRange { start: '\\x61', end: '\\x7A' }, // a-z",
          "    ]);",
          "    let result = class_unicode.to_byte_class();",
          "    assert!(result.is_some());",
          "    let class_bytes = result.unwrap();",
          "    let expected_ranges = vec![",
          "    ClassBytesRange { start: 0x30u8, end: 0x39u8 }, // 0-9",
          "    ClassBytesRange { start: 0x41u8, end: 0x5Au8 }, // A-Z",
          "    ClassBytesRange { start: 0x61u8, end: 0x7Au8 }, // a-z",
          "    ];",
          "    assert_eq!(class_bytes.set.intervals(), expected_ranges);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: '\\x00', end: '\\x00' }, // Single character range",
          "        ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }, // Single character range",
          "    ]);",
          "    let result = class_unicode.to_byte_class();",
          "}"
        ],
        "oracle": [
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x00' }, ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }]);",
          "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 0 }, ClassBytesRange { start: 127, end: 127 }]));",
          "    assert_eq!(result, expected);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::new(vec![",
          "        ClassUnicodeRange { start: '\\x00', end: '\\x00' }, // Single character range",
          "        ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }, // Single character range",
          "    ]);",
          "    let result = class_unicode.to_byte_class();",
          "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: '\\x00', end: '\\x00' }, ClassUnicodeRange { start: '\\x7F', end: '\\x7F' }]);",
          "    let expected = Some(ClassBytes::new(vec![ClassBytesRange { start: 0, end: 0 }, ClassBytesRange { start: 127, end: 127 }]));",
          "    assert_eq!(result, expected);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]