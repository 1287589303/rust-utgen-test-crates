[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'a', b' ', b'b', b'_', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'b', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'a', b'_', b' ', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'i', b's', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'i', b's', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'c', b'_', b'a'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'c', b'a']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'a', b' ', b'b', b'_', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'b', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'a', b'_', b' ', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'i', b's', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'i', b's', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'c', b'_', b'a'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'c', b'a']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ']);",
          "    assert_eq!(result.len(), 1);",
          "    assert!(result.is_empty() == false);",
          "    assert!(result[0] == b' ');",
          "    assert!(result[0] != b'_');",
          "    assert!(result[0] != b'-');",
          "    assert!(result.len() <= slice.len());",
          "    let mut slice: &mut [u8] = &mut [b'_', b'-', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_', b'-', b'c']);",
          "    assert!(result.len() == 3);",
          "    assert!(result.contains(&b' '));",
          "    assert!(result.contains(&b'_'));",
          "    assert!(result.contains(&b'-'));",
          "    assert!(result[2] == b'c');",
          "    let mut slice: &mut [u8] = &mut [b'I', b's', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'i', b's', b'c']);",
          "    assert!(result.len() == 3);",
          "    assert!(result.contains(&b'i'));",
          "    assert!(result.contains(&b's'));",
          "    assert!(result.contains(&b'c'));",
          "    assert!(result[0] != b' ');",
          "    assert!(result[1] != b'_');",
          "    assert!(result[2] != b'-');"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ']);",
          "    assert_eq!(result.len(), 1);",
          "    assert!(result.is_empty() == false);",
          "    assert!(result[0] == b' ');",
          "    assert!(result[0] != b'_');",
          "    assert!(result[0] != b'-');",
          "    assert!(result.len() <= slice.len());",
          "    let mut slice: &mut [u8] = &mut [b'_', b'-', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_', b'-', b'c']);",
          "    assert!(result.len() == 3);",
          "    assert!(result.contains(&b' '));",
          "    assert!(result.contains(&b'_'));",
          "    assert!(result.contains(&b'-'));",
          "    assert!(result[2] == b'c');",
          "    let mut slice: &mut [u8] = &mut [b'I', b's', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'i', b's', b'c']);",
          "    assert!(result.len() == 3);",
          "    assert!(result.contains(&b'i'));",
          "    assert!(result.contains(&b's'));",
          "    assert!(result.contains(&b'c'));",
          "    assert!(result[0] != b' ');",
          "    assert!(result[1] != b'_');",
          "    assert!(result[2] != b'-');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_']);",
          "    assert_eq!(result.len(), 1);",
          "    assert!(result.is_ascii());"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_']);",
          "    assert_eq!(result.len(), 1);",
          "    assert!(result.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ', b' ']);",
          "    assert!(result.len() == 2);",
          "    assert!(result.as_ptr() == slice.as_ptr());"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ', b' ']);",
          "    assert!(result.len() == 2);",
          "    assert!(result.as_ptr() == slice.as_ptr());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut []);",
          "    assert!(result.as_ptr() == slice.as_ptr());",
          "    assert_eq!(slice.len(), 2);",
          "    assert_eq!(slice[0], b' ');",
          "    assert_eq!(slice[1], b'_');"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut []);",
          "    assert!(result.as_ptr() == slice.as_ptr());",
          "    assert_eq!(slice.len(), 2);",
          "    assert_eq!(slice[0], b' ');",
          "    assert_eq!(slice[1], b'_');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ']);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'-'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'-']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'a'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ']);",
          "    let mut slice: &mut [u8] = &mut [b 'a', b '_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ']);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'-'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'-']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'a'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ']);",
          "    let mut slice: &mut [u8] = &mut [b 'a', b '_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ', b'_'][..]);",
          "    assert_eq!(slice.len(), 2);",
          "    assert_eq!(result.len(), 2);",
          "    assert_eq!(result.as_ptr(), slice.as_ptr());"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b' ', b'_'][..]);",
          "    assert_eq!(slice.len(), 2);",
          "    assert_eq!(result.len(), 2);",
          "    assert_eq!(result.as_ptr(), slice.as_ptr());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    result.len() == 0",
          "    result.as_ptr() == slice.as_ptr()",
          "    slice[0] == b' '",
          "    slice[1] == b'_'",
          "    slice[2] == b' '",
          "    slice[3] == b'_'",
          "    slice[0..result.len()] == b\"\"",
          "    result.is_empty() == true",
          "    result as *const _ == slice as *const _"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b' ', b'_'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    result.len() == 0",
          "    result.as_ptr() == slice.as_ptr()",
          "    slice[0] == b' '",
          "    slice[1] == b'_'",
          "    slice[2] == b' '",
          "    slice[3] == b'_'",
          "    slice[0..result.len()] == b\"\"",
          "    result.is_empty() == true",
          "    result as *const _ == slice as *const _",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'_', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_', b' '][..]);",
          "    assert_eq!(result.len(), 2);",
          "    assert!(result.iter().all(|&b| b == b'_' || b == b' '));",
          "    assert!(result.as_mut_ptr() == slice.as_mut_ptr());",
          "    assert!(slice.len() == 2);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'_', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'_', b' '][..]);",
          "    assert_eq!(result.len(), 2);",
          "    assert!(result.iter().all(|&b| b == b'_' || b == b' '));",
          "    assert!(result.as_mut_ptr() == slice.as_mut_ptr());",
          "    assert!(slice.len() == 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]