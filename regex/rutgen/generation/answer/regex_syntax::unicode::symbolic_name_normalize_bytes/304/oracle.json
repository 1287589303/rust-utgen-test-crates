[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'A', b'_', b'Z', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'A', b'Z']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'-', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'B', b'_', b'C'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'b', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z', b'-', b' ', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'A', b'_', b'B'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'b']);",
          "    let mut slice: &mut [u8] = &mut [b'c', b' ', b'_', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'c']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'_', b'Z', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'A', b'Z']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'-', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'B', b'_', b'C'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'b', b'c']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z', b'-', b' ', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'A', b'_', b'B'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'b']);",
          "    let mut slice: &mut [u8] = &mut [b'c', b' ', b'_', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'c']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'A', b' ']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'_']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'-']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'z']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'A']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'A']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'-']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'A', b' ', b'Z']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a', b'z']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'_']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'-']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'z']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'A']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'A']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'-']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'A', b' ', b'Z']; assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a', b'z']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'z'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ','_','-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'-', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'z'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ','_','-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'-', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A', b'B'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'A', b'B'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'b']);",
          "    assert_eq!(slice, &mut [b'a', b'b']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A', b'B'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'B'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'b']);",
          "    assert_eq!(slice, &mut [b'a', b'b']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'i', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-', b'A', b'B', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'A', b'B', b'Z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-', b'c', b'c', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'c', b'c', b'c']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'i', b's', b' ', b'A', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'A', b'Z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-', b'I', b'S', b'a', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'A', b'I', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'i', b'z']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'i', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-', b'A', b'B', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'A', b'B', b'Z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-', b'c', b'c', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'c', b'c', b'c']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'i', b's', b' ', b'A', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'A', b'Z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-', b'I', b'S', b'a', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'A', b'I', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'i', b'z']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_', b'-'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'_', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'_', b'-']);",
          "    assert!(slice.len() == 2);",
          "    assert!(slice[0] == b'_');",
          "    assert!(slice[1] == b'-');"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'_', b'-'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'_', b'-']);",
          "    assert!(slice.len() == 2);",
          "    assert!(slice[0] == b'_');",
          "    assert!(slice[1] == b'-');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let slice: &mut [u8] = &mut [b' ', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b' ' as u8, b' ' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'_', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'_' as u8, b'_' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'-', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'-' as u8, b'-' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a' as u8, b'z' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a' as u8, b' ' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b' ', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b' ' as u8, b'z' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'_', b'A'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'_' as u8, b'a' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'-', b'-', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'-' as u8, b'-' as u8]);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let slice: &mut [u8] = &mut [b' ', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b' ' as u8, b' ' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'_', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'_' as u8, b'_' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'-', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'-' as u8, b'-' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a' as u8, b'z' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a' as u8, b' ' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b' ', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b' ' as u8, b'z' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'_', b'A'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'_' as u8, b'a' as u8]);",
          "    ",
          "    let slice: &mut [u8] = &mut [b'-', b'-', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'-' as u8, b'-' as u8]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A', b' '];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'A'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'_', b'-', b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'_', b'-', b'G', b'O', b'O', b'Y'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'g', b'o', b'o', b'y']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A', b' '];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'A'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'_', b'-', b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'_', b'-', b'G', b'O', b'O', b'Y'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'g', b'o', b'o', b'y']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'i'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice).len(), 0);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice).len(), 0);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice).len(), 0);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'A'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'Z', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'B', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'B']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'_', b'B', b'-', b'C'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'B', b'C']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'i'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b' ', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice).len(), 0);",
          "    let mut slice: &mut [u8] = &mut [b'_', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice).len(), 0);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice).len(), 0);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'A'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'a']);",
          "    let mut slice: &mut [u8] = &mut [b'Z', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z', b'z']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'B', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'B']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'_', b'B', b'-', b'C'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'B', b'C']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'I'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'I'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'i']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'B', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'b']);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'-', b'X', b'Y'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'x', b'y']);",
          "    let mut slice: &mut [u8] = &mut [b'Z', b' ', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'I'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'I'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'i']);",
          "    let mut slice: &mut [u8] = &mut [b'A', b'B', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'b']);",
          "    let mut slice: &mut [u8] = &mut [b'-', b'-', b'X', b'Y'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'x', b'y']);",
          "    let mut slice: &mut [u8] = &mut [b'Z', b' ', b'_'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'z']);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'i', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b' ', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b' ']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'B'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'b']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'c', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'b']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'i', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b' ', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b' ']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'A', b'Z'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'_', b'-'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut []);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'B'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'b']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'c', b' '];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'b']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'I', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'_', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'-', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut []);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'B', b'C', b'D'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'b', b'c', b'd']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'c', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'c']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'I', b'S', b'_', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'i', b's', b'c']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'I', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'A', b' ', b'_', b'Z'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a', b'z']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b' ', b'-', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut []);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'B', b'C', b'D'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'b', b'c', b'd']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'c', b' '];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'c']);",
          "    ",
          "    let mut slice: &mut [u8] = &mut [b'I', b'S', b'_', b'c'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'i', b's', b'c']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'I', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'I', b'S'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'i', b's']);"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'I', b'S'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'I', b'S'];",
          "    assert_eq!(symbolic_name_normalize_bytes(slice), &mut [b'i', b's']);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'\\x80', b'A'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    let mut slice: &mut [u8] = &mut [b'\\x80', b'A'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a']);",
          "    assert_eq!(slice.len(), 1);",
          "    assert!(result.is_ascii());",
          "    assert!(result.len() <= slice.len());",
          "    assert!(result[0] == b'a');"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'\\x80', b'A'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    let mut slice: &mut [u8] = &mut [b'\\x80', b'A'];",
          "    let result = symbolic_name_normalize_bytes(slice);",
          "    assert_eq!(result, &mut [b'a']);",
          "    assert_eq!(slice.len(), 1);",
          "    assert!(result.is_ascii());",
          "    assert!(result.len() <= slice.len());",
          "    assert!(result[0] == b'a');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A', b'\\x80'];",
          "    symbolic_name_normalize_bytes(slice);",
          "}"
        ],
        "oracle": [
          "    slice.len() >= 2  // Ensure precondition for length of the slice is met",
          "    b'A' <= b  // Ensure the byte is within the valid uppercase ASCII range",
          "    b <= b'Z'  // Ensure the byte is within the valid uppercase ASCII range",
          "    b == b' '  // Ensure the byte is a space character",
          "    b == b'_'  // Ensure the byte is an underscore character",
          "    b == b'-'  // Ensure the byte is a hyphen character",
          "    starts_with_is == false  // Ensure the \"is\" prefix condition is false",
          "    &mut slice[..next_write]  // Ensure return value is a mutable slice with next_write length"
        ],
        "code": [
          "{",
          "    let mut slice: &mut [u8] = &mut [b'A', b'\\x80'];",
          "    symbolic_name_normalize_bytes(slice);",
          "    slice.len() >= 2  // Ensure precondition for length of the slice is met",
          "    b'A' <= b  // Ensure the byte is within the valid uppercase ASCII range",
          "    b <= b'Z'  // Ensure the byte is within the valid uppercase ASCII range",
          "    b == b' '  // Ensure the byte is a space character",
          "    b == b'_'  // Ensure the byte is an underscore character",
          "    b == b'-'  // Ensure the byte is a hyphen character",
          "    starts_with_is == false  // Ensure the \"is\" prefix condition is false",
          "    &mut slice[..next_write]  // Ensure return value is a mutable slice with next_write length",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]