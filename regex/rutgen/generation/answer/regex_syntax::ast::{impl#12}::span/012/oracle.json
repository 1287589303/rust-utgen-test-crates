[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(0),",
          "        end: Position(0),",
          "    };",
          "    let ast = Ast::empty(span);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ast.span(), &span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(0),",
          "        end: Position(0),",
          "    };",
          "    let ast = Ast::empty(span);",
          "    ast.span();",
          "    assert_eq!(ast.span(), &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(1),",
          "        end: Position(2),",
          "    };",
          "    let flags = SetFlags {",
          "        span,",
          "        flags: Flags::default(),",
          "    };",
          "    let ast = Ast::flags(flags);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    ast.span() == &Span { start: Position(1), end: Position(2) }",
          "    let span = Span { start: Position(1), end: Position(2) };",
          "    let ast = Ast::empty(span);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(3), end: Position(4) };",
          "    let literal = Literal { span, kind: LiteralKind::SomeKind, c: 'a' };",
          "    let ast = Ast::literal(literal);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(5), end: Position(6) };",
          "    let assertion = Assertion { span, kind: AssertionKind::SomeKind };",
          "    let ast = Ast::assertion(assertion);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(7), end: Position(8) };",
          "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::SomeKind, negated: false };",
          "    let ast = Ast::class_unicode(class_unicode);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(9), end: Position(10) };",
          "    let alternation = Alternation { span, asts: vec![Ast::empty(span)] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(11), end: Position(12) };",
          "    let group = Group { span, kind: GroupKind::SomeKind, ast: Box::new(ast) };",
          "    let ast = Ast::group(group);",
          "    ast.span() == &span"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(1),",
          "        end: Position(2),",
          "    };",
          "    let flags = SetFlags {",
          "        span,",
          "        flags: Flags::default(),",
          "    };",
          "    let ast = Ast::flags(flags);",
          "    ast.span();",
          "    ast.span() == &Span { start: Position(1), end: Position(2) }",
          "    let span = Span { start: Position(1), end: Position(2) };",
          "    let ast = Ast::empty(span);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(3), end: Position(4) };",
          "    let literal = Literal { span, kind: LiteralKind::SomeKind, c: 'a' };",
          "    let ast = Ast::literal(literal);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(5), end: Position(6) };",
          "    let assertion = Assertion { span, kind: AssertionKind::SomeKind };",
          "    let ast = Ast::assertion(assertion);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(7), end: Position(8) };",
          "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::SomeKind, negated: false };",
          "    let ast = Ast::class_unicode(class_unicode);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(9), end: Position(10) };",
          "    let alternation = Alternation { span, asts: vec![Ast::empty(span)] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.span() == &span",
          "    let span = Span { start: Position(11), end: Position(12) };",
          "    let group = Group { span, kind: GroupKind::SomeKind, ast: Box::new(ast) };",
          "    let ast = Ast::group(group);",
          "    ast.span() == &span",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(0),",
          "        end: Position(1),",
          "    };",
          "    let literal = Literal {",
          "        span,",
          "        kind: LiteralKind::Character,",
          "        c: 'a',",
          "    };",
          "    let ast = Ast::literal(literal);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let ast_empty = Ast::Empty(Box::new(span));",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags_span = Span { start: Position(2), end: Position(3) };",
          "    let set_flags = SetFlags { span: flags_span.clone(), flags: Flags::new() };",
          "    let ast_flags = Ast::Flags(Box::new(set_flags));",
          "    assert_eq!(ast_flags.span(), &flags_span);",
          "    ",
          "    let literal_span = Span { start: Position(4), end: Position(5) };",
          "    let literal = Literal { span: literal_span.clone(), kind: LiteralKind::Character, c: 'b' };",
          "    let ast_literal = Ast::Literal(Box::new(literal));",
          "    assert_eq!(ast_literal.span(), &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(6), end: Position(7) };",
          "    let ast_dot = Ast::Dot(Box::new(dot_span));",
          "    assert_eq!(ast_dot.span(), &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(8), end: Position(9) };",
          "    let assertion = Assertion { span: assertion_span.clone(), kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::Assertion(Box::new(assertion));",
          "    assert_eq!(ast_assertion.span(), &assertion_span);",
          "    ",
          "    let class_unicode_span = Span { start: Position(10), end: Position(11) };",
          "    let class_unicode = ClassUnicode { span: class_unicode_span.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(class_unicode));",
          "    assert_eq!(ast_class_unicode.span(), &class_unicode_span);",
          "    ",
          "    let class_perl_span = Span { start: Position(12), end: Position(13) };",
          "    let class_perl = ClassPerl { span: class_perl_span.clone(), kind: ClassPerlKind::Digit, negated: false };",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(class_perl));",
          "    assert_eq!(ast_class_perl.span(), &class_perl_span);",
          "    ",
          "    let class_bracketed_span = Span { start: Position(14), end: Position(15) };",
          "    let class_bracketed = ClassBracketed { span: class_bracketed_span.clone(), negated: true, kind: ClassSet::Normal };",
          "    let ast_class_bracketed = Ast::ClassBracketed(Box::new(class_bracketed));",
          "    assert_eq!(ast_class_bracketed.span(), &class_bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(16), end: Position(17) };",
          "    let repetition = Repetition { min: 1, max: Some(2), greedy: true, sub: Box::new(ast_literal) };",
          "    let ast_repetition = Ast::Repetition(Box::new(repetition));",
          "    assert_eq!(ast_repetition.span(), &repetition_span);",
          "    ",
          "    let group_span = Span { start: Position(18), end: Position(19) };",
          "    let group = Group { span: group_span.clone(), kind: GroupKind::Capturing, ast: Box::new(ast_class_unicode) };",
          "    let ast_group = Ast::Group(Box::new(group));",
          "    assert_eq!(ast_group.span(), &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(20), end: Position(21) };",
          "    let alternation = Alternation { span: alternation_span.clone(), asts: vec![ast_flags, ast_literal] };",
          "    let ast_alternation = Ast::Alternation(Box::new(alternation));",
          "    assert_eq!(ast_alternation.span(), &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(22), end: Position(23) };",
          "    let concat = Concat { span: concat_span.clone(), asts: vec![ast_literal, ast_class_perl] };",
          "    let ast_concat = Ast::Concat(Box::new(concat));",
          "    assert_eq!(ast_concat.span(), &concat_span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(0),",
          "        end: Position(1),",
          "    };",
          "    let literal = Literal {",
          "        span,",
          "        kind: LiteralKind::Character,",
          "        c: 'a',",
          "    };",
          "    let ast = Ast::literal(literal);",
          "    ast.span();",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let ast_empty = Ast::Empty(Box::new(span));",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags_span = Span { start: Position(2), end: Position(3) };",
          "    let set_flags = SetFlags { span: flags_span.clone(), flags: Flags::new() };",
          "    let ast_flags = Ast::Flags(Box::new(set_flags));",
          "    assert_eq!(ast_flags.span(), &flags_span);",
          "    ",
          "    let literal_span = Span { start: Position(4), end: Position(5) };",
          "    let literal = Literal { span: literal_span.clone(), kind: LiteralKind::Character, c: 'b' };",
          "    let ast_literal = Ast::Literal(Box::new(literal));",
          "    assert_eq!(ast_literal.span(), &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(6), end: Position(7) };",
          "    let ast_dot = Ast::Dot(Box::new(dot_span));",
          "    assert_eq!(ast_dot.span(), &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(8), end: Position(9) };",
          "    let assertion = Assertion { span: assertion_span.clone(), kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::Assertion(Box::new(assertion));",
          "    assert_eq!(ast_assertion.span(), &assertion_span);",
          "    ",
          "    let class_unicode_span = Span { start: Position(10), end: Position(11) };",
          "    let class_unicode = ClassUnicode { span: class_unicode_span.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(class_unicode));",
          "    assert_eq!(ast_class_unicode.span(), &class_unicode_span);",
          "    ",
          "    let class_perl_span = Span { start: Position(12), end: Position(13) };",
          "    let class_perl = ClassPerl { span: class_perl_span.clone(), kind: ClassPerlKind::Digit, negated: false };",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(class_perl));",
          "    assert_eq!(ast_class_perl.span(), &class_perl_span);",
          "    ",
          "    let class_bracketed_span = Span { start: Position(14), end: Position(15) };",
          "    let class_bracketed = ClassBracketed { span: class_bracketed_span.clone(), negated: true, kind: ClassSet::Normal };",
          "    let ast_class_bracketed = Ast::ClassBracketed(Box::new(class_bracketed));",
          "    assert_eq!(ast_class_bracketed.span(), &class_bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(16), end: Position(17) };",
          "    let repetition = Repetition { min: 1, max: Some(2), greedy: true, sub: Box::new(ast_literal) };",
          "    let ast_repetition = Ast::Repetition(Box::new(repetition));",
          "    assert_eq!(ast_repetition.span(), &repetition_span);",
          "    ",
          "    let group_span = Span { start: Position(18), end: Position(19) };",
          "    let group = Group { span: group_span.clone(), kind: GroupKind::Capturing, ast: Box::new(ast_class_unicode) };",
          "    let ast_group = Ast::Group(Box::new(group));",
          "    assert_eq!(ast_group.span(), &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(20), end: Position(21) };",
          "    let alternation = Alternation { span: alternation_span.clone(), asts: vec![ast_flags, ast_literal] };",
          "    let ast_alternation = Ast::Alternation(Box::new(alternation));",
          "    assert_eq!(ast_alternation.span(), &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(22), end: Position(23) };",
          "    let concat = Concat { span: concat_span.clone(), asts: vec![ast_literal, ast_class_perl] };",
          "    let ast_concat = Ast::Concat(Box::new(concat));",
          "    assert_eq!(ast_concat.span(), &concat_span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(2),",
          "        end: Position(3),",
          "    };",
          "    let ast = Ast::dot(span);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(2), end: Position(3) };",
          "    let ast = Ast::empty(span);",
          "    let result = ast.span();",
          "    assert_eq!(result, &span);",
          "    ",
          "    let flag_span = Span { start: Position(1), end: Position(5) };",
          "    let flags_ast = Ast::flags(SetFlags { span: flag_span, flags: Flags::default() });",
          "    let result = flags_ast.span();",
          "    assert_eq!(result, &flag_span);",
          "    ",
          "    let literal_span = Span { start: Position(0), end: Position(4) };",
          "    let literal_ast = Ast::literal(Literal { span: literal_span, kind: LiteralKind::Char, c: 'a' });",
          "    let result = literal_ast.span();",
          "    assert_eq!(result, &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(1), end: Position(2) };",
          "    let dot_ast = Ast::dot(dot_span);",
          "    let result = dot_ast.span();",
          "    assert_eq!(result, &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(0), end: Position(1) };",
          "    let assertion_ast = Ast::assertion(Assertion { span: assertion_span, kind: AssertionKind::Start });",
          "    let result = assertion_ast.span();",
          "    assert_eq!(result, &assertion_span);",
          "    ",
          "    let class_unicode_span = Span { start: Position(0), end: Position(10) };",
          "    let class_unicode_ast = Ast::class_unicode(ClassUnicode { span: class_unicode_span, negated: false, kind: ClassUnicodeKind::Letter });",
          "    let result = class_unicode_ast.span();",
          "    assert_eq!(result, &class_unicode_span);",
          "    ",
          "    let class_perl_span = Span { start: Position(0), end: Position(1) };",
          "    let class_perl_ast = Ast::class_perl(ClassPerl { span: class_perl_span, kind: ClassPerlKind::Digit, negated: false });",
          "    let result = class_perl_ast.span();",
          "    assert_eq!(result, &class_perl_span);",
          "    ",
          "    let class_bracketed_span = Span { start: Position(0), end: Position(5) };",
          "    let class_bracketed_ast = Ast::class_bracketed(ClassBracketed { span: class_bracketed_span, negated: false, kind: ClassSet::Normal });",
          "    let result = class_bracketed_ast.span();",
          "    assert_eq!(result, &class_bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(0), end: Position(6) };",
          "    let repetition_ast = Ast::repetition(Repetition { span: repetition_span, min: 1, max: Some(3), greedy: true, sub: Box::new(Ast::literal(Literal { span: repetition_span, kind: LiteralKind::Char, c: 'b' })) });",
          "    let result = repetition_ast.span();",
          "    assert_eq!(result, &repetition_span);",
          "    ",
          "    let group_span = Span { start: Position(0), end: Position(8) };",
          "    let group_ast = Ast::group(Group { span: group_span, kind: GroupKind::Capture, ast: Box::new(Ast::literal(Literal { span: group_span, kind: LiteralKind::Char, c: 'c' })) });",
          "    let result = group_ast.span();",
          "    assert_eq!(result, &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(0), end: Position(9) };",
          "    let alternation_ast = Ast::alternation(Alternation { span: alternation_span, asts: vec![Ast::dot(dot_span), Ast::literal(Literal { span: alternation_span, kind: LiteralKind::Char, c: 'd' })] });",
          "    let result = alternation_ast.span();",
          "    assert_eq!(result, &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(0), end: Position(14) };",
          "    let concat_ast = Ast::concat(Concat { span: concat_span, asts: vec![Ast::literal(Literal { span: concat_span, kind: LiteralKind::Char, c: 'e' }), Ast::dot(dot_span)] });",
          "    let result = concat_ast.span();",
          "    assert_eq!(result, &concat_span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(2),",
          "        end: Position(3),",
          "    };",
          "    let ast = Ast::dot(span);",
          "    ast.span();",
          "    let span = Span { start: Position(2), end: Position(3) };",
          "    let ast = Ast::empty(span);",
          "    let result = ast.span();",
          "    assert_eq!(result, &span);",
          "    ",
          "    let flag_span = Span { start: Position(1), end: Position(5) };",
          "    let flags_ast = Ast::flags(SetFlags { span: flag_span, flags: Flags::default() });",
          "    let result = flags_ast.span();",
          "    assert_eq!(result, &flag_span);",
          "    ",
          "    let literal_span = Span { start: Position(0), end: Position(4) };",
          "    let literal_ast = Ast::literal(Literal { span: literal_span, kind: LiteralKind::Char, c: 'a' });",
          "    let result = literal_ast.span();",
          "    assert_eq!(result, &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(1), end: Position(2) };",
          "    let dot_ast = Ast::dot(dot_span);",
          "    let result = dot_ast.span();",
          "    assert_eq!(result, &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(0), end: Position(1) };",
          "    let assertion_ast = Ast::assertion(Assertion { span: assertion_span, kind: AssertionKind::Start });",
          "    let result = assertion_ast.span();",
          "    assert_eq!(result, &assertion_span);",
          "    ",
          "    let class_unicode_span = Span { start: Position(0), end: Position(10) };",
          "    let class_unicode_ast = Ast::class_unicode(ClassUnicode { span: class_unicode_span, negated: false, kind: ClassUnicodeKind::Letter });",
          "    let result = class_unicode_ast.span();",
          "    assert_eq!(result, &class_unicode_span);",
          "    ",
          "    let class_perl_span = Span { start: Position(0), end: Position(1) };",
          "    let class_perl_ast = Ast::class_perl(ClassPerl { span: class_perl_span, kind: ClassPerlKind::Digit, negated: false });",
          "    let result = class_perl_ast.span();",
          "    assert_eq!(result, &class_perl_span);",
          "    ",
          "    let class_bracketed_span = Span { start: Position(0), end: Position(5) };",
          "    let class_bracketed_ast = Ast::class_bracketed(ClassBracketed { span: class_bracketed_span, negated: false, kind: ClassSet::Normal });",
          "    let result = class_bracketed_ast.span();",
          "    assert_eq!(result, &class_bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(0), end: Position(6) };",
          "    let repetition_ast = Ast::repetition(Repetition { span: repetition_span, min: 1, max: Some(3), greedy: true, sub: Box::new(Ast::literal(Literal { span: repetition_span, kind: LiteralKind::Char, c: 'b' })) });",
          "    let result = repetition_ast.span();",
          "    assert_eq!(result, &repetition_span);",
          "    ",
          "    let group_span = Span { start: Position(0), end: Position(8) };",
          "    let group_ast = Ast::group(Group { span: group_span, kind: GroupKind::Capture, ast: Box::new(Ast::literal(Literal { span: group_span, kind: LiteralKind::Char, c: 'c' })) });",
          "    let result = group_ast.span();",
          "    assert_eq!(result, &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(0), end: Position(9) };",
          "    let alternation_ast = Ast::alternation(Alternation { span: alternation_span, asts: vec![Ast::dot(dot_span), Ast::literal(Literal { span: alternation_span, kind: LiteralKind::Char, c: 'd' })] });",
          "    let result = alternation_ast.span();",
          "    assert_eq!(result, &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(0), end: Position(14) };",
          "    let concat_ast = Ast::concat(Concat { span: concat_span, asts: vec![Ast::literal(Literal { span: concat_span, kind: LiteralKind::Char, c: 'e' }), Ast::dot(dot_span)] });",
          "    let result = concat_ast.span();",
          "    assert_eq!(result, &concat_span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(4),",
          "        end: Position(5),",
          "    };",
          "    let assertion = Assertion {",
          "        span,",
          "        kind: AssertionKind::Start,",
          "    };",
          "    let ast = Ast::assertion(assertion);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(4), end: Position(5) }; assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(1), end: Position(2) }; let flags = SetFlags { span, flags: Flags::empty() }; let ast = Ast::flags(flags); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(3), end: Position(4) }; let literal = Literal { span, kind: LiteralKind::Char, c: 'a' }; let ast = Ast::literal(literal); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(0), end: Position(1) }; let ast = Ast::dot(span); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(2), end: Position(3) }; let class_unicode = ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Letter }; let ast = Ast::class_unicode(class_unicode); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(5), end: Position(6) }; let class_perl = ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }; let ast = Ast::class_perl(class_perl); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(6), end: Position(7) }; let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Normal }; let ast = Ast::class_bracketed(class_bracketed); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(7), end: Position(8) }; let repetition = Repetition { span, min: 1, max: Some(2), greedy: false, sub: Box::new(ast) }; let ast = Ast::repetition(repetition); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(8), end: Position(9) }; let group = Group { span, kind: GroupKind::Captured, ast: Box::new(ast) }; let ast = Ast::group(group); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(9), end: Position(10) }; let alternation = Alternation { span, asts: vec![ast] }; let ast = Ast::alternation(alternation); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(10), end: Position(11) }; let concat = Concat { span, asts: vec![ast] }; let ast = Ast::concat(concat); assert_eq!(ast.span(), &span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(4),",
          "        end: Position(5),",
          "    };",
          "    let assertion = Assertion {",
          "        span,",
          "        kind: AssertionKind::Start,",
          "    };",
          "    let ast = Ast::assertion(assertion);",
          "    ast.span();",
          "    let span = Span { start: Position(4), end: Position(5) }; assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(1), end: Position(2) }; let flags = SetFlags { span, flags: Flags::empty() }; let ast = Ast::flags(flags); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(3), end: Position(4) }; let literal = Literal { span, kind: LiteralKind::Char, c: 'a' }; let ast = Ast::literal(literal); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(0), end: Position(1) }; let ast = Ast::dot(span); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(2), end: Position(3) }; let class_unicode = ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Letter }; let ast = Ast::class_unicode(class_unicode); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(5), end: Position(6) }; let class_perl = ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }; let ast = Ast::class_perl(class_perl); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(6), end: Position(7) }; let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Normal }; let ast = Ast::class_bracketed(class_bracketed); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(7), end: Position(8) }; let repetition = Repetition { span, min: 1, max: Some(2), greedy: false, sub: Box::new(ast) }; let ast = Ast::repetition(repetition); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(8), end: Position(9) }; let group = Group { span, kind: GroupKind::Captured, ast: Box::new(ast) }; let ast = Ast::group(group); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(9), end: Position(10) }; let alternation = Alternation { span, asts: vec![ast] }; let ast = Ast::alternation(alternation); assert_eq!(ast.span(), &span);",
          "    let span = Span { start: Position(10), end: Position(11) }; let concat = Concat { span, asts: vec![ast] }; let ast = Ast::concat(concat); assert_eq!(ast.span(), &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(6),",
          "        end: Position(7),",
          "    };",
          "    let class_unicode = ClassUnicode {",
          "        span,",
          "        negated: false,",
          "        kind: ClassUnicodeKind::Letter,",
          "    };",
          "    let ast = Ast::class_unicode(class_unicode);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let ast_empty = Ast::empty(span.clone());",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let span_flags = Span { start: Position(2), end: Position(3) };",
          "    let set_flags = SetFlags { span: span_flags.clone(), flags: Flags::default() };",
          "    let ast_flags = Ast::flags(set_flags);",
          "    assert_eq!(ast_flags.span(), &span_flags);",
          "    ",
          "    let span_literal = Span { start: Position(4), end: Position(5) };",
          "    let literal = Literal { span: span_literal.clone(), kind: LiteralKind::Character, c: 'a' };",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span_literal);",
          "    ",
          "    let span_dot = Span { start: Position(5), end: Position(6) };",
          "    let ast_dot = Ast::dot(span_dot.clone());",
          "    assert_eq!(ast_dot.span(), &span_dot);",
          "    ",
          "    let span_assertion = Span { start: Position(6), end: Position(7) };",
          "    let assertion = Assertion { span: span_assertion.clone(), kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span_assertion);",
          "    ",
          "    let span_class_unicode = Span { start: Position(7), end: Position(8) };",
          "    let class_unicode = ClassUnicode { span: span_class_unicode.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span_class_unicode);",
          "    ",
          "    let span_class_perl = Span { start: Position(8), end: Position(9) };",
          "    let class_perl = ClassPerl { span: span_class_perl.clone(), kind: ClassPerlKind::Digit, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span_class_perl);",
          "    ",
          "    let span_class_bracketed = Span { start: Position(9), end: Position(10) };",
          "    let class_bracketed = ClassBracketed { span: span_class_bracketed.clone(), negated: false, kind: ClassSet::Normal };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span_class_bracketed);",
          "    ",
          "    let span_repetition = Span { start: Position(10), end: Position(11) };",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(Ast::empty(span.clone())) };",
          "    let ast_repetition = Ast::repetition(repetition);",
          "    assert_eq!(ast_repetition.span(), &span_repetition);",
          "    ",
          "    let span_group = Span { start: Position(11), end: Position(12) };",
          "    let group = Group { span: span_group.clone(), kind: GroupKind::Normal, ast: Box::new(Ast::empty(span.clone())) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span_group);",
          "    ",
          "    let span_alternation = Span { start: Position(12), end: Position(13) };",
          "    let alternation = Alternation { span: span_alternation.clone(), asts: vec![Ast::empty(span.clone())] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span_alternation);",
          "    ",
          "    let span_concat = Span { start: Position(13), end: Position(14) };",
          "    let concat = Concat { span: span_concat.clone(), asts: vec![Ast::empty(span.clone()), Ast::empty(span.clone())] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span_concat);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(6),",
          "        end: Position(7),",
          "    };",
          "    let class_unicode = ClassUnicode {",
          "        span,",
          "        negated: false,",
          "        kind: ClassUnicodeKind::Letter,",
          "    };",
          "    let ast = Ast::class_unicode(class_unicode);",
          "    ast.span();",
          "    let span = Span { start: Position(0), end: Position(1) };",
          "    let ast_empty = Ast::empty(span.clone());",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let span_flags = Span { start: Position(2), end: Position(3) };",
          "    let set_flags = SetFlags { span: span_flags.clone(), flags: Flags::default() };",
          "    let ast_flags = Ast::flags(set_flags);",
          "    assert_eq!(ast_flags.span(), &span_flags);",
          "    ",
          "    let span_literal = Span { start: Position(4), end: Position(5) };",
          "    let literal = Literal { span: span_literal.clone(), kind: LiteralKind::Character, c: 'a' };",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span_literal);",
          "    ",
          "    let span_dot = Span { start: Position(5), end: Position(6) };",
          "    let ast_dot = Ast::dot(span_dot.clone());",
          "    assert_eq!(ast_dot.span(), &span_dot);",
          "    ",
          "    let span_assertion = Span { start: Position(6), end: Position(7) };",
          "    let assertion = Assertion { span: span_assertion.clone(), kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span_assertion);",
          "    ",
          "    let span_class_unicode = Span { start: Position(7), end: Position(8) };",
          "    let class_unicode = ClassUnicode { span: span_class_unicode.clone(), negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span_class_unicode);",
          "    ",
          "    let span_class_perl = Span { start: Position(8), end: Position(9) };",
          "    let class_perl = ClassPerl { span: span_class_perl.clone(), kind: ClassPerlKind::Digit, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span_class_perl);",
          "    ",
          "    let span_class_bracketed = Span { start: Position(9), end: Position(10) };",
          "    let class_bracketed = ClassBracketed { span: span_class_bracketed.clone(), negated: false, kind: ClassSet::Normal };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span_class_bracketed);",
          "    ",
          "    let span_repetition = Span { start: Position(10), end: Position(11) };",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(Ast::empty(span.clone())) };",
          "    let ast_repetition = Ast::repetition(repetition);",
          "    assert_eq!(ast_repetition.span(), &span_repetition);",
          "    ",
          "    let span_group = Span { start: Position(11), end: Position(12) };",
          "    let group = Group { span: span_group.clone(), kind: GroupKind::Normal, ast: Box::new(Ast::empty(span.clone())) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span_group);",
          "    ",
          "    let span_alternation = Span { start: Position(12), end: Position(13) };",
          "    let alternation = Alternation { span: span_alternation.clone(), asts: vec![Ast::empty(span.clone())] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span_alternation);",
          "    ",
          "    let span_concat = Span { start: Position(13), end: Position(14) };",
          "    let concat = Concat { span: span_concat.clone(), asts: vec![Ast::empty(span.clone()), Ast::empty(span.clone())] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span_concat);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(8),",
          "        end: Position(9),",
          "    };",
          "    let class_perl = ClassPerl {",
          "        span,",
          "        kind: ClassPerlKind::Digit,",
          "        negated: false,",
          "    };",
          "    let ast = Ast::class_perl(class_perl);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span_empty = Span { start: Position(0), end: Position(0) };",
          "    let ast_empty = Ast::empty(span_empty);",
          "    assert_eq!(ast_empty.span(), &span_empty);",
          "    ",
          "    let span_flags = Span { start: Position(1), end: Position(2) };",
          "    let set_flags = SetFlags { span: span_flags, flags: Flags };",
          "    let ast_flags = Ast::flags(set_flags);",
          "    assert_eq!(ast_flags.span(), &span_flags);",
          "    ",
          "    let span_literal = Span { start: Position(3), end: Position(4) };",
          "    let literal = Literal(Box::new([b'a']));",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span_literal);",
          "    ",
          "    let span_dot = Span { start: Position(5), end: Position(6) };",
          "    let ast_dot = Ast::dot(span_dot);",
          "    assert_eq!(ast_dot.span(), &span_dot);",
          "    ",
          "    let span_assertion = Span { start: Position(7), end: Position(8) };",
          "    let assertion = Assertion { span: span_assertion, kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span_assertion);",
          "    ",
          "    let span_class_unicode = Span { start: Position(9), end: Position(10) };",
          "    let class_unicode = ClassUnicode { span: span_class_unicode, negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span_class_unicode);",
          "    ",
          "    let span_class_perl = Span { start: Position(11), end: Position(12) };",
          "    let class_perl = ClassPerl { span: span_class_perl, kind: ClassPerlKind::Word, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span_class_perl);",
          "    ",
          "    let span_class_bracketed = Span { start: Position(13), end: Position(14) };",
          "    let class_bracketed = ClassBracketed { span: span_class_bracketed, negated: true, kind: ClassSet::Union };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span_class_bracketed);",
          "    ",
          "    let span_repetition = Span { start: Position(15), end: Position(16) };",
          "    let repetition = Repetition { span: span_repetition, min: 1, max: Some(3), greedy: true, sub: Box::new(ast_class_perl) };",
          "    let ast_repetition = Ast::repetition(repetition);",
          "    assert_eq!(ast_repetition.span(), &span_repetition);",
          "    ",
          "    let span_group = Span { start: Position(17), end: Position(18) };",
          "    let group = Group { span: span_group, kind: GroupKind::Capturing, ast: Box::new(ast_repetition) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span_group);",
          "    ",
          "    let span_alternation = Span { start: Position(19), end: Position(20) };",
          "    let alternation = Alternation { span: span_alternation, asts: vec![Box::new(ast_class_unicode), Box::new(ast_literal)] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span_alternation);",
          "    ",
          "    let span_concat = Span { start: Position(21), end: Position(22) };",
          "    let concat = Concat { span: span_concat, asts: vec![Box::new(ast_dot), Box::new(ast_assertion)] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span_concat);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(8),",
          "        end: Position(9),",
          "    };",
          "    let class_perl = ClassPerl {",
          "        span,",
          "        kind: ClassPerlKind::Digit,",
          "        negated: false,",
          "    };",
          "    let ast = Ast::class_perl(class_perl);",
          "    ast.span();",
          "    let span_empty = Span { start: Position(0), end: Position(0) };",
          "    let ast_empty = Ast::empty(span_empty);",
          "    assert_eq!(ast_empty.span(), &span_empty);",
          "    ",
          "    let span_flags = Span { start: Position(1), end: Position(2) };",
          "    let set_flags = SetFlags { span: span_flags, flags: Flags };",
          "    let ast_flags = Ast::flags(set_flags);",
          "    assert_eq!(ast_flags.span(), &span_flags);",
          "    ",
          "    let span_literal = Span { start: Position(3), end: Position(4) };",
          "    let literal = Literal(Box::new([b'a']));",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span_literal);",
          "    ",
          "    let span_dot = Span { start: Position(5), end: Position(6) };",
          "    let ast_dot = Ast::dot(span_dot);",
          "    assert_eq!(ast_dot.span(), &span_dot);",
          "    ",
          "    let span_assertion = Span { start: Position(7), end: Position(8) };",
          "    let assertion = Assertion { span: span_assertion, kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span_assertion);",
          "    ",
          "    let span_class_unicode = Span { start: Position(9), end: Position(10) };",
          "    let class_unicode = ClassUnicode { span: span_class_unicode, negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span_class_unicode);",
          "    ",
          "    let span_class_perl = Span { start: Position(11), end: Position(12) };",
          "    let class_perl = ClassPerl { span: span_class_perl, kind: ClassPerlKind::Word, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span_class_perl);",
          "    ",
          "    let span_class_bracketed = Span { start: Position(13), end: Position(14) };",
          "    let class_bracketed = ClassBracketed { span: span_class_bracketed, negated: true, kind: ClassSet::Union };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span_class_bracketed);",
          "    ",
          "    let span_repetition = Span { start: Position(15), end: Position(16) };",
          "    let repetition = Repetition { span: span_repetition, min: 1, max: Some(3), greedy: true, sub: Box::new(ast_class_perl) };",
          "    let ast_repetition = Ast::repetition(repetition);",
          "    assert_eq!(ast_repetition.span(), &span_repetition);",
          "    ",
          "    let span_group = Span { start: Position(17), end: Position(18) };",
          "    let group = Group { span: span_group, kind: GroupKind::Capturing, ast: Box::new(ast_repetition) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span_group);",
          "    ",
          "    let span_alternation = Span { start: Position(19), end: Position(20) };",
          "    let alternation = Alternation { span: span_alternation, asts: vec![Box::new(ast_class_unicode), Box::new(ast_literal)] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span_alternation);",
          "    ",
          "    let span_concat = Span { start: Position(21), end: Position(22) };",
          "    let concat = Concat { span: span_concat, asts: vec![Box::new(ast_dot), Box::new(ast_assertion)] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span_concat);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(10),",
          "        end: Position(11),",
          "    };",
          "    let class_bracketed = ClassBracketed {",
          "        span,",
          "        negated: false,",
          "        kind: ClassSet::Normal,",
          "    };",
          "    let ast = Ast::class_bracketed(class_bracketed);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(10), end: Position(11) };",
          "    let ast = Ast::Empty(Box::new(span));",
          "    assert_eq!(ast.span(), &span);",
          "    ",
          "    let flags_span = Span { start: Position(12), end: Position(13) };",
          "    let set_flags = SetFlags { span: flags_span, flags: Flags::new() };",
          "    let ast = Ast::Flags(Box::new(set_flags));",
          "    assert_eq!(ast.span(), &flags_span);",
          "    ",
          "    let literal_span = Span { start: Position(14), end: Position(15) };",
          "    let literal = Literal { span: literal_span, kind: LiteralKind::Char, c: 'a' };",
          "    let ast = Ast::Literal(Box::new(literal));",
          "    assert_eq!(ast.span(), &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(16), end: Position(17) };",
          "    let ast = Ast::Dot(Box::new(dot_span));",
          "    assert_eq!(ast.span(), &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(18), end: Position(19) };",
          "    let assertion = Assertion { span: assertion_span, kind: AssertionKind::WordBoundary };",
          "    let ast = Ast::Assertion(Box::new(assertion));",
          "    assert_eq!(ast.span(), &assertion_span);",
          "    ",
          "    let unicode_span = Span { start: Position(20), end: Position(21) };",
          "    let class_unicode = ClassUnicode { span: unicode_span, negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast = Ast::ClassUnicode(Box::new(class_unicode));",
          "    assert_eq!(ast.span(), &unicode_span);",
          "    ",
          "    let perl_class_span = Span { start: Position(22), end: Position(23) };",
          "    let class_perl = ClassPerl { span: perl_class_span, kind: ClassPerlKind::Digit, negated: false };",
          "    let ast = Ast::ClassPerl(Box::new(class_perl));",
          "    assert_eq!(ast.span(), &perl_class_span);",
          "    ",
          "    let bracketed_span = Span { start: Position(24), end: Position(25) };",
          "    let class_bracketed = ClassBracketed { span: bracketed_span, negated: false, kind: ClassSet::Normal };",
          "    let ast = Ast::ClassBracketed(Box::new(class_bracketed));",
          "    assert_eq!(ast.span(), &bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(26), end: Position(27) };",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(ast) };",
          "    let ast = Ast::Repetition(Box::new(repetition));",
          "    assert_eq!(ast.span(), &repetition.span);",
          "    ",
          "    let group_span = Span { start: Position(28), end: Position(29) };",
          "    let group = Group { span: group_span, kind: GroupKind::Capture, ast: Box::new(ast) };",
          "    let ast = Ast::Group(Box::new(group));",
          "    assert_eq!(ast.span(), &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(30), end: Position(31) };",
          "    let alternation = Alternation { span: alternation_span, asts: vec![ast] };",
          "    let ast = Ast::Alternation(Box::new(alternation));",
          "    assert_eq!(ast.span(), &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(32), end: Position(33) };",
          "    let concat = Concat { span: concat_span, asts: vec![ast] };",
          "    let ast = Ast::Concat(Box::new(concat));",
          "    assert_eq!(ast.span(), &concat_span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(10),",
          "        end: Position(11),",
          "    };",
          "    let class_bracketed = ClassBracketed {",
          "        span,",
          "        negated: false,",
          "        kind: ClassSet::Normal,",
          "    };",
          "    let ast = Ast::class_bracketed(class_bracketed);",
          "    ast.span();",
          "    let span = Span { start: Position(10), end: Position(11) };",
          "    let ast = Ast::Empty(Box::new(span));",
          "    assert_eq!(ast.span(), &span);",
          "    ",
          "    let flags_span = Span { start: Position(12), end: Position(13) };",
          "    let set_flags = SetFlags { span: flags_span, flags: Flags::new() };",
          "    let ast = Ast::Flags(Box::new(set_flags));",
          "    assert_eq!(ast.span(), &flags_span);",
          "    ",
          "    let literal_span = Span { start: Position(14), end: Position(15) };",
          "    let literal = Literal { span: literal_span, kind: LiteralKind::Char, c: 'a' };",
          "    let ast = Ast::Literal(Box::new(literal));",
          "    assert_eq!(ast.span(), &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(16), end: Position(17) };",
          "    let ast = Ast::Dot(Box::new(dot_span));",
          "    assert_eq!(ast.span(), &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(18), end: Position(19) };",
          "    let assertion = Assertion { span: assertion_span, kind: AssertionKind::WordBoundary };",
          "    let ast = Ast::Assertion(Box::new(assertion));",
          "    assert_eq!(ast.span(), &assertion_span);",
          "    ",
          "    let unicode_span = Span { start: Position(20), end: Position(21) };",
          "    let class_unicode = ClassUnicode { span: unicode_span, negated: false, kind: ClassUnicodeKind::Letter };",
          "    let ast = Ast::ClassUnicode(Box::new(class_unicode));",
          "    assert_eq!(ast.span(), &unicode_span);",
          "    ",
          "    let perl_class_span = Span { start: Position(22), end: Position(23) };",
          "    let class_perl = ClassPerl { span: perl_class_span, kind: ClassPerlKind::Digit, negated: false };",
          "    let ast = Ast::ClassPerl(Box::new(class_perl));",
          "    assert_eq!(ast.span(), &perl_class_span);",
          "    ",
          "    let bracketed_span = Span { start: Position(24), end: Position(25) };",
          "    let class_bracketed = ClassBracketed { span: bracketed_span, negated: false, kind: ClassSet::Normal };",
          "    let ast = Ast::ClassBracketed(Box::new(class_bracketed));",
          "    assert_eq!(ast.span(), &bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(26), end: Position(27) };",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(ast) };",
          "    let ast = Ast::Repetition(Box::new(repetition));",
          "    assert_eq!(ast.span(), &repetition.span);",
          "    ",
          "    let group_span = Span { start: Position(28), end: Position(29) };",
          "    let group = Group { span: group_span, kind: GroupKind::Capture, ast: Box::new(ast) };",
          "    let ast = Ast::Group(Box::new(group));",
          "    assert_eq!(ast.span(), &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(30), end: Position(31) };",
          "    let alternation = Alternation { span: alternation_span, asts: vec![ast] };",
          "    let ast = Ast::Alternation(Box::new(alternation));",
          "    assert_eq!(ast.span(), &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(32), end: Position(33) };",
          "    let concat = Concat { span: concat_span, asts: vec![ast] };",
          "    let ast = Ast::Concat(Box::new(concat));",
          "    assert_eq!(ast.span(), &concat_span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(12),",
          "        end: Position(13),",
          "    };",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(Ast::empty(span)),",
          "    };",
          "    let ast = Ast::repetition(repetition);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(12), end: Position(13) };",
          "    let ast_empty = Ast::empty(span);",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags = SetFlags { span, flags: Flags };",
          "    let ast_flags = Ast::flags(flags);",
          "    assert_eq!(ast_flags.span(), &span);",
          "    ",
          "    let literal = Literal { span, kind: LiteralKind, c: 'a' };",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span);",
          "    ",
          "    let dot_ast = Ast::dot(span);",
          "    assert_eq!(dot_ast.span(), &span);",
          "    ",
          "    let assertion = Assertion { span, kind: AssertionKind };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span);",
          "    ",
          "    let class_unicode = ClassUnicode { span, negated: false, kind: ClassUnicodeKind };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span);",
          "    ",
          "    let class_perl = ClassPerl { span, kind: ClassPerlKind, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span);",
          "    ",
          "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span);",
          "    ",
          "    let group = Group { span, kind: GroupKind, ast: Box::new(Ast::empty(span)) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span);",
          "    ",
          "    let alternation = Alternation { span, asts: vec![ast_empty] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span);",
          "    ",
          "    let concat = Concat { span, asts: vec![ast_empty] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(12),",
          "        end: Position(13),",
          "    };",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(Ast::empty(span)),",
          "    };",
          "    let ast = Ast::repetition(repetition);",
          "    ast.span();",
          "    let span = Span { start: Position(12), end: Position(13) };",
          "    let ast_empty = Ast::empty(span);",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags = SetFlags { span, flags: Flags };",
          "    let ast_flags = Ast::flags(flags);",
          "    assert_eq!(ast_flags.span(), &span);",
          "    ",
          "    let literal = Literal { span, kind: LiteralKind, c: 'a' };",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span);",
          "    ",
          "    let dot_ast = Ast::dot(span);",
          "    assert_eq!(dot_ast.span(), &span);",
          "    ",
          "    let assertion = Assertion { span, kind: AssertionKind };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span);",
          "    ",
          "    let class_unicode = ClassUnicode { span, negated: false, kind: ClassUnicodeKind };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span);",
          "    ",
          "    let class_perl = ClassPerl { span, kind: ClassPerlKind, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span);",
          "    ",
          "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span);",
          "    ",
          "    let group = Group { span, kind: GroupKind, ast: Box::new(Ast::empty(span)) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span);",
          "    ",
          "    let alternation = Alternation { span, asts: vec![ast_empty] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span);",
          "    ",
          "    let concat = Concat { span, asts: vec![ast_empty] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(14),",
          "        end: Position(15),",
          "    };",
          "    let group = Group {",
          "        span,",
          "        kind: GroupKind::Capture,",
          "        ast: Box::new(Ast::empty(span)),",
          "    };",
          "    let ast = Ast::group(group);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(14), end: Position(15) };",
          "    let ast_empty = Ast::Empty(Box::new(span));",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags_span = Span { start: Position(0), end: Position(0) };",
          "    let ast_flags = Ast::Flags(Box::new(SetFlags { span: flags_span, flags: Flags::new() }));",
          "    assert_eq!(ast_flags.span(), &flags_span);",
          "    ",
          "    let literal_span = Span { start: Position(1), end: Position(2) };",
          "    let ast_literal = Ast::Literal(Box::new(Literal { span: literal_span, kind: LiteralKind::Char, c: 'a' }));",
          "    assert_eq!(ast_literal.span(), &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(3), end: Position(4) };",
          "    let ast_dot = Ast::Dot(Box::new(dot_span));",
          "    assert_eq!(ast_dot.span(), &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(5), end: Position(6) };",
          "    let ast_assertion = Ast::Assertion(Box::new(Assertion { span: assertion_span, kind: AssertionKind::WordBoundary }));",
          "    assert_eq!(ast_assertion.span(), &assertion_span);",
          "    ",
          "    let class_unicode_span = Span { start: Position(7), end: Position(8) };",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(ClassUnicode { span: class_unicode_span, negated: false, kind: ClassUnicodeKind::Any }));",
          "    assert_eq!(ast_class_unicode.span(), &class_unicode_span);",
          "    ",
          "    let class_perl_span = Span { start: Position(9), end: Position(10) };",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(ClassPerl { span: class_perl_span, kind: ClassPerlKind::Digit, negated: false }));",
          "    assert_eq!(ast_class_perl.span(), &class_perl_span);",
          "    ",
          "    let class_bracketed_span = Span { start: Position(11), end: Position(12) };",
          "    let ast_class_bracketed = Ast::ClassBracketed(Box::new(ClassBracketed { span: class_bracketed_span, negated: false, kind: ClassSet::Normal }));",
          "    assert_eq!(ast_class_bracketed.span(), &class_bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(13), end: Position(14) };",
          "    let ast_repetition = Ast::Repetition(Box::new(Repetition { span: repetition_span, min: 1, max: Some(5), greedy: true, sub: Box::new(ast_empty) }));",
          "    assert_eq!(ast_repetition.span(), &repetition_span);",
          "    ",
          "    let group_span = Span { start: Position(15), end: Position(16) };",
          "    let ast_group = Ast::Group(Box::new(Group { span: group_span, kind: GroupKind::NonCapture, ast: Box::new(ast_empty) }));",
          "    assert_eq!(ast_group.span(), &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(17), end: Position(18) };",
          "    let ast_alternation = Ast::Alternation(Box::new(Alternation { span: alternation_span, asts: vec![ast_empty] }));",
          "    assert_eq!(ast_alternation.span(), &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(19), end: Position(20) };",
          "    let ast_concat = Ast::Concat(Box::new(Concat { span: concat_span, asts: vec![ast_empty] }));",
          "    assert_eq!(ast_concat.span(), &concat_span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(14),",
          "        end: Position(15),",
          "    };",
          "    let group = Group {",
          "        span,",
          "        kind: GroupKind::Capture,",
          "        ast: Box::new(Ast::empty(span)),",
          "    };",
          "    let ast = Ast::group(group);",
          "    ast.span();",
          "    let span = Span { start: Position(14), end: Position(15) };",
          "    let ast_empty = Ast::Empty(Box::new(span));",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags_span = Span { start: Position(0), end: Position(0) };",
          "    let ast_flags = Ast::Flags(Box::new(SetFlags { span: flags_span, flags: Flags::new() }));",
          "    assert_eq!(ast_flags.span(), &flags_span);",
          "    ",
          "    let literal_span = Span { start: Position(1), end: Position(2) };",
          "    let ast_literal = Ast::Literal(Box::new(Literal { span: literal_span, kind: LiteralKind::Char, c: 'a' }));",
          "    assert_eq!(ast_literal.span(), &literal_span);",
          "    ",
          "    let dot_span = Span { start: Position(3), end: Position(4) };",
          "    let ast_dot = Ast::Dot(Box::new(dot_span));",
          "    assert_eq!(ast_dot.span(), &dot_span);",
          "    ",
          "    let assertion_span = Span { start: Position(5), end: Position(6) };",
          "    let ast_assertion = Ast::Assertion(Box::new(Assertion { span: assertion_span, kind: AssertionKind::WordBoundary }));",
          "    assert_eq!(ast_assertion.span(), &assertion_span);",
          "    ",
          "    let class_unicode_span = Span { start: Position(7), end: Position(8) };",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(ClassUnicode { span: class_unicode_span, negated: false, kind: ClassUnicodeKind::Any }));",
          "    assert_eq!(ast_class_unicode.span(), &class_unicode_span);",
          "    ",
          "    let class_perl_span = Span { start: Position(9), end: Position(10) };",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(ClassPerl { span: class_perl_span, kind: ClassPerlKind::Digit, negated: false }));",
          "    assert_eq!(ast_class_perl.span(), &class_perl_span);",
          "    ",
          "    let class_bracketed_span = Span { start: Position(11), end: Position(12) };",
          "    let ast_class_bracketed = Ast::ClassBracketed(Box::new(ClassBracketed { span: class_bracketed_span, negated: false, kind: ClassSet::Normal }));",
          "    assert_eq!(ast_class_bracketed.span(), &class_bracketed_span);",
          "    ",
          "    let repetition_span = Span { start: Position(13), end: Position(14) };",
          "    let ast_repetition = Ast::Repetition(Box::new(Repetition { span: repetition_span, min: 1, max: Some(5), greedy: true, sub: Box::new(ast_empty) }));",
          "    assert_eq!(ast_repetition.span(), &repetition_span);",
          "    ",
          "    let group_span = Span { start: Position(15), end: Position(16) };",
          "    let ast_group = Ast::Group(Box::new(Group { span: group_span, kind: GroupKind::NonCapture, ast: Box::new(ast_empty) }));",
          "    assert_eq!(ast_group.span(), &group_span);",
          "    ",
          "    let alternation_span = Span { start: Position(17), end: Position(18) };",
          "    let ast_alternation = Ast::Alternation(Box::new(Alternation { span: alternation_span, asts: vec![ast_empty] }));",
          "    assert_eq!(ast_alternation.span(), &alternation_span);",
          "    ",
          "    let concat_span = Span { start: Position(19), end: Position(20) };",
          "    let ast_concat = Ast::Concat(Box::new(Concat { span: concat_span, asts: vec![ast_empty] }));",
          "    assert_eq!(ast_concat.span(), &concat_span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(16),",
          "        end: Position(17),",
          "    };",
          "    let alternation = Alternation {",
          "        span,",
          "        asts: vec![Ast::empty(span), Ast::empty(span)],",
          "    };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(16), end: Position(17) };",
          "    let ast_empty = Ast::Empty(Box::new(span.clone()));",
          "    assert_eq!(ast_empty.span(), &span);",
          "    let ast_flags = Ast::Flags(Box::new(SetFlags { span: span.clone(), flags: Flags }));",
          "    assert_eq!(ast_flags.span(), &span);",
          "    let ast_literal = Ast::Literal(Box::new(Literal { span: span.clone(), kind: LiteralKind, c: 'a' }));",
          "    assert_eq!(ast_literal.span(), &span);",
          "    let ast_dot = Ast::Dot(Box::new(span.clone()));",
          "    assert_eq!(ast_dot.span(), &span);",
          "    let ast_assertion = Ast::Assertion(Box::new(Assertion { span: span.clone(), kind: AssertionKind }));",
          "    assert_eq!(ast_assertion.span(), &span);",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind }));",
          "    assert_eq!(ast_class_unicode.span(), &span);",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(ClassPerl { span: span.clone(), kind: ClassPerlKind, negated: false }));",
          "    assert_eq!(ast_class_perl.span(), &span);",
          "    let ast_class_bracketed = Ast::ClassBracketed(Box::new(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet }));",
          "    assert_eq!(ast_class_bracketed.span(), &span);",
          "    let ast_repetition = Ast::Repetition(Box::new(Repetition { span: span.clone(), min: 1, max: Some(1), greedy: true, sub: Box::new(ast_empty) }));",
          "    assert_eq!(ast_repetition.span(), &span);",
          "    let ast_group = Ast::Group(Box::new(Group { span: span.clone(), kind: GroupKind, ast: Box::new(ast_empty) }));",
          "    assert_eq!(ast_group.span(), &span);",
          "    let ast_alternation = Ast::Alternation(Box::new(Alternation { span: span.clone(), asts: vec![ast_empty, ast_empty] }));",
          "    assert_eq!(ast_alternation.span(), &span);",
          "    let ast_concat = Ast::Concat(Box::new(Concat { span: span.clone(), asts: vec![ast_empty, ast_empty] }));",
          "    assert_eq!(ast_concat.span(), &span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(16),",
          "        end: Position(17),",
          "    };",
          "    let alternation = Alternation {",
          "        span,",
          "        asts: vec![Ast::empty(span), Ast::empty(span)],",
          "    };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.span();",
          "    let span = Span { start: Position(16), end: Position(17) };",
          "    let ast_empty = Ast::Empty(Box::new(span.clone()));",
          "    assert_eq!(ast_empty.span(), &span);",
          "    let ast_flags = Ast::Flags(Box::new(SetFlags { span: span.clone(), flags: Flags }));",
          "    assert_eq!(ast_flags.span(), &span);",
          "    let ast_literal = Ast::Literal(Box::new(Literal { span: span.clone(), kind: LiteralKind, c: 'a' }));",
          "    assert_eq!(ast_literal.span(), &span);",
          "    let ast_dot = Ast::Dot(Box::new(span.clone()));",
          "    assert_eq!(ast_dot.span(), &span);",
          "    let ast_assertion = Ast::Assertion(Box::new(Assertion { span: span.clone(), kind: AssertionKind }));",
          "    assert_eq!(ast_assertion.span(), &span);",
          "    let ast_class_unicode = Ast::ClassUnicode(Box::new(ClassUnicode { span: span.clone(), negated: false, kind: ClassUnicodeKind }));",
          "    assert_eq!(ast_class_unicode.span(), &span);",
          "    let ast_class_perl = Ast::ClassPerl(Box::new(ClassPerl { span: span.clone(), kind: ClassPerlKind, negated: false }));",
          "    assert_eq!(ast_class_perl.span(), &span);",
          "    let ast_class_bracketed = Ast::ClassBracketed(Box::new(ClassBracketed { span: span.clone(), negated: false, kind: ClassSet }));",
          "    assert_eq!(ast_class_bracketed.span(), &span);",
          "    let ast_repetition = Ast::Repetition(Box::new(Repetition { span: span.clone(), min: 1, max: Some(1), greedy: true, sub: Box::new(ast_empty) }));",
          "    assert_eq!(ast_repetition.span(), &span);",
          "    let ast_group = Ast::Group(Box::new(Group { span: span.clone(), kind: GroupKind, ast: Box::new(ast_empty) }));",
          "    assert_eq!(ast_group.span(), &span);",
          "    let ast_alternation = Ast::Alternation(Box::new(Alternation { span: span.clone(), asts: vec![ast_empty, ast_empty] }));",
          "    assert_eq!(ast_alternation.span(), &span);",
          "    let ast_concat = Ast::Concat(Box::new(Concat { span: span.clone(), asts: vec![ast_empty, ast_empty] }));",
          "    assert_eq!(ast_concat.span(), &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span {",
          "        start: Position(18),",
          "        end: Position(19),",
          "    };",
          "    let concat = Concat {",
          "        span,",
          "        asts: vec![Ast::empty(span), Ast::empty(span)],",
          "    };",
          "    let ast = Ast::concat(concat);",
          "    ast.span();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position(18), end: Position(19) };",
          "    let ast_empty = Ast::empty(span);",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags = SetFlags { span, flags: Flags::new() };",
          "    let ast_flags = Ast::flags(flags);",
          "    assert_eq!(ast_flags.span(), &span);",
          "    ",
          "    let literal = Literal { span, kind: LiteralKind::Char, c: 'a' };",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span);",
          "    ",
          "    let dot_ast = Ast::dot(span);",
          "    assert_eq!(dot_ast.span(), &span);",
          "    ",
          "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span);",
          "    ",
          "    let class_unicode = ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Unicode };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span);",
          "    ",
          "    let class_perl = ClassPerl { span, kind: ClassPerlKind::Word, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span);",
          "    ",
          "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Normal };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span);",
          "    ",
          "    let repetition = Repetition { min: 1, max: Some(1), greedy: true, sub: Box::new(ast_empty) };",
          "    let ast_repetition = Ast::repetition(repetition);",
          "    assert_eq!(ast_repetition.span(), &span);",
          "    ",
          "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(ast_empty) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span);",
          "    ",
          "    let alternation = Alternation { span, asts: vec![ast_empty, ast_empty] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span);",
          "    ",
          "    let concat = Concat { span, asts: vec![ast_empty, ast_empty] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span);"
        ],
        "code": [
          "{",
          "    let span = Span {",
          "        start: Position(18),",
          "        end: Position(19),",
          "    };",
          "    let concat = Concat {",
          "        span,",
          "        asts: vec![Ast::empty(span), Ast::empty(span)],",
          "    };",
          "    let ast = Ast::concat(concat);",
          "    ast.span();",
          "    let span = Span { start: Position(18), end: Position(19) };",
          "    let ast_empty = Ast::empty(span);",
          "    assert_eq!(ast_empty.span(), &span);",
          "    ",
          "    let flags = SetFlags { span, flags: Flags::new() };",
          "    let ast_flags = Ast::flags(flags);",
          "    assert_eq!(ast_flags.span(), &span);",
          "    ",
          "    let literal = Literal { span, kind: LiteralKind::Char, c: 'a' };",
          "    let ast_literal = Ast::literal(literal);",
          "    assert_eq!(ast_literal.span(), &span);",
          "    ",
          "    let dot_ast = Ast::dot(span);",
          "    assert_eq!(dot_ast.span(), &span);",
          "    ",
          "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
          "    let ast_assertion = Ast::assertion(assertion);",
          "    assert_eq!(ast_assertion.span(), &span);",
          "    ",
          "    let class_unicode = ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Unicode };",
          "    let ast_class_unicode = Ast::class_unicode(class_unicode);",
          "    assert_eq!(ast_class_unicode.span(), &span);",
          "    ",
          "    let class_perl = ClassPerl { span, kind: ClassPerlKind::Word, negated: false };",
          "    let ast_class_perl = Ast::class_perl(class_perl);",
          "    assert_eq!(ast_class_perl.span(), &span);",
          "    ",
          "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Normal };",
          "    let ast_class_bracketed = Ast::class_bracketed(class_bracketed);",
          "    assert_eq!(ast_class_bracketed.span(), &span);",
          "    ",
          "    let repetition = Repetition { min: 1, max: Some(1), greedy: true, sub: Box::new(ast_empty) };",
          "    let ast_repetition = Ast::repetition(repetition);",
          "    assert_eq!(ast_repetition.span(), &span);",
          "    ",
          "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(ast_empty) };",
          "    let ast_group = Ast::group(group);",
          "    assert_eq!(ast_group.span(), &span);",
          "    ",
          "    let alternation = Alternation { span, asts: vec![ast_empty, ast_empty] };",
          "    let ast_alternation = Ast::alternation(alternation);",
          "    assert_eq!(ast_alternation.span(), &span);",
          "    ",
          "    let concat = Concat { span, asts: vec![ast_empty, ast_empty] };",
          "    let ast_concat = Ast::concat(concat);",
          "    assert_eq!(ast_concat.span(), &span);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]