[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyError;",
          "",
          "    let pattern = \"first line\\nsecond line\";",
          "    let span = ast::Span { start: Position::new(0, 0), end: Position::new(0, 12) }; // Span covering first line",
          "    let aux_span = Some(ast::Span { start: Position::new(1, 0), end: Position::new(1, 12) }); // Span covering second line",
          "",
          "    let formatter = Formatter {",
          "        pattern,",
          "        err: &DummyError,",
          "        span: &span,",
          "        aux_span,",
          "    };",
          "",
          "    let spans = Spans::from_formatter(&formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(spans.pattern, \"first line\\nsecond line\");",
          "    assert_eq!(spans.line_number_width, 2);",
          "    assert_eq!(spans.by_line.len(), 2);",
          "    assert_eq!(spans.by_line[0].len(), 1);",
          "    assert_eq!(spans.by_line[1].len(), 1);",
          "    assert_eq!(spans.by_line[0][0].start, Position::new(0, 0));",
          "    assert_eq!(spans.by_line[0][0].end, Position::new(0, 12));",
          "    assert_eq!(spans.by_line[1][0].start, Position::new(1, 0));",
          "    assert_eq!(spans.by_line[1][0].end, Position::new(1, 12));",
          "    assert!(spans.multi_line.is_empty());"
        ],
        "code": [
          "{",
          "    struct DummyError;",
          "",
          "    let pattern = \"first line\\nsecond line\";",
          "    let span = ast::Span { start: Position::new(0, 0), end: Position::new(0, 12) }; // Span covering first line",
          "    let aux_span = Some(ast::Span { start: Position::new(1, 0), end: Position::new(1, 12) }); // Span covering second line",
          "",
          "    let formatter = Formatter {",
          "        pattern,",
          "        err: &DummyError,",
          "        span: &span,",
          "        aux_span,",
          "    };",
          "",
          "    let spans = Spans::from_formatter(&formatter);",
          "    assert_eq!(spans.pattern, \"first line\\nsecond line\");",
          "    assert_eq!(spans.line_number_width, 2);",
          "    assert_eq!(spans.by_line.len(), 2);",
          "    assert_eq!(spans.by_line[0].len(), 1);",
          "    assert_eq!(spans.by_line[1].len(), 1);",
          "    assert_eq!(spans.by_line[0][0].start, Position::new(0, 0));",
          "    assert_eq!(spans.by_line[0][0].end, Position::new(0, 12));",
          "    assert_eq!(spans.by_line[1][0].start, Position::new(1, 0));",
          "    assert_eq!(spans.by_line[1][0].end, Position::new(1, 12));",
          "    assert!(spans.multi_line.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]