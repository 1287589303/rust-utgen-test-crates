[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 1, // StartKind::Unanchored",
          "        // StartByteMap with valid configurations",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 0, // maybe_pattern_len = 0 (assuming within LIMIT)",
          "        1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 0, // StartKind::Both",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 1, // maybe_pattern_len = 1 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    1, 0, 0, 0, // universal_anchored (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 1, // StartKind::Unanchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 5, // maybe_pattern_len = 5 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    1, 0, 0, 0, // universal_anchored (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 2, // StartKind::Anchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 3, // maybe_pattern_len = 3 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    2, 0, 0, 0, // universal_anchored (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 0, // StartKind::Both",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 1, // maybe_pattern_len = 1 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    0, 0, 0, 0, // universal_anchored = 0 (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 1, // StartKind::Unanchored",
          "        // StartByteMap with valid configurations",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 0, // maybe_pattern_len = 0 (assuming within LIMIT)",
          "        1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 0, // StartKind::Both",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 1, // maybe_pattern_len = 1 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    1, 0, 0, 0, // universal_anchored (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 1, // StartKind::Unanchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 5, // maybe_pattern_len = 5 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    1, 0, 0, 0, // universal_anchored (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 2, // StartKind::Anchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 3, // maybe_pattern_len = 3 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    2, 0, 0, 0, // universal_anchored (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 0, // StartKind::Both",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 1, // maybe_pattern_len = 1 (assuming within LIMIT)",
          "    1, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    0, 0, 0, 0, // universal_anchored = 0 (valid StateID convertible)",
          "    // Start states for the table (6 * 4 bytes for StateID, assuming 4 bytes size)",
          "    ];",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 0, // StartKind::Both",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 5, // maybe_pattern_len = 5 (within LIMIT)",
          "        2, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let kind_check = StartKind::from_bytes(slice).is_ok();",
          "    let start_map_check = StartByteMap::from_bytes(slice).is_ok();",
          "    let stride_check = wire::try_read_u32_as_usize(slice, \"sparse start table stride\").is_ok();",
          "    let valid_stride = stride == Start::len();",
          "    let pattern_len_check = wire::try_read_u32_as_usize(slice, \"sparse start table patterns\").is_ok();",
          "    let invalid_pattern_len = maybe_pattern_len.as_u32() != u32::MAX;",
          "    let valid_pattern_len_limit = !pattern_len.map_or(false, |len| len > PatternID::LIMIT);",
          "    let universal_unanchored_check = wire::try_read_u32(slice, \"universal unanchored start\").is_ok();",
          "    let valid_universal_unanchored = universal_unanchored != u32::MAX;",
          "    let universal_start_check = StateID::try_from(universal_unanchored).is_ok();",
          "    let universal_anchored_check = wire::try_read_u32(slice, \"universal anchored start\").is_err();"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 0, // StartKind::Both",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 5, // maybe_pattern_len = 5 (within LIMIT)",
          "        2, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    let kind_check = StartKind::from_bytes(slice).is_ok();",
          "    let start_map_check = StartByteMap::from_bytes(slice).is_ok();",
          "    let stride_check = wire::try_read_u32_as_usize(slice, \"sparse start table stride\").is_ok();",
          "    let valid_stride = stride == Start::len();",
          "    let pattern_len_check = wire::try_read_u32_as_usize(slice, \"sparse start table patterns\").is_ok();",
          "    let invalid_pattern_len = maybe_pattern_len.as_u32() != u32::MAX;",
          "    let valid_pattern_len_limit = !pattern_len.map_or(false, |len| len > PatternID::LIMIT);",
          "    let universal_unanchored_check = wire::try_read_u32(slice, \"universal unanchored start\").is_ok();",
          "    let valid_universal_unanchored = universal_unanchored != u32::MAX;",
          "    let universal_start_check = StateID::try_from(universal_unanchored).is_ok();",
          "    let universal_anchored_check = wire::try_read_u32(slice, \"universal anchored start\").is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 2, // StartKind::Anchored",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 1, // maybe_pattern_len = 1 (within LIMIT)",
          "        3, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 0, // StartKind::Both",
          "    0, 0, 0, 1, // Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 0, // maybe_pattern_len = 0 (within LIMIT)",
          "    3, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    0, 0, 0, 0, // universal_anchored = 0",
          "    ];",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 1, // StartKind::Unanchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 0, // maybe_pattern_len = 0 (within LIMIT)",
          "    2, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "    ];",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 2, // StartKind::Anchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 1, // maybe_pattern_len = 1 (within LIMIT)",
          "    4, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "    ];",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 2, // StartKind::Anchored",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 1, // maybe_pattern_len = 1 (within LIMIT)",
          "        3, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 0, // StartKind::Both",
          "    0, 0, 0, 1, // Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 0, // maybe_pattern_len = 0 (within LIMIT)",
          "    3, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    0, 0, 0, 0, // universal_anchored = 0",
          "    ];",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 1, // StartKind::Unanchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 0, // maybe_pattern_len = 0 (within LIMIT)",
          "    2, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "    ];",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let slice: &[u8] = &[",
          "    0, 0, 0, 2, // StartKind::Anchored",
          "    0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "    0, 0, 0, 6, // stride = 6",
          "    0, 0, 0, 1, // maybe_pattern_len = 1 (within LIMIT)",
          "    4, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "    u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "    ];",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 1, // StartKind::Unanchored",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 1, // maybe_pattern_len = 1 (within LIMIT)",
          "        4, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "}"
        ],
        "oracle": [
          "    unsafe { StartTable::from_bytes_unchecked(slice) }.isOk();",
          "    slice[0..4].contains(&0); // Check for StartKind::Unanchored",
          "    slice[4..12].iter().all(|&x| (0..=5).contains(&(x as usize)); // Valid Start:: values",
          "    slice[12..16].eq(&[0, 0, 0, 6]); // Check for stride == 6",
          "    slice[16..20].eq(&[0, 0, 0, 1]); // Check for maybe_pattern_len == 1",
          "    slice[20..24].iter().all(|&x| x == 0xFF); // Check for universal_anchored == u32::MAX",
          "    slice.len() >= 24; // Ensure enough bytes for start states table",
          "    slice[12] != 0; // Ensure stride is non-zero",
          "    slice[24..].len() > 0; // Verify start state entries exist",
          "    slice.contains(&0_u8); // Ensure at least one Start:: entry for valid state"
        ],
        "code": [
          "{",
          "    let slice: &[u8] = &[",
          "        0, 0, 0, 1, // StartKind::Unanchored",
          "        0, 1, 2, 3, 4, 5, 6, 7, // valid Start:: values",
          "        0, 0, 0, 6, // stride = 6",
          "        0, 0, 0, 1, // maybe_pattern_len = 1 (within LIMIT)",
          "        4, 0, 0, 0, // universal_unanchored (valid StateID convertible)",
          "        u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, u32::MAX as u8, // universal_anchored = u32::MAX",
          "        // Start states for the table",
          "    ];",
          "    let _result = unsafe { StartTable::from_bytes_unchecked(slice) };",
          "    unsafe { StartTable::from_bytes_unchecked(slice) }.isOk();",
          "    slice[0..4].contains(&0); // Check for StartKind::Unanchored",
          "    slice[4..12].iter().all(|&x| (0..=5).contains(&(x as usize)); // Valid Start:: values",
          "    slice[12..16].eq(&[0, 0, 0, 6]); // Check for stride == 6",
          "    slice[16..20].eq(&[0, 0, 0, 1]); // Check for maybe_pattern_len == 1",
          "    slice[20..24].iter().all(|&x| x == 0xFF); // Check for universal_anchored == u32::MAX",
          "    slice.len() >= 24; // Ensure enough bytes for start states table",
          "    slice[12] != 0; // Ensure stride is non-zero",
          "    slice[24..].len() > 0; // Verify start state entries exist",
          "    slice.contains(&0_u8); // Ensure at least one Start:: entry for valid state",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]