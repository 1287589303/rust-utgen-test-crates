[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 0; // StartKind::Both",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "        &kind_value.to_le_bytes()[..],",
          "        &start_map_bytes[..],",
          "        &stride_bytes[..],",
          "        &pattern_length_bytes[..],",
          "    ].concat();",
          "",
          "    let _ = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "}"
        ],
        "oracle": [
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 0; // StartKind::Both",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let (start_table, length) = result.unwrap();",
          "    assert_eq!(length, slice.len() - 512);",
          "    assert_eq!(start_table.kind, StartKind::Both);",
          "    assert_eq!(start_table.pattern_len, Some(0));",
          "    assert_eq!(start_table.stride, 6);"
        ],
        "code": [
          "{",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 0; // StartKind::Both",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "        &kind_value.to_le_bytes()[..],",
          "        &start_map_bytes[..],",
          "        &stride_bytes[..],",
          "        &pattern_length_bytes[..],",
          "    ].concat();",
          "",
          "    let _ = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 0; // StartKind::Both",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    ",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_ok());",
          "    ",
          "    let (start_table, length) = result.unwrap();",
          "    assert_eq!(length, slice.len() - 512);",
          "    assert_eq!(start_table.kind, StartKind::Both);",
          "    assert_eq!(start_table.pattern_len, Some(0));",
          "    assert_eq!(start_table.stride, 6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 1; // StartKind::Unanchored",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "        &kind_value.to_le_bytes()[..],",
          "        &start_map_bytes[..],",
          "        &stride_bytes[..],",
          "        &pattern_length_bytes[..],",
          "    ].concat();",
          "",
          "    let _ = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "}"
        ],
        "oracle": [
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 0; // StartKind::Both",
          "    let start_map_bytes = [0u8; 256]; // All valid Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = (u32::MAX).to_le_bytes(); // Invalid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 2; // StartKind::Anchored",
          "    let start_map_bytes = [5u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = (u32::MAX).to_le_bytes(); // Invalid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 1; // StartKind::Unanchored",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "        &kind_value.to_le_bytes()[..],",
          "        &start_map_bytes[..],",
          "        &stride_bytes[..],",
          "        &pattern_length_bytes[..],",
          "    ].concat();",
          "",
          "    let _ = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 0; // StartKind::Both",
          "    let start_map_bytes = [0u8; 256]; // All valid Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = (u32::MAX).to_le_bytes(); // Invalid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "    ",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 2; // StartKind::Anchored",
          "    let start_map_bytes = [5u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = (u32::MAX).to_le_bytes(); // Invalid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    let result = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 2; // StartKind::Anchored",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "        &kind_value.to_le_bytes()[..],",
          "        &start_map_bytes[..],",
          "        &stride_bytes[..],",
          "        &pattern_length_bytes[..],",
          "    ].concat();",
          "",
          "    let _ = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "}"
        ],
        "oracle": [
          "    let kind_value = 0; // StartKind::Both",
          "    let slice: [u8; 512] = [0; 512];",
          "    assert!(StartKind::from_bytes(&slice).is_ok());",
          "    let start_map_bytes = [1u8; 256];",
          "    let stride_bytes = 6u32.to_le_bytes();",
          "    let pattern_length_bytes = (u32::MAX).to_le_bytes(); // Invalid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    assert!(unsafe { StartTable::from_bytes_unchecked(&slice) }.is_err());",
          "    ",
          "    let kind_value = 0; // StartKind::Both",
          "    let slice: [u8; 512] = [0; 512];",
          "    assert!(StartKind::from_bytes(&slice).is_ok());",
          "    let start_map_bytes = [1u8; 256];",
          "    let stride_bytes = 6u32.to_le_bytes();",
          "    let pattern_length_bytes = 1u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    assert!(wire::try_read_u32_as_usize(&slice, \"sparse start table patterns\").is_ok());",
          "    assert!(wire::try_read_u32_as_usize(&slice, \"sparse start table stride\").is_ok());",
          "    assert_eq!(stride_bytes, 6u32.to_le_bytes());",
          "    assert!(unsafe { StartTable::from_bytes_unchecked(&slice) }.is_ok());"
        ],
        "code": [
          "{",
          "    let slice: [u8; 512] = [0; 512];",
          "    let kind_value = 2; // StartKind::Anchored",
          "    let start_map_bytes = [1u8; 256]; // Example Start values",
          "    let stride_bytes = 6u32.to_le_bytes(); // Must equal Start::len()",
          "    let pattern_length_bytes = 0u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "        &kind_value.to_le_bytes()[..],",
          "        &start_map_bytes[..],",
          "        &stride_bytes[..],",
          "        &pattern_length_bytes[..],",
          "    ].concat();",
          "",
          "    let _ = unsafe { StartTable::from_bytes_unchecked(&slice) };",
          "    let kind_value = 0; // StartKind::Both",
          "    let slice: [u8; 512] = [0; 512];",
          "    assert!(StartKind::from_bytes(&slice).is_ok());",
          "    let start_map_bytes = [1u8; 256];",
          "    let stride_bytes = 6u32.to_le_bytes();",
          "    let pattern_length_bytes = (u32::MAX).to_le_bytes(); // Invalid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    assert!(unsafe { StartTable::from_bytes_unchecked(&slice) }.is_err());",
          "    ",
          "    let kind_value = 0; // StartKind::Both",
          "    let slice: [u8; 512] = [0; 512];",
          "    assert!(StartKind::from_bytes(&slice).is_ok());",
          "    let start_map_bytes = [1u8; 256];",
          "    let stride_bytes = 6u32.to_le_bytes();",
          "    let pattern_length_bytes = 1u32.to_le_bytes(); // Valid pattern length",
          "    let slice = [",
          "    &kind_value.to_le_bytes()[..],",
          "    &start_map_bytes[..],",
          "    &stride_bytes[..],",
          "    &pattern_length_bytes[..],",
          "    ].concat();",
          "    assert!(wire::try_read_u32_as_usize(&slice, \"sparse start table patterns\").is_ok());",
          "    assert!(wire::try_read_u32_as_usize(&slice, \"sparse start table stride\").is_ok());",
          "    assert_eq!(stride_bytes, 6u32.to_le_bytes());",
          "    assert!(unsafe { StartTable::from_bytes_unchecked(&slice) }.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]