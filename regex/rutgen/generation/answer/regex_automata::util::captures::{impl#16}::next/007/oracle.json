[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_info_inner = GroupInfoInner {",
          "        index_to_name: vec![vec![Some(Arc::from(\"first_group\")), Some(Arc::from(\"second_group\"))]],",
          "        ..Default::default()",
          "    };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    ",
          "    let pids = PatternIDIter::new(vec![PatternID::default()]).into_iter();",
          "    let mut all_names = GroupInfoAllNames {",
          "        group_info: &group_info,",
          "        pids,",
          "        current_pid: Some(PatternID::default()),",
          "        names: None,",
          "    };",
          "",
          "    let result = all_names.next();",
          "}"
        ],
        "oracle": [
          "    let group_info_inner = GroupInfoInner { index_to_name: vec![vec![Some(Arc::from(\"first_group\")), Some(Arc::from(\"second_group\"))]], ..Default::default() };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    let pids = PatternIDIter::new(vec![PatternID::default()]).into_iter();",
          "    let mut all_names = GroupInfoAllNames { group_info: &group_info, pids, current_pid: Some(PatternID::default()), names: Some(core::iter::enumerate(group_info.pattern_names(PatternID::default()))) };",
          "    let result = all_names.next();",
          "    assert!(result.is_some());",
          "    let (pid, group_index, name) = result.unwrap();",
          "    assert_eq!(pid, PatternID::default());",
          "    assert_eq!(group_index, 0);",
          "    assert_eq!(name, Some(\"first_group\"));"
        ],
        "code": [
          "{",
          "    let group_info_inner = GroupInfoInner {",
          "        index_to_name: vec![vec![Some(Arc::from(\"first_group\")), Some(Arc::from(\"second_group\"))]],",
          "        ..Default::default()",
          "    };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    ",
          "    let pids = PatternIDIter::new(vec![PatternID::default()]).into_iter();",
          "    let mut all_names = GroupInfoAllNames {",
          "        group_info: &group_info,",
          "        pids,",
          "        current_pid: Some(PatternID::default()),",
          "        names: None,",
          "    };",
          "",
          "    let result = all_names.next();",
          "    let group_info_inner = GroupInfoInner { index_to_name: vec![vec![Some(Arc::from(\"first_group\")), Some(Arc::from(\"second_group\"))]], ..Default::default() };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    let pids = PatternIDIter::new(vec![PatternID::default()]).into_iter();",
          "    let mut all_names = GroupInfoAllNames { group_info: &group_info, pids, current_pid: Some(PatternID::default()), names: Some(core::iter::enumerate(group_info.pattern_names(PatternID::default()))) };",
          "    let result = all_names.next();",
          "    assert!(result.is_some());",
          "    let (pid, group_index, name) = result.unwrap();",
          "    assert_eq!(pid, PatternID::default());",
          "    assert_eq!(group_index, 0);",
          "    assert_eq!(name, Some(\"first_group\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_info_inner = GroupInfoInner {",
          "        index_to_name: vec![",
          "            vec![Some(Arc::from(\"group_0\")), Some(Arc::from(\"group_1\"))],",
          "            vec![Some(Arc::from(\"group_2\"))],",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    ",
          "    let pids = PatternIDIter::new(vec![PatternID::default(), PatternID(SmallIndex(1))]).into_iter();",
          "    let mut all_names = GroupInfoAllNames {",
          "        group_info: &group_info,",
          "        pids,",
          "        current_pid: Some(PatternID::default()),",
          "        names: None,",
          "    };",
          "",
          "    let result = all_names.next();",
          "    let next_result = all_names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some((PatternID::default(), 0, Some(\"group_0\"))));",
          "    assert_eq!(next_result, Some((PatternID::default(), 1, Some(\"group_1\"))));"
        ],
        "code": [
          "{",
          "    let group_info_inner = GroupInfoInner {",
          "        index_to_name: vec![",
          "            vec![Some(Arc::from(\"group_0\")), Some(Arc::from(\"group_1\"))],",
          "            vec![Some(Arc::from(\"group_2\"))],",
          "        ],",
          "        ..Default::default()",
          "    };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    ",
          "    let pids = PatternIDIter::new(vec![PatternID::default(), PatternID(SmallIndex(1))]).into_iter();",
          "    let mut all_names = GroupInfoAllNames {",
          "        group_info: &group_info,",
          "        pids,",
          "        current_pid: Some(PatternID::default()),",
          "        names: None,",
          "    };",
          "",
          "    let result = all_names.next();",
          "    let next_result = all_names.next();",
          "    assert_eq!(result, Some((PatternID::default(), 0, Some(\"group_0\"))));",
          "    assert_eq!(next_result, Some((PatternID::default(), 1, Some(\"group_1\"))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_info_inner = GroupInfoInner {",
          "        index_to_name: vec![vec![Some(Arc::from(\"only_group\"))]],",
          "        ..Default::default()",
          "    };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    ",
          "    let pids = PatternIDIter::new(vec![PatternID::default()]).into_iter();",
          "    let mut all_names = GroupInfoAllNames {",
          "        group_info: &group_info,",
          "        pids,",
          "        current_pid: Some(PatternID::default()),",
          "        names: None,",
          "    };",
          "",
          "    let result = all_names.next();",
          "}"
        ],
        "oracle": [
          "    let expected_result = Some((PatternID::default(), 0, Some(\"only_group\")));",
          "    assert_eq!(result, expected_result);"
        ],
        "code": [
          "{",
          "    let group_info_inner = GroupInfoInner {",
          "        index_to_name: vec![vec![Some(Arc::from(\"only_group\"))]],",
          "        ..Default::default()",
          "    };",
          "    let group_info = GroupInfo(Arc::new(group_info_inner));",
          "    ",
          "    let pids = PatternIDIter::new(vec![PatternID::default()]).into_iter();",
          "    let mut all_names = GroupInfoAllNames {",
          "        group_info: &group_info,",
          "        pids,",
          "        current_pid: Some(PatternID::default()),",
          "        names: None,",
          "    };",
          "",
          "    let result = all_names.next();",
          "    let expected_result = Some((PatternID::default(), 0, Some(\"only_group\")));",
          "    assert_eq!(result, expected_result);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]