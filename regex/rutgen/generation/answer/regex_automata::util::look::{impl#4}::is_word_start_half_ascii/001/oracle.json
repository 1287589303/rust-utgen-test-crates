[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"word_example\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false); // 'word_example' has a word character before index 1",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"_test\", 1), false); // underscore is a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\" test\", 1), true); // space is not a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"123test\", 1), false); // digit is a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"abc\", 1), false); // 'a' is a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"  \", 1), true); // space is not a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"\", 1), false); // out of bounds (should not panic, but check for handling)"
        ],
        "code": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"word_example\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "    assert_eq!(result, false); // 'word_example' has a word character before index 1",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"_test\", 1), false); // underscore is a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\" test\", 1), true); // space is not a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"123test\", 1), false); // digit is a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"abc\", 1), false); // 'a' is a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"  \", 1), true); // space is not a word character",
          "    assert_eq!(matcher.is_word_start_half_ascii(b\"\", 1), false); // out of bounds (should not panic, but check for handling)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"!nonword\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "}"
        ],
        "oracle": [
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"!nonword\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "    assert_eq!(result, true); // word_before is false since haystack[0] is not a word byte",
          "    let at = 0; // at = 0",
          "    let result_at_zero = matcher.is_word_start_half_ascii(haystack, at);",
          "    assert_eq!(result_at_zero, true); // should return true as at is zero",
          "    let haystack_with_word = b\"nword\";",
          "    let at_word = 1; // haystack[0] is a word byte ('n')",
          "    let result_word = matcher.is_word_start_half_ascii(haystack_with_word, at_word);",
          "    assert_eq!(result_word, false); // word_before is true since haystack[0] is a word byte",
          "    let at_end = haystack.len(); // at = haystack.len()",
          "    let result_at_end = matcher.is_word_start_half_ascii(haystack, at_end);",
          "    assert_eq!(result_at_end, true); // should return true as defined in documentation"
        ],
        "code": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"!nonword\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"!nonword\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "    assert_eq!(result, true); // word_before is false since haystack[0] is not a word byte",
          "    let at = 0; // at = 0",
          "    let result_at_zero = matcher.is_word_start_half_ascii(haystack, at);",
          "    assert_eq!(result_at_zero, true); // should return true as at is zero",
          "    let haystack_with_word = b\"nword\";",
          "    let at_word = 1; // haystack[0] is a word byte ('n')",
          "    let result_word = matcher.is_word_start_half_ascii(haystack_with_word, at_word);",
          "    assert_eq!(result_word, false); // word_before is true since haystack[0] is a word byte",
          "    let at_end = haystack.len(); // at = haystack.len()",
          "    let result_at_end = matcher.is_word_start_half_ascii(haystack, at_end);",
          "    assert_eq!(result_at_end, true); // should return true as defined in documentation",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"1_first\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, false);"
        ],
        "code": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"1_first\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "    assert_eq!(result, false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"@starts\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, true);"
        ],
        "code": [
          "{",
          "    let matcher = LookMatcher::new();",
          "    let haystack = b\"@starts\";",
          "    let at = 1; // at > 0",
          "    let result = matcher.is_word_start_half_ascii(haystack, at);",
          "    assert_eq!(result, true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]