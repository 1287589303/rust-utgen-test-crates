[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind_empty = HirKind::Empty;",
          "    let hir_empty = Hir { kind: hir_kind_empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_empty.kind.subs(), &[]);",
          "    ",
          "    let hir_kind_char = HirKind::Char('a');",
          "    let hir_char = Hir { kind: hir_kind_char, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_char.kind.subs(), &[]);",
          "    ",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] });",
          "    let hir_class = Hir { kind: hir_kind_class, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_class.kind.subs(), &[]);",
          "    ",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let hir_look = Hir { kind: hir_kind_look, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_look.kind.subs(), &[]);",
          "    ",
          "    let repetition_sub = Box::new(HirKind::Char('b'));",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(2), greedy: true, sub: repetition_sub });",
          "    let hir_repetition = Hir { kind: hir_kind_repetition, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_repetition.kind.subs(), &[HirKind::Char('b')]);",
          "    ",
          "    let capture_sub = Box::new(HirKind::Char('c'));",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: capture_sub });",
          "    let hir_capture = Hir { kind: hir_kind_capture, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_capture.kind.subs(), &[HirKind::Char('c')]);",
          "    ",
          "    let concat_subs = vec![HirKind::Char('d'), HirKind::Char('e')];",
          "    let hir_kind_concat = HirKind::Concat(concat_subs.clone());",
          "    let hir_concat = Hir { kind: hir_kind_concat, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_concat.kind.subs(), &concat_subs);",
          "    ",
          "    let alternation_subs = vec![HirKind::Char('f'), HirKind::Char('g')];",
          "    let hir_kind_alternation = HirKind::Alternation(alternation_subs.clone());",
          "    let hir_alternation = Hir { kind: hir_kind_alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_alternation.kind.subs(), &alternation_subs);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "    let hir_kind_empty = HirKind::Empty;",
          "    let hir_empty = Hir { kind: hir_kind_empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_empty.kind.subs(), &[]);",
          "    ",
          "    let hir_kind_char = HirKind::Char('a');",
          "    let hir_char = Hir { kind: hir_kind_char, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_char.kind.subs(), &[]);",
          "    ",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] });",
          "    let hir_class = Hir { kind: hir_kind_class, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_class.kind.subs(), &[]);",
          "    ",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let hir_look = Hir { kind: hir_kind_look, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_look.kind.subs(), &[]);",
          "    ",
          "    let repetition_sub = Box::new(HirKind::Char('b'));",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(2), greedy: true, sub: repetition_sub });",
          "    let hir_repetition = Hir { kind: hir_kind_repetition, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_repetition.kind.subs(), &[HirKind::Char('b')]);",
          "    ",
          "    let capture_sub = Box::new(HirKind::Char('c'));",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: capture_sub });",
          "    let hir_capture = Hir { kind: hir_kind_capture, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_capture.kind.subs(), &[HirKind::Char('c')]);",
          "    ",
          "    let concat_subs = vec![HirKind::Char('d'), HirKind::Char('e')];",
          "    let hir_kind_concat = HirKind::Concat(concat_subs.clone());",
          "    let hir_concat = Hir { kind: hir_kind_concat, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_concat.kind.subs(), &concat_subs);",
          "    ",
          "    let alternation_subs = vec![HirKind::Char('f'), HirKind::Char('g')];",
          "    let hir_kind_alternation = HirKind::Alternation(alternation_subs.clone());",
          "    let hir_alternation = Hir { kind: hir_kind_alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_alternation.kind.subs(), &alternation_subs);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Char('a');",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind_empty = HirKind::Empty;",
          "    let expected_empty = &[];",
          "    let hir_empty = Hir { kind: hir_kind_empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_empty.kind.subs(), expected_empty);",
          "    ",
          "    let hir_kind_char = HirKind::Char('b');",
          "    let expected_char = &[];",
          "    let hir_char = Hir { kind: hir_kind_char, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_char.kind.subs(), expected_char);",
          "    ",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] });",
          "    let expected_class = &[];",
          "    let hir_class = Hir { kind: hir_kind_class, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_class.kind.subs(), expected_class);",
          "    ",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let expected_look = &[];",
          "    let hir_look = Hir { kind: hir_kind_look, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_look.kind.subs(), expected_look);",
          "    ",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(HirKind::Char('c').into()) });",
          "    let expected_repetition = &[Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_repetition = Hir { kind: hir_kind_repetition, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_repetition.kind.subs(), expected_repetition);",
          "    ",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(HirKind::Char('d').into()) });",
          "    let expected_capture = &[Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_capture = Hir { kind: hir_kind_capture, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_capture.kind.subs(), expected_capture);",
          "    ",
          "    let hir_kind_concat = HirKind::Concat(vec![Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('f'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let expected_concat = &[Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('f'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_concat = Hir { kind: hir_kind_concat, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_concat.kind.subs(), expected_concat);",
          "    ",
          "    let hir_kind_alternation = HirKind::Alternation(vec![Hir { kind: HirKind::Char('g'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('h'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let expected_alternation = &[Hir { kind: HirKind::Char('g'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('h'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_alternation = Hir { kind: hir_kind_alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_alternation.kind.subs(), expected_alternation);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Char('a');",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "    let hir_kind_empty = HirKind::Empty;",
          "    let expected_empty = &[];",
          "    let hir_empty = Hir { kind: hir_kind_empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_empty.kind.subs(), expected_empty);",
          "    ",
          "    let hir_kind_char = HirKind::Char('b');",
          "    let expected_char = &[];",
          "    let hir_char = Hir { kind: hir_kind_char, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_char.kind.subs(), expected_char);",
          "    ",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] });",
          "    let expected_class = &[];",
          "    let hir_class = Hir { kind: hir_kind_class, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_class.kind.subs(), expected_class);",
          "    ",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let expected_look = &[];",
          "    let hir_look = Hir { kind: hir_kind_look, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_look.kind.subs(), expected_look);",
          "    ",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(HirKind::Char('c').into()) });",
          "    let expected_repetition = &[Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_repetition = Hir { kind: hir_kind_repetition, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_repetition.kind.subs(), expected_repetition);",
          "    ",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(HirKind::Char('d').into()) });",
          "    let expected_capture = &[Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_capture = Hir { kind: hir_kind_capture, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_capture.kind.subs(), expected_capture);",
          "    ",
          "    let hir_kind_concat = HirKind::Concat(vec![Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('f'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let expected_concat = &[Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('f'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_concat = Hir { kind: hir_kind_concat, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_concat.kind.subs(), expected_concat);",
          "    ",
          "    let hir_kind_alternation = HirKind::Alternation(vec![Hir { kind: HirKind::Char('g'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('h'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let expected_alternation = &[Hir { kind: HirKind::Char('g'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Char('h'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }];",
          "    let hir_alternation = Hir { kind: hir_kind_alternation, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_alternation.kind.subs(), expected_alternation);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class { ranges: vec![] };",
          "    let hir_kind = HirKind::Class(class);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir.kind.subs(), &[]);"
        ],
        "code": [
          "{",
          "    let class = Class { ranges: vec![] };",
          "    let hir_kind = HirKind::Class(class);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "    assert_eq!(hir.kind.subs(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind_empty = HirKind::Empty; assert_eq!(hir_kind_empty.subs(), &[]);",
          "    let hir_kind_char = HirKind::Char('a'); assert_eq!(hir_kind_char.subs(), &[]);",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] }); assert_eq!(hir_kind_class.subs(), &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start); assert_eq!(hir_kind_look.subs(), &[]);",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(hir_kind_char) }); assert_eq!(hir_kind_repetition.subs(), &[hir_kind_char]);",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(hir_kind_char) }); assert_eq!(hir_kind_capture.subs(), &[hir_kind_char]);",
          "    let hir_kind_concat = HirKind::Concat(vec![hir_kind_char.clone(), hir_kind_class.clone()]); assert_eq!(hir_kind_concat.subs(), &[hir_kind_char, hir_kind_class]);",
          "    let hir_kind_alternation = HirKind::Alternation(vec![hir_kind_char.clone(), hir_kind_look.clone()]); assert_eq!(hir_kind_alternation.subs(), &[hir_kind_char, hir_kind_look]);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let _sub_expressions = hir.kind.subs();",
          "    let hir_kind_empty = HirKind::Empty; assert_eq!(hir_kind_empty.subs(), &[]);",
          "    let hir_kind_char = HirKind::Char('a'); assert_eq!(hir_kind_char.subs(), &[]);",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] }); assert_eq!(hir_kind_class.subs(), &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start); assert_eq!(hir_kind_look.subs(), &[]);",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(hir_kind_char) }); assert_eq!(hir_kind_repetition.subs(), &[hir_kind_char]);",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(hir_kind_char) }); assert_eq!(hir_kind_capture.subs(), &[hir_kind_char]);",
          "    let hir_kind_concat = HirKind::Concat(vec![hir_kind_char.clone(), hir_kind_class.clone()]); assert_eq!(hir_kind_concat.subs(), &[hir_kind_char, hir_kind_class]);",
          "    let hir_kind_alternation = HirKind::Alternation(vec![hir_kind_char.clone(), hir_kind_look.clone()]); assert_eq!(hir_kind_alternation.subs(), &[hir_kind_char, hir_kind_look]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]