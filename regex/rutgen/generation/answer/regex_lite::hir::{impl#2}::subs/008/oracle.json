[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind = HirKind::Empty; assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Char('a'); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] }); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Look(Look::Start); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(result, from_ref(&Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }));",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(result, from_ref(&Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }));",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(result, vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }].as_slice());",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(result, vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }].as_slice());"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let result = hir_kind.subs();",
          "    let hir_kind = HirKind::Empty; assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Char('a'); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] }); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Look(Look::Start); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(result, from_ref(&Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }));",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(result, from_ref(&Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }));",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(result, vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }].as_slice());",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(result, vec![Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }].as_slice());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Char('a');",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind_empty = HirKind::Empty; assert_eq!(hir_kind_empty.subs(), &[]);",
          "    let hir_kind_char = HirKind::Char('a'); assert_eq!(hir_kind_char.subs(), &[]);",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] }); assert_eq!(hir_kind_class.subs(), &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start); assert_eq!(hir_kind_look.subs(), &[]);",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(HirKind::Char('b').into()) }); assert_eq!(hir_kind_repetition.subs(), &[HirKind::Char('b')]);",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(HirKind::Char('c').into()) }); assert_eq!(hir_kind_capture.subs(), &[HirKind::Char('c')]);",
          "    let hir_kind_concat = HirKind::Concat(vec![HirKind::Char('d'), HirKind::Char('e')]); assert_eq!(hir_kind_concat.subs(), &[HirKind::Char('d'), HirKind::Char('e')]);",
          "    let hir_kind_alternation = HirKind::Alternation(vec![HirKind::Char('f'), HirKind::Char('g')]); assert_eq!(hir_kind_alternation.subs(), &[HirKind::Char('f'), HirKind::Char('g')]);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Char('a');",
          "    let result = hir_kind.subs();",
          "    let hir_kind_empty = HirKind::Empty; assert_eq!(hir_kind_empty.subs(), &[]);",
          "    let hir_kind_char = HirKind::Char('a'); assert_eq!(hir_kind_char.subs(), &[]);",
          "    let hir_kind_class = HirKind::Class(Class { ranges: vec![] }); assert_eq!(hir_kind_class.subs(), &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start); assert_eq!(hir_kind_look.subs(), &[]);",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(HirKind::Char('b').into()) }); assert_eq!(hir_kind_repetition.subs(), &[HirKind::Char('b')]);",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(HirKind::Char('c').into()) }); assert_eq!(hir_kind_capture.subs(), &[HirKind::Char('c')]);",
          "    let hir_kind_concat = HirKind::Concat(vec![HirKind::Char('d'), HirKind::Char('e')]); assert_eq!(hir_kind_concat.subs(), &[HirKind::Char('d'), HirKind::Char('e')]);",
          "    let hir_kind_alternation = HirKind::Alternation(vec![HirKind::Char('f'), HirKind::Char('g')]); assert_eq!(hir_kind_alternation.subs(), &[HirKind::Char('f'), HirKind::Char('g')]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class { ranges: vec![] };",
          "    let hir_kind = HirKind::Class(class);",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let class = Class { ranges: vec![] };",
          "    let hir_kind_empty = HirKind::Empty;",
          "    let hir_kind_char = HirKind::Char('a');",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let result_empty = hir_kind_empty.subs();",
          "    let result_class = hir_kind.subs();",
          "    let result_char = hir_kind_char.subs();",
          "    let result_look = hir_kind_look.subs();",
          "    assert_eq!(result_empty, &[]);",
          "    assert_eq!(result_class, &[]);",
          "    assert_eq!(result_char, &[]);",
          "    assert_eq!(result_look, &[]);"
        ],
        "code": [
          "{",
          "    let class = Class { ranges: vec![] };",
          "    let hir_kind = HirKind::Class(class);",
          "    let result = hir_kind.subs();",
          "    let class = Class { ranges: vec![] };",
          "    let hir_kind_empty = HirKind::Empty;",
          "    let hir_kind_char = HirKind::Char('a');",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let result_empty = hir_kind_empty.subs();",
          "    let result_class = hir_kind.subs();",
          "    let result_char = hir_kind_char.subs();",
          "    let result_look = hir_kind_look.subs();",
          "    assert_eq!(result_empty, &[]);",
          "    assert_eq!(result_class, &[]);",
          "    assert_eq!(result_char, &[]);",
          "    assert_eq!(result_look, &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind = HirKind::Empty; assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Char('a'); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Look(Look::End); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] }); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 1, max: Some(2), greedy: true, sub: Box::new(Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    let result = hir_kind.subs();",
          "    let hir_kind = HirKind::Empty; assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Char('a'); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Look(Look::End); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] }); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 1, max: Some(2), greedy: true, sub: Box::new(Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]); assert_eq!(hir_kind.subs(), &[Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]