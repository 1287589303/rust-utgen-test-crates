[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind = HirKind::Empty; assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Char('a'); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] }); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Look(Look::Start); assert_eq!(result, &[]);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let result = hir_kind.subs();",
          "    let hir_kind = HirKind::Empty; assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Char('a'); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] }); assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Look(Look::Start); assert_eq!(result, &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Char('a');",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Empty;",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] });",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Char('a');",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Empty;",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Class(Class { ranges: vec![] });",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_range = ClassRange { start: 'a'..='z' }; // Assuming ClassRange is defined appropriately",
          "    let class = Class { ranges: vec![class_range] };",
          "    let hir_kind = HirKind::Class(class);",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, &[]);",
          "    let hir_kind_empty = HirKind::Empty;",
          "    let result_empty = hir_kind_empty.subs();",
          "    assert_eq!(result_empty, &[]);",
          "    let hir_kind_char = HirKind::Char('c');",
          "    let result_char = hir_kind_char.subs();",
          "    assert_eq!(result_char, &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let result_look = hir_kind_look.subs();",
          "    assert_eq!(result_look, &[]);"
        ],
        "code": [
          "{",
          "    let class_range = ClassRange { start: 'a'..='z' }; // Assuming ClassRange is defined appropriately",
          "    let class = Class { ranges: vec![class_range] };",
          "    let hir_kind = HirKind::Class(class);",
          "    let result = hir_kind.subs();",
          "    assert_eq!(result, &[]);",
          "    let hir_kind_empty = HirKind::Empty;",
          "    let result_empty = hir_kind_empty.subs();",
          "    assert_eq!(result_empty, &[]);",
          "    let hir_kind_char = HirKind::Char('c');",
          "    let result_char = hir_kind_char.subs();",
          "    assert_eq!(result_char, &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start);",
          "    let result_look = hir_kind_look.subs();",
          "    assert_eq!(result_look, &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    let result = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    ",
          "    let char_hir = HirKind::Char('a');",
          "    assert_eq!(char_hir.subs(), &[]);",
          "    ",
          "    let class_hir = HirKind::Class(Class { ranges: vec![] });",
          "    assert_eq!(class_hir.subs(), &[]);",
          "    ",
          "    let empty_hir = HirKind::Empty;",
          "    assert_eq!(empty_hir.subs(), &[]);"
        ],
        "code": [
          "{",
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    let result = hir_kind.subs();",
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    ",
          "    let char_hir = HirKind::Char('a');",
          "    assert_eq!(char_hir.subs(), &[]);",
          "    ",
          "    let class_hir = HirKind::Class(Class { ranges: vec![] });",
          "    assert_eq!(class_hir.subs(), &[]);",
          "    ",
          "    let empty_hir = HirKind::Empty;",
          "    assert_eq!(empty_hir.subs(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]