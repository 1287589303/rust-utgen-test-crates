[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Look(Look::Start), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "    let hir = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Look(Look::Start), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[]);",
          "    let hir = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('b'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('c'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('d'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "    let hir = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir.kind.subs(), &[Hir { kind: HirKind::Char('e'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_char = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_char.kind.subs(), &[]);",
          "    let hir_empty = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_empty.kind.subs(), &[]);",
          "    let hir_class = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_class.kind.subs(), &[]);",
          "    let hir_look = Hir { kind: HirKind::Look(Look::Start), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_look.kind.subs(), &[]);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Empty,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "    let hir_char = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_char.kind.subs(), &[]);",
          "    let hir_empty = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_empty.kind.subs(), &[]);",
          "    let hir_class = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_class.kind.subs(), &[]);",
          "    let hir_look = Hir { kind: HirKind::Look(Look::Start), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_look.kind.subs(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(Look::Start),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_char = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_char.kind.subs(), &[]);",
          "    let hir_empty = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_empty.kind.subs(), &[]);",
          "    let hir_class = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_class.kind.subs(), &[]);",
          "    let hir_look = Hir { kind: HirKind::Look(Look::End), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_look.kind.subs(), &[]);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Look(Look::Start),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "    let hir_char = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_char.kind.subs(), &[]);",
          "    let hir_empty = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_empty.kind.subs(), &[]);",
          "    let hir_class = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_class.kind.subs(), &[]);",
          "    let hir_look = Hir { kind: HirKind::Look(Look::End), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }; assert_eq!(hir_look.kind.subs(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class {",
          "            ranges: vec![],",
          "        }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_char = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_char.kind.subs(), &[]);",
          "    ",
          "    let hir_empty = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_empty.kind.subs(), &[]);",
          "    ",
          "    let hir_class = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_class.kind.subs(), &[]);",
          "    ",
          "    let hir_look = Hir { kind: HirKind::Look(Look::Start), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_look.kind.subs(), &[]);",
          "    ",
          "    let hir_repetition = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(hir_char.clone()) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_repetition.kind.subs(), &[hir_char]);",
          "    ",
          "    let hir_capture = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(hir_char.clone()) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_capture.kind.subs(), &[hir_char]);",
          "    ",
          "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_char.clone(), hir_class.clone()]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_concat.kind.subs(), &[hir_char, hir_class]);",
          "    ",
          "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_char.clone(), hir_look.clone()]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_alternation.kind.subs(), &[hir_char, hir_look]);"
        ],
        "code": [
          "{",
          "    let hir = Hir {",
          "        kind: HirKind::Class(Class {",
          "            ranges: vec![],",
          "        }),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _ = hir.kind.subs();",
          "    let hir_char = Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_char.kind.subs(), &[]);",
          "    ",
          "    let hir_empty = Hir { kind: HirKind::Empty, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_empty.kind.subs(), &[]);",
          "    ",
          "    let hir_class = Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_class.kind.subs(), &[]);",
          "    ",
          "    let hir_look = Hir { kind: HirKind::Look(Look::Start), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_look.kind.subs(), &[]);",
          "    ",
          "    let hir_repetition = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(hir_char.clone()) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_repetition.kind.subs(), &[hir_char]);",
          "    ",
          "    let hir_capture = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(hir_char.clone()) }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_capture.kind.subs(), &[hir_char]);",
          "    ",
          "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_char.clone(), hir_class.clone()]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_concat.kind.subs(), &[hir_char, hir_class]);",
          "    ",
          "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_char.clone(), hir_look.clone()]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir_alternation.kind.subs(), &[hir_char, hir_look]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]