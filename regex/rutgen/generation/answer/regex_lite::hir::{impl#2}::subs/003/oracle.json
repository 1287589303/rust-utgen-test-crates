[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_sub = Box::new(Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    });",
          "    let capture = Capture {",
          "        index: 1,",
          "        name: None,",
          "        sub: hir_sub,",
          "    };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir {",
          "        kind: hir_kind,",
          "        is_start_anchored: true,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _result = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_sub = Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None });",
          "    let capture = Capture { index: 1, name: None, sub: hir_sub };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir.kind.subs(), &[*hir_sub]);"
        ],
        "code": [
          "{",
          "    let hir_sub = Box::new(Hir {",
          "        kind: HirKind::Char('a'),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    });",
          "    let capture = Capture {",
          "        index: 1,",
          "        name: None,",
          "        sub: hir_sub,",
          "    };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir {",
          "        kind: hir_kind,",
          "        is_start_anchored: true,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _result = hir.kind.subs();",
          "    let hir_sub = Box::new(Hir { kind: HirKind::Char('a'), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None });",
          "    let capture = Capture { index: 1, name: None, sub: hir_sub };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: None };",
          "    assert_eq!(hir.kind.subs(), &[*hir_sub]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_sub = Box::new(Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Char('b'),",
          "                is_start_anchored: true,",
          "                is_match_empty: false,",
          "                static_explicit_captures_len: None,",
          "            },",
          "            Hir {",
          "                kind: HirKind::Class(Class {",
          "                    ranges: vec![],",
          "                }),",
          "                is_start_anchored: false,",
          "                is_match_empty: false,",
          "                static_explicit_captures_len: None,",
          "            },",
          "        ]),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    });",
          "    let capture = Capture {",
          "        index: 2,",
          "        name: Some(Box::from(\"name\")),",
          "        sub: hir_sub,",
          "    };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir {",
          "        kind: hir_kind,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _result = hir.kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_sub = Box::new(Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Char('b'), is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None });",
          "    let capture = Capture { index: 2, name: Some(Box::from(\"name\")), sub: hir_sub };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let result = hir.kind.subs();",
          "    assert_eq!(result.len(), 2);",
          "    assert_eq!(result[0].kind, HirKind::Char('b'));",
          "    assert_eq!(result[1].kind, HirKind::Class(Class { ranges: vec![] }));"
        ],
        "code": [
          "{",
          "    let hir_sub = Box::new(Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Char('b'),",
          "                is_start_anchored: true,",
          "                is_match_empty: false,",
          "                static_explicit_captures_len: None,",
          "            },",
          "            Hir {",
          "                kind: HirKind::Class(Class {",
          "                    ranges: vec![],",
          "                }),",
          "                is_start_anchored: false,",
          "                is_match_empty: false,",
          "                static_explicit_captures_len: None,",
          "            },",
          "        ]),",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    });",
          "    let capture = Capture {",
          "        index: 2,",
          "        name: Some(Box::from(\"name\")),",
          "        sub: hir_sub,",
          "    };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir {",
          "        kind: hir_kind,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "    };",
          "    let _result = hir.kind.subs();",
          "    let hir_sub = Box::new(Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Char('b'), is_start_anchored: true, is_match_empty: false, static_explicit_captures_len: None }, Hir { kind: HirKind::Class(Class { ranges: vec![] }), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None }]), is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None });",
          "    let capture = Capture { index: 2, name: Some(Box::from(\"name\")), sub: hir_sub };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let hir = Hir { kind: hir_kind, is_start_anchored: false, is_match_empty: false, static_explicit_captures_len: None };",
          "    let result = hir.kind.subs();",
          "    assert_eq!(result.len(), 2);",
          "    assert_eq!(result[0].kind, HirKind::Char('b'));",
          "    assert_eq!(result[1].kind, HirKind::Class(Class { ranges: vec![] }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]