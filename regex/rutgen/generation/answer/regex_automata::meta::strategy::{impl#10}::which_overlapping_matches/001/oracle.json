[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"a\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 1,",
          "        which: alloc::boxed::Box::new([true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "}"
        ],
        "oracle": [
          "    assert!(cache.capmatches == Captures::default());",
          "    assert!(cache.pikevm == wrappers::PikeVMCache::default());",
          "    assert!(cache.backtrack == wrappers::BoundedBacktrackerCache::default());",
          "    assert!(cache.onepass == wrappers::OnePassCache::default());",
          "    assert!(cache.hybrid == wrappers::HybridCache::default());",
          "    assert!(cache.revhybrid == wrappers::ReverseHybridCache::default());",
          "    assert_eq!(input.haystack, b\"a\".as_ref());",
          "    assert!(input.span == Span::default());",
          "    assert!(input.anchored == Anchored::default());",
          "    assert!(input.earliest == false);",
          "    assert_eq!(patset.len, 1);",
          "    assert!(patset.which == alloc::boxed::Box::new([true]));",
          "    assert!(strategy.is_accelerated() == false);",
          "    assert!(strategy.memory_usage() >= 0);",
          "    assert!(strategy.search(&mut cache, &input).is_none());",
          "    assert!(strategy.search_half(&mut cache, &input).is_none());",
          "    assert!(strategy.is_match(&mut cache, &input) == false);",
          "    assert!(strategy.search_slots(&mut cache, &input, &mut [None]).is_none());",
          "    assert!(patset.len <= 1);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"a\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 1,",
          "        which: alloc::boxed::Box::new([true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert!(cache.capmatches == Captures::default());",
          "    assert!(cache.pikevm == wrappers::PikeVMCache::default());",
          "    assert!(cache.backtrack == wrappers::BoundedBacktrackerCache::default());",
          "    assert!(cache.onepass == wrappers::OnePassCache::default());",
          "    assert!(cache.hybrid == wrappers::HybridCache::default());",
          "    assert!(cache.revhybrid == wrappers::ReverseHybridCache::default());",
          "    assert_eq!(input.haystack, b\"a\".as_ref());",
          "    assert!(input.span == Span::default());",
          "    assert!(input.anchored == Anchored::default());",
          "    assert!(input.earliest == false);",
          "    assert_eq!(patset.len, 1);",
          "    assert!(patset.which == alloc::boxed::Box::new([true]));",
          "    assert!(strategy.is_accelerated() == false);",
          "    assert!(strategy.memory_usage() >= 0);",
          "    assert!(strategy.search(&mut cache, &input).is_none());",
          "    assert!(strategy.search_half(&mut cache, &input).is_none());",
          "    assert!(strategy.is_match(&mut cache, &input) == false);",
          "    assert!(strategy.search_slots(&mut cache, &input, &mut [None]).is_none());",
          "    assert!(patset.len <= 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"abc\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 3,",
          "        which: alloc::boxed::Box::new([true, false, true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(patset.len, 3);",
          "    assert_eq!(patset.which[0], true);",
          "    assert_eq!(patset.which[1], false);",
          "    assert_eq!(patset.which[2], true);",
          "    assert!(cache.capmatches.is_empty());",
          "    assert!(cache.pikevm.is_empty());",
          "    assert!(cache.backtrack.is_empty());",
          "    assert!(cache.onepass.is_empty());",
          "    assert!(cache.hybrid.is_empty());",
          "    assert!(cache.revhybrid.is_empty());"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"abc\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 3,",
          "        which: alloc::boxed::Box::new([true, false, true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert_eq!(patset.len, 3);",
          "    assert_eq!(patset.which[0], true);",
          "    assert_eq!(patset.which[1], false);",
          "    assert_eq!(patset.which[2], true);",
          "    assert!(cache.capmatches.is_empty());",
          "    assert!(cache.pikevm.is_empty());",
          "    assert!(cache.backtrack.is_empty());",
          "    assert!(cache.onepass.is_empty());",
          "    assert!(cache.hybrid.is_empty());",
          "    assert!(cache.revhybrid.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let haystack: Vec<u8> = (0..=255).collect();",
          "    let input = Input {",
          "        haystack: &haystack,",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 1,",
          "        which: alloc::boxed::Box::new([true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(patset.len, 1);",
          "    assert_eq!(patset.which[0], true);",
          "    assert!(cache.capmatches.is_empty());",
          "    assert!(cache.pikevm.is_empty());",
          "    assert!(cache.backtrack.is_empty());",
          "    assert!(cache.onepass.is_empty());",
          "    assert!(cache.hybrid.is_empty());",
          "    assert!(cache.revhybrid.is_empty());",
          "    assert_eq!(strategy.is_accelerated(), false);",
          "    assert!(strategy.memory_usage() > 0);",
          "    assert!(strategy.search(&mut cache, &input).is_some());",
          "    assert!(strategy.search_half(&mut cache, &input).is_some());",
          "    assert!(strategy.is_match(&mut cache, &input));",
          "    let mut slots = vec![None];",
          "    assert!(strategy.search_slots(&mut cache, &input, &mut slots).is_some());",
          "    let patset_before = patset.clone();",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert_ne!(patset, patset_before);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let haystack: Vec<u8> = (0..=255).collect();",
          "    let input = Input {",
          "        haystack: &haystack,",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 1,",
          "        which: alloc::boxed::Box::new([true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert_eq!(patset.len, 1);",
          "    assert_eq!(patset.which[0], true);",
          "    assert!(cache.capmatches.is_empty());",
          "    assert!(cache.pikevm.is_empty());",
          "    assert!(cache.backtrack.is_empty());",
          "    assert!(cache.onepass.is_empty());",
          "    assert!(cache.hybrid.is_empty());",
          "    assert!(cache.revhybrid.is_empty());",
          "    assert_eq!(strategy.is_accelerated(), false);",
          "    assert!(strategy.memory_usage() > 0);",
          "    assert!(strategy.search(&mut cache, &input).is_some());",
          "    assert!(strategy.search_half(&mut cache, &input).is_some());",
          "    assert!(strategy.is_match(&mut cache, &input));",
          "    let mut slots = vec![None];",
          "    assert!(strategy.search_slots(&mut cache, &input, &mut slots).is_some());",
          "    let patset_before = patset.clone();",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert_ne!(patset, patset_before);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"test input\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 5,",
          "        which: alloc::boxed::Box::new([true, true, true, true, true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "}"
        ],
        "oracle": [
          "    assert!(cache.capmatches.is_empty());",
          "    assert_eq!(patset.len, 5);",
          "    assert!(patset.which.iter().all(|&x| x == true));",
          "    assert_eq!(patset.which.len(), 5);",
          "    assert!(strategy.is_accelerated());",
          "    assert!(strategy.memory_usage() > 0);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"test input\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 5,",
          "        which: alloc::boxed::Box::new([true, true, true, true, true]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert!(cache.capmatches.is_empty());",
          "    assert_eq!(patset.len, 5);",
          "    assert!(patset.which.iter().all(|&x| x == true));",
          "    assert_eq!(patset.which.len(), 5);",
          "    assert!(strategy.is_accelerated());",
          "    assert!(strategy.memory_usage() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"sample text\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 4,",
          "        which: alloc::boxed::Box::new([true, false, true, false]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(cache.capmatches, Captures::default());",
          "    assert!(patset.len == 4);",
          "    assert_eq!(patset.which.as_ref(), &[true, false, true, false]);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        capmatches: Captures::default(),",
          "        pikevm: wrappers::PikeVMCache::default(),",
          "        backtrack: wrappers::BoundedBacktrackerCache::default(),",
          "        onepass: wrappers::OnePassCache::default(),",
          "        hybrid: wrappers::HybridCache::default(),",
          "        revhybrid: wrappers::ReverseHybridCache::default(),",
          "    };",
          "",
          "    let input = Input {",
          "        haystack: b\"sample text\".as_ref(),",
          "        span: Span::default(),",
          "        anchored: Anchored::default(),",
          "        earliest: false,",
          "    };",
          "",
          "    let mut patset = PatternSet {",
          "        len: 4,",
          "        which: alloc::boxed::Box::new([true, false, true, false]),",
          "    };",
          "",
          "    let strategy = ReverseInner {",
          "        core: Core::default(),",
          "        preinner: Prefilter::default(),",
          "        nfarev: NFA::default(),",
          "        hybrid: wrappers::ReverseHybrid::default(),",
          "        dfa: wrappers::ReverseDFA::default(),",
          "    };",
          "",
          "    strategy.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert_eq!(cache.capmatches, Captures::default());",
          "    assert!(patset.len == 4);",
          "    assert_eq!(patset.which.as_ref(), &[true, false, true, false]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]