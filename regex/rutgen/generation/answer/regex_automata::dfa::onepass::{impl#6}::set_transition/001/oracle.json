[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(0);",
          "    let byte = 1;",
          "    let transition = Transition { start: 0, end: 1, next: StateID(1) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dfa.table[0 << dfa.stride2() + dfa.classes.get(1).as_usize()], Transition { start: 0, end: 1, next: StateID(1) });"
        ],
        "code": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(0);",
          "    let byte = 1;",
          "    let transition = Transition { start: 0, end: 1, next: StateID(1) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "    assert_eq!(dfa.table[0 << dfa.stride2() + dfa.classes.get(1).as_usize()], Transition { start: 0, end: 1, next: StateID(1) });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(511); // Boundary case for stride.",
          "    let byte = 255; // Maximum byte value.",
          "    let transition = Transition { start: 0, end: 1, next: StateID(1) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()], transition);"
        ],
        "code": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(511); // Boundary case for stride.",
          "    let byte = 255; // Maximum byte value.",
          "    let transition = Transition { start: 0, end: 1, next: StateID(1) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "    assert_eq!(dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()], transition);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(1);",
          "    let byte = 0; // Minimum byte value.",
          "    let transition = Transition { start: 2, end: 3, next: StateID(2) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "}"
        ],
        "oracle": [
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()] == transition",
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()].next == transition.next",
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()].start == transition.start",
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()].end == transition.end"
        ],
        "code": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(1);",
          "    let byte = 0; // Minimum byte value.",
          "    let transition = Transition { start: 2, end: 3, next: StateID(2) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()] == transition",
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()].next == transition.next",
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()].start == transition.start",
          "    dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()].end == transition.end",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(1);",
          "    let byte = 255; // Maximum byte value.",
          "    let transition = Transition { start: 2, end: 3, next: StateID(2) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dfa.table[state_id.as_usize() << dfa.stride2() + dfa.classes.get(byte).as_usize()], transition);"
        ],
        "code": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(1);",
          "    let byte = 255; // Maximum byte value.",
          "    let transition = Transition { start: 2, end: 3, next: StateID(2) };",
          "    dfa.set_transition(state_id, byte, transition);",
          "    assert_eq!(dfa.table[state_id.as_usize() << dfa.stride2() + dfa.classes.get(byte).as_usize()], transition);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(10);",
          "    let byte = 100; // Some arbitrary value.",
          "    let transition1 = Transition { start: 5, end: 10, next: StateID(20) };",
          "    let transition2 = Transition { start: 2, end: 6, next: StateID(30) };",
          "    ",
          "    dfa.set_transition(state_id, byte, transition1);",
          "    dfa.set_transition(StateID(2), byte, transition2);",
          "}"
        ],
        "oracle": [
          "    dfa.set_transition(state_id, byte, Transition { start: 5, end: 10, next: StateID(20) });",
          "    assert_eq!(dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()], Transition { start: 5, end: 10, next: StateID(20) });",
          "    ",
          "    dfa.set_transition(StateID(2), byte, Transition { start: 2, end: 6, next: StateID(30) });",
          "    assert_eq!(dfa.table[(StateID(2).as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()], Transition { start: 2, end: 6, next: StateID(30) });"
        ],
        "code": [
          "{",
          "    let mut dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: NFA::default(),",
          "        table: vec![Transition { start: 0, end: 0, next: StateID(0) }; 512],",
          "        starts: vec![StateID(0)],",
          "        min_match_id: StateID(0),",
          "        classes: ByteClasses([0; 256]),",
          "        alphabet_len: 256,",
          "        stride2: 9,",
          "        pateps_offset: 0,",
          "        explicit_slot_start: 0,",
          "    };",
          "    let state_id = StateID(10);",
          "    let byte = 100; // Some arbitrary value.",
          "    let transition1 = Transition { start: 5, end: 10, next: StateID(20) };",
          "    let transition2 = Transition { start: 2, end: 6, next: StateID(30) };",
          "    ",
          "    dfa.set_transition(state_id, byte, transition1);",
          "    dfa.set_transition(StateID(2), byte, transition2);",
          "    dfa.set_transition(state_id, byte, Transition { start: 5, end: 10, next: StateID(20) });",
          "    assert_eq!(dfa.table[(state_id.as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()], Transition { start: 5, end: 10, next: StateID(20) });",
          "    ",
          "    dfa.set_transition(StateID(2), byte, Transition { start: 2, end: 6, next: StateID(30) });",
          "    assert_eq!(dfa.table[(StateID(2).as_usize() << dfa.stride2()) + dfa.classes.get(byte).as_usize()], Transition { start: 2, end: 6, next: StateID(30) });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]