[
  {
    "uses": [
      "use alloc::collections::BTreeMap;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use alloc::collections::BTreeMap;",
          "",
          "    struct TestDFA {",
          "        special: Special,",
          "        state_len: usize,",
          "        starts: Vec<(StateID, usize, usize)>,",
          "        transitions: BTreeMap<StateID, Vec<PatternID>>,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn new(state_len: usize, starts: Vec<(StateID, usize, usize)>, matches: BTreeMap<StateID, Vec<PatternID>>) -> Self {",
          "            let mut special = Special::new();",
          "            special.quit_id = StateID(1);",
          "",
          "            TestDFA { ",
          "                special, ",
          "                state_len, ",
          "                starts, ",
          "                transitions: matches ",
          "            }",
          "        }",
          "",
          "        fn to_state_id(&self, id: usize) -> StateID {",
          "            StateID(id as u32)",
          "        }",
          "",
          "        fn state_len(&self) -> usize {",
          "            self.state_len",
          "        }",
          "",
          "        fn starts(&self) -> &[(StateID, usize, usize)] {",
          "            &self.starts",
          "        }",
          "",
          "        fn shuffle(&mut self) -> Result<(), BuildError> {",
          "            shuffle(self, self.transitions.clone())",
          "        }",
          "    }",
          "",
          "    let starts = vec![",
          "        (StateID(2), 0, 0), // valid start states",
          "        (StateID(3), 0, 0)",
          "    ];",
          "    let matches: BTreeMap<StateID, Vec<PatternID>> = BTreeMap::from([",
          "        (StateID(4), vec![PatternID(0)]), // valid matches",
          "        (StateID(5), vec![PatternID(1)]),",
          "    ]);",
          "",
          "    let mut dfa = TestDFA::new(3, starts, matches);",
          "    dfa.shuffle().unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(dfa.state_len() > 2);",
          "    assert!(!dfa.starts().is_empty());",
          "    assert!(!dfa.starts().iter().any(|(start_id, _, _)| *start_id == DEAD));",
          "    assert!(dfa.starts().iter().all(|(start_id, _, _)| !dfa.transitions.contains_key(start_id)));",
          "    assert!(!dfa.transitions.is_empty());",
          "    assert!(dfa.transitions.iter().any(|(id, _)| *id == StateID(4));",
          "    assert!(dfa.transitions.iter().any(|(id, _)| *id == StateID(5));",
          "    assert!(!dfa.special.matches());",
          "    assert!(dfa.starts().iter().any(|(id, _, _)| id == &StateID(2));",
          "    assert!(!dfa.starts().iter().any(|(id, _, _)| id == &StateID(3));",
          "    assert!(dfa.set_pattern_map(&dfa.transitions).is_ok());"
        ],
        "code": [
          "{",
          "    use alloc::collections::BTreeMap;",
          "",
          "    struct TestDFA {",
          "        special: Special,",
          "        state_len: usize,",
          "        starts: Vec<(StateID, usize, usize)>,",
          "        transitions: BTreeMap<StateID, Vec<PatternID>>,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn new(state_len: usize, starts: Vec<(StateID, usize, usize)>, matches: BTreeMap<StateID, Vec<PatternID>>) -> Self {",
          "            let mut special = Special::new();",
          "            special.quit_id = StateID(1);",
          "",
          "            TestDFA { ",
          "                special, ",
          "                state_len, ",
          "                starts, ",
          "                transitions: matches ",
          "            }",
          "        }",
          "",
          "        fn to_state_id(&self, id: usize) -> StateID {",
          "            StateID(id as u32)",
          "        }",
          "",
          "        fn state_len(&self) -> usize {",
          "            self.state_len",
          "        }",
          "",
          "        fn starts(&self) -> &[(StateID, usize, usize)] {",
          "            &self.starts",
          "        }",
          "",
          "        fn shuffle(&mut self) -> Result<(), BuildError> {",
          "            shuffle(self, self.transitions.clone())",
          "        }",
          "    }",
          "",
          "    let starts = vec![",
          "        (StateID(2), 0, 0), // valid start states",
          "        (StateID(3), 0, 0)",
          "    ];",
          "    let matches: BTreeMap<StateID, Vec<PatternID>> = BTreeMap::from([",
          "        (StateID(4), vec![PatternID(0)]), // valid matches",
          "        (StateID(5), vec![PatternID(1)]),",
          "    ]);",
          "",
          "    let mut dfa = TestDFA::new(3, starts, matches);",
          "    dfa.shuffle().unwrap();",
          "    assert!(dfa.state_len() > 2);",
          "    assert!(!dfa.starts().is_empty());",
          "    assert!(!dfa.starts().iter().any(|(start_id, _, _)| *start_id == DEAD));",
          "    assert!(dfa.starts().iter().all(|(start_id, _, _)| !dfa.transitions.contains_key(start_id)));",
          "    assert!(!dfa.transitions.is_empty());",
          "    assert!(dfa.transitions.iter().any(|(id, _)| *id == StateID(4));",
          "    assert!(dfa.transitions.iter().any(|(id, _)| *id == StateID(5));",
          "    assert!(!dfa.special.matches());",
          "    assert!(dfa.starts().iter().any(|(id, _, _)| id == &StateID(2));",
          "    assert!(!dfa.starts().iter().any(|(id, _, _)| id == &StateID(3));",
          "    assert!(dfa.set_pattern_map(&dfa.transitions).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    use alloc::collections::BTreeMap;",
          "",
          "    struct TestDFA {",
          "        special: Special,",
          "        state_len: usize,",
          "        starts: Vec<(StateID, usize, usize)>,",
          "        transitions: BTreeMap<StateID, Vec<PatternID>>,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn new(state_len: usize, starts: Vec<(StateID, usize, usize)>, matches: BTreeMap<StateID, Vec<PatternID>>) -> Self {",
          "            let mut special = Special::new();",
          "            special.quit_id = StateID(1);",
          "",
          "            TestDFA { ",
          "                special, ",
          "                state_len, ",
          "                starts, ",
          "                transitions: matches ",
          "            }",
          "        }",
          "",
          "        fn to_state_id(&self, id: usize) -> StateID {",
          "            StateID(id as u32)",
          "        }",
          "",
          "        fn state_len(&self) -> usize {",
          "            self.state_len",
          "        }",
          "",
          "        fn starts(&self) -> &[(StateID, usize, usize)] {",
          "            &self.starts",
          "        }",
          "",
          "        fn shuffle(&mut self) -> Result<(), BuildError> {",
          "            shuffle(self, self.transitions.clone())",
          "        }",
          "    }",
          "",
          "    let starts = vec![",
          "        (StateID(0), 0, 0) // DEAD state (valid start_id cannot be DEAD)",
          "    ];",
          "    let matches: BTreeMap<StateID, Vec<PatternID>> = BTreeMap::from([]);",
          "",
          "    let mut dfa = TestDFA::new(3, starts, matches);",
          "    dfa.shuffle().unwrap(); // This should panic since starts can't be DEAD",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dfa.state_len(), 3);",
          "    assert!(!dfa.starts().is_empty());",
          "    assert!(!dfa.starts().iter().any(|(start_id, _, _)| *start_id == DEAD));",
          "    assert!(!matches.contains_key(&StateID(0)));",
          "    assert!(dfa.transitions.is_empty());",
          "    assert!(matches.is_empty());",
          "    assert!(dfa.transitions.is_empty());",
          "    assert!(dfa.special.matches());",
          "    assert!(dfa.starts().iter().any(|(id, _, _)| *id == StateID(0)));",
          "    assert!(!dfa.starts().iter().any(|(id, _, _)| *id == StateID(1)));",
          "    assert!(dfa.set_pattern_map(&matches).is_ok());"
        ],
        "code": [
          "{",
          "    use alloc::collections::BTreeMap;",
          "",
          "    struct TestDFA {",
          "        special: Special,",
          "        state_len: usize,",
          "        starts: Vec<(StateID, usize, usize)>,",
          "        transitions: BTreeMap<StateID, Vec<PatternID>>,",
          "    }",
          "",
          "    impl TestDFA {",
          "        fn new(state_len: usize, starts: Vec<(StateID, usize, usize)>, matches: BTreeMap<StateID, Vec<PatternID>>) -> Self {",
          "            let mut special = Special::new();",
          "            special.quit_id = StateID(1);",
          "",
          "            TestDFA { ",
          "                special, ",
          "                state_len, ",
          "                starts, ",
          "                transitions: matches ",
          "            }",
          "        }",
          "",
          "        fn to_state_id(&self, id: usize) -> StateID {",
          "            StateID(id as u32)",
          "        }",
          "",
          "        fn state_len(&self) -> usize {",
          "            self.state_len",
          "        }",
          "",
          "        fn starts(&self) -> &[(StateID, usize, usize)] {",
          "            &self.starts",
          "        }",
          "",
          "        fn shuffle(&mut self) -> Result<(), BuildError> {",
          "            shuffle(self, self.transitions.clone())",
          "        }",
          "    }",
          "",
          "    let starts = vec![",
          "        (StateID(0), 0, 0) // DEAD state (valid start_id cannot be DEAD)",
          "    ];",
          "    let matches: BTreeMap<StateID, Vec<PatternID>> = BTreeMap::from([]);",
          "",
          "    let mut dfa = TestDFA::new(3, starts, matches);",
          "    dfa.shuffle().unwrap(); // This should panic since starts can't be DEAD",
          "    assert_eq!(dfa.state_len(), 3);",
          "    assert!(!dfa.starts().is_empty());",
          "    assert!(!dfa.starts().iter().any(|(start_id, _, _)| *start_id == DEAD));",
          "    assert!(!matches.contains_key(&StateID(0)));",
          "    assert!(dfa.transitions.is_empty());",
          "    assert!(matches.is_empty());",
          "    assert!(dfa.transitions.is_empty());",
          "    assert!(dfa.special.matches());",
          "    assert!(dfa.starts().iter().any(|(id, _, _)| *id == StateID(0)));",
          "    assert!(!dfa.starts().iter().any(|(id, _, _)| *id == StateID(1)));",
          "    assert!(dfa.set_pattern_map(&matches).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]