[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            unicode: Some(false),",
          "            ..Default::default()",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let x_start = Literal {",
          "        span: Span { start: Position(0), end: Position(1) },",
          "        kind: LiteralKind::Character,",
          "        c: 'A',",
          "    };",
          "",
          "    let x_end = Literal {",
          "        span: Span { start: Position(1), end: Position(2) },",
          "        kind: LiteralKind::Character,",
          "        c: '\\u{0100}', // Out of byte range",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Range(ClassSetRange {",
          "        span: Span { start: Position(0), end: Position(2) },",
          "        start: x_start,",
          "        end: x_end,",
          "    });",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
          "    let result = visitor.visit_class_set_item_post(&ast);",
          "",
          "    // Note: we do not check assertions; this is only for invocation.",
          "}"
        ],
        "oracle": [
          "    visitor.flags().unicode() == false",
          "    visitor.class_literal_byte(&x.start).is_ok()",
          "    visitor.class_literal_byte(&x.end).is_err()",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges().len() == 1",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].start() == 65 // ASCII value of 'A'",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].end() == 65 // ASCII value of 'A'"
        ],
        "code": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            unicode: Some(false),",
          "            ..Default::default()",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let x_start = Literal {",
          "        span: Span { start: Position(0), end: Position(1) },",
          "        kind: LiteralKind::Character,",
          "        c: 'A',",
          "    };",
          "",
          "    let x_end = Literal {",
          "        span: Span { start: Position(1), end: Position(2) },",
          "        kind: LiteralKind::Character,",
          "        c: '\\u{0100}', // Out of byte range",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Range(ClassSetRange {",
          "        span: Span { start: Position(0), end: Position(2) },",
          "        start: x_start,",
          "        end: x_end,",
          "    });",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
          "    let result = visitor.visit_class_set_item_post(&ast);",
          "",
          "    // Note: we do not check assertions; this is only for invocation.",
          "    visitor.flags().unicode() == false",
          "    visitor.class_literal_byte(&x.start).is_ok()",
          "    visitor.class_literal_byte(&x.end).is_err()",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges().len() == 1",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].start() == 65 // ASCII value of 'A'",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].end() == 65 // ASCII value of 'A'",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]