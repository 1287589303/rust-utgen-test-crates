[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: false,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let x = Literal {",
          "        span: Span {",
          "            start: Position(0),",
          "            end: Position(1),",
          "        },",
          "        kind: LiteralKind::Character,",
          "        c: 'a',",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
          "",
          "    visitor.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    visitor.flags().unicode() == false",
          "    visitor.class_literal_byte(&x).is_ok()",
          "    visitor.pop().unwrap().unwrap_class_bytes().len() == 1",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].start() == 97",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].end() == 97",
          "    visitor.stack.borrow().len() == 1",
          "    visitor.stack.borrow()[0].unwrap_class_bytes().is_ascii() == true",
          "    visitor.visit_class_set_item_post(&ast).unwrap() == Ok(())"
        ],
        "code": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: false,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let x = Literal {",
          "        span: Span {",
          "            start: Position(0),",
          "            end: Position(1),",
          "        },",
          "        kind: LiteralKind::Character,",
          "        c: 'a',",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
          "",
          "    visitor.visit_class_set_item_post(&ast).unwrap();",
          "    visitor.flags().unicode() == false",
          "    visitor.class_literal_byte(&x).is_ok()",
          "    visitor.pop().unwrap().unwrap_class_bytes().len() == 1",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].start() == 97",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].end() == 97",
          "    visitor.stack.borrow().len() == 1",
          "    visitor.stack.borrow()[0].unwrap_class_bytes().is_ascii() == true",
          "    visitor.visit_class_set_item_post(&ast).unwrap() == Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: false,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let x = Literal {",
          "        span: Span {",
          "            start: Position(1),",
          "            end: Position(2),",
          "        },",
          "        kind: LiteralKind::Character,",
          "        c: 'b',",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
          "",
          "    visitor.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    visitor.flags().unicode() == false",
          "    visitor.pop().is_some()",
          "    visitor.pop().unwrap().unwrap_class_bytes() == some_initial_class_bytes",
          "    visitor.class_literal_byte(&x).unwrap() == byte_value",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges().last().unwrap().start() == byte_value",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges().last().unwrap().end() == byte_value",
          "    Ok(()) == visitor.visit_class_set_item_post(&ast)"
        ],
        "code": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: false,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let x = Literal {",
          "        span: Span {",
          "            start: Position(1),",
          "            end: Position(2),",
          "        },",
          "        kind: LiteralKind::Character,",
          "        c: 'b',",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
          "",
          "    visitor.visit_class_set_item_post(&ast).unwrap();",
          "    visitor.flags().unicode() == false",
          "    visitor.pop().is_some()",
          "    visitor.pop().unwrap().unwrap_class_bytes() == some_initial_class_bytes",
          "    visitor.class_literal_byte(&x).unwrap() == byte_value",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges().last().unwrap().start() == byte_value",
          "    visitor.pop().unwrap().unwrap_class_bytes().ranges().last().unwrap().end() == byte_value",
          "    Ok(()) == visitor.visit_class_set_item_post(&ast)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: false,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let x = Literal {",
          "        span: Span {",
          "            start: Position(2),",
          "            end: Position(3),",
          "        },",
          "        kind: LiteralKind::Character,",
          "        c: 'z',",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
          "",
          "    visitor.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(visitor.pop().unwrap().unwrap_class_bytes().ranges().len(), 1);",
          "    assert_eq!(visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].start(), b'z');",
          "    assert_eq!(visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].end(), b'z');",
          "    assert!(visitor.pop().is_none());",
          "    assert_eq!(visitor.visit_class_set_item_post(&ast).unwrap(), Ok(()));"
        ],
        "code": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            case_insensitive: None,",
          "            multi_line: None,",
          "            dot_matches_new_line: None,",
          "            swap_greed: None,",
          "            unicode: Some(false),",
          "            crlf: None,",
          "        }),",
          "        utf8: false,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let x = Literal {",
          "        span: Span {",
          "            start: Position(2),",
          "            end: Position(3),",
          "        },",
          "        kind: LiteralKind::Character,",
          "        c: 'z',",
          "    };",
          "",
          "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
          "",
          "    visitor.visit_class_set_item_post(&ast).unwrap();",
          "    assert_eq!(visitor.pop().unwrap().unwrap_class_bytes().ranges().len(), 1);",
          "    assert_eq!(visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].start(), b'z');",
          "    assert_eq!(visitor.pop().unwrap().unwrap_class_bytes().ranges()[0].end(), b'z');",
          "    assert!(visitor.pop().is_none());",
          "    assert_eq!(visitor.visit_class_set_item_post(&ast).unwrap(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]