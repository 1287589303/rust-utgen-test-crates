[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            unicode: Some(false),",
          "            ..Default::default()",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let start_literal = Literal {",
          "        span: Span { start: Position(0), end: Position(1) },",
          "        kind: LiteralKind::Char,",
          "        c: 'a',",
          "    };",
          "",
          "    let end_literal = Literal {",
          "        span: Span { start: Position(2), end: Position(3) },",
          "        kind: LiteralKind::Char,",
          "        c: 'z',",
          "    };",
          "",
          "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange {",
          "        span: Span { start: Position(0), end: Position(4) },",
          "        start: start_literal,",
          "        end: end_literal,",
          "    });",
          "",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    translator_i.visit_class_set_item_post(&class_set_item).unwrap();",
          "}"
        ],
        "oracle": [
          "    let translator = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    unicode: Some(false),",
          "    ..Default::default()",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let start_literal = Literal {",
          "    span: Span { start: Position(0), end: Position(1) },",
          "    kind: LiteralKind::Char,",
          "    c: 'a',",
          "    };",
          "    ",
          "    let end_literal = Literal {",
          "    span: Span { start: Position(2), end: Position(3) },",
          "    kind: LiteralKind::Char,",
          "    c: 'z',",
          "    };",
          "    ",
          "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange {",
          "    span: Span { start: Position(0), end: Position(4) },",
          "    start: start_literal,",
          "    end: end_literal,",
          "    });",
          "    ",
          "    // Precondition 1: *ast matches ast::ClassSetItem::Range(ref x)",
          "    assert!(matches!(class_set_item, ast::ClassSetItem::Range(_)));",
          "    ",
          "    // Precondition 2: self.flags().unicode() is false",
          "    assert_eq!(translator_i.flags().unicode(), false);",
          "    ",
          "    // Precondition 3: self.class_literal_byte(&x.start)? is Ok",
          "    assert!(translator_i.class_literal_byte(&start_literal).is_ok());",
          "    ",
          "    // Precondition 4: self.class_literal_byte(&x.end)? is Ok",
          "    assert!(translator_i.class_literal_byte(&end_literal).is_ok());",
          "    ",
          "    // Expected return value/type: Ok(())",
          "    assert_eq!(translator_i.visit_class_set_item_post(&class_set_item).unwrap(), Ok(()));"
        ],
        "code": [
          "{",
          "    let mut translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags {",
          "            unicode: Some(false),",
          "            ..Default::default()",
          "        }),",
          "        utf8: true,",
          "        line_terminator: b'\\n',",
          "    };",
          "",
          "    let start_literal = Literal {",
          "        span: Span { start: Position(0), end: Position(1) },",
          "        kind: LiteralKind::Char,",
          "        c: 'a',",
          "    };",
          "",
          "    let end_literal = Literal {",
          "        span: Span { start: Position(2), end: Position(3) },",
          "        kind: LiteralKind::Char,",
          "        c: 'z',",
          "    };",
          "",
          "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange {",
          "        span: Span { start: Position(0), end: Position(4) },",
          "        start: start_literal,",
          "        end: end_literal,",
          "    });",
          "",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    translator_i.visit_class_set_item_post(&class_set_item).unwrap();",
          "    let translator = Translator {",
          "    stack: RefCell::new(vec![]),",
          "    flags: Cell::new(Flags {",
          "    unicode: Some(false),",
          "    ..Default::default()",
          "    }),",
          "    utf8: true,",
          "    line_terminator: b'\\n',",
          "    };",
          "    ",
          "    let start_literal = Literal {",
          "    span: Span { start: Position(0), end: Position(1) },",
          "    kind: LiteralKind::Char,",
          "    c: 'a',",
          "    };",
          "    ",
          "    let end_literal = Literal {",
          "    span: Span { start: Position(2), end: Position(3) },",
          "    kind: LiteralKind::Char,",
          "    c: 'z',",
          "    };",
          "    ",
          "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange {",
          "    span: Span { start: Position(0), end: Position(4) },",
          "    start: start_literal,",
          "    end: end_literal,",
          "    });",
          "    ",
          "    // Precondition 1: *ast matches ast::ClassSetItem::Range(ref x)",
          "    assert!(matches!(class_set_item, ast::ClassSetItem::Range(_)));",
          "    ",
          "    // Precondition 2: self.flags().unicode() is false",
          "    assert_eq!(translator_i.flags().unicode(), false);",
          "    ",
          "    // Precondition 3: self.class_literal_byte(&x.start)? is Ok",
          "    assert!(translator_i.class_literal_byte(&start_literal).is_ok());",
          "    ",
          "    // Precondition 4: self.class_literal_byte(&x.end)? is Ok",
          "    assert!(translator_i.class_literal_byte(&end_literal).is_ok());",
          "    ",
          "    // Expected return value/type: Ok(())",
          "    assert_eq!(translator_i.visit_class_set_item_post(&class_set_item).unwrap(), Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]