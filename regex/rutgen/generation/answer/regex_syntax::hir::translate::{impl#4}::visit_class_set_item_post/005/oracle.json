[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyVisitor {",
          "        stack: RefCell<Vec<HirFrame>>,",
          "        flags: Cell<Flags>,",
          "    }",
          "",
          "    impl DummyVisitor {",
          "        fn new() -> Self {",
          "            Self {",
          "                stack: RefCell::new(vec![]),",
          "                flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
          "            }",
          "        }",
          "        ",
          "        fn pop(&self) -> Option<HirFrame> {",
          "            self.stack.borrow_mut().pop()",
          "        }",
          "",
          "        fn push(&self, frame: HirFrame) {",
          "            self.stack.borrow_mut().push(frame);",
          "        }",
          "        ",
          "        fn bytes_fold_and_negate(",
          "            &self,",
          "            span: &Span,",
          "            negated: bool,",
          "            class: &mut ClassBytes,",
          "        ) -> Result<()> {",
          "            if negated {",
          "                class.negate();",
          "            }",
          "            Ok(())",
          "        }",
          "        ",
          "        fn flags(&self) -> Flags {",
          "            self.flags.get()",
          "        }",
          "    }",
          "",
          "    let mut visitor = DummyVisitor::new();",
          "    ",
          "    let span = Span { start: Position::new(0), end: Position::new(10) };",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
          "    visitor.push(HirFrame::ClassBytes(class_bytes.clone()));",
          "",
          "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
          "        span,",
          "        negated: false,",
          "        kind: ast::ClassSet::Union,",
          "    }));",
          "",
          "    visitor.visit_class_set_item_post(&class_set_item).unwrap();",
          "}"
        ],
        "oracle": [
          "    visitor.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange::new(0, 255)])));",
          "    visitor.flags.set(Flags { unicode: Some(false), ..Default::default() });",
          "    let result = visitor.bytes_fold_and_negate(&class_set_item.span, false, &mut cls1);",
          "    assert_eq!(result, Ok(()));",
          "    let frame = visitor.pop().unwrap();",
          "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
          "    let cls = frame.unwrap_class_bytes();",
          "    assert!(cls.ranges().len() > 0);",
          "    assert!(!cls.is_ascii());",
          "    assert_eq!(cls.minimum_len(), Some(0));",
          "    assert_eq!(cls.maximum_len(), Some(256));"
        ],
        "code": [
          "{",
          "    struct DummyVisitor {",
          "        stack: RefCell<Vec<HirFrame>>,",
          "        flags: Cell<Flags>,",
          "    }",
          "",
          "    impl DummyVisitor {",
          "        fn new() -> Self {",
          "            Self {",
          "                stack: RefCell::new(vec![]),",
          "                flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
          "            }",
          "        }",
          "        ",
          "        fn pop(&self) -> Option<HirFrame> {",
          "            self.stack.borrow_mut().pop()",
          "        }",
          "",
          "        fn push(&self, frame: HirFrame) {",
          "            self.stack.borrow_mut().push(frame);",
          "        }",
          "        ",
          "        fn bytes_fold_and_negate(",
          "            &self,",
          "            span: &Span,",
          "            negated: bool,",
          "            class: &mut ClassBytes,",
          "        ) -> Result<()> {",
          "            if negated {",
          "                class.negate();",
          "            }",
          "            Ok(())",
          "        }",
          "        ",
          "        fn flags(&self) -> Flags {",
          "            self.flags.get()",
          "        }",
          "    }",
          "",
          "    let mut visitor = DummyVisitor::new();",
          "    ",
          "    let span = Span { start: Position::new(0), end: Position::new(10) };",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
          "    visitor.push(HirFrame::ClassBytes(class_bytes.clone()));",
          "",
          "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
          "        span,",
          "        negated: false,",
          "        kind: ast::ClassSet::Union,",
          "    }));",
          "",
          "    visitor.visit_class_set_item_post(&class_set_item).unwrap();",
          "    visitor.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange::new(0, 255)])));",
          "    visitor.flags.set(Flags { unicode: Some(false), ..Default::default() });",
          "    let result = visitor.bytes_fold_and_negate(&class_set_item.span, false, &mut cls1);",
          "    assert_eq!(result, Ok(()));",
          "    let frame = visitor.pop().unwrap();",
          "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
          "    let cls = frame.unwrap_class_bytes();",
          "    assert!(cls.ranges().len() > 0);",
          "    assert!(!cls.is_ascii());",
          "    assert_eq!(cls.minimum_len(), Some(0));",
          "    assert_eq!(cls.maximum_len(), Some(256));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyVisitor {",
          "        stack: RefCell<Vec<HirFrame>>,",
          "        flags: Cell<Flags>,",
          "    }",
          "",
          "    impl DummyVisitor {",
          "        fn new() -> Self {",
          "            Self {",
          "                stack: RefCell::new(vec![]),",
          "                flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
          "            }",
          "        }",
          "        ",
          "        fn pop(&self) -> Option<HirFrame> {",
          "            self.stack.borrow_mut().pop()",
          "        }",
          "",
          "        fn push(&self, frame: HirFrame) {",
          "            self.stack.borrow_mut().push(frame);",
          "        }",
          "        ",
          "        fn bytes_fold_and_negate(",
          "            &self,",
          "            span: &Span,",
          "            negated: bool,",
          "            class: &mut ClassBytes,",
          "        ) -> Result<()> {",
          "            if negated {",
          "                class.negate();",
          "            }",
          "            Ok(())",
          "        }",
          "        ",
          "        fn flags(&self) -> Flags {",
          "            self.flags.get()",
          "        }",
          "    }",
          "",
          "    let mut visitor = DummyVisitor::new();",
          "    ",
          "    let span = Span { start: Position::new(0), end: Position::new(10) };",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(0, 100)]);",
          "    visitor.push(HirFrame::ClassBytes(class_bytes.clone()));",
          "",
          "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
          "        span,",
          "        negated: true,",
          "        kind: ast::ClassSet::Union,",
          "    }));",
          "",
          "    visitor.visit_class_set_item_post(&class_set_item).unwrap();",
          "}"
        ],
        "oracle": [
          "    self.push(HirFrame::ClassBytes(cls1));",
          "    cls1.union(&cls2);",
          "    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();",
          "    self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls1).unwrap();",
          "    self.flags().unicode();",
          "    Ok(())"
        ],
        "code": [
          "{",
          "    struct DummyVisitor {",
          "        stack: RefCell<Vec<HirFrame>>,",
          "        flags: Cell<Flags>,",
          "    }",
          "",
          "    impl DummyVisitor {",
          "        fn new() -> Self {",
          "            Self {",
          "                stack: RefCell::new(vec![]),",
          "                flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
          "            }",
          "        }",
          "        ",
          "        fn pop(&self) -> Option<HirFrame> {",
          "            self.stack.borrow_mut().pop()",
          "        }",
          "",
          "        fn push(&self, frame: HirFrame) {",
          "            self.stack.borrow_mut().push(frame);",
          "        }",
          "        ",
          "        fn bytes_fold_and_negate(",
          "            &self,",
          "            span: &Span,",
          "            negated: bool,",
          "            class: &mut ClassBytes,",
          "        ) -> Result<()> {",
          "            if negated {",
          "                class.negate();",
          "            }",
          "            Ok(())",
          "        }",
          "        ",
          "        fn flags(&self) -> Flags {",
          "            self.flags.get()",
          "        }",
          "    }",
          "",
          "    let mut visitor = DummyVisitor::new();",
          "    ",
          "    let span = Span { start: Position::new(0), end: Position::new(10) };",
          "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(0, 100)]);",
          "    visitor.push(HirFrame::ClassBytes(class_bytes.clone()));",
          "",
          "    let class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
          "        span,",
          "        negated: true,",
          "        kind: ast::ClassSet::Union,",
          "    }));",
          "",
          "    visitor.visit_class_set_item_post(&class_set_item).unwrap();",
          "    self.push(HirFrame::ClassBytes(cls1));",
          "    cls1.union(&cls2);",
          "    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();",
          "    self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls1).unwrap();",
          "    self.flags().unicode();",
          "    Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]