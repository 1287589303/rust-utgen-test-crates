[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::default(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: Vec::new(),",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![",
          "        // Use valid ranges, e.g., ranges within 0-255",
          "        hir::UnicodeRange::new(65, 90), // A-Z",
          "        hir::UnicodeRange::new(97, 122), // a-z",
          "    ]);",
          "    ",
          "    // Triggering add_union()? to return an Err with the empty builder state.",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class).is_err(), true);",
          "    assert!(matches!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class).err(), Some(BuildError { .. })));",
          "    assert_eq!(compiler.utf8_suffix.borrow().map.len(), 10);",
          "    assert_eq!(compiler.utf8_suffix.borrow().version, 1);",
          "    assert_eq!(compiler.builder.borrow().states.len(), 0);",
          "    assert_eq!(compiler.trie_state.borrow().states.len(), 0);",
          "    assert_eq!(compiler.trie_state.borrow().free.len(), 0);"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::default(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: Vec::new(),",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![",
          "        // Use valid ranges, e.g., ranges within 0-255",
          "        hir::UnicodeRange::new(65, 90), // A-Z",
          "        hir::UnicodeRange::new(97, 122), // a-z",
          "    ]);",
          "    ",
          "    // Triggering add_union()? to return an Err with the empty builder state.",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "    assert_eq!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class).is_err(), true);",
          "    assert!(matches!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class).err(), Some(BuildError { .. })));",
          "    assert_eq!(compiler.utf8_suffix.borrow().map.len(), 10);",
          "    assert_eq!(compiler.utf8_suffix.borrow().version, 1);",
          "    assert_eq!(compiler.builder.borrow().states.len(), 0);",
          "    assert_eq!(compiler.trie_state.borrow().states.len(), 0);",
          "    assert_eq!(compiler.trie_state.borrow().free.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::default(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: Vec::new(),",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![",
          "        // Use an invalid range to ensure Edge case",
          "        hir::UnicodeRange::new(255, 254), // Invalid range since start > end",
          "    ]);",
          "",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "}"
        ],
        "oracle": [
          "    assert!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class).is_err());",
          "    assert!(matches!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class), Err(BuildError { kind: _ })));"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::default(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: Vec::new(),",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![",
          "        // Use an invalid range to ensure Edge case",
          "        hir::UnicodeRange::new(255, 254), // Invalid range since start > end",
          "    ]);",
          "",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "    assert!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class).is_err());",
          "    assert!(matches!(compiler.c_unicode_class_reverse_with_suffix(&unicode_class), Err(BuildError { kind: _ })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::default(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: Vec::new(),",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![",
          "        // Large valid ranges",
          "        hir::UnicodeRange::new(0, 255), // Full byte range",
          "    ]);",
          "",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "}"
        ],
        "oracle": [
          "    let compiler = Compiler { parser: ParserBuilder::default(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State { compiled: Utf8BoundedMap::default(), uncompiled: Vec::new(), }), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)), };",
          "    ",
          "    let unicode_class = hir::ClassUnicode::new(vec![hir::UnicodeRange::new(0, 255)]);",
          "    ",
          "    let result = compiler.add_union();",
          "    assert!(result.is_err());",
          "    ",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "    assert!(result.is_err());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::default(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State {",
          "            compiled: Utf8BoundedMap::default(),",
          "            uncompiled: Vec::new(),",
          "        }),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![",
          "        // Large valid ranges",
          "        hir::UnicodeRange::new(0, 255), // Full byte range",
          "    ]);",
          "",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "    let compiler = Compiler { parser: ParserBuilder::default(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State { compiled: Utf8BoundedMap::default(), uncompiled: Vec::new(), }), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap::new(10)), };",
          "    ",
          "    let unicode_class = hir::ClassUnicode::new(vec![hir::UnicodeRange::new(0, 255)]);",
          "    ",
          "    let result = compiler.add_union();",
          "    assert!(result.is_err());",
          "    ",
          "    let _ = compiler.c_unicode_class_reverse_with_suffix(&unicode_class);",
          "    assert!(result.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]