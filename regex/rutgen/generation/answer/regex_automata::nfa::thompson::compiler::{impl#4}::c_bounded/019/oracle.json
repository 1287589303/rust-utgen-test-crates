[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::concat(vec![",
          "        hir::Hir::literal(b'a'),",
          "        hir::Hir::literal(b'a'),",
          "    ]);",
          "    let result = compiler.c_bounded(&expr, true, 1, 3);",
          "}"
        ],
        "oracle": [
          "    let result = compiler.c_bounded(&expr, true, 1, 3);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start);",
          "    assert_eq!(thompson_ref.end, expected_end);",
          "    assert!(self.patch(prev_end, empty).is_ok());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::concat(vec![",
          "        hir::Hir::literal(b'a'),",
          "        hir::Hir::literal(b'a'),",
          "    ]);",
          "    let result = compiler.c_bounded(&expr, true, 1, 3);",
          "    let result = compiler.c_bounded(&expr, true, 1, 3);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start);",
          "    assert_eq!(thompson_ref.end, expected_end);",
          "    assert!(self.patch(prev_end, empty).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::literal(b'a');",
          "    let result = compiler.c_bounded(&expr, false, 1, 4);",
          "}"
        ],
        "oracle": [
          "    let expr = hir::Hir::literal(b'a');",
          "    let result = compiler.c_bounded(&expr, false, 1, 4);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, /* expected start state ID */ );",
          "    assert_eq!(thompson_ref.end, /* expected end state ID */ );",
          "    assert!(self.c_exactly(&expr, 1).is_ok());",
          "    assert!(self.add_empty().is_ok());",
          "    assert!(self.patch(prev_end, empty).is_ok());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::literal(b'a');",
          "    let result = compiler.c_bounded(&expr, false, 1, 4);",
          "    let expr = hir::Hir::literal(b'a');",
          "    let result = compiler.c_bounded(&expr, false, 1, 4);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, /* expected start state ID */ );",
          "    assert_eq!(thompson_ref.end, /* expected end state ID */ );",
          "    assert!(self.c_exactly(&expr, 1).is_ok());",
          "    assert!(self.add_empty().is_ok());",
          "    assert!(self.patch(prev_end, empty).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::repeat(Box::new(hir::Hir::literal(b'a')), 2, None);",
          "    let result = compiler.c_bounded(&expr, true, 2, 5);",
          "}"
        ],
        "oracle": [
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State::default()), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }) };",
          "    let expr = hir::Hir::repeat(Box::new(hir::Hir::literal(b'a')), 2, None);",
          "    let prefix_result = compiler.c_exactly(&expr, 2);",
          "    assert!(prefix_result.is_ok());",
          "    let empty_result = compiler.add_empty();",
          "    assert!(empty_result.is_ok());",
          "    let result = compiler.c_bounded(&expr, true, 2, 5);",
          "    assert_eq!(result, Ok(ThompsonRef { start: prefix_result.unwrap().start, end: empty_result.unwrap() }));",
          "    assert!(compiler.patch(StateID(1), StateID(2)).is_ok());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::repeat(Box::new(hir::Hir::literal(b'a')), 2, None);",
          "    let result = compiler.c_bounded(&expr, true, 2, 5);",
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State::default()), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }) };",
          "    let expr = hir::Hir::repeat(Box::new(hir::Hir::literal(b'a')), 2, None);",
          "    let prefix_result = compiler.c_exactly(&expr, 2);",
          "    assert!(prefix_result.is_ok());",
          "    let empty_result = compiler.add_empty();",
          "    assert!(empty_result.is_ok());",
          "    let result = compiler.c_bounded(&expr, true, 2, 5);",
          "    assert_eq!(result, Ok(ThompsonRef { start: prefix_result.unwrap().start, end: empty_result.unwrap() }));",
          "    assert!(compiler.patch(StateID(1), StateID(2)).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::capture(0, None, Box::new(hir::Hir::literal(b'a')));",
          "    let result = compiler.c_bounded(&expr, false, 3, 6);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, compiler.c_exactly(&expr, 3).unwrap().start);",
          "    assert!(compiler.add_empty().is_ok());",
          "    assert!(thompson_ref.end == compiler.add_empty().unwrap());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::capture(0, None, Box::new(hir::Hir::literal(b'a')));",
          "    let result = compiler.c_bounded(&expr, false, 3, 6);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, compiler.c_exactly(&expr, 3).unwrap().start);",
          "    assert!(compiler.add_empty().is_ok());",
          "    assert!(thompson_ref.end == compiler.add_empty().unwrap());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::literal(b'b');",
          "    let result = compiler.c_bounded(&expr, true, 4, 6);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, compiler.c_exactly(&expr, 4).unwrap().start);",
          "    assert!(compiler.add_empty().is_ok());",
          "    assert!(compiler.patch(thompson_ref.end, compiler.add_empty().unwrap()).is_ok());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap { version: 0, capacity: 0, map: vec![] }),",
          "    };",
          "    let expr = hir::Hir::literal(b'b');",
          "    let result = compiler.c_bounded(&expr, true, 4, 6);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, compiler.c_exactly(&expr, 4).unwrap().start);",
          "    assert!(compiler.add_empty().is_ok());",
          "    assert!(compiler.patch(thompson_ref.end, compiler.add_empty().unwrap()).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]