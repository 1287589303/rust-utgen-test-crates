[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
          "        c: '\\n',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{:02X}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{:04X}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{:08X}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
          "        c: '\\n',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{:02X}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{:04X}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{:08X}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "        c: '\\x0b',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    writer.fmt_literal(&ast); // Expecting output: \"\\v\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\n\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\ \"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\a\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\f\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\t\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\r\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\u{000B}\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\u{000C}\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\t\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\n\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\r\""
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "        c: '\\x0b',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\v\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\n\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\ \"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\a\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\f\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\t\"",
          "    writer.fmt_literal(&ast); // Expecting output: \"\\r\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\u{000B}\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\u{000C}\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\t\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\n\"",
          "    writer.fmt_literal(&ast); // Expecting output: r\"\\r\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
          "        c: ' ',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{42}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000043}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
          "        c: ' ',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{42}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000043}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
          "        c: '\\x07',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{41}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000041}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
          "        c: '\\x07',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{41}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000041}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "        c: '\\x0c',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::LineFeed)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\n\"); // Expected output for LineFeed",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::VerticalTab)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\v\"); // Expected output for VerticalTab",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::Space)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\ \"); // Expected output for Space",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::Bell)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\a\"); // Expected output for Bell",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::FormFeed)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\f\"); // Expected output for FormFeed",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::Tab)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\t\"); // Expected output for Tab",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::CarriageReturn)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\r\"); // Expected output for CarriageReturn",
          "    ",
          "    writer.fmt_literal(&ast); // For HexFixed(ast::HexLiteralKind::UnicodeShort)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\u{000C}\"); // Expected output for UnicodeShort",
          "    ",
          "    writer.fmt_literal(&ast); // For HexFixed(ast::HexLiteralKind::X)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\x{0C}\"); // Expected output for X",
          "    ",
          "    writer.fmt_literal(&ast); // For HexFixed(ast::HexLiteralKind::UnicodeLong)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\U{0000000C}\"); // Expected output for UnicodeLong"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "        c: '\\x0c',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::LineFeed)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\n\"); // Expected output for LineFeed",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::VerticalTab)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\v\"); // Expected output for VerticalTab",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::Space)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\ \"); // Expected output for Space",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::Bell)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\a\"); // Expected output for Bell",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::FormFeed)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\f\"); // Expected output for FormFeed",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::Tab)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\t\"); // Expected output for Tab",
          "    ",
          "    writer.fmt_literal(&ast); // For Special(ast::SpecialLiteralKind::CarriageReturn)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\r\"); // Expected output for CarriageReturn",
          "    ",
          "    writer.fmt_literal(&ast); // For HexFixed(ast::HexLiteralKind::UnicodeShort)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\u{000C}\"); // Expected output for UnicodeShort",
          "    ",
          "    writer.fmt_literal(&ast); // For HexFixed(ast::HexLiteralKind::X)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\x{0C}\"); // Expected output for X",
          "    ",
          "    writer.fmt_literal(&ast); // For HexFixed(ast::HexLiteralKind::UnicodeLong)",
          "    ",
          "    assert_eq!(writer.wtr.output, r\"\\U{0000000C}\"); // Expected output for UnicodeLong",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
          "        c: '\\t',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x41\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u0041\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U00000041\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
          "        c: '\\t',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\t\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\x0C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x41\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u0041\");",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U00000041\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
          "        c: '\\r',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\r\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
          "    c: '\\n',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\n\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\v\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
          "    c: '\\t',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\t\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
          "    c: '\\x07',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\a\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "    c: '\\x0C',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\f\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
          "    c: ' ',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\ \");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\x{:02X}\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "    c: 'α',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\u{:04X}\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "    c: '𐍈',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\U{:08X}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
          "        c: '\\r',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\r\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
          "    c: '\\n',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\n\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\v\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
          "    c: '\\t',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\t\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
          "    c: '\\x07',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\a\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "    c: '\\x0C',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\f\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
          "    c: ' ',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\ \");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\x{:02X}\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "    c: 'α',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\u{:04X}\");",
          "    let ast = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "    c: '𐍈',",
          "    }; writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\U{:08X}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "        c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_line_feed = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
          "    c: '\\n',",
          "    };",
          "    assert_eq!(writer.fmt_literal(&ast_line_feed), Ok(()));",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_vertical_tab = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_vertical_tab);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_space = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
          "    c: ' ',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_space);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_bell = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
          "    c: '\\x07',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_bell);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_form_feed = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "    c: '\\x0C',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_form_feed);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_carriage_return = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
          "    c: '\\r',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_carriage_return);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_hex_unicode_short = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "    c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_hex_unicode_short);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_hex_x = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_hex_x);",
          "    assert_eq!(writer.wtr.output, r\"\\x{41}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_hex_unicode_long = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "    c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_hex_unicode_long);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000041}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "        c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_line_feed = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
          "    c: '\\n',",
          "    };",
          "    assert_eq!(writer.fmt_literal(&ast_line_feed), Ok(()));",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_vertical_tab = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "    c: '\\x0B',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_vertical_tab);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_space = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
          "    c: ' ',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_space);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_bell = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
          "    c: '\\x07',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_bell);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_form_feed = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "    c: '\\x0C',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_form_feed);",
          "    assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_carriage_return = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
          "    c: '\\r',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_carriage_return);",
          "    assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_hex_unicode_short = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort),",
          "    c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_hex_unicode_short);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_hex_x = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_hex_x);",
          "    assert_eq!(writer.wtr.output, r\"\\x{41}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast_hex_unicode_long = ast::Literal {",
          "    span: Span::default(),",
          "    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "    c: 'A',",
          "    };",
          "    let _ = writer.fmt_literal(&ast_hex_unicode_long);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000041}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "        c: 'B',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\u{0B}' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\u{07}' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\u{0C}' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'B' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\x42\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'B' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\u{0042}\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'B' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\U{00000042}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),",
          "        c: 'B',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\u{0B}' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\u{07}' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed), c: '\\u{0C}' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\f\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\t\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn), c: '\\r' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\r\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'B' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\x42\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'B' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\u{0042}\");",
          "    ",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'B' }; let _ = writer.fmt_literal(&ast); assert_eq!(writer.wtr.output, r\"\\U{00000042}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "        c: 'C',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{42}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000043}\");"
        ],
        "code": [
          "{",
          "    struct TestWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for TestWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong),",
          "        c: 'C',",
          "    };",
          "    let _ = writer.fmt_literal(&ast);",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed), c: '\\n' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\n\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\v\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\ \");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\a\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeShort), c: 'A' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\u{0041}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X), c: 'B' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\x{42}\");",
          "    ",
          "    let mut writer = Writer { wtr: TestWriter { output: String::new() } };",
          "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::UnicodeLong), c: 'C' };",
          "    let _ = writer.fmt_literal(&ast);",
          "    assert_eq!(writer.wtr.output, r\"\\U{00000043}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]