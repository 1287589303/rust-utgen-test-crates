[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
          "        c: '\\u{1F600}', // example Unicode scalar character",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
          "    c: '\\u{1F600}',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\U{1F600}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
          "    c: '\\u{007F}',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{007F}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\x{41}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::Meta,",
          "    c: '\\u{007B}',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{007B}\");"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
          "        c: '\\u{1F600}', // example Unicode scalar character",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
          "    c: '\\u{1F600}',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\U{1F600}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
          "    c: '\\u{007F}',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{007F}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
          "    c: 'A',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\x{41}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::Meta,",
          "    c: '\\u{007B}',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{007B}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
          "        c: '\\u{007F}', // example boundary value",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong), c: '\\u{D7FF}' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\U{D7FF}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X), c: '\\u{03A9}' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\x{3A9}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::Meta, c: 'A' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\A\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort), c: '\\u{00A0}' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{00A0}\");"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
          "        c: '\\u{007F}', // example boundary value",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong), c: '\\u{D7FF}' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\U{D7FF}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X), c: '\\u{03A9}' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\x{3A9}\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::Meta, c: 'A' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\A\");",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let ast = ast::Literal { span: Span::new(0, 1), kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort), c: '\\u{00A0}' };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{00A0}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
          "        c: 'A', // character within valid range",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    writer.output == r\"\\x{{41}}\"",
          "    visitor.fmt_literal(&ast).is_ok()",
          "    ast.kind == ast::LiteralKind::HexBrace(ast::HexLiteralKind::X)",
          "    ast.c == 'A'",
          "    writer.output.is_empty() == false",
          "    writer.output.len() == 6"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
          "        c: 'A', // character within valid range",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    writer.output == r\"\\x{{41}}\"",
          "    visitor.fmt_literal(&ast).is_ok()",
          "    ast.kind == ast::LiteralKind::HexBrace(ast::HexLiteralKind::X)",
          "    ast.c == 'A'",
          "    writer.output.is_empty() == false",
          "    writer.output.len() == 6",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::Meta,",
          "        c: '\\u{20}', // example Unicode scalar character",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writer.output, r\"\\ \");",
          "    ",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
          "    c: '\\u{1F600}', // example Unicode scalar character (grinning face)",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{1F600}\");",
          "    ",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
          "    c: '\\u{1F680}', // example Unicode scalar character (rocket)",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\U{1F680}\");",
          "    ",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
          "    c: 'x',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\x{78}\");"
        ],
        "code": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "    ",
          "    let mut writer = MockWriter { output: String::new() };",
          "    ",
          "    let ast = ast::Literal {",
          "        span: Span::new(0, 1),",
          "        kind: ast::LiteralKind::Meta,",
          "        c: '\\u{20}', // example Unicode scalar character",
          "    };",
          "    ",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\ \");",
          "    ",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
          "    c: '\\u{1F600}', // example Unicode scalar character (grinning face)",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\u{1F600}\");",
          "    ",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
          "    c: '\\u{1F680}', // example Unicode scalar character (rocket)",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\U{1F680}\");",
          "    ",
          "    let ast = ast::Literal {",
          "    span: Span::new(0, 1),",
          "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
          "    c: 'x',",
          "    };",
          "    let mut visitor = Writer { wtr: &mut writer };",
          "    let _ = visitor.fmt_literal(&ast);",
          "    assert_eq!(writer.output, r\"\\x{78}\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]