[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![ClassUnicodeRange::new('A', 'Z'), ClassUnicodeRange::new('a', 'z')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "",
          "    let result = unicode_class.try_case_fold_simple();",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().0, ());"
        ],
        "code": [
          "{",
          "    let ranges = vec![ClassUnicodeRange::new('A', 'Z'), ClassUnicodeRange::new('a', 'z')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().0, ());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_unicode_class = Class::Unicode(ClassUnicode::empty());",
          "",
          "    let result = empty_unicode_class.try_case_fold_simple();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().is_none(), true);"
        ],
        "code": [
          "{",
          "    let empty_unicode_class = Class::Unicode(ClassUnicode::empty());",
          "",
          "    let result = empty_unicode_class.try_case_fold_simple();",
          "    assert_eq!(result.is_err(), true);",
          "    assert_eq!(result.unwrap_err().is_none(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "",
          "    let result = unicode_class.try_case_fold_simple();",
          "}"
        ],
        "oracle": [
          "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert!(result.is_err());",
          "    assert_eq!(result, Err(CaseFoldError(())));"
        ],
        "code": [
          "{",
          "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let ranges = vec![ClassUnicodeRange::new('A', 'A')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert!(result.is_err());",
          "    assert_eq!(result, Err(CaseFoldError(())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "",
          "    let result = unicode_class.try_case_fold_simple();",
          "}"
        ],
        "oracle": [
          "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert!(result.is_err());",
          "    assert_eq!(result, Err(CaseFoldError(())));"
        ],
        "code": [
          "{",
          "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let ranges = vec![ClassUnicodeRange::new('é', 'é')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert!(result.is_err());",
          "    assert_eq!(result, Err(CaseFoldError(())));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]