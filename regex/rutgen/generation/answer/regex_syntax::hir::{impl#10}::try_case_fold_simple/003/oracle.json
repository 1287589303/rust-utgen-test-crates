[
  {
    "uses": [
      "use crate::hir::Class;",
      "use crate::hir::ClassUnicode;",
      "use crate::hir::ClassUnicodeKind;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::hir::{Class, ClassUnicode, ClassUnicodeKind};",
          "    ",
          "    let ranges = vec![",
          "        ClassUnicodeRange::new('A'..='Z'), // valid uppercase range",
          "        ClassUnicodeRange::new('a'..='z'), // valid lowercase range",
          "    ];",
          "    ",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    ",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let _ = result.unwrap(); // expect Ok(())",
          "}"
        ],
        "oracle": [
          "    let ranges = vec![ClassUnicodeRange::new('A'..='Z'), ClassUnicodeRange::new('a'..='z')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    assert_eq!(unicode_class.try_case_fold_simple(), Ok(()));",
          "    assert!(matches!(unicode_class, Class::Unicode(_)));",
          "    assert!(unicode_class.is_ascii());"
        ],
        "code": [
          "{",
          "    use crate::hir::{Class, ClassUnicode, ClassUnicodeKind};",
          "    ",
          "    let ranges = vec![",
          "        ClassUnicodeRange::new('A'..='Z'), // valid uppercase range",
          "        ClassUnicodeRange::new('a'..='z'), // valid lowercase range",
          "    ];",
          "    ",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    ",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let _ = result.unwrap(); // expect Ok(())",
          "    let ranges = vec![ClassUnicodeRange::new('A'..='Z'), ClassUnicodeRange::new('a'..='z')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    assert_eq!(unicode_class.try_case_fold_simple(), Ok(()));",
          "    assert!(matches!(unicode_class, Class::Unicode(_)));",
          "    assert!(unicode_class.is_ascii());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::hir::{Class, ClassUnicode};",
          "    ",
          "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
          "    ",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let _ = result.unwrap(); // expect Ok(())",
          "}"
        ],
        "oracle": [
          "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert_eq!(result, Ok(()));"
        ],
        "code": [
          "{",
          "    use crate::hir::{Class, ClassUnicode};",
          "    ",
          "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
          "    ",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let _ = result.unwrap(); // expect Ok(())",
          "    let unicode_class = Class::Unicode(ClassUnicode::empty());",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert_eq!(result, Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::hir::{Class, ClassUnicode};",
          "    ",
          "    let ranges = vec![",
          "        ClassUnicodeRange::new('é'..='è'), // valid range including accented letters",
          "    ];",
          "    ",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    ",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let _ = result.unwrap(); // expect Ok(())",
          "}"
        ],
        "oracle": [
          "    let ranges = vec![ClassUnicodeRange::new('é'..='è')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert_eq!(result, Ok(()));"
        ],
        "code": [
          "{",
          "    use crate::hir::{Class, ClassUnicode};",
          "    ",
          "    let ranges = vec![",
          "        ClassUnicodeRange::new('é'..='è'), // valid range including accented letters",
          "    ];",
          "    ",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    ",
          "    let result = unicode_class.try_case_fold_simple();",
          "    let _ = result.unwrap(); // expect Ok(())",
          "    let ranges = vec![ClassUnicodeRange::new('é'..='è')];",
          "    let mut unicode_class = Class::Unicode(ClassUnicode::new(ranges));",
          "    let result = unicode_class.try_case_fold_simple();",
          "    assert_eq!(result, Ok(()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]