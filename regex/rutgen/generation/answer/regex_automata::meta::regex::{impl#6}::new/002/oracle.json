[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config::default();",
          "    let hirs: Vec<&Hir> = vec![];",
          "    let regex_info = RegexInfo::new(config, &hirs);",
          "}"
        ],
        "oracle": [
          "    assert!(regex_info.0.config == config);",
          "    assert!(regex_info.0.props.is_empty());",
          "    assert!(regex_info.0.props_union.is_empty());",
          "    assert_eq!(regex_info.0.props.len(), 0);",
          "    assert_eq!(regex_info.0.props_union.len(), 0);"
        ],
        "code": [
          "{",
          "    let config = Config::default();",
          "    let hirs: Vec<&Hir> = vec![];",
          "    let regex_info = RegexInfo::new(config, &hirs);",
          "    assert!(regex_info.0.config == config);",
          "    assert!(regex_info.0.props.is_empty());",
          "    assert!(regex_info.0.props_union.is_empty());",
          "    assert_eq!(regex_info.0.props.len(), 0);",
          "    assert_eq!(regex_info.0.props_union.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config {",
          "        match_kind: None,",
          "        utf8_empty: None,",
          "        autopre: None,",
          "        pre: None,",
          "        which_captures: None,",
          "        nfa_size_limit: None,",
          "        onepass_size_limit: None,",
          "        hybrid_cache_capacity: None,",
          "        hybrid: None,",
          "        dfa: None,",
          "        dfa_size_limit: None,",
          "        dfa_state_limit: None,",
          "        onepass: None,",
          "        backtrack: None,",
          "        byte_classes: None,",
          "        line_terminator: None,",
          "    };",
          "    let hirs: Vec<&Hir> = vec![];",
          "    let regex_info = RegexInfo::new(config, &hirs);",
          "}"
        ],
        "oracle": [
          "    let config = Config { match_kind: None, utf8_empty: None, autopre: None, pre: None, which_captures: None, nfa_size_limit: None, onepass_size_limit: None, hybrid_cache_capacity: None, hybrid: None, dfa: None, dfa_size_limit: None, dfa_state_limit: None, onepass: None, backtrack: None, byte_classes: None, line_terminator: None };",
          "    let hirs: Vec<&Hir> = vec![];",
          "    let regex_info = RegexInfo::new(config, &hirs);",
          "    assert!(regex_info.config() == &config);",
          "    assert!(regex_info.props().is_empty());",
          "    assert!(Arc::strong_count(&regex_info.0) == 1);",
          "    assert!(regex_info.props_union() == &hir::Properties::default());"
        ],
        "code": [
          "{",
          "    let config = Config {",
          "        match_kind: None,",
          "        utf8_empty: None,",
          "        autopre: None,",
          "        pre: None,",
          "        which_captures: None,",
          "        nfa_size_limit: None,",
          "        onepass_size_limit: None,",
          "        hybrid_cache_capacity: None,",
          "        hybrid: None,",
          "        dfa: None,",
          "        dfa_size_limit: None,",
          "        dfa_state_limit: None,",
          "        onepass: None,",
          "        backtrack: None,",
          "        byte_classes: None,",
          "        line_terminator: None,",
          "    };",
          "    let hirs: Vec<&Hir> = vec![];",
          "    let regex_info = RegexInfo::new(config, &hirs);",
          "    let config = Config { match_kind: None, utf8_empty: None, autopre: None, pre: None, which_captures: None, nfa_size_limit: None, onepass_size_limit: None, hybrid_cache_capacity: None, hybrid: None, dfa: None, dfa_size_limit: None, dfa_state_limit: None, onepass: None, backtrack: None, byte_classes: None, line_terminator: None };",
          "    let hirs: Vec<&Hir> = vec![];",
          "    let regex_info = RegexInfo::new(config, &hirs);",
          "    assert!(regex_info.config() == &config);",
          "    assert!(regex_info.props().is_empty());",
          "    assert!(Arc::strong_count(&regex_info.0) == 1);",
          "    assert!(regex_info.props_union() == &hir::Properties::default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]