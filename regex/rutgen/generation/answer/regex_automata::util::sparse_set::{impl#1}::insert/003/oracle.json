[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    let state_id = StateID::new_unchecked(0);",
          "    set.insert(state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(state_id));",
          "    assert_eq!(set.capacity(), 5);",
          "    assert!(!set.is_empty());",
          "    ",
          "    let state_id_2 = StateID::new_unchecked(1);",
          "    let result = set.insert(state_id_2);",
          "    assert!(result);",
          "    assert_eq!(set.len(), 2);",
          "    assert!(set.contains(state_id_2));",
          "    assert_eq!(set.capacity(), 5);",
          "    ",
          "    let state_id_3 = StateID::new_unchecked(0);",
          "    let result_existing = set.insert(state_id_3);",
          "    assert!(!result_existing);",
          "    assert_eq!(set.len(), 2);",
          "    ",
          "    let state_id_4 = StateID::new_unchecked(5);",
          "    let result_over_capacity = std::panic::catch_unwind(|| {",
          "    set.insert(state_id_4);",
          "    });",
          "    assert!(result_over_capacity.is_err());"
        ],
        "code": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    let state_id = StateID::new_unchecked(0);",
          "    set.insert(state_id);",
          "    assert_eq!(set.len(), 1);",
          "    assert!(set.contains(state_id));",
          "    assert_eq!(set.capacity(), 5);",
          "    assert!(!set.is_empty());",
          "    ",
          "    let state_id_2 = StateID::new_unchecked(1);",
          "    let result = set.insert(state_id_2);",
          "    assert!(result);",
          "    assert_eq!(set.len(), 2);",
          "    assert!(set.contains(state_id_2));",
          "    assert_eq!(set.capacity(), 5);",
          "    ",
          "    let state_id_3 = StateID::new_unchecked(0);",
          "    let result_existing = set.insert(state_id_3);",
          "    assert!(!result_existing);",
          "    assert_eq!(set.len(), 2);",
          "    ",
          "    let state_id_4 = StateID::new_unchecked(5);",
          "    let result_over_capacity = std::panic::catch_unwind(|| {",
          "    set.insert(state_id_4);",
          "    });",
          "    assert!(result_over_capacity.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    for i in 0..4 {",
          "        let state_id = StateID::new_unchecked(i);",
          "        set.insert(state_id);",
          "    }",
          "}"
        ],
        "oracle": [
          "    set.insert(StateID::new_unchecked(4)) == true",
          "    set.contains(StateID::new_unchecked(4)) == true",
          "    let panic_insert = std::panic::catch_unwind(|| set.insert(StateID::new_unchecked(5)));",
          "    panic_insert.is_err() == true",
          "    set.len() == 5",
          "    set.capacity() == 5"
        ],
        "code": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    for i in 0..4 {",
          "        let state_id = StateID::new_unchecked(i);",
          "        set.insert(state_id);",
          "    }",
          "    set.insert(StateID::new_unchecked(4)) == true",
          "    set.contains(StateID::new_unchecked(4)) == true",
          "    let panic_insert = std::panic::catch_unwind(|| set.insert(StateID::new_unchecked(5)));",
          "    panic_insert.is_err() == true",
          "    set.len() == 5",
          "    set.capacity() == 5",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    for i in 0..5 {",
          "        let state_id = StateID::new_unchecked(i);",
          "        set.insert(state_id);",
          "    }",
          "    let overflow_id = StateID::new_unchecked(5);",
          "    set.insert(overflow_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.len(), 5);",
          "    assert!(set.is_empty() == false);",
          "    assert!(set.contains(StateID::new_unchecked(0)));",
          "    assert!(set.contains(StateID::new_unchecked(1)));",
          "    assert!(set.contains(StateID::new_unchecked(2)));",
          "    assert!(set.contains(StateID::new_unchecked(3)));",
          "    assert!(set.contains(StateID::new_unchecked(4)));",
          "    assert!(!set.contains(StateID::new_unchecked(5)));",
          "    assert!(set.capacity() == 5);",
          "    let new_state_id = StateID::new_unchecked(6);",
          "    assert!(!set.insert(new_state_id));",
          "    let existing_id = StateID::new_unchecked(2);",
          "    assert!(!set.insert(existing_id));",
          "    assert_eq!(set.len(), 5);",
          "    assert!(std::panic::catch_unwind(|| set.insert(overflow_id)).is_err());"
        ],
        "code": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    for i in 0..5 {",
          "        let state_id = StateID::new_unchecked(i);",
          "        set.insert(state_id);",
          "    }",
          "    let overflow_id = StateID::new_unchecked(5);",
          "    set.insert(overflow_id);",
          "    assert_eq!(set.len(), 5);",
          "    assert!(set.is_empty() == false);",
          "    assert!(set.contains(StateID::new_unchecked(0)));",
          "    assert!(set.contains(StateID::new_unchecked(1)));",
          "    assert!(set.contains(StateID::new_unchecked(2)));",
          "    assert!(set.contains(StateID::new_unchecked(3)));",
          "    assert!(set.contains(StateID::new_unchecked(4)));",
          "    assert!(!set.contains(StateID::new_unchecked(5)));",
          "    assert!(set.capacity() == 5);",
          "    let new_state_id = StateID::new_unchecked(6);",
          "    assert!(!set.insert(new_state_id));",
          "    let existing_id = StateID::new_unchecked(2);",
          "    assert!(!set.insert(existing_id));",
          "    assert_eq!(set.len(), 5);",
          "    assert!(std::panic::catch_unwind(|| set.insert(overflow_id)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    for i in 0..5 {",
          "        let state_id = StateID::new_unchecked(i);",
          "        set.insert(state_id);",
          "    }",
          "    let id_at_capacity = StateID::new_unchecked(5);",
          "    set.insert(id_at_capacity);",
          "}"
        ],
        "oracle": [
          "    set.insert(state_id); // Expected return: true for each insertion until capacity",
          "    assert_eq!(set.len(), 5); // Verify length after insertion",
          "    assert!(set.contains(StateID::new_unchecked(0))); // Verify presence of inserted IDs",
          "    assert!(set.contains(StateID::new_unchecked(1)));",
          "    assert!(set.contains(StateID::new_unchecked(2)));",
          "    assert!(set.contains(StateID::new_unchecked(3)));",
          "    assert!(set.contains(StateID::new_unchecked(4)));",
          "    let result = set.insert(id_at_capacity); // Expected return: false, since the capacity is reached",
          "    assert!(!result); // Validate that inserting above capacity returns false",
          "    assert!(set.len() == 5); // Ensure length hasn't changed after attempting to insert above capacity",
          "    assert!(set.capacity() == 5); // Check that capacity is still as initialized"
        ],
        "code": [
          "{",
          "    let mut set = SparseSet::new(5);",
          "    for i in 0..5 {",
          "        let state_id = StateID::new_unchecked(i);",
          "        set.insert(state_id);",
          "    }",
          "    let id_at_capacity = StateID::new_unchecked(5);",
          "    set.insert(id_at_capacity);",
          "    set.insert(state_id); // Expected return: true for each insertion until capacity",
          "    assert_eq!(set.len(), 5); // Verify length after insertion",
          "    assert!(set.contains(StateID::new_unchecked(0))); // Verify presence of inserted IDs",
          "    assert!(set.contains(StateID::new_unchecked(1)));",
          "    assert!(set.contains(StateID::new_unchecked(2)));",
          "    assert!(set.contains(StateID::new_unchecked(3)));",
          "    assert!(set.contains(StateID::new_unchecked(4)));",
          "    let result = set.insert(id_at_capacity); // Expected return: false, since the capacity is reached",
          "    assert!(!result); // Validate that inserting above capacity returns false",
          "    assert!(set.len() == 5); // Ensure length hasn't changed after attempting to insert above capacity",
          "    assert!(set.capacity() == 5); // Check that capacity is still as initialized",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]