[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 0, upper: 0 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "    ",
          "    let empty_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
          "    let _iter = empty_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.0.clone().count(), 0);",
          "    let single_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }]);",
          "    let single_iter = single_interval_set.iter();",
          "    assert_eq!(single_iter.0.clone().count(), 1);",
          "    assert_eq!(single_iter.0.clone().next(), Some(TestInterval { lower: 1, upper: 5 }));",
          "    let multiple_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 3 }, TestInterval { lower: 4, upper: 6 }]);",
          "    let multiple_iter = multiple_interval_set.iter();",
          "    assert_eq!(multiple_iter.0.clone().count(), 2);",
          "    assert_eq!(multiple_iter.0.clone().next(), Some(TestInterval { lower: 1, upper: 3 }));",
          "    assert_eq!(multiple_iter.0.clone().nth(1), Some(TestInterval { lower: 4, upper: 6 }));"
        ],
        "code": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 0, upper: 0 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "    ",
          "    let empty_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
          "    let _iter = empty_set.iter();",
          "    assert_eq!(_iter.0.clone().count(), 0);",
          "    let single_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }]);",
          "    let single_iter = single_interval_set.iter();",
          "    assert_eq!(single_iter.0.clone().count(), 1);",
          "    assert_eq!(single_iter.0.clone().next(), Some(TestInterval { lower: 1, upper: 5 }));",
          "    let multiple_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 3 }, TestInterval { lower: 4, upper: 6 }]);",
          "    let multiple_iter = multiple_interval_set.iter();",
          "    assert_eq!(multiple_iter.0.clone().count(), 2);",
          "    assert_eq!(multiple_iter.0.clone().next(), Some(TestInterval { lower: 1, upper: 3 }));",
          "    assert_eq!(multiple_iter.0.clone().nth(1), Some(TestInterval { lower: 4, upper: 6 }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 1, upper: 1 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "",
          "    let single_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 1 }]);",
          "    let _iter = single_interval_set.iter();",
          "}"
        ],
        "oracle": [
          "    let single_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 1 }]); assert_eq!(_iter.0.len(), 1); assert_eq!(_iter.0[0], TestInterval { lower: 1, upper: 1 }); let empty_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]); let _iter_empty = empty_interval_set.iter(); assert_eq!(_iter_empty.0.len(), 0); let multi_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }]); let _iter_multi = multi_interval_set.iter(); assert_eq!(_iter_multi.0.len(), 2); assert_eq!(_iter_multi.0[0], TestInterval { lower: 1, upper: 2 }); assert_eq!(_iter_multi.0[1], TestInterval { lower: 3, upper: 4 });"
        ],
        "code": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 1, upper: 1 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "",
          "    let single_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 1 }]);",
          "    let _iter = single_interval_set.iter();",
          "    let single_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 1 }]); assert_eq!(_iter.0.len(), 1); assert_eq!(_iter.0[0], TestInterval { lower: 1, upper: 1 }); let empty_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]); let _iter_empty = empty_interval_set.iter(); assert_eq!(_iter_empty.0.len(), 0); let multi_interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }]); let _iter_multi = multi_interval_set.iter(); assert_eq!(_iter_multi.0.len(), 2); assert_eq!(_iter_multi.0[0], TestInterval { lower: 1, upper: 2 }); assert_eq!(_iter_multi.0[1], TestInterval { lower: 3, upper: 4 });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 0, upper: 0 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "",
          "    let multiple_intervals_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
          "        TestInterval { lower: 1, upper: 2 },",
          "        TestInterval { lower: 3, upper: 4 },",
          "        TestInterval { lower: 5, upper: 6 },",
          "    ]);",
          "    let _iter = multiple_intervals_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.0.len(), 3);",
          "    assert_eq!(_iter.0[0], TestInterval { lower: 1, upper: 2 });",
          "    assert_eq!(_iter.0[1], TestInterval { lower: 3, upper: 4 });",
          "    assert_eq!(_iter.0[2], TestInterval { lower: 5, upper: 6 });"
        ],
        "code": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 0, upper: 0 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "",
          "    let multiple_intervals_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
          "        TestInterval { lower: 1, upper: 2 },",
          "        TestInterval { lower: 3, upper: 4 },",
          "        TestInterval { lower: 5, upper: 6 },",
          "    ]);",
          "    let _iter = multiple_intervals_set.iter();",
          "    assert_eq!(_iter.0.len(), 3);",
          "    assert_eq!(_iter.0[0], TestInterval { lower: 1, upper: 2 });",
          "    assert_eq!(_iter.0[1], TestInterval { lower: 3, upper: 4 });",
          "    assert_eq!(_iter.0[2], TestInterval { lower: 5, upper: 6 });",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 0, upper: 0 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "",
          "    let consecutive_intervals_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
          "        TestInterval { lower: 1, upper: 3 },",
          "        TestInterval { lower: 4, upper: 6 },",
          "        TestInterval { lower: 7, upper: 9 },",
          "    ]);",
          "    let _iter = consecutive_intervals_set.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_iter.0.len(), 3);",
          "    assert_eq!(_iter.0.next(), Some(&TestInterval { lower: 1, upper: 3 }));",
          "    assert_eq!(_iter.0.next(), Some(&TestInterval { lower: 4, upper: 6 }));",
          "    assert_eq!(_iter.0.next(), Some(&TestInterval { lower: 7, upper: 9 }));",
          "    assert_eq!(_iter.0.next(), None);"
        ],
        "code": [
          "{",
          "    struct TestInterval {",
          "        lower: u32,",
          "        upper: u32,",
          "    }",
          "",
          "    impl Clone for TestInterval {",
          "        fn clone(&self) -> Self {",
          "            Self { lower: self.lower, upper: self.upper }",
          "        }",
          "    }",
          "",
          "    impl Copy for TestInterval {}",
          "",
          "    impl Debug for TestInterval {",
          "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
          "            write!(f, \"[{}, {}]\", self.lower, self.upper)",
          "        }",
          "    }",
          "",
          "    impl Default for TestInterval {",
          "        fn default() -> Self {",
          "            Self { lower: 0, upper: 0 }",
          "        }",
          "    }",
          "",
          "    impl Eq for TestInterval {}",
          "    impl PartialEq for TestInterval {",
          "        fn eq(&self, other: &Self) -> bool {",
          "            self.lower == other.lower && self.upper == other.upper",
          "        }",
          "    }",
          "    impl PartialOrd for TestInterval {",
          "        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
          "            self.lower.partial_cmp(&other.lower)",
          "        }",
          "    }",
          "    impl Ord for TestInterval {",
          "        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
          "            self.lower.cmp(&other.lower)",
          "        }",
          "    }",
          "",
          "    let consecutive_intervals_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
          "        TestInterval { lower: 1, upper: 3 },",
          "        TestInterval { lower: 4, upper: 6 },",
          "        TestInterval { lower: 7, upper: 9 },",
          "    ]);",
          "    let _iter = consecutive_intervals_set.iter();",
          "    assert_eq!(_iter.0.len(), 3);",
          "    assert_eq!(_iter.0.next(), Some(&TestInterval { lower: 1, upper: 3 }));",
          "    assert_eq!(_iter.0.next(), Some(&TestInterval { lower: 4, upper: 6 }));",
          "    assert_eq!(_iter.0.next(), Some(&TestInterval { lower: 7, upper: 9 }));",
          "    assert_eq!(_iter.0.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]