[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { has_empty: true, is_utf8: false, is_always_start_anchored: false };",
          "    let special = Special { max: 0, quit_id: 1, min_match: 2, max_match: 3, min_accel: 4, max_accel: 5, min_start: 6, max_start: 7 };",
          "    let tt = Transitions { sparse: vec![], classes: ByteClasses::new(), state_len: 1, pattern_len: 0 };",
          "    let st = StartTable { table: vec![0; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(0), universal_start_unanchored: None, universal_start_anchored: None };",
          "    ",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes.len(), expected_length);",
          "    assert!(bytes[0..4].iter().all(|&b| b == expected_value));",
          "    assert!(bytes.contains(&expected_byte));",
          "    assert!(dfa.try_search_fwd(&Input::new(\"test_input\")).is_ok());",
          "    assert_eq!(dfa.pattern_len(), expected_pattern_length);",
          "    assert_eq!(dfa.match_len(1), expected_match_length);",
          "    assert!(dfa.is_dead_state(0));",
          "    assert!(dfa.is_special_state(1));",
          "    assert!(dfa.is_match_state(2));",
          "    assert!(dfa.is_start_state(6));",
          "    assert!(dfa.has_empty());",
          "    assert!(!dfa.is_utf8());",
          "    assert!(!dfa.is_always_start_anchored());"
        ],
        "code": [
          "{",
          "    let flags = Flags { has_empty: true, is_utf8: false, is_always_start_anchored: false };",
          "    let special = Special { max: 0, quit_id: 1, min_match: 2, max_match: 3, min_accel: 4, max_accel: 5, min_start: 6, max_start: 7 };",
          "    let tt = Transitions { sparse: vec![], classes: ByteClasses::new(), state_len: 1, pattern_len: 0 };",
          "    let st = StartTable { table: vec![0; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(0), universal_start_unanchored: None, universal_start_anchored: None };",
          "    ",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "    assert_eq!(bytes.len(), expected_length);",
          "    assert!(bytes[0..4].iter().all(|&b| b == expected_value));",
          "    assert!(bytes.contains(&expected_byte));",
          "    assert!(dfa.try_search_fwd(&Input::new(\"test_input\")).is_ok());",
          "    assert_eq!(dfa.pattern_len(), expected_pattern_length);",
          "    assert_eq!(dfa.match_len(1), expected_match_length);",
          "    assert!(dfa.is_dead_state(0));",
          "    assert!(dfa.is_special_state(1));",
          "    assert!(dfa.is_match_state(2));",
          "    assert!(dfa.is_start_state(6));",
          "    assert!(dfa.has_empty());",
          "    assert!(!dfa.is_utf8());",
          "    assert!(!dfa.is_always_start_anchored());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: true };",
          "    let special = Special { max: 3, quit_id: 4, min_match: 5, max_match: 6, min_accel: 7, max_accel: 8, min_start: 9, max_start: 10 };",
          "    let tt = Transitions { sparse: vec![1, 2, 3], classes: ByteClasses::new(), state_len: 4, pattern_len: 4 };",
          "    let st = StartTable { table: vec![0, 1, 2, 3, 4, 5, 6, 7], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(4), universal_start_unanchored: Some(1), universal_start_anchored: Some(2) };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes.len() > 0, true);",
          "    assert_eq!(bytes[0..4], dfa.write_to_len().to_le_bytes().as_slice());",
          "    assert_eq!(bytes[4..].len(), dfa.tt.pattern_len * size_of::<StateID>());",
          "    assert_eq!(dfa.tt.sparse, vec![1, 2, 3]);",
          "    assert_eq!(dfa.flags.is_utf8, true);",
          "    assert_eq!(dfa.special.max, 3);",
          "    assert_eq!(dfa.special.quit_id, 4);",
          "    assert_eq!(dfa.st.kind, StartKind::Both);",
          "    assert_eq!(dfa.pattern_len, 4);"
        ],
        "code": [
          "{",
          "    let flags = Flags { has_empty: false, is_utf8: true, is_always_start_anchored: true };",
          "    let special = Special { max: 3, quit_id: 4, min_match: 5, max_match: 6, min_accel: 7, max_accel: 8, min_start: 9, max_start: 10 };",
          "    let tt = Transitions { sparse: vec![1, 2, 3], classes: ByteClasses::new(), state_len: 4, pattern_len: 4 };",
          "    let st = StartTable { table: vec![0, 1, 2, 3, 4, 5, 6, 7], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(4), universal_start_unanchored: Some(1), universal_start_anchored: Some(2) };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "    assert_eq!(bytes.len() > 0, true);",
          "    assert_eq!(bytes[0..4], dfa.write_to_len().to_le_bytes().as_slice());",
          "    assert_eq!(bytes[4..].len(), dfa.tt.pattern_len * size_of::<StateID>());",
          "    assert_eq!(dfa.tt.sparse, vec![1, 2, 3]);",
          "    assert_eq!(dfa.flags.is_utf8, true);",
          "    assert_eq!(dfa.special.max, 3);",
          "    assert_eq!(dfa.special.quit_id, 4);",
          "    assert_eq!(dfa.st.kind, StartKind::Both);",
          "    assert_eq!(dfa.pattern_len, 4);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { has_empty: true, is_utf8: true, is_always_start_anchored: false };",
          "    let special = Special { max: 255, quit_id: 254, min_match: 0, max_match: 255, min_accel: 1, max_accel: 10, min_start: 2, max_start: 254 };",
          "    let tt = Transitions { sparse: vec![0; 256], classes: ByteClasses::new(), state_len: 256, pattern_len: 10 };",
          "    let st = StartTable { table: vec![1; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(10), universal_start_unanchored: Some(1), universal_start_anchored: Some(2) };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes.len(), expected_length);",
          "    assert!(bytes.iter().all(|&b| b >= 0));",
          "    assert!(bytes.iter().all(|&b| b <= 255));",
          "    assert!(dfa.try_search_fwd(&Input::new(\"foo12345\")).is_ok());",
          "    assert_eq!(dfa.tt.state_len, 256);",
          "    assert_eq!(dfa.pattern_len, 10);",
          "    assert_eq!(dfa.flags.is_utf8, true);",
          "    assert_eq!(dfa.special.quit_id, 254);",
          "    assert_eq!(dfa.st.pattern_len, Some(10));",
          "    assert_eq!(dfa.st.universal_start_unanchored, Some(1));",
          "    assert_eq!(dfa.st.universal_start_anchored, Some(2));"
        ],
        "code": [
          "{",
          "    let flags = Flags { has_empty: true, is_utf8: true, is_always_start_anchored: false };",
          "    let special = Special { max: 255, quit_id: 254, min_match: 0, max_match: 255, min_accel: 1, max_accel: 10, min_start: 2, max_start: 254 };",
          "    let tt = Transitions { sparse: vec![0; 256], classes: ByteClasses::new(), state_len: 256, pattern_len: 10 };",
          "    let st = StartTable { table: vec![1; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(10), universal_start_unanchored: Some(1), universal_start_anchored: Some(2) };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "    assert_eq!(bytes.len(), expected_length);",
          "    assert!(bytes.iter().all(|&b| b >= 0));",
          "    assert!(bytes.iter().all(|&b| b <= 255));",
          "    assert!(dfa.try_search_fwd(&Input::new(\"foo12345\")).is_ok());",
          "    assert_eq!(dfa.tt.state_len, 256);",
          "    assert_eq!(dfa.pattern_len, 10);",
          "    assert_eq!(dfa.flags.is_utf8, true);",
          "    assert_eq!(dfa.special.quit_id, 254);",
          "    assert_eq!(dfa.st.pattern_len, Some(10));",
          "    assert_eq!(dfa.st.universal_start_unanchored, Some(1));",
          "    assert_eq!(dfa.st.universal_start_anchored, Some(2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { has_empty: true, is_utf8: true, is_always_start_anchored: false };",
          "    let special = Special { max: 2, quit_id: 1, min_match: 0, max_match: 1, min_accel: 1, max_accel: 2, min_start: 0, max_start: 1 };",
          "    let tt = Transitions { sparse: vec![0, 1, 2], classes: ByteClasses::new(), state_len: 3, pattern_len: 0 };",
          "    let st = StartTable { table: vec![0; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "}"
        ],
        "oracle": [
          "    let flags = Flags { has_empty: true, is_utf8: true, is_always_start_anchored: false };",
          "    let special = Special { max: 2, quit_id: 1, min_match: 0, max_match: 1, min_accel: 1, max_accel: 2, min_start: 0, max_start: 1 };",
          "    let tt = Transitions { sparse: vec![0, 1, 2], classes: ByteClasses::new(), state_len: 3, pattern_len: 0 };",
          "    let st = StartTable { table: vec![0; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None };",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "    assert!(!bytes.is_empty());",
          "    assert_eq!(bytes.len() % size_of::<u8>(), 0);",
          "    assert!(dfa.from_bytes(&bytes).is_ok());",
          "    assert!(dfa.from_bytes_unchecked(&bytes).is_ok());"
        ],
        "code": [
          "{",
          "    let flags = Flags { has_empty: true, is_utf8: true, is_always_start_anchored: false };",
          "    let special = Special { max: 2, quit_id: 1, min_match: 0, max_match: 1, min_accel: 1, max_accel: 2, min_start: 0, max_start: 1 };",
          "    let tt = Transitions { sparse: vec![0, 1, 2], classes: ByteClasses::new(), state_len: 3, pattern_len: 0 };",
          "    let st = StartTable { table: vec![0; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "    let flags = Flags { has_empty: true, is_utf8: true, is_always_start_anchored: false };",
          "    let special = Special { max: 2, quit_id: 1, min_match: 0, max_match: 1, min_accel: 1, max_accel: 2, min_start: 0, max_start: 1 };",
          "    let tt = Transitions { sparse: vec![0, 1, 2], classes: ByteClasses::new(), state_len: 3, pattern_len: 0 };",
          "    let st = StartTable { table: vec![0; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: None, universal_start_unanchored: None, universal_start_anchored: None };",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "    assert!(!bytes.is_empty());",
          "    assert_eq!(bytes.len() % size_of::<u8>(), 0);",
          "    assert!(dfa.from_bytes(&bytes).is_ok());",
          "    assert!(dfa.from_bytes_unchecked(&bytes).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let flags = Flags { has_empty: false, is_utf8: false, is_always_start_anchored: true };",
          "    let special = Special { max: 6, quit_id: 5, min_match: 1, max_match: 2, min_accel: 0, max_accel: 10, min_start: 2, max_start: 4 };",
          "    let tt = Transitions { sparse: vec![4, 5, 6, 7], classes: ByteClasses::new(), state_len: 6, pattern_len: 5 };",
          "    let st = StartTable { table: vec![3; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(5), universal_start_unanchored: Some(3), universal_start_anchored: Some(4) };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(bytes.len() > 0, true);",
          "    assert_eq!(bytes[0..4], dfa.tt.sparse[0..4]);",
          "    assert_eq!(bytes[4..8], dfa.st.table[0..4]);",
          "    assert_eq!(bytes[8..12], dfa.special.min_match.to_le_bytes());",
          "    assert_eq!(bytes[12..16], dfa.special.max_match.to_le_bytes());",
          "    assert_eq!(bytes[16..20], dfa.flags.has_empty as u8.to_le_bytes());",
          "    assert_eq!(bytes[20..24], dfa.flags.is_utf8 as u8.to_le_bytes());",
          "    assert_eq!(bytes[24..28], dfa.flags.is_always_start_anchored as u8.to_le_bytes());",
          "    assert_eq!(bytes[28..32], dfa.quitset.bits.0);",
          "    assert_eq!(bytes[32..36], dfa.pre.is_fast as u8.to_le_bytes());",
          "    assert_eq!(bytes[36..40], dfa.pre.max_needle_len.to_le_bytes());",
          "    assert_eq!(bytes[40..44], dfa.special.quit_id.to_le_bytes());",
          "    assert_eq!(bytes[44..48], dfa.special.min_accel.to_le_bytes());",
          "    assert_eq!(bytes[48..52], dfa.special.max_accel.to_le_bytes());",
          "    assert_eq!(bytes[52..56], dfa.special.min_start.to_le_bytes());",
          "    assert_eq!(bytes[56..60], dfa.special.max_start.to_le_bytes());"
        ],
        "code": [
          "{",
          "    let flags = Flags { has_empty: false, is_utf8: false, is_always_start_anchored: true };",
          "    let special = Special { max: 6, quit_id: 5, min_match: 1, max_match: 2, min_accel: 0, max_accel: 10, min_start: 2, max_start: 4 };",
          "    let tt = Transitions { sparse: vec![4, 5, 6, 7], classes: ByteClasses::new(), state_len: 6, pattern_len: 5 };",
          "    let st = StartTable { table: vec![3; 8], kind: StartKind::Both, start_map: StartByteMap::new(), stride: 1, pattern_len: Some(5), universal_start_unanchored: Some(3), universal_start_anchored: Some(4) };",
          "",
          "    let dfa = DFA { tt, st, special, pre: None, quitset: ByteSet::new(), flags };",
          "    let bytes = dfa.to_bytes_little_endian();",
          "    assert_eq!(bytes.len() > 0, true);",
          "    assert_eq!(bytes[0..4], dfa.tt.sparse[0..4]);",
          "    assert_eq!(bytes[4..8], dfa.st.table[0..4]);",
          "    assert_eq!(bytes[8..12], dfa.special.min_match.to_le_bytes());",
          "    assert_eq!(bytes[12..16], dfa.special.max_match.to_le_bytes());",
          "    assert_eq!(bytes[16..20], dfa.flags.has_empty as u8.to_le_bytes());",
          "    assert_eq!(bytes[20..24], dfa.flags.is_utf8 as u8.to_le_bytes());",
          "    assert_eq!(bytes[24..28], dfa.flags.is_always_start_anchored as u8.to_le_bytes());",
          "    assert_eq!(bytes[28..32], dfa.quitset.bits.0);",
          "    assert_eq!(bytes[32..36], dfa.pre.is_fast as u8.to_le_bytes());",
          "    assert_eq!(bytes[36..40], dfa.pre.max_needle_len.to_le_bytes());",
          "    assert_eq!(bytes[40..44], dfa.special.quit_id.to_le_bytes());",
          "    assert_eq!(bytes[44..48], dfa.special.min_accel.to_le_bytes());",
          "    assert_eq!(bytes[48..52], dfa.special.max_accel.to_le_bytes());",
          "    assert_eq!(bytes[52..56], dfa.special.min_start.to_le_bytes());",
          "    assert_eq!(bytes[56..60], dfa.special.max_start.to_le_bytes());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]