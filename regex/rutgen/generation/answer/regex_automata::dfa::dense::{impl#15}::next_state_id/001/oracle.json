[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestTable {",
          "        table: Vec<u32>,",
          "        classes: ByteClasses,",
          "        stride2: usize,",
          "    }",
          "",
          "    let valid_stride2 = 3; // Example: power of 2, so stride of 8",
          "    let dfa = TestTable {",
          "        table: vec![0; 8], // Placeholder for actual size, must match stride",
          "        classes: ByteClasses([0; 256]),",
          "        stride2: valid_stride2,",
          "    };",
          "    ",
          "    let state_id_zero = StateID(0);",
          "    let next_id_zero = dfa.next_state_id(state_id_zero);",
          "    ",
          "    let state_id_max = StateID((1 << valid_stride2) - 1);",
          "    let next_id_max = dfa.next_state_id(state_id_max);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dfa.next_state_id(StateID(0)), StateID(1 << valid_stride2));",
          "    assert_eq!(dfa.next_state_id(StateID((1 << valid_stride2) - 1)), StateID::new_unchecked(0));"
        ],
        "code": [
          "{",
          "    struct TestTable {",
          "        table: Vec<u32>,",
          "        classes: ByteClasses,",
          "        stride2: usize,",
          "    }",
          "",
          "    let valid_stride2 = 3; // Example: power of 2, so stride of 8",
          "    let dfa = TestTable {",
          "        table: vec![0; 8], // Placeholder for actual size, must match stride",
          "        classes: ByteClasses([0; 256]),",
          "        stride2: valid_stride2,",
          "    };",
          "    ",
          "    let state_id_zero = StateID(0);",
          "    let next_id_zero = dfa.next_state_id(state_id_zero);",
          "    ",
          "    let state_id_max = StateID((1 << valid_stride2) - 1);",
          "    let next_id_max = dfa.next_state_id(state_id_max);",
          "    assert_eq!(dfa.next_state_id(StateID(0)), StateID(1 << valid_stride2));",
          "    assert_eq!(dfa.next_state_id(StateID((1 << valid_stride2) - 1)), StateID::new_unchecked(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestTable {",
          "        table: Vec<u32>,",
          "        classes: ByteClasses,",
          "        stride2: usize,",
          "    }",
          "",
          "    let valid_stride2 = 4; // Example: power of 2, so stride of 16",
          "    let dfa = TestTable {",
          "        table: vec![0; 16], // Placeholder for actual size, must match stride",
          "        classes: ByteClasses([0; 256]),",
          "        stride2: valid_stride2,",
          "    };",
          "",
          "    let state_id_boundary = StateID((1 << valid_stride2) - 1);",
          "    let next_id_boundary = dfa.next_state_id(state_id_boundary);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(next_id_boundary.as_usize(), (1 << valid_stride2));",
          "    assert!(dfa.is_valid(next_id_boundary) == false);",
          "    assert_eq!(dfa.to_index(state_id_boundary), ((1 << valid_stride2) - 1) >> valid_stride2);",
          "    assert!(dfa.to_index(next_id_boundary) > dfa.to_index(state_id_boundary));",
          "    assert_eq!(next_id_boundary, dfa.to_state_id(dfa.to_index(state_id_boundary) + 1));",
          "    assert!(dfa.memory_usage() > 0);"
        ],
        "code": [
          "{",
          "    struct TestTable {",
          "        table: Vec<u32>,",
          "        classes: ByteClasses,",
          "        stride2: usize,",
          "    }",
          "",
          "    let valid_stride2 = 4; // Example: power of 2, so stride of 16",
          "    let dfa = TestTable {",
          "        table: vec![0; 16], // Placeholder for actual size, must match stride",
          "        classes: ByteClasses([0; 256]),",
          "        stride2: valid_stride2,",
          "    };",
          "",
          "    let state_id_boundary = StateID((1 << valid_stride2) - 1);",
          "    let next_id_boundary = dfa.next_state_id(state_id_boundary);",
          "    assert_eq!(next_id_boundary.as_usize(), (1 << valid_stride2));",
          "    assert!(dfa.is_valid(next_id_boundary) == false);",
          "    assert_eq!(dfa.to_index(state_id_boundary), ((1 << valid_stride2) - 1) >> valid_stride2);",
          "    assert!(dfa.to_index(next_id_boundary) > dfa.to_index(state_id_boundary));",
          "    assert_eq!(next_id_boundary, dfa.to_state_id(dfa.to_index(state_id_boundary) + 1));",
          "    assert!(dfa.memory_usage() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]