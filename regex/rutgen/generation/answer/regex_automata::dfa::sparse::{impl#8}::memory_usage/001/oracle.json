[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse: Vec<u8> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transitions.memory_usage(), 0);",
          "    ",
          "    let sparse: Vec<u8> = vec![1, 2, 3];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "    sparse,",
          "    classes,",
          "    state_len: 1,",
          "    pattern_len: 0,",
          "    };",
          "    assert_eq!(transitions.memory_usage(), 3);",
          "    ",
          "    let sparse: Vec<u8> = vec![0; 100];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "    sparse,",
          "    classes,",
          "    state_len: 1,",
          "    pattern_len: 0,",
          "    };",
          "    assert_eq!(transitions.memory_usage(), 100);",
          "    ",
          "    let sparse: Vec<u8> = vec![4, 5, 6, 7, 8];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "    sparse,",
          "    classes,",
          "    state_len: 2,",
          "    pattern_len: 1,",
          "    };",
          "    assert_eq!(transitions.memory_usage(), 5);"
        ],
        "code": [
          "{",
          "    let sparse: Vec<u8> = vec![];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "    assert_eq!(transitions.memory_usage(), 0);",
          "    ",
          "    let sparse: Vec<u8> = vec![1, 2, 3];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "    sparse,",
          "    classes,",
          "    state_len: 1,",
          "    pattern_len: 0,",
          "    };",
          "    assert_eq!(transitions.memory_usage(), 3);",
          "    ",
          "    let sparse: Vec<u8> = vec![0; 100];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "    sparse,",
          "    classes,",
          "    state_len: 1,",
          "    pattern_len: 0,",
          "    };",
          "    assert_eq!(transitions.memory_usage(), 100);",
          "    ",
          "    let sparse: Vec<u8> = vec![4, 5, 6, 7, 8];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "    sparse,",
          "    classes,",
          "    state_len: 2,",
          "    pattern_len: 1,",
          "    };",
          "    assert_eq!(transitions.memory_usage(), 5);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse: Vec<u8> = vec![0];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transitions.memory_usage(), 1);"
        ],
        "code": [
          "{",
          "    let sparse: Vec<u8> = vec![0];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "    assert_eq!(transitions.memory_usage(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse: Vec<u8> = vec![0, 1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "}"
        ],
        "oracle": [
          "    let sparse: Vec<u8> = vec![0, 1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions { sparse, classes, state_len: 1, pattern_len: 0 };",
          "    assert_eq!(transitions.memory_usage(), 2);"
        ],
        "code": [
          "{",
          "    let sparse: Vec<u8> = vec![0, 1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "    let sparse: Vec<u8> = vec![0, 1];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions { sparse, classes, state_len: 1, pattern_len: 0 };",
          "    assert_eq!(transitions.memory_usage(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse: Vec<u8> = (0..256).map(|x| x as u8).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transitions.memory_usage(), 256);"
        ],
        "code": [
          "{",
          "    let sparse: Vec<u8> = (0..256).map(|x| x as u8).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 0,",
          "    };",
          "    transitions.memory_usage();",
          "    assert_eq!(transitions.memory_usage(), 256);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse: Vec<u8> = (0..1000).map(|x| (x % 256) as u8).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1000,",
          "        pattern_len: 10,",
          "    };",
          "    transitions.memory_usage();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transitions.memory_usage(), 1000);"
        ],
        "code": [
          "{",
          "    let sparse: Vec<u8> = (0..1000).map(|x| (x % 256) as u8).collect();",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = Transitions {",
          "        sparse,",
          "        classes,",
          "        state_len: 1000,",
          "        pattern_len: 10,",
          "    };",
          "    transitions.memory_usage();",
          "    assert_eq!(transitions.memory_usage(), 1000);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]