[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let transitions = vec![LazyStateID(0), LazyStateID(2), LazyStateID(4)];",
          "    let dfa = DFA {",
          "        config: Default::default(),",
          "        nfa: Default::default(),",
          "        stride2: 1,",
          "        start_map: Default::default(),",
          "        classes: Default::default(),",
          "        quitset: Default::default(),",
          "        cache_capacity: 0,",
          "    };",
          "    let cache = Cache {",
          "        trans: transitions.clone(),",
          "        starts: Default::default(),",
          "        states: Default::default(),",
          "        states_to_id: Default::default(),",
          "        sparses: Default::default(),",
          "        stack: Default::default(),",
          "        scratch_state_builder: Default::default(),",
          "        state_saver: Default::default(),",
          "        memory_usage_state: 0,",
          "        clear_count: 0,",
          "        bytes_searched: 0,",
          "        progress: Default::default(),",
          "    };",
          "",
          "    let lazy_ref = LazyRef {",
          "        dfa: &dfa,",
          "        cache: &cache,",
          "    };",
          "",
          "    let id = LazyStateID::new_unchecked(0); // Valid index and multiple of stride",
          "    lazy_ref.is_valid(id);",
          "}"
        ],
        "oracle": [
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(0)); // Expect: true (valid index, multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(2)); // Expect: true (valid index, multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(4)); // Expect: true (valid index, multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(1)); // Expect: false (valid index, not a multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(3)); // Expect: false (valid index, not a multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(5)); // Expect: false (invalid index, exceeds cache length)"
        ],
        "code": [
          "{",
          "    let transitions = vec![LazyStateID(0), LazyStateID(2), LazyStateID(4)];",
          "    let dfa = DFA {",
          "        config: Default::default(),",
          "        nfa: Default::default(),",
          "        stride2: 1,",
          "        start_map: Default::default(),",
          "        classes: Default::default(),",
          "        quitset: Default::default(),",
          "        cache_capacity: 0,",
          "    };",
          "    let cache = Cache {",
          "        trans: transitions.clone(),",
          "        starts: Default::default(),",
          "        states: Default::default(),",
          "        states_to_id: Default::default(),",
          "        sparses: Default::default(),",
          "        stack: Default::default(),",
          "        scratch_state_builder: Default::default(),",
          "        state_saver: Default::default(),",
          "        memory_usage_state: 0,",
          "        clear_count: 0,",
          "        bytes_searched: 0,",
          "        progress: Default::default(),",
          "    };",
          "",
          "    let lazy_ref = LazyRef {",
          "        dfa: &dfa,",
          "        cache: &cache,",
          "    };",
          "",
          "    let id = LazyStateID::new_unchecked(0); // Valid index and multiple of stride",
          "    lazy_ref.is_valid(id);",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(0)); // Expect: true (valid index, multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(2)); // Expect: true (valid index, multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(4)); // Expect: true (valid index, multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(1)); // Expect: false (valid index, not a multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(3)); // Expect: false (valid index, not a multiple of stride)",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(5)); // Expect: false (invalid index, exceeds cache length)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let transitions = vec![LazyStateID(0), LazyStateID(1), LazyStateID(2), LazyStateID(3), LazyStateID(4)];",
          "    let dfa = DFA {",
          "        config: Default::default(),",
          "        nfa: Default::default(),",
          "        stride2: 2,",
          "        start_map: Default::default(),",
          "        classes: Default::default(),",
          "        quitset: Default::default(),",
          "        cache_capacity: 0,",
          "    };",
          "    let cache = Cache {",
          "        trans: transitions.clone(),",
          "        starts: Default::default(),",
          "        states: Default::default(),",
          "        states_to_id: Default::default(),",
          "        sparses: Default::default(),",
          "        stack: Default::default(),",
          "        scratch_state_builder: Default::default(),",
          "        state_saver: Default::default(),",
          "        memory_usage_state: 0,",
          "        clear_count: 0,",
          "        bytes_searched: 0,",
          "        progress: Default::default(),",
          "    };",
          "",
          "    let lazy_ref = LazyRef {",
          "        dfa: &dfa,",
          "        cache: &cache,",
          "    };",
          "",
          "    let id = LazyStateID::new_unchecked(4); // Valid index and multiple of stride",
          "    lazy_ref.is_valid(id);",
          "}"
        ],
        "oracle": [
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(0)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(2)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(4)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(1)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(3)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(5)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(6)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(8)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(7)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(10)).is_true());"
        ],
        "code": [
          "{",
          "    let transitions = vec![LazyStateID(0), LazyStateID(1), LazyStateID(2), LazyStateID(3), LazyStateID(4)];",
          "    let dfa = DFA {",
          "        config: Default::default(),",
          "        nfa: Default::default(),",
          "        stride2: 2,",
          "        start_map: Default::default(),",
          "        classes: Default::default(),",
          "        quitset: Default::default(),",
          "        cache_capacity: 0,",
          "    };",
          "    let cache = Cache {",
          "        trans: transitions.clone(),",
          "        starts: Default::default(),",
          "        states: Default::default(),",
          "        states_to_id: Default::default(),",
          "        sparses: Default::default(),",
          "        stack: Default::default(),",
          "        scratch_state_builder: Default::default(),",
          "        state_saver: Default::default(),",
          "        memory_usage_state: 0,",
          "        clear_count: 0,",
          "        bytes_searched: 0,",
          "        progress: Default::default(),",
          "    };",
          "",
          "    let lazy_ref = LazyRef {",
          "        dfa: &dfa,",
          "        cache: &cache,",
          "    };",
          "",
          "    let id = LazyStateID::new_unchecked(4); // Valid index and multiple of stride",
          "    lazy_ref.is_valid(id);",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(0)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(2)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(4)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(1)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(3)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(5)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(6)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(8)).is_true());",
          "    assert!(!lazy_ref.is_valid(LazyStateID::new_unchecked(7)).is_true());",
          "    assert!(lazy_ref.is_valid(LazyStateID::new_unchecked(10)).is_true());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let transitions = vec![LazyStateID(0), LazyStateID(1), LazyStateID(2)];",
          "    let dfa = DFA {",
          "        config: Default::default(),",
          "        nfa: Default::default(),",
          "        stride2: 1,",
          "        start_map: Default::default(),",
          "        classes: Default::default(),",
          "        quitset: Default::default(),",
          "        cache_capacity: 0,",
          "    };",
          "    let cache = Cache {",
          "        trans: transitions.clone(),",
          "        starts: Default::default(),",
          "        states: Default::default(),",
          "        states_to_id: Default::default(),",
          "        sparses: Default::default(),",
          "        stack: Default::default(),",
          "        scratch_state_builder: Default::default(),",
          "        state_saver: Default::default(),",
          "        memory_usage_state: 0,",
          "        clear_count: 0,",
          "        bytes_searched: 0,",
          "        progress: Default::default(),",
          "    };",
          "",
          "    let lazy_ref = LazyRef {",
          "        dfa: &dfa,",
          "        cache: &cache,",
          "    };",
          "",
          "    let id = LazyStateID::new_unchecked(2); // Valid index and multiple of stride",
          "    lazy_ref.is_valid(id);",
          "}"
        ],
        "oracle": [
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(2)); // valid index and multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(4)); // valid index and multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(0)); // valid index and multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(1)); // valid index but not a multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(3)); // invalid index, not multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(5)); // invalid index, not multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(6)); // valid index and multiple of stride if stride == 2",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(7)); // invalid index, not a multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(8)); // invalid index if > cache.trans.len()",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(10)); // valid index and multiple of stride if stride == 2"
        ],
        "code": [
          "{",
          "    let transitions = vec![LazyStateID(0), LazyStateID(1), LazyStateID(2)];",
          "    let dfa = DFA {",
          "        config: Default::default(),",
          "        nfa: Default::default(),",
          "        stride2: 1,",
          "        start_map: Default::default(),",
          "        classes: Default::default(),",
          "        quitset: Default::default(),",
          "        cache_capacity: 0,",
          "    };",
          "    let cache = Cache {",
          "        trans: transitions.clone(),",
          "        starts: Default::default(),",
          "        states: Default::default(),",
          "        states_to_id: Default::default(),",
          "        sparses: Default::default(),",
          "        stack: Default::default(),",
          "        scratch_state_builder: Default::default(),",
          "        state_saver: Default::default(),",
          "        memory_usage_state: 0,",
          "        clear_count: 0,",
          "        bytes_searched: 0,",
          "        progress: Default::default(),",
          "    };",
          "",
          "    let lazy_ref = LazyRef {",
          "        dfa: &dfa,",
          "        cache: &cache,",
          "    };",
          "",
          "    let id = LazyStateID::new_unchecked(2); // Valid index and multiple of stride",
          "    lazy_ref.is_valid(id);",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(2)); // valid index and multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(4)); // valid index and multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(0)); // valid index and multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(1)); // valid index but not a multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(3)); // invalid index, not multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(5)); // invalid index, not multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(6)); // valid index and multiple of stride if stride == 2",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(7)); // invalid index, not a multiple of stride",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(8)); // invalid index if > cache.trans.len()",
          "    lazy_ref.is_valid(LazyStateID::new_unchecked(10)); // valid index and multiple of stride if stride == 2",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]