[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_ranges: &[u8] = &[];",
          "    let next: &[u8] = &[];",
          "    let pattern_ids: &[u8] = &[];",
          "    let accel: &[u8] = &[];",
          "",
          "    let state = State {",
          "        id: StateID::default(),",
          "        is_match: true,",
          "        ntrans: 0,",
          "        input_ranges,",
          "        next,",
          "        pattern_ids,",
          "        accel,",
          "    };",
          "",
          "    let nwrite = state.write_to_len();",
          "    let mut dst = vec![0; nwrite];",
          "",
          "    let result = state.write_to::<wire::LittleEndian>(&mut dst);",
          "}"
        ],
        "oracle": [
          "    result.unwrap();",
          "    assert_eq!(dst.len(), nwrite);",
          "    assert_eq!(dst[0], 1 << 15);",
          "    assert_eq!(dst[1..].len(), 0);",
          "    assert!(dst[1..].is_empty());",
          "    assert_eq!(state.next_at(0).as_u32(), DEAD.as_u32());",
          "    assert_eq!(state.pattern_len(), 0);",
          "    assert!(state.accelerator().is_empty());",
          "    assert_eq!(result, Ok(nwrite));"
        ],
        "code": [
          "{",
          "    let input_ranges: &[u8] = &[];",
          "    let next: &[u8] = &[];",
          "    let pattern_ids: &[u8] = &[];",
          "    let accel: &[u8] = &[];",
          "",
          "    let state = State {",
          "        id: StateID::default(),",
          "        is_match: true,",
          "        ntrans: 0,",
          "        input_ranges,",
          "        next,",
          "        pattern_ids,",
          "        accel,",
          "    };",
          "",
          "    let nwrite = state.write_to_len();",
          "    let mut dst = vec![0; nwrite];",
          "",
          "    let result = state.write_to::<wire::LittleEndian>(&mut dst);",
          "    result.unwrap();",
          "    assert_eq!(dst.len(), nwrite);",
          "    assert_eq!(dst[0], 1 << 15);",
          "    assert_eq!(dst[1..].len(), 0);",
          "    assert!(dst[1..].is_empty());",
          "    assert_eq!(state.next_at(0).as_u32(), DEAD.as_u32());",
          "    assert_eq!(state.pattern_len(), 0);",
          "    assert!(state.accelerator().is_empty());",
          "    assert_eq!(result, Ok(nwrite));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_ranges: &[u8] = &[];",
          "    let next: &[u8] = &[];",
          "    let pattern_ids: &[u8] = &[];",
          "    let accel: &[u8] = &[];",
          "",
          "    let state = State {",
          "        id: StateID::default(),",
          "        is_match: false,",
          "        ntrans: 0,",
          "        input_ranges,",
          "        next,",
          "        pattern_ids,",
          "        accel,",
          "    };",
          "",
          "    let nwrite = state.write_to_len();",
          "    let mut dst = vec![0; nwrite];",
          "",
          "    let result = state.write_to::<wire::LittleEndian>(&mut dst);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Ok(nwrite));",
          "    assert!(dst.len() >= nwrite);",
          "    assert_eq!(state.is_match, false);",
          "    assert_eq!(state.ntrans, 0);",
          "    assert!(dst[0] == 0);",
          "    assert_eq!(dst[1..].to_vec(), accel.to_vec());",
          "    assert_eq!(dst[1 + accel.len()..].len(), 0);"
        ],
        "code": [
          "{",
          "    let input_ranges: &[u8] = &[];",
          "    let next: &[u8] = &[];",
          "    let pattern_ids: &[u8] = &[];",
          "    let accel: &[u8] = &[];",
          "",
          "    let state = State {",
          "        id: StateID::default(),",
          "        is_match: false,",
          "        ntrans: 0,",
          "        input_ranges,",
          "        next,",
          "        pattern_ids,",
          "        accel,",
          "    };",
          "",
          "    let nwrite = state.write_to_len();",
          "    let mut dst = vec![0; nwrite];",
          "",
          "    let result = state.write_to::<wire::LittleEndian>(&mut dst);",
          "    assert_eq!(result, Ok(nwrite));",
          "    assert!(dst.len() >= nwrite);",
          "    assert_eq!(state.is_match, false);",
          "    assert_eq!(state.ntrans, 0);",
          "    assert!(dst[0] == 0);",
          "    assert_eq!(dst[1..].to_vec(), accel.to_vec());",
          "    assert_eq!(dst[1 + accel.len()..].len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]