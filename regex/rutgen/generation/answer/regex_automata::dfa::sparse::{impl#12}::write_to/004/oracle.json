[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = vec![0u8; 64];",
          "    let table = StartTable {",
          "        table: vec![0u8; 32],",
          "        kind: StartKind::Both,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 4,",
          "        pattern_len: Some(1),",
          "        universal_start_unanchored: Some(StateID(0)),",
          "        universal_start_anchored: Some(StateID(1)),",
          "    };",
          "    let _ = table.write_to::<EndianType>(&mut dst).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst.len(), 64);",
          "    assert_eq!(table.pattern_len.unwrap(), 1);",
          "    assert!(table.universal_start_unanchored.is_some());",
          "    assert!(table.universal_start_anchored.is_some());",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert!(result.is_ok());",
          "    let _ = result.unwrap();",
          "    assert_eq!(result.unwrap(), 64);",
          "    assert!(table.iter().count() > 0);",
          "    assert!(table.iter().next().is_some());",
          "    dst.iter().all(|&x| x == 0);"
        ],
        "code": [
          "{",
          "    let mut dst = vec![0u8; 64];",
          "    let table = StartTable {",
          "        table: vec![0u8; 32],",
          "        kind: StartKind::Both,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 4,",
          "        pattern_len: Some(1),",
          "        universal_start_unanchored: Some(StateID(0)),",
          "        universal_start_anchored: Some(StateID(1)),",
          "    };",
          "    let _ = table.write_to::<EndianType>(&mut dst).unwrap();",
          "    assert_eq!(dst.len(), 64);",
          "    assert_eq!(table.pattern_len.unwrap(), 1);",
          "    assert!(table.universal_start_unanchored.is_some());",
          "    assert!(table.universal_start_anchored.is_some());",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert!(result.is_ok());",
          "    let _ = result.unwrap();",
          "    assert_eq!(result.unwrap(), 64);",
          "    assert!(table.iter().count() > 0);",
          "    assert!(table.iter().next().is_some());",
          "    dst.iter().all(|&x| x == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = vec![0u8; 60];",
          "    let table = StartTable {",
          "        table: vec![0u8; 32],",
          "        kind: StartKind::Unanchored,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 4,",
          "        pattern_len: Some(0),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "    let nwrite = table.write_to::<EndianType>(&mut dst).unwrap();",
          "    assert_eq!(dst.len(), nwrite);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(dst.len(), 60);",
          "    assert!(nwrite <= dst.len());",
          "    assert!(table.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert_eq!(table.kind.write_to::<EndianType>(&mut dst).unwrap(), 8);",
          "    assert_eq!(table.start_map.write_to(&mut dst).unwrap(), 256);",
          "    assert!(table.iter().next().is_some());",
          "    assert!(table.iter().next().is_none());",
          "    assert_eq!(nwrite, 60);",
          "    assert!(table.write_to::<EndianType>(&mut dst).unwrap() == Ok(nwrite));"
        ],
        "code": [
          "{",
          "    let mut dst = vec![0u8; 60];",
          "    let table = StartTable {",
          "        table: vec![0u8; 32],",
          "        kind: StartKind::Unanchored,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 4,",
          "        pattern_len: Some(0),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "    let nwrite = table.write_to::<EndianType>(&mut dst).unwrap();",
          "    assert_eq!(dst.len(), nwrite);",
          "    assert_eq!(dst.len(), 60);",
          "    assert!(nwrite <= dst.len());",
          "    assert!(table.write_to::<EndianType>(&mut dst).is_ok());",
          "    assert_eq!(table.kind.write_to::<EndianType>(&mut dst).unwrap(), 8);",
          "    assert_eq!(table.start_map.write_to(&mut dst).unwrap(), 256);",
          "    assert!(table.iter().next().is_some());",
          "    assert!(table.iter().next().is_none());",
          "    assert_eq!(nwrite, 60);",
          "    assert!(table.write_to::<EndianType>(&mut dst).unwrap() == Ok(nwrite));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut dst = vec![0u8; 10];",
          "    let table = StartTable {",
          "        table: vec![0u8; 40],",
          "        kind: StartKind::Anchored,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 8,",
          "        pattern_len: Some(2),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: Some(StateID(2)),",
          "    };",
          "    let _ = table.write_to::<EndianType>(&mut dst).unwrap();",
          "}"
        ],
        "oracle": [
          "    let mut dst = vec![0u8; 40];",
          "    let table = StartTable {",
          "    table: vec![0u8; 40],",
          "    kind: StartKind::Both,",
          "    start_map: StartByteMap::new(&LookMatcher::default()),",
          "    stride: 8,",
          "    pattern_len: Some(2),",
          "    universal_start_unanchored: Some(StateID(1)),",
          "    universal_start_anchored: Some(StateID(2)),",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(40));",
          "    ",
          "    let mut dst = vec![0u8; 40];",
          "    let table = StartTable {",
          "    table: vec![0u8; 40],",
          "    kind: StartKind::Anchored,",
          "    start_map: StartByteMap::new(&LookMatcher::default()),",
          "    stride: 8,",
          "    pattern_len: Some(2),",
          "    universal_start_unanchored: None,",
          "    universal_start_anchored: None,",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(40));",
          "    ",
          "    let mut dst = vec![0u8; 40];",
          "    let table = StartTable {",
          "    table: vec![0u8; 40],",
          "    kind: StartKind::Unanchored,",
          "    start_map: StartByteMap::new(&LookMatcher::default()),",
          "    stride: 8,",
          "    pattern_len: Some(2),",
          "    universal_start_unanchored: Some(StateID(3)),",
          "    universal_start_anchored: None,",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(40));"
        ],
        "code": [
          "{",
          "    let mut dst = vec![0u8; 10];",
          "    let table = StartTable {",
          "        table: vec![0u8; 40],",
          "        kind: StartKind::Anchored,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 8,",
          "        pattern_len: Some(2),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: Some(StateID(2)),",
          "    };",
          "    let _ = table.write_to::<EndianType>(&mut dst).unwrap();",
          "    let mut dst = vec![0u8; 40];",
          "    let table = StartTable {",
          "    table: vec![0u8; 40],",
          "    kind: StartKind::Both,",
          "    start_map: StartByteMap::new(&LookMatcher::default()),",
          "    stride: 8,",
          "    pattern_len: Some(2),",
          "    universal_start_unanchored: Some(StateID(1)),",
          "    universal_start_anchored: Some(StateID(2)),",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(40));",
          "    ",
          "    let mut dst = vec![0u8; 40];",
          "    let table = StartTable {",
          "    table: vec![0u8; 40],",
          "    kind: StartKind::Anchored,",
          "    start_map: StartByteMap::new(&LookMatcher::default()),",
          "    stride: 8,",
          "    pattern_len: Some(2),",
          "    universal_start_unanchored: None,",
          "    universal_start_anchored: None,",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(40));",
          "    ",
          "    let mut dst = vec![0u8; 40];",
          "    let table = StartTable {",
          "    table: vec![0u8; 40],",
          "    kind: StartKind::Unanchored,",
          "    start_map: StartByteMap::new(&LookMatcher::default()),",
          "    stride: 8,",
          "    pattern_len: Some(2),",
          "    universal_start_unanchored: Some(StateID(3)),",
          "    universal_start_anchored: None,",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst);",
          "    assert_eq!(result, Ok(40));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut dst = vec![0u8; 64];",
          "    let table = StartTable {",
          "        table: vec![0u8; 32],",
          "        kind: StartKind::Both,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 0,",
          "        pattern_len: None,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst).unwrap();",
          "    assert_eq!(result, table.write_to_len());",
          "}"
        ],
        "oracle": [
          "    assert!(dst.len() == table.write_to_len());",
          "    let written_start_kind = table.kind.write_to::<EndianType>(&mut dst).unwrap();",
          "    assert!(written_start_kind > 0);",
          "    let written_start_map = table.start_map.write_to(&mut dst).unwrap();",
          "    assert!(written_start_map > 0);",
          "    for (sid, _, _) in table.iter() {",
          "    assert_eq!(E::write_u32(sid.as_u32(), &mut dst), Ok(StateID::SIZE));",
          "    }",
          "    let empty_iter_result = table.iter().next();",
          "    assert!(empty_iter_result.is_none());",
          "    assert_eq!(result, Ok(table.write_to_len()));"
        ],
        "code": [
          "{",
          "    let mut dst = vec![0u8; 64];",
          "    let table = StartTable {",
          "        table: vec![0u8; 32],",
          "        kind: StartKind::Both,",
          "        start_map: StartByteMap::new(&LookMatcher::default()),",
          "        stride: 0,",
          "        pattern_len: None,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "    let result = table.write_to::<EndianType>(&mut dst).unwrap();",
          "    assert_eq!(result, table.write_to_len());",
          "    assert!(dst.len() == table.write_to_len());",
          "    let written_start_kind = table.kind.write_to::<EndianType>(&mut dst).unwrap();",
          "    assert!(written_start_kind > 0);",
          "    let written_start_map = table.start_map.write_to(&mut dst).unwrap();",
          "    assert!(written_start_map > 0);",
          "    for (sid, _, _) in table.iter() {",
          "    assert_eq!(E::write_u32(sid.as_u32(), &mut dst), Ok(StateID::SIZE));",
          "    }",
          "    let empty_iter_result = table.iter().next();",
          "    assert!(empty_iter_result.is_none());",
          "    assert_eq!(result, Ok(table.write_to_len()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]