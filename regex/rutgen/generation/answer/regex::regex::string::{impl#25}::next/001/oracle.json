[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockGroupInfoPatternNames;",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            None",
          "        }",
          "    }",
          "    ",
          "    let captures = MockGroupInfoPatternNames;",
          "    let mut capture_names = CaptureNames(captures);",
          "    let _ = capture_names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(capture_names.next(), None);",
          "    assert_eq!(capture_names.next(), None);",
          "    let mock_capture_names = CaptureNames(MockGroupInfoPatternNames);",
          "    assert!(mock_capture_names.next().is_none());",
          "    let mut capture_names_iterator = CaptureNames(captures);",
          "    assert!(capture_names_iterator.next().is_none());",
          "    assert!(capture_names_iterator.next().is_none());"
        ],
        "code": [
          "{",
          "    struct MockGroupInfoPatternNames;",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            None",
          "        }",
          "    }",
          "    ",
          "    let captures = MockGroupInfoPatternNames;",
          "    let mut capture_names = CaptureNames(captures);",
          "    let _ = capture_names.next();",
          "    assert_eq!(capture_names.next(), None);",
          "    assert_eq!(capture_names.next(), None);",
          "    let mock_capture_names = CaptureNames(MockGroupInfoPatternNames);",
          "    assert!(mock_capture_names.next().is_none());",
          "    let mut capture_names_iterator = CaptureNames(captures);",
          "    assert!(capture_names_iterator.next().is_none());",
          "    assert!(capture_names_iterator.next().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockGroupInfoPatternNames {",
          "        called: bool,",
          "    }",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            if !self.called {",
          "                self.called = true;",
          "                Some(Some(\"capture1\"))",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "    ",
          "    let mut captures = MockGroupInfoPatternNames { called: false };",
          "    let mut capture_names = CaptureNames(captures);",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(capture_names.next(), Some(Some(\"capture1\")));",
          "    assert_eq!(capture_names.next(), None);"
        ],
        "code": [
          "{",
          "    struct MockGroupInfoPatternNames {",
          "        called: bool,",
          "    }",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            if !self.called {",
          "                self.called = true;",
          "                Some(Some(\"capture1\"))",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "    ",
          "    let mut captures = MockGroupInfoPatternNames { called: false };",
          "    let mut capture_names = CaptureNames(captures);",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture1\")));",
          "    assert_eq!(capture_names.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockGroupInfoPatternNames {",
          "        count: usize,",
          "    }",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            if self.count < 3 {",
          "                self.count += 1;",
          "                Some(Some(&format!(\"capture{}\", self.count)))",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "    ",
          "    let mut captures = MockGroupInfoPatternNames { count: 0 };",
          "    let mut capture_names = CaptureNames(captures);",
          "    ",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(capture_names.next(), Some(Some(\"capture1\")));",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture2\")));",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture3\")));",
          "    assert_eq!(capture_names.next(), None);"
        ],
        "code": [
          "{",
          "    struct MockGroupInfoPatternNames {",
          "        count: usize,",
          "    }",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            if self.count < 3 {",
          "                self.count += 1;",
          "                Some(Some(&format!(\"capture{}\", self.count)))",
          "            } else {",
          "                None",
          "            }",
          "        }",
          "    }",
          "    ",
          "    let mut captures = MockGroupInfoPatternNames { count: 0 };",
          "    let mut capture_names = CaptureNames(captures);",
          "    ",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture1\")));",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture2\")));",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture3\")));",
          "    assert_eq!(capture_names.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockGroupInfoPatternNames {",
          "        state: usize,",
          "    }",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            match self.state {",
          "                0 => {",
          "                    self.state += 1;",
          "                    Some(Some(\"capture1\"))",
          "                },",
          "                1 => {",
          "                    self.state += 1;",
          "                    Some(None)",
          "                },",
          "                2 => {",
          "                    self.state += 1;",
          "                    Some(Some(\"capture3\"))",
          "                },",
          "                _ => None,",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut captures = MockGroupInfoPatternNames { state: 0 };",
          "    let mut capture_names = CaptureNames(captures);",
          "    ",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(capture_names.next(), Some(Some(\"capture1\")));",
          "    assert_eq!(capture_names.next(), Some(None));",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture3\")));",
          "    assert_eq!(capture_names.next(), None);"
        ],
        "code": [
          "{",
          "    struct MockGroupInfoPatternNames {",
          "        state: usize,",
          "    }",
          "    impl Iterator for MockGroupInfoPatternNames {",
          "        type Item = Option<&'static str>;",
          "        fn next(&mut self) -> Option<Option<&'static str>> {",
          "            match self.state {",
          "                0 => {",
          "                    self.state += 1;",
          "                    Some(Some(\"capture1\"))",
          "                },",
          "                1 => {",
          "                    self.state += 1;",
          "                    Some(None)",
          "                },",
          "                2 => {",
          "                    self.state += 1;",
          "                    Some(Some(\"capture3\"))",
          "                },",
          "                _ => None,",
          "            }",
          "        }",
          "    }",
          "",
          "    let mut captures = MockGroupInfoPatternNames { state: 0 };",
          "    let mut capture_names = CaptureNames(captures);",
          "    ",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    let _ = capture_names.next();",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture1\")));",
          "    assert_eq!(capture_names.next(), Some(None));",
          "    assert_eq!(capture_names.next(), Some(Some(\"capture3\")));",
          "    assert_eq!(capture_names.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]