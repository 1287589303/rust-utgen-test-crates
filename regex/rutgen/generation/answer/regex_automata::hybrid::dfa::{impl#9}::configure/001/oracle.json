[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::Literal),",
          "        pre: Some(Some(Prefilter::Simple)),",
          "        starts_for_each_pattern: Some(true),",
          "        byte_classes: Some(true),",
          "        unicode_word_boundary: Some(true),",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: Some(true),",
          "        cache_capacity: Some(1024),",
          "        skip_cache_capacity_check: Some(true),",
          "        minimum_cache_clear_count: Some(Some(100)),",
          "        minimum_bytes_per_state: Some(Some(1000)),",
          "    };",
          "    builder.configure(config);",
          "}"
        ],
        "oracle": [
          "    let mut builder = Builder::new();",
          "    let config = Config {",
          "    match_kind: Some(MatchKind::Literal),",
          "    pre: Some(Some(Prefilter::Simple)),",
          "    starts_for_each_pattern: Some(true),",
          "    byte_classes: Some(true),",
          "    unicode_word_boundary: Some(true),",
          "    quitset: Some(ByteSet::empty()),",
          "    specialize_start_states: Some(true),",
          "    cache_capacity: Some(1024),",
          "    skip_cache_capacity_check: Some(true),",
          "    minimum_cache_clear_count: Some(Some(100)),",
          "    minimum_bytes_per_state: Some(Some(1000)),",
          "    };",
          "    let result = builder.configure(config);",
          "    assert_eq!(result, &builder);"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::Literal),",
          "        pre: Some(Some(Prefilter::Simple)),",
          "        starts_for_each_pattern: Some(true),",
          "        byte_classes: Some(true),",
          "        unicode_word_boundary: Some(true),",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: Some(true),",
          "        cache_capacity: Some(1024),",
          "        skip_cache_capacity_check: Some(true),",
          "        minimum_cache_clear_count: Some(Some(100)),",
          "        minimum_bytes_per_state: Some(Some(1000)),",
          "    };",
          "    builder.configure(config);",
          "    let mut builder = Builder::new();",
          "    let config = Config {",
          "    match_kind: Some(MatchKind::Literal),",
          "    pre: Some(Some(Prefilter::Simple)),",
          "    starts_for_each_pattern: Some(true),",
          "    byte_classes: Some(true),",
          "    unicode_word_boundary: Some(true),",
          "    quitset: Some(ByteSet::empty()),",
          "    specialize_start_states: Some(true),",
          "    cache_capacity: Some(1024),",
          "    skip_cache_capacity_check: Some(true),",
          "    minimum_cache_clear_count: Some(Some(100)),",
          "    minimum_bytes_per_state: Some(Some(1000)),",
          "    };",
          "    let result = builder.configure(config);",
          "    assert_eq!(result, &builder);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    ",
          "    let config_zero_capacity = Config {",
          "        match_kind: None,",
          "        pre: None,",
          "        starts_for_each_pattern: None,",
          "        byte_classes: None,",
          "        unicode_word_boundary: None,",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: None,",
          "        cache_capacity: Some(0),",
          "        skip_cache_capacity_check: None,",
          "        minimum_cache_clear_count: Some(Some(0)),",
          "        minimum_bytes_per_state: Some(Some(1)),",
          "    };",
          "    builder.configure(config_zero_capacity);",
          "",
          "    let config_max_capacity = Config {",
          "        match_kind: None,",
          "        pre: None,",
          "        starts_for_each_pattern: None,",
          "        byte_classes: None,",
          "        unicode_word_boundary: None,",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: None,",
          "        cache_capacity: Some(1024),",
          "        skip_cache_capacity_check: None,",
          "        minimum_cache_clear_count: Some(Some(100)),",
          "        minimum_bytes_per_state: Some(Some(1000)),",
          "    };",
          "    builder.configure(config_max_capacity);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.config.cache_capacity, Some(0));",
          "    assert_eq!(builder.config.minimum_cache_clear_count, Some(Some(0)));",
          "    assert_eq!(builder.config.minimum_bytes_per_state, Some(Some(1)));",
          "    assert_eq!(builder.config.cache_capacity, Some(1024));",
          "    assert_eq!(builder.config.minimum_cache_clear_count, Some(Some(100)));",
          "    assert_eq!(builder.config.minimum_bytes_per_state, Some(Some(1000)));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    ",
          "    let config_zero_capacity = Config {",
          "        match_kind: None,",
          "        pre: None,",
          "        starts_for_each_pattern: None,",
          "        byte_classes: None,",
          "        unicode_word_boundary: None,",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: None,",
          "        cache_capacity: Some(0),",
          "        skip_cache_capacity_check: None,",
          "        minimum_cache_clear_count: Some(Some(0)),",
          "        minimum_bytes_per_state: Some(Some(1)),",
          "    };",
          "    builder.configure(config_zero_capacity);",
          "",
          "    let config_max_capacity = Config {",
          "        match_kind: None,",
          "        pre: None,",
          "        starts_for_each_pattern: None,",
          "        byte_classes: None,",
          "        unicode_word_boundary: None,",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: None,",
          "        cache_capacity: Some(1024),",
          "        skip_cache_capacity_check: None,",
          "        minimum_cache_clear_count: Some(Some(100)),",
          "        minimum_bytes_per_state: Some(Some(1000)),",
          "    };",
          "    builder.configure(config_max_capacity);",
          "    assert_eq!(builder.config.cache_capacity, Some(0));",
          "    assert_eq!(builder.config.minimum_cache_clear_count, Some(Some(0)));",
          "    assert_eq!(builder.config.minimum_bytes_per_state, Some(Some(1)));",
          "    assert_eq!(builder.config.cache_capacity, Some(1024));",
          "    assert_eq!(builder.config.minimum_cache_clear_count, Some(Some(100)));",
          "    assert_eq!(builder.config.minimum_bytes_per_state, Some(Some(1000)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::Regex),",
          "        pre: None,",
          "        starts_for_each_pattern: Some(false),",
          "        byte_classes: Some(false),",
          "        unicode_word_boundary: Some(false),",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: Some(false),",
          "        cache_capacity: Some(512),",
          "        skip_cache_capacity_check: Some(false),",
          "        minimum_cache_clear_count: Some(Some(50)),",
          "        minimum_bytes_per_state: Some(Some(500)),",
          "    };",
          "    builder.configure(config);",
          "}"
        ],
        "oracle": [
          "    assert!(builder.config.match_kind.is_some());",
          "    assert_eq!(builder.config.match_kind.unwrap(), MatchKind::Regex);",
          "    assert!(builder.config.pre.is_none());",
          "    assert_eq!(builder.config.starts_for_each_pattern, Some(false));",
          "    assert_eq!(builder.config.byte_classes, Some(false));",
          "    assert_eq!(builder.config.unicode_word_boundary, Some(false));",
          "    assert!(builder.config.quitset.is_some());",
          "    assert!(builder.config.quitset.unwrap().is_empty());",
          "    assert_eq!(builder.config.specialize_start_states, Some(false));",
          "    assert_eq!(builder.config.cache_capacity, Some(512));",
          "    assert_eq!(builder.config.skip_cache_capacity_check, Some(false));",
          "    assert_eq!(builder.config.minimum_cache_clear_count, Some(Some(50)));",
          "    assert_eq!(builder.config.minimum_bytes_per_state, Some(Some(500)));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let config = Config {",
          "        match_kind: Some(MatchKind::Regex),",
          "        pre: None,",
          "        starts_for_each_pattern: Some(false),",
          "        byte_classes: Some(false),",
          "        unicode_word_boundary: Some(false),",
          "        quitset: Some(ByteSet::empty()),",
          "        specialize_start_states: Some(false),",
          "        cache_capacity: Some(512),",
          "        skip_cache_capacity_check: Some(false),",
          "        minimum_cache_clear_count: Some(Some(50)),",
          "        minimum_bytes_per_state: Some(Some(500)),",
          "    };",
          "    builder.configure(config);",
          "    assert!(builder.config.match_kind.is_some());",
          "    assert_eq!(builder.config.match_kind.unwrap(), MatchKind::Regex);",
          "    assert!(builder.config.pre.is_none());",
          "    assert_eq!(builder.config.starts_for_each_pattern, Some(false));",
          "    assert_eq!(builder.config.byte_classes, Some(false));",
          "    assert_eq!(builder.config.unicode_word_boundary, Some(false));",
          "    assert!(builder.config.quitset.is_some());",
          "    assert!(builder.config.quitset.unwrap().is_empty());",
          "    assert_eq!(builder.config.specialize_start_states, Some(false));",
          "    assert_eq!(builder.config.cache_capacity, Some(512));",
          "    assert_eq!(builder.config.skip_cache_capacity_check, Some(false));",
          "    assert_eq!(builder.config.minimum_cache_clear_count, Some(Some(50)));",
          "    assert_eq!(builder.config.minimum_bytes_per_state, Some(Some(500)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]