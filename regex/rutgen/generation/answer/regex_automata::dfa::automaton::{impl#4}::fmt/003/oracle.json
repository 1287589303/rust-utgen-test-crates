[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte = 10; // Example byte within the range",
          "    let error = StartError::Quit { byte };",
          "    let result = format!(\"{}\", error);",
          "}"
        ],
        "oracle": [
          "    format!(\"{}\", StartError::Quit { byte: 10 }) == \"error computing start state because the look-behind byte DebugByte(10) triggered a quit state\"",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Yes }) == \"error computing start state because anchored searches are not supported or enabled\"",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::No }) == \"error computing start state because unanchored searches are not supported or enabled\"",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(5)) }) == \"error computing start state because anchored searches for a specific pattern (5) are not supported or enabled\""
        ],
        "code": [
          "{",
          "    let byte = 10; // Example byte within the range",
          "    let error = StartError::Quit { byte };",
          "    let result = format!(\"{}\", error);",
          "    format!(\"{}\", StartError::Quit { byte: 10 }) == \"error computing start state because the look-behind byte DebugByte(10) triggered a quit state\"",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Yes }) == \"error computing start state because anchored searches are not supported or enabled\"",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::No }) == \"error computing start state because unanchored searches are not supported or enabled\"",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(5)) }) == \"error computing start state because anchored searches for a specific pattern (5) are not supported or enabled\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::Yes };",
          "    let result = format!(\"{}\", error);",
          "}"
        ],
        "oracle": [
          "    let error = StartError::Quit { byte: 0xFF };",
          "    let result = format!(\"{}\", error);",
          "    assert_eq!(result, \"error computing start state because the look-behind byte DebugByte(255) triggered a quit state\");",
          "    ",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::No };",
          "    let result = format!(\"{}\", error);",
          "    assert_eq!(result, \"error computing start state because unanchored searches are not supported or enabled\");",
          "    ",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(42)) };",
          "    let result = format!(\"{}\", error);",
          "    assert_eq!(result, \"error computing start state because anchored searches for a specific pattern (42) are not supported or enabled\");"
        ],
        "code": [
          "{",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::Yes };",
          "    let result = format!(\"{}\", error);",
          "    let error = StartError::Quit { byte: 0xFF };",
          "    let result = format!(\"{}\", error);",
          "    assert_eq!(result, \"error computing start state because the look-behind byte DebugByte(255) triggered a quit state\");",
          "    ",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::No };",
          "    let result = format!(\"{}\", error);",
          "    assert_eq!(result, \"error computing start state because unanchored searches are not supported or enabled\");",
          "    ",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(42)) };",
          "    let result = format!(\"{}\", error);",
          "    assert_eq!(result, \"error computing start state because anchored searches for a specific pattern (42) are not supported or enabled\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::No };",
          "    let result = format!(\"{}\", error);",
          "}"
        ],
        "oracle": [
          "    format!(\"{}\", StartError::Quit { byte: 0 }) == \"error computing start state because the look-behind byte DebugByte(0) triggered a quit state\";",
          "    format!(\"{}\", StartError::Quit { byte: 255 }) == \"error computing start state because the look-behind byte DebugByte(255) triggered a quit state\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Yes }) == \"error computing start state because anchored searches are not supported or enabled\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::No }) == \"error computing start state because unanchored searches are not supported or enabled\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(1)) }) == \"error computing start state because anchored searches for a specific pattern (1) are not supported or enabled\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(10)) }) == \"error computing start state because anchored searches for a specific pattern (10) are not supported or enabled\";"
        ],
        "code": [
          "{",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::No };",
          "    let result = format!(\"{}\", error);",
          "    format!(\"{}\", StartError::Quit { byte: 0 }) == \"error computing start state because the look-behind byte DebugByte(0) triggered a quit state\";",
          "    format!(\"{}\", StartError::Quit { byte: 255 }) == \"error computing start state because the look-behind byte DebugByte(255) triggered a quit state\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Yes }) == \"error computing start state because anchored searches are not supported or enabled\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::No }) == \"error computing start state because unanchored searches are not supported or enabled\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(1)) }) == \"error computing start state because anchored searches for a specific pattern (1) are not supported or enabled\";",
          "    format!(\"{}\", StartError::UnsupportedAnchored { mode: Anchored::Pattern(PatternID(10)) }) == \"error computing start state because anchored searches for a specific pattern (10) are not supported or enabled\";",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pid = PatternID(5); // Example PatternID within the range",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::Pattern(pid) };",
          "    let result = format!(\"{}\", error);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"error computing start state because anchored searches for a specific pattern ({}) are not supported or enabled\", pid.as_usize());",
          "    write!(f, \"error computing start state because anchored searches are not supported or enabled\");",
          "    write!(f, \"error computing start state because unanchored searches are not supported or enabled\");",
          "    write!(f, \"error computing start state because the look-behind byte {:?} triggered a quit state\", crate::util::escape::DebugByte(byte));"
        ],
        "code": [
          "{",
          "    let pid = PatternID(5); // Example PatternID within the range",
          "    let error = StartError::UnsupportedAnchored { mode: Anchored::Pattern(pid) };",
          "    let result = format!(\"{}\", error);",
          "    write!(f, \"error computing start state because anchored searches for a specific pattern ({}) are not supported or enabled\", pid.as_usize());",
          "    write!(f, \"error computing start state because anchored searches are not supported or enabled\");",
          "    write!(f, \"error computing start state because unanchored searches are not supported or enabled\");",
          "    write!(f, \"error computing start state because the look-behind byte {:?} triggered a quit state\", crate::util::escape::DebugByte(byte));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]