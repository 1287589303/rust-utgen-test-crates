[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0)));",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // This should panic",
          "}"
        ],
        "oracle": [
          "    assert_panics!(group_info.add_first_group(PatternID(SmallIndex(0))));"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0)));",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // This should panic",
          "    assert_panics!(group_info.add_first_group(PatternID(SmallIndex(0))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0)));",
          "    group_info.add_first_group(PatternID(SmallIndex(1)));",
          "    group_info.add_first_group(PatternID(SmallIndex(2))); // This should panic",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges.len(), 2);",
          "    assert_eq!(group_info.name_to_index.len(), 2);",
          "    assert_eq!(group_info.index_to_name.len(), 2);",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>() * 2);",
          "    assert!(std::panic::catch_unwind(|| group_info.add_first_group(PatternID(SmallIndex(2))).unwrap_err()).is_err());"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0)));",
          "    group_info.add_first_group(PatternID(SmallIndex(1)));",
          "    group_info.add_first_group(PatternID(SmallIndex(2))); // This should panic",
          "    assert_eq!(group_info.slot_ranges.len(), 2);",
          "    assert_eq!(group_info.name_to_index.len(), 2);",
          "    assert_eq!(group_info.index_to_name.len(), 2);",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>() * 2);",
          "    assert!(std::panic::catch_unwind(|| group_info.add_first_group(PatternID(SmallIndex(2))).unwrap_err()).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // Valid",
          "    group_info.add_first_group(PatternID(SmallIndex(1))); // Valid",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges.len(), 2);",
          "    assert_eq!(group_info.name_to_index.len(), 2);",
          "    assert_eq!(group_info.index_to_name.len(), 2);",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>() * 2);"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // Valid",
          "    group_info.add_first_group(PatternID(SmallIndex(1))); // Valid",
          "    assert_eq!(group_info.slot_ranges.len(), 2);",
          "    assert_eq!(group_info.name_to_index.len(), 2);",
          "    assert_eq!(group_info.index_to_name.len(), 2);",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>() * 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // Valid",
          "    group_info.slot_ranges.push((SmallIndex(0), SmallIndex(1))); // Manipulate to cause inconsistency",
          "    group_info.add_first_group(PatternID(SmallIndex(1))); // This should panic",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges.len(), 1); // Verifying initial length after first group addition",
          "    assert_eq!(group_info.name_to_index.len(), 1); // Verifying name_to_index length after first group addition",
          "    assert_eq!(group_info.index_to_name.len(), 1); // Verifying index_to_name length after first group addition",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>()); // Checking memory_extra after first group addition",
          "    assert!(std::panic::catch_unwind(|| group_info.add_first_group(PatternID(SmallIndex(1)))).is_err()); // Ensuring panic occurs on second group addition"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // Valid",
          "    group_info.slot_ranges.push((SmallIndex(0), SmallIndex(1))); // Manipulate to cause inconsistency",
          "    group_info.add_first_group(PatternID(SmallIndex(1))); // This should panic",
          "    assert_eq!(group_info.slot_ranges.len(), 1); // Verifying initial length after first group addition",
          "    assert_eq!(group_info.name_to_index.len(), 1); // Verifying name_to_index length after first group addition",
          "    assert_eq!(group_info.index_to_name.len(), 1); // Verifying index_to_name length after first group addition",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>()); // Checking memory_extra after first group addition",
          "    assert!(std::panic::catch_unwind(|| group_info.add_first_group(PatternID(SmallIndex(1)))).is_err()); // Ensuring panic occurs on second group addition",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // Valid",
          "    group_info.add_first_group(PatternID(SmallIndex(1))); // Valid",
          "    group_info.add_first_group(PatternID(SmallIndex(2))); // Valid, pushing to small slot limit",
          "}"
        ],
        "oracle": [
          "    assert_eq!(group_info.slot_ranges.len(), 3);",
          "    assert_eq!(group_info.name_to_index.len(), 3);",
          "    assert_eq!(group_info.index_to_name.len(), 3);",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>() * 3);",
          "    assert_eq!(group_info.slot_ranges[0], (SmallIndex(0), SmallIndex(0)));",
          "    assert_eq!(group_info.slot_ranges[1], (SmallIndex(1), SmallIndex(1)));",
          "    assert_eq!(group_info.slot_ranges[2], (SmallIndex(2), SmallIndex(2)));"
        ],
        "code": [
          "{",
          "    let mut group_info = GroupInfoInner::default();",
          "    group_info.add_first_group(PatternID(SmallIndex(0))); // Valid",
          "    group_info.add_first_group(PatternID(SmallIndex(1))); // Valid",
          "    group_info.add_first_group(PatternID(SmallIndex(2))); // Valid, pushing to small slot limit",
          "    assert_eq!(group_info.slot_ranges.len(), 3);",
          "    assert_eq!(group_info.name_to_index.len(), 3);",
          "    assert_eq!(group_info.index_to_name.len(), 3);",
          "    assert_eq!(group_info.memory_extra, core::mem::size_of::<Option<Arc<str>>>() * 3);",
          "    assert_eq!(group_info.slot_ranges[0], (SmallIndex(0), SmallIndex(0)));",
          "    assert_eq!(group_info.slot_ranges[1], (SmallIndex(1), SmallIndex(1)));",
          "    assert_eq!(group_info.slot_ranges[2], (SmallIndex(2), SmallIndex(2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]