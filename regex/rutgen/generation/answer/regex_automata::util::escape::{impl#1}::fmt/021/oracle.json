[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct<'a>(&'a [u8]);",
          "",
          "    let input = [",
          "        0x0b, // \\x0b (vertical tab)",
          "        0x0c, // \\x0c (form feed)",
          "        0x0e, // \\x0e (control character)",
          "        0x7f, // \\x7f (delete)",
          "        0x01, // \\x01 (start of heading)",
          "        0x02, // \\x02 (start of text)",
          "        0x03, // \\x03 (end of text)",
          "        0x04, // \\x04 (end of transmission)",
          "        0x05, // \\x05 (enquiry)",
          "        0x06, // \\x06 (acknowledge)",
          "        0x07, // \\x07 (bell)",
          "        0x08, // \\x08 (backspace)",
          "        0x0a, // \\n (line feed)",
          "        0x0d, // \\r (carriage return)",
          "        0x09, // \\t (tab)",
          "        0x0f, // \\x0f (control character)",
          "    ];",
          "    ",
          "    let debug_haystack = TestStruct(&input);",
          "    let _ = core::fmt::Debug::fmt(&debug_haystack, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok()",
          "    let Some(result) = utf8::decode(self.0)",
          "    result.is_ok()",
          "    let ch = result.unwrap()",
          "    ch == '\\x0b'",
          "    ch == '\\x0c'",
          "    ch == '\\0'",
          "    ch == '\\x7f'",
          "    ch == '\\n'",
          "    ch == '\\r'",
          "    ch == '\\t'",
          "    !('\\x01'..='\\x08').contains(&ch)",
          "    ('\\x0e'..='\\x19').contains(&ch)",
          "    ('\\x0b' == ch || ('\\x0e'..='\\x19').contains(&ch) || '\\x0c' == ch || '\\x7f' == ch || ('\\x01'..='\\x08').contains(&ch))",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_ok()",
          "    let Some(result) = utf8::decode(self.0)",
          "    write!(f, \"\\\"\").is_ok()",
          "    Ok(())"
        ],
        "code": [
          "{",
          "    struct TestStruct<'a>(&'a [u8]);",
          "",
          "    let input = [",
          "        0x0b, // \\x0b (vertical tab)",
          "        0x0c, // \\x0c (form feed)",
          "        0x0e, // \\x0e (control character)",
          "        0x7f, // \\x7f (delete)",
          "        0x01, // \\x01 (start of heading)",
          "        0x02, // \\x02 (start of text)",
          "        0x03, // \\x03 (end of text)",
          "        0x04, // \\x04 (end of transmission)",
          "        0x05, // \\x05 (enquiry)",
          "        0x06, // \\x06 (acknowledge)",
          "        0x07, // \\x07 (bell)",
          "        0x08, // \\x08 (backspace)",
          "        0x0a, // \\n (line feed)",
          "        0x0d, // \\r (carriage return)",
          "        0x09, // \\t (tab)",
          "        0x0f, // \\x0f (control character)",
          "    ];",
          "    ",
          "    let debug_haystack = TestStruct(&input);",
          "    let _ = core::fmt::Debug::fmt(&debug_haystack, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\").is_ok()",
          "    let Some(result) = utf8::decode(self.0)",
          "    result.is_ok()",
          "    let ch = result.unwrap()",
          "    ch == '\\x0b'",
          "    ch == '\\x0c'",
          "    ch == '\\0'",
          "    ch == '\\x7f'",
          "    ch == '\\n'",
          "    ch == '\\r'",
          "    ch == '\\t'",
          "    !('\\x01'..='\\x08').contains(&ch)",
          "    ('\\x0e'..='\\x19').contains(&ch)",
          "    ('\\x0b' == ch || ('\\x0e'..='\\x19').contains(&ch) || '\\x0c' == ch || '\\x7f' == ch || ('\\x01'..='\\x08').contains(&ch))",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_ok()",
          "    let Some(result) = utf8::decode(self.0)",
          "    write!(f, \"\\\"\").is_ok()",
          "    Ok(())",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct<'a>(&'a [u8]);",
          "",
          "    let input = [",
          "        0x0e, // \\x0e",
          "        0x12, // \\x12",
          "        0x19, // \\x19",
          "        0x7f, // \\x7f",
          "        0x0b, // \\x0b",
          "        0x0c, // \\x0c",
          "        0x08, // \\x08",
          "    ];",
          "    ",
          "    let debug_haystack = TestStruct(&input);",
          "    let _ = core::fmt::Debug::fmt(&debug_haystack, &mut core::fmt::Formatter::new());",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8::decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\x0b';",
          "    ch matches '\\x0c';",
          "    ch matches '\\0';",
          "    ch matches '\\x7f';",
          "    ch matches '\\n';",
          "    ch matches '\\r';",
          "    ch matches '\\t';",
          "    ch matches '\\x01'..='\\x08';",
          "    ch matches '\\x0e'..='\\x19';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());"
        ],
        "code": [
          "{",
          "    struct TestStruct<'a>(&'a [u8]);",
          "",
          "    let input = [",
          "        0x0e, // \\x0e",
          "        0x12, // \\x12",
          "        0x19, // \\x19",
          "        0x7f, // \\x7f",
          "        0x0b, // \\x0b",
          "        0x0c, // \\x0c",
          "        0x08, // \\x08",
          "    ];",
          "    ",
          "    let debug_haystack = TestStruct(&input);",
          "    let _ = core::fmt::Debug::fmt(&debug_haystack, &mut core::fmt::Formatter::new());",
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8::decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\x0b';",
          "    ch matches '\\x0c';",
          "    ch matches '\\0';",
          "    ch matches '\\x7f';",
          "    ch matches '\\n';",
          "    ch matches '\\r';",
          "    ch matches '\\t';",
          "    ch matches '\\x01'..='\\x08';",
          "    ch matches '\\x0e'..='\\x19';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]