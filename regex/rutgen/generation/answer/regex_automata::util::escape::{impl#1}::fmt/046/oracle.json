[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[0x00];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    result.is_ok();",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[0x00];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    result.is_ok();",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[0x01, 0x02, 0x03, 0x04];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").unwrap();",
          "    utf8::decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    matches!(ch, '\\0');",
          "    write!(f, \"\\\\0\").is_ok();"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[0x01, 0x02, 0x03, 0x04];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").unwrap();",
          "    utf8::decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    ch == '\\0';",
          "    matches!(ch, '\\0');",
          "    write!(f, \"\\\\0\").is_ok();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[0x7f];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x00]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x01]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x7f]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x01, 0x02, 0x03]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x00, 0x0a, 0x0d, 0x0c]).fmt(f)).is_ok(), true);",
          "    assert!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x7f]).fmt(f)).unwrap().is_ok());"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[0x7f];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x00]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x01]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x7f]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x01, 0x02, 0x03]).fmt(f)).is_ok(), true);",
          "    assert_eq!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x00, 0x0a, 0x0d, 0x0c]).fmt(f)).is_ok(), true);",
          "    assert!(core::fmt::write(&mut core::fmt::Formatter::new(), |f| DebugHaystack(&[0x7f]).fmt(f)).unwrap().is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[0x80, 0xff];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").unwrap();",
          "    let Some(result) = utf8::decode(&data).unwrap();",
          "    let ch = match result { Ok(ch) => ch, _ => panic!(\"Expected Ok result\"); };",
          "    assert_eq!(ch, '\\0');",
          "    write!(f, \"\\\\0\").unwrap();"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[0x80, 0xff];",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").unwrap();",
          "    let Some(result) = utf8::decode(&data).unwrap();",
          "    let ch = match result { Ok(ch) => ch, _ => panic!(\"Expected Ok result\"); };",
          "    assert_eq!(ch, '\\0');",
          "    write!(f, \"\\\\0\").unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let data: &[u8] = &[0x61, 0x62, 0x63]; // \"abc\"",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    match utf8::decode(bytes) { Some(Ok(ch)) => ch.is_ascii(), _ => false };",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();"
        ],
        "code": [
          "{",
          "    let data: &[u8] = &[0x61, 0x62, 0x63]; // \"abc\"",
          "    let haystack = DebugHaystack(data);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    match utf8::decode(bytes) { Some(Ok(ch)) => ch.is_ascii(), _ => false };",
          "    ch == '\\0';",
          "    write!(f, \"\\\\0\").is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]