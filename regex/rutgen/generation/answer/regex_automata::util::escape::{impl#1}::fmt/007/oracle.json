[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = DebugHaystack(&[0]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok()",
          "    utf8::decode(bytes).is_some()",
          "    match result { Ok(ch) => true, _ => false }",
          "    ch == '\\x0b'",
          "    ch == '\\x0c'",
          "    ch == '\\0'",
          "    ch == '\\x7f'",
          "    ch == '\\n'",
          "    ch == '\\r'",
          "    ch == '\\t'",
          "    ('\\x01'..='\\x08').contains(&ch)",
          "    ('\\x01'..='\\x08').contains(&ch)",
          "    matches!(ch, '\\x0b' | '\\x0e'..='\\x19' | '\\x0c' | '\\x7f' | '\\x01'..='\\x08')",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err()"
        ],
        "code": [
          "{",
          "    let haystack = DebugHaystack(&[0]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").is_ok()",
          "    utf8::decode(bytes).is_some()",
          "    match result { Ok(ch) => true, _ => false }",
          "    ch == '\\x0b'",
          "    ch == '\\x0c'",
          "    ch == '\\0'",
          "    ch == '\\x7f'",
          "    ch == '\\n'",
          "    ch == '\\r'",
          "    ch == '\\t'",
          "    ('\\x01'..='\\x08').contains(&ch)",
          "    ('\\x01'..='\\x08').contains(&ch)",
          "    matches!(ch, '\\x0b' | '\\x0e'..='\\x19' | '\\x0c' | '\\x7f' | '\\x01'..='\\x08')",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err()",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = DebugHaystack(&[11]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8::decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\x0b';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());"
        ],
        "code": [
          "{",
          "    let haystack = DebugHaystack(&[11]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8::decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\x0b';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;",
          "    write!(f, \"\\\"\")?;",
          "    Ok(());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = DebugHaystack(&[12]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    matches!(ch, '\\x0b');",
          "    matches!(ch, '\\x0c');",
          "    matches!(ch, '\\0');",
          "    matches!(ch, '\\x7f');",
          "    matches!(ch, '\\n');",
          "    matches!(ch, '\\r');",
          "    matches!(ch, '\\t');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x0b' | '\\x0c' | '\\x0e'..='\\x19' | '\\x7f' | '\\x01'..='\\x08');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();"
        ],
        "code": [
          "{",
          "    let haystack = DebugHaystack(&[12]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(result, Ok(ch));",
          "    matches!(ch, '\\x0b');",
          "    matches!(ch, '\\x0c');",
          "    matches!(ch, '\\0');",
          "    matches!(ch, '\\x7f');",
          "    matches!(ch, '\\n');",
          "    matches!(ch, '\\r');",
          "    matches!(ch, '\\t');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x0b' | '\\x0c' | '\\x0e'..='\\x19' | '\\x7f' | '\\x01'..='\\x08');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = DebugHaystack(&[9]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").unwrap();",
          "    let result = utf8::decode(&[9]);",
          "    assert!(result.is_some());",
          "    let ch = result.unwrap().ok().unwrap();",
          "    assert_eq!(ch, '\\t');",
          "    let haystack = DebugHaystack(&[0x0b]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[0x0c]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[0]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[0x7f]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[10]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[13]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[1]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[8]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let haystack = DebugHaystack(&[9]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").unwrap();",
          "    let result = utf8::decode(&[9]);",
          "    assert!(result.is_some());",
          "    let ch = result.unwrap().ok().unwrap();",
          "    assert_eq!(ch, '\\t');",
          "    let haystack = DebugHaystack(&[0x0b]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[0x0c]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[0]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[0x7f]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[10]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[13]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[1]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "    let haystack = DebugHaystack(&[8]);",
          "    let result = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = DebugHaystack(&[10]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").unwrap();",
          "    let result = utf8::decode(&[10]);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert_eq!(ch, '\\n');",
          "    }",
          "    let mut bytes = &[10];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert_eq!(ch, '\\n');",
          "    }",
          "    bytes = &[0];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Err(byte)) = result {",
          "    assert_eq!(byte, 0);",
          "    }",
          "    bytes = &[11];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x0b');",
          "    }",
          "    bytes = &[12];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x0c');",
          "    }",
          "    bytes = &[127];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x7f');",
          "    }",
          "    bytes = &[1];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x01');",
          "    }",
          "    bytes = &[8];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x08');",
          "    }"
        ],
        "code": [
          "{",
          "    let haystack = DebugHaystack(&[10]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").unwrap();",
          "    let result = utf8::decode(&[10]);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert_eq!(ch, '\\n');",
          "    }",
          "    let mut bytes = &[10];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert_eq!(ch, '\\n');",
          "    }",
          "    bytes = &[0];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Err(byte)) = result {",
          "    assert_eq!(byte, 0);",
          "    }",
          "    bytes = &[11];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x0b');",
          "    }",
          "    bytes = &[12];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x0c');",
          "    }",
          "    bytes = &[127];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x7f');",
          "    }",
          "    bytes = &[1];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x01');",
          "    }",
          "    bytes = &[8];",
          "    let result = utf8::decode(bytes);",
          "    assert!(result.is_some());",
          "    if let Some(Ok(ch)) = result {",
          "    assert!(ch == '\\x08');",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = DebugHaystack(&[13]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(ch, '\\x0b');",
          "    matches!(ch, '\\x0c');",
          "    matches!(ch, '\\0');",
          "    matches!(ch, '\\x7f');",
          "    matches!(ch, '\\n');",
          "    matches!(ch, '\\r');",
          "    matches!(ch, '\\t');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x0b' | '\\x0c' | '\\x0e'..='\\x19' | '\\x7f' | '\\x01'..='\\x08');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();"
        ],
        "code": [
          "{",
          "    let haystack = DebugHaystack(&[13]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\").is_ok();",
          "    utf8::decode(bytes).is_some();",
          "    matches!(result, Ok(ch));",
          "    matches!(ch, '\\x0b');",
          "    matches!(ch, '\\x0c');",
          "    matches!(ch, '\\0');",
          "    matches!(ch, '\\x7f');",
          "    matches!(ch, '\\n');",
          "    matches!(ch, '\\r');",
          "    matches!(ch, '\\t');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x01'..='\\x08');",
          "    matches!(ch, '\\x0b' | '\\x0c' | '\\x0e'..='\\x19' | '\\x7f' | '\\x01'..='\\x08');",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch)).is_err();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack = DebugHaystack(&[1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 16, 17, 18, 19, 127]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8::decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\x0b';",
          "    ch matches '\\x0c';",
          "    ch matches '\\0';",
          "    ch matches '\\x7f';",
          "    ch matches '\\n';",
          "    ch matches '\\r';",
          "    ch matches '\\t';",
          "    ch matches '\\x01'..='\\x08';",
          "    ch matches '\\x01'..='\\x08';",
          "    ch matches '\\x0b' or '\\x0e'..='\\x19' or '\\x0c' or '\\x7f' or '\\x01'..='\\x08';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch));"
        ],
        "code": [
          "{",
          "    let haystack = DebugHaystack(&[1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 16, 17, 18, 19, 127]);",
          "    let _ = core::fmt::write(&mut core::fmt::Formatter::new(), |f| haystack.fmt(f));",
          "    write!(f, \"\\\"\")?;",
          "    let Some(result) = utf8::decode(bytes);",
          "    result matches Ok(ch);",
          "    ch matches '\\x0b';",
          "    ch matches '\\x0c';",
          "    ch matches '\\0';",
          "    ch matches '\\x7f';",
          "    ch matches '\\n';",
          "    ch matches '\\r';",
          "    ch matches '\\t';",
          "    ch matches '\\x01'..='\\x08';",
          "    ch matches '\\x01'..='\\x08';",
          "    ch matches '\\x0b' or '\\x0e'..='\\x19' or '\\x0c' or '\\x7f' or '\\x01'..='\\x08';",
          "    write!(f, \"\\\\x{:02x}\", u32::from(ch));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]