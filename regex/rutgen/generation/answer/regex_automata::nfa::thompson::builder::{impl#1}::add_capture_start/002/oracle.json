[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap(); // initial unnamed capture",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap(); // first named capture",
          "    let _ = builder.add_capture_start(StateID::ZERO, 2, Some(Arc::from(\"group2\"))).unwrap(); // second named capture",
          "    let result = builder.finish_pattern(StateID::ZERO);",
          "}"
        ],
        "oracle": [
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    assert!(builder.captures.len() == pid.as_usize());",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 1);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 2);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 2, Some(Arc::from(\"group2\"))).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 3);",
          "    let result = builder.finish_pattern(StateID::ZERO);",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap(); // initial unnamed capture",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap(); // first named capture",
          "    let _ = builder.add_capture_start(StateID::ZERO, 2, Some(Arc::from(\"group2\"))).unwrap(); // second named capture",
          "    let result = builder.finish_pattern(StateID::ZERO);",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    assert!(builder.captures.len() == pid.as_usize());",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 1);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 2);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 2, Some(Arc::from(\"group2\"))).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 3);",
          "    let result = builder.finish_pattern(StateID::ZERO);",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let _ = builder.start_pattern(); // start new pattern",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap(); // reuse group index",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "}"
        ],
        "oracle": [
          "    let pid = builder.current_pattern_id();",
          "    let captures_len = builder.captures.len();",
          "    assert_eq!(captures_len, pid.as_usize());",
          "    let next_start = StateID::ZERO;",
          "    let result = builder.add_capture_start(next_start, 0, None);",
          "    assert!(result.is_ok());",
          "    let group_index1 = 1;",
          "    let result1 = builder.add_capture_start(next_start, group_index1, Some(Arc::from(\"group1\")));",
          "    assert!(result1.is_ok());",
          "    let captures_after_first_pattern = builder.captures[pid.as_usize()].len();",
          "    assert_eq!(captures_after_first_pattern, 2);",
          "    let group_index2 = 1;",
          "    let result2 = builder.add_capture_start(next_start, group_index2, Some(Arc::from(\"group1\")));",
          "    assert!(result2.is_ok());",
          "    let captures_after_second_pattern = builder.captures[pid.as_usize()].len();",
          "    assert_eq!(captures_after_second_pattern, 2);",
          "    let result_build = builder.build(StateID::ZERO, StateID::ZERO);",
          "    assert!(result_build.is_err());"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let _ = builder.start_pattern(); // start new pattern",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap(); // reuse group index",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "    let pid = builder.current_pattern_id();",
          "    let captures_len = builder.captures.len();",
          "    assert_eq!(captures_len, pid.as_usize());",
          "    let next_start = StateID::ZERO;",
          "    let result = builder.add_capture_start(next_start, 0, None);",
          "    assert!(result.is_ok());",
          "    let group_index1 = 1;",
          "    let result1 = builder.add_capture_start(next_start, group_index1, Some(Arc::from(\"group1\")));",
          "    assert!(result1.is_ok());",
          "    let captures_after_first_pattern = builder.captures[pid.as_usize()].len();",
          "    assert_eq!(captures_after_first_pattern, 2);",
          "    let group_index2 = 1;",
          "    let result2 = builder.add_capture_start(next_start, group_index2, Some(Arc::from(\"group1\")));",
          "    assert!(result2.is_ok());",
          "    let captures_after_second_pattern = builder.captures[pid.as_usize()].len();",
          "    assert_eq!(captures_after_second_pattern, 2);",
          "    let result_build = builder.build(StateID::ZERO, StateID::ZERO);",
          "    assert!(result_build.is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap(); // duplicate name",
          "    let _ = builder.finish_pattern(StateID::ZERO).unwrap();",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(SmallIndex::try_from(1).is_ok(), true);",
          "    assert!(pid.as_usize() >= builder.captures.len());",
          "    assert!(pid.as_usize() == builder.captures.len());",
          "    assert_eq!(builder.captures.len(), 1);",
          "    assert!(builder.captures[pid.as_usize()].is_empty());",
          "    assert!(builder.captures[pid.as_usize()].len() <= 1);",
          "    assert!(builder.captures[pid.as_usize()].as_slice().contains(&None));",
          "    assert_eq!(builder.captures[pid.as_usize()].get(1), Some(Some(Arc::from(\"group1\"))));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap(); // duplicate name",
          "    let _ = builder.finish_pattern(StateID::ZERO).unwrap();",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "    assert_eq!(SmallIndex::try_from(1).is_ok(), true);",
          "    assert!(pid.as_usize() >= builder.captures.len());",
          "    assert!(pid.as_usize() == builder.captures.len());",
          "    assert_eq!(builder.captures.len(), 1);",
          "    assert!(builder.captures[pid.as_usize()].is_empty());",
          "    assert!(builder.captures[pid.as_usize()].len() <= 1);",
          "    assert!(builder.captures[pid.as_usize()].as_slice().contains(&None));",
          "    assert_eq!(builder.captures[pid.as_usize()].get(1), Some(Some(Arc::from(\"group1\"))));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let _ = builder.start_pattern(); // start a new pattern",
          "    let second_pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group2\"))).unwrap();",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "}"
        ],
        "oracle": [
          "    let builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 1);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 2);",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let _ = builder.start_pattern();",
          "    let second_pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    assert!(builder.captures[second_pid.as_usize()].len() == 1);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group2\"))).unwrap();",
          "    assert!(builder.captures[second_pid.as_usize()].len() == 2);",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let _ = builder.start_pattern(); // start a new pattern",
          "    let second_pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group2\"))).unwrap();",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "    let builder = Builder::new();",
          "    let _ = builder.start_pattern();",
          "    let pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 1);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group1\"))).unwrap();",
          "    assert!(builder.captures[pid.as_usize()].len() == 2);",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let _ = builder.start_pattern();",
          "    let second_pid = builder.current_pattern_id();",
          "    let _ = builder.add_capture_start(StateID::ZERO, 0, None).unwrap();",
          "    assert!(builder.captures[second_pid.as_usize()].len() == 1);",
          "    let _ = builder.add_capture_start(StateID::ZERO, 1, Some(Arc::from(\"group2\"))).unwrap();",
          "    assert!(builder.captures[second_pid.as_usize()].len() == 2);",
          "    let _ = builder.finish_pattern(StateID::ZERO);",
          "    let result = builder.build(StateID::ZERO, StateID::ZERO);",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]