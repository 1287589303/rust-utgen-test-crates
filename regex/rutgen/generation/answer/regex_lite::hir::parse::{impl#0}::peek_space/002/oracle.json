[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   a\"; // Pattern starts with whitespace followed by a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   a\"; // Pattern starts with whitespace followed by a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    assert_eq!(parser.peek_space(), Some('a'));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   a\"; // Pattern starts with whitespace followed by a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   a\"; // Pattern starts with whitespace followed by a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    assert_eq!(parser.peek_space(), Some('a'));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   # comment\\n b\"; // Pattern starts with whitespace, followed by comment, and a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some('b'));",
          "    assert_eq!(parser.pos().unwrap(), 0);",
          "    assert!(parser.is_done() == false);",
          "    assert!(parser.flags().ignore_whitespace == true);",
          "    assert!(parser.peek_space().is_some());",
          "    assert!(parser.peek_space().unwrap() == 'b');"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   # comment\\n b\"; // Pattern starts with whitespace, followed by comment, and a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b'));",
          "    assert_eq!(parser.pos().unwrap(), 0);",
          "    assert!(parser.is_done() == false);",
          "    assert!(parser.flags().ignore_whitespace == true);",
          "    assert!(parser.peek_space().is_some());",
          "    assert!(parser.peek_space().unwrap() == 'b');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \" \\n\\t b\"; // Pattern contains whitespace, newline, and a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \" \\n\\t b\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Verify that the next non-whitespace character is 'b'",
          "    parser.pos.set(1);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Check that peek_space still returns 'b' with leading whitespace skipped",
          "    parser.pos.set(3);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, None); // Ensure peek_space returns None when at the end of the pattern"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \" \\n\\t b\"; // Pattern contains whitespace, newline, and a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \" \\n\\t b\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Verify that the next non-whitespace character is 'b'",
          "    parser.pos.set(1);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Check that peek_space still returns 'b' with leading whitespace skipped",
          "    parser.pos.set(3);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, None); // Ensure peek_space returns None when at the end of the pattern",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   b\"; // Pattern contains leading whitespace, followed immediately by a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   b\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Validates that 'b' is the next character ignoring leading whitespace",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   #comment\\n   c\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('c')); // Validates that 'c' is the next character after ignoring whitespace and a comment",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   \\n   \";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, None); // Validates that there is no character after whitespace",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   a#comment\\n   b\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Validates 'b' after skipping whitespace and a comment",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   \";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, None); // Validates that there is no character after only whitespace"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   b\"; // Pattern contains leading whitespace, followed immediately by a character",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   b\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Validates that 'b' is the next character ignoring leading whitespace",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   #comment\\n   c\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('c')); // Validates that 'c' is the next character after ignoring whitespace and a comment",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   \\n   \";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, None); // Validates that there is no character after whitespace",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   a#comment\\n   b\";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, Some('b')); // Validates 'b' after skipping whitespace and a comment",
          "    ",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"   \";",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0);",
          "    let result = parser.peek_space();",
          "    assert_eq!(result, None); // Validates that there is no character after only whitespace",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"# first comment\\n   # second comment\\n c\"; // Includes multiple comments and whitespace",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"# first comment\\n   # second comment\\n c\"; // Includes multiple comments and whitespace",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    assert!(parser.peek_space().is_some()); // Assert that the peek_space returns a character after whitespace and comments",
          "    assert_eq!(parser.peek_space(), Some('c')); // Assert that the next character is 'c' after whitespaces and comments"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"# first comment\\n   # second comment\\n c\"; // Includes multiple comments and whitespace",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    let result = parser.peek_space();",
          "    let config = Config { nest_limit: 10, flags: Flags { ignore_whitespace: true, ..Default::default() } };",
          "    let pattern = \"# first comment\\n   # second comment\\n c\"; // Includes multiple comments and whitespace",
          "    let parser = Parser::new(config, pattern);",
          "    parser.pos.set(0); // Set position to start of pattern",
          "    assert!(parser.peek_space().is_some()); // Assert that the peek_space returns a character after whitespace and comments",
          "    assert_eq!(parser.peek_space(), Some('c')); // Assert that the next character is 'c' after whitespaces and comments",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]