[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 1, flags: Flags::default() };",
          "    let pattern = \"((()))\"; // Exceeds nesting limit",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));",
          "    ",
          "    parser.depth.set(2);",
          "    parser.char.set(Some('('));",
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));",
          "    ",
          "    parser.depth.set(1);",
          "    parser.char.set(Some('('));",
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));",
          "    ",
          "    parser.depth.set(0);",
          "    parser.char.set(Some('('));",
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 1, flags: Flags::default() };",
          "    let pattern = \"((()))\"; // Exceeds nesting limit",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));",
          "    ",
          "    parser.depth.set(2);",
          "    parser.char.set(Some('('));",
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));",
          "    ",
          "    parser.depth.set(1);",
          "    parser.char.set(Some('('));",
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));",
          "    ",
          "    parser.depth.set(0);",
          "    parser.char.set(Some('('));",
          "    assert!(matches!(parser.parse(), Err(Error { msg: ERR_TOO_MUCH_NESTING })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"(?<name>abc)(?<name>def)\"; // Duplicate capture group name",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![String::from(\"name\")]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.unwrap_err().msg, ERR_DUPLICATE_CAPTURE_NAME);",
          "    assert_eq!(parser.capture_names.borrow().len(), 1);",
          "    assert_eq!(parser.capture_index.get(), 0);",
          "    assert_eq!(parser.depth.get(), 0);",
          "    assert_eq!(parser.pos.get(), 0);",
          "    assert!(matches!(parser.char.get(), Some('(')));",
          "    assert!(parser.flags.borrow().case_insensitive == false);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"(?<name>abc)(?<name>def)\"; // Duplicate capture group name",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![String::from(\"name\")]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "    assert_eq!(_result.unwrap_err().msg, ERR_DUPLICATE_CAPTURE_NAME);",
          "    assert_eq!(parser.capture_names.borrow().len(), 1);",
          "    assert_eq!(parser.capture_index.get(), 0);",
          "    assert_eq!(parser.depth.get(), 0);",
          "    assert_eq!(parser.pos.get(), 0);",
          "    assert!(matches!(parser.char.get(), Some('(')));",
          "    assert!(parser.flags.borrow().case_insensitive == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"(?i)(?m)(??)\"; // Invalid flag declaration",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_EMPTY_FLAGS);",
          "    assert!(parser.capture_names.borrow().is_empty());",
          "    assert_eq!(parser.flags.borrow().case_insensitive, false);",
          "    assert_eq!(parser.flags.borrow().multi_line, false);",
          "    assert_eq!(parser.depth.get(), 0);",
          "    assert_eq!(parser.pos.get(), 0);",
          "    assert_eq!(parser.char.get(), Some('('));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"(?i)(?m)(??)\"; // Invalid flag declaration",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_EMPTY_FLAGS);",
          "    assert!(parser.capture_names.borrow().is_empty());",
          "    assert_eq!(parser.flags.borrow().case_insensitive, false);",
          "    assert_eq!(parser.flags.borrow().multi_line, false);",
          "    assert_eq!(parser.depth.get(), 0);",
          "    assert_eq!(parser.pos.get(), 0);",
          "    assert_eq!(parser.char.get(), Some('('));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"(abc)\\\\1\"; // Backreferences are not supported",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_is_err, true);",
          "    assert_eq!(_error.msg, ERR_BACKREF_UNSUPPORTED);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"(abc)\\\\1\"; // Backreferences are not supported",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('(')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "    assert_eq!(_is_err, true);",
          "    assert_eq!(_error.msg, ERR_BACKREF_UNSUPPORTED);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = r\"\\p{L}\"; // Unicode character classes are not supported",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('\\\\')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_ , Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = r\"\\p{L}\"; // Unicode character classes are not supported",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('\\\\')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "    assert_eq!(_ , Err(Error::new(ERR_UNICODE_CLASS_UNSUPPORTED)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"{1,}\"; // Counted repetition operator must have a valid decimal",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('{')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_INVALID);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_DECIMAL_NO_DIGITS);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_DECIMAL_INVALID);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_MIN_UNCLOSED);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_COMMA_UNCLOSED);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_INVALID_RANGE);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"{1,}\"; // Counted repetition operator must have a valid decimal",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('{')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_INVALID);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_DECIMAL_NO_DIGITS);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_DECIMAL_INVALID);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_MIN_UNCLOSED);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_COMMA_UNCLOSED);",
          "    assert_eq!(parser.parse().unwrap_err().msg, ERR_COUNTED_REP_INVALID_RANGE);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"{0xG}\"; // Non-hex digit in hexadecimal number",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('{')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse(), Err(Error::new(ERR_HEX_BRACE_INVALID_DIGIT)));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let pattern = \"{0xG}\"; // Non-hex digit in hexadecimal number",
          "    ",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('{')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    ",
          "    let _ = parser.parse();",
          "    assert_eq!(parser.parse(), Err(Error::new(ERR_HEX_BRACE_INVALID_DIGIT)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]