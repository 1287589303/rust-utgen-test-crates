[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seen = {",
          "        let mut set = alloc::collections::BTreeSet::new();",
          "        set.insert(StateID(1));",
          "        set.insert(StateID(2));",
          "        set.insert(StateID(3));",
          "        Seen { set }",
          "    };",
          "",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "",
          "    let start_table = StartTable {",
          "        table: vec![0; 8 + 3 * 8], // 8 entries for the starts, 3 patterns with 8 IDs each, just as an example",
          "        kind: StartKind::Both,",
          "        start_map,",
          "        stride: 3,",
          "        pattern_len: Some(3),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(5),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(100),",
          "        max_match: StateID(200),",
          "        min_accel: StateID(300),",
          "        max_accel: StateID(400),",
          "        min_start: StateID(1),",
          "        max_start: StateID(3),",
          "    };",
          "",
          "    start_table.validate(&special, &seen).unwrap();",
          "}"
        ],
        "oracle": [
          "    let seen = Seen { set: alloc::collections::BTreeSet::new() };",
          "    seen.insert(StateID(1));",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "    let start_table = StartTable {",
          "    table: vec![0; 8 + 3 * 8],",
          "    kind: StartKind::Both,",
          "    start_map,",
          "    stride: 3,",
          "    pattern_len: Some(3),",
          "    universal_start_unanchored: None,",
          "    universal_start_anchored: None",
          "    };",
          "    let special = Special {",
          "    max: StateID(5),",
          "    quit_id: StateID(0),",
          "    min_match: StateID(100),",
          "    max_match: StateID(200),",
          "    min_accel: StateID(300),",
          "    max_accel: StateID(400),",
          "    min_start: StateID(1),",
          "    max_start: StateID(3)",
          "    };",
          "    start_table.validate(&special, &seen).unwrap();",
          "    seen.insert(StateID(2));",
          "    start_table.validate(&special, &seen).unwrap();",
          "    seen.insert(StateID(3));",
          "    start_table.validate(&special, &seen).unwrap();"
        ],
        "code": [
          "{",
          "    let seen = {",
          "        let mut set = alloc::collections::BTreeSet::new();",
          "        set.insert(StateID(1));",
          "        set.insert(StateID(2));",
          "        set.insert(StateID(3));",
          "        Seen { set }",
          "    };",
          "",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "",
          "    let start_table = StartTable {",
          "        table: vec![0; 8 + 3 * 8], // 8 entries for the starts, 3 patterns with 8 IDs each, just as an example",
          "        kind: StartKind::Both,",
          "        start_map,",
          "        stride: 3,",
          "        pattern_len: Some(3),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(5),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(100),",
          "        max_match: StateID(200),",
          "        min_accel: StateID(300),",
          "        max_accel: StateID(400),",
          "        min_start: StateID(1),",
          "        max_start: StateID(3),",
          "    };",
          "",
          "    start_table.validate(&special, &seen).unwrap();",
          "    let seen = Seen { set: alloc::collections::BTreeSet::new() };",
          "    seen.insert(StateID(1));",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "    let start_table = StartTable {",
          "    table: vec![0; 8 + 3 * 8],",
          "    kind: StartKind::Both,",
          "    start_map,",
          "    stride: 3,",
          "    pattern_len: Some(3),",
          "    universal_start_unanchored: None,",
          "    universal_start_anchored: None",
          "    };",
          "    let special = Special {",
          "    max: StateID(5),",
          "    quit_id: StateID(0),",
          "    min_match: StateID(100),",
          "    max_match: StateID(200),",
          "    min_accel: StateID(300),",
          "    max_accel: StateID(400),",
          "    min_start: StateID(1),",
          "    max_start: StateID(3)",
          "    };",
          "    start_table.validate(&special, &seen).unwrap();",
          "    seen.insert(StateID(2));",
          "    start_table.validate(&special, &seen).unwrap();",
          "    seen.insert(StateID(3));",
          "    start_table.validate(&special, &seen).unwrap();",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seen = Seen {",
          "        set: alloc::collections::BTreeSet::new(),",
          "    };",
          "",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "",
          "    let start_table = StartTable {",
          "        table: vec![0; 8], // Minimum 8 entries",
          "        kind: StartKind::Both,",
          "        start_map,",
          "        stride: 0,",
          "        pattern_len: None,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(0),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(0),",
          "        max_match: StateID(0),",
          "        min_accel: StateID(0),",
          "        max_accel: StateID(0),",
          "        min_start: StateID(0),",
          "        max_start: StateID(0),",
          "    };",
          "",
          "    start_table.validate(&special, &seen).unwrap();",
          "}"
        ],
        "oracle": [
          "    start_table.validate(&special, &seen).unwrap(); // Validates without errors when seen contains valid IDs and no match states exist.",
          "    let seen = Seen { set: alloc::collections::BTreeSet::new() }; // Valid witness for seen to show valid IDs.",
          "    let id = StateID(0); // A valid state ID that passes seen.contains(&id) check.",
          "    seen.insert(id); // Insert a valid ID into seen to satisfy precondition.",
          "    assert!(sp.is_match_state(id) == false); // Assert precondition that id is not a match state.",
          "    start_table.iter().next().is_some(); // Ensure precondition for the iterator iter() is true."
        ],
        "code": [
          "{",
          "    let seen = Seen {",
          "        set: alloc::collections::BTreeSet::new(),",
          "    };",
          "",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "",
          "    let start_table = StartTable {",
          "        table: vec![0; 8], // Minimum 8 entries",
          "        kind: StartKind::Both,",
          "        start_map,",
          "        stride: 0,",
          "        pattern_len: None,",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(0),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(0),",
          "        max_match: StateID(0),",
          "        min_accel: StateID(0),",
          "        max_accel: StateID(0),",
          "        min_start: StateID(0),",
          "        max_start: StateID(0),",
          "    };",
          "",
          "    start_table.validate(&special, &seen).unwrap();",
          "    start_table.validate(&special, &seen).unwrap(); // Validates without errors when seen contains valid IDs and no match states exist.",
          "    let seen = Seen { set: alloc::collections::BTreeSet::new() }; // Valid witness for seen to show valid IDs.",
          "    let id = StateID(0); // A valid state ID that passes seen.contains(&id) check.",
          "    seen.insert(id); // Insert a valid ID into seen to satisfy precondition.",
          "    assert!(sp.is_match_state(id) == false); // Assert precondition that id is not a match state.",
          "    start_table.iter().next().is_some(); // Ensure precondition for the iterator iter() is true.",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let seen = {",
          "        let mut set = alloc::collections::BTreeSet::new();",
          "        set.insert(StateID(1));",
          "        set.insert(StateID(2));",
          "        set.insert(StateID(3));",
          "        set.insert(StateID(4));",
          "        Seen { set }",
          "    };",
          "",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "",
          "    let start_table = StartTable {",
          "        table: vec![0; 8 + 4 * 8],",
          "        kind: StartKind::Both,",
          "        start_map,",
          "        stride: 4,",
          "        pattern_len: Some(4),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(5),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(2),",
          "        min_accel: StateID(3),",
          "        max_accel: StateID(4),",
          "        min_start: StateID(0),",
          "        max_start: StateID(2),",
          "    };",
          "",
          "    start_table.validate(&special, &seen).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(start_table.iter().all(|(id, _, _)| seen.contains(&id)));",
          "    assert!(start_table.iter().all(|(id, _, _)| !special.is_match_state(id)));",
          "    assert_eq!(start_table.validate(&special, &seen), Ok(()));",
          "    assert!(start_table.iter().next().is_none());",
          "    assert!(seen.contains(&StateID(1)));",
          "    assert!(seen.contains(&StateID(2)));",
          "    assert!(seen.contains(&StateID(3)));",
          "    assert!(seen.contains(&StateID(4)));",
          "    assert!(!special.is_match_state(StateID(3)));",
          "    assert!(!special.is_match_state(StateID(4)));",
          "    assert_eq!(start_table.len(), 8 + 4 * 8);"
        ],
        "code": [
          "{",
          "    let seen = {",
          "        let mut set = alloc::collections::BTreeSet::new();",
          "        set.insert(StateID(1));",
          "        set.insert(StateID(2));",
          "        set.insert(StateID(3));",
          "        set.insert(StateID(4));",
          "        Seen { set }",
          "    };",
          "",
          "    let start_map = StartByteMap { map: [Start::NonWordByte; 256] };",
          "",
          "    let start_table = StartTable {",
          "        table: vec![0; 8 + 4 * 8],",
          "        kind: StartKind::Both,",
          "        start_map,",
          "        stride: 4,",
          "        pattern_len: Some(4),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(5),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(2),",
          "        min_accel: StateID(3),",
          "        max_accel: StateID(4),",
          "        min_start: StateID(0),",
          "        max_start: StateID(2),",
          "    };",
          "",
          "    start_table.validate(&special, &seen).unwrap();",
          "    assert!(start_table.iter().all(|(id, _, _)| seen.contains(&id)));",
          "    assert!(start_table.iter().all(|(id, _, _)| !special.is_match_state(id)));",
          "    assert_eq!(start_table.validate(&special, &seen), Ok(()));",
          "    assert!(start_table.iter().next().is_none());",
          "    assert!(seen.contains(&StateID(1)));",
          "    assert!(seen.contains(&StateID(2)));",
          "    assert!(seen.contains(&StateID(3)));",
          "    assert!(seen.contains(&StateID(4)));",
          "    assert!(!special.is_match_state(StateID(3)));",
          "    assert!(!special.is_match_state(StateID(4)));",
          "    assert_eq!(start_table.len(), 8 + 4 * 8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]