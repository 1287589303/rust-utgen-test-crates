[
  {
    "uses": [
      "use crate::util::wire::NativeEndian;",
      "use crate::util::wire::LittleEndian;",
      "use crate::util::wire::BigEndian;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::util::wire::LittleEndian;",
          "    let flags = Flags {",
          "        has_empty: true,",
          "        is_utf8: true,",
          "        is_always_start_anchored: false,",
          "    };",
          "    let transitions = Transitions {",
          "        sparse: vec![0; 10],",
          "        classes: ByteClasses::new(),",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "    let start_table = StartTable {",
          "        table: vec![0u8; 20],",
          "        kind: StartKind::Both,",
          "        start_map: StartByteMap::new(),",
          "        stride: 4,",
          "        pattern_len: Some(1),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "    let special = Special {",
          "        max: 5,",
          "        quit_id: 1,",
          "        min_match: 0,",
          "        max_match: 2,",
          "        min_accel: 2,",
          "        max_accel: 4,",
          "        min_start: 0,",
          "        max_start: 3,",
          "    };",
          "    let quitset = ByteSet::empty();",
          "    ",
          "    let dfa = DFA {",
          "        tt: transitions,",
          "        st: start_table,",
          "        special,",
          "        pre: None,",
          "        quitset,",
          "        flags,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; 100];",
          "    let result = dfa.write_to::<LittleEndian>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert!(wire::write_label(LABEL, &mut buffer[..]).is_ok());",
          "    assert!(wire::write_endianness_check::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(wire::write_version::<LittleEndian>(VERSION, &mut buffer[..]).is_ok());",
          "    assert!(flags.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.tt.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.st.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.special.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.quitset.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert_eq!(result, Ok(buffer.len()));"
        ],
        "code": [
          "{",
          "    use crate::util::wire::LittleEndian;",
          "    let flags = Flags {",
          "        has_empty: true,",
          "        is_utf8: true,",
          "        is_always_start_anchored: false,",
          "    };",
          "    let transitions = Transitions {",
          "        sparse: vec![0; 10],",
          "        classes: ByteClasses::new(),",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "    let start_table = StartTable {",
          "        table: vec![0u8; 20],",
          "        kind: StartKind::Both,",
          "        start_map: StartByteMap::new(),",
          "        stride: 4,",
          "        pattern_len: Some(1),",
          "        universal_start_unanchored: None,",
          "        universal_start_anchored: None,",
          "    };",
          "    let special = Special {",
          "        max: 5,",
          "        quit_id: 1,",
          "        min_match: 0,",
          "        max_match: 2,",
          "        min_accel: 2,",
          "        max_accel: 4,",
          "        min_start: 0,",
          "        max_start: 3,",
          "    };",
          "    let quitset = ByteSet::empty();",
          "    ",
          "    let dfa = DFA {",
          "        tt: transitions,",
          "        st: start_table,",
          "        special,",
          "        pre: None,",
          "        quitset,",
          "        flags,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; 100];",
          "    let result = dfa.write_to::<LittleEndian>(&mut buffer);",
          "    assert!(wire::write_label(LABEL, &mut buffer[..]).is_ok());",
          "    assert!(wire::write_endianness_check::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(wire::write_version::<LittleEndian>(VERSION, &mut buffer[..]).is_ok());",
          "    assert!(flags.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.tt.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.st.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.special.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert!(dfa.quitset.write_to::<LittleEndian>(&mut buffer[..]).is_ok());",
          "    assert_eq!(result, Ok(buffer.len()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::util::wire::BigEndian;",
          "    let flags = Flags {",
          "        has_empty: false,",
          "        is_utf8: false,",
          "        is_always_start_anchored: true,",
          "    };",
          "    let transitions = Transitions {",
          "        sparse: vec![1; 15],",
          "        classes: ByteClasses::new(),",
          "        state_len: 2,",
          "        pattern_len: 3,",
          "    };",
          "    let start_table = StartTable {",
          "        table: vec![0u8; 40],",
          "        kind: StartKind::Unanchored,",
          "        start_map: StartByteMap::new(),",
          "        stride: 5,",
          "        pattern_len: Some(2),",
          "        universal_start_unanchored: Some(3),",
          "        universal_start_anchored: None,",
          "    };",
          "    let special = Special {",
          "        max: 6,",
          "        quit_id: 2,",
          "        min_match: 1,",
          "        max_match: 3,",
          "        min_accel: 2,",
          "        max_accel: 5,",
          "        min_start: 1,",
          "        max_start: 4,",
          "    };",
          "    let quitset = ByteSet::empty();",
          "    ",
          "    let dfa = DFA {",
          "        tt: transitions,",
          "        st: start_table,",
          "        special,",
          "        pre: None,",
          "        quitset,",
          "        flags,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; 100];",
          "    let result = dfa.write_to::<BigEndian>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), buffer.len());",
          "    assert_eq!(buffer[0..LABEL.len()], LABEL.as_bytes());",
          "    assert_eq!(buffer[LABEL.len()..LABEL.len() + 4], &[0xFE, 0xFF, 0, 0]); // endian check for BigEndian",
          "    assert_eq!(buffer[LABEL.len() + 4..LABEL.len() + 8], &VERSION.to_le_bytes()); // version check",
          "    assert_eq!(buffer[LABEL.len() + 8], 0); // check the unused byte",
          "    // Flags validation",
          "    assert_eq!(buffer[LABEL.len() + 12..LABEL.len() + 16], &0b00000100u32.to_le_bytes()); // flags",
          "    // Transition validation",
          "    assert_eq!(buffer[LABEL.len() + 16..LABEL.len() + 16 + transitions.sparse.len()], transitions.sparse); // transitions",
          "    // Start table validation",
          "    assert_eq!(buffer[LABEL.len() + 16 + transitions.sparse.len()..], start_table.table); // start table",
          "    // Special validation",
          "    assert_eq!(buffer[LABEL.len() + 16 + transitions.sparse.len() + start_table.table.len()..].len(), special.write_to_len()); // validate remaining for special states",
          "    assert_eq!(buffer[LABEL.len() + 16 + transitions.sparse.len() + start_table.table.len() + special.write_to_len()..].len(), quitset.write_to_len()); // validate remaining for quitset"
        ],
        "code": [
          "{",
          "    use crate::util::wire::BigEndian;",
          "    let flags = Flags {",
          "        has_empty: false,",
          "        is_utf8: false,",
          "        is_always_start_anchored: true,",
          "    };",
          "    let transitions = Transitions {",
          "        sparse: vec![1; 15],",
          "        classes: ByteClasses::new(),",
          "        state_len: 2,",
          "        pattern_len: 3,",
          "    };",
          "    let start_table = StartTable {",
          "        table: vec![0u8; 40],",
          "        kind: StartKind::Unanchored,",
          "        start_map: StartByteMap::new(),",
          "        stride: 5,",
          "        pattern_len: Some(2),",
          "        universal_start_unanchored: Some(3),",
          "        universal_start_anchored: None,",
          "    };",
          "    let special = Special {",
          "        max: 6,",
          "        quit_id: 2,",
          "        min_match: 1,",
          "        max_match: 3,",
          "        min_accel: 2,",
          "        max_accel: 5,",
          "        min_start: 1,",
          "        max_start: 4,",
          "    };",
          "    let quitset = ByteSet::empty();",
          "    ",
          "    let dfa = DFA {",
          "        tt: transitions,",
          "        st: start_table,",
          "        special,",
          "        pre: None,",
          "        quitset,",
          "        flags,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; 100];",
          "    let result = dfa.write_to::<BigEndian>(&mut buffer);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert_eq!(result.unwrap(), buffer.len());",
          "    assert_eq!(buffer[0..LABEL.len()], LABEL.as_bytes());",
          "    assert_eq!(buffer[LABEL.len()..LABEL.len() + 4], &[0xFE, 0xFF, 0, 0]); // endian check for BigEndian",
          "    assert_eq!(buffer[LABEL.len() + 4..LABEL.len() + 8], &VERSION.to_le_bytes()); // version check",
          "    assert_eq!(buffer[LABEL.len() + 8], 0); // check the unused byte",
          "    // Flags validation",
          "    assert_eq!(buffer[LABEL.len() + 12..LABEL.len() + 16], &0b00000100u32.to_le_bytes()); // flags",
          "    // Transition validation",
          "    assert_eq!(buffer[LABEL.len() + 16..LABEL.len() + 16 + transitions.sparse.len()], transitions.sparse); // transitions",
          "    // Start table validation",
          "    assert_eq!(buffer[LABEL.len() + 16 + transitions.sparse.len()..], start_table.table); // start table",
          "    // Special validation",
          "    assert_eq!(buffer[LABEL.len() + 16 + transitions.sparse.len() + start_table.table.len()..].len(), special.write_to_len()); // validate remaining for special states",
          "    assert_eq!(buffer[LABEL.len() + 16 + transitions.sparse.len() + start_table.table.len() + special.write_to_len()..].len(), quitset.write_to_len()); // validate remaining for quitset",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::util::wire::NativeEndian;",
          "    let flags = Flags {",
          "        has_empty: true,",
          "        is_utf8: false,",
          "        is_always_start_anchored: true,",
          "    };",
          "    let transitions = Transitions {",
          "        sparse: vec![2; 12],",
          "        classes: ByteClasses::new(),",
          "        state_len: 3,",
          "        pattern_len: 2,",
          "    };",
          "    let start_table = StartTable {",
          "        table: vec![0u8; 30],",
          "        kind: StartKind::Anchored,",
          "        start_map: StartByteMap::new(),",
          "        stride: 3,",
          "        pattern_len: None,",
          "        universal_start_unanchored: Some(2),",
          "        universal_start_anchored: None,",
          "    };",
          "    let special = Special {",
          "        max: 7,",
          "        quit_id: 3,",
          "        min_match: 0,",
          "        max_match: 5,",
          "        min_accel: 3,",
          "        max_accel: 6,",
          "        min_start: 2,",
          "        max_start: 5,",
          "    };",
          "    let quitset = ByteSet::empty();",
          "    ",
          "    let dfa = DFA {",
          "        tt: transitions,",
          "        st: start_table,",
          "        special,",
          "        pre: None,",
          "        quitset,",
          "        flags,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; 100];",
          "    let result = dfa.write_to::<NativeEndian>(&mut buffer);",
          "}"
        ],
        "oracle": [
          "    wire::write_label(LABEL, &mut buffer[..]).is_ok();",
          "    wire::write_endianness_check::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    wire::write_version::<NativeEndian>(VERSION, &mut buffer[..]).is_ok();",
          "    dfa.flags.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.tt.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.st.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.special.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.quitset.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    result.unwrap().eq(&expected_length);"
        ],
        "code": [
          "{",
          "    use crate::util::wire::NativeEndian;",
          "    let flags = Flags {",
          "        has_empty: true,",
          "        is_utf8: false,",
          "        is_always_start_anchored: true,",
          "    };",
          "    let transitions = Transitions {",
          "        sparse: vec![2; 12],",
          "        classes: ByteClasses::new(),",
          "        state_len: 3,",
          "        pattern_len: 2,",
          "    };",
          "    let start_table = StartTable {",
          "        table: vec![0u8; 30],",
          "        kind: StartKind::Anchored,",
          "        start_map: StartByteMap::new(),",
          "        stride: 3,",
          "        pattern_len: None,",
          "        universal_start_unanchored: Some(2),",
          "        universal_start_anchored: None,",
          "    };",
          "    let special = Special {",
          "        max: 7,",
          "        quit_id: 3,",
          "        min_match: 0,",
          "        max_match: 5,",
          "        min_accel: 3,",
          "        max_accel: 6,",
          "        min_start: 2,",
          "        max_start: 5,",
          "    };",
          "    let quitset = ByteSet::empty();",
          "    ",
          "    let dfa = DFA {",
          "        tt: transitions,",
          "        st: start_table,",
          "        special,",
          "        pre: None,",
          "        quitset,",
          "        flags,",
          "    };",
          "    ",
          "    let mut buffer = vec![0; 100];",
          "    let result = dfa.write_to::<NativeEndian>(&mut buffer);",
          "    wire::write_label(LABEL, &mut buffer[..]).is_ok();",
          "    wire::write_endianness_check::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    wire::write_version::<NativeEndian>(VERSION, &mut buffer[..]).is_ok();",
          "    dfa.flags.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.tt.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.st.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.special.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    dfa.quitset.write_to::<NativeEndian>(&mut buffer[..]).is_ok();",
          "    result.unwrap().eq(&expected_length);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]