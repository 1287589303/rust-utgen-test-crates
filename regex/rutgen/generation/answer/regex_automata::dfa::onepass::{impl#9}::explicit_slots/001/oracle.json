[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![],",
          "        explicit_slot_len: 0,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "}"
        ],
        "oracle": [
          "    let mut cache = Cache {",
          "    explicit_slots: vec![None; 5],",
          "    explicit_slot_len: 5,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 5);",
          "    assert!(slots.iter().all(|slot| slot.is_none()));",
          "    ",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 3],",
          "    explicit_slot_len: 3,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 3);",
          "    assert!(slots.iter().all(|slot| slot.is_some()));",
          "    ",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())); 0],",
          "    explicit_slot_len: 0,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 0);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![],",
          "        explicit_slot_len: 0,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![None; 5],",
          "    explicit_slot_len: 5,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 5);",
          "    assert!(slots.iter().all(|slot| slot.is_none()));",
          "    ",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(NonMaxUsize(NonZeroUsize::new(1).unwrap())); 3],",
          "    explicit_slot_len: 3,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 3);",
          "    assert!(slots.iter().all(|slot| slot.is_some()));",
          "    ",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(NonMaxUsize(NonZeroUsize::new(2).unwrap())); 0],",
          "    explicit_slot_len: 0,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let non_max_usize = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![Some(non_max_usize)],",
          "        explicit_slot_len: 1,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "}"
        ],
        "oracle": [
          "    let non_max_usize = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(non_max_usize)],",
          "    explicit_slot_len: 1,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 1);",
          "    assert!(slots[0].is_some());",
          "    assert_eq!(slots[0], Some(non_max_usize));",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    cache.explicit_slots()[0] = Some(non_max_usize2);",
          "    assert_eq!(cache.explicit_slots()[0], Some(non_max_usize2));"
        ],
        "code": [
          "{",
          "    let non_max_usize = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![Some(non_max_usize)],",
          "        explicit_slot_len: 1,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    let non_max_usize = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(non_max_usize)],",
          "    explicit_slot_len: 1,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 1);",
          "    assert!(slots[0].is_some());",
          "    assert_eq!(slots[0], Some(non_max_usize));",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    cache.explicit_slots()[0] = Some(non_max_usize2);",
          "    assert_eq!(cache.explicit_slots()[0], Some(non_max_usize2));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2)],",
          "        explicit_slot_len: 2,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "}"
        ],
        "oracle": [
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let mut cache = Cache { explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2)], explicit_slot_len: 2 };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 2);",
          "    assert_eq!(slots[0], Some(non_max_usize1));",
          "    assert_eq!(slots[1], Some(non_max_usize2));",
          "    assert!(std::ptr::eq(slots.as_mut_ptr(), cache.explicit_slots.as_mut_ptr()));",
          "    cache.explicit_slot_len = 1;",
          "    let slots_after_update = cache.explicit_slots();",
          "    assert_eq!(slots_after_update.len(), 1);",
          "    assert_eq!(slots_after_update[0], Some(non_max_usize1));"
        ],
        "code": [
          "{",
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2)],",
          "        explicit_slot_len: 2,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let mut cache = Cache { explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2)], explicit_slot_len: 2 };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 2);",
          "    assert_eq!(slots[0], Some(non_max_usize1));",
          "    assert_eq!(slots[1], Some(non_max_usize2));",
          "    assert!(std::ptr::eq(slots.as_mut_ptr(), cache.explicit_slots.as_mut_ptr()));",
          "    cache.explicit_slot_len = 1;",
          "    let slots_after_update = cache.explicit_slots();",
          "    assert_eq!(slots_after_update.len(), 1);",
          "    assert_eq!(slots_after_update[0], Some(non_max_usize1));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let non_max_usize3 = NonMaxUsize(NonZeroUsize::new(3).unwrap());",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2), Some(non_max_usize3)],",
          "        explicit_slot_len: 3,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "}"
        ],
        "oracle": [
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let non_max_usize3 = NonMaxUsize(NonZeroUsize::new(3).unwrap());",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2), Some(non_max_usize3)],",
          "    explicit_slot_len: 3,",
          "    };",
          "    assert_eq!(cache.explicit_slots().len(), 3);",
          "    assert_eq!(cache.explicit_slots()[0], Some(non_max_usize1));",
          "    assert_eq!(cache.explicit_slots()[1], Some(non_max_usize2));",
          "    assert_eq!(cache.explicit_slots()[2], Some(non_max_usize3));"
        ],
        "code": [
          "{",
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let non_max_usize3 = NonMaxUsize(NonZeroUsize::new(3).unwrap());",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2), Some(non_max_usize3)],",
          "        explicit_slot_len: 3,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    let non_max_usize1 = NonMaxUsize(NonZeroUsize::new(1).unwrap());",
          "    let non_max_usize2 = NonMaxUsize(NonZeroUsize::new(2).unwrap());",
          "    let non_max_usize3 = NonMaxUsize(NonZeroUsize::new(3).unwrap());",
          "    let mut cache = Cache {",
          "    explicit_slots: vec![Some(non_max_usize1), Some(non_max_usize2), Some(non_max_usize3)],",
          "    explicit_slot_len: 3,",
          "    };",
          "    assert_eq!(cache.explicit_slots().len(), 3);",
          "    assert_eq!(cache.explicit_slots()[0], Some(non_max_usize1));",
          "    assert_eq!(cache.explicit_slots()[1], Some(non_max_usize2));",
          "    assert_eq!(cache.explicit_slots()[2], Some(non_max_usize3));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 10],",
          "        explicit_slot_len: 10,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "}"
        ],
        "oracle": [
          "    let mut cache = Cache { explicit_slots: vec![None; 10], explicit_slot_len: 10 };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 10);",
          "    assert_eq!(slots[0], None);",
          "    assert_eq!(slots[1], None);",
          "    assert_eq!(slots[2], None);",
          "    assert_eq!(slots[3], None);",
          "    assert_eq!(slots[4], None);",
          "    assert_eq!(slots[5], None);",
          "    assert_eq!(slots[6], None);",
          "    assert_eq!(slots[7], None);",
          "    assert_eq!(slots[8], None);",
          "    assert_eq!(slots[9], None);"
        ],
        "code": [
          "{",
          "    let mut cache = Cache {",
          "        explicit_slots: vec![None; 10],",
          "        explicit_slot_len: 10,",
          "    };",
          "    let slots = cache.explicit_slots();",
          "    let mut cache = Cache { explicit_slots: vec![None; 10], explicit_slot_len: 10 };",
          "    let slots = cache.explicit_slots();",
          "    assert_eq!(slots.len(), 10);",
          "    assert_eq!(slots[0], None);",
          "    assert_eq!(slots[1], None);",
          "    assert_eq!(slots[2], None);",
          "    assert_eq!(slots[3], None);",
          "    assert_eq!(slots[4], None);",
          "    assert_eq!(slots[5], None);",
          "    assert_eq!(slots[6], None);",
          "    assert_eq!(slots[7], None);",
          "    assert_eq!(slots[8], None);",
          "    assert_eq!(slots[9], None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]