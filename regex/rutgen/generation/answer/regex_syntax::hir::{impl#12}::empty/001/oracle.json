[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges().len(), 0);",
          "    assert!(class_unicode.is_ascii() == false);",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "    assert_eq!(class_unicode.ranges().len(), 0);",
          "    assert!(class_unicode.is_ascii() == false);",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_class_unicode = ClassUnicode::new(vec![]);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(empty_class_unicode, ClassUnicode::empty());",
          "    assert!(empty_class_unicode.iter().next().is_none());",
          "    assert_eq!(empty_class_unicode.ranges().len(), 0);",
          "    assert!(!empty_class_unicode.is_ascii());",
          "    assert_eq!(empty_class_unicode.minimum_len(), None);",
          "    assert_eq!(empty_class_unicode.maximum_len(), None);",
          "    assert_eq!(empty_class_unicode.literal(), None);",
          "    assert_eq!(empty_class_unicode.to_byte_class(), None);"
        ],
        "code": [
          "{",
          "    let empty_class_unicode = ClassUnicode::new(vec![]);",
          "    assert_eq!(empty_class_unicode, ClassUnicode::empty());",
          "    assert!(empty_class_unicode.iter().next().is_none());",
          "    assert_eq!(empty_class_unicode.ranges().len(), 0);",
          "    assert!(!empty_class_unicode.is_ascii());",
          "    assert_eq!(empty_class_unicode.minimum_len(), None);",
          "    assert_eq!(empty_class_unicode.maximum_len(), None);",
          "    assert_eq!(empty_class_unicode.literal(), None);",
          "    assert_eq!(empty_class_unicode.to_byte_class(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut class_unicode = ClassUnicode::empty();",
          "    class_unicode.push(ClassUnicodeRange { start: 'a', end: 'a' });",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges(), &[]);",
          "    class_unicode.case_fold_simple();",
          "    assert!(class_unicode.is_ascii());",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);",
          "    assert!(class_unicode.to_byte_class().is_none());"
        ],
        "code": [
          "{",
          "    let mut class_unicode = ClassUnicode::empty();",
          "    class_unicode.push(ClassUnicodeRange { start: 'a', end: 'a' });",
          "    assert_eq!(class_unicode.ranges(), &[]);",
          "    class_unicode.case_fold_simple();",
          "    assert!(class_unicode.is_ascii());",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);",
          "    assert!(class_unicode.to_byte_class().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "    let iter = class_unicode.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_unicode.ranges().len(), 0);",
          "    assert!(!class_unicode.is_ascii());",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);",
          "    assert_eq!(class_unicode.to_byte_class(), None);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "    let iter = class_unicode.iter();",
          "    assert_eq!(class_unicode.ranges().len(), 0);",
          "    assert!(!class_unicode.is_ascii());",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);",
          "    assert_eq!(class_unicode.to_byte_class(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "    let ranges = class_unicode.ranges();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ranges.len(), 0);",
          "    assert!(class_unicode.is_ascii());",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);",
          "    assert_eq!(class_unicode.to_byte_class(), None);"
        ],
        "code": [
          "{",
          "    let class_unicode = ClassUnicode::empty();",
          "    let ranges = class_unicode.ranges();",
          "    assert_eq!(ranges.len(), 0);",
          "    assert!(class_unicode.is_ascii());",
          "    assert_eq!(class_unicode.minimum_len(), None);",
          "    assert_eq!(class_unicode.maximum_len(), None);",
          "    assert_eq!(class_unicode.literal(), None);",
          "    assert_eq!(class_unicode.to_byte_class(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]