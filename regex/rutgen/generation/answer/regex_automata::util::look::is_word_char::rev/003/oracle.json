[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"\";",
          "    let at: usize = 0;",
          "    let _ = super::rev(haystack, at);",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"\";",
          "    let at: usize = 0;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"\\xFF\";",
          "    let at: usize = 1;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abc\";",
          "    let at: usize = 1;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"\\xC0\\xAF\";",
          "    let at: usize = 2;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"\\xEF\\xBF\\xBD\";",
          "    let at: usize = 3;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"\";",
          "    let at: usize = 0;",
          "    let _ = super::rev(haystack, at);",
          "    let haystack: &[u8] = b\"\";",
          "    let at: usize = 0;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"\\xFF\";",
          "    let at: usize = 1;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abc\";",
          "    let at: usize = 1;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"\\xC0\\xAF\";",
          "    let at: usize = 2;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"\\xEF\\xBF\\xBD\";",
          "    let at: usize = 3;",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"\\x80\"; // non-leading byte",
          "    let at: usize = 1;",
          "    let _ = super::rev(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(super::rev(haystack, at), Ok(false));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"\\x80\"; // non-leading byte",
          "    let at: usize = 1;",
          "    let _ = super::rev(haystack, at);",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"abc\\x80\"; // last byte is a non-leading byte",
          "    let at: usize = 4; // length of haystack",
          "    let _ = super::rev(haystack, at);",
          "}"
        ],
        "oracle": [
          "    Result::Ok(false)",
          "    Result::Ok(true)",
          "    Result::Err(super::UnicodeWordBoundaryError::new())",
          "    Result::Ok(false)",
          "    Result::Ok(true)",
          "    Result::Ok(false)"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"abc\\x80\"; // last byte is a non-leading byte",
          "    let at: usize = 4; // length of haystack",
          "    let _ = super::rev(haystack, at);",
          "    Result::Ok(false)",
          "    Result::Ok(true)",
          "    Result::Err(super::UnicodeWordBoundaryError::new())",
          "    Result::Ok(false)",
          "    Result::Ok(true)",
          "    Result::Ok(false)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"\\x80\\x80\"; // two non-leading bytes",
          "    let at: usize = 2; // length of haystack",
          "    let _ = super::rev(haystack, at);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at: usize = 0; // index at 0",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    let haystack: &[u8] = b\"\\xFF\"; // one non-leading byte",
          "    let at: usize = 1; // index at 1",
          "    assert_eq!(super::rev(haystack, at), Ok(false));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"\\x80\\x80\"; // two non-leading bytes",
          "    let at: usize = 2; // length of haystack",
          "    let _ = super::rev(haystack, at);",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    let haystack: &[u8] = b\"\"; // empty haystack",
          "    let at: usize = 0; // index at 0",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    let haystack: &[u8] = b\"\\xFF\"; // one non-leading byte",
          "    let at: usize = 1; // index at 1",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let haystack: &[u8] = b\"abc\\x80\"; // last byte is a non-leading byte",
          "    let at: usize = 3;  // third byte, valid byte but not leading",
          "    let _ = super::rev(haystack, at);",
          "}"
        ],
        "oracle": [
          "    let haystack: &[u8] = b\"\"; // empty input resulting in utf8::decode_last(&haystack[..at]) being None",
          "    let at: usize = 0; // at should be 0 when haystack is empty",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abc\\xff\"; // last byte is invalid, leading to utf8::decode_last(&haystack[..at]) matching Some(Err(_))",
          "    let at: usize = 3; // valid at position",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abc\"; // proper utf-8 sequence with no errors",
          "    let at: usize = 2; // pointing to valid character",
          "    // This tests valid utf-8 leading character when at is correctly aligned with character boundaries.",
          "    assert_eq!(super::rev(haystack, at), Ok(true));",
          "    ",
          "    let haystack: &[u8] = b\"abc\\x80\"; // non-leading byte",
          "    let at: usize = 3; // should match utf8::decode_last with Some(Err(_))",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abcdefgh\"; // clear utf-8, at should align within valid character",
          "    let at: usize = 8; // last position within bounds",
          "    assert_eq!(super::rev(haystack, at), Ok(false));"
        ],
        "code": [
          "{",
          "    let haystack: &[u8] = b\"abc\\x80\"; // last byte is a non-leading byte",
          "    let at: usize = 3;  // third byte, valid byte but not leading",
          "    let _ = super::rev(haystack, at);",
          "    let haystack: &[u8] = b\"\"; // empty input resulting in utf8::decode_last(&haystack[..at]) being None",
          "    let at: usize = 0; // at should be 0 when haystack is empty",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abc\\xff\"; // last byte is invalid, leading to utf8::decode_last(&haystack[..at]) matching Some(Err(_))",
          "    let at: usize = 3; // valid at position",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abc\"; // proper utf-8 sequence with no errors",
          "    let at: usize = 2; // pointing to valid character",
          "    // This tests valid utf-8 leading character when at is correctly aligned with character boundaries.",
          "    assert_eq!(super::rev(haystack, at), Ok(true));",
          "    ",
          "    let haystack: &[u8] = b\"abc\\x80\"; // non-leading byte",
          "    let at: usize = 3; // should match utf8::decode_last with Some(Err(_))",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "    ",
          "    let haystack: &[u8] = b\"abcdefgh\"; // clear utf-8, at should align within valid character",
          "    let at: usize = 8; // last position within bounds",
          "    assert_eq!(super::rev(haystack, at), Ok(false));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]