[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
          "    };",
          "    ",
          "    captures.set_pattern(Some(PatternID(SmallIndex::new(0))));",
          "    let is_match = captures.pid.is_some();",
          "    let pattern_id = captures.pid;",
          "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
          "}"
        ],
        "oracle": [
          "    assert!(is_match);",
          "    assert!(pattern_id.is_some());",
          "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
          "    ",
          "    captures.set_pattern(None);",
          "    let is_match_after_none = captures.pid.is_some();",
          "    let pattern_id_after_none = captures.pid;",
          "    let slots_after_none: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
          "    ",
          "    assert!(!is_match_after_none);",
          "    assert!(pattern_id_after_none.is_none());",
          "    assert_eq!(slots_after_none, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);"
        ],
        "code": [
          "{",
          "    let mut captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: None,",
          "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
          "    };",
          "    ",
          "    captures.set_pattern(Some(PatternID(SmallIndex::new(0))));",
          "    let is_match = captures.pid.is_some();",
          "    let pattern_id = captures.pid;",
          "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
          "    assert!(is_match);",
          "    assert!(pattern_id.is_some());",
          "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
          "    ",
          "    captures.set_pattern(None);",
          "    let is_match_after_none = captures.pid.is_some();",
          "    let pattern_id_after_none = captures.pid;",
          "    let slots_after_none: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
          "    ",
          "    assert!(!is_match_after_none);",
          "    assert!(pattern_id_after_none.is_none());",
          "    assert_eq!(slots_after_none, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: Some(PatternID(SmallIndex::new(0))),",
          "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
          "    };",
          "",
          "    captures.set_pattern(None);",
          "    let is_match = captures.pid.is_none();",
          "    let pattern_id = captures.pid;",
          "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
          "}"
        ],
        "oracle": [
          "    assert!(is_match);",
          "    assert!(pattern_id.is_none());",
          "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);"
        ],
        "code": [
          "{",
          "    let mut captures = Captures {",
          "        group_info: GroupInfo::default(),",
          "        pid: Some(PatternID(SmallIndex::new(0))),",
          "        slots: vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6],",
          "    };",
          "",
          "    captures.set_pattern(None);",
          "    let is_match = captures.pid.is_none();",
          "    let pattern_id = captures.pid;",
          "    let slots: Vec<Option<NonMaxUsize>> = captures.slots().to_vec();",
          "    assert!(is_match);",
          "    assert!(pattern_id.is_none());",
          "    assert_eq!(slots, vec![Some(NonMaxUsize(NonZeroUsize::new(0).unwrap())); 6]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]