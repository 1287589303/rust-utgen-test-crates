[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags {",
          "            case_insensitive: false,",
          "            multi_line: false,",
          "            dot_matches_new_line: false,",
          "            swap_greed: false,",
          "            crlf: false,",
          "            ignore_whitespace: false,",
          "        },",
          "    };",
          "    let pattern = \"\\\\S\"; // Input pattern with uppercase 'S'",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('S')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    parser.parse_perl_class(); // Call under test",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char.get(), Some('S'));",
          "    assert_eq!(parser.pos.get(), 1);",
          "    assert_eq!(parser.flags.borrow().case_insensitive, false);",
          "    assert_eq!(parser.flags.borrow().multi_line, false);",
          "    assert_eq!(parser.flags.borrow().dot_matches_new_line, false);",
          "    assert_eq!(parser.flags.borrow().swap_greed, false);",
          "    assert_eq!(parser.flags.borrow().crlf, false);",
          "    assert_eq!(parser.flags.borrow().ignore_whitespace, false);",
          "    assert_eq!(parser.capture_index.get(), 0);",
          "    assert!(matches!(parser.capture_names.borrow().len(), 0));",
          "    assert!(parser.parse_perl_class().is_ok());",
          "    let hir_result = parser.parse_perl_class().unwrap();",
          "    assert_eq!(hir_result.kind(), &HirKind::Class(hir::Class::new(vec![hir::ClassRange { start: '0', end: '9' }])));",
          "    assert!(hir_result.is_start_anchored());",
          "    assert!(!hir_result.is_match_empty());",
          "    assert_eq!(hir_result.static_explicit_captures_len(), Some(0));"
        ],
        "code": [
          "{",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags {",
          "            case_insensitive: false,",
          "            multi_line: false,",
          "            dot_matches_new_line: false,",
          "            swap_greed: false,",
          "            crlf: false,",
          "            ignore_whitespace: false,",
          "        },",
          "    };",
          "    let pattern = \"\\\\S\"; // Input pattern with uppercase 'S'",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('S')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    parser.parse_perl_class(); // Call under test",
          "    assert_eq!(parser.char.get(), Some('S'));",
          "    assert_eq!(parser.pos.get(), 1);",
          "    assert_eq!(parser.flags.borrow().case_insensitive, false);",
          "    assert_eq!(parser.flags.borrow().multi_line, false);",
          "    assert_eq!(parser.flags.borrow().dot_matches_new_line, false);",
          "    assert_eq!(parser.flags.borrow().swap_greed, false);",
          "    assert_eq!(parser.flags.borrow().crlf, false);",
          "    assert_eq!(parser.flags.borrow().ignore_whitespace, false);",
          "    assert_eq!(parser.capture_index.get(), 0);",
          "    assert!(matches!(parser.capture_names.borrow().len(), 0));",
          "    assert!(parser.parse_perl_class().is_ok());",
          "    let hir_result = parser.parse_perl_class().unwrap();",
          "    assert_eq!(hir_result.kind(), &HirKind::Class(hir::Class::new(vec![hir::ClassRange { start: '0', end: '9' }])));",
          "    assert!(hir_result.is_start_anchored());",
          "    assert!(!hir_result.is_match_empty());",
          "    assert_eq!(hir_result.static_explicit_captures_len(), Some(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags {",
          "            case_insensitive: false,",
          "            multi_line: false,",
          "            dot_matches_new_line: false,",
          "            swap_greed: false,",
          "            crlf: false,",
          "            ignore_whitespace: false,",
          "        },",
          "    };",
          "    let pattern = \"\\\\s\"; // Input pattern with lowercase 's'",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('s')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    parser.parse_perl_class(); // Call under test",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char.get(), Some('s')); // Verify char is 's'",
          "    assert_eq!(parser.pos.get(), 1); // Verify position is incremented after bump",
          "    assert!(parser.capture_index.get() == 0); // Ensure capture index remains unchanged",
          "    assert!(parser.flags.borrow().case_insensitive == false); // Confirm flags are unchanged",
          "    let class = parser.parse_perl_class(); // Execute parse_perl_class",
          "    assert_eq!(class.kind(), &HirKind::Class(hir::Class { ranges: vec![hir::ClassRange { start: ' ', end: ' ' }] })); // Validate class ranges for '\\s'",
          "    assert!(matches!(class.is_start_anchored(), false)); // Confirm starting anchor is false",
          "    assert!(matches!(class.is_match_empty(), false)); // Confirm match empty is false",
          "    assert_eq!(class.static_explicit_captures_len(), Some(0)); // Validate static explicit captures length is 0",
          "    assert!(parser.char.get().is_none()); // Confirm char is None after parsing completion",
          "    assert!(parser.capture_names.borrow().is_empty()); // Validate capture names remain empty after parsing",
          "    parser.bump(); // Advance position to account for parsing",
          "    assert_eq!(parser.pos.get(), 1); // Validate position after bumping",
          "    assert!(class.is_canonical()); // Ensure the class is canonical after parsing",
          "    assert!(class.ascii_case_fold().is_ok()); // Validate case folding is successful",
          "    assert!(class.negate().is_ok()); // Verify negate operation works correctly"
        ],
        "code": [
          "{",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags {",
          "            case_insensitive: false,",
          "            multi_line: false,",
          "            dot_matches_new_line: false,",
          "            swap_greed: false,",
          "            crlf: false,",
          "            ignore_whitespace: false,",
          "        },",
          "    };",
          "    let pattern = \"\\\\s\"; // Input pattern with lowercase 's'",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(0),",
          "        char: Cell::new(Some('s')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    parser.parse_perl_class(); // Call under test",
          "    assert_eq!(parser.char.get(), Some('s')); // Verify char is 's'",
          "    assert_eq!(parser.pos.get(), 1); // Verify position is incremented after bump",
          "    assert!(parser.capture_index.get() == 0); // Ensure capture index remains unchanged",
          "    assert!(parser.flags.borrow().case_insensitive == false); // Confirm flags are unchanged",
          "    let class = parser.parse_perl_class(); // Execute parse_perl_class",
          "    assert_eq!(class.kind(), &HirKind::Class(hir::Class { ranges: vec![hir::ClassRange { start: ' ', end: ' ' }] })); // Validate class ranges for '\\s'",
          "    assert!(matches!(class.is_start_anchored(), false)); // Confirm starting anchor is false",
          "    assert!(matches!(class.is_match_empty(), false)); // Confirm match empty is false",
          "    assert_eq!(class.static_explicit_captures_len(), Some(0)); // Validate static explicit captures length is 0",
          "    assert!(parser.char.get().is_none()); // Confirm char is None after parsing completion",
          "    assert!(parser.capture_names.borrow().is_empty()); // Validate capture names remain empty after parsing",
          "    parser.bump(); // Advance position to account for parsing",
          "    assert_eq!(parser.pos.get(), 1); // Validate position after bumping",
          "    assert!(class.is_canonical()); // Ensure the class is canonical after parsing",
          "    assert!(class.ascii_case_fold().is_ok()); // Validate case folding is successful",
          "    assert!(class.negate().is_ok()); // Verify negate operation works correctly",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]