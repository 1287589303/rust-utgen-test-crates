[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<valid_name>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"valid_name\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(parser.char(), Some('v'));",
          "    assert_eq!(is_capture_char('v', true), true);",
          "    assert_eq!(parser.bump(), false);",
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(name.is_empty(), false);",
          "    assert!(parser.add_capture_name(\"valid_name\").is_ok());",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_name\"));"
        ],
        "code": [
          "{",
          "    let pattern = \"<valid_name>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"valid_name\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(parser.char(), Some('v'));",
          "    assert_eq!(is_capture_char('v', true), true);",
          "    assert_eq!(parser.bump(), false);",
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(name.is_empty(), false);",
          "    assert!(parser.add_capture_name(\"valid_name\").is_ok());",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_name\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<_validName123>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('_')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"validName123\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(parser.char(), '>');",
          "    assert_eq!(is_capture_char(parser.char(), parser.pos() == 1), true);",
          "    assert_eq!(parser.bump(), false);",
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(name.is_empty(), false);",
          "    assert_eq!(parser.add_capture_name(name), Ok(()));",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"_validName123\"));"
        ],
        "code": [
          "{",
          "    let pattern = \"<_validName123>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('_')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"validName123\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(parser.char(), '>');",
          "    assert_eq!(is_capture_char(parser.char(), parser.pos() == 1), true);",
          "    assert_eq!(parser.bump(), false);",
          "    assert_eq!(parser.is_done(), false);",
          "    assert_eq!(name.is_empty(), false);",
          "    assert_eq!(parser.add_capture_name(name), Ok(()));",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"_validName123\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<_alpha_123>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('_')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"alpha_123\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert!(!parser.is_done());",
          "    assert_eq!(parser.char(), Some('>'));",
          "    assert!(is_capture_char(parser.char().unwrap(), parser.pos() == 1));",
          "    assert!(!parser.bump());",
          "    assert!(!parser.is_done());",
          "    assert!(!name.is_empty());",
          "    assert!(parser.add_capture_name(name).is_ok());",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"_alpha_123\"));"
        ],
        "code": [
          "{",
          "    let pattern = \"<_alpha_123>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('_')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"alpha_123\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert!(!parser.is_done());",
          "    assert_eq!(parser.char(), Some('>'));",
          "    assert!(is_capture_char(parser.char().unwrap(), parser.pos() == 1));",
          "    assert!(!parser.bump());",
          "    assert!(!parser.is_done());",
          "    assert!(!name.is_empty());",
          "    assert!(parser.add_capture_name(name).is_ok());",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"_alpha_123\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<name123>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('n')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"name123\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert!(parser.is_done() == false);",
          "    assert!(parser.char() == '>');",
          "    assert!(is_capture_char(parser.char(), parser.pos() == 1) == true);",
          "    assert!(parser.bump() == false);",
          "    assert!(parser.is_done() == false);",
          "    assert!(name.is_empty() == false);",
          "    assert!(parser.add_capture_name(name).is_ok());",
          "    assert!(parser.parse_capture_name().unwrap() == \"name123\");"
        ],
        "code": [
          "{",
          "    let pattern = \"<name123>\";",
          "    let config = Config {",
          "        nest_limit: 10,",
          "        flags: Flags::default(),",
          "    };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('n')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"name123\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert!(parser.is_done() == false);",
          "    assert!(parser.char() == '>');",
          "    assert!(is_capture_char(parser.char(), parser.pos() == 1) == true);",
          "    assert!(parser.bump() == false);",
          "    assert!(parser.is_done() == false);",
          "    assert!(name.is_empty() == false);",
          "    assert!(parser.add_capture_name(name).is_ok());",
          "    assert!(parser.parse_capture_name().unwrap() == \"name123\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]