[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<valid_capture_name>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
          "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
          "    assert_eq!(parser.pos.get(), 19);",
          "    assert!(parser.capture_names.borrow().len() == 1);",
          "    assert!(parser.is_done() == false);",
          "    assert!(parser.char.get().is_some());",
          "    assert!(parser.char.get().unwrap() == '>');"
        ],
        "code": [
          "{",
          "    let pattern = \"<valid_capture_name>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
          "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
          "    assert_eq!(parser.pos.get(), 19);",
          "    assert!(parser.capture_names.borrow().len() == 1);",
          "    assert!(parser.is_done() == false);",
          "    assert!(parser.char.get().is_some());",
          "    assert!(parser.char.get().unwrap() == '>');",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<invalid@name>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('i')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_err, Error::new(ERR_INVALID_GROUP_NAME));",
          "    assert_eq!(parser.capture_names.borrow().len(), 0);",
          "    assert_eq!(parser.pos.get(), 1);",
          "    assert_eq!(parser.char.get(), Some('i'));",
          "    assert_eq!(parser.is_done(), false);",
          "    parser.pos.set(0);",
          "    assert!(parser.parse_capture_name().is_err());",
          "    parser.char.set(Some('>'));",
          "    parser.pos.set(2);",
          "    assert!(parser.parse_capture_name().is_ok());",
          "    assert!(parser.capture_names.borrow().contains(&String::from(\"invalid@name\")));",
          "    parser.pos.set(1);",
          "    parser.char.set(None);",
          "    assert_eq!(parser.parse_capture_name().err().unwrap().msg, ERR_EMPTY_GROUP_NAME);",
          "    parser.char.set(Some('>'));",
          "    assert!(parser.parse_capture_name().is_err());"
        ],
        "code": [
          "{",
          "    let pattern = \"<invalid@name>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('i')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert_eq!(_err, Error::new(ERR_INVALID_GROUP_NAME));",
          "    assert_eq!(parser.capture_names.borrow().len(), 0);",
          "    assert_eq!(parser.pos.get(), 1);",
          "    assert_eq!(parser.char.get(), Some('i'));",
          "    assert_eq!(parser.is_done(), false);",
          "    parser.pos.set(0);",
          "    assert!(parser.parse_capture_name().is_err());",
          "    parser.char.set(Some('>'));",
          "    parser.pos.set(2);",
          "    assert!(parser.parse_capture_name().is_ok());",
          "    assert!(parser.capture_names.borrow().contains(&String::from(\"invalid@name\")));",
          "    parser.pos.set(1);",
          "    parser.char.set(None);",
          "    assert_eq!(parser.parse_capture_name().err().unwrap().msg, ERR_EMPTY_GROUP_NAME);",
          "    parser.char.set(Some('>'));",
          "    assert!(parser.parse_capture_name().is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<duplicate_name><duplicate_name>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('d')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"duplicate_name\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(*parser.parse_capture_name().unwrap(), \"duplicate_name\");",
          "    assert!(parser.capture_names.borrow().len() > 1);",
          "    assert_eq!(parser.capture_names.borrow()[0], \"duplicate_name\");",
          "    assert_eq!(parser.pos.get(), 17);",
          "    assert!(parser.is_done());",
          "    assert!(parser.char.get().is_none());",
          "    assert_eq!(parser.capture_index.get(), 1);"
        ],
        "code": [
          "{",
          "    let pattern = \"<duplicate_name><duplicate_name>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('d')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![\"duplicate_name\".to_string()]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert_eq!(*parser.parse_capture_name().unwrap(), \"duplicate_name\");",
          "    assert!(parser.capture_names.borrow().len() > 1);",
          "    assert_eq!(parser.capture_names.borrow()[0], \"duplicate_name\");",
          "    assert_eq!(parser.pos.get(), 17);",
          "    assert!(parser.is_done());",
          "    assert!(parser.char.get().is_none());",
          "    assert_eq!(parser.capture_index.get(), 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('>')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.pos.get(), 1);",
          "    assert!(parser.capture_names.borrow().is_empty());",
          "    assert!(parser.char.get().is_some());",
          "    assert!(parser.char.get().unwrap() == '>');",
          "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_EMPTY_GROUP_NAME)));"
        ],
        "code": [
          "{",
          "    let pattern = \"<>\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('>')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert_eq!(parser.pos.get(), 1);",
          "    assert!(parser.capture_names.borrow().is_empty());",
          "    assert!(parser.char.get().is_some());",
          "    assert!(parser.char.get().unwrap() == '>');",
          "    assert_eq!(parser.parse_capture_name(), Err(Error::new(ERR_EMPTY_GROUP_NAME)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<valid_capture_name\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
          "    assert!(parser.is_done());",
          "    assert_eq!(parser.pos.get(), 20);",
          "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
          "    assert!(parser.capture_index.get() > 0);",
          "    assert!(parser.char.get().is_none());",
          "    assert_eq!(parser.pattern, \"<valid_capture_name\");"
        ],
        "code": [
          "{",
          "    let pattern = \"<valid_capture_name\";",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let parser = Parser {",
          "        config,",
          "        pattern,",
          "        depth: Cell::new(0),",
          "        pos: Cell::new(1),",
          "        char: Cell::new(Some('v')),",
          "        capture_index: Cell::new(0),",
          "        flags: RefCell::new(Flags::default()),",
          "        capture_names: RefCell::new(vec![]),",
          "    };",
          "    let _ = parser.parse_capture_name();",
          "    assert_eq!(parser.parse_capture_name(), Ok(\"valid_capture_name\"));",
          "    assert!(parser.is_done());",
          "    assert_eq!(parser.pos.get(), 20);",
          "    assert!(parser.capture_names.borrow().contains(&\"valid_capture_name\".to_string()));",
          "    assert!(parser.capture_index.get() > 0);",
          "    assert!(parser.char.get().is_none());",
          "    assert_eq!(parser.pattern, \"<valid_capture_name\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]