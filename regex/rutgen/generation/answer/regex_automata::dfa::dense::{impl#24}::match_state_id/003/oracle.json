[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let special = Special { max: 0, quit_id: 0, min_match: DEAD, max_match: DEAD, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 };",
          "",
          "    let dfa = DFA {",
          "        tt: TransitionTable { stride2: 0 },",
          "        st: StartTable::default(),",
          "        ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 },",
          "        special,",
          "        accels: Accels::default(),",
          "        pre: None,",
          "        quitset: ByteSet::default(),",
          "        flags: Flags::default(),",
          "    };",
          "",
          "    let index = 0;",
          "",
          "    let _ = MatchStates::default().match_state_id(&dfa, index);",
          "}"
        ],
        "oracle": [
          "    assert!(dfa.special.matches() == false);",
          "    let index = 0;",
          "    let special = Special { max: 0, quit_id: 0, min_match: DEAD, max_match: DEAD, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 };",
          "    let dfa = DFA {",
          "    tt: TransitionTable { stride2: 0 },",
          "    st: StartTable::default(),",
          "    ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 },",
          "    special,",
          "    accels: Accels::default(),",
          "    pre: None,",
          "    quitset: ByteSet::default(),",
          "    flags: Flags::default(),",
          "    };",
          "    assert!(std::panic::catch_unwind(|| MatchStates::default().match_state_id(&dfa, index)).is_err());"
        ],
        "code": [
          "{",
          "    let special = Special { max: 0, quit_id: 0, min_match: DEAD, max_match: DEAD, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 };",
          "",
          "    let dfa = DFA {",
          "        tt: TransitionTable { stride2: 0 },",
          "        st: StartTable::default(),",
          "        ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 },",
          "        special,",
          "        accels: Accels::default(),",
          "        pre: None,",
          "        quitset: ByteSet::default(),",
          "        flags: Flags::default(),",
          "    };",
          "",
          "    let index = 0;",
          "",
          "    let _ = MatchStates::default().match_state_id(&dfa, index);",
          "    assert!(dfa.special.matches() == false);",
          "    let index = 0;",
          "    let special = Special { max: 0, quit_id: 0, min_match: DEAD, max_match: DEAD, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 };",
          "    let dfa = DFA {",
          "    tt: TransitionTable { stride2: 0 },",
          "    st: StartTable::default(),",
          "    ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 },",
          "    special,",
          "    accels: Accels::default(),",
          "    pre: None,",
          "    quitset: ByteSet::default(),",
          "    flags: Flags::default(),",
          "    };",
          "    assert!(std::panic::catch_unwind(|| MatchStates::default().match_state_id(&dfa, index)).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let special = Special { max: 0, quit_id: 0, min_match: DEAD, max_match: DEAD, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 };",
          "",
          "    let dfa = DFA {",
          "        tt: TransitionTable { stride2: 1 },",
          "        st: StartTable::default(),",
          "        ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 },",
          "        special,",
          "        accels: Accels::default(),",
          "        pre: None,",
          "        quitset: ByteSet::default(),",
          "        flags: Flags::default(),",
          "    };",
          "",
          "    let index = 0;",
          "",
          "    let _ = MatchStates::default().match_state_id(&dfa, index);",
          "}"
        ],
        "oracle": [
          "    assert!(dfa.special.matches() == false);",
          "    let index = 0;",
          "    let sid = MatchStates::default().match_state_id(&dfa, index);",
          "    assert!(matches!(catch_unwind(|| MatchStates::default().match_state_id(&dfa, index)), Err(_)));",
          "    assert_eq!(sid, StateID::new(0).unwrap());",
          "    assert!(dfa.is_match_state(sid) == false);",
          "    assert!(dfa.ms.len() == 0);"
        ],
        "code": [
          "{",
          "    let special = Special { max: 0, quit_id: 0, min_match: DEAD, max_match: DEAD, min_accel: 0, max_accel: 0, min_start: 0, max_start: 0 };",
          "",
          "    let dfa = DFA {",
          "        tt: TransitionTable { stride2: 1 },",
          "        st: StartTable::default(),",
          "        ms: MatchStates { slices: vec![], pattern_ids: vec![], pattern_len: 0 },",
          "        special,",
          "        accels: Accels::default(),",
          "        pre: None,",
          "        quitset: ByteSet::default(),",
          "        flags: Flags::default(),",
          "    };",
          "",
          "    let index = 0;",
          "",
          "    let _ = MatchStates::default().match_state_id(&dfa, index);",
          "    assert!(dfa.special.matches() == false);",
          "    let index = 0;",
          "    let sid = MatchStates::default().match_state_id(&dfa, index);",
          "    assert!(matches!(catch_unwind(|| MatchStates::default().match_state_id(&dfa, index)), Err(_)));",
          "    assert_eq!(sid, StateID::new(0).unwrap());",
          "    assert!(dfa.is_match_state(sid) == false);",
          "    assert!(dfa.ms.len() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]