[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let classes = ByteClasses::empty();",
          "    let table: Vec<u32> = vec![];",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(size_of::<u32>() + size_of::<u32>() + transition_table.classes.write_to_len() + (transition_table.table.len() * StateID::SIZE), transition_table.write_to_len());",
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() + size_of::<u32>() + 256 + (0 * StateID::SIZE));",
          "    assert_eq!(transition_table.stride2, 1);",
          "    assert_eq!(transition_table.table.len(), 0);",
          "    assert_eq!(transition_table.classes.write_to_len(), 256);",
          "    assert!(transition_table.write_to_len() > 0);"
        ],
        "code": [
          "{",
          "    let classes = ByteClasses::empty();",
          "    let table: Vec<u32> = vec![];",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "    assert_eq!(size_of::<u32>() + size_of::<u32>() + transition_table.classes.write_to_len() + (transition_table.table.len() * StateID::SIZE), transition_table.write_to_len());",
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() + size_of::<u32>() + 256 + (0 * StateID::SIZE));",
          "    assert_eq!(transition_table.stride2, 1);",
          "    assert_eq!(transition_table.table.len(), 0);",
          "    assert_eq!(transition_table.classes.write_to_len(), 256);",
          "    assert!(transition_table.write_to_len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(0, 1);",
          "    let table: Vec<u32> = vec![0];",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(size_of::<u32>(), 4);",
          "    assert_eq!(size_of::<u32>(), 4);",
          "    assert_eq!(transition_table.classes.write_to_len(), 256);",
          "    assert_eq!(transition_table.table().len(), 1);",
          "    assert_eq!(StateID::SIZE, 4);",
          "    assert_eq!(transition_table.write_to_len(), 4 + 4 + 256 + (1 * 4));"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    classes.set(0, 1);",
          "    let table: Vec<u32> = vec![0];",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 1,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "    assert_eq!(size_of::<u32>(), 4);",
          "    assert_eq!(size_of::<u32>(), 4);",
          "    assert_eq!(transition_table.classes.write_to_len(), 256);",
          "    assert_eq!(transition_table.table().len(), 1);",
          "    assert_eq!(StateID::SIZE, 4);",
          "    assert_eq!(transition_table.write_to_len(), 4 + 4 + 256 + (1 * 4));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    for i in 0..256 {",
          "        classes.set(i as u8, i as u8);",
          "    }",
          "    let table: Vec<u32> = (0..256).collect();",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 8,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() + size_of::<u32>() + transition_table.classes.write_to_len() + (transition_table.table().len() * StateID::SIZE));",
          "    assert_eq!(transition_table.write_to_len(), 8 + 8 + 256 + (256 * size_of::<StateID>()));",
          "    assert!(transition_table.write_to_len() > 0);",
          "    assert_eq!(transition_table.write_to_len(), 8 + 8 + 256 + (256 * 4));",
          "    assert!(transition_table.write_to_len() >= size_of::<u32>() * 2);",
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() * 2 + transition_table.classes.write_to_len() + transition_table.table.len() * size_of::<StateID>());"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::empty();",
          "    for i in 0..256 {",
          "        classes.set(i as u8, i as u8);",
          "    }",
          "    let table: Vec<u32> = (0..256).collect();",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 8,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() + size_of::<u32>() + transition_table.classes.write_to_len() + (transition_table.table().len() * StateID::SIZE));",
          "    assert_eq!(transition_table.write_to_len(), 8 + 8 + 256 + (256 * size_of::<StateID>()));",
          "    assert!(transition_table.write_to_len() > 0);",
          "    assert_eq!(transition_table.write_to_len(), 8 + 8 + 256 + (256 * 4));",
          "    assert!(transition_table.write_to_len() >= size_of::<u32>() * 2);",
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() * 2 + transition_table.classes.write_to_len() + transition_table.table.len() * size_of::<StateID>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let table: Vec<u32> = vec![0; 256];",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 2,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() + size_of::<u32>() + transition_table.classes.write_to_len() + (transition_table.table().len() * StateID::SIZE));",
          "    assert_eq!(transition_table.write_to_len(), 8 + transition_table.classes.write_to_len() + (256 * StateID::SIZE));",
          "    assert!(transition_table.write_to_len() > 0);",
          "    assert_eq!(transition_table.write_to_len() % size_of::<u32>(), 0);"
        ],
        "code": [
          "{",
          "    let mut classes = ByteClasses::singletons();",
          "    let table: Vec<u32> = vec![0; 256];",
          "",
          "    let transition_table = TransitionTable {",
          "        table,",
          "        classes,",
          "        stride2: 2,",
          "    };",
          "",
          "    transition_table.write_to_len();",
          "    assert_eq!(transition_table.write_to_len(), size_of::<u32>() + size_of::<u32>() + transition_table.classes.write_to_len() + (transition_table.table().len() * StateID::SIZE));",
          "    assert_eq!(transition_table.write_to_len(), 8 + transition_table.classes.write_to_len() + (256 * StateID::SIZE));",
          "    assert!(transition_table.write_to_len() > 0);",
          "    assert_eq!(transition_table.write_to_len() % size_of::<u32>(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]