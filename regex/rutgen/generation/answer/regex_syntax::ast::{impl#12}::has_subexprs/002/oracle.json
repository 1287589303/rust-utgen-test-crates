[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::literal(Literal::new(span.clone(), 'a'))) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ast.has_subexprs(), true);"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::literal(Literal::new(span.clone(), 'a'))) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "    assert_eq!(ast.has_subexprs(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let concat = Concat { span: span.clone(), asts: vec![Box::new(Ast::literal(Literal::new(span.clone(), 'a'))), Box::new(Ast::literal(Literal::new(span.clone(), 'b')))] };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::concat(concat)), Box::new(Ast::dot(span.clone()))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(ast.has_subexprs(), true);"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let concat = Concat { span: span.clone(), asts: vec![Box::new(Ast::literal(Literal::new(span.clone(), 'a'))), Box::new(Ast::literal(Literal::new(span.clone(), 'b')))] };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::concat(concat)), Box::new(Ast::dot(span.clone()))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "    assert_eq!(ast.has_subexprs(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Ast::literal(Literal::new(span.clone(), 'a'))) };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::assertion(Assertion { span: span.clone(), kind: AssertionKind::WordBoundary })) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::repetition(repetition)), Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "}"
        ],
        "oracle": [
          "    assert!(ast.is_some());",
          "    assert!(ast.has_subexprs());",
          "    assert_eq!(ast.span(), &span);",
          "    assert!(matches!(ast, Ast::Alternation(_)));",
          "    assert!(matches!(ast, Ast::Group(_)));",
          "    assert!(matches!(ast, Ast::Repetition(_)));"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Ast::literal(Literal::new(span.clone(), 'a'))) };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::assertion(Assertion { span: span.clone(), kind: AssertionKind::WordBoundary })) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::repetition(repetition)), Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "    assert!(ast.is_some());",
          "    assert!(ast.has_subexprs());",
          "    assert_eq!(ast.span(), &span);",
          "    assert!(matches!(ast, Ast::Alternation(_)));",
          "    assert!(matches!(ast, Ast::Group(_)));",
          "    assert!(matches!(ast, Ast::Repetition(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::empty(span.clone()))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::empty(span.clone()))] };",
          "    let ast = Ast::alternation(alternation);",
          "    assert_eq!(ast.has_subexprs(), true);"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::empty(span.clone()))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::empty(span.clone()))] };",
          "    let ast = Ast::alternation(alternation);",
          "    assert_eq!(ast.has_subexprs(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::literal(Literal::new(span.clone(), 'x'))) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::group(group.clone())), Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "}"
        ],
        "oracle": [
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::literal(Literal::new(span.clone(), 'x'))) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::group(group.clone())), Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    assert_eq!(ast.has_subexprs(), true);"
        ],
        "code": [
          "{",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::literal(Literal::new(span.clone(), 'x'))) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::group(group.clone())), Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    ast.has_subexprs();",
          "    let span = Span { start: Position::start(), end: Position::end() };",
          "    let group = Group { span: span.clone(), kind: GroupKind::Default, ast: Box::new(Ast::literal(Literal::new(span.clone(), 'x'))) };",
          "    let alternation = Alternation { span, asts: vec![Box::new(Ast::group(group.clone())), Box::new(Ast::group(group))] };",
          "    let ast = Ast::alternation(alternation);",
          "    assert_eq!(ast.has_subexprs(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]