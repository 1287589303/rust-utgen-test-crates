[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"a*b\".to_string();",
          "    let states = vec![State::new(), State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "}"
        ],
        "oracle": [
          "    assert!(_nfa_ref.is_some());",
          "    assert_eq!(_nfa_ref.pattern, \"a*b\");",
          "    assert_eq!(_nfa_ref.states.len(), 2);",
          "    assert_eq!(_nfa_ref.start, StateID::new(0));",
          "    assert!(!_nfa_ref.is_start_anchored);",
          "    assert!(_nfa_ref.is_match_empty);",
          "    assert_eq!(_nfa_ref.static_explicit_captures_len, None);",
          "    assert_eq!(_nfa_ref.memory_extra, 0);"
        ],
        "code": [
          "{",
          "    let pattern = \"a*b\".to_string();",
          "    let states = vec![State::new(), State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "    assert!(_nfa_ref.is_some());",
          "    assert_eq!(_nfa_ref.pattern, \"a*b\");",
          "    assert_eq!(_nfa_ref.states.len(), 2);",
          "    assert_eq!(_nfa_ref.start, StateID::new(0));",
          "    assert!(!_nfa_ref.is_start_anchored);",
          "    assert!(_nfa_ref.is_match_empty);",
          "    assert_eq!(_nfa_ref.static_explicit_captures_len, None);",
          "    assert_eq!(_nfa_ref.memory_extra, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: true,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "    pattern,",
          "    states,",
          "    start,",
          "    is_start_anchored: true,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: None,",
          "    cap_name_to_index: CaptureNameMap::new(),",
          "    cap_index_to_name: vec![],",
          "    memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let nfa_ref = pike_vm.nfa();",
          "    assert_eq!(nfa_ref.pattern, \"\");",
          "    assert_eq!(nfa_ref.states.len(), 1);",
          "    assert_eq!(nfa_ref.start, StateID::new(0));",
          "    assert!(nfa_ref.is_start_anchored);",
          "    assert!(!nfa_ref.is_match_empty);",
          "    assert!(nfa_ref.static_explicit_captures_len.is_none());",
          "    assert_eq!(nfa_ref.memory_extra, 0);"
        ],
        "code": [
          "{",
          "    let pattern = \"\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: true,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: None,",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "    let pattern = \"\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "    pattern,",
          "    states,",
          "    start,",
          "    is_start_anchored: true,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: None,",
          "    cap_name_to_index: CaptureNameMap::new(),",
          "    cap_index_to_name: vec![],",
          "    memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let nfa_ref = pike_vm.nfa();",
          "    assert_eq!(nfa_ref.pattern, \"\");",
          "    assert_eq!(nfa_ref.states.len(), 1);",
          "    assert_eq!(nfa_ref.start, StateID::new(0));",
          "    assert!(nfa_ref.is_start_anchored);",
          "    assert!(!nfa_ref.is_match_empty);",
          "    assert!(nfa_ref.static_explicit_captures_len.is_none());",
          "    assert_eq!(nfa_ref.memory_extra, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"c\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"c\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "    pattern,",
          "    states,",
          "    start,",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: Some(0),",
          "    cap_name_to_index: CaptureNameMap::new(),",
          "    cap_index_to_name: vec![],",
          "    memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let nfa_ref = pike_vm.nfa();",
          "    assert_eq!(nfa_ref.pattern, \"c\");",
          "    assert_eq!(nfa_ref.states.len(), 1);",
          "    assert_eq!(nfa_ref.start, StateID::new(0));",
          "    assert!(!nfa_ref.is_start_anchored);",
          "    assert!(!nfa_ref.is_match_empty);",
          "    assert_eq!(nfa_ref.static_explicit_captures_len, Some(0));",
          "    assert!(nfa_ref.cap_name_to_index.is_empty());",
          "    assert!(nfa_ref.cap_index_to_name.is_empty());",
          "    assert_eq!(nfa_ref.memory_extra, 0);"
        ],
        "code": [
          "{",
          "    let pattern = \"c\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: false,",
          "        is_match_empty: false,",
          "        static_explicit_captures_len: Some(0),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "    let pattern = \"c\".to_string();",
          "    let states = vec![State::new()];",
          "    let start = StateID::new(0);",
          "    let nfa = NFA {",
          "    pattern,",
          "    states,",
          "    start,",
          "    is_start_anchored: false,",
          "    is_match_empty: false,",
          "    static_explicit_captures_len: Some(0),",
          "    cap_name_to_index: CaptureNameMap::new(),",
          "    cap_index_to_name: vec![],",
          "    memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let nfa_ref = pike_vm.nfa();",
          "    assert_eq!(nfa_ref.pattern, \"c\");",
          "    assert_eq!(nfa_ref.states.len(), 1);",
          "    assert_eq!(nfa_ref.start, StateID::new(0));",
          "    assert!(!nfa_ref.is_start_anchored);",
          "    assert!(!nfa_ref.is_match_empty);",
          "    assert_eq!(nfa_ref.static_explicit_captures_len, Some(0));",
          "    assert!(nfa_ref.cap_name_to_index.is_empty());",
          "    assert!(nfa_ref.cap_index_to_name.is_empty());",
          "    assert_eq!(nfa_ref.memory_extra, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"abc\".to_string();",
          "    let states = vec![State::new(), State::new(), State::new()];",
          "    let start = StateID::new(1);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: Some(2),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "}"
        ],
        "oracle": [
          "    let pattern = \"abc\".to_string();",
          "    let states = vec![State::new(), State::new(), State::new()];",
          "    let start = StateID::new(1);",
          "    let nfa = NFA {",
          "    pattern,",
          "    states,",
          "    start,",
          "    is_start_anchored: false,",
          "    is_match_empty: true,",
          "    static_explicit_captures_len: Some(2),",
          "    cap_name_to_index: CaptureNameMap::new(),",
          "    cap_index_to_name: vec![],",
          "    memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    assert_eq!(pike_vm.nfa().pattern, \"abc\");",
          "    assert_eq!(pike_vm.nfa().states.len(), 3);",
          "    assert_eq!(pike_vm.nfa().start, StateID::new(1));",
          "    assert!(!pike_vm.nfa().is_start_anchored);",
          "    assert!(pike_vm.nfa().is_match_empty);",
          "    assert_eq!(pike_vm.nfa().static_explicit_captures_len, Some(2));",
          "    assert_eq!(pike_vm.nfa().memory_extra, 0);"
        ],
        "code": [
          "{",
          "    let pattern = \"abc\".to_string();",
          "    let states = vec![State::new(), State::new(), State::new()];",
          "    let start = StateID::new(1);",
          "    let nfa = NFA {",
          "        pattern,",
          "        states,",
          "        start,",
          "        is_start_anchored: false,",
          "        is_match_empty: true,",
          "        static_explicit_captures_len: Some(2),",
          "        cap_name_to_index: CaptureNameMap::new(),",
          "        cap_index_to_name: vec![],",
          "        memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    let _nfa_ref = pike_vm.nfa();",
          "    let pattern = \"abc\".to_string();",
          "    let states = vec![State::new(), State::new(), State::new()];",
          "    let start = StateID::new(1);",
          "    let nfa = NFA {",
          "    pattern,",
          "    states,",
          "    start,",
          "    is_start_anchored: false,",
          "    is_match_empty: true,",
          "    static_explicit_captures_len: Some(2),",
          "    cap_name_to_index: CaptureNameMap::new(),",
          "    cap_index_to_name: vec![],",
          "    memory_extra: 0,",
          "    };",
          "    let pike_vm = PikeVM::new(nfa);",
          "    assert_eq!(pike_vm.nfa().pattern, \"abc\");",
          "    assert_eq!(pike_vm.nfa().states.len(), 3);",
          "    assert_eq!(pike_vm.nfa().start, StateID::new(1));",
          "    assert!(!pike_vm.nfa().is_start_anchored);",
          "    assert!(pike_vm.nfa().is_match_empty);",
          "    assert_eq!(pike_vm.nfa().static_explicit_captures_len, Some(2));",
          "    assert_eq!(pike_vm.nfa().memory_extra, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]