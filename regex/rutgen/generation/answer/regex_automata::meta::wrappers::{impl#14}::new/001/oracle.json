[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let regex_info = {",
          "        let config = {",
          "            let mut builder = regex_automata::meta::regex::ConfigBuilder::default();",
          "            builder.set_hybrid(true);",
          "            builder.build()",
          "        };",
          "        RegexInfo(Arc::new(RegexInfoI { config }))",
          "    };",
          "",
          "    let nfa = {",
          "        let inner = Arc::new(Inner::new());",
          "        NFA(inner)",
          "    };",
          "",
          "    let reverse_hybrid = ReverseHybrid::new(&regex_info, &nfa);",
          "}"
        ],
        "oracle": [
          "    assert!(reverse_hybrid.0.is_some());",
          "    assert!(reverse_hybrid.0.as_ref().unwrap().0.is_some());",
          "    assert_eq!(reverse_hybrid.0.as_ref().unwrap().0.config().get_hybrid(), true);",
          "    assert_eq!(reverse_hybrid.0.as_ref().unwrap().0.byte_classes(), regex_info.0.config().get_byte_classes());",
          "    assert!(matches!(reverse_hybrid.0.as_ref().unwrap(), ReverseHybridEngine(_)));",
          "    assert!(matches!(reverse_hybrid, ReverseHybrid(ref engine) if engine.0.is_some()));"
        ],
        "code": [
          "{",
          "    let regex_info = {",
          "        let config = {",
          "            let mut builder = regex_automata::meta::regex::ConfigBuilder::default();",
          "            builder.set_hybrid(true);",
          "            builder.build()",
          "        };",
          "        RegexInfo(Arc::new(RegexInfoI { config }))",
          "    };",
          "",
          "    let nfa = {",
          "        let inner = Arc::new(Inner::new());",
          "        NFA(inner)",
          "    };",
          "",
          "    let reverse_hybrid = ReverseHybrid::new(&regex_info, &nfa);",
          "    assert!(reverse_hybrid.0.is_some());",
          "    assert!(reverse_hybrid.0.as_ref().unwrap().0.is_some());",
          "    assert_eq!(reverse_hybrid.0.as_ref().unwrap().0.config().get_hybrid(), true);",
          "    assert_eq!(reverse_hybrid.0.as_ref().unwrap().0.byte_classes(), regex_info.0.config().get_byte_classes());",
          "    assert!(matches!(reverse_hybrid.0.as_ref().unwrap(), ReverseHybridEngine(_)));",
          "    assert!(matches!(reverse_hybrid, ReverseHybrid(ref engine) if engine.0.is_some()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let regex_info = {",
          "        let config = {",
          "            let mut builder = regex_automata::meta::regex::ConfigBuilder::default();",
          "            builder.set_hybrid(false);",
          "            builder.build()",
          "        };",
          "        RegexInfo(Arc::new(RegexInfoI { config }))",
          "    };",
          "",
          "    let nfa = {",
          "        let inner = Arc::new(Inner::new());",
          "        NFA(inner)",
          "    };",
          "",
          "    let reverse_hybrid = ReverseHybrid::new(&regex_info, &nfa);",
          "}"
        ],
        "oracle": [
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert_eq!(reverse_hybrid, ReverseHybrid::none());",
          "    assert_eq!(reverse_hybrid.0, ReverseHybridEngine::new(&regex_info, &nfa));",
          "    assert!(matches!(reverse_hybrid, ReverseHybrid(_)));",
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert_eq!(reverse_hybrid.0, ReverseHybridEngine::new(&regex_info, &nfa));",
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert!(reverse_hybrid.0.is_none());"
        ],
        "code": [
          "{",
          "    let regex_info = {",
          "        let config = {",
          "            let mut builder = regex_automata::meta::regex::ConfigBuilder::default();",
          "            builder.set_hybrid(false);",
          "            builder.build()",
          "        };",
          "        RegexInfo(Arc::new(RegexInfoI { config }))",
          "    };",
          "",
          "    let nfa = {",
          "        let inner = Arc::new(Inner::new());",
          "        NFA(inner)",
          "    };",
          "",
          "    let reverse_hybrid = ReverseHybrid::new(&regex_info, &nfa);",
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert_eq!(reverse_hybrid, ReverseHybrid::none());",
          "    assert_eq!(reverse_hybrid.0, ReverseHybridEngine::new(&regex_info, &nfa));",
          "    assert!(matches!(reverse_hybrid, ReverseHybrid(_)));",
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert_eq!(reverse_hybrid.0, ReverseHybridEngine::new(&regex_info, &nfa));",
          "    assert!(reverse_hybrid.0.is_none());",
          "    assert!(reverse_hybrid.0.is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]