[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "        states: vec![State(Arc::from(vec![0; 10]))],",
          "        // omitted other Cache fields for brevity",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(0);",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state, &cache.states[0]);",
          "    assert!(state.is_valid());",
          "    assert_eq!(lazy_ref.is_sentinel(lazy_id), false);",
          "    assert_eq!(lazy_ref.is_valid(lazy_id), true);",
          "    assert_eq!(lazy_ref.memory_usage_for_one_more_state(size_of::<State>()), 10);",
          "    assert!(lazy_ref.state_fits_in_cache(state));"
        ],
        "code": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "        states: vec![State(Arc::from(vec![0; 10]))],",
          "        // omitted other Cache fields for brevity",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(0);",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "    assert_eq!(state, &cache.states[0]);",
          "    assert!(state.is_valid());",
          "    assert_eq!(lazy_ref.is_sentinel(lazy_id), false);",
          "    assert_eq!(lazy_ref.is_valid(lazy_id), true);",
          "    assert_eq!(lazy_ref.memory_usage_for_one_more_state(size_of::<State>()), 10);",
          "    assert!(lazy_ref.state_fits_in_cache(state));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 2,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "        states: vec![State(Arc::from(vec![0; 20]))],",
          "        // omitted other Cache fields for brevity",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(3); // (3 >> 2) = 0",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "}"
        ],
        "oracle": [
          "    let dfa = DFA { config: Config::default(), nfa: thompson::NFA::new(), stride2: 2, start_map: StartByteMap::default(), classes: ByteClasses::new(), quitset: ByteSet::new(), cache_capacity: 10 };",
          "    let cache = Cache { states: vec![State(Arc::from(vec![0; 20]))], forward: dfa::Cache::default(), reverse: dfa::Cache::default() };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(3);",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "    assert_eq!(state.0.as_ref(), Arc::from(vec![0; 20]));",
          "    assert!(lazy_ref.get_cached_state(lazy_id).is_valid());",
          "    assert!(lazy_ref.is_sentinel(lazy_id));",
          "    assert_eq!(lazy_ref.unknown_id(), LazyStateID::new_unchecked(LazyStateID::MASK_UNKNOWN));",
          "    assert_eq!(lazy_ref.dead_id(), LazyStateID::new_unchecked(LazyStateID::MASK_DEAD));",
          "    assert_eq!(lazy_ref.quit_id(), LazyStateID::new_unchecked(LazyStateID::MASK_QUIT));"
        ],
        "code": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 2,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "        states: vec![State(Arc::from(vec![0; 20]))],",
          "        // omitted other Cache fields for brevity",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(3); // (3 >> 2) = 0",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "    let dfa = DFA { config: Config::default(), nfa: thompson::NFA::new(), stride2: 2, start_map: StartByteMap::default(), classes: ByteClasses::new(), quitset: ByteSet::new(), cache_capacity: 10 };",
          "    let cache = Cache { states: vec![State(Arc::from(vec![0; 20]))], forward: dfa::Cache::default(), reverse: dfa::Cache::default() };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(3);",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "    assert_eq!(state.0.as_ref(), Arc::from(vec![0; 20]));",
          "    assert!(lazy_ref.get_cached_state(lazy_id).is_valid());",
          "    assert!(lazy_ref.is_sentinel(lazy_id));",
          "    assert_eq!(lazy_ref.unknown_id(), LazyStateID::new_unchecked(LazyStateID::MASK_UNKNOWN));",
          "    assert_eq!(lazy_ref.dead_id(), LazyStateID::new_unchecked(LazyStateID::MASK_DEAD));",
          "    assert_eq!(lazy_ref.quit_id(), LazyStateID::new_unchecked(LazyStateID::MASK_QUIT));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "        states: vec![State(Arc::from(vec![0; 5]))],",
          "        // omitted other Cache fields for brevity",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(16); // (16 >> 1) = 8, which is out of bounds",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "}"
        ],
        "oracle": [
          "    let dfa = DFA {",
          "    config: Config::default(),",
          "    nfa: thompson::NFA::new(),",
          "    stride2: 1,",
          "    start_map: StartByteMap::default(),",
          "    classes: ByteClasses::new(),",
          "    quitset: ByteSet::new(),",
          "    cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "    states: vec![State(Arc::from(vec![0; 5]))],",
          "    forward: dfa::Cache::default(),",
          "    reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(16);",
          "    assert!(std::panic::catch_unwind(|| {",
          "    lazy_ref.get_cached_state(lazy_id);",
          "    }).is_err());"
        ],
        "code": [
          "{",
          "    let dfa = DFA {",
          "        config: Config::default(),",
          "        nfa: thompson::NFA::new(),",
          "        stride2: 1,",
          "        start_map: StartByteMap::default(),",
          "        classes: ByteClasses::new(),",
          "        quitset: ByteSet::new(),",
          "        cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "        states: vec![State(Arc::from(vec![0; 5]))],",
          "        // omitted other Cache fields for brevity",
          "        forward: dfa::Cache::default(),",
          "        reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(16); // (16 >> 1) = 8, which is out of bounds",
          "    let state = lazy_ref.get_cached_state(lazy_id);",
          "    let dfa = DFA {",
          "    config: Config::default(),",
          "    nfa: thompson::NFA::new(),",
          "    stride2: 1,",
          "    start_map: StartByteMap::default(),",
          "    classes: ByteClasses::new(),",
          "    quitset: ByteSet::new(),",
          "    cache_capacity: 10,",
          "    };",
          "    let cache = Cache {",
          "    states: vec![State(Arc::from(vec![0; 5]))],",
          "    forward: dfa::Cache::default(),",
          "    reverse: dfa::Cache::default(),",
          "    };",
          "    let lazy_ref = LazyRef { dfa: &dfa, cache: &cache };",
          "    let lazy_id = LazyStateID::new_unchecked(16);",
          "    assert!(std::panic::catch_unwind(|| {",
          "    lazy_ref.get_cached_state(lazy_id);",
          "    }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]