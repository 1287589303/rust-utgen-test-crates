[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(0);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"foo\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"quux\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_exact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(0);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"foo\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"quux\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_exact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"f\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"q\");",
          "    assert!(seq.literals().unwrap()[2].is_inexact());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(1);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"f\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"q\");",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(3);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::inexact(b\"qu\")]));",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[2].len(), 2);"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(3);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::inexact(b\"qu\")]));",
          "    assert!(seq.literals().unwrap()[0].is_exact());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[2].len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(5);",
          "}"
        ],
        "oracle": [
          "    seq.keep_first_bytes(5);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(3);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::inexact(b\"qu\")]));",
          "    ",
          "    seq.keep_first_bytes(2);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"fo\"), Literal::inexact(b\"qu\")]));",
          "    ",
          "    seq.keep_first_bytes(0);",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(b\"\"), Literal::inexact(b\"\"), Literal::inexact(b\"\")]));",
          "    ",
          "    seq.keep_first_bytes(10);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(1);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"f\"), Literal::inexact(b\"q\")]));",
          "    ",
          "    seq.keep_first_bytes(4);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::inexact(b\"quu\")]));",
          "    ",
          "    seq.keep_first_bytes(6);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(7);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(2);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"fo\"), Literal::inexact(b\"qu\")]));"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    seq.keep_first_bytes(5);",
          "    seq.keep_first_bytes(5);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(3);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::inexact(b\"qu\")]));",
          "    ",
          "    seq.keep_first_bytes(2);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"fo\"), Literal::inexact(b\"qu\")]));",
          "    ",
          "    seq.keep_first_bytes(0);",
          "    assert_eq!(seq.literals(), Some(&[Literal::inexact(b\"\"), Literal::inexact(b\"\"), Literal::inexact(b\"\")]));",
          "    ",
          "    seq.keep_first_bytes(10);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(1);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"f\"), Literal::inexact(b\"q\")]));",
          "    ",
          "    seq.keep_first_bytes(4);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::inexact(b\"quu\")]));",
          "    ",
          "    seq.keep_first_bytes(6);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(7);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]));",
          "    ",
          "    seq.keep_first_bytes(2);",
          "    assert_eq!(seq.literals(), Some(&[Literal::exact(b\"a\"), Literal::inexact(b\"fo\"), Literal::inexact(b\"qu\")]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    let max_len = seq.max_literal_len().unwrap();",
          "    seq.keep_first_bytes(max_len);",
          "}"
        ],
        "oracle": [
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"fo\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"qu\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    assert!(!seq.literals().unwrap()[0].is_inexact());",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[2].len(), 2);"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(vec![Literal::exact(b\"a\"), Literal::inexact(b\"foo\"), Literal::exact(b\"quux\")]);",
          "    let max_len = seq.max_literal_len().unwrap();",
          "    seq.keep_first_bytes(max_len);",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"a\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"fo\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"qu\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    assert!(!seq.literals().unwrap()[0].is_inexact());",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[2].len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]