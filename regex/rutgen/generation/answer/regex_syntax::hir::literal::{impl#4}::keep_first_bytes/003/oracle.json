[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"abc\", b\"defg\", b\"hijkl\"]);",
          "    seq.keep_first_bytes(2);",
          "}"
        ],
        "oracle": [
          "    let mut seq = Seq::new(&[b\"abc\", b\"defg\", b\"hijkl\"]);",
          "    seq.keep_first_bytes(2);",
          "    let expected_seq = Seq::new(&[b\"ab\", b\"de\", b\"hi\"]);",
          "    assert_eq!(expected_seq.literals(), seq.literals());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    assert!(seq.is_finite());"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"abc\", b\"defg\", b\"hijkl\"]);",
          "    seq.keep_first_bytes(2);",
          "    let mut seq = Seq::new(&[b\"abc\", b\"defg\", b\"hijkl\"]);",
          "    seq.keep_first_bytes(2);",
          "    let expected_seq = Seq::new(&[b\"ab\", b\"de\", b\"hi\"]);",
          "    assert_eq!(expected_seq.literals(), seq.literals());",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    assert!(seq.is_finite());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"x\", b\"yzabc\", b\"foo\", b\"quuxxx\"]);",
          "    seq.keep_first_bytes(3);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().unwrap().len(), 4);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"x\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"yz\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"foo\");",
          "    assert_eq!(seq.literals().unwrap()[3].as_bytes(), b\"quu\");"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"x\", b\"yzabc\", b\"foo\", b\"quuxxx\"]);",
          "    seq.keep_first_bytes(3);",
          "    assert_eq!(seq.literals().unwrap().len(), 4);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"x\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"yz\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"foo\");",
          "    assert_eq!(seq.literals().unwrap()[3].as_bytes(), b\"quu\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"short\", b\"exact\", b\"match\"]);",
          "    seq.keep_first_bytes(6);",
          "}"
        ],
        "oracle": [
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"short\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"exact\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"match\");",
          "    ",
          "    seq.keep_first_bytes(6);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"short\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    ",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"exact\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"match\");"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"short\", b\"exact\", b\"match\"]);",
          "    seq.keep_first_bytes(6);",
          "    assert!(seq.literals().is_some());",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"short\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"exact\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"match\");",
          "    ",
          "    seq.keep_first_bytes(6);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"short\");",
          "    assert!(seq.literals().unwrap()[1].is_inexact());",
          "    assert!(seq.literals().unwrap()[2].is_inexact());",
          "    ",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"exact\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"match\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"nonempty\", b\"literals\", b\"here\"]);",
          "    seq.keep_first_bytes(0);",
          "}"
        ],
        "oracle": [
          "    let mut seq = Seq::new(&[b\"nonempty\", b\"literals\", b\"here\"]);",
          "    seq.keep_first_bytes(0);",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"nonempty\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"literals\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"here\");"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"nonempty\", b\"literals\", b\"here\"]);",
          "    seq.keep_first_bytes(0);",
          "    let mut seq = Seq::new(&[b\"nonempty\", b\"literals\", b\"here\"]);",
          "    seq.keep_first_bytes(0);",
          "    assert_eq!(seq.literals().unwrap().len(), 3);",
          "    assert_eq!(seq.literals().unwrap()[0].as_bytes(), b\"nonempty\");",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), b\"literals\");",
          "    assert_eq!(seq.literals().unwrap()[2].as_bytes(), b\"here\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq = Seq::new(&[b\"\", b\"nonempty\"]);",
          "    seq.keep_first_bytes(1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq.literals().is_some(), true);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 0);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), &[b'n']);",
          "    assert_eq!(seq.literals().unwrap()[0].is_exact(), true);",
          "    assert_eq!(seq.literals().unwrap()[1].is_exact(), false);"
        ],
        "code": [
          "{",
          "    let mut seq = Seq::new(&[b\"\", b\"nonempty\"]);",
          "    seq.keep_first_bytes(1);",
          "    assert_eq!(seq.literals().is_some(), true);",
          "    assert_eq!(seq.literals().unwrap().len(), 2);",
          "    assert_eq!(seq.literals().unwrap()[0].len(), 0);",
          "    assert_eq!(seq.literals().unwrap()[1].len(), 1);",
          "    assert_eq!(seq.literals().unwrap()[1].as_bytes(), &[b'n']);",
          "    assert_eq!(seq.literals().unwrap()[0].is_exact(), true);",
          "    assert_eq!(seq.literals().unwrap()[1].is_exact(), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]