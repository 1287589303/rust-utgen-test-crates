[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(10);",
          "    let state_id_1 = StateID(1);",
          "    let state_id_2 = StateID(2);",
          "    sparse_set.insert(state_id_1);",
          "    sparse_set.insert(state_id_2);",
          "",
          "    let contains_1 = sparse_set.contains(state_id_1);",
          "    let contains_2 = sparse_set.contains(state_id_2);",
          "    let contains_3 = sparse_set.contains(StateID(3));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert!(!sparse_set.is_empty());",
          "    assert!(contains_1);",
          "    assert!(contains_2);",
          "    assert!(!contains_3);",
          "    assert!(sparse_set.contains(state_id_1));",
          "    assert!(sparse_set.contains(state_id_2));",
          "    assert!(!sparse_set.contains(StateID(3)));"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(10);",
          "    let state_id_1 = StateID(1);",
          "    let state_id_2 = StateID(2);",
          "    sparse_set.insert(state_id_1);",
          "    sparse_set.insert(state_id_2);",
          "",
          "    let contains_1 = sparse_set.contains(state_id_1);",
          "    let contains_2 = sparse_set.contains(state_id_2);",
          "    let contains_3 = sparse_set.contains(StateID(3));",
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert!(!sparse_set.is_empty());",
          "    assert!(contains_1);",
          "    assert!(contains_2);",
          "    assert!(!contains_3);",
          "    assert!(sparse_set.contains(state_id_1));",
          "    assert!(sparse_set.contains(state_id_2));",
          "    assert!(!sparse_set.contains(StateID(3)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_set = SparseSet::new(10);",
          "    let contains_1 = sparse_set.contains(StateID(1));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.len(), 0);",
          "    assert_eq!(sparse_set.contains(StateID(1)), false);",
          "    sparse_set.insert(StateID(1));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert_eq!(sparse_set.contains(StateID(1)), true);",
          "    assert_eq!(sparse_set.contains(StateID(2)), false);",
          "    sparse_set.insert(StateID(2));",
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert_eq!(sparse_set.contains(StateID(2)), true);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.len(), 0);",
          "    assert_eq!(sparse_set.contains(StateID(1)), false);",
          "    assert_eq!(sparse_set.contains(StateID(2)), false);",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert_eq!(sparse_set.contains(StateID(3)), true);",
          "    sparse_set.resize(20);",
          "    assert_eq!(sparse_set.capacity(), 20);",
          "    assert_eq!(sparse_set.contains(StateID(3)), true);",
          "    assert_eq!(sparse_set.contains(StateID(4)), false);"
        ],
        "code": [
          "{",
          "    let sparse_set = SparseSet::new(10);",
          "    let contains_1 = sparse_set.contains(StateID(1));",
          "    assert_eq!(sparse_set.len(), 0);",
          "    assert_eq!(sparse_set.contains(StateID(1)), false);",
          "    sparse_set.insert(StateID(1));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert_eq!(sparse_set.contains(StateID(1)), true);",
          "    assert_eq!(sparse_set.contains(StateID(2)), false);",
          "    sparse_set.insert(StateID(2));",
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert_eq!(sparse_set.contains(StateID(2)), true);",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.len(), 0);",
          "    assert_eq!(sparse_set.contains(StateID(1)), false);",
          "    assert_eq!(sparse_set.contains(StateID(2)), false);",
          "    sparse_set.insert(StateID(3));",
          "    assert_eq!(sparse_set.len(), 1);",
          "    assert_eq!(sparse_set.contains(StateID(3)), true);",
          "    sparse_set.resize(20);",
          "    assert_eq!(sparse_set.capacity(), 20);",
          "    assert_eq!(sparse_set.contains(StateID(3)), true);",
          "    assert_eq!(sparse_set.contains(StateID(4)), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(10);",
          "    let state_id = StateID(1);",
          "    sparse_set.insert(state_id);",
          "",
          "    let contains = sparse_set.contains(state_id);",
          "    let not_contains = sparse_set.contains(StateID(2));",
          "}"
        ],
        "oracle": [
          "    assert!(contains);",
          "    assert!(!not_contains);"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(10);",
          "    let state_id = StateID(1);",
          "    sparse_set.insert(state_id);",
          "",
          "    let contains = sparse_set.contains(state_id);",
          "    let not_contains = sparse_set.contains(StateID(2));",
          "    assert!(contains);",
          "    assert!(!not_contains);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    for i in 0..5 {",
          "        sparse_set.insert(StateID(i));",
          "    }",
          "",
          "    let contains_last = sparse_set.contains(StateID(4));",
          "    let not_contains_out_of_bounds = sparse_set.contains(StateID(5));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.len(), 5);",
          "    assert!(contains_last);",
          "    assert!(!not_contains_out_of_bounds);",
          "    assert!(sparse_set.contains(StateID(0)));",
          "    assert!(sparse_set.contains(StateID(1)));",
          "    assert!(sparse_set.contains(StateID(2)));",
          "    assert!(sparse_set.contains(StateID(3)));",
          "    assert!(sparse_set.contains(StateID(4)));",
          "    assert!(!sparse_set.contains(StateID(5)));",
          "    assert!(sparse_set.is_empty() == false);"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(5);",
          "    for i in 0..5 {",
          "        sparse_set.insert(StateID(i));",
          "    }",
          "",
          "    let contains_last = sparse_set.contains(StateID(4));",
          "    let not_contains_out_of_bounds = sparse_set.contains(StateID(5));",
          "    assert_eq!(sparse_set.len(), 5);",
          "    assert!(contains_last);",
          "    assert!(!not_contains_out_of_bounds);",
          "    assert!(sparse_set.contains(StateID(0)));",
          "    assert!(sparse_set.contains(StateID(1)));",
          "    assert!(sparse_set.contains(StateID(2)));",
          "    assert!(sparse_set.contains(StateID(3)));",
          "    assert!(sparse_set.contains(StateID(4)));",
          "    assert!(!sparse_set.contains(StateID(5)));",
          "    assert!(sparse_set.is_empty() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sparse_set = SparseSet::new(0);",
          "    let contains = sparse_set.contains(StateID(0));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.len(), 0);",
          "    assert!(!contains);  // should not contain any StateID since set is empty",
          "    ",
          "    let mut sparse_set = SparseSet::new(10);",
          "    sparse_set.insert(StateID(0));",
          "    sparse_set.insert(StateID(1));",
          "    let contains_0 = sparse_set.contains(StateID(0));",
          "    let contains_1 = sparse_set.contains(StateID(1));",
          "    let contains_2 = sparse_set.contains(StateID(2));",
          "    ",
          "    assert!(contains_0);  // should contain StateID(0)",
          "    assert!(contains_1);  // should contain StateID(1)",
          "    assert!(!contains_2); // should not contain StateID(2)",
          "    ",
          "    let capacity = sparse_set.capacity();",
          "    assert!(capacity >= 10);  // check that capacity is at least 10",
          "    ",
          "    let len = sparse_set.len();",
          "    assert_eq!(len, 2);  // check that length reflects the number of inserted IDs",
          "    ",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.len(), 0);  // should be empty after clear",
          "    assert!(sparse_set.is_empty());    // is_empty should return true after clear"
        ],
        "code": [
          "{",
          "    let sparse_set = SparseSet::new(0);",
          "    let contains = sparse_set.contains(StateID(0));",
          "    assert_eq!(sparse_set.len(), 0);",
          "    assert!(!contains);  // should not contain any StateID since set is empty",
          "    ",
          "    let mut sparse_set = SparseSet::new(10);",
          "    sparse_set.insert(StateID(0));",
          "    sparse_set.insert(StateID(1));",
          "    let contains_0 = sparse_set.contains(StateID(0));",
          "    let contains_1 = sparse_set.contains(StateID(1));",
          "    let contains_2 = sparse_set.contains(StateID(2));",
          "    ",
          "    assert!(contains_0);  // should contain StateID(0)",
          "    assert!(contains_1);  // should contain StateID(1)",
          "    assert!(!contains_2); // should not contain StateID(2)",
          "    ",
          "    let capacity = sparse_set.capacity();",
          "    assert!(capacity >= 10);  // check that capacity is at least 10",
          "    ",
          "    let len = sparse_set.len();",
          "    assert_eq!(len, 2);  // check that length reflects the number of inserted IDs",
          "    ",
          "    sparse_set.clear();",
          "    assert_eq!(sparse_set.len(), 0);  // should be empty after clear",
          "    assert!(sparse_set.is_empty());    // is_empty should return true after clear",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(StateID(0));",
          "    sparse_set.insert(StateID(1));",
          "",
          "    let contains_first = sparse_set.contains(StateID(0));",
          "    let contains_second = sparse_set.contains(StateID(1));",
          "    let not_contains_third = sparse_set.contains(StateID(2));",
          "}"
        ],
        "oracle": [
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert!(sparse_set.contains(StateID(0)));",
          "    assert!(sparse_set.contains(StateID(1)));",
          "    assert!(!sparse_set.contains(StateID(2)));"
        ],
        "code": [
          "{",
          "    let mut sparse_set = SparseSet::new(3);",
          "    sparse_set.insert(StateID(0));",
          "    sparse_set.insert(StateID(1));",
          "",
          "    let contains_first = sparse_set.contains(StateID(0));",
          "    let contains_second = sparse_set.contains(StateID(1));",
          "    let not_contains_third = sparse_set.contains(StateID(2));",
          "    assert_eq!(sparse_set.len(), 2);",
          "    assert!(sparse_set.contains(StateID(0)));",
          "    assert!(sparse_set.contains(StateID(1)));",
          "    assert!(!sparse_set.contains(StateID(2)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]