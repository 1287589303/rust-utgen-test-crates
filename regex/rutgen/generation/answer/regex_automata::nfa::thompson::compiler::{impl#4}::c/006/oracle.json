[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let expr = Hir::empty();",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracle": [
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State::default()), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap::default()) }; let expr = Hir::literal(b\"test\"); let result = compiler.c(&expr); assert!(result.is_ok()); let thompson_ref = result.unwrap(); assert_eq!(thompson_ref.start, expected_start_id); assert_eq!(thompson_ref.end, expected_end_id); let expr = Hir::class_bytes(vec![byte_range]); let result = compiler.c(&expr); assert!(result.is_ok()); let thompson_ref = result.unwrap(); assert_eq!(thompson_ref.start, expected_start_id); assert_eq!(thompson_ref.end, expected_end_id); let expr = Hir::class_unicode(vec![unicode_range]); let result = compiler.c(&expr); assert!(result.is_ok()); let thompson_ref = result.unwrap(); assert_eq!(thompson_ref.start, expected_start_id); assert_eq!(thompson_ref.end, expected_end_id);"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let expr = Hir::empty();",
          "    let _ = compiler.c(&expr);",
          "    let compiler = Compiler { parser: ParserBuilder::new(), config: Config::default(), builder: RefCell::new(Builder::default()), utf8_state: RefCell::new(Utf8State::default()), trie_state: RefCell::new(RangeTrie::default()), utf8_suffix: RefCell::new(Utf8SuffixMap::default()) }; let expr = Hir::literal(b\"test\"); let result = compiler.c(&expr); assert!(result.is_ok()); let thompson_ref = result.unwrap(); assert_eq!(thompson_ref.start, expected_start_id); assert_eq!(thompson_ref.end, expected_end_id); let expr = Hir::class_bytes(vec![byte_range]); let result = compiler.c(&expr); assert!(result.is_ok()); let thompson_ref = result.unwrap(); assert_eq!(thompson_ref.start, expected_start_id); assert_eq!(thompson_ref.end, expected_end_id); let expr = Hir::class_unicode(vec![unicode_range]); let result = compiler.c(&expr); assert!(result.is_ok()); let thompson_ref = result.unwrap(); assert_eq!(thompson_ref.start, expected_start_id); assert_eq!(thompson_ref.end, expected_end_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let expr = Hir::literal(vec![1]);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(compiler.c(&Hir::literal(vec![1])), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_bytes = Hir::class(Class::Bytes(hir::ClassBytes::new(vec![(1, 1)])));",
          "    assert_eq!(compiler.c(&expr_bytes), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_unicode = Hir::class(Class::Unicode(hir::ClassUnicode::new(vec![(1, 1)])));",
          "    assert_eq!(compiler.c(&expr_unicode), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_empty = Hir::empty();",
          "    assert_eq!(compiler.c(&expr_empty).is_err(), true);",
          "    let expr_repetition = Hir::repetition(Box::new(expr), 0, Some(1), true);",
          "    assert_eq!(compiler.c(&expr_repetition), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_capture = Hir::capture(0, None, Box::new(expr));",
          "    assert_eq!(compiler.c(&expr_capture), Ok(ThompsonRef { start: _, end: _ }));"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let expr = Hir::literal(vec![1]);",
          "    let _ = compiler.c(&expr);",
          "    assert_eq!(compiler.c(&Hir::literal(vec![1])), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_bytes = Hir::class(Class::Bytes(hir::ClassBytes::new(vec![(1, 1)])));",
          "    assert_eq!(compiler.c(&expr_bytes), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_unicode = Hir::class(Class::Unicode(hir::ClassUnicode::new(vec![(1, 1)])));",
          "    assert_eq!(compiler.c(&expr_unicode), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_empty = Hir::empty();",
          "    assert_eq!(compiler.c(&expr_empty).is_err(), true);",
          "    let expr_repetition = Hir::repetition(Box::new(expr), 0, Some(1), true);",
          "    assert_eq!(compiler.c(&expr_repetition), Ok(ThompsonRef { start: _, end: _ }));",
          "    let expr_capture = Hir::capture(0, None, Box::new(expr));",
          "    assert_eq!(compiler.c(&expr_capture), Ok(ThompsonRef { start: _, end: _ }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let expr = Hir::literal(vec![1, 2, 3]);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracle": [
          "    let expr_bytes = Hir::literal(vec![1, 2, 3]);",
          "    let expr_unicode = Hir::class_unicode(...);",
          "    let _bytes_result = compiler.c(&expr_bytes);",
          "    let _unicode_result = compiler.c(&expr_unicode);",
          "    let expr_byte_class = Hir::class_bytes(...);",
          "    let _byte_class_result = compiler.c(&expr_byte_class);",
          "    let lit_result = compiler.c_literal(&vec![4, 5, 6]);"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let expr = Hir::literal(vec![1, 2, 3]);",
          "    let _ = compiler.c(&expr);",
          "    let expr_bytes = Hir::literal(vec![1, 2, 3]);",
          "    let expr_unicode = Hir::class_unicode(...);",
          "    let _bytes_result = compiler.c(&expr_bytes);",
          "    let _unicode_result = compiler.c(&expr_unicode);",
          "    let expr_byte_class = Hir::class_bytes(...);",
          "    let _byte_class_result = compiler.c(&expr_byte_class);",
          "    let lit_result = compiler.c_literal(&vec![4, 5, 6]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![(0x20, 0x7E)]);",
          "    let expr = Hir::class_unicode(unicode_class);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracle": [
          "    let unicode_class = hir::ClassUnicode::new(vec![(0x20, 0x7E)]);",
          "    let expr = Hir::class_unicode(unicode_class);",
          "    let result = compiler.c(&expr);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start >= 0);",
          "    assert!(thompson_ref.end >= thompson_ref.start);",
          "    ",
          "    let byte_class = hir::ClassBytes::new(vec![(b'a', b'z')]);",
          "    let expr = Hir::class_bytes(byte_class);",
          "    let result = compiler.c(&expr);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start >= 0);",
          "    assert!(thompson_ref.end >= thompson_ref.start);",
          "    ",
          "    let literal = hir::Literal(vec![b'a', b'b', b'c']);",
          "    let expr = Hir::literal(literal);",
          "    let result = compiler.c(&expr);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start >= 0);",
          "    assert!(thompson_ref.end >= thompson_ref.start);"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let unicode_class = hir::ClassUnicode::new(vec![(0x20, 0x7E)]);",
          "    let expr = Hir::class_unicode(unicode_class);",
          "    let _ = compiler.c(&expr);",
          "    let unicode_class = hir::ClassUnicode::new(vec![(0x20, 0x7E)]);",
          "    let expr = Hir::class_unicode(unicode_class);",
          "    let result = compiler.c(&expr);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start >= 0);",
          "    assert!(thompson_ref.end >= thompson_ref.start);",
          "    ",
          "    let byte_class = hir::ClassBytes::new(vec![(b'a', b'z')]);",
          "    let expr = Hir::class_bytes(byte_class);",
          "    let result = compiler.c(&expr);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start >= 0);",
          "    assert!(thompson_ref.end >= thompson_ref.start);",
          "    ",
          "    let literal = hir::Literal(vec![b'a', b'b', b'c']);",
          "    let expr = Hir::literal(literal);",
          "    let result = compiler.c(&expr);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start >= 0);",
          "    assert!(thompson_ref.end >= thompson_ref.start);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let byte_class = hir::ClassBytes::new(vec![(0, 255)]);",
          "    let expr = Hir::class_bytes(byte_class);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracle": [
          "    let byte_class = hir::ClassBytes::new(vec![(0, 255)]);",
          "    let expr = Hir::class_bytes(byte_class);",
          "    assert!(compiler.c(&expr).is_ok());",
          "    ",
          "    let unicode_class = hir::ClassUnicode::new(vec![(0, 127)]);",
          "    let expr_unicode = Hir::class_unicode(unicode_class);",
          "    assert!(compiler.c(&expr_unicode).is_ok());",
          "    ",
          "    let literal = hir::Literal::new(vec![b'a']);",
          "    let expr_literal = Hir::literal(literal);",
          "    assert!(compiler.c(&expr_literal).is_ok());",
          "    ",
          "    let empty_class = hir::ClassBytes::new(vec![]);",
          "    let expr_empty = Hir::class_bytes(empty_class);",
          "    assert!(matches!(compiler.c(&expr_empty), Err(BuildError { kind: _ })));",
          "    ",
          "    let repeated_expr = hir::Repetition::new(box expr, 1, Some(1), false);",
          "    let expr_repetition = Hir::repetition(repeated_expr);",
          "    assert!(compiler.c(&expr_repetition).is_ok());",
          "    ",
          "    let capture_expr = hir::Capture::new(0, None, box expr);",
          "    let expr_capture = Hir::capture(capture_expr);",
          "    assert!(compiler.c(&expr_capture).is_ok());",
          "    ",
          "    let concat_expr = hir::Concat::new(vec![expr.clone(), expr.clone()]);",
          "    let expr_concat = Hir::concat(concat_expr);",
          "    assert!(compiler.c(&expr_concat).is_ok());",
          "    ",
          "    let alternation_expr = hir::Alternation::new(vec![expr.clone(), expr.clone()]);",
          "    let expr_alternation = Hir::alternation(alternation_expr);",
          "    assert!(compiler.c(&expr_alternation).is_ok());"
        ],
        "code": [
          "{",
          "    let compiler = Compiler {",
          "        parser: ParserBuilder::new(),",
          "        config: Config::default(),",
          "        builder: RefCell::new(Builder::default()),",
          "        utf8_state: RefCell::new(Utf8State::default()),",
          "        trie_state: RefCell::new(RangeTrie::default()),",
          "        utf8_suffix: RefCell::new(Utf8SuffixMap::default()),",
          "    };",
          "    let byte_class = hir::ClassBytes::new(vec![(0, 255)]);",
          "    let expr = Hir::class_bytes(byte_class);",
          "    let _ = compiler.c(&expr);",
          "    let byte_class = hir::ClassBytes::new(vec![(0, 255)]);",
          "    let expr = Hir::class_bytes(byte_class);",
          "    assert!(compiler.c(&expr).is_ok());",
          "    ",
          "    let unicode_class = hir::ClassUnicode::new(vec![(0, 127)]);",
          "    let expr_unicode = Hir::class_unicode(unicode_class);",
          "    assert!(compiler.c(&expr_unicode).is_ok());",
          "    ",
          "    let literal = hir::Literal::new(vec![b'a']);",
          "    let expr_literal = Hir::literal(literal);",
          "    assert!(compiler.c(&expr_literal).is_ok());",
          "    ",
          "    let empty_class = hir::ClassBytes::new(vec![]);",
          "    let expr_empty = Hir::class_bytes(empty_class);",
          "    assert!(matches!(compiler.c(&expr_empty), Err(BuildError { kind: _ })));",
          "    ",
          "    let repeated_expr = hir::Repetition::new(box expr, 1, Some(1), false);",
          "    let expr_repetition = Hir::repetition(repeated_expr);",
          "    assert!(compiler.c(&expr_repetition).is_ok());",
          "    ",
          "    let capture_expr = hir::Capture::new(0, None, box expr);",
          "    let expr_capture = Hir::capture(capture_expr);",
          "    assert!(compiler.c(&expr_capture).is_ok());",
          "    ",
          "    let concat_expr = hir::Concat::new(vec![expr.clone(), expr.clone()]);",
          "    let expr_concat = Hir::concat(concat_expr);",
          "    assert!(compiler.c(&expr_concat).is_ok());",
          "    ",
          "    let alternation_expr = hir::Alternation::new(vec![expr.clone(), expr.clone()]);",
          "    let expr_alternation = Hir::alternation(alternation_expr);",
          "    assert!(compiler.c(&expr_alternation).is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]