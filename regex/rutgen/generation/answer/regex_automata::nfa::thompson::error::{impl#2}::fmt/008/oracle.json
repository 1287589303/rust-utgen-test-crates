[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"error\".to_string())),",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"error parsing regex\") == core::fmt::format(format_args!(\"{}\", error))",
          "    error.kind() == BuildErrorKind::Syntax(_)"
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"error\".to_string())),",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    write!(f, \"error parsing regex\") == core::fmt::format(format_args!(\"{}\", error))",
          "    error.kind() == BuildErrorKind::Syntax(_)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"error\".to_string())),",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    let error = BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"syntax error\".to_string())) };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"error parsing regex\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"error\".to_string())) };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"error with capture groups\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new()) };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"NFA contains Unicode word boundary\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"attempted to compile 10 patterns, \\n              which exceeds the limit of 5\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyStates { given: 20, limit: 15 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"attempted to compile 20 NFA states, \\n              which exceeds the limit of 15\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"heap usage during NFA compilation exceeded limit of 1024\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 5 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"capture group index 5 is invalid (too big or discontinuous)\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::UnsupportedCaptures };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"currently captures must be disabled when compiling \\n              a reverse NFA\");"
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"error\".to_string())),",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    let error = BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"syntax error\".to_string())) };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"error parsing regex\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"error\".to_string())) };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"error with capture groups\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new()) };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"NFA contains Unicode word boundary\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"attempted to compile 10 patterns, \\n              which exceeds the limit of 5\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyStates { given: 20, limit: 15 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"attempted to compile 20 NFA states, \\n              which exceeds the limit of 15\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"heap usage during NFA compilation exceeded limit of 1024\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 5 } };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"capture group index 5 is invalid (too big or discontinuous)\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::UnsupportedCaptures };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"currently captures must be disabled when compiling \\n              a reverse NFA\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new(\"error\".to_string())),",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"syntax error\")) })) == \"error parsing regex\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"capture error\")) })) == \"error with capture groups\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new(\"Unicode error\".to_string())) })) == \"NFA contains Unicode word boundary\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::TooManyPatterns { given: 5, limit: 3 } })) == \"attempted to compile 5 patterns, \\n which exceeds the limit of 3\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::TooManyStates { given: 10, limit: 7 } })) == \"attempted to compile 10 NFA states, \\n which exceeds the limit of 7\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } })) == \"heap usage during NFA compilation exceeded limit of 1024\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 100 } })) == \"capture group index 100 is invalid (too big or discontinuous)\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::UnsupportedCaptures })) == \"currently captures must be disabled when compiling \\n a reverse NFA\""
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new(\"error\".to_string())),",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"syntax error\")) })) == \"error parsing regex\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"capture error\")) })) == \"error with capture groups\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new(\"Unicode error\".to_string())) })) == \"NFA contains Unicode word boundary\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::TooManyPatterns { given: 5, limit: 3 } })) == \"attempted to compile 5 patterns, \\n which exceeds the limit of 3\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::TooManyStates { given: 10, limit: 7 } })) == \"attempted to compile 10 NFA states, \\n which exceeds the limit of 7\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } })) == \"heap usage during NFA compilation exceeded limit of 1024\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 100 } })) == \"capture group index 100 is invalid (too big or discontinuous)\"",
          "    core::fmt::format(format_args!(\"{}\", BuildError { kind: BuildErrorKind::UnsupportedCaptures })) == \"currently captures must be disabled when compiling \\n a reverse NFA\"",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"attempted to compile {} patterns, which exceeds the limit of {}\", 10, 5)"
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    write!(f, \"attempted to compile {} patterns, which exceeds the limit of {}\", 10, 5)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::TooManyStates { given: 10, limit: 5 },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    let error = BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"syntax error\")) };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"error parsing regex\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"capture error\")) };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"error with capture groups\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new(\"unicode boundary error\")) };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"NFA contains Unicode word boundary\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"attempted to compile 10 patterns, which exceeds the limit of 5\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyStates { given: 10, limit: 5 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"attempted to compile 10 NFA states, which exceeds the limit of 5\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"heap usage during NFA compilation exceeded limit of 1024\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 5 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"capture group index 5 is invalid (too big or discontinuous)\");",
          "    ",
          "    #[cfg(feature = \"syntax\")]",
          "    let error = BuildError { kind: BuildErrorKind::UnsupportedCaptures };",
          "    #[cfg(feature = \"syntax\")]",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"currently captures must be disabled when compiling a reverse NFA\");"
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::TooManyStates { given: 10, limit: 5 },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    let error = BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new(\"syntax error\")) };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"error parsing regex\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new(\"capture error\")) };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"error with capture groups\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new(\"unicode boundary error\")) };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"NFA contains Unicode word boundary\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"attempted to compile 10 patterns, which exceeds the limit of 5\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::TooManyStates { given: 10, limit: 5 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"attempted to compile 10 NFA states, which exceeds the limit of 5\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"heap usage during NFA compilation exceeded limit of 1024\");",
          "    ",
          "    let error = BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 5 } };",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"capture group index 5 is invalid (too big or discontinuous)\");",
          "    ",
          "    #[cfg(feature = \"syntax\")]",
          "    let error = BuildError { kind: BuildErrorKind::UnsupportedCaptures };",
          "    #[cfg(feature = \"syntax\")]",
          "    assert_eq!(core::fmt::format(format_args!(\"{}\", error)), \"currently captures must be disabled when compiling a reverse NFA\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"heap usage during NFA compilation exceeded limit of {}\", 1024)"
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    write!(f, \"heap usage during NFA compilation exceeded limit of {}\", 1024)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::InvalidCaptureIndex { index: u32::MAX },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    write!(f, \"capture group index {} is invalid (too big or discontinuous)\", u32::MAX)"
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::InvalidCaptureIndex { index: u32::MAX },",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    write!(f, \"capture group index {} is invalid (too big or discontinuous)\", u32::MAX)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::UnsupportedCaptures,",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "}"
        ],
        "oracle": [
          "    let error = BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new()) };",
          "    let error = BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new()) };",
          "    let error = BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new()) };",
          "    let error = BuildError { kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 } };",
          "    let error = BuildError { kind: BuildErrorKind::TooManyStates { given: 10, limit: 5 } };",
          "    let error = BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } };",
          "    let error = BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 42 } };",
          "    let error = BuildError { kind: BuildErrorKind::UnsupportedCaptures };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"error parsing regex\");",
          "    assert_eq!(result, \"error with capture groups\");",
          "    assert_eq!(result, \"NFA contains Unicode word boundary\");",
          "    assert_eq!(result, \"attempted to compile 10 patterns, which exceeds the limit of 5\");",
          "    assert_eq!(result, \"attempted to compile 10 NFA states, which exceeds the limit of 5\");",
          "    assert_eq!(result, \"heap usage during NFA compilation exceeded limit of 1024\");",
          "    assert_eq!(result, \"capture group index 42 is invalid (too big or discontinuous)\");",
          "    assert_eq!(result, \"currently captures must be disabled when compiling a reverse NFA\");"
        ],
        "code": [
          "{",
          "    let error = BuildError {",
          "        kind: BuildErrorKind::UnsupportedCaptures,",
          "    };",
          "    let _ = core::fmt::format(format_args!(\"{}\", error));",
          "    let error = BuildError { kind: BuildErrorKind::Syntax(regex_syntax::Error::new()) };",
          "    let error = BuildError { kind: BuildErrorKind::Captures(captures::GroupInfoError::new()) };",
          "    let error = BuildError { kind: BuildErrorKind::Word(look::UnicodeWordBoundaryError::new()) };",
          "    let error = BuildError { kind: BuildErrorKind::TooManyPatterns { given: 10, limit: 5 } };",
          "    let error = BuildError { kind: BuildErrorKind::TooManyStates { given: 10, limit: 5 } };",
          "    let error = BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit: 1024 } };",
          "    let error = BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index: 42 } };",
          "    let error = BuildError { kind: BuildErrorKind::UnsupportedCaptures };",
          "    let result = core::fmt::format(format_args!(\"{}\", error));",
          "    assert_eq!(result, \"error parsing regex\");",
          "    assert_eq!(result, \"error with capture groups\");",
          "    assert_eq!(result, \"NFA contains Unicode word boundary\");",
          "    assert_eq!(result, \"attempted to compile 10 patterns, which exceeds the limit of 5\");",
          "    assert_eq!(result, \"attempted to compile 10 NFA states, which exceeds the limit of 5\");",
          "    assert_eq!(result, \"heap usage during NFA compilation exceeded limit of 1024\");",
          "    assert_eq!(result, \"capture group index 42 is invalid (too big or discontinuous)\");",
          "    assert_eq!(result, \"currently captures must be disabled when compiling a reverse NFA\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]