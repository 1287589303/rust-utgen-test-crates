[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"(?P<my_capture>abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result.is_ok(), true);",
          "    let group = _result.unwrap();",
          "    assert!(matches!(group, Either::Right(_)));",
          "    assert_eq!(group.span.start.offset, 0);",
          "    assert_eq!(group.span.end.offset, pattern.len());",
          "    assert_eq!(group.kind, ast::GroupKind::CaptureName { starts_with_p: true, name });",
          "    assert_eq!(name.name, \"my_capture\");",
          "    assert_eq!(name.index, 0);",
          "    assert_eq!(name.span.start.offset, 4);",
          "    assert_eq!(name.span.end.offset, 14);"
        ],
        "code": [
          "{",
          "    let pattern = \"(?P<my_capture>abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "    assert_eq!(_result.is_ok(), true);",
          "    let group = _result.unwrap();",
          "    assert!(matches!(group, Either::Right(_)));",
          "    assert_eq!(group.span.start.offset, 0);",
          "    assert_eq!(group.span.end.offset, pattern.len());",
          "    assert_eq!(group.kind, ast::GroupKind::CaptureName { starts_with_p: true, name });",
          "    assert_eq!(name.name, \"my_capture\");",
          "    assert_eq!(name.index, 0);",
          "    assert_eq!(name.span.start.offset, 4);",
          "    assert_eq!(name.span.end.offset, 14);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"(?i:abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(*result, Either::Right(ast::Group { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 8, line: 1, column: 9 } }, kind: GroupKind::NonCapturing(flags), ast: Box::new(Ast::empty(span)) }));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::RepetitionMissing, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupUnclosed, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::UnsupportedLookAround, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::FlagDuplicate { .. }, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::FlagUnexpectedEof, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupNameInvalid, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupNameUnexpectedEof, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupNameEmpty, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::CaptureLimitExceeded, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::CaptureNameDuplicate { .. }, .. })));"
        ],
        "code": [
          "{",
          "    let pattern = \"(?i:abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "    assert_eq!(*result, Either::Right(ast::Group { span: Span { start: Position { offset: 0, line: 1, column: 1 }, end: Position { offset: 8, line: 1, column: 9 } }, kind: GroupKind::NonCapturing(flags), ast: Box::new(Ast::empty(span)) }));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::RepetitionMissing, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupUnclosed, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::UnsupportedLookAround, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::FlagDuplicate { .. }, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::FlagUnexpectedEof, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupNameInvalid, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupNameUnexpectedEof, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::GroupNameEmpty, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::CaptureLimitExceeded, .. })));",
          "    assert!(matches!(result, Err(Error { kind: ErrorKind::CaptureNameDuplicate { .. }, .. })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"(?)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(_result, Err(ast::Error { kind: ast::ErrorKind::RepetitionMissing, .. })));",
          "    assert_eq!(parser.pos().offset, 2);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 3);",
          "    assert!(parser.capture_index.get() == 0);"
        ],
        "code": [
          "{",
          "    let pattern = \"(?)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "    assert!(matches!(_result, Err(ast::Error { kind: ast::ErrorKind::RepetitionMissing, .. })));",
          "    assert_eq!(parser.pos().offset, 2);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 3);",
          "    assert!(parser.capture_index.get() == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"(abc\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '(');",
          "    assert!(matches!(_result, Err(ast::ErrorKind::GroupUnclosed)));",
          "    assert_eq!(parser.span().start.offset, 0);",
          "    assert_eq!(parser.span().end.offset, 4);",
          "    assert!(parser.is_eof());",
          "    assert!(parser.bump_if(\"(\"));",
          "    assert!(parser.bump_space());",
          "    assert!(parser.next_capture_index(open_span).is_err());",
          "    assert!(parser.parse_flags().is_err());",
          "    assert!(parser.parse_capture_name(capture_index).is_err());"
        ],
        "code": [
          "{",
          "    let pattern = \"(abc\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "    assert_eq!(parser.char(), '(');",
          "    assert!(matches!(_result, Err(ast::ErrorKind::GroupUnclosed)));",
          "    assert_eq!(parser.span().start.offset, 0);",
          "    assert_eq!(parser.span().end.offset, 4);",
          "    assert!(parser.is_eof());",
          "    assert!(parser.bump_if(\"(\"));",
          "    assert!(parser.bump_space());",
          "    assert!(parser.next_capture_index(open_span).is_err());",
          "    assert!(parser.parse_flags().is_err());",
          "    assert!(parser.parse_capture_name(capture_index).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"(?P<>abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.pos(), Position { offset: 0, line: 1, column: 1 });",
          "    assert!(matches!(_result, Err(Error { kind: ErrorKind::GroupNameEmpty, .. })));"
        ],
        "code": [
          "{",
          "    let pattern = \"(?P<>abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "    assert_eq!(parser.pos(), Position { offset: 0, line: 1, column: 1 });",
          "    assert!(matches!(_result, Err(Error { kind: ErrorKind::GroupNameEmpty, .. })));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"(?P<1invalid>abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(parser.parse_group(), Err(e) if e.kind == ast::ErrorKind::GroupNameInvalid));",
          "    assert_eq!(parser.pos().offset, 0);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 1);",
          "    assert!(parser.is_eof());"
        ],
        "code": [
          "{",
          "    let pattern = \"(?P<1invalid>abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "    assert!(matches!(parser.parse_group(), Err(e) if e.kind == ast::ErrorKind::GroupNameInvalid));",
          "    assert_eq!(parser.pos().offset, 0);",
          "    assert_eq!(parser.pos().line, 1);",
          "    assert_eq!(parser.pos().column, 1);",
          "    assert!(parser.is_eof());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"(?=abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(parser.char(), '(');",
          "    assert_eq!(parser.bump_if(\"?P<\"), false);",
          "    assert_eq!(parser.bump_if(\"?<\"), false);",
          "    assert!(parser.is_lookaround_prefix());",
          "    assert!(matches!(_result, Err(ast::ErrorKind::UnsupportedLookAround)));"
        ],
        "code": [
          "{",
          "    let pattern = \"(?=abc)\";",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern,",
          "    };",
          "    let _result = parser.parse_group();",
          "    assert_eq!(parser.char(), '(');",
          "    assert_eq!(parser.bump_if(\"?P<\"), false);",
          "    assert_eq!(parser.bump_if(\"?<\"), false);",
          "    assert!(parser.is_lookaround_prefix());",
          "    assert!(matches!(_result, Err(ast::ErrorKind::UnsupportedLookAround)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]