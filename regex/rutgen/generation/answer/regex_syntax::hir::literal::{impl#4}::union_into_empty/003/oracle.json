[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq1 = Seq::new(&[b\"a\", b\"b\", b\"c\"]);",
          "    let mut seq2 = Seq::new(&[b\"x\", b\"y\", b\"z\"]);",
          "    seq1.union_into_empty(&mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq1.literals(), Some(&[b\"a\", b\"b\", b\"c\"]));",
          "    assert_eq!(seq2.len(), Some(0));",
          "    assert_eq!(seq1.len(), Some(3));",
          "    assert_eq!(seq1.literals(), Some(&[b\"a\", b\"b\", b\"c\"]));",
          "    assert!(seq1.is_finite());",
          "    assert!(!seq1.is_empty());"
        ],
        "code": [
          "{",
          "    let mut seq1 = Seq::new(&[b\"a\", b\"b\", b\"c\"]);",
          "    let mut seq2 = Seq::new(&[b\"x\", b\"y\", b\"z\"]);",
          "    seq1.union_into_empty(&mut seq2);",
          "    assert_eq!(seq1.literals(), Some(&[b\"a\", b\"b\", b\"c\"]));",
          "    assert_eq!(seq2.len(), Some(0));",
          "    assert_eq!(seq1.len(), Some(3));",
          "    assert_eq!(seq1.literals(), Some(&[b\"a\", b\"b\", b\"c\"]));",
          "    assert!(seq1.is_finite());",
          "    assert!(!seq1.is_empty());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq1 = Seq::new(&[b\"one\", b\"two\"]);",
          "    let mut seq2 = Seq::new(&[b\"three\"]);",
          "    seq1.union_into_empty(&mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(Some(1), seq2.len());",
          "    assert_eq!(Seq::new(&[b\"one\", b\"two\"]), seq1);",
          "    assert_eq!(lits1.iter().position(|m| m.is_empty()), None);",
          "    assert_eq!(self.literals, Some(vec![Literal::new(b\"one\"), Literal::new(b\"two\")]));",
          "    assert_eq!(other.literals, Some(vec![Literal::new(b\"three\")]));"
        ],
        "code": [
          "{",
          "    let mut seq1 = Seq::new(&[b\"one\", b\"two\"]);",
          "    let mut seq2 = Seq::new(&[b\"three\"]);",
          "    seq1.union_into_empty(&mut seq2);",
          "    assert_eq!(Some(1), seq2.len());",
          "    assert_eq!(Seq::new(&[b\"one\", b\"two\"]), seq1);",
          "    assert_eq!(lits1.iter().position(|m| m.is_empty()), None);",
          "    assert_eq!(self.literals, Some(vec![Literal::new(b\"one\"), Literal::new(b\"two\")]));",
          "    assert_eq!(other.literals, Some(vec![Literal::new(b\"three\")]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut seq1 = Seq::new(&[b\"alpha\", b\"beta\"]);",
          "    let mut seq2 = Seq::new(&[b\"beta\", b\"gamma\"]);",
          "    seq1.union_into_empty(&mut seq2);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(seq1.literals().unwrap(), &[b\"alpha\", b\"beta\"]);",
          "    assert_eq!(seq2.len(), Some(0));"
        ],
        "code": [
          "{",
          "    let mut seq1 = Seq::new(&[b\"alpha\", b\"beta\"]);",
          "    let mut seq2 = Seq::new(&[b\"beta\", b\"gamma\"]);",
          "    seq1.union_into_empty(&mut seq2);",
          "    assert_eq!(seq1.literals().unwrap(), &[b\"alpha\", b\"beta\"]);",
          "    assert_eq!(seq2.len(), Some(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]