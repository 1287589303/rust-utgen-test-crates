[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(1);",
          "    let key = vec![];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(0);",
          "    map.set(key, hash, state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), 1);",
          "    assert_eq!(map.map[hash].version, 0);",
          "    assert_eq!(map.map[hash].key.len(), 0);",
          "    assert_eq!(map.map[hash].val, StateID(0));",
          "    assert!(map.get(&key, hash).is_some());",
          "    assert_eq!(map.get(&key, hash).unwrap(), StateID(0));"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(1);",
          "    let key = vec![];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(0);",
          "    map.set(key, hash, state_id);",
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), 1);",
          "    assert_eq!(map.map[hash].version, 0);",
          "    assert_eq!(map.map[hash].key.len(), 0);",
          "    assert_eq!(map.map[hash].val, StateID(0));",
          "    assert!(map.get(&key, hash).is_some());",
          "    assert_eq!(map.get(&key, hash).unwrap(), StateID(0));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = vec![Transition { start: 1, end: 1, next: StateID(1) }];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(1);",
          "    map.set(key.clone(), hash, state_id);",
          "}"
        ],
        "oracle": [
          "    map.version == 0",
          "    map.capacity == 10",
          "    map.map.len() == 10",
          "    map.map[hash].version == map.version",
          "    map.map[hash].key == key",
          "    map.map[hash].val == state_id"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = vec![Transition { start: 1, end: 1, next: StateID(1) }];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(1);",
          "    map.set(key.clone(), hash, state_id);",
          "    map.version == 0",
          "    map.capacity == 10",
          "    map.map.len() == 10",
          "    map.map[hash].version == map.version",
          "    map.map[hash].key == key",
          "    map.map[hash].val == state_id",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = vec![Transition { start: 0, end: 255, next: StateID(2) }];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(2);",
          "    map.set(key.clone(), hash, state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), 10);",
          "    assert!(map.map.iter().all(|entry| entry.version == 0));",
          "    assert_eq!(map.get(&key, hash), Some(state_id));",
          "    assert_eq!(map.map[hash].key, key);",
          "    assert_eq!(map.map[hash].val, state_id);",
          "    assert_eq!(map.map[hash].version, map.version);"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = vec![Transition { start: 0, end: 255, next: StateID(2) }];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(2);",
          "    map.set(key.clone(), hash, state_id);",
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), 10);",
          "    assert!(map.map.iter().all(|entry| entry.version == 0));",
          "    assert_eq!(map.get(&key, hash), Some(state_id));",
          "    assert_eq!(map.map[hash].key, key);",
          "    assert_eq!(map.map[hash].val, state_id);",
          "    assert_eq!(map.map[hash].version, map.version);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let capacity = 1_000_000;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    let key = vec![Transition { start: 0, end: 0, next: StateID(3) }];",
          "    let hash = map.hash(&key) % capacity;",
          "    let state_id = StateID(3);",
          "    map.set(key.clone(), hash, state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), capacity);",
          "    assert!(map.map[hash].version == 0);",
          "    assert!(map.map[hash].key == key);",
          "    assert!(map.map[hash].val == state_id);"
        ],
        "code": [
          "{",
          "    let capacity = 1_000_000;",
          "    let mut map = Utf8BoundedMap::new(capacity);",
          "    let key = vec![Transition { start: 0, end: 0, next: StateID(3) }];",
          "    let hash = map.hash(&key) % capacity;",
          "    let state_id = StateID(3);",
          "    map.set(key.clone(), hash, state_id);",
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), capacity);",
          "    assert!(map.map[hash].version == 0);",
          "    assert!(map.map[hash].key == key);",
          "    assert!(map.map[hash].val == state_id);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = vec![",
          "        Transition { start: 0, end: 1, next: StateID(4) },",
          "        Transition { start: 2, end: 3, next: StateID(5) },",
          "    ];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(4);",
          "    map.set(key, hash, state_id);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), 10);",
          "    assert_eq!(map.map[hash].version, 0);",
          "    assert_eq!(map.map[hash].key.len(), 2);",
          "    assert_eq!(map.map[hash].key[0], Transition { start: 0, end: 1, next: StateID(4) });",
          "    assert_eq!(map.map[hash].key[1], Transition { start: 2, end: 3, next: StateID(5) });",
          "    assert_eq!(map.map[hash].val, state_id);",
          "    assert!(map.get(&key, hash).is_some());",
          "    assert_eq!(map.get(&key, hash), Some(state_id));"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = vec![",
          "        Transition { start: 0, end: 1, next: StateID(4) },",
          "        Transition { start: 2, end: 3, next: StateID(5) },",
          "    ];",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(4);",
          "    map.set(key, hash, state_id);",
          "    assert_eq!(map.version, 0);",
          "    assert_eq!(map.map.len(), 10);",
          "    assert_eq!(map.map[hash].version, 0);",
          "    assert_eq!(map.map[hash].key.len(), 2);",
          "    assert_eq!(map.map[hash].key[0], Transition { start: 0, end: 1, next: StateID(4) });",
          "    assert_eq!(map.map[hash].key[1], Transition { start: 2, end: 3, next: StateID(5) });",
          "    assert_eq!(map.map[hash].val, state_id);",
          "    assert!(map.get(&key, hash).is_some());",
          "    assert_eq!(map.get(&key, hash), Some(state_id));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = (0..255)",
          "        .map(|i| Transition { start: i, end: 255, next: StateID(i as u32) })",
          "        .collect::<Vec<Transition>>();",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(255);",
          "    map.set(key, hash, state_id);",
          "}"
        ],
        "oracle": [
          "    let map = Utf8BoundedMap::new(10);",
          "    let key = (0..255).map(|i| Transition { start: i, end: 255, next: StateID(i as u32) }).collect::<Vec<Transition>>();",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(255);",
          "    map.set(key, hash, state_id);",
          "    assert_eq!(map.get(&key, hash), Some(state_id));",
          "    assert_eq!(map.map[hash].version, map.version);",
          "    assert_eq!(map.map[hash].key.len(), 256);",
          "    assert_eq!(map.map[hash].val, state_id);",
          "    assert!(map.get(&key, hash).is_some());"
        ],
        "code": [
          "{",
          "    let mut map = Utf8BoundedMap::new(10);",
          "    let key = (0..255)",
          "        .map(|i| Transition { start: i, end: 255, next: StateID(i as u32) })",
          "        .collect::<Vec<Transition>>();",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(255);",
          "    map.set(key, hash, state_id);",
          "    let map = Utf8BoundedMap::new(10);",
          "    let key = (0..255).map(|i| Transition { start: i, end: 255, next: StateID(i as u32) }).collect::<Vec<Transition>>();",
          "    let hash = map.hash(&key);",
          "    let state_id = StateID(255);",
          "    map.set(key, hash, state_id);",
          "    assert_eq!(map.get(&key, hash), Some(state_id));",
          "    assert_eq!(map.map[hash].version, map.version);",
          "    assert_eq!(map.map[hash].key.len(), 256);",
          "    assert_eq!(map.map[hash].val, state_id);",
          "    assert!(map.get(&key, hash).is_some());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]