[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Clone)]",
          "    struct TestTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let mut sparse_data = vec![0u8; 256];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = TestTransitions {",
          "        sparse: sparse_data,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(1),",
          "        min_start: StateID(1),",
          "        max_start: StateID(1),",
          "    };",
          "",
          "    let mut id = StateID(0);",
          "    while id.0 < transitions.sparse.len() {",
          "        let state = transitions.try_state(&special, id).unwrap();",
          "        let next_id = wire::add(id.0, state.write_to_len(), \"next state ID offset\").unwrap();",
          "        id = StateID::new(next_id).unwrap();",
          "    }",
          "",
          "    assert_eq!(transitions.state_len, 1);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(validate(&transitions, &special).is_ok(), true);",
          "    assert_eq!(transitions.try_state(&special, StateID(0)).is_ok(), true);",
          "    assert_eq!(transitions.try_state(&special, StateID(1)).is_ok(), true);",
          "    assert_eq!(wire::add(id.0, transitions.try_state(&special, id).unwrap().write_to_len(), \"next state ID offset\").is_ok(), true);",
          "    assert_eq!(StateID::new(wire::add(id.0, transitions.try_state(&special, id).unwrap().write_to_len(), \"next state ID offset\").unwrap()).is_ok(), true);",
          "    assert_eq!(transitions.states().next().is_some(), true);",
          "    assert_eq!(transitions.states().next().is_none(), false);",
          "    assert_eq!(transitions.state_len, 1);"
        ],
        "code": [
          "{",
          "    #[derive(Clone)]",
          "    struct TestTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let mut sparse_data = vec![0u8; 256];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = TestTransitions {",
          "        sparse: sparse_data,",
          "        classes,",
          "        state_len: 1,",
          "        pattern_len: 1,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(1),",
          "        min_start: StateID(1),",
          "        max_start: StateID(1),",
          "    };",
          "",
          "    let mut id = StateID(0);",
          "    while id.0 < transitions.sparse.len() {",
          "        let state = transitions.try_state(&special, id).unwrap();",
          "        let next_id = wire::add(id.0, state.write_to_len(), \"next state ID offset\").unwrap();",
          "        id = StateID::new(next_id).unwrap();",
          "    }",
          "",
          "    assert_eq!(transitions.state_len, 1);",
          "    assert_eq!(validate(&transitions, &special).is_ok(), true);",
          "    assert_eq!(transitions.try_state(&special, StateID(0)).is_ok(), true);",
          "    assert_eq!(transitions.try_state(&special, StateID(1)).is_ok(), true);",
          "    assert_eq!(wire::add(id.0, transitions.try_state(&special, id).unwrap().write_to_len(), \"next state ID offset\").is_ok(), true);",
          "    assert_eq!(StateID::new(wire::add(id.0, transitions.try_state(&special, id).unwrap().write_to_len(), \"next state ID offset\").unwrap()).is_ok(), true);",
          "    assert_eq!(transitions.states().next().is_some(), true);",
          "    assert_eq!(transitions.states().next().is_none(), false);",
          "    assert_eq!(transitions.state_len, 1);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Clone)]",
          "    struct TestTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let sparse_data = vec![0u8; 256];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = TestTransitions {",
          "        sparse: sparse_data,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 1,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(1),",
          "        min_start: StateID(1),",
          "        max_start: StateID(1),",
          "    };",
          "",
          "    let id = StateID(1);",
          "    let state = transitions.try_state(&special, id).unwrap();",
          "    let next_id = wire::add(id.0, state.write_to_len(), \"next state ID offset\").unwrap();",
          "    let new_id = StateID::new(next_id).unwrap();",
          "",
          "    assert!(id.0 < transitions.sparse.len());",
          "}"
        ],
        "oracle": [
          "    assert!(id.as_usize() < self.sparse().len());",
          "    assert!(!sp.is_special_state(id));",
          "    assert!(self.try_state(sp, id).is_ok());",
          "    assert!(wire::add(id.as_usize(), state.write_to_len(), \"next state ID offset\").is_ok());",
          "    assert!(StateID::new(wire::add(id.as_usize(), state.write_to_len(), \"next state ID offset\").unwrap()).is_ok());",
          "    assert!(id.as_usize() >= self.sparse().len());",
          "    assert!(self.states().iter().any(|s| s.id() == id));",
          "    assert!(i < state.ntrans);",
          "    assert!(verified.contains(&to));",
          "    assert!(i >= state.ntrans);",
          "    assert!(!self.states().any(|s| s.id() == id));",
          "    assert!(len == self.state_len);",
          "    assert_eq!(self.validate(&special), Ok(verified));"
        ],
        "code": [
          "{",
          "    #[derive(Clone)]",
          "    struct TestTransitions {",
          "        sparse: Vec<u8>,",
          "        classes: ByteClasses,",
          "        state_len: usize,",
          "        pattern_len: usize,",
          "    }",
          "",
          "    let sparse_data = vec![0u8; 256];",
          "    let classes = ByteClasses([0; 256]);",
          "    let transitions = TestTransitions {",
          "        sparse: sparse_data,",
          "        classes,",
          "        state_len: 2,",
          "        pattern_len: 1,",
          "    };",
          "",
          "    let special = Special {",
          "        max: StateID(1),",
          "        quit_id: StateID(0),",
          "        min_match: StateID(1),",
          "        max_match: StateID(1),",
          "        min_accel: StateID(1),",
          "        max_accel: StateID(1),",
          "        min_start: StateID(1),",
          "        max_start: StateID(1),",
          "    };",
          "",
          "    let id = StateID(1);",
          "    let state = transitions.try_state(&special, id).unwrap();",
          "    let next_id = wire::add(id.0, state.write_to_len(), \"next state ID offset\").unwrap();",
          "    let new_id = StateID::new(next_id).unwrap();",
          "",
          "    assert!(id.0 < transitions.sparse.len());",
          "    assert!(id.as_usize() < self.sparse().len());",
          "    assert!(!sp.is_special_state(id));",
          "    assert!(self.try_state(sp, id).is_ok());",
          "    assert!(wire::add(id.as_usize(), state.write_to_len(), \"next state ID offset\").is_ok());",
          "    assert!(StateID::new(wire::add(id.as_usize(), state.write_to_len(), \"next state ID offset\").unwrap()).is_ok());",
          "    assert!(id.as_usize() >= self.sparse().len());",
          "    assert!(self.states().iter().any(|s| s.id() == id));",
          "    assert!(i < state.ntrans);",
          "    assert!(verified.contains(&to));",
          "    assert!(i >= state.ntrans);",
          "    assert!(!self.states().any(|s| s.id() == id));",
          "    assert!(len == self.state_len);",
          "    assert_eq!(self.validate(&special), Ok(verified));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]