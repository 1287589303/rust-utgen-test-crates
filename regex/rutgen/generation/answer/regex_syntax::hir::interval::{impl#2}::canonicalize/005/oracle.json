[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd, Eq, Ord)]",
      "struct TestBound(u32);",
      "",
      "impl TestBound {",
      "    fn increment(self) -> Self {",
      "        TestBound(self.0 + 1)",
      "    }",
      "    ",
      "    fn decrement(self) -> Self {",
      "        TestBound(self.0 - 1)",
      "    }",
      "}",
      "",
      "impl Bound for TestBound {}",
      "",
      "#[derive(Clone, Debug, Default, PartialEq, PartialOrd)]",
      "struct TestInterval {",
      "    lower: TestBound,",
      "    upper: TestBound,",
      "}",
      "",
      "impl Interval for TestInterval {",
      "    type Bound = TestBound;",
      "",
      "    fn lower(&self) -> Self::Bound { self.lower }",
      "    fn upper(&self) -> Self::Bound { self.upper }",
      "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
      "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
      "    fn case_fold_simple(&self, _: &mut Vec<Self>) -> Result<(), unicode::CaseFoldError> { Ok(()) }",
      "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
      "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
      "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(7) },",
          "        TestInterval { lower: TestBound(8), upper: TestBound(10) },",
          "    ]);",
          "    set.canonicalize();",
          "}"
        ],
        "oracle": [
          "    set.ranges[0].is_contiguous(&set.ranges[1]);",
          "    set.ranges[1].is_contiguous(&set.ranges[0]);",
          "    set.ranges.len() == 3;",
          "    set.is_canonical() == false;",
          "    set.ranges[0].lower() == TestBound(1);",
          "    set.ranges[0].upper() == TestBound(5);",
          "    set.ranges[1].lower() == TestBound(3);",
          "    set.ranges[1].upper() == TestBound(7);",
          "    set.ranges[2].lower() == TestBound(8);",
          "    set.ranges[2].upper() == TestBound(10);",
          "    set.ranges.sort();",
          "    set.ranges.drain(..set.ranges.len());",
          "    set.ranges.push(set.ranges[0]);",
          "    set.ranges.push(set.ranges[1]);",
          "    set.ranges.push(set.ranges[2]);",
          "    assert!(!set.ranges.is_empty());",
          "    set.is_canonical();",
          "    set.ranges.len() == 2;",
          "    set.ranges[0].lower() == TestBound(1);",
          "    set.ranges[0].upper() == TestBound(7);",
          "    set.ranges[1].lower() == TestBound(8);",
          "    set.ranges[1].upper() == TestBound(10);"
        ],
        "code": [
          "{",
          "    let mut set = IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(7) },",
          "        TestInterval { lower: TestBound(8), upper: TestBound(10) },",
          "    ]);",
          "    set.canonicalize();",
          "    set.ranges[0].is_contiguous(&set.ranges[1]);",
          "    set.ranges[1].is_contiguous(&set.ranges[0]);",
          "    set.ranges.len() == 3;",
          "    set.is_canonical() == false;",
          "    set.ranges[0].lower() == TestBound(1);",
          "    set.ranges[0].upper() == TestBound(5);",
          "    set.ranges[1].lower() == TestBound(3);",
          "    set.ranges[1].upper() == TestBound(7);",
          "    set.ranges[2].lower() == TestBound(8);",
          "    set.ranges[2].upper() == TestBound(10);",
          "    set.ranges.sort();",
          "    set.ranges.drain(..set.ranges.len());",
          "    set.ranges.push(set.ranges[0]);",
          "    set.ranges.push(set.ranges[1]);",
          "    set.ranges.push(set.ranges[2]);",
          "    assert!(!set.ranges.is_empty());",
          "    set.is_canonical();",
          "    set.ranges.len() == 2;",
          "    set.ranges[0].lower() == TestBound(1);",
          "    set.ranges[0].upper() == TestBound(7);",
          "    set.ranges[1].lower() == TestBound(8);",
          "    set.ranges[1].upper() == TestBound(10);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(6), upper: TestBound(9) },",
          "    ]);",
          "    set.canonicalize();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(set.ranges.len(), 3);",
          "    assert_eq!(set.ranges[0], TestInterval { lower: TestBound(1), upper: TestBound(5) });",
          "    assert_eq!(set.ranges[1], TestInterval { lower: TestBound(6), upper: TestBound(9) });",
          "    assert!(set.is_canonical());",
          "    set.canonicalize();",
          "    assert_eq!(set.ranges.len(), 3);",
          "    assert_eq!(set.ranges[0], TestInterval { lower: TestBound(1), upper: TestBound(5) });",
          "    assert_eq!(set.ranges[1], TestInterval { lower: TestBound(6), upper: TestBound(9) });",
          "    assert!(set.is_canonical());"
        ],
        "code": [
          "{",
          "    let mut set = IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(6), upper: TestBound(9) },",
          "    ]);",
          "    set.canonicalize();",
          "    assert_eq!(set.ranges.len(), 3);",
          "    assert_eq!(set.ranges[0], TestInterval { lower: TestBound(1), upper: TestBound(5) });",
          "    assert_eq!(set.ranges[1], TestInterval { lower: TestBound(6), upper: TestBound(9) });",
          "    assert!(set.is_canonical());",
          "    set.canonicalize();",
          "    assert_eq!(set.ranges.len(), 3);",
          "    assert_eq!(set.ranges[0], TestInterval { lower: TestBound(1), upper: TestBound(5) });",
          "    assert_eq!(set.ranges[1], TestInterval { lower: TestBound(6), upper: TestBound(9) });",
          "    assert!(set.is_canonical());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut set = IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(2), upper: TestBound(8) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(4), upper: TestBound(6) },",
          "    ]);",
          "    set.canonicalize();",
          "}"
        ],
        "oracle": [
          "    let mut set = IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(5), upper: TestBound(10) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(2), upper: TestBound(4) },",
          "    ]);",
          "    set.canonicalize();",
          "    assert_eq!(set.intervals(), &[TestInterval { lower: TestBound(1), upper: TestBound(10) }]);",
          "    ",
          "    let mut set = IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(2), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(7), upper: TestBound(9) },",
          "    ]);",
          "    set.canonicalize();",
          "    assert_eq!(set.intervals(), &[TestInterval { lower: TestBound(2), upper: TestBound(5) }, TestInterval { lower: TestBound(7), upper: TestBound(9) }]);",
          "    ",
          "    let mut set = IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(10), upper: TestBound(12) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "    ]);",
          "    set.canonicalize();",
          "    assert_eq!(set.intervals(), &[TestInterval { lower: TestBound(1), upper: TestBound(2) }, TestInterval { lower: TestBound(10), upper: TestBound(12) }]);"
        ],
        "code": [
          "{",
          "    let mut set = IntervalSet::new(vec![",
          "        TestInterval { lower: TestBound(2), upper: TestBound(8) },",
          "        TestInterval { lower: TestBound(3), upper: TestBound(5) },",
          "        TestInterval { lower: TestBound(4), upper: TestBound(6) },",
          "    ]);",
          "    set.canonicalize();",
          "    let mut set = IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(5), upper: TestBound(10) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(3) },",
          "    TestInterval { lower: TestBound(2), upper: TestBound(4) },",
          "    ]);",
          "    set.canonicalize();",
          "    assert_eq!(set.intervals(), &[TestInterval { lower: TestBound(1), upper: TestBound(10) }]);",
          "    ",
          "    let mut set = IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(2), upper: TestBound(5) },",
          "    TestInterval { lower: TestBound(7), upper: TestBound(9) },",
          "    ]);",
          "    set.canonicalize();",
          "    assert_eq!(set.intervals(), &[TestInterval { lower: TestBound(2), upper: TestBound(5) }, TestInterval { lower: TestBound(7), upper: TestBound(9) }]);",
          "    ",
          "    let mut set = IntervalSet::new(vec![",
          "    TestInterval { lower: TestBound(10), upper: TestBound(12) },",
          "    TestInterval { lower: TestBound(1), upper: TestBound(2) },",
          "    ]);",
          "    set.canonicalize();",
          "    assert_eq!(set.intervals(), &[TestInterval { lower: TestBound(1), upper: TestBound(2) }, TestInterval { lower: TestBound(10), upper: TestBound(12) }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]