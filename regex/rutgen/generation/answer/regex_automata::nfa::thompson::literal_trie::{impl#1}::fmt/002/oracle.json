[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id = StateID(0.into());",
          "    let state = State {",
          "        id: state_id,",
          "        is_match: false,",
          "        ntrans: 0,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "    ",
          "    let trie = LiteralTrie {",
          "        states: vec![state],",
          "        rev: false,",
          "    };",
          "    ",
          "    let mut buffer = vec![];",
          "    let mut formatter = core::fmt::Formatter::new(&mut buffer);",
          "    ",
          "    let _ = trie.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(writeln!(formatter, \"LiteralTrie(\"), Ok(()));",
          "    assert!(trie.states.iter().next().is_some());",
          "    assert!(writeln!(formatter, \"{:06?}: {:?}\", state_id.as_usize(), &trie.states[0]).is_err());"
        ],
        "code": [
          "{",
          "    let state_id = StateID(0.into());",
          "    let state = State {",
          "        id: state_id,",
          "        is_match: false,",
          "        ntrans: 0,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "    ",
          "    let trie = LiteralTrie {",
          "        states: vec![state],",
          "        rev: false,",
          "    };",
          "    ",
          "    let mut buffer = vec![];",
          "    let mut formatter = core::fmt::Formatter::new(&mut buffer);",
          "    ",
          "    let _ = trie.fmt(&mut formatter);",
          "    assert_eq!(writeln!(formatter, \"LiteralTrie(\"), Ok(()));",
          "    assert!(trie.states.iter().next().is_some());",
          "    assert!(writeln!(formatter, \"{:06?}: {:?}\", state_id.as_usize(), &trie.states[0]).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id_1 = StateID(1.into());",
          "    let state_1 = State {",
          "        id: state_id_1,",
          "        is_match: false,",
          "        ntrans: 1,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "    ",
          "    let state_id_2 = StateID(2.into());",
          "    let state_2 = State {",
          "        id: state_id_2,",
          "        is_match: true,",
          "        ntrans: 1,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "",
          "    let trie = LiteralTrie {",
          "        states: vec![state_1, state_2],",
          "        rev: false,",
          "    };",
          "    ",
          "    let mut buffer = vec![];",
          "    let mut formatter = core::fmt::Formatter::new(&mut buffer);",
          "    ",
          "    let _ = trie.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    writeln!(f, \"LiteralTrie(\") should be Ok/Some",
          "    (self.states.iter().with_state_ids()) should produce (sid, state)",
          "    writeln!(f, \"{:06?}: {:?}\", sid.as_usize(), state) should be Err/None"
        ],
        "code": [
          "{",
          "    let state_id_1 = StateID(1.into());",
          "    let state_1 = State {",
          "        id: state_id_1,",
          "        is_match: false,",
          "        ntrans: 1,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "    ",
          "    let state_id_2 = StateID(2.into());",
          "    let state_2 = State {",
          "        id: state_id_2,",
          "        is_match: true,",
          "        ntrans: 1,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "",
          "    let trie = LiteralTrie {",
          "        states: vec![state_1, state_2],",
          "        rev: false,",
          "    };",
          "    ",
          "    let mut buffer = vec![];",
          "    let mut formatter = core::fmt::Formatter::new(&mut buffer);",
          "    ",
          "    let _ = trie.fmt(&mut formatter);",
          "    writeln!(f, \"LiteralTrie(\") should be Ok/Some",
          "    (self.states.iter().with_state_ids()) should produce (sid, state)",
          "    writeln!(f, \"{:06?}: {:?}\", sid.as_usize(), state) should be Err/None",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let state_id = StateID(-1.into()); // Invalid StateID to trigger error",
          "    let state = State {",
          "        id: state_id,",
          "        is_match: false,",
          "        ntrans: 0,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "",
          "    let trie = LiteralTrie {",
          "        states: vec![state],",
          "        rev: false,",
          "    };",
          "",
          "    let mut buffer = vec![];",
          "    let mut formatter = core::fmt::Formatter::new(&mut buffer);",
          "",
          "    let _ = trie.fmt(&mut formatter);",
          "}"
        ],
        "oracle": [
          "    assert!(writeln!(f, \"LiteralTrie(\").is_ok());",
          "    assert!((sid, state).is_some());",
          "    assert!(matches!(writeln!(f, \"{:06?}: {:?}\", sid.as_usize(), state), Err(_)));"
        ],
        "code": [
          "{",
          "    let state_id = StateID(-1.into()); // Invalid StateID to trigger error",
          "    let state = State {",
          "        id: state_id,",
          "        is_match: false,",
          "        ntrans: 0,",
          "        input_ranges: &[],",
          "        next: &[],",
          "        pattern_ids: &[],",
          "        accel: &[],",
          "    };",
          "",
          "    let trie = LiteralTrie {",
          "        states: vec![state],",
          "        rev: false,",
          "    };",
          "",
          "    let mut buffer = vec![];",
          "    let mut formatter = core::fmt::Formatter::new(&mut buffer);",
          "",
          "    let _ = trie.fmt(&mut formatter);",
          "    assert!(writeln!(f, \"LiteralTrie(\").is_ok());",
          "    assert!((sid, state).is_some());",
          "    assert!(matches!(writeln!(f, \"{:06?}: {:?}\", sid.as_usize(), state), Err(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]