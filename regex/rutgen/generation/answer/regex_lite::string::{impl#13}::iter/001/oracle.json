[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"(\\w)\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A\";",
          "",
          "    let slots = vec![None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_it.caps.haystack, \"A\");",
          "    assert_eq!(_it.caps.slots, CaptureLocations(vec![None]));",
          "    assert_eq!(_it.caps.pikevm.nfa().pattern(), r\"(\\w)\");",
          "    assert_eq!(_it.caps.pikevm.nfa().capture_names().len(), 1);",
          "    assert_eq!(_it.caps.len(), 1);",
          "    assert!(matches!(_it.next(), Some(_)));",
          "    assert_eq!(_it.next().unwrap().map(|m| m.as_str()), Some(\"A\"));",
          "    assert_eq!(_it.next(), None);"
        ],
        "code": [
          "{",
          "    let pattern = r\"(\\w)\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A\";",
          "",
          "    let slots = vec![None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "    assert_eq!(_it.caps.haystack, \"A\");",
          "    assert_eq!(_it.caps.slots, CaptureLocations(vec![None]));",
          "    assert_eq!(_it.caps.pikevm.nfa().pattern(), r\"(\\w)\");",
          "    assert_eq!(_it.caps.pikevm.nfa().capture_names().len(), 1);",
          "    assert_eq!(_it.caps.len(), 1);",
          "    assert!(matches!(_it.next(), Some(_)));",
          "    assert_eq!(_it.next().unwrap().map(|m| m.as_str()), Some(\"A\"));",
          "    assert_eq!(_it.next(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"(\\w)(\\d)?(\\w)\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A1B\";",
          "",
          "    let slots = vec![None, None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_it.caps.haystack, \"A1B\");",
          "    assert_eq!(_it.caps.slots, CaptureLocations(vec![None, None, None]));",
          "    assert_eq!(_it.caps.pikevm.nfa().pattern(), r\"(\\w)(\\d)?(\\w)\");",
          "    assert!(matches!(_it.caps.pikevm.nfa().capture_names(), CaptureNames { .. }));",
          "    assert!(matches!(_it.caps.pikevm.nfa().capture_names().len(), 3));",
          "    assert_eq!(_it.caps.pikevm.nfa().static_explicit_captures_len(), None);",
          "    assert_eq!(_it.caps.pikevm.nfa().is_start_anchored(), false);",
          "    assert_eq!(_it.caps.pikevm.nfa().group_len(), 3);",
          "    assert_eq!(_it.caps.len(), 3);"
        ],
        "code": [
          "{",
          "    let pattern = r\"(\\w)(\\d)?(\\w)\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A1B\";",
          "",
          "    let slots = vec![None, None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "    assert_eq!(_it.caps.haystack, \"A1B\");",
          "    assert_eq!(_it.caps.slots, CaptureLocations(vec![None, None, None]));",
          "    assert_eq!(_it.caps.pikevm.nfa().pattern(), r\"(\\w)(\\d)?(\\w)\");",
          "    assert!(matches!(_it.caps.pikevm.nfa().capture_names(), CaptureNames { .. }));",
          "    assert!(matches!(_it.caps.pikevm.nfa().capture_names().len(), 3));",
          "    assert_eq!(_it.caps.pikevm.nfa().static_explicit_captures_len(), None);",
          "    assert_eq!(_it.caps.pikevm.nfa().is_start_anchored(), false);",
          "    assert_eq!(_it.caps.pikevm.nfa().group_len(), 3);",
          "    assert_eq!(_it.caps.len(), 3);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"(\\w)(\\d)?(\\w)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A B\";",
          "",
          "    let slots = vec![None, None, None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "}"
        ],
        "oracle": [
          "    let pattern = r\"(\\w)(\\d)?(\\w)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A B\";",
          "    ",
          "    let slots = vec![None, None, None, None];",
          "    let captures = Captures {",
          "    haystack,",
          "    slots: CaptureLocations(slots.clone()),",
          "    pikevm: Arc::new(pikevm),",
          "    };",
          "    ",
          "    let it = captures.iter();",
          "    assert_eq!(it.caps.haystack, \"A B\");",
          "    assert_eq!(it.caps.slots.0.len(), 4);",
          "    assert!(it.caps.pikevm.nfa().capture_names().it.len() > 0);"
        ],
        "code": [
          "{",
          "    let pattern = r\"(\\w)(\\d)?(\\w)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A B\";",
          "",
          "    let slots = vec![None, None, None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "    let pattern = r\"(\\w)(\\d)?(\\w)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"A B\";",
          "    ",
          "    let slots = vec![None, None, None, None];",
          "    let captures = Captures {",
          "    haystack,",
          "    slots: CaptureLocations(slots.clone()),",
          "    pikevm: Arc::new(pikevm),",
          "    };",
          "    ",
          "    let it = captures.iter();",
          "    assert_eq!(it.caps.haystack, \"A B\");",
          "    assert_eq!(it.caps.slots.0.len(), 4);",
          "    assert!(it.caps.pikevm.nfa().capture_names().it.len() > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"(\\d)(\\w)\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"AB\";",
          "",
          "    let slots = vec![None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_it.caps.haystack, \"AB\");",
          "    assert_eq!(_it.caps.slots, CaptureLocations(vec![None, None]));",
          "    assert_eq!(_it.caps.pikevm.nfa.pattern(), r\"(\\d)(\\w)\");",
          "    assert!(matches!(_it.caps.pikevm.nfa.capture_names().it, core::slice::Iter::<Option<Arc<str>>>::len()));",
          "    assert_eq!(_it.caps.pikevm.nfa().capture_names().it.clone().count(), 2);",
          "    assert!(matches!(_it.caps.pikevm.nfa().is_start_anchored()));",
          "    assert_eq!(_it.caps.pikevm.nfa.static_explicit_captures_len(), None);",
          "    assert_eq!(_it.caps.len(), 0);"
        ],
        "code": [
          "{",
          "    let pattern = r\"(\\d)(\\w)\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"AB\";",
          "",
          "    let slots = vec![None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "    assert_eq!(_it.caps.haystack, \"AB\");",
          "    assert_eq!(_it.caps.slots, CaptureLocations(vec![None, None]));",
          "    assert_eq!(_it.caps.pikevm.nfa.pattern(), r\"(\\d)(\\w)\");",
          "    assert!(matches!(_it.caps.pikevm.nfa.capture_names().it, core::slice::Iter::<Option<Arc<str>>>::len()));",
          "    assert_eq!(_it.caps.pikevm.nfa().capture_names().it.clone().count(), 2);",
          "    assert!(matches!(_it.caps.pikevm.nfa().is_start_anchored()));",
          "    assert_eq!(_it.caps.pikevm.nfa.static_explicit_captures_len(), None);",
          "    assert_eq!(_it.caps.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = r\"(\\w+)(\\d+)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"Hello123\";",
          "",
          "    let slots = vec![None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "}"
        ],
        "oracle": [
          "    let pattern = r\"(\\w+)(\\d+)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"Hello123\";",
          "    ",
          "    let slots = vec![None, None];",
          "    let captures = Captures {",
          "    haystack,",
          "    slots: CaptureLocations(slots.clone()),",
          "    pikevm: Arc::new(pikevm),",
          "    };",
          "    ",
          "    let it = captures.iter();",
          "    assert!(it.caps.haystack == haystack);",
          "    assert_eq!(it.it.len(), 2);",
          "    ",
          "    let mut results: Vec<Option<&str>> = it.it.map(|(index, cap)| cap.map(|m| m.as_str())).collect();",
          "    assert_eq!(results[0], Some(\"H\"));",
          "    assert_eq!(results[1], Some(\"ello123\"));",
          "    ",
          "    let next = it.next();",
          "    assert!(next.is_some());",
          "    assert_eq!(next.unwrap().map(|m| m.as_str()), Some(\"H\"));",
          "    ",
          "    let nth_capture = it.next();",
          "    assert_eq!(nth_capture.unwrap().map(|m| m.as_str()), Some(\"ello123\"));",
          "    assert!(it.next().is_none());"
        ],
        "code": [
          "{",
          "    let pattern = r\"(\\w+)(\\d+)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"Hello123\";",
          "",
          "    let slots = vec![None, None];",
          "    let captures = Captures {",
          "        haystack,",
          "        slots: CaptureLocations(slots.clone()),",
          "        pikevm: Arc::new(pikevm),",
          "    };",
          "",
          "    let _it = captures.iter();",
          "    let pattern = r\"(\\w+)(\\d+)?\";",
          "    let nfa = NFA::new(Config::default(), pattern.to_string(), &Hir::new()).unwrap();",
          "    let pikevm = PikeVM::new(nfa.clone());",
          "    let haystack = \"Hello123\";",
          "    ",
          "    let slots = vec![None, None];",
          "    let captures = Captures {",
          "    haystack,",
          "    slots: CaptureLocations(slots.clone()),",
          "    pikevm: Arc::new(pikevm),",
          "    };",
          "    ",
          "    let it = captures.iter();",
          "    assert!(it.caps.haystack == haystack);",
          "    assert_eq!(it.it.len(), 2);",
          "    ",
          "    let mut results: Vec<Option<&str>> = it.it.map(|(index, cap)| cap.map(|m| m.as_str())).collect();",
          "    assert_eq!(results[0], Some(\"H\"));",
          "    assert_eq!(results[1], Some(\"ello123\"));",
          "    ",
          "    let next = it.next();",
          "    assert!(next.is_some());",
          "    assert_eq!(next.unwrap().map(|m| m.as_str()), Some(\"H\"));",
          "    ",
          "    let nth_capture = it.next();",
          "    assert_eq!(nth_capture.unwrap().map(|m| m.as_str()), Some(\"ello123\"));",
          "    assert!(it.next().is_none());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]