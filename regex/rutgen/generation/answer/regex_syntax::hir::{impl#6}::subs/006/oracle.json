[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let empty_hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties::default(),",
          "    };",
          "    let _ = empty_hir.subs();",
          "}"
        ],
        "oracle": [
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() }; assert_eq!(empty_hir.subs(), &[]);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }; assert_eq!(literal_hir.subs(), &[]);",
          "    let class_hir = Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']))), props: Properties::default() }; assert_eq!(class_hir.subs(), &[]);",
          "    let look_hir = Hir { kind: HirKind::Look(Look::Start), props: Properties::default() }; assert_eq!(look_hir.subs(), &[]);",
          "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'x'], exact: true }), props: Properties::default() }) }), props: Properties::default() }; assert_eq!(repetition_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'x'], exact: true }), props: Properties::default() }]);",
          "    let capture_hir = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'y'], exact: true }), props: Properties::default() }) }), props: Properties::default() }; assert_eq!(capture_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'y'], exact: true }), props: Properties::default() }]);",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]), props: Properties::default() }; assert_eq!(concat_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]);",
          "    let alternation_hir = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }]), props: Properties::default() }; assert_eq!(alternation_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }]);"
        ],
        "code": [
          "{",
          "    let empty_hir = Hir {",
          "        kind: HirKind::Empty,",
          "        props: Properties::default(),",
          "    };",
          "    let _ = empty_hir.subs();",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() }; assert_eq!(empty_hir.subs(), &[]);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }; assert_eq!(literal_hir.subs(), &[]);",
          "    let class_hir = Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']))), props: Properties::default() }; assert_eq!(class_hir.subs(), &[]);",
          "    let look_hir = Hir { kind: HirKind::Look(Look::Start), props: Properties::default() }; assert_eq!(look_hir.subs(), &[]);",
          "    let repetition_hir = Hir { kind: HirKind::Repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'x'], exact: true }), props: Properties::default() }) }), props: Properties::default() }; assert_eq!(repetition_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'x'], exact: true }), props: Properties::default() }]);",
          "    let capture_hir = Hir { kind: HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'y'], exact: true }), props: Properties::default() }) }), props: Properties::default() }; assert_eq!(capture_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'y'], exact: true }), props: Properties::default() }]);",
          "    let concat_hir = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]), props: Properties::default() }; assert_eq!(concat_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]);",
          "    let alternation_hir = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }]), props: Properties::default() }; assert_eq!(alternation_hir.subs(), &[Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal_hir = Hir {",
          "        kind: HirKind::Literal(Literal(vec![b'a', b'b', b'c'].into_boxed_slice())),",
          "        props: Properties::default(),",
          "    };",
          "    let _ = literal_hir.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(literal_hir.subs(), &[]);",
          "    ",
          "    let empty_hir = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default(),",
          "    };",
          "    assert_eq!(empty_hir.subs(), &[]);",
          "    ",
          "    let look_hir = Hir {",
          "    kind: HirKind::Look(Look::Start),",
          "    props: Properties::default(),",
          "    };",
          "    assert_eq!(look_hir.subs(), &[]);",
          "    ",
          "    let class_hir = Hir {",
          "    kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']))),",
          "    props: Properties::default(),",
          "    };",
          "    assert_eq!(class_hir.subs(), &[]);"
        ],
        "code": [
          "{",
          "    let literal_hir = Hir {",
          "        kind: HirKind::Literal(Literal(vec![b'a', b'b', b'c'].into_boxed_slice())),",
          "        props: Properties::default(),",
          "    };",
          "    let _ = literal_hir.subs();",
          "    assert_eq!(literal_hir.subs(), &[]);",
          "    ",
          "    let empty_hir = Hir {",
          "    kind: HirKind::Empty,",
          "    props: Properties::default(),",
          "    };",
          "    assert_eq!(empty_hir.subs(), &[]);",
          "    ",
          "    let look_hir = Hir {",
          "    kind: HirKind::Look(Look::Start),",
          "    props: Properties::default(),",
          "    };",
          "    assert_eq!(look_hir.subs(), &[]);",
          "    ",
          "    let class_hir = Hir {",
          "    kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']))),",
          "    props: Properties::default(),",
          "    };",
          "    assert_eq!(class_hir.subs(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_hir = Hir {",
          "        kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']))),",
          "        props: Properties::default(),",
          "    };",
          "    let _ = class_hir.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class_hir.subs(), &[]);",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() };",
          "    assert_eq!(empty_hir.subs(), &[]);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal(Box::new(b\"example\".to_vec())), props: Properties::default() };",
          "    assert_eq!(literal_hir.subs(), &[]);",
          "    let look_hir = Hir { kind: HirKind::Look(Look::Start), props: Properties::default() };",
          "    assert_eq!(look_hir.subs(), &[]);"
        ],
        "code": [
          "{",
          "    let class_hir = Hir {",
          "        kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']))),",
          "        props: Properties::default(),",
          "    };",
          "    let _ = class_hir.subs();",
          "    assert_eq!(class_hir.subs(), &[]);",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() };",
          "    assert_eq!(empty_hir.subs(), &[]);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal(Box::new(b\"example\".to_vec())), props: Properties::default() };",
          "    assert_eq!(literal_hir.subs(), &[]);",
          "    let look_hir = Hir { kind: HirKind::Look(Look::Start), props: Properties::default() };",
          "    assert_eq!(look_hir.subs(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look_hir = Hir {",
          "        kind: HirKind::Look(Look::Start),",
          "        props: Properties::default(),",
          "    };",
          "    let _ = look_hir.subs();",
          "}"
        ],
        "oracle": [
          "    let look_hir = Hir { kind: HirKind::Look(Look::Start), props: Properties::default() }; assert_eq!(look_hir.subs(), &[]);",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() }; assert_eq!(empty_hir.subs(), &[]);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }; assert_eq!(literal_hir.subs(), &[]);",
          "    let class_hir = Hir { kind: HirKind::Class(Class::Bytes(ClassBytes { bytes: vec![b'a'] })), props: Properties::default() }; assert_eq!(class_hir.subs(), &[]);"
        ],
        "code": [
          "{",
          "    let look_hir = Hir {",
          "        kind: HirKind::Look(Look::Start),",
          "        props: Properties::default(),",
          "    };",
          "    let _ = look_hir.subs();",
          "    let look_hir = Hir { kind: HirKind::Look(Look::Start), props: Properties::default() }; assert_eq!(look_hir.subs(), &[]);",
          "    let empty_hir = Hir { kind: HirKind::Empty, props: Properties::default() }; assert_eq!(empty_hir.subs(), &[]);",
          "    let literal_hir = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }; assert_eq!(literal_hir.subs(), &[]);",
          "    let class_hir = Hir { kind: HirKind::Class(Class::Bytes(ClassBytes { bytes: vec![b'a'] })), props: Properties::default() }; assert_eq!(class_hir.subs(), &[]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]