[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_expression = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: vec![b'a'],",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(sub_expression),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let _result = hir.subs();",
          "}"
        ],
        "oracle": [
          "    let sub_expression = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() };",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(sub_expression) };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    let result = hir.subs();",
          "    assert_eq!(result, &[*sub_expression]);"
        ],
        "code": [
          "{",
          "    let sub_expression = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: vec![b'a'],",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "        min: 1,",
          "        max: Some(3),",
          "        greedy: true,",
          "        sub: Box::new(sub_expression),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let _result = hir.subs();",
          "    let sub_expression = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() };",
          "    let repetition = Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(sub_expression) };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    let result = hir.subs();",
          "    assert_eq!(result, &[*sub_expression]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_expression = Hir {",
          "        kind: HirKind::Capture(Capture {",
          "            index: 1,",
          "            name: Some(Box::from(\"group\")),",
          "            sub: Box::new(Hir {",
          "                kind: HirKind::Literal(Literal {",
          "                    bytes: vec![b'b'],",
          "                    exact: true,",
          "                }),",
          "                props: Properties::default(),",
          "            }),",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "        min: 0,",
          "        max: Some(5),",
          "        greedy: false,",
          "        sub: Box::new(sub_expression),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let _result = hir.subs();",
          "}"
        ],
        "oracle": [
          "    let sub_expression = Hir {",
          "    kind: HirKind::Capture(Capture {",
          "    index: 1,",
          "    name: Some(Box::from(\"group\")),",
          "    sub: Box::new(Hir {",
          "    kind: HirKind::Literal(Literal {",
          "    bytes: vec![b'b'],",
          "    exact: true,",
          "    }),",
          "    props: Properties::default(),",
          "    }),",
          "    }),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "    min: 0,",
          "    max: Some(5),",
          "    greedy: false,",
          "    sub: Box::new(sub_expression),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "    kind: HirKind::Repetition(repetition),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    assert_eq!(hir.subs(), &[sub_expression]);"
        ],
        "code": [
          "{",
          "    let sub_expression = Hir {",
          "        kind: HirKind::Capture(Capture {",
          "            index: 1,",
          "            name: Some(Box::from(\"group\")),",
          "            sub: Box::new(Hir {",
          "                kind: HirKind::Literal(Literal {",
          "                    bytes: vec![b'b'],",
          "                    exact: true,",
          "                }),",
          "                props: Properties::default(),",
          "            }),",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "        min: 0,",
          "        max: Some(5),",
          "        greedy: false,",
          "        sub: Box::new(sub_expression),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let _result = hir.subs();",
          "    let sub_expression = Hir {",
          "    kind: HirKind::Capture(Capture {",
          "    index: 1,",
          "    name: Some(Box::from(\"group\")),",
          "    sub: Box::new(Hir {",
          "    kind: HirKind::Literal(Literal {",
          "    bytes: vec![b'b'],",
          "    exact: true,",
          "    }),",
          "    props: Properties::default(),",
          "    }),",
          "    }),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "    min: 0,",
          "    max: Some(5),",
          "    greedy: false,",
          "    sub: Box::new(sub_expression),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "    kind: HirKind::Repetition(repetition),",
          "    props: Properties::default(),",
          "    };",
          "    ",
          "    assert_eq!(hir.subs(), &[sub_expression]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let sub_expression1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: vec![b'c'],",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let sub_expression2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: vec![b'd'],",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "        min: 2,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir {",
          "            kind: HirKind::Concat(vec![sub_expression1, sub_expression2]),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let _result = hir.subs();",
          "}"
        ],
        "oracle": [
          "    let sub_expression1 = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() };",
          "    let sub_expression2 = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() };",
          "    let repetition = Repetition { min: 2, max: None, greedy: true, sub: Box::new(Hir { kind: HirKind::Concat(vec![sub_expression1, sub_expression2]), props: Properties::default() }) };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    let result = hir.subs();",
          "    assert_eq!(result.len(), 1);",
          "    assert_eq!(result[0].kind, HirKind::Concat(vec![sub_expression1, sub_expression2]));"
        ],
        "code": [
          "{",
          "    let sub_expression1 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: vec![b'c'],",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let sub_expression2 = Hir {",
          "        kind: HirKind::Literal(Literal {",
          "            bytes: vec![b'd'],",
          "            exact: true,",
          "        }),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let repetition = Repetition {",
          "        min: 2,",
          "        max: None,",
          "        greedy: true,",
          "        sub: Box::new(Hir {",
          "            kind: HirKind::Concat(vec![sub_expression1, sub_expression2]),",
          "            props: Properties::default(),",
          "        }),",
          "    };",
          "    ",
          "    let hir = Hir {",
          "        kind: HirKind::Repetition(repetition),",
          "        props: Properties::default(),",
          "    };",
          "    ",
          "    let _result = hir.subs();",
          "    let sub_expression1 = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() };",
          "    let sub_expression2 = Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() };",
          "    let repetition = Repetition { min: 2, max: None, greedy: true, sub: Box::new(Hir { kind: HirKind::Concat(vec![sub_expression1, sub_expression2]), props: Properties::default() }) };",
          "    let hir = Hir { kind: HirKind::Repetition(repetition), props: Properties::default() };",
          "    let result = hir.subs();",
          "    assert_eq!(result.len(), 1);",
          "    assert_eq!(result[0].kind, HirKind::Concat(vec![sub_expression1, sub_expression2]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]