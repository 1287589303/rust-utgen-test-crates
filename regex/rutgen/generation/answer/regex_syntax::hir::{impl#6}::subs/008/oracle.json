[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let _ = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Literal(Literal { bytes: vec![b'a'], exact: true });",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode { /* fields */ }));",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 0, max: Some(2), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }) });",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }].as_slice());",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: false }), props: Properties::default() }) });",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: false }), props: Properties::default() }].as_slice());",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }]);",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }].as_slice());",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'e'], exact: false }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'f'], exact: false }), props: Properties::default() }]);",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'e'], exact: false }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'f'], exact: false }), props: Properties::default() }].as_slice());"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let _ = hir_kind.subs();",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Literal(Literal { bytes: vec![b'a'], exact: true });",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode { /* fields */ }));",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Look(Look::Start);",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 0, max: Some(2), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }) });",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }].as_slice());",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: false }), props: Properties::default() }) });",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: false }), props: Properties::default() }].as_slice());",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }]);",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'c'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'd'], exact: true }), props: Properties::default() }].as_slice());",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'e'], exact: false }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'f'], exact: false }), props: Properties::default() }]);",
          "    assert_eq!(hir_kind.subs(), [Hir { kind: HirKind::Literal(Literal { bytes: vec![b'e'], exact: false }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'f'], exact: false }), props: Properties::default() }].as_slice());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Literal(vec![b'a', b'b', b'c'].into_boxed_slice());",
          "    let hir_kind = HirKind::Literal(literal);",
          "    let _ = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind_empty = HirKind::Empty; assert_eq!(hir_kind_empty.subs(), &[]);",
          "    let hir_kind_literal = HirKind::Literal(Literal(vec![b'a', b'b', b'c'].into_boxed_slice())); assert_eq!(hir_kind_literal.subs(), &[]);",
          "    let hir_kind_class = HirKind::Class(Class::Bytes(ClassBytes::new(vec![b'a', b'b', b'c']))); assert_eq!(hir_kind_class.subs(), &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start); assert_eq!(hir_kind_look.subs(), &[]);",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(2), greedy: true, sub: Box::new(hir_kind_literal.clone()) }); assert_eq!(hir_kind_repetition.subs(), &[hir_kind_literal.clone()]);",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 1, name: None, sub: Box::new(hir_kind_literal.clone()) }); assert_eq!(hir_kind_capture.subs(), &[hir_kind_literal.clone()]);",
          "    let hir_kind_concat = HirKind::Concat(vec![hir_kind_literal.clone(), hir_kind_class.clone()]); assert_eq!(hir_kind_concat.subs(), &[hir_kind_literal.clone(), hir_kind_class.clone()]);",
          "    let hir_kind_alternation = HirKind::Alternation(vec![hir_kind_literal.clone(), hir_kind_look.clone()]); assert_eq!(hir_kind_alternation.subs(), &[hir_kind_literal.clone(), hir_kind_look.clone()]);"
        ],
        "code": [
          "{",
          "    let literal = Literal(vec![b'a', b'b', b'c'].into_boxed_slice());",
          "    let hir_kind = HirKind::Literal(literal);",
          "    let _ = hir_kind.subs();",
          "    let hir_kind_empty = HirKind::Empty; assert_eq!(hir_kind_empty.subs(), &[]);",
          "    let hir_kind_literal = HirKind::Literal(Literal(vec![b'a', b'b', b'c'].into_boxed_slice())); assert_eq!(hir_kind_literal.subs(), &[]);",
          "    let hir_kind_class = HirKind::Class(Class::Bytes(ClassBytes::new(vec![b'a', b'b', b'c']))); assert_eq!(hir_kind_class.subs(), &[]);",
          "    let hir_kind_look = HirKind::Look(Look::Start); assert_eq!(hir_kind_look.subs(), &[]);",
          "    let hir_kind_repetition = HirKind::Repetition(Repetition { min: 1, max: Some(2), greedy: true, sub: Box::new(hir_kind_literal.clone()) }); assert_eq!(hir_kind_repetition.subs(), &[hir_kind_literal.clone()]);",
          "    let hir_kind_capture = HirKind::Capture(Capture { index: 1, name: None, sub: Box::new(hir_kind_literal.clone()) }); assert_eq!(hir_kind_capture.subs(), &[hir_kind_literal.clone()]);",
          "    let hir_kind_concat = HirKind::Concat(vec![hir_kind_literal.clone(), hir_kind_class.clone()]); assert_eq!(hir_kind_concat.subs(), &[hir_kind_literal.clone(), hir_kind_class.clone()]);",
          "    let hir_kind_alternation = HirKind::Alternation(vec![hir_kind_literal.clone(), hir_kind_look.clone()]); assert_eq!(hir_kind_alternation.subs(), &[hir_kind_literal.clone(), hir_kind_look.clone()]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c'].into_iter().collect()));",
          "    let hir_kind = HirKind::Class(class);",
          "    let _ = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let empt_hir_kind = HirKind::Empty;",
          "    assert_eq!(empt_hir_kind.subs(), &[]);",
          "    let literal_hir_kind = HirKind::Literal(Literal(Box::new([b'a', b'b', b'c'])));",
          "    assert_eq!(literal_hir_kind.subs(), &[]);",
          "    let look_hir_kind = HirKind::Look(Look::Start);",
          "    assert_eq!(look_hir_kind.subs(), &[]);",
          "    let class_hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c'].into_iter().collect())));",
          "    assert_eq!(class_hir_kind.subs(), &[]);",
          "    let repetition_hir_kind = HirKind::Repetition(Repetition { min: 1, max: None, greedy: true, sub: Box::new(hir_kind) });",
          "    assert_eq!(repetition_hir_kind.subs(), &[hir_kind]);",
          "    let capture_hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(hir_kind) });",
          "    assert_eq!(capture_hir_kind.subs(), &[hir_kind]);",
          "    let concat_hir_kind = HirKind::Concat(vec![hir_kind.clone(), hir_kind.clone()]);",
          "    assert_eq!(concat_hir_kind.subs(), &[hir_kind, hir_kind]);",
          "    let alternation_hir_kind = HirKind::Alternation(vec![hir_kind.clone(), hir_kind.clone()]);",
          "    assert_eq!(alternation_hir_kind.subs(), &[hir_kind, hir_kind]);"
        ],
        "code": [
          "{",
          "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c'].into_iter().collect()));",
          "    let hir_kind = HirKind::Class(class);",
          "    let _ = hir_kind.subs();",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let empt_hir_kind = HirKind::Empty;",
          "    assert_eq!(empt_hir_kind.subs(), &[]);",
          "    let literal_hir_kind = HirKind::Literal(Literal(Box::new([b'a', b'b', b'c'])));",
          "    assert_eq!(literal_hir_kind.subs(), &[]);",
          "    let look_hir_kind = HirKind::Look(Look::Start);",
          "    assert_eq!(look_hir_kind.subs(), &[]);",
          "    let class_hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c'].into_iter().collect())));",
          "    assert_eq!(class_hir_kind.subs(), &[]);",
          "    let repetition_hir_kind = HirKind::Repetition(Repetition { min: 1, max: None, greedy: true, sub: Box::new(hir_kind) });",
          "    assert_eq!(repetition_hir_kind.subs(), &[hir_kind]);",
          "    let capture_hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(hir_kind) });",
          "    assert_eq!(capture_hir_kind.subs(), &[hir_kind]);",
          "    let concat_hir_kind = HirKind::Concat(vec![hir_kind.clone(), hir_kind.clone()]);",
          "    assert_eq!(concat_hir_kind.subs(), &[hir_kind, hir_kind]);",
          "    let alternation_hir_kind = HirKind::Alternation(vec![hir_kind.clone(), hir_kind.clone()]);",
          "    assert_eq!(alternation_hir_kind.subs(), &[hir_kind, hir_kind]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    let _ = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let empty_hir = HirKind::Empty;",
          "    assert_eq!(empty_hir.subs(), &[]);",
          "    let class_hir = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
          "    assert_eq!(class_hir.subs(), &[]);",
          "    let literal_hir = HirKind::Literal(Literal::from(\"test\".as_bytes()));",
          "    assert_eq!(literal_hir.subs(), &[]);",
          "    let repetition_hir = HirKind::Repetition(Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(HirKind::Empty) });",
          "    let repetition_subs = repetition_hir.subs();",
          "    assert_eq!(repetition_subs.len(), 1);",
          "    let capture_hir = HirKind::Capture(Capture { index: 1, name: None, sub: Box::new(HirKind::Empty) });",
          "    let capture_subs = capture_hir.subs();",
          "    assert_eq!(capture_subs.len(), 1);",
          "    let concat_hir = HirKind::Concat(vec![HirKind::Empty, HirKind::Literal(Literal::from(\"abc\".as_bytes()))]);",
          "    let concat_subs = concat_hir.subs();",
          "    assert_eq!(concat_subs.len(), 2);",
          "    let alternation_hir = HirKind::Alternation(vec![HirKind::Literal(Literal::from(\"xyz\".as_bytes())), HirKind::Look(Look::End)]);",
          "    let alternation_subs = alternation_hir.subs();",
          "    assert_eq!(alternation_subs.len(), 2);"
        ],
        "code": [
          "{",
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    let _ = hir_kind.subs();",
          "    assert_eq!(hir_kind.subs(), &[]);",
          "    let empty_hir = HirKind::Empty;",
          "    assert_eq!(empty_hir.subs(), &[]);",
          "    let class_hir = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
          "    assert_eq!(class_hir.subs(), &[]);",
          "    let literal_hir = HirKind::Literal(Literal::from(\"test\".as_bytes()));",
          "    assert_eq!(literal_hir.subs(), &[]);",
          "    let repetition_hir = HirKind::Repetition(Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(HirKind::Empty) });",
          "    let repetition_subs = repetition_hir.subs();",
          "    assert_eq!(repetition_subs.len(), 1);",
          "    let capture_hir = HirKind::Capture(Capture { index: 1, name: None, sub: Box::new(HirKind::Empty) });",
          "    let capture_subs = capture_hir.subs();",
          "    assert_eq!(capture_subs.len(), 1);",
          "    let concat_hir = HirKind::Concat(vec![HirKind::Empty, HirKind::Literal(Literal::from(\"abc\".as_bytes()))]);",
          "    let concat_subs = concat_hir.subs();",
          "    assert_eq!(concat_subs.len(), 2);",
          "    let alternation_hir = HirKind::Alternation(vec![HirKind::Literal(Literal::from(\"xyz\".as_bytes())), HirKind::Look(Look::End)]);",
          "    let alternation_subs = alternation_hir.subs();",
          "    assert_eq!(alternation_subs.len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]