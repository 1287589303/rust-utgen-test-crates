[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let subs: &[Hir] = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let hir_kind = HirKind::Empty; assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode { /* fields */ })); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Look(Look::Start); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }) }); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 1);",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }) }); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 1);",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 2);",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 2);"
        ],
        "code": [
          "{",
          "    let hir_kind = HirKind::Empty;",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    let hir_kind = HirKind::Empty; assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode { /* fields */ })); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Look(Look::Start); assert_eq!(hir_kind.subs(), &[]);",
          "    let hir_kind = HirKind::Repetition(Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }) }); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 1);",
          "    let hir_kind = HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }) }); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 1);",
          "    let hir_kind = HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 2);",
          "    let hir_kind = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { bytes: vec![b'a'], exact: true }), props: Properties::default() }, Hir { kind: HirKind::Literal(Literal { bytes: vec![b'b'], exact: true }), props: Properties::default() }]); let subs: &[Hir] = hir_kind.subs(); assert_eq!(subs.len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let literal = Literal(Box::new([b'a', b'b', b'c']));",
          "    let hir_kind = HirKind::Literal(literal);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(subs.len(), 0);",
          "    assert!(matches!(hir_kind, HirKind::Literal(_)));",
          "    let empty_hir_kind = HirKind::Empty;",
          "    let empty_subs: &[Hir] = empty_hir_kind.subs();",
          "    assert_eq!(empty_subs.len(), 0);",
          "    let look_hir_kind = HirKind::Look(Look::Start);",
          "    let look_subs: &[Hir] = look_hir_kind.subs();",
          "    assert_eq!(look_subs.len(), 0);",
          "    let class_hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
          "    let class_subs: &[Hir] = class_hir_kind.subs();",
          "    assert_eq!(class_subs.len(), 0);"
        ],
        "code": [
          "{",
          "    let literal = Literal(Box::new([b'a', b'b', b'c']));",
          "    let hir_kind = HirKind::Literal(literal);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    assert!(matches!(hir_kind, HirKind::Literal(_)));",
          "    let empty_hir_kind = HirKind::Empty;",
          "    let empty_subs: &[Hir] = empty_hir_kind.subs();",
          "    assert_eq!(empty_subs.len(), 0);",
          "    let look_hir_kind = HirKind::Look(Look::Start);",
          "    let look_subs: &[Hir] = look_hir_kind.subs();",
          "    assert_eq!(look_subs.len(), 0);",
          "    let class_hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
          "    let class_subs: &[Hir] = class_hir_kind.subs();",
          "    assert_eq!(class_subs.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));",
          "    let hir_kind = HirKind::Class(class);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(subs.len(), 0); // Ensures there are no sub-expressions for HirKind::Class",
          "    let empty_hir_kind = HirKind::Empty;",
          "    assert_eq!(empty_hir_kind.subs(), &[]); // Tests that subs for HirKind::Empty returns an empty slice",
          "    let look_hir_kind = HirKind::Look(Look::Start);",
          "    assert_eq!(look_hir_kind.subs(), &[]); // Tests that subs for HirKind::Look returns an empty slice",
          "    let literal_hir_kind = HirKind::Literal(Literal(Box::new([b'a', b'b', b'c'])));",
          "    assert_eq!(literal_hir_kind.subs(), &[]); // Tests that subs for HirKind::Literal returns an empty slice",
          "    let class_hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c'])));",
          "    assert_eq!(class_hir_kind.subs(), &[]); // Tests that subs for HirKind::Class returns an empty slice"
        ],
        "code": [
          "{",
          "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));",
          "    let hir_kind = HirKind::Class(class);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 0); // Ensures there are no sub-expressions for HirKind::Class",
          "    let empty_hir_kind = HirKind::Empty;",
          "    assert_eq!(empty_hir_kind.subs(), &[]); // Tests that subs for HirKind::Empty returns an empty slice",
          "    let look_hir_kind = HirKind::Look(Look::Start);",
          "    assert_eq!(look_hir_kind.subs(), &[]); // Tests that subs for HirKind::Look returns an empty slice",
          "    let literal_hir_kind = HirKind::Literal(Literal(Box::new([b'a', b'b', b'c'])));",
          "    assert_eq!(literal_hir_kind.subs(), &[]); // Tests that subs for HirKind::Literal returns an empty slice",
          "    let class_hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c'])));",
          "    assert_eq!(class_hir_kind.subs(), &[]); // Tests that subs for HirKind::Class returns an empty slice",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "}"
        ],
        "oracle": [
          "    let literal = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'a' });",
          "    let subs: &[Hir] = literal.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let empty = HirKind::Empty;",
          "    let subs: &[Hir] = empty.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let look = Look::End;",
          "    let hir_kind = HirKind::Look(look);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let class = Class::Unicode(ClassUnicode::default());",
          "    let hir_kind = HirKind::Class(class);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'b' })) };",
          "    let hir_kind = HirKind::Repetition(repetition);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 1);",
          "    ",
          "    let capture = Capture { index: 0, name: None, sub: Box::new(HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'c' })) };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 1);",
          "    ",
          "    let concat = HirKind::Concat(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'd' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'e' })]);",
          "    let subs: &[Hir] = concat.subs();",
          "    assert_eq!(subs.len(), 2);",
          "    ",
          "    let alternation = HirKind::Alternation(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'f' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'g' })]);",
          "    let subs: &[Hir] = alternation.subs();",
          "    assert_eq!(subs.len(), 2);"
        ],
        "code": [
          "{",
          "    let look = Look::Start;",
          "    let hir_kind = HirKind::Look(look);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    let literal = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'a' });",
          "    let subs: &[Hir] = literal.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let empty = HirKind::Empty;",
          "    let subs: &[Hir] = empty.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let look = Look::End;",
          "    let hir_kind = HirKind::Look(look);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let class = Class::Unicode(ClassUnicode::default());",
          "    let hir_kind = HirKind::Class(class);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 0);",
          "    ",
          "    let repetition = Repetition { min: 1, max: Some(5), greedy: true, sub: Box::new(HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'b' })) };",
          "    let hir_kind = HirKind::Repetition(repetition);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 1);",
          "    ",
          "    let capture = Capture { index: 0, name: None, sub: Box::new(HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'c' })) };",
          "    let hir_kind = HirKind::Capture(capture);",
          "    let subs: &[Hir] = hir_kind.subs();",
          "    assert_eq!(subs.len(), 1);",
          "    ",
          "    let concat = HirKind::Concat(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'd' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'e' })]);",
          "    let subs: &[Hir] = concat.subs();",
          "    assert_eq!(subs.len(), 2);",
          "    ",
          "    let alternation = HirKind::Alternation(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'f' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::SomeKind, c: 'g' })]);",
          "    let subs: &[Hir] = alternation.subs();",
          "    assert_eq!(subs.len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]