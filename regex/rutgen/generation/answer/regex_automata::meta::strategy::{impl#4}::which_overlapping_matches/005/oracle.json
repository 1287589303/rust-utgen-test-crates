[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = Input {",
          "        haystack: &[b'a'; 256],",
          "        span: Span::new(0, 256),",
          "        anchored: Anchored::True,",
          "        earliest: true,",
          "    };",
          "    let mut patset = PatternSet {",
          "        len: 1,",
          "        which: alloc::boxed::Box::new([true; 10]),",
          "    };",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache(None),",
          "        backtrack: wrappers::BoundedBacktrackerCache(None),",
          "        onepass: wrappers::OnePassCache(None),",
          "        hybrid: wrappers::HybridCache(None),",
          "        revhybrid: wrappers::ReverseHybridCache(None),",
          "    };",
          "    let core = Core {",
          "        info: RegexInfo(Arc::new(RegexInfoI {})),",
          "        pre: None,",
          "        nfa: NFA(Arc::new(Inner {})),",
          "        nfarev: None,",
          "        pikevm: wrappers::PikeVM::none(),",
          "        backtrack: wrappers::BoundedBacktracker::new(),",
          "        onepass: wrappers::OnePass::none(),",
          "        hybrid: wrappers::Hybrid::none(),",
          "        dfa: DFA::new(&core.info, core.pre, &core.nfa, &core.nfarev),",
          "    };",
          "    ",
          "    core.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "}"
        ],
        "oracle": [
          "    assert!(core.dfa.get(&input).is_some());",
          "    let engine = core.dfa.get(&input).unwrap();",
          "    assert!(engine.try_which_overlapping_matches(&input, &mut patset).is_ok());",
          "    assert_eq!(patset.len, 1);",
          "    assert!(patset.which[0]);"
        ],
        "code": [
          "{",
          "    let input = Input {",
          "        haystack: &[b'a'; 256],",
          "        span: Span::new(0, 256),",
          "        anchored: Anchored::True,",
          "        earliest: true,",
          "    };",
          "    let mut patset = PatternSet {",
          "        len: 1,",
          "        which: alloc::boxed::Box::new([true; 10]),",
          "    };",
          "    let mut cache = Cache {",
          "        capmatches: Captures::new(),",
          "        pikevm: wrappers::PikeVMCache(None),",
          "        backtrack: wrappers::BoundedBacktrackerCache(None),",
          "        onepass: wrappers::OnePassCache(None),",
          "        hybrid: wrappers::HybridCache(None),",
          "        revhybrid: wrappers::ReverseHybridCache(None),",
          "    };",
          "    let core = Core {",
          "        info: RegexInfo(Arc::new(RegexInfoI {})),",
          "        pre: None,",
          "        nfa: NFA(Arc::new(Inner {})),",
          "        nfarev: None,",
          "        pikevm: wrappers::PikeVM::none(),",
          "        backtrack: wrappers::BoundedBacktracker::new(),",
          "        onepass: wrappers::OnePass::none(),",
          "        hybrid: wrappers::Hybrid::none(),",
          "        dfa: DFA::new(&core.info, core.pre, &core.nfa, &core.nfarev),",
          "    };",
          "    ",
          "    core.which_overlapping_matches(&mut cache, &input, &mut patset);",
          "    assert!(core.dfa.get(&input).is_some());",
          "    let engine = core.dfa.get(&input).unwrap();",
          "    assert!(engine.try_which_overlapping_matches(&input, &mut patset).is_ok());",
          "    assert_eq!(patset.len, 1);",
          "    assert!(patset.which[0]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]