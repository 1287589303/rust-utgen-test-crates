[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_classes = ByteClasses::empty();",
          "    let _ = byte_classes.stride2();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(byte_classes.stride2(), 0);",
          "    let byte_classes_singleton = ByteClasses::singletons();",
          "    assert_eq!(byte_classes_singleton.stride2(), 1);",
          "    let mut filled_byte_classes = ByteClasses::empty();",
          "    filled_byte_classes.set(0, 1);",
          "    assert_eq!(filled_byte_classes.stride2(), 1);",
          "    filled_byte_classes.set(255, 1);",
          "    assert_eq!(filled_byte_classes.stride2(), 8);",
          "    filled_byte_classes.set(127, 3);",
          "    assert_eq!(filled_byte_classes.stride2(), 8);",
          "    let mut full_byte_classes = ByteClasses::empty();",
          "    for i in 0..=255 { full_byte_classes.set(i, 1); }",
          "    assert_eq!(full_byte_classes.stride2(), 9);"
        ],
        "code": [
          "{",
          "    let byte_classes = ByteClasses::empty();",
          "    let _ = byte_classes.stride2();",
          "    assert_eq!(byte_classes.stride2(), 0);",
          "    let byte_classes_singleton = ByteClasses::singletons();",
          "    assert_eq!(byte_classes_singleton.stride2(), 1);",
          "    let mut filled_byte_classes = ByteClasses::empty();",
          "    filled_byte_classes.set(0, 1);",
          "    assert_eq!(filled_byte_classes.stride2(), 1);",
          "    filled_byte_classes.set(255, 1);",
          "    assert_eq!(filled_byte_classes.stride2(), 8);",
          "    filled_byte_classes.set(127, 3);",
          "    assert_eq!(filled_byte_classes.stride2(), 8);",
          "    let mut full_byte_classes = ByteClasses::empty();",
          "    for i in 0..=255 { full_byte_classes.set(i, 1); }",
          "    assert_eq!(full_byte_classes.stride2(), 9);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let byte_classes = ByteClasses::singletons();",
          "    let _ = byte_classes.stride2();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(byte_classes.stride2(), expected_value);",
          "    let byte_classes_empty = ByteClasses::empty();",
          "    assert_eq!(byte_classes_empty.stride2(), expected_value_empty);",
          "    let byte_classes_custom = ByteClasses::from_bytes(&custom_slice).expect(\"Failed to create ByteClasses\");",
          "    assert_eq!(byte_classes_custom.stride2(), expected_value_custom);",
          "    assert!(byte_classes.stride2() >= 0);",
          "    assert!(byte_classes.stride2() <= max_expected_stride);",
          "    let byte_classes_singleton = ByteClasses::singletons();",
          "    assert!(byte_classes_singleton.stride2() > 0);",
          "    assert!(byte_classes_singleton.stride2() <= 8);"
        ],
        "code": [
          "{",
          "    let byte_classes = ByteClasses::singletons();",
          "    let _ = byte_classes.stride2();",
          "    assert_eq!(byte_classes.stride2(), expected_value);",
          "    let byte_classes_empty = ByteClasses::empty();",
          "    assert_eq!(byte_classes_empty.stride2(), expected_value_empty);",
          "    let byte_classes_custom = ByteClasses::from_bytes(&custom_slice).expect(\"Failed to create ByteClasses\");",
          "    assert_eq!(byte_classes_custom.stride2(), expected_value_custom);",
          "    assert!(byte_classes.stride2() >= 0);",
          "    assert!(byte_classes.stride2() <= max_expected_stride);",
          "    let byte_classes_singleton = ByteClasses::singletons();",
          "    assert!(byte_classes_singleton.stride2() > 0);",
          "    assert!(byte_classes_singleton.stride2() <= 8);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    for byte in 0..256 {",
          "        byte_classes.set(byte, 1);",
          "    }",
          "    let _ = byte_classes.stride2();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(byte_classes.stride2(), expected_stride2_value);",
          "    assert!(byte_classes.stride2() >= 0);",
          "    assert!(byte_classes.stride2() <= 8);",
          "    assert!(byte_classes.stride2().is_power_of_two());",
          "    assert_eq!(byte_classes.stride2(), byte_classes.alphabet_len().next_power_of_two().trailing_zeros() as usize);"
        ],
        "code": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    for byte in 0..256 {",
          "        byte_classes.set(byte, 1);",
          "    }",
          "    let _ = byte_classes.stride2();",
          "    assert_eq!(byte_classes.stride2(), expected_stride2_value);",
          "    assert!(byte_classes.stride2() >= 0);",
          "    assert!(byte_classes.stride2() <= 8);",
          "    assert!(byte_classes.stride2().is_power_of_two());",
          "    assert_eq!(byte_classes.stride2(), byte_classes.alphabet_len().next_power_of_two().trailing_zeros() as usize);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    byte_classes.set(0, 1);",
          "    byte_classes.set(1, 1);",
          "    byte_classes.set(2, 1);",
          "    let _ = byte_classes.stride2();",
          "}"
        ],
        "oracle": [
          "    let mut byte_classes = ByteClasses::empty();",
          "    byte_classes.set(0, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_1_class);",
          "    byte_classes.set(1, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_2_classes);",
          "    byte_classes.set(2, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_3_classes);",
          "    byte_classes.set(3, 0);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_3_classes_with_zero);",
          "    byte_classes.set(255, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_4_classes_with_high);",
          "    byte_classes = ByteClasses::singletons();",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_singletons);"
        ],
        "code": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    byte_classes.set(0, 1);",
          "    byte_classes.set(1, 1);",
          "    byte_classes.set(2, 1);",
          "    let _ = byte_classes.stride2();",
          "    let mut byte_classes = ByteClasses::empty();",
          "    byte_classes.set(0, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_1_class);",
          "    byte_classes.set(1, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_2_classes);",
          "    byte_classes.set(2, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_3_classes);",
          "    byte_classes.set(3, 0);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_3_classes_with_zero);",
          "    byte_classes.set(255, 1);",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_4_classes_with_high);",
          "    byte_classes = ByteClasses::singletons();",
          "    assert_eq!(byte_classes.stride2(), expected_stride_for_singletons);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    let _ = byte_classes.stride2();",
          "}"
        ],
        "oracle": [
          "    let byte_classes = ByteClasses::empty();",
          "    let stride = byte_classes.stride2();",
          "    assert_eq!(stride, 0);",
          "    let mut singletons_byte_classes = ByteClasses::singletons();",
          "    let singletons_stride = singletons_byte_classes.stride2();",
          "    assert!(singletons_stride > 0);",
          "    let mut custom_byte_classes = ByteClasses::empty();",
          "    custom_byte_classes.set(0, 0);",
          "    let custom_stride = custom_byte_classes.stride2();",
          "    assert_eq!(custom_stride, expected_stride_value);",
          "    let alphabet_length = custom_byte_classes.alphabet_len();",
          "    assert!(custom_stride >= (alphabet_length as usize).next_power_of_two().trailing_zeros() as usize);",
          "    let _ = custom_byte_classes.iter();",
          "    let stride_for_non_empty = custom_byte_classes.stride2();",
          "    assert!(stride_for_non_empty > 0);"
        ],
        "code": [
          "{",
          "    let mut byte_classes = ByteClasses::empty();",
          "    let _ = byte_classes.stride2();",
          "    let byte_classes = ByteClasses::empty();",
          "    let stride = byte_classes.stride2();",
          "    assert_eq!(stride, 0);",
          "    let mut singletons_byte_classes = ByteClasses::singletons();",
          "    let singletons_stride = singletons_byte_classes.stride2();",
          "    assert!(singletons_stride > 0);",
          "    let mut custom_byte_classes = ByteClasses::empty();",
          "    custom_byte_classes.set(0, 0);",
          "    let custom_stride = custom_byte_classes.stride2();",
          "    assert_eq!(custom_stride, expected_stride_value);",
          "    let alphabet_length = custom_byte_classes.alphabet_len();",
          "    assert!(custom_stride >= (alphabet_length as usize).next_power_of_two().trailing_zeros() as usize);",
          "    let _ = custom_byte_classes.iter();",
          "    let stride_for_non_empty = custom_byte_classes.stride2();",
          "    assert!(stride_for_non_empty > 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]