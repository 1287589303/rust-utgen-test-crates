[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::Start;",
          "    let next = StateID(SmallIndex::new_unchecked(5));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(output, \"Start => 5\");"
        ],
        "code": [
          "{",
          "    let look = Look::Start;",
          "    let next = StateID(SmallIndex::new_unchecked(5));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "    assert_eq!(output, \"Start => 5\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::End;",
          "    let next = StateID(SmallIndex::new_unchecked(10));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"End => 10\") == res.unwrap()",
          "    assert_eq!(output, \"End => 10\")"
        ],
        "code": [
          "{",
          "    let look = Look::End;",
          "    let next = StateID(SmallIndex::new_unchecked(10));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "    write!(f, \"End => 10\") == res.unwrap()",
          "    assert_eq!(output, \"End => 10\")",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::WordAscii;",
          "    let next = StateID(SmallIndex::new_unchecked(15));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"WordAscii => {:?}\", next.as_usize());",
          "    write!(f, \"capture(pid={:?}, group={:?}, slot={:?}) => {:?}\", pattern_id.as_usize(), group_index.as_usize(), slot.as_usize(), next.as_usize());",
          "    write!(f, \"FAIL\");",
          "    write!(f, \"MATCH({:?})\", pattern_id.as_usize());",
          "    assert_eq!(res, Ok(()));",
          "    assert_eq!(output, \"WordAscii => 15\");",
          "    assert!(output.contains(\"WordAscii\"));"
        ],
        "code": [
          "{",
          "    let look = Look::WordAscii;",
          "    let next = StateID(SmallIndex::new_unchecked(15));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "    write!(f, \"WordAscii => {:?}\", next.as_usize());",
          "    write!(f, \"capture(pid={:?}, group={:?}, slot={:?}) => {:?}\", pattern_id.as_usize(), group_index.as_usize(), slot.as_usize(), next.as_usize());",
          "    write!(f, \"FAIL\");",
          "    write!(f, \"MATCH({:?})\", pattern_id.as_usize());",
          "    assert_eq!(res, Ok(()));",
          "    assert_eq!(output, \"WordAscii => 15\");",
          "    assert!(output.contains(\"WordAscii\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::WordUnicode;",
          "    let next = StateID(SmallIndex::new_unchecked(20));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(output, \"WordUnicode => 20\");",
          "    assert!(res.is_ok());"
        ],
        "code": [
          "{",
          "    let look = Look::WordUnicode;",
          "    let next = StateID(SmallIndex::new_unchecked(20));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "    assert_eq!(output, \"WordUnicode => 20\");",
          "    assert!(res.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let look = Look::WordEndAscii;",
          "    let next = StateID(SmallIndex::new_unchecked(core::i32::MAX as usize - 1));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(output, \"WordEndAscii => 2147483647\");",
          "    assert!(res.is_ok());"
        ],
        "code": [
          "{",
          "    let look = Look::WordEndAscii;",
          "    let next = StateID(SmallIndex::new_unchecked(core::i32::MAX as usize - 1));",
          "    let state = State::Look { look, next };",
          "    let mut output = String::new();",
          "    let res = state.fmt(&mut output);",
          "    assert_eq!(output, \"WordEndAscii => 2147483647\");",
          "    assert!(res.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]