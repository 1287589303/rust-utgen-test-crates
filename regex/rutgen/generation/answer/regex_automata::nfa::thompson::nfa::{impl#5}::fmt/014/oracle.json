[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([Transition { start: 0u8, end: 1u8, next: StateID(SmallIndex::new_unchecked(1)) }]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(format!(\"{:?}\", state), \"sparse(Transition { start: 0, end: 1, next: StateID(1) })\");"
        ],
        "code": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([Transition { start: 0u8, end: 1u8, next: StateID(SmallIndex::new_unchecked(1)) }]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "    assert_eq!(format!(\"{:?}\", state), \"sparse(Transition { start: 0, end: 1, next: StateID(1) })\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([",
          "            Transition { start: 0u8, end: 0u8, next: StateID(SmallIndex::new_unchecked(1)) },",
          "            Transition { start: 2u8, end: 2u8, next: StateID(SmallIndex::new_unchecked(2)) },",
          "            Transition { start: 3u8, end: 5u8, next: StateID(SmallIndex::new_unchecked(3)) },",
          "        ]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "}"
        ],
        "oracle": [
          "    let transitions = SparseTransitions { transitions: Box::from([ Transition { start: 0u8, end: 0u8, next: StateID(SmallIndex::new_unchecked(1)) }, Transition { start: 2u8, end: 2u8, next: StateID(SmallIndex::new_unchecked(2)) }, Transition { start: 3u8, end: 5u8, next: StateID(SmallIndex::new_unchecked(3)) }, ]) };",
          "    let state = State::Sparse(transitions);",
          "    let output = format!(\"{:?}\", state);",
          "    assert!(output.contains(\"sparse\"));",
          "    assert!(output.contains(\"Transition { start: 0, end: 0, next: 1 }\"));",
          "    assert!(output.contains(\"Transition { start: 2, end: 2, next: 2 }\"));",
          "    assert!(output.contains(\"Transition { start: 3, end: 5, next: 3 }\"));"
        ],
        "code": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([",
          "            Transition { start: 0u8, end: 0u8, next: StateID(SmallIndex::new_unchecked(1)) },",
          "            Transition { start: 2u8, end: 2u8, next: StateID(SmallIndex::new_unchecked(2)) },",
          "            Transition { start: 3u8, end: 5u8, next: StateID(SmallIndex::new_unchecked(3)) },",
          "        ]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "    let transitions = SparseTransitions { transitions: Box::from([ Transition { start: 0u8, end: 0u8, next: StateID(SmallIndex::new_unchecked(1)) }, Transition { start: 2u8, end: 2u8, next: StateID(SmallIndex::new_unchecked(2)) }, Transition { start: 3u8, end: 5u8, next: StateID(SmallIndex::new_unchecked(3)) }, ]) };",
          "    let state = State::Sparse(transitions);",
          "    let output = format!(\"{:?}\", state);",
          "    assert!(output.contains(\"sparse\"));",
          "    assert!(output.contains(\"Transition { start: 0, end: 0, next: 1 }\"));",
          "    assert!(output.contains(\"Transition { start: 2, end: 2, next: 2 }\"));",
          "    assert!(output.contains(\"Transition { start: 3, end: 5, next: 3 }\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"sparse()\")",
          "    let transitions = SparseTransitions { transitions: Box::from([]) };",
          "    assert_eq!(format!(\"{:?}\", state), \"sparse()\");"
        ],
        "code": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "    write!(f, \"sparse()\")",
          "    let transitions = SparseTransitions { transitions: Box::from([]) };",
          "    assert_eq!(format!(\"{:?}\", state), \"sparse()\");",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([",
          "            Transition { start: 0u8, end: 0u8, next: StateID(SmallIndex::new_unchecked(255)) },",
          "            Transition { start: 1u8, end: 1u8, next: StateID(SmallIndex::new_unchecked(254)) },",
          "        ]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "}"
        ],
        "oracle": [
          "    write!(f, \"sparse(Transition {{ start: 0, end: 0, next: 255 }}, Transition {{ start: 1, end: 1, next: 254 }})\")",
          "    write!(f, \"sparse({})\", \"Transition { start: 0, end: 0, next: 255 }, Transition { start: 1, end: 1, next: 254 }\")"
        ],
        "code": [
          "{",
          "    let transitions = SparseTransitions {",
          "        transitions: Box::from([",
          "            Transition { start: 0u8, end: 0u8, next: StateID(SmallIndex::new_unchecked(255)) },",
          "            Transition { start: 1u8, end: 1u8, next: StateID(SmallIndex::new_unchecked(254)) },",
          "        ]),",
          "    };",
          "    let state = State::Sparse(transitions);",
          "    let _ = format!(\"{:?}\", state);",
          "    write!(f, \"sparse(Transition {{ start: 0, end: 0, next: 255 }}, Transition {{ start: 1, end: 1, next: 254 }})\")",
          "    write!(f, \"sparse({})\", \"Transition { start: 0, end: 0, next: 255 }, Transition { start: 1, end: 1, next: 254 }\")",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]