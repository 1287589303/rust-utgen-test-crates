[
  {
    "uses": [
      "use regex_automata::dfa::dense;",
      "use regex_automata::util::prefilter::Prefilter;",
      "use regex_automata::dfa::Automaton;",
      "use regex_automata::nfa::thompson::NFA;",
      "use regex_automata::util::alphabet::ByteSet;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_automata::{",
          "        dfa::{dense, Automaton},",
          "        nfa::thompson::NFA,",
          "        util::{alphabet::ByteSet, prefilter::Prefilter},",
          "    };",
          "",
          "    let nfa = NFA::new(\"abc\").unwrap();",
          "    let mut builder = dense::Builder::new();",
          "    builder.configure(",
          "        dense::Config::new()",
          "            .unicode_word_boundary(true)",
          "            .byte_classes(false)",
          "            .minimize(false)",
          "            .accelerate(false)",
          "            .specialize_start_states(false),",
          "    );",
          "",
          "    let mut quitset = ByteSet::empty();",
          "    for b in 0x80..=0xFF {",
          "        quitset.add(b);",
          "    }",
          "",
          "    let dfa = builder.build_from_nfa(&nfa).unwrap();",
          "}"
        ],
        "oracle": [
          "    assert!(builder.config.get_unicode_word_boundary());",
          "    assert!(nfa.look_set_any().contains_word_unicode());",
          "    for b in 0x80..=0xFF {",
          "    quitset.add(b);",
          "    }",
          "    assert!(!builder.config.get_byte_classes());",
          "    assert!(DFA::initial(",
          "    classes,",
          "    nfa.pattern_len(),",
          "    builder.config.get_starts(),",
          "    nfa.look_matcher(),",
          "    builder.config.get_starts_for_each_pattern(),",
          "    builder.config.get_prefilter().map(|p| p.clone()),",
          "    quitset,",
          "    Flags::from_nfa(&nfa),",
          "    ).is_ok());",
          "    assert!(determinize::Config::new()",
          "    .match_kind(builder.config.get_match_kind())",
          "    .quit(quitset)",
          "    .dfa_size_limit(builder.config.get_dfa_size_limit())",
          "    .determinize_size_limit(builder.config.get_determinize_size_limit())",
          "    .run(&nfa, &mut dfa).is_ok());",
          "    assert!(!builder.config.get_minimize());",
          "    assert!(!builder.config.get_accelerate());",
          "    assert!(!builder.config.get_specialize_start_states());",
          "    assert_eq!(dfa, Ok(dfa));"
        ],
        "code": [
          "{",
          "    use regex_automata::{",
          "        dfa::{dense, Automaton},",
          "        nfa::thompson::NFA,",
          "        util::{alphabet::ByteSet, prefilter::Prefilter},",
          "    };",
          "",
          "    let nfa = NFA::new(\"abc\").unwrap();",
          "    let mut builder = dense::Builder::new();",
          "    builder.configure(",
          "        dense::Config::new()",
          "            .unicode_word_boundary(true)",
          "            .byte_classes(false)",
          "            .minimize(false)",
          "            .accelerate(false)",
          "            .specialize_start_states(false),",
          "    );",
          "",
          "    let mut quitset = ByteSet::empty();",
          "    for b in 0x80..=0xFF {",
          "        quitset.add(b);",
          "    }",
          "",
          "    let dfa = builder.build_from_nfa(&nfa).unwrap();",
          "    assert!(builder.config.get_unicode_word_boundary());",
          "    assert!(nfa.look_set_any().contains_word_unicode());",
          "    for b in 0x80..=0xFF {",
          "    quitset.add(b);",
          "    }",
          "    assert!(!builder.config.get_byte_classes());",
          "    assert!(DFA::initial(",
          "    classes,",
          "    nfa.pattern_len(),",
          "    builder.config.get_starts(),",
          "    nfa.look_matcher(),",
          "    builder.config.get_starts_for_each_pattern(),",
          "    builder.config.get_prefilter().map(|p| p.clone()),",
          "    quitset,",
          "    Flags::from_nfa(&nfa),",
          "    ).is_ok());",
          "    assert!(determinize::Config::new()",
          "    .match_kind(builder.config.get_match_kind())",
          "    .quit(quitset)",
          "    .dfa_size_limit(builder.config.get_dfa_size_limit())",
          "    .determinize_size_limit(builder.config.get_determinize_size_limit())",
          "    .run(&nfa, &mut dfa).is_ok());",
          "    assert!(!builder.config.get_minimize());",
          "    assert!(!builder.config.get_accelerate());",
          "    assert!(!builder.config.get_specialize_start_states());",
          "    assert_eq!(dfa, Ok(dfa));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use regex_automata::{",
          "        dfa::{dense, Automaton},",
          "        nfa::thompson::NFA,",
          "        util::{alphabet::ByteSet, prefilter::Prefilter},",
          "    };",
          "",
          "    let nfa = NFA::new(\"abc\").unwrap();",
          "    let mut builder = dense::Builder::new();",
          "    builder.configure(",
          "        dense::Config::new()",
          "            .unicode_word_boundary(false)",
          "            .byte_classes(false)",
          "            .minimize(false)",
          "            .accelerate(false)",
          "            .specialize_start_states(false),",
          "    );",
          "",
          "    let dfa = builder.build_from_nfa(&nfa).unwrap();",
          "}"
        ],
        "oracle": [
          "    Ok(nfa)",
          "    self.config.get_unicode_word_boundary() == true",
          "    nfa.look_set_any().contains_word_unicode() == true",
          "    b in 0x80..=0xFF == true",
          "    self.config.get_byte_classes() == false",
          "    DFA::initial(classes, nfa.pattern_len(), self.config.get_starts(), nfa.look_matcher(), self.config.get_starts_for_each_pattern(), self.config.get_prefilter().map(|p| p.clone()), quitset, Flags::from_nfa(&nfa))? == Ok(dfa)",
          "    determinize::Config::new().match_kind(self.config.get_match_kind()).quit(quitset).dfa_size_limit(self.config.get_dfa_size_limit()).determinize_size_limit(self.config.get_determinize_size_limit()).run(nfa, &mut dfa)? == Ok(dfa)",
          "    self.config.get_minimize() == false",
          "    self.config.get_accelerate() == false",
          "    self.config.get_specialize_start_states() == false"
        ],
        "code": [
          "{",
          "    use regex_automata::{",
          "        dfa::{dense, Automaton},",
          "        nfa::thompson::NFA,",
          "        util::{alphabet::ByteSet, prefilter::Prefilter},",
          "    };",
          "",
          "    let nfa = NFA::new(\"abc\").unwrap();",
          "    let mut builder = dense::Builder::new();",
          "    builder.configure(",
          "        dense::Config::new()",
          "            .unicode_word_boundary(false)",
          "            .byte_classes(false)",
          "            .minimize(false)",
          "            .accelerate(false)",
          "            .specialize_start_states(false),",
          "    );",
          "",
          "    let dfa = builder.build_from_nfa(&nfa).unwrap();",
          "    Ok(nfa)",
          "    self.config.get_unicode_word_boundary() == true",
          "    nfa.look_set_any().contains_word_unicode() == true",
          "    b in 0x80..=0xFF == true",
          "    self.config.get_byte_classes() == false",
          "    DFA::initial(classes, nfa.pattern_len(), self.config.get_starts(), nfa.look_matcher(), self.config.get_starts_for_each_pattern(), self.config.get_prefilter().map(|p| p.clone()), quitset, Flags::from_nfa(&nfa))? == Ok(dfa)",
          "    determinize::Config::new().match_kind(self.config.get_match_kind()).quit(quitset).dfa_size_limit(self.config.get_dfa_size_limit()).determinize_size_limit(self.config.get_determinize_size_limit()).run(nfa, &mut dfa)? == Ok(dfa)",
          "    self.config.get_minimize() == false",
          "    self.config.get_accelerate() == false",
          "    self.config.get_specialize_start_states() == false",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]