[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let first_concat = Hir::concat(vec![",
          "        Hir::literal(\"abc\".to_string()),",
          "        Hir::literal(\"123\".to_string()),",
          "    ]);",
          "    let second_concat = Hir::concat(vec![",
          "        Hir::literal(\"abc\".to_string()),",
          "        Hir::literal(\"456\".to_string()),",
          "    ]);",
          "",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "        Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    ",
          "    let _result = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    let first_concat = Hir::concat(vec![Hir::literal(\"abc\".to_string()), Hir::literal(\"123\".to_string())]);",
          "    let second_concat = Hir::concat(vec![Hir::literal(\"abc\".to_string()), Hir::literal(\"456\".to_string())]);",
          "    let hirs = vec![Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() }, Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() }];",
          "    assert_eq!(_result, Ok(Hir::concat(vec![Hir::literal(\"abc\".to_string()), Hir::alternation(vec![Hir::literal(\"123\".to_string()), Hir::literal(\"456\".to_string())])]));"
        ],
        "code": [
          "{",
          "    let first_concat = Hir::concat(vec![",
          "        Hir::literal(\"abc\".to_string()),",
          "        Hir::literal(\"123\".to_string()),",
          "    ]);",
          "    let second_concat = Hir::concat(vec![",
          "        Hir::literal(\"abc\".to_string()),",
          "        Hir::literal(\"456\".to_string()),",
          "    ]);",
          "",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "        Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    ",
          "    let _result = lift_common_prefix(hirs);",
          "    let first_concat = Hir::concat(vec![Hir::literal(\"abc\".to_string()), Hir::literal(\"123\".to_string())]);",
          "    let second_concat = Hir::concat(vec![Hir::literal(\"abc\".to_string()), Hir::literal(\"456\".to_string())]);",
          "    let hirs = vec![Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() }, Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() }];",
          "    assert_eq!(_result, Ok(Hir::concat(vec![Hir::literal(\"abc\".to_string()), Hir::alternation(vec![Hir::literal(\"123\".to_string()), Hir::literal(\"456\".to_string())])]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let first_concat = Hir::concat(vec![",
          "        Hir::literal(\"xyz\".to_string()),",
          "    ]);",
          "    let second_concat = Hir::concat(vec![",
          "        Hir::literal(\"xyz\".to_string()),",
          "        Hir::literal(\"boom\".to_string()),",
          "    ]);",
          "",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "        Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    ",
          "    let _result = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    let first_concat = Hir::concat(vec![Hir::literal(\"xyz\".to_string())]);",
          "    let second_concat = Hir::concat(vec![Hir::literal(\"xyz\".to_string()), Hir::literal(\"boom\".to_string())]);",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "    Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().kind(), &HirKind::Concat(vec![",
          "    Hir::literal(\"xyz\".to_string()),",
          "    Hir::alternation(vec![",
          "    Hir::concat(vec![Hir::literal(\"boom\".to_string())]),",
          "    ]),",
          "    ]));"
        ],
        "code": [
          "{",
          "    let first_concat = Hir::concat(vec![",
          "        Hir::literal(\"xyz\".to_string()),",
          "    ]);",
          "    let second_concat = Hir::concat(vec![",
          "        Hir::literal(\"xyz\".to_string()),",
          "        Hir::literal(\"boom\".to_string()),",
          "    ]);",
          "",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "        Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    ",
          "    let _result = lift_common_prefix(hirs);",
          "    let first_concat = Hir::concat(vec![Hir::literal(\"xyz\".to_string())]);",
          "    let second_concat = Hir::concat(vec![Hir::literal(\"xyz\".to_string()), Hir::literal(\"boom\".to_string())]);",
          "    let hirs = vec![",
          "    Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "    Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert!(result.is_ok());",
          "    assert_eq!(result.unwrap().kind(), &HirKind::Concat(vec![",
          "    Hir::literal(\"xyz\".to_string()),",
          "    Hir::alternation(vec![",
          "    Hir::concat(vec![Hir::literal(\"boom\".to_string())]),",
          "    ]),",
          "    ]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let first_concat = Hir::concat(vec![",
          "        Hir::literal(\"foo\".to_string()),",
          "        Hir::literal(\"bar\".to_string()),",
          "    ]);",
          "    let second_concat = Hir::concat(vec![",
          "        Hir::literal(\"foo\".to_string()),",
          "        Hir::literal(\"baz\".to_string()),",
          "    ]);",
          "",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "        Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    ",
          "    let _result = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    let first_concat = Hir::concat(vec![Hir::literal(\"foo\".to_string()), Hir::literal(\"bar\".to_string())]);",
          "    let second_concat = Hir::concat(vec![Hir::literal(\"foo\".to_string()), Hir::literal(\"baz\".to_string())]);",
          "    let hirs = vec![Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() }, Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() }];",
          "    let result = lift_common_prefix(hirs);",
          "    assert!(result.is_ok());",
          "    if let Ok(hir) = result {",
          "    match hir.kind() {",
          "    HirKind::Concat(ref xs) => {",
          "    assert_eq!(xs.len(), 2);",
          "    assert!(matches!(xs[0].kind(), HirKind::Concat(_)));",
          "    assert!(matches!(xs[1].kind(), HirKind::Alternation(_)));",
          "    }",
          "    _ => panic!(\"Expected HirKind::Concat\")",
          "    }",
          "    }"
        ],
        "code": [
          "{",
          "    let first_concat = Hir::concat(vec![",
          "        Hir::literal(\"foo\".to_string()),",
          "        Hir::literal(\"bar\".to_string()),",
          "    ]);",
          "    let second_concat = Hir::concat(vec![",
          "        Hir::literal(\"foo\".to_string()),",
          "        Hir::literal(\"baz\".to_string()),",
          "    ]);",
          "",
          "    let hirs = vec![",
          "        Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() },",
          "        Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() },",
          "    ];",
          "    ",
          "    let _result = lift_common_prefix(hirs);",
          "    let first_concat = Hir::concat(vec![Hir::literal(\"foo\".to_string()), Hir::literal(\"bar\".to_string())]);",
          "    let second_concat = Hir::concat(vec![Hir::literal(\"foo\".to_string()), Hir::literal(\"baz\".to_string())]);",
          "    let hirs = vec![Hir { kind: HirKind::Concat(vec![first_concat]), props: Properties::default() }, Hir { kind: HirKind::Concat(vec![second_concat]), props: Properties::default() }];",
          "    let result = lift_common_prefix(hirs);",
          "    assert!(result.is_ok());",
          "    if let Ok(hir) = result {",
          "    match hir.kind() {",
          "    HirKind::Concat(ref xs) => {",
          "    assert_eq!(xs.len(), 2);",
          "    assert!(matches!(xs[0].kind(), HirKind::Concat(_)));",
          "    assert!(matches!(xs[1].kind(), HirKind::Alternation(_)));",
          "    }",
          "    _ => panic!(\"Expected HirKind::Concat\")",
          "    }",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]