[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let first = Hir {",
          "        kind: HirKind::Concat(vec![]), // Empty prefix",
          "        props: Properties {},",
          "    };",
          "    let second = Hir {",
          "        kind: HirKind::Concat(vec![Hir {",
          "            kind: HirKind::Literal(Literal::from(\"test\")),",
          "            props: Properties {},",
          "        }]),",
          "        props: Properties {},",
          "    };",
          "    ",
          "    let hirs = vec![first, second];",
          "    let _ = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(lift_common_prefix(vec![Hir { kind: HirKind::Concat(vec![]), props: Properties {} }, Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties {} }]), props: Properties {} }]), Err(vec![Hir { kind: HirKind::Concat(vec![]), props: Properties {} }, Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties {} }]), props: Properties {} }]));"
        ],
        "code": [
          "{",
          "    let first = Hir {",
          "        kind: HirKind::Concat(vec![]), // Empty prefix",
          "        props: Properties {},",
          "    };",
          "    let second = Hir {",
          "        kind: HirKind::Concat(vec![Hir {",
          "            kind: HirKind::Literal(Literal::from(\"test\")),",
          "            props: Properties {},",
          "        }]),",
          "        props: Properties {},",
          "    };",
          "    ",
          "    let hirs = vec![first, second];",
          "    let _ = lift_common_prefix(hirs);",
          "    assert_eq!(lift_common_prefix(vec![Hir { kind: HirKind::Concat(vec![]), props: Properties {} }, Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties {} }]), props: Properties {} }]), Err(vec![Hir { kind: HirKind::Concat(vec![]), props: Properties {} }, Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"test\")), props: Properties {} }]), props: Properties {} }]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let first = Hir {",
          "        kind: HirKind::Concat(vec![]), // Empty prefix",
          "        props: Properties {},",
          "    };",
          "    let second = Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::from(\"example\")),",
          "                props: Properties {},",
          "            },",
          "        ]),",
          "        props: Properties {},",
          "    };",
          "    let third = Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::from(\"sample\")),",
          "                props: Properties {},",
          "            },",
          "        ]),",
          "        props: Properties {},",
          "    };",
          "    ",
          "    let hirs = vec![first, second, third];",
          "    let _ = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    let first = Hir { kind: HirKind::Concat(vec![]), props: Properties {} };",
          "    let second = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"example\")), props: Properties {} }]), props: Properties {} };",
          "    let third = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"sample\")), props: Properties {} }]), props: Properties {} };",
          "    let hirs = vec![first, second, third];",
          "    assert_eq!(lift_common_prefix(hirs), Err(hirs));"
        ],
        "code": [
          "{",
          "    let first = Hir {",
          "        kind: HirKind::Concat(vec![]), // Empty prefix",
          "        props: Properties {},",
          "    };",
          "    let second = Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::from(\"example\")),",
          "                props: Properties {},",
          "            },",
          "        ]),",
          "        props: Properties {},",
          "    };",
          "    let third = Hir {",
          "        kind: HirKind::Concat(vec![",
          "            Hir {",
          "                kind: HirKind::Literal(Literal::from(\"sample\")),",
          "                props: Properties {},",
          "            },",
          "        ]),",
          "        props: Properties {},",
          "    };",
          "    ",
          "    let hirs = vec![first, second, third];",
          "    let _ = lift_common_prefix(hirs);",
          "    let first = Hir { kind: HirKind::Concat(vec![]), props: Properties {} };",
          "    let second = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"example\")), props: Properties {} }]), props: Properties {} };",
          "    let third = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(Literal::from(\"sample\")), props: Properties {} }]), props: Properties {} };",
          "    let hirs = vec![first, second, third];",
          "    assert_eq!(lift_common_prefix(hirs), Err(hirs));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]