[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"foo\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"bar\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"foo\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"baz\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "",
          "    let _result = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(\"bar\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    ]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(\"baz\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    ]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    ",
          "    assert!(hirs.len() > 1);",
          "    let prefix = match hirs[0].kind() {",
          "    HirKind::Concat(ref xs) => xs,",
          "    _ => panic!(\"Expected HirKind::Concat\"),",
          "    };",
          "    assert!(!prefix.is_empty());",
          "    for h in hirs.iter().skip(1) {",
          "    let concat = match h.kind() {",
          "    HirKind::Concat(ref xs) => xs,",
          "    _ => panic!(\"Expected HirKind::Concat\"),",
          "    };",
          "    let common_len = prefix",
          "    .iter()",
          "    .zip(concat.iter())",
          "    .take_while(|(x, y)| x == y)",
          "    .count();",
          "    assert!(common_len != 0);",
          "    }",
          "    let len = prefix.len();",
          "    let mut prefix_concat = vec![];",
          "    let mut suffix_alts = vec![];",
          "    for h in hirs {",
          "    let mut concat = match h.into_kind() {",
          "    HirKind::Concat(xs) => xs,",
          "    _ => unreachable!(),",
          "    };",
          "    suffix_alts.push(Hir::concat(concat.split_off(len)));",
          "    if prefix_concat.is_empty() {",
          "    prefix_concat = concat;",
          "    }",
          "    }",
          "    let mut concat = prefix_concat;",
          "    concat.push(Hir::alternation(suffix_alts));",
          "    let result = lift_common_prefix(hirs);",
          "    assert!(result.is_ok());"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"foo\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"bar\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"foo\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"baz\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "",
          "    let _result = lift_common_prefix(hirs);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(\"bar\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    ]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![",
          "    Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Literal(\"baz\".into()),",
          "    props: Properties::default(),",
          "    },",
          "    ]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    ",
          "    assert!(hirs.len() > 1);",
          "    let prefix = match hirs[0].kind() {",
          "    HirKind::Concat(ref xs) => xs,",
          "    _ => panic!(\"Expected HirKind::Concat\"),",
          "    };",
          "    assert!(!prefix.is_empty());",
          "    for h in hirs.iter().skip(1) {",
          "    let concat = match h.kind() {",
          "    HirKind::Concat(ref xs) => xs,",
          "    _ => panic!(\"Expected HirKind::Concat\"),",
          "    };",
          "    let common_len = prefix",
          "    .iter()",
          "    .zip(concat.iter())",
          "    .take_while(|(x, y)| x == y)",
          "    .count();",
          "    assert!(common_len != 0);",
          "    }",
          "    let len = prefix.len();",
          "    let mut prefix_concat = vec![];",
          "    let mut suffix_alts = vec![];",
          "    for h in hirs {",
          "    let mut concat = match h.into_kind() {",
          "    HirKind::Concat(xs) => xs,",
          "    _ => unreachable!(),",
          "    };",
          "    suffix_alts.push(Hir::concat(concat.split_off(len)));",
          "    if prefix_concat.is_empty() {",
          "    prefix_concat = concat;",
          "    }",
          "    }",
          "    let mut concat = prefix_concat;",
          "    concat.push(Hir::alternation(suffix_alts));",
          "    let result = lift_common_prefix(hirs);",
          "    assert!(result.is_ok());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"abc\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"xyz\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"abc\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"123\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "",
          "    let _result = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(\"abc\".into()), props: Properties::default() }, Hir { kind: HirKind::Literal(\"xyz\".into()), props: Properties::default() }]), props: Properties::default() }, Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(\"abc\".into()), props: Properties::default() }, Hir { kind: HirKind::Literal(\"123\".into()), props: Properties::default() }]), props: Properties::default() }]; assert!(hirs.len() > 1); assert!(matches!(hirs[0].kind(), HirKind::Concat(_))); assert!(!hirs[0].kind().is_empty()); assert!(hirs.iter().skip(1).count() > 0); assert!(*left_val != *right_val); assert!(hirs.iter().any(|h| matches!(h.kind(), HirKind::Concat(_)))); assert!(matches!(h.into_kind(), HirKind::Concat(_))); assert!(prefix_concat.is_empty()); let result = lift_common_prefix(hirs).unwrap(); assert!(matches!(result, Hir::Concat(_)));"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"abc\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"xyz\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "        Hir {",
          "            kind: HirKind::Concat(vec![",
          "                Hir {",
          "                    kind: HirKind::Literal(\"abc\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "                Hir {",
          "                    kind: HirKind::Literal(\"123\".into()),",
          "                    props: Properties::default(),",
          "                },",
          "            ]),",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "",
          "    let _result = lift_common_prefix(hirs);",
          "    let hirs = vec![Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(\"abc\".into()), props: Properties::default() }, Hir { kind: HirKind::Literal(\"xyz\".into()), props: Properties::default() }]), props: Properties::default() }, Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(\"abc\".into()), props: Properties::default() }, Hir { kind: HirKind::Literal(\"123\".into()), props: Properties::default() }]), props: Properties::default() }]; assert!(hirs.len() > 1); assert!(matches!(hirs[0].kind(), HirKind::Concat(_))); assert!(!hirs[0].kind().is_empty()); assert!(hirs.iter().skip(1).count() > 0); assert!(*left_val != *right_val); assert!(hirs.iter().any(|h| matches!(h.kind(), HirKind::Concat(_)))); assert!(matches!(h.into_kind(), HirKind::Concat(_))); assert!(prefix_concat.is_empty()); let result = lift_common_prefix(hirs).unwrap(); assert!(matches!(result, Hir::Concat(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Concat(vec![Hir {",
          "                kind: HirKind::Literal(\"123\".into()),",
          "                props: Properties::default(),",
          "            }]),",
          "            props: Properties::default(),",
          "        },",
          "        Hir {",
          "            kind: HirKind::Concat(vec![Hir {",
          "                kind: HirKind::Literal(\"456\".into()),",
          "                props: Properties::default(),",
          "            }]),",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "",
          "    let _result = lift_common_prefix(hirs);",
          "}"
        ],
        "oracle": [
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"abc\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"abx\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_ok(), true);",
          "    let (kind, props) = result.unwrap().into_parts();",
          "    assert!(matches!(kind, HirKind::Concat(_)));",
          "    assert!(props.is_valid());",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"test\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"testing\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_err(), true);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_err(), true);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    }, Hir {",
          "    kind: HirKind::Literal(\"bar\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    }, Hir {",
          "    kind: HirKind::Literal(\"baz\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap().kind(), HirKind::Concat(_)));"
        ],
        "code": [
          "{",
          "    let hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Concat(vec![Hir {",
          "                kind: HirKind::Literal(\"123\".into()),",
          "                props: Properties::default(),",
          "            }]),",
          "            props: Properties::default(),",
          "        },",
          "        Hir {",
          "            kind: HirKind::Concat(vec![Hir {",
          "                kind: HirKind::Literal(\"456\".into()),",
          "                props: Properties::default(),",
          "            }]),",
          "            props: Properties::default(),",
          "        },",
          "    ];",
          "",
          "    let _result = lift_common_prefix(hirs);",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"abc\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"abx\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_ok(), true);",
          "    let (kind, props) = result.unwrap().into_parts();",
          "    assert!(matches!(kind, HirKind::Concat(_)));",
          "    assert!(props.is_valid());",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"test\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"testing\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_err(), true);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_err(), true);",
          "    ",
          "    let hirs = vec![",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    }, Hir {",
          "    kind: HirKind::Literal(\"bar\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    Hir {",
          "    kind: HirKind::Concat(vec![Hir {",
          "    kind: HirKind::Literal(\"foo\".into()),",
          "    props: Properties::default(),",
          "    }, Hir {",
          "    kind: HirKind::Literal(\"baz\".into()),",
          "    props: Properties::default(),",
          "    }]),",
          "    props: Properties::default(),",
          "    },",
          "    ];",
          "    let result = lift_common_prefix(hirs);",
          "    assert_eq!(result.is_ok(), true);",
          "    assert!(matches!(result.unwrap().kind(), HirKind::Concat(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]