[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id1 = StateID(SmallIndex(1));",
          "    let state_id2 = StateID(SmallIndex(2));",
          "    let state_id3 = StateID(SmallIndex(3));",
          "",
          "    let remap = vec![state_id1, state_id2, state_id3];",
          "    ",
          "    let state = State::Union {",
          "        alternates: Box::new([state_id2, state_id3]),",
          "    };",
          "",
          "    let mut state = state;",
          "    state.remap(&remap);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state, State::Union { alternates: Box::new([state_id2, state_id3]) });",
          "    assert_eq!(state.remap(&remap), ());",
          "    assert_eq!(state_id2, remap[state_id2]);",
          "    assert_eq!(state_id3, remap[state_id3]);",
          "    assert_eq!(state.remap(&remap).next, remap[state_id2]);",
          "    assert_eq!(state.remap(&remap).next, remap[state_id3]);"
        ],
        "code": [
          "{",
          "    let state_id1 = StateID(SmallIndex(1));",
          "    let state_id2 = StateID(SmallIndex(2));",
          "    let state_id3 = StateID(SmallIndex(3));",
          "",
          "    let remap = vec![state_id1, state_id2, state_id3];",
          "    ",
          "    let state = State::Union {",
          "        alternates: Box::new([state_id2, state_id3]),",
          "    };",
          "",
          "    let mut state = state;",
          "    state.remap(&remap);",
          "    assert_eq!(state, State::Union { alternates: Box::new([state_id2, state_id3]) });",
          "    assert_eq!(state.remap(&remap), ());",
          "    assert_eq!(state_id2, remap[state_id2]);",
          "    assert_eq!(state_id3, remap[state_id3]);",
          "    assert_eq!(state.remap(&remap).next, remap[state_id2]);",
          "    assert_eq!(state.remap(&remap).next, remap[state_id3]);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id1 = StateID(SmallIndex(1));",
          "    let state_id2 = StateID(SmallIndex(2));",
          "",
          "    let remap = vec![state_id1, state_id2];",
          "    ",
          "    let state = State::Union {",
          "        alternates: Box::new([state_id1]),",
          "    };",
          "",
          "    let mut state = state;",
          "    state.remap(&remap);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state.alternates.len(), 1);",
          "    assert_eq!(state.alternates[0], state_id1);",
          "    assert_eq!(state.alternates[0], remap[0]);",
          "    assert_ne!(state.alternates[0], remap[1]);",
          "    assert_eq!(state.is_epsilon(), false);"
        ],
        "code": [
          "{",
          "    let state_id1 = StateID(SmallIndex(1));",
          "    let state_id2 = StateID(SmallIndex(2));",
          "",
          "    let remap = vec![state_id1, state_id2];",
          "    ",
          "    let state = State::Union {",
          "        alternates: Box::new([state_id1]),",
          "    };",
          "",
          "    let mut state = state;",
          "    state.remap(&remap);",
          "    assert_eq!(state.alternates.len(), 1);",
          "    assert_eq!(state.alternates[0], state_id1);",
          "    assert_eq!(state.alternates[0], remap[0]);",
          "    assert_ne!(state.alternates[0], remap[1]);",
          "    assert_eq!(state.is_epsilon(), false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state_id = StateID(SmallIndex(0));",
          "",
          "    let remap = vec![state_id];",
          "    ",
          "    let state = State::Union {",
          "        alternates: Box::new([state_id]),",
          "    };",
          "",
          "    let mut state = state;",
          "    state.remap(&remap);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(state, State::Union { alternates: Box::new([state_id]) });",
          "    assert_eq!(state.get_alternates_count(), 1);",
          "    assert!(state.is_epsilon());",
          "    assert!(state.remap(&remap).is_none());",
          "    assert_eq!(state.memory_usage(), expected_memory_usage);",
          "    assert!(state.contains_state(state_id));",
          "    assert!(matches!(state, State::Union { .. }));",
          "    assert_eq!(state.get_next_state(state_id), None);",
          "    assert!(state.is_complete());",
          "    assert!(state.has_transitions());"
        ],
        "code": [
          "{",
          "    let state_id = StateID(SmallIndex(0));",
          "",
          "    let remap = vec![state_id];",
          "    ",
          "    let state = State::Union {",
          "        alternates: Box::new([state_id]),",
          "    };",
          "",
          "    let mut state = state;",
          "    state.remap(&remap);",
          "    assert_eq!(state, State::Union { alternates: Box::new([state_id]) });",
          "    assert_eq!(state.get_alternates_count(), 1);",
          "    assert!(state.is_epsilon());",
          "    assert!(state.remap(&remap).is_none());",
          "    assert_eq!(state.memory_usage(), expected_memory_usage);",
          "    assert!(state.contains_state(state_id));",
          "    assert!(matches!(state, State::Union { .. }));",
          "    assert_eq!(state.get_next_state(state_id), None);",
          "    assert!(state.is_complete());",
          "    assert!(state.has_transitions());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]