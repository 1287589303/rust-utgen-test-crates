self.nfa.look_set_any().available().is_ok(), self.nfa.look_set_any().iter().count() == 0, self.nfa.pattern_len().as_u64() <= PatternEpsilons::PATTERN_ID_LIMIT, self.nfa.group_info().explicit_slot_len() <= Slots::LIMIT, self.add_empty_state().is_ok(), self.add_start_state(None, self.nfa.start_anchored()).is_ok(), self.config.get_starts_for_each_pattern() == false, self.uncompiled_nfa_ids.len() > 0, self.stack_push(nfa_id, Epsilons::empty()).is_ok(), self.stack.pop().is_some(), *self.nfa.state(id) == thompson::State::Match { pattern_id }, self.matched == false, self.stack.pop().is_some(), self.uncompiled_nfa_ids.len() > 0, expected_result == Ok(self.dfa)
