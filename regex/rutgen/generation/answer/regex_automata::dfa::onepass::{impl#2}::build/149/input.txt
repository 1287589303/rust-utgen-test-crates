self.nfa.look_set_any().available() == Ok && self.nfa.look_set_any().iter().is_empty() == true && self.nfa.pattern_len().as_u64() <= PatternEpsilons::PATTERN_ID_LIMIT && self.nfa.group_info().explicit_slot_len() <= Slots::LIMIT && self.add_empty_state() == Ok && self.add_start_state(None, self.nfa.start_anchored()) == Ok && self.config.get_starts_for_each_pattern() == false && self.uncompiled_nfa_ids.len() > 0 && self.stack_push(nfa_id, Epsilons::empty()) == Ok && self.stack.pop().is_some() && *self.nfa.state(id) matches thompson::State::Fail == true && let Some((id, epsilons)) = self.stack.pop() is true && let Some(nfa_id) = self.uncompiled_nfa_ids.pop() is true and result is Ok(self.dfa)
