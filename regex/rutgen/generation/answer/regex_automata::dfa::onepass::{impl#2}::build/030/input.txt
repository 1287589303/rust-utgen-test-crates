self.nfa.look_set_any().available() == Ok, look.as_repr() <= Look::WordUnicodeNegate.as_repr(), self.nfa.pattern_len().as_u64() <= PatternEpsilons::PATTERN_ID_LIMIT, self.nfa.group_info().explicit_slot_len() <= Slots::LIMIT, self.add_empty_state() == Ok, self.add_start_state(None, self.nfa.start_anchored()) == Ok, self.config.get_starts_for_each_pattern() == true, pid must be a valid pattern in self.nfa.patterns(), self.add_start_state(Some(pid), self.nfa.start_pattern(pid).unwrap()) == Ok, let Some(nfa_id) = self.uncompiled_nfa_ids.pop() should succeed, self.stack_push(nfa_id, Epsilons::empty()) == Ok, let Some((id, epsilons)) = self.stack.pop() should succeed, *self.nfa.state(id) must be of type Sparse and match with traversed states, trans in sparse.transitions.iter() should yield valid transitions, self.compile_transition(dfa_id, trans, epsilons) == Ok
