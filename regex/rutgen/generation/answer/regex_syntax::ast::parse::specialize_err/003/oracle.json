[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error_kind_from = ast::ErrorKind::ClassEscapeInvalid;",
          "    let error_kind_to = ast::ErrorKind::EscapeUnexpectedEof;",
          "    let error_span = ast::Span { start: Position { offset: 0 }, end: Position { offset: 5 } };",
          "    let error_pattern = String::from(\"Invalid escape in class\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::GroupNameEmpty, pattern: error_pattern, span: error_span });",
          "",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupNameEmpty);"
        ],
        "code": [
          "{",
          "    let error_kind_from = ast::ErrorKind::ClassEscapeInvalid;",
          "    let error_kind_to = ast::ErrorKind::EscapeUnexpectedEof;",
          "    let error_span = ast::Span { start: Position { offset: 0 }, end: Position { offset: 5 } };",
          "    let error_pattern = String::from(\"Invalid escape in class\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::GroupNameEmpty, pattern: error_pattern, span: error_span });",
          "",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::GroupNameEmpty);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error_kind_from = ast::ErrorKind::FlagUnrecognized;",
          "    let error_kind_to = ast::ErrorKind::CaptureLimitExceeded;",
          "    let error_span = ast::Span { start: Position { offset: 10 }, end: Position { offset: 15 } };",
          "    let error_pattern = String::from(\"Unrecognized flag encountered\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::FlagDanglingNegation, pattern: error_pattern, span: error_span });",
          "",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "}"
        ],
        "oracle": [
          "    let error_kind_from = ast::ErrorKind::FlagUnrecognized;",
          "    let error_kind_to = ast::ErrorKind::CaptureLimitExceeded;",
          "    let error_span = ast::Span { start: Position { offset: 10 }, end: Position { offset: 15 } };",
          "    let error_pattern = String::from(\"Unrecognized flag encountered\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::FlagDanglingNegation, pattern: error_pattern, span: error_span });",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::FlagDanglingNegation);"
        ],
        "code": [
          "{",
          "    let error_kind_from = ast::ErrorKind::FlagUnrecognized;",
          "    let error_kind_to = ast::ErrorKind::CaptureLimitExceeded;",
          "    let error_span = ast::Span { start: Position { offset: 10 }, end: Position { offset: 15 } };",
          "    let error_pattern = String::from(\"Unrecognized flag encountered\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::FlagDanglingNegation, pattern: error_pattern, span: error_span });",
          "",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "    let error_kind_from = ast::ErrorKind::FlagUnrecognized;",
          "    let error_kind_to = ast::ErrorKind::CaptureLimitExceeded;",
          "    let error_span = ast::Span { start: Position { offset: 10 }, end: Position { offset: 15 } };",
          "    let error_pattern = String::from(\"Unrecognized flag encountered\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::FlagDanglingNegation, pattern: error_pattern, span: error_span });",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::FlagDanglingNegation);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let error_kind_from = ast::ErrorKind::DecimalEmpty;",
          "    let error_kind_to = ast::ErrorKind::RepetitionCountInvalid;",
          "    let error_span = ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } };",
          "    let error_pattern = String::from(\"Decimal number expected but found empty\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::GroupNameInvalid, pattern: error_pattern, span: error_span });",
          "",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "}"
        ],
        "oracle": [
          "    Err(ast::Error { kind: ast::ErrorKind::GroupNameInvalid, pattern: String::from(\"Decimal number expected but found empty\"), span: ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } } }) == result",
          "    result.is_err() == true",
          "    result.unwrap_err().kind == ast::ErrorKind::GroupNameInvalid",
          "    result.unwrap_err().pattern == String::from(\"Decimal number expected but found empty\")",
          "    result.unwrap_err().span == ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } }",
          "    result.unwrap_err() != Err(ast::Error { kind: ast::ErrorKind::RepetitionCountInvalid, pattern: String::from(\"Decimal number expected but found empty\"), span: ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } } })"
        ],
        "code": [
          "{",
          "    let error_kind_from = ast::ErrorKind::DecimalEmpty;",
          "    let error_kind_to = ast::ErrorKind::RepetitionCountInvalid;",
          "    let error_span = ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } };",
          "    let error_pattern = String::from(\"Decimal number expected but found empty\");",
          "    let error = Err(ast::Error { kind: ast::ErrorKind::GroupNameInvalid, pattern: error_pattern, span: error_span });",
          "",
          "    let result: Result<()> = specialize_err(error, error_kind_from, error_kind_to);",
          "    Err(ast::Error { kind: ast::ErrorKind::GroupNameInvalid, pattern: String::from(\"Decimal number expected but found empty\"), span: ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } } }) == result",
          "    result.is_err() == true",
          "    result.unwrap_err().kind == ast::ErrorKind::GroupNameInvalid",
          "    result.unwrap_err().pattern == String::from(\"Decimal number expected but found empty\")",
          "    result.unwrap_err().span == ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } }",
          "    result.unwrap_err() != Err(ast::Error { kind: ast::ErrorKind::RepetitionCountInvalid, pattern: String::from(\"Decimal number expected but found empty\"), span: ast::Span { start: Position { offset: 20 }, end: Position { offset: 25 } } })",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]