[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "    ",
          "    let empty_bracketed = ast::ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ast::ClassSet::Item(ast::ClassSetItem::Empty(Span::default())),",
          "    };",
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(empty_bracketed)));",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracle": [
          "    visitor.induct_class(&ClassInduct::Item(&ClassSetItem::Union(Box::new(ClassSetUnion { span: Span::default(), items: vec![] }))));",
          "    visitor.induct_class(&ClassInduct::BinaryOp(&ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span::default()))) }));"
        ],
        "code": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "    ",
          "    let empty_bracketed = ast::ClassBracketed {",
          "        span: Span::default(),",
          "        negated: false,",
          "        kind: ast::ClassSet::Item(ast::ClassSetItem::Empty(Span::default())),",
          "    };",
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(empty_bracketed)));",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "    visitor.induct_class(&ClassInduct::Item(&ClassSetItem::Union(Box::new(ClassSetUnion { span: Span::default(), items: vec![] }))));",
          "    visitor.induct_class(&ClassInduct::BinaryOp(&ClassSetBinaryOp { span: Span::default(), kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))), rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span::default()))) }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "    ",
          "    let class_item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
          "    let union_set = ast::ClassSetUnion {",
          "        span: Span::default(),",
          "        items: vec![class_item],",
          "    };",
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Union(Box::new(union_set)));",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracle": [
          "    visitor.induct_class(&induct); // assert that the result is None for ClassInduct::Item(&ast::ClassSetItem::Union(ref x))",
          "    assert_eq!(visitor.induct_class(&induct), None); // expected return value is None",
          "    let induct = ClassInduct::BinaryOp(&ClassSetBinaryOp { /* fields */ });",
          "    assert_eq!(visitor.induct_class(&induct), None); // assert that the result is None for ClassInduct::BinaryOp(op)"
        ],
        "code": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "    ",
          "    let class_item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
          "    let union_set = ast::ClassSetUnion {",
          "        span: Span::default(),",
          "        items: vec![class_item],",
          "    };",
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Union(Box::new(union_set)));",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "    visitor.induct_class(&induct); // assert that the result is None for ClassInduct::Item(&ast::ClassSetItem::Union(ref x))",
          "    assert_eq!(visitor.induct_class(&induct), None); // expected return value is None",
          "    let induct = ClassInduct::BinaryOp(&ClassSetBinaryOp { /* fields */ });",
          "    assert_eq!(visitor.induct_class(&induct), None); // assert that the result is None for ClassInduct::BinaryOp(op)",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "",
          "    let binary_op = ClassSetBinaryOp {",
          "        span: Span::default(),",
          "        kind: ClassSetBinaryOpKind::And,",
          "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))),",
          "        rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span::default()))),",
          "    };",
          "    let induct = ClassInduct::BinaryOp(&binary_op);",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(visitor.induct_class(&induct), None);"
        ],
        "code": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "",
          "    let binary_op = ClassSetBinaryOp {",
          "        span: Span::default(),",
          "        kind: ClassSetBinaryOpKind::And,",
          "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::default()))),",
          "        rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span::default()))),",
          "    };",
          "    let induct = ClassInduct::BinaryOp(&binary_op);",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "    assert_eq!(visitor.induct_class(&induct), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "",
          "    let other_item = ClassSet::Item(ClassSetItem::Ascii(ClassAscii { /* fields */ }));",
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ }));",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "}"
        ],
        "oracle": [
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
          "    assert_eq!(visitor.induct_class(&induct), None);",
          "    ",
          "    let induct = ClassInduct::BinaryOp(&ClassSetBinaryOp { lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* fields */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* fields */ }))), kind: ClassSetBinaryOpKind::And, span: Span::default() });",
          "    assert_eq!(visitor.induct_class(&induct), None);"
        ],
        "code": [
          "{",
          "    struct DummyAst;",
          "    impl Ast for DummyAst { /* implementation details */ }",
          "",
          "    let other_item = ClassSet::Item(ClassSetItem::Ascii(ClassAscii { /* fields */ }));",
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ }));",
          "    let visitor = HeapVisitor::new();",
          "",
          "    visitor.induct_class(&induct);",
          "    let induct = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
          "    assert_eq!(visitor.induct_class(&induct), None);",
          "    ",
          "    let induct = ClassInduct::BinaryOp(&ClassSetBinaryOp { lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* fields */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* fields */ }))), kind: ClassSetBinaryOpKind::And, span: Span::default() });",
          "    assert_eq!(visitor.induct_class(&induct), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]