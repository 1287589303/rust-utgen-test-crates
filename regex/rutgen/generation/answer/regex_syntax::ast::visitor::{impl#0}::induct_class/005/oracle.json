[
  {
    "uses": [
      "use crate::ast::ClassInduct;",
      "use crate::ast::ClassFrame;",
      "use crate::ast::ClassSetUnion;",
      "use alloc::vec;",
      "use crate::ast::ClassSetItem;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use crate::ast::{ClassSetItem, ClassSetUnion, ClassInduct, ClassFrame};",
          "    use alloc::vec;",
          "",
          "    let item1 = ClassSetItem::Literal(Literal::new(\"a\"));",
          "    let item2 = ClassSetItem::Literal(Literal::new(\"b\"));",
          "    let items = vec![item1.clone(), item2.clone()];",
          "",
          "    let class_set_union = ClassSetUnion {",
          "        span: Span::new(0, 1),",
          "        items,",
          "    };",
          "",
          "    let class_set_item = ClassSetItem::Union(class_set_union);",
          "    let class_induct = ClassInduct::Item(&class_set_item);",
          "",
          "    let frame = HeapVisitor::new().induct_class(&class_induct);",
          "",
          "    // Exit the function without assertion",
          "}"
        ],
        "oracle": [
          "    assert_eq!(frame, Some(ClassFrame::Union { head: &item1, tail: &[item2] }));"
        ],
        "code": [
          "{",
          "    use crate::ast::{ClassSetItem, ClassSetUnion, ClassInduct, ClassFrame};",
          "    use alloc::vec;",
          "",
          "    let item1 = ClassSetItem::Literal(Literal::new(\"a\"));",
          "    let item2 = ClassSetItem::Literal(Literal::new(\"b\"));",
          "    let items = vec![item1.clone(), item2.clone()];",
          "",
          "    let class_set_union = ClassSetUnion {",
          "        span: Span::new(0, 1),",
          "        items,",
          "    };",
          "",
          "    let class_set_item = ClassSetItem::Union(class_set_union);",
          "    let class_induct = ClassInduct::Item(&class_set_item);",
          "",
          "    let frame = HeapVisitor::new().induct_class(&class_induct);",
          "",
          "    // Exit the function without assertion",
          "    assert_eq!(frame, Some(ClassFrame::Union { head: &item1, tail: &[item2] }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]