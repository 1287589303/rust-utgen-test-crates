[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal {}));",
          "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal {}));",
          "    ",
          "    let op = ClassSetBinaryOp {",
          "        span: Span {},",
          "        kind: ClassSetBinaryOpKind::And,",
          "        lhs: Box::new(lhs),",
          "        rhs: Box::new(rhs),",
          "    };",
          "",
          "    let ast = ClassInduct::BinaryOp(&op);",
          "    let mut visitor = HeapVisitor::new();",
          "    ",
          "    let result = visitor.induct_class(&ast);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(result, Some(ClassFrame::BinaryLHS { op: &op, lhs: &op.lhs, rhs: &op.rhs }));"
        ],
        "code": [
          "{",
          "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal {}));",
          "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal {}));",
          "    ",
          "    let op = ClassSetBinaryOp {",
          "        span: Span {},",
          "        kind: ClassSetBinaryOpKind::And,",
          "        lhs: Box::new(lhs),",
          "        rhs: Box::new(rhs),",
          "    };",
          "",
          "    let ast = ClassInduct::BinaryOp(&op);",
          "    let mut visitor = HeapVisitor::new();",
          "    ",
          "    let result = visitor.induct_class(&ast);",
          "    assert_eq!(result, Some(ClassFrame::BinaryLHS { op: &op, lhs: &op.lhs, rhs: &op.rhs }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal {}));",
          "    let rhs = ClassSet::Item(ClassSetItem::Empty(Span {}));",
          "    ",
          "    let op = ClassSetBinaryOp {",
          "        span: Span {},",
          "        kind: ClassSetBinaryOpKind::And,",
          "        lhs: Box::new(lhs),",
          "        rhs: Box::new(rhs),",
          "    };",
          "",
          "    let ast = ClassInduct::BinaryOp(&op);",
          "    let mut visitor = HeapVisitor::new();",
          "    ",
          "    let result = visitor.induct_class(&ast);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_some());",
          "    if let Some(frame) = result {",
          "    match frame {",
          "    ClassFrame::BinaryLHS { op, lhs, rhs } => {",
          "    assert_eq!(op, &op);",
          "    assert_eq!(lhs, &op.lhs);",
          "    assert_eq!(rhs, &op.rhs);",
          "    },",
          "    _ => panic!(\"Expected ClassFrame::BinaryLHS\"),",
          "    }",
          "    }"
        ],
        "code": [
          "{",
          "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal {}));",
          "    let rhs = ClassSet::Item(ClassSetItem::Empty(Span {}));",
          "    ",
          "    let op = ClassSetBinaryOp {",
          "        span: Span {},",
          "        kind: ClassSetBinaryOpKind::And,",
          "        lhs: Box::new(lhs),",
          "        rhs: Box::new(rhs),",
          "    };",
          "",
          "    let ast = ClassInduct::BinaryOp(&op);",
          "    let mut visitor = HeapVisitor::new();",
          "    ",
          "    let result = visitor.induct_class(&ast);",
          "    assert!(result.is_some());",
          "    if let Some(frame) = result {",
          "    match frame {",
          "    ClassFrame::BinaryLHS { op, lhs, rhs } => {",
          "    assert_eq!(op, &op);",
          "    assert_eq!(lhs, &op.lhs);",
          "    assert_eq!(rhs, &op.rhs);",
          "    },",
          "    _ => panic!(\"Expected ClassFrame::BinaryLHS\"),",
          "    }",
          "    }",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]