[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![65..=65])); // ASCII 'A'",
          "    let _result = class.literal();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Some(vec![65]));",
          "    let class_empty = Class::Bytes(ClassBytes::empty());",
          "    let _result_empty = class_empty.literal();",
          "    assert_eq!(_result_empty, None);",
          "    let class_multiple = Class::Bytes(ClassBytes::new(vec![65..=67])); // ASCII 'A', 'B', 'C'",
          "    let _result_multiple = class_multiple.literal();",
          "    assert_eq!(_result_multiple, None);",
          "    let class_exactly_one = Class::Bytes(ClassBytes::new(vec![255..=255])); // single byte 255",
          "    let _result_exactly_one = class_exactly_one.literal();",
          "    assert_eq!(_result_exactly_one, Some(vec![255]));"
        ],
        "code": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![65..=65])); // ASCII 'A'",
          "    let _result = class.literal();",
          "    assert_eq!(_result, Some(vec![65]));",
          "    let class_empty = Class::Bytes(ClassBytes::empty());",
          "    let _result_empty = class_empty.literal();",
          "    assert_eq!(_result_empty, None);",
          "    let class_multiple = Class::Bytes(ClassBytes::new(vec![65..=67])); // ASCII 'A', 'B', 'C'",
          "    let _result_multiple = class_multiple.literal();",
          "    assert_eq!(_result_multiple, None);",
          "    let class_exactly_one = Class::Bytes(ClassBytes::new(vec![255..=255])); // single byte 255",
          "    let _result_exactly_one = class_exactly_one.literal();",
          "    assert_eq!(_result_exactly_one, Some(vec![255]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![0..=0])); // Byte 0",
          "    let _result = class.literal();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Some(vec![0]));"
        ],
        "code": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![0..=0])); // Byte 0",
          "    let _result = class.literal();",
          "    assert_eq!(_result, Some(vec![0]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![255..=255])); // Byte 255",
          "    let _result = class.literal();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_result, Some(vec![255]));",
          "    let class = Class::Bytes(ClassBytes::new(vec![0..=0])); // Byte 0",
          "    assert_eq!(_result, Some(vec![0]));",
          "    let class = Class::Bytes(ClassBytes::new(vec![1..=1])); // Byte 1",
          "    assert_eq!(_result, Some(vec![1]));",
          "    let class = Class::Bytes(ClassBytes::new(vec![1..=2])); // Multiple bytes",
          "    assert_eq!(_result, None);",
          "    let class = Class::Bytes(ClassBytes::empty()); // Empty class",
          "    assert_eq!(_result, None);"
        ],
        "code": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![255..=255])); // Byte 255",
          "    let _result = class.literal();",
          "    assert_eq!(_result, Some(vec![255]));",
          "    let class = Class::Bytes(ClassBytes::new(vec![0..=0])); // Byte 0",
          "    assert_eq!(_result, Some(vec![0]));",
          "    let class = Class::Bytes(ClassBytes::new(vec![1..=1])); // Byte 1",
          "    assert_eq!(_result, Some(vec![1]));",
          "    let class = Class::Bytes(ClassBytes::new(vec![1..=2])); // Multiple bytes",
          "    assert_eq!(_result, None);",
          "    let class = Class::Bytes(ClassBytes::empty()); // Empty class",
          "    assert_eq!(_result, None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class::Bytes(ClassBytes::empty());",
          "    let _result = class.literal();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class.literal(), None);"
        ],
        "code": [
          "{",
          "    let class = Class::Bytes(ClassBytes::empty());",
          "    let _result = class.literal();",
          "    assert_eq!(class.literal(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![65..=65, 66..=66])); // Bytes 'A' and 'B'",
          "    let _result = class.literal();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(class.literal(), None);"
        ],
        "code": [
          "{",
          "    let class = Class::Bytes(ClassBytes::new(vec![65..=65, 66..=66])); // Bytes 'A' and 'B'",
          "    let _result = class.literal();",
          "    assert_eq!(class.literal(), None);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]