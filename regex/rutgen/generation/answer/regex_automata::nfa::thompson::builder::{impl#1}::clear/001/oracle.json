[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder {",
          "        pattern_id: Some(PatternID::default()),",
          "        states: vec![State { transitions: vec![] }],",
          "        start_pattern: vec![StateID(SmallIndex::default())],",
          "        captures: vec![vec![Some(Arc::new(\"capture\".to_string()))]],",
          "        memory_states: 10,",
          "        utf8: true,",
          "        reverse: false,",
          "        look_matcher: LookMatcher { lineterm: Default::default() },",
          "        size_limit: Some(100),",
          "        ..Default::default()",
          "    };",
          "",
          "    builder.clear();",
          "}"
        ],
        "oracle": [
          "    assert!(builder.pattern_id.is_none());",
          "    assert!(builder.states.is_empty());",
          "    assert!(builder.start_pattern.is_empty());",
          "    assert!(builder.captures.is_empty());",
          "    assert_eq!(builder.memory_states, 0);",
          "    assert_eq!(builder.utf8, true);",
          "    assert_eq!(builder.reverse, false);",
          "    assert!(builder.size_limit == Some(100));"
        ],
        "code": [
          "{",
          "    let mut builder = Builder {",
          "        pattern_id: Some(PatternID::default()),",
          "        states: vec![State { transitions: vec![] }],",
          "        start_pattern: vec![StateID(SmallIndex::default())],",
          "        captures: vec![vec![Some(Arc::new(\"capture\".to_string()))]],",
          "        memory_states: 10,",
          "        utf8: true,",
          "        reverse: false,",
          "        look_matcher: LookMatcher { lineterm: Default::default() },",
          "        size_limit: Some(100),",
          "        ..Default::default()",
          "    };",
          "",
          "    builder.clear();",
          "    assert!(builder.pattern_id.is_none());",
          "    assert!(builder.states.is_empty());",
          "    assert!(builder.start_pattern.is_empty());",
          "    assert!(builder.captures.is_empty());",
          "    assert_eq!(builder.memory_states, 0);",
          "    assert_eq!(builder.utf8, true);",
          "    assert_eq!(builder.reverse, false);",
          "    assert!(builder.size_limit == Some(100));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut builder = Builder::new();",
          "",
          "    builder.clear();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(builder.pattern_id, None);",
          "    assert!(builder.states.is_empty());",
          "    assert!(builder.start_pattern.is_empty());",
          "    assert!(builder.captures.is_empty());",
          "    assert_eq!(builder.memory_states, 0);"
        ],
        "code": [
          "{",
          "    let mut builder = Builder::new();",
          "",
          "    builder.clear();",
          "    assert_eq!(builder.pattern_id, None);",
          "    assert!(builder.states.is_empty());",
          "    assert!(builder.start_pattern.is_empty());",
          "    assert!(builder.captures.is_empty());",
          "    assert_eq!(builder.memory_states, 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]