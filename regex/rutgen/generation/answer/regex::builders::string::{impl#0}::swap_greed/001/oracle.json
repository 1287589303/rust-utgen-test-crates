[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = RegexBuilder::new(r\"a+\")",
          "        .swap_greed(true)",
          "        .build()",
          "        .unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.swap_greed(true), &re);",
          "    assert_eq!(re.swap_greed(false), &re);",
          "    let re_greedy = RegexBuilder::new(r\"a+\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"aaa\"), re_greedy.find(\"aaa\").map(|m| m.as_str()));",
          "    let re_non_greedy = RegexBuilder::new(r\"a+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"a\"), re_non_greedy.find(\"aaa\").map(|m| m.as_str()));"
        ],
        "code": [
          "{",
          "    let re = RegexBuilder::new(r\"a+\")",
          "        .swap_greed(true)",
          "        .build()",
          "        .unwrap();",
          "    assert_eq!(re.swap_greed(true), &re);",
          "    assert_eq!(re.swap_greed(false), &re);",
          "    let re_greedy = RegexBuilder::new(r\"a+\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"aaa\"), re_greedy.find(\"aaa\").map(|m| m.as_str()));",
          "    let re_non_greedy = RegexBuilder::new(r\"a+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"a\"), re_non_greedy.find(\"aaa\").map(|m| m.as_str()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = RegexBuilder::new(r\"a+\")",
          "        .swap_greed(false)",
          "        .build()",
          "        .unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(\"aaa\").map(|m| m.as_str()), Some(\"aaa\"));",
          "    let re_non_greedy = RegexBuilder::new(r\"a+\")",
          "    .swap_greed(true)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_non_greedy.find(\"aaa\").map(|m| m.as_str()), Some(\"a\"));",
          "    let re_empty = RegexBuilder::new(r\"a+\")",
          "    .swap_greed(false)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_empty.find(\"\").map(|m| m.as_str()), None);",
          "    let re_multiple = RegexBuilder::new(r\"b+\")",
          "    .swap_greed(false)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_multiple.find(\"bbb\").map(|m| m.as_str()), Some(\"bbb\"));",
          "    let re_non_greedy_multiple = RegexBuilder::new(r\"b+\")",
          "    .swap_greed(true)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_non_greedy_multiple.find(\"bbb\").map(|m| m.as_str()), Some(\"b\"));"
        ],
        "code": [
          "{",
          "    let re = RegexBuilder::new(r\"a+\")",
          "        .swap_greed(false)",
          "        .build()",
          "        .unwrap();",
          "    assert_eq!(re.find(\"aaa\").map(|m| m.as_str()), Some(\"aaa\"));",
          "    let re_non_greedy = RegexBuilder::new(r\"a+\")",
          "    .swap_greed(true)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_non_greedy.find(\"aaa\").map(|m| m.as_str()), Some(\"a\"));",
          "    let re_empty = RegexBuilder::new(r\"a+\")",
          "    .swap_greed(false)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_empty.find(\"\").map(|m| m.as_str()), None);",
          "    let re_multiple = RegexBuilder::new(r\"b+\")",
          "    .swap_greed(false)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_multiple.find(\"bbb\").map(|m| m.as_str()), Some(\"bbb\"));",
          "    let re_non_greedy_multiple = RegexBuilder::new(r\"b+\")",
          "    .swap_greed(true)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_non_greedy_multiple.find(\"bbb\").map(|m| m.as_str()), Some(\"b\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = RegexBuilder::new(r\"\")",
          "        .swap_greed(true)",
          "        .build()",
          "        .unwrap();",
          "}"
        ],
        "oracle": [
          "    let re = RegexBuilder::new(r\"a+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"a\"), re.find(\"aaa\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"a+?\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"aa\"), re.find(\"aaaa\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"b+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"b\"), re.find(\"bbb\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"c+?\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"cc\"), re.find(\"cccc\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\".+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"xxxx\"), re.find(\"xxxx\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"x+?\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"xx\"), re.find(\"xxxxx\").map(|m| m.as_str()));"
        ],
        "code": [
          "{",
          "    let re = RegexBuilder::new(r\"\")",
          "        .swap_greed(true)",
          "        .build()",
          "        .unwrap();",
          "    let re = RegexBuilder::new(r\"a+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"a\"), re.find(\"aaa\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"a+?\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"aa\"), re.find(\"aaaa\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"b+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"b\"), re.find(\"bbb\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"c+?\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"cc\"), re.find(\"cccc\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\".+\").swap_greed(true).build().unwrap();",
          "    assert_eq!(Some(\"xxxx\"), re.find(\"xxxx\").map(|m| m.as_str()));",
          "    let re = RegexBuilder::new(r\"x+?\").swap_greed(false).build().unwrap();",
          "    assert_eq!(Some(\"xx\"), re.find(\"xxxxx\").map(|m| m.as_str()));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = RegexBuilder::new(r\"[a-z]+\")",
          "        .swap_greed(false)",
          "        .build()",
          "        .unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(\"aaa\").map(|m| m.as_str()), Some(\"aaa\"));",
          "    let re_greedy = RegexBuilder::new(r\"[a-z]+\")",
          "    .swap_greed(true)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_greedy.find(\"aaa\").map(|m| m.as_str()), Some(\"a\"));",
          "    assert_eq!(re_greedy.find(\"abba\").map(|m| m.as_str()), Some(\"a\"));",
          "    let re_no_match = RegexBuilder::new(r\"[0-9]+\")",
          "    .swap_greed(false)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_no_match.find(\"aaa\"), None);",
          "    assert!(re_no_match.swap_greed(true).is_instance_of::<RegexBuilder>());",
          "    assert!(re.swap_greed(false).is_instance_of::<RegexBuilder>());",
          "    assert!(re_greedy.swap_greed(true).is_instance_of::<RegexBuilder>());"
        ],
        "code": [
          "{",
          "    let re = RegexBuilder::new(r\"[a-z]+\")",
          "        .swap_greed(false)",
          "        .build()",
          "        .unwrap();",
          "    assert_eq!(re.find(\"aaa\").map(|m| m.as_str()), Some(\"aaa\"));",
          "    let re_greedy = RegexBuilder::new(r\"[a-z]+\")",
          "    .swap_greed(true)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_greedy.find(\"aaa\").map(|m| m.as_str()), Some(\"a\"));",
          "    assert_eq!(re_greedy.find(\"abba\").map(|m| m.as_str()), Some(\"a\"));",
          "    let re_no_match = RegexBuilder::new(r\"[0-9]+\")",
          "    .swap_greed(false)",
          "    .build()",
          "    .unwrap();",
          "    assert_eq!(re_no_match.find(\"aaa\"), None);",
          "    assert!(re_no_match.swap_greed(true).is_instance_of::<RegexBuilder>());",
          "    assert!(re.swap_greed(false).is_instance_of::<RegexBuilder>());",
          "    assert!(re_greedy.swap_greed(true).is_instance_of::<RegexBuilder>());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let re = RegexBuilder::new(r\"(a+|b+){1,2}\")",
          "        .swap_greed(true)",
          "        .build()",
          "        .unwrap();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(re.find(\"aa\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bb\").map(|m| m.as_str()), Some(\"bb\"));",
          "    assert_eq!(re.find(\"ab\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"aaa\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bba\").map(|m| m.as_str()), Some(\"b\"));",
          "    assert_eq!(re.find(\"aab\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"aabab\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"aababba\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bab\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"aaaab\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bbaaa\").map(|m| m.as_str()), Some(\"b\"));",
          "    assert_eq!(re.find(\"aaabb\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"abab\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"b\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"a\").map(|m| m.as_str()), Some(\"a\"));"
        ],
        "code": [
          "{",
          "    let re = RegexBuilder::new(r\"(a+|b+){1,2}\")",
          "        .swap_greed(true)",
          "        .build()",
          "        .unwrap();",
          "    assert_eq!(re.find(\"aa\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bb\").map(|m| m.as_str()), Some(\"bb\"));",
          "    assert_eq!(re.find(\"ab\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"aaa\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bba\").map(|m| m.as_str()), Some(\"b\"));",
          "    assert_eq!(re.find(\"aab\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"aabab\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"aababba\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bab\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"aaaab\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"bbaaa\").map(|m| m.as_str()), Some(\"b\"));",
          "    assert_eq!(re.find(\"aaabb\").map(|m| m.as_str()), Some(\"aa\"));",
          "    assert_eq!(re.find(\"abab\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"b\").map(|m| m.as_str()), None);",
          "    assert_eq!(re.find(\"a\").map(|m| m.as_str()), Some(\"a\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]