[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { size_limit: None };",
          "    let pattern = String::from(\"a*\");",
          "    let compiler = Compiler::new(config, pattern);",
          "",
          "    let sub_capture = Hir::capture(Capture {",
          "        index: 0,",
          "        name: Some(Box::from(\"capture\")),",
          "        sub: Box::new(Hir::char('a')),",
          "    });",
          "",
          "    let repetition = Hir::repetition(Repetition {",
          "        min: 0,",
          "        max: Some(10),",
          "        greedy: true,",
          "        sub: Box::new(sub_capture),",
          "    });",
          "",
          "    let result = compiler.c(&repetition);",
          "}"
        ],
        "oracle": [
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start_state);",
          "    assert_eq!(thompson_ref.end, expected_end_state);",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() >= 1);",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"capture\")));"
        ],
        "code": [
          "{",
          "    let config = Config { size_limit: None };",
          "    let pattern = String::from(\"a*\");",
          "    let compiler = Compiler::new(config, pattern);",
          "",
          "    let sub_capture = Hir::capture(Capture {",
          "        index: 0,",
          "        name: Some(Box::from(\"capture\")),",
          "        sub: Box::new(Hir::char('a')),",
          "    });",
          "",
          "    let repetition = Hir::repetition(Repetition {",
          "        min: 0,",
          "        max: Some(10),",
          "        greedy: true,",
          "        sub: Box::new(sub_capture),",
          "    });",
          "",
          "    let result = compiler.c(&repetition);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start_state);",
          "    assert_eq!(thompson_ref.end, expected_end_state);",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() >= 1);",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"capture\")));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { size_limit: None };",
          "    let pattern = String::from(\"a*?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "",
          "    let sub_capture = Hir::capture(Capture {",
          "        index: 1,",
          "        name: Some(Box::from(\"capture1\")),",
          "        sub: Box::new(Hir::char('a')),",
          "    });",
          "",
          "    let repetition = Hir::repetition(Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: false,",
          "        sub: Box::new(sub_capture),",
          "    });",
          "",
          "    let result = compiler.c(&repetition);",
          "}"
        ],
        "oracle": [
          "    let config = Config { size_limit: None };",
          "    let pattern = String::from(\"a*?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    let sub_capture = Hir::capture(Capture { index: 1, name: Some(Box::from(\"capture1\")), sub: Box::new(Hir::char('a')), });",
          "    let repetition = Hir::repetition(Repetition { min: 0, max: None, greedy: false, sub: Box::new(sub_capture), });",
          "    let result = compiler.c(&repetition);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start_id);",
          "    assert_eq!(thompson_ref.end, expected_end_id);",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() > 0);",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"capture1\")));",
          "    assert!(thompson_ref.start != thompson_ref.end);"
        ],
        "code": [
          "{",
          "    let config = Config { size_limit: None };",
          "    let pattern = String::from(\"a*?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "",
          "    let sub_capture = Hir::capture(Capture {",
          "        index: 1,",
          "        name: Some(Box::from(\"capture1\")),",
          "        sub: Box::new(Hir::char('a')),",
          "    });",
          "",
          "    let repetition = Hir::repetition(Repetition {",
          "        min: 0,",
          "        max: None,",
          "        greedy: false,",
          "        sub: Box::new(sub_capture),",
          "    });",
          "",
          "    let result = compiler.c(&repetition);",
          "    let config = Config { size_limit: None };",
          "    let pattern = String::from(\"a*?\");",
          "    let compiler = Compiler::new(config, pattern);",
          "    let sub_capture = Hir::capture(Capture { index: 1, name: Some(Box::from(\"capture1\")), sub: Box::new(Hir::char('a')), });",
          "    let repetition = Hir::repetition(Repetition { min: 0, max: None, greedy: false, sub: Box::new(sub_capture), });",
          "    let result = compiler.c(&repetition);",
          "    assert!(result.is_ok());",
          "    let thompson_ref = result.unwrap();",
          "    assert_eq!(thompson_ref.start, expected_start_id);",
          "    assert_eq!(thompson_ref.end, expected_end_id);",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() > 0);",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.contains_key(&Arc::from(\"capture1\")));",
          "    assert!(thompson_ref.start != thompson_ref.end);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]