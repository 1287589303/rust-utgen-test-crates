[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let empty_hir = Hir::empty();",
          "    let alternation_hir = Hir::alternation(vec![empty_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "}"
        ],
        "oracle": [
          "    result = compiler.c(&alternation_hir);",
          "    assert!(result.is_ok());",
          "    ",
          "    let nfa = result.unwrap();",
          "    assert_eq!(nfa.pattern, \"pattern\");",
          "    assert!(nfa.is_start_anchored);",
          "    assert!(nfa.is_match_empty);",
          "    assert_eq!(nfa.cap_name_to_index.len(), 0);",
          "    assert_eq!(nfa.cap_index_to_name.len(), 0);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let empty_hir = Hir::empty();",
          "    let alternation_hir = Hir::alternation(vec![empty_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "    result = compiler.c(&alternation_hir);",
          "    assert!(result.is_ok());",
          "    ",
          "    let nfa = result.unwrap();",
          "    assert_eq!(nfa.pattern, \"pattern\");",
          "    assert!(nfa.is_start_anchored);",
          "    assert!(nfa.is_match_empty);",
          "    assert_eq!(nfa.cap_name_to_index.len(), 0);",
          "    assert_eq!(nfa.cap_index_to_name.len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let char_hir = Hir::char('a');",
          "    let alternation_hir = Hir::alternation(vec![char_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(hir.kind(), &HirKind::Alternation(vec![Hir::char('a')]));",
          "    assert!(matches!(compiler.c(&alternation_hir), Ok(_)));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.is_empty());",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.is_empty());",
          "    assert_eq!(compiler.nfa.borrow().pattern, \"pattern\");",
          "    assert_eq!(compiler.nfa.borrow().is_match_empty, false);",
          "    assert!(compiler.nfa.borrow().is_start_anchored);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let char_hir = Hir::char('a');",
          "    let alternation_hir = Hir::alternation(vec![char_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "    assert_eq!(hir.kind(), &HirKind::Alternation(vec![Hir::char('a')]));",
          "    assert!(matches!(compiler.c(&alternation_hir), Ok(_)));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.is_empty());",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.is_empty());",
          "    assert_eq!(compiler.nfa.borrow().pattern, \"pattern\");",
          "    assert_eq!(compiler.nfa.borrow().is_match_empty, false);",
          "    assert!(compiler.nfa.borrow().is_start_anchored);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let char_hir_a = Hir::char('a');",
          "    let char_hir_b = Hir::char('b');",
          "    let class_hir = Hir::class(Class { ranges: vec![] });",
          "    let alternation_hir = Hir::alternation(vec![char_hir_a, char_hir_b, class_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "}"
        ],
        "oracle": [
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let char_hir_a = Hir::char('a');",
          "    let char_hir_b = Hir::char('b');",
          "    let class_hir = Hir::class(Class { ranges: vec![] });",
          "    let alternation_hir = Hir::alternation(vec![char_hir_a.clone(), char_hir_b.clone(), class_hir.clone()]);",
          "    let compiler = Compiler::new(config.clone(), String::from(\"pattern\"));",
          "    let result = compiler.c(&alternation_hir);",
          "    assert!(result.is_ok());",
          "    ",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start.is_valid_state());",
          "    assert!(thompson_ref.end.is_valid_state());",
          "    ",
          "    let nfa = compiler.nfa.borrow();",
          "    assert_eq!(nfa.cap_index_to_name.len(), 0);",
          "    assert_eq!(nfa.static_explicit_captures_len, None);",
          "    ",
          "    let alternation_subs = match alternation_hir.kind() {",
          "    HirKind::Alternation(ref subs) => subs,",
          "    _ => panic!(\"Expected HirKind::Alternation\"),",
          "    };",
          "    assert_eq!(alternation_subs.len(), 3);",
          "    assert!(alternation_subs.contains(&char_hir_a));",
          "    assert!(alternation_subs.contains(&char_hir_b));",
          "    assert!(alternation_subs.contains(&class_hir));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let char_hir_a = Hir::char('a');",
          "    let char_hir_b = Hir::char('b');",
          "    let class_hir = Hir::class(Class { ranges: vec![] });",
          "    let alternation_hir = Hir::alternation(vec![char_hir_a, char_hir_b, class_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let char_hir_a = Hir::char('a');",
          "    let char_hir_b = Hir::char('b');",
          "    let class_hir = Hir::class(Class { ranges: vec![] });",
          "    let alternation_hir = Hir::alternation(vec![char_hir_a.clone(), char_hir_b.clone(), class_hir.clone()]);",
          "    let compiler = Compiler::new(config.clone(), String::from(\"pattern\"));",
          "    let result = compiler.c(&alternation_hir);",
          "    assert!(result.is_ok());",
          "    ",
          "    let thompson_ref = result.unwrap();",
          "    assert!(thompson_ref.start.is_valid_state());",
          "    assert!(thompson_ref.end.is_valid_state());",
          "    ",
          "    let nfa = compiler.nfa.borrow();",
          "    assert_eq!(nfa.cap_index_to_name.len(), 0);",
          "    assert_eq!(nfa.static_explicit_captures_len, None);",
          "    ",
          "    let alternation_subs = match alternation_hir.kind() {",
          "    HirKind::Alternation(ref subs) => subs,",
          "    _ => panic!(\"Expected HirKind::Alternation\"),",
          "    };",
          "    assert_eq!(alternation_subs.len(), 3);",
          "    assert!(alternation_subs.contains(&char_hir_a));",
          "    assert!(alternation_subs.contains(&char_hir_b));",
          "    assert!(alternation_subs.contains(&class_hir));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let repetition_hir = Hir::repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir::char('c')) });",
          "    let alternation_hir = Hir::alternation(vec![Hir::char('a'), repetition_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(compiler.c(&alternation_hir), Ok(_)));",
          "    assert_eq!(alternation_hir.kind(), &HirKind::Alternation(vec![Hir::char('a'), repetition_hir]));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.is_empty());",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.is_empty());",
          "    assert!(compiler.nfa.borrow().memory_extra == 0);",
          "    assert!(compiler.nfa.borrow().is_match_empty == false);",
          "    assert!(compiler.nfa.borrow().is_start_anchored == false);",
          "    assert!(compiler.nfa.borrow().static_explicit_captures_len.is_none());",
          "    assert!(compiler.nfa.borrow().pattern == \"pattern\");",
          "    assert!(compiler.nfa.borrow().states.is_empty());",
          "    assert!(compiler.nfa.borrow().start == 0);"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let repetition_hir = Hir::repetition(Repetition { min: 1, max: Some(3), greedy: true, sub: Box::new(Hir::char('c')) });",
          "    let alternation_hir = Hir::alternation(vec![Hir::char('a'), repetition_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "    assert!(matches!(compiler.c(&alternation_hir), Ok(_)));",
          "    assert_eq!(alternation_hir.kind(), &HirKind::Alternation(vec![Hir::char('a'), repetition_hir]));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.is_empty());",
          "    assert!(compiler.nfa.borrow().cap_name_to_index.is_empty());",
          "    assert!(compiler.nfa.borrow().memory_extra == 0);",
          "    assert!(compiler.nfa.borrow().is_match_empty == false);",
          "    assert!(compiler.nfa.borrow().is_start_anchored == false);",
          "    assert!(compiler.nfa.borrow().static_explicit_captures_len.is_none());",
          "    assert!(compiler.nfa.borrow().pattern == \"pattern\");",
          "    assert!(compiler.nfa.borrow().states.is_empty());",
          "    assert!(compiler.nfa.borrow().start == 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let capture_hir = Hir::capture(Capture { index: 0, name: None, sub: Box::new(Hir::char('d')) });",
          "    let alternation_hir = Hir::alternation(vec![capture_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "}"
        ],
        "oracle": [
          "    assert_eq!(_is_ok, true);",
          "    assert!(matches!(_result, Ok(_)));",
          "    assert!(matches!(_result, Ok(ThompsonRef { start, end }) if start != end));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() > 0);",
          "    assert!(compiler.nfa.borrow().static_explicit_captures_len.is_some());",
          "    assert!(compiler.nfa.borrow().is_match_empty);",
          "    assert!(compiler.nfa.borrow().is_start_anchored);",
          "    assert!(capture_hir.is_match_empty());",
          "    assert!(capture_hir.static_explicit_captures_len().is_none());",
          "    assert_eq!(capture_hir.kind(), &HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::char('d')) }));",
          "    assert!(alternation_hir.kind() == &HirKind::Alternation(vec![capture_hir]));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let capture_hir = Hir::capture(Capture { index: 0, name: None, sub: Box::new(Hir::char('d')) });",
          "    let alternation_hir = Hir::alternation(vec![capture_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "    assert_eq!(_is_ok, true);",
          "    assert!(matches!(_result, Ok(_)));",
          "    assert!(matches!(_result, Ok(ThompsonRef { start, end }) if start != end));",
          "    assert!(compiler.nfa.borrow().cap_index_to_name.len() > 0);",
          "    assert!(compiler.nfa.borrow().static_explicit_captures_len.is_some());",
          "    assert!(compiler.nfa.borrow().is_match_empty);",
          "    assert!(compiler.nfa.borrow().is_start_anchored);",
          "    assert!(capture_hir.is_match_empty());",
          "    assert!(capture_hir.static_explicit_captures_len().is_none());",
          "    assert_eq!(capture_hir.kind(), &HirKind::Capture(Capture { index: 0, name: None, sub: Box::new(Hir::char('d')) }));",
          "    assert!(alternation_hir.kind() == &HirKind::Alternation(vec![capture_hir]));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let empty_hir = Hir::empty();",
          "    let char_hir = Hir::char('a');",
          "    let class_hir = Hir::class(Class { ranges: vec![] });",
          "    let look_hir = Hir::look(Look::Start);",
          "    let repetition_hir = Hir::repetition(Repetition { min: 1, max: None, greedy: false, sub: Box::new(Hir::char('b')) });",
          "    let alternation_hir = Hir::alternation(vec![empty_hir, char_hir, class_hir, look_hir, repetition_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "}"
        ],
        "oracle": [
          "    assert!(matches!(compiler.c(&alternation_hir), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::empty(), Hir::char('x')])), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::class(Class { ranges: vec![] }), Hir::look(Look::End)])), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::repetition(Repetition { min: 0, max: Some(1), greedy: true, sub: Box::new(Hir::char('c')) })])), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::capture(Capture { index: 0, name: None, sub: Box::new(Hir::char('d')) })])), Ok(_)));"
        ],
        "code": [
          "{",
          "    let config = Config { nest_limit: 10, flags: Flags::default() };",
          "    let empty_hir = Hir::empty();",
          "    let char_hir = Hir::char('a');",
          "    let class_hir = Hir::class(Class { ranges: vec![] });",
          "    let look_hir = Hir::look(Look::Start);",
          "    let repetition_hir = Hir::repetition(Repetition { min: 1, max: None, greedy: false, sub: Box::new(Hir::char('b')) });",
          "    let alternation_hir = Hir::alternation(vec![empty_hir, char_hir, class_hir, look_hir, repetition_hir]);",
          "    let compiler = Compiler::new(config, String::from(\"pattern\"));",
          "    let _ = compiler.c(&alternation_hir);",
          "    assert!(matches!(compiler.c(&alternation_hir), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::empty(), Hir::char('x')])), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::class(Class { ranges: vec![] }), Hir::look(Look::End)])), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::repetition(Repetition { min: 0, max: Some(1), greedy: true, sub: Box::new(Hir::char('c')) })])), Ok(_)));",
          "    assert!(matches!(compiler.c(&Hir::alternation(vec![Hir::capture(Capture { index: 0, name: None, sub: Box::new(Hir::char('d')) })])), Ok(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]