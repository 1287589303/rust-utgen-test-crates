[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = GroupInfo::empty();",
          "    let _ = info.explicit_slot_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(0, info.explicit_slot_len());",
          "    assert_eq!(0, info.slot_len());",
          "    assert_eq!(0, info.implicit_slot_len());"
        ],
        "code": [
          "{",
          "    let info = GroupInfo::empty();",
          "    let _ = info.explicit_slot_len();",
          "    assert_eq!(0, info.explicit_slot_len());",
          "    assert_eq!(0, info.slot_len());",
          "    assert_eq!(0, info.implicit_slot_len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = GroupInfo::new(vec![vec![None]]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(info.explicit_slot_len(), 0);",
          "    let info = GroupInfo::new(vec![vec![Some(\"foo\"), Some(\"bar\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 2);",
          "    let info = GroupInfo::new(vec![vec![None, Some(\"foo\"), None]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 1);",
          "    let info = GroupInfo::new(vec![vec![Some(\"a\"), Some(\"b\")], vec![Some(\"c\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 4);",
          "    let info = GroupInfo::new(vec![vec![], vec![]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 0);",
          "    let empty_info = GroupInfo::empty();",
          "    assert_eq!(empty_info.explicit_slot_len(), 0);",
          "    let info = GroupInfo::new(vec![vec![Some(\"a\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 2);",
          "    let info = GroupInfo::new(vec![vec![Some(\"x\"), None, Some(\"y\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 2);"
        ],
        "code": [
          "{",
          "    let info = GroupInfo::new(vec![vec![None]]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "    assert_eq!(info.explicit_slot_len(), 0);",
          "    let info = GroupInfo::new(vec![vec![Some(\"foo\"), Some(\"bar\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 2);",
          "    let info = GroupInfo::new(vec![vec![None, Some(\"foo\"), None]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 1);",
          "    let info = GroupInfo::new(vec![vec![Some(\"a\"), Some(\"b\")], vec![Some(\"c\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 4);",
          "    let info = GroupInfo::new(vec![vec![], vec![]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 0);",
          "    let empty_info = GroupInfo::empty();",
          "    assert_eq!(empty_info.explicit_slot_len(), 0);",
          "    let info = GroupInfo::new(vec![vec![Some(\"a\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 2);",
          "    let info = GroupInfo::new(vec![vec![Some(\"x\"), None, Some(\"y\")]]).unwrap();",
          "    assert_eq!(info.explicit_slot_len(), 2);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = GroupInfo::new(vec![vec![None, Some(\"foo\"), Some(\"bar\")]]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(info.slot_len(), 6);",
          "    assert_eq!(info.implicit_slot_len(), 2);",
          "    assert_eq!(info.explicit_slot_len(), 4);",
          "    assert_eq!(info.explicit_slot_len(), info.slot_len().saturating_sub(info.implicit_slot_len()));",
          "    assert_eq!(GroupInfo::empty().explicit_slot_len(), 0);",
          "    assert_eq!(GroupInfo::empty().slot_len(), 0);"
        ],
        "code": [
          "{",
          "    let info = GroupInfo::new(vec![vec![None, Some(\"foo\"), Some(\"bar\")]]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "    assert_eq!(info.slot_len(), 6);",
          "    assert_eq!(info.implicit_slot_len(), 2);",
          "    assert_eq!(info.explicit_slot_len(), 4);",
          "    assert_eq!(info.explicit_slot_len(), info.slot_len().saturating_sub(info.implicit_slot_len()));",
          "    assert_eq!(GroupInfo::empty().explicit_slot_len(), 0);",
          "    assert_eq!(GroupInfo::empty().slot_len(), 0);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = GroupInfo::new(vec![",
          "        vec![Some(\"group1\"), Some(\"group2\"), None],",
          "        vec![None, Some(\"group3\")]",
          "    ]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(info.slot_len(), 8);",
          "    assert_eq!(info.implicit_slot_len(), 2);",
          "    assert_eq!(info.explicit_slot_len(), 6);"
        ],
        "code": [
          "{",
          "    let info = GroupInfo::new(vec![",
          "        vec![Some(\"group1\"), Some(\"group2\"), None],",
          "        vec![None, Some(\"group3\")]",
          "    ]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "    assert_eq!(info.slot_len(), 8);",
          "    assert_eq!(info.implicit_slot_len(), 2);",
          "    assert_eq!(info.explicit_slot_len(), 6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = GroupInfo::new(vec![",
          "        vec![None, None],",
          "        vec![None]",
          "    ]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(0, info.explicit_slot_len());",
          "    assert_eq!(info.slot_len(), info.implicit_slot_len());"
        ],
        "code": [
          "{",
          "    let info = GroupInfo::new(vec![",
          "        vec![None, None],",
          "        vec![None]",
          "    ]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "    assert_eq!(0, info.explicit_slot_len());",
          "    assert_eq!(info.slot_len(), info.implicit_slot_len());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let info = GroupInfo::new(vec![",
          "        vec![Some(\"a\"), None],",
          "        vec![Some(\"b\"), Some(\"c\"), None],",
          "        vec![None]",
          "    ]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(info.slot_len(), 8);",
          "    assert_eq!(info.implicit_slot_len(), 2);",
          "    assert_eq!(info.explicit_slot_len(), 6);"
        ],
        "code": [
          "{",
          "    let info = GroupInfo::new(vec![",
          "        vec![Some(\"a\"), None],",
          "        vec![Some(\"b\"), Some(\"c\"), None],",
          "        vec![None]",
          "    ]).unwrap();",
          "    let _ = info.explicit_slot_len();",
          "    assert_eq!(info.slot_len(), 8);",
          "    assert_eq!(info.implicit_slot_len(), 2);",
          "    assert_eq!(info.explicit_slot_len(), 6);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]