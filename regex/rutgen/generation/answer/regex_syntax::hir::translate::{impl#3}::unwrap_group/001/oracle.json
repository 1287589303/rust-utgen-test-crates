[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_frame = HirFrame::Expr(hir::Hir {",
          "        kind: hir::HirKind::Empty, ",
          "        props: Default::default()",
          "    });",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    let hir_frame = HirFrame::Expr(hir::Hir { kind: hir::HirKind::Empty, props: Default::default() });",
          "    let result = std::panic::catch_unwind(|| hir_frame.unwrap_group());",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"tried to unwrap group from HirFrame, got: Expr(...)\"));"
        ],
        "code": [
          "{",
          "    let hir_frame = HirFrame::Expr(hir::Hir {",
          "        kind: hir::HirKind::Empty, ",
          "        props: Default::default()",
          "    });",
          "    hir_frame.unwrap_group();",
          "    let hir_frame = HirFrame::Expr(hir::Hir { kind: hir::HirKind::Empty, props: Default::default() });",
          "    let result = std::panic::catch_unwind(|| hir_frame.unwrap_group());",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"tried to unwrap group from HirFrame, got: Expr(...)\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_frame = HirFrame::Literal(vec![b'a', b'b', b'c']);",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(panic_or_return(unwrap_group(hir_frame)), \"tried to unwrap group from HirFrame, got: Literal([97, 98, 99])\");",
          "    assert!(std::panic::catch_unwind(|| { hir_frame.unwrap_group(); }).is_err());",
          "    assert!(matches!(hir_frame, HirFrame::Literal(_)));"
        ],
        "code": [
          "{",
          "    let hir_frame = HirFrame::Literal(vec![b'a', b'b', b'c']);",
          "    hir_frame.unwrap_group();",
          "    assert_eq!(panic_or_return(unwrap_group(hir_frame)), \"tried to unwrap group from HirFrame, got: Literal([97, 98, 99])\");",
          "    assert!(std::panic::catch_unwind(|| { hir_frame.unwrap_group(); }).is_err());",
          "    assert!(matches!(hir_frame, HirFrame::Literal(_)));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_unicode = hir::ClassUnicode {",
          "        set: Default::default(),",
          "        negated: false,",
          "        span: Default::default(),",
          "    };",
          "    let hir_frame = HirFrame::ClassUnicode(class_unicode);",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(std::panic::catch_unwind(|| {",
          "    let class_unicode = hir::ClassUnicode {",
          "    set: Default::default(),",
          "    negated: false,",
          "    span: Default::default(),",
          "    };",
          "    let hir_frame = HirFrame::ClassUnicode(class_unicode);",
          "    hir_frame.unwrap_group();",
          "    }).is_err(), true);"
        ],
        "code": [
          "{",
          "    let class_unicode = hir::ClassUnicode {",
          "        set: Default::default(),",
          "        negated: false,",
          "        span: Default::default(),",
          "    };",
          "    let hir_frame = HirFrame::ClassUnicode(class_unicode);",
          "    hir_frame.unwrap_group();",
          "    assert_eq!(std::panic::catch_unwind(|| {",
          "    let class_unicode = hir::ClassUnicode {",
          "    set: Default::default(),",
          "    negated: false,",
          "    span: Default::default(),",
          "    };",
          "    let hir_frame = HirFrame::ClassUnicode(class_unicode);",
          "    hir_frame.unwrap_group();",
          "    }).is_err(), true);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let class_bytes = hir::ClassBytes {",
          "        set: Default::default(),",
          "    };",
          "    let hir_frame = HirFrame::ClassBytes(class_bytes);",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(panic::catch_unwind(|| { hir_frame.unwrap_group(); }).is_err(), true);",
          "    assert_eq!(panic::catch_unwind(|| { hir_frame.unwrap_group(); }).unwrap_err().is_some(), true);",
          "    assert_eq!(format!(\"{:?}\", panic::catch_unwind(|| { hir_frame.unwrap_group(); }).unwrap_err()), \"tried to unwrap group from HirFrame, got: ClassBytes(...)\");",
          "    assert!(matches!(hir_frame, HirFrame::ClassBytes(_)));",
          "    assert!(!matches!(hir_frame, HirFrame::Group { .. }));"
        ],
        "code": [
          "{",
          "    let class_bytes = hir::ClassBytes {",
          "        set: Default::default(),",
          "    };",
          "    let hir_frame = HirFrame::ClassBytes(class_bytes);",
          "    hir_frame.unwrap_group();",
          "    assert_eq!(panic::catch_unwind(|| { hir_frame.unwrap_group(); }).is_err(), true);",
          "    assert_eq!(panic::catch_unwind(|| { hir_frame.unwrap_group(); }).unwrap_err().is_some(), true);",
          "    assert_eq!(format!(\"{:?}\", panic::catch_unwind(|| { hir_frame.unwrap_group(); }).unwrap_err()), \"tried to unwrap group from HirFrame, got: ClassBytes(...)\");",
          "    assert!(matches!(hir_frame, HirFrame::ClassBytes(_)));",
          "    assert!(!matches!(hir_frame, HirFrame::Group { .. }));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_frame = HirFrame::Repetition;",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert!(std::panic::catch_unwind(|| {",
          "    let hir_frame = HirFrame::Repetition;",
          "    hir_frame.unwrap_group();",
          "    }).is_err());"
        ],
        "code": [
          "{",
          "    let hir_frame = HirFrame::Repetition;",
          "    hir_frame.unwrap_group();",
          "    assert!(std::panic::catch_unwind(|| {",
          "    let hir_frame = HirFrame::Repetition;",
          "    hir_frame.unwrap_group();",
          "    }).is_err());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_frame = HirFrame::Concat;",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    assert_eq!(std::panic::catch_unwind(|| HirFrame::Concat.unwrap_group()).is_err(), true);",
          "    assert!(std::panic::catch_unwind(|| HirFrame::Concat.unwrap_group()).is_err());",
          "    assert!(std::panic::catch_unwind(|| HirFrame::Group { old_flags: Flags::default() }.unwrap_group()).is_err() == false);",
          "    assert!(std::panic::catch_unwind(|| {",
          "    let frame = HirFrame::Group { old_flags: Flags::default() };",
          "    frame.unwrap_group() == frame.unwrap_group()",
          "    }).is_err() == false);",
          "    assert!(std::panic::catch_unwind(|| HirFrame::Group { old_flags: Flags::default() }.unwrap_group() == Flags::default()).is_err() == false);"
        ],
        "code": [
          "{",
          "    let hir_frame = HirFrame::Concat;",
          "    hir_frame.unwrap_group();",
          "    assert_eq!(std::panic::catch_unwind(|| HirFrame::Concat.unwrap_group()).is_err(), true);",
          "    assert!(std::panic::catch_unwind(|| HirFrame::Concat.unwrap_group()).is_err());",
          "    assert!(std::panic::catch_unwind(|| HirFrame::Group { old_flags: Flags::default() }.unwrap_group()).is_err() == false);",
          "    assert!(std::panic::catch_unwind(|| {",
          "    let frame = HirFrame::Group { old_flags: Flags::default() };",
          "    frame.unwrap_group() == frame.unwrap_group()",
          "    }).is_err() == false);",
          "    assert!(std::panic::catch_unwind(|| HirFrame::Group { old_flags: Flags::default() }.unwrap_group() == Flags::default()).is_err() == false);",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_frame = HirFrame::Alternation;",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    let hir_frame = HirFrame::Group { old_flags: Flags::default() }; assert_eq!(hir_frame.unwrap_group(), Flags::default());",
          "    let hir_frame = HirFrame::Concat; assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::ClassUnicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::default() }); assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::Literal(vec![b'a']); assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::Repetition; assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::Group { old_flags: Flags::default() }; assert_eq!(hir_frame.unwrap_group(), Flags::default());"
        ],
        "code": [
          "{",
          "    let hir_frame = HirFrame::Alternation;",
          "    hir_frame.unwrap_group();",
          "    let hir_frame = HirFrame::Group { old_flags: Flags::default() }; assert_eq!(hir_frame.unwrap_group(), Flags::default());",
          "    let hir_frame = HirFrame::Concat; assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::ClassUnicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::default() }); assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::Literal(vec![b'a']); assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::Repetition; assert!(std::panic::catch_unwind(|| hir_frame.unwrap_group()).is_err());",
          "    let hir_frame = HirFrame::Group { old_flags: Flags::default() }; assert_eq!(hir_frame.unwrap_group(), Flags::default());",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let hir_frame = HirFrame::AlternationBranch;",
          "    hir_frame.unwrap_group();",
          "}"
        ],
        "oracle": [
          "    let hir_frame = HirFrame::AlternationBranch;",
          "    let result = std::panic::catch_unwind(|| hir_frame.unwrap_group());",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"tried to unwrap group from HirFrame, got: AlternationBranch\"));"
        ],
        "code": [
          "{",
          "    let hir_frame = HirFrame::AlternationBranch;",
          "    hir_frame.unwrap_group();",
          "    let hir_frame = HirFrame::AlternationBranch;",
          "    let result = std::panic::catch_unwind(|| hir_frame.unwrap_group());",
          "    assert!(result.is_err());",
          "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), Some(&\"tried to unwrap group from HirFrame, got: AlternationBranch\"));",
          "}"
        ],
        "can_compile": false,
        "repaired": false
      }
    ]
  }
]